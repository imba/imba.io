/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		__webpack_require__(1);
		
		// need to use webpack for this include to work as intended
		Scrimbla = __webpack_require__(14);
		
		var App = __webpack_require__(57).App;
		APP = new App();
		APP.schedule();
		
		__webpack_require__(59);
		
		// awaken pages etc
		q$('._page').map(function(el) { return el; });
		return q$('.awaken').map(function(el) { return el; });
	
	})()

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		if (typeof Imba === 'undefined') {
			__webpack_require__(2);
			
			Imba.CLIENT = true;
			
			__webpack_require__(3);
			__webpack_require__(4);
			__webpack_require__(5);
			__webpack_require__(6);
			__webpack_require__(7);
			__webpack_require__(8);
			__webpack_require__(9);
			__webpack_require__(10);
			__webpack_require__(11);
			__webpack_require__(12);
			return __webpack_require__(13);
		} else {
			return console.warn("Imba is already loaded");
		};
	
	})()

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		// externs;
		
		if (true) {
			global = window;
		};
		
		/*
		Imba is the namespace for all runtime related utilities
		@namespace
		*/
		
		Imba = {
			VERSION: '0.14.1',
			DEBUG: false
		};
		
		var reg = /-./g;
		
		/*
		True if running in client environment.
		@return {bool}
		*/
		
		Imba.isClient = function (){
			return Imba.CLIENT === true;
		};
		
		/*
		True if running in server environment.
		@return {bool}
		*/
		
		Imba.isServer = function (){
			return (false) === true;
		};
		
		Imba.subclass = function (obj,sup){
			;
			for (var k in sup){
				if (sup.hasOwnProperty(k)) { obj[k] = sup[k] };
			};
			
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
			return obj;
		};
		
		/*
		Lightweight method for making an object iterable in imbas for/in loops.
		If the compiler cannot say for certain that a target in a for loop is an
		array, it will cache the iterable version before looping.
		
		```imba
		# this is the whole method
		def Imba.iterable o
			return o ? (o:toArray ? o.toArray : o) : []
		
		class CustomIterable
			def toArray
				[1,2,3]
		
		# will return [2,4,6]
		for x in CustomIterable.new
			x * 2
		
		```
		*/
		
		Imba.iterable = function (o){
			return o ? ((o.toArray ? (o.toArray()) : (o))) : ([]);
		};
		
		/*
		Coerces a value into a promise. If value is array it will
		call `Promise.all(value)`, or if it is not a promise it will
		wrap the value in `Promise.resolve(value)`. Used for experimental
		await syntax.
		@return {Promise}
		*/
		
		Imba.await = function (value){
			if (value instanceof Array) {
				return Promise.all(value);
			} else if (value && value.then) {
				return value;
			} else {
				return Promise.resolve(value);
			};
		};
		
		Imba.toCamelCase = function (str){
			return str.replace(reg,function(m) { return m.charAt(1).toUpperCase(); });
		};
		
		Imba.toCamelCase = function (str){
			return str.replace(reg,function(m) { return m.charAt(1).toUpperCase(); });
		};
		
		Imba.indexOf = function (a,b){
			return (b && b.indexOf) ? (b.indexOf(a)) : ([].indexOf.call(a,b));
		};
		
		Imba.prop = function (scope,name,opts){
			if (scope.defineProperty) {
				return scope.defineProperty(name,opts);
			};
			return;
		};
		
		return Imba.attr = function (scope,name,opts){
			if (scope.defineAttribute) {
				return scope.defineAttribute(name,opts);
			};
			
			var getName = Imba.toCamelCase(name);
			var setName = Imba.toCamelCase('set-' + name);
			
			scope.prototype[getName] = function() {
				return this.getAttribute(name);
			};
			
			scope.prototype[setName] = function(value) {
				this.setAttribute(name,value);
				return this;
			};
			
			return;
		};
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	(function(){
		
		
		function emit__(event,args,node){
			// var node = cbs[event]
			var prev,cb,ret;
			
			while ((prev = node) && (node = node.next)){
				if (cb = node.listener) {
					if (node.path && cb[node.path]) {
						ret = args ? (cb[node.path].apply(cb,args)) : (cb[node.path]());
					} else {
						// check if it is a method?
						ret = args ? (cb.apply(node,args)) : (cb.call(node));
					};
				};
				
				if (node.times && --node.times <= 0) {
					prev.next = node.next;
					node.listener = null;
				};
			};
			return;
		};
		
		// method for registering a listener on object
		Imba.listen = function (obj,event,listener,path){
			var $1;
			var cbs,list,tail;
			cbs = obj.__listeners__ || (obj.__listeners__ = {});
			list = cbs[($1 = event)] || (cbs[$1] = {});
			tail = list.tail || (list.tail = (list.next = {}));
			tail.listener = listener;
			tail.path = path;
			list.tail = tail.next = {};
			return tail;
		};
		
		Imba.once = function (obj,event,listener){
			var tail = Imba.listen(obj,event,listener);
			tail.times = 1;
			return tail;
		};
		
		Imba.unlisten = function (obj,event,cb,meth){
			var node,prev;
			var meta = obj.__listeners__;
			if (!meta) { return };
			
			if (node = meta[event]) {
				while ((prev = node) && (node = node.next)){
					if (node == cb || node.listener == cb) {
						prev.next = node.next;
						// check for correct path as well?
						node.listener = null;
						break;
					};
				};
			};
			return;
		};
		
		Imba.emit = function (obj,event,params){
			var cb;
			if (cb = obj.__listeners__) {
				if (cb[event]) { emit__(event,params,cb[event]) };
				if (cb.all) { emit__(event,[event,params],cb.all) }; // and event != 'all'
			};
			return;
		};
		
		return Imba.observeProperty = function (observer,key,trigger,target,prev){
			if (prev && typeof prev == 'object') {
				Imba.unlisten(prev,'all',observer,trigger);
			};
			if (target && typeof target == 'object') {
				Imba.listen(target,'all',observer,trigger);
			};
			return this;
		};
	
	})()

/***/ },
/* 4 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		
		var raf; // very simple raf polyfill
		raf || (raf = global.requestAnimationFrame);
		raf || (raf = global.webkitRequestAnimationFrame);
		raf || (raf = global.mozRequestAnimationFrame);
		raf || (raf = function(blk) { return setTimeout(blk,1000 / 60); });
		
		Imba.tick = function (d){
			if (this._scheduled) { raf(Imba.ticker()) };
			this.emit(this,'tick',[d]);
			return;
		};
		
		Imba.ticker = function (){
			var self = this;
			return self._ticker || (self._ticker = function(e) { return self.tick(e); });
		};
		
		/*
		
		Global alternative to requestAnimationFrame. Schedule a target
		to tick every frame. You can specify which method to call on the
		target (defaults to tick).
		
		*/
		
		Imba.schedule = function (target,method){
			if(method === undefined) method = 'tick';
			this.listen(this,'tick',target,method);
			// start scheduling now if this was the first one
			if (!this._scheduled) {
				this._scheduled = true;
				raf(Imba.ticker());
			};
			return this;
		};
		
		/*
		
		Unschedule a previously scheduled target
		
		*/
		
		Imba.unschedule = function (target,method){
			this.unlisten(this,'tick',target,method);
			var cbs = this.__listeners__ || (this.__listeners__ = {});
			if (!cbs.tick || !cbs.tick.next || !cbs.tick.next.listener) {
				this._scheduled = false;
			};
			return this;
		};
		
		/*
		
		Light wrapper around native setTimeout that expects the block / function
		as last argument (instead of first). It also triggers an event to Imba
		after the timeout to let schedulers update (to rerender etc) afterwards.
		
		*/
		
		Imba.setTimeout = function (delay,block){
			return setTimeout(function() {
				block();
				return Imba.emit(Imba,'timeout',[block]);
			},delay);
		};
		
		/*
		
		Light wrapper around native setInterval that expects the block / function
		as last argument (instead of first). It also triggers an event to Imba
		after every interval to let schedulers update (to rerender etc) afterwards.
		
		*/
		
		Imba.setInterval = function (interval,block){
			return setInterval(function() {
				block();
				return Imba.emit(Imba,'interval',[block]);
			},interval);
		};
		
		/*
		Clear interval with specified id
		*/
		
		Imba.clearInterval = function (interval){
			return clearInterval(interval);
		};
		
		/*
		Clear timeout with specified id
		*/
		
		Imba.clearTimeout = function (timeout){
			return clearTimeout(timeout);
		};
		
		// should add an Imba.run / setImmediate that
		// pushes listener onto the tick-queue with times - once
		
		
		/*
		
		Instances of Imba.Scheduler manages when to call `tick()` on their target,
		at a specified framerate or when certain events occur. Root-nodes in your
		applications will usually have a scheduler to make sure they rerender when
		something changes. It is also possible to make inner components use their
		own schedulers to control when they render.
		
		@iname scheduler
		
		*/
		
		Imba.Scheduler = function Scheduler(target){
			var self = this;
			self._target = target;
			self._marked = false;
			self._active = false;
			self._marker = function() { return self.mark(); };
			self._ticker = function(e) { return self.tick(e); };
			
			self._events = true;
			self._fps = 1;
			
			self._dt = 0;
			self._timestamp = 0;
			self._ticks = 0;
			self._flushes = 0;
		};
		
		/*
			Create a new Imba.Scheduler for specified target
			@return {Imba.Scheduler}
			*/
		
		/*
			Check whether the current scheduler is active or not
			@return {bool}
			*/
		
		Imba.Scheduler.prototype.active = function (){
			return this._active;
		};
		
		/*
			Delta time between the two last ticks
			@return {Number}
			*/
		
		Imba.Scheduler.prototype.dt = function (){
			return this._dt;
		};
		
		/*
			Delta time between the two last ticks
			@return {Number}
			*/
		
		Imba.Scheduler.prototype.configure = function (pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var fps = pars.fps !== undefined ? pars.fps : 1;
			var events = pars.events !== undefined ? pars.events : true;
			if (events != null) { this._events = events };
			if (fps != null) { this._fps = fps };
			return this;
		};
		
		// def reschedule
		// 	raf(@ticker)
		// 	self
		
		/*
			Mark the scheduler as dirty. This will make sure that
			the scheduler calls `target.tick` on the next frame
			@return {self}
			*/
		
		Imba.Scheduler.prototype.mark = function (){
			this._marked = true;
			return this;
		};
		
		/*
			Instantly trigger target.tick and mark scheduler as clean (not dirty/marked).
			This is called implicitly from tick, but can also be called manually if you
			really want to force a tick without waiting for the next frame.
			@return {self}
			*/
		
		Imba.Scheduler.prototype.flush = function (){
			this._marked = false;
			this._flushes++;
			this._target.tick();
			return this;
		};
		
		/*
			@fixme this expects raf to run at 60 fps 
		
			Called automatically on every frame while the scheduler is active.
			It will only call `target.tick` if the scheduler is marked dirty,
			or when according to @fps setting.
		
			If you have set up a scheduler with an fps of 1, tick will still be
			called every frame, but `target.tick` will only be called once every
			second, and it will *make sure* each `target.tick` happens in separate
			seconds according to Date. So if you have a node that renders a clock
			based on Date.now (or something similar), you can schedule it with 1fps,
			never needing to worry about two ticks happening within the same second.
			The same goes for 4fps, 10fps etc.
		
			@protected
			@return {self}
			*/
		
		Imba.Scheduler.prototype.tick = function (delta){
			this._ticks++;
			this._dt = delta;
			
			var fps = this._fps;
			
			if (fps == 60) {
				this._marked = true;
			} else if (fps == 30) {
				if (this._ticks % 2) { this._marked = true };
			} else if (fps) {
				// if it is less round - we trigger based
				// on date, for consistent rendering.
				// ie, if you want to render every second
				// it is important that no two renders
				// happen during the same second (according to Date)
				var period = ((60 / fps) / 60) * 1000;
				var beat = Math.floor(Date.now() / period);
				
				if (this._beat != beat) {
					this._beat = beat;
					this._marked = true;
				};
			};
			
			if (this._marked) this.flush();
			// reschedule if @active
			return this;
		};
		
		/*
			Start the scheduler if it is not already active.
			**While active**, the scheduler will override `target.commit`
			to do nothing. By default Imba.tag#commit calls render, so
			that rendering is cascaded through to children when rendering
			a node. When a scheduler is active (for a node), Imba disables
			this automatic rendering.
			*/
		
		Imba.Scheduler.prototype.activate = function (){
			if (!this._active) {
				this._active = true;
				// override target#commit while this is active
				this._commit = this._target.commit;
				this._target.commit = function() { return this; };
				Imba.schedule(this);
				if (this._events) { Imba.listen(Imba,'event',this,'onevent') };
				this._target && this._target.flag  &&  this._target.flag('scheduled_');
				this.tick(0); // start ticking
			};
			return this;
		};
		
		/*
			Stop the scheduler if it is active.
			*/
		
		Imba.Scheduler.prototype.deactivate = function (){
			if (this._active) {
				this._active = false;
				this._target.commit = this._commit;
				Imba.unschedule(this);
				Imba.unlisten(Imba,'event',this);
				this._target && this._target.unflag  &&  this._target.unflag('scheduled_');
			};
			return this;
		};
		
		Imba.Scheduler.prototype.track = function (){
			return this._marker;
		};
		
		Imba.Scheduler.prototype.onevent = function (event){
			var $1;
			if (this._marked) { return this };
			
			if (this._events instanceof Function) {
				if (this._events(event)) this.mark();
			} else if (this._events instanceof Array) {
				if (idx$(($1 = event) && $1.type  &&  $1.type(),this._events) >= 0) this.mark();
			} else if (this._events) {
				if (event._responder) this.mark();
			};
			return this;
		};
		return Imba.Scheduler;
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		Imba.static = function (items,nr){
			items.static = nr;
			return items;
		};
		
		/*
		This is the baseclass that all tags in imba inherit from.
		@iname node
		*/
		
		Imba.Tag = function Tag(dom){
			this.setDom(dom);
		};
		
		Imba.Tag.createNode = function (){
			throw "Not implemented";
		};
		
		Imba.Tag.build = function (){
			return new this(this.createNode());
		};
		
		
		
		Imba.Tag.prototype.object = function(v){ return this._object; }
		Imba.Tag.prototype.setObject = function(v){ this._object = v; return this; };
		
		Imba.Tag.prototype.dom = function (){
			return this._dom;
		};
		
		Imba.Tag.prototype.setDom = function (dom){
			dom._tag = this;
			this._dom = dom;
			return this;
		};
		
		/*
			Setting references for tags like
			`<div@header>` will compile to `tag('div').setRef('header',this).end()`
			By default it adds the reference as a className to the tag.
			@return {self}
			*/
		
		Imba.Tag.prototype.setRef = function (ref,ctx){
			this.flag(this._ref = ref);
			return this;
		};
		
		/*
			Method that is called by the compiled tag-chains, for
			binding events on tags to methods etc.
			`<a :tap=fn>` compiles to `tag('a').setHandler('tap',fn,this).end()`
			where this refers to the context in which the tag is created.
			@return {self}
			*/
		
		Imba.Tag.prototype.setHandler = function (event,handler,ctx){
			var key = 'on' + event;
			
			if (handler instanceof Function) {
				this[key] = handler;
			} else if (handler instanceof Array) {
				var fn = handler.shift();
				this[key] = function(e) { return ctx[fn].apply(ctx,handler.concat(e)); };
			} else {
				this[key] = function(e) { return ctx[handler](e); };
			};
			return this;
		};
		
		Imba.Tag.prototype.setId = function (id){
			this.dom().id = id;
			return this;
		};
		
		Imba.Tag.prototype.id = function (){
			return this.dom().id;
		};
		
		/*
			Adds a new attribute or changes the value of an existing attribute
			on the specified tag. If the value is null or false, the attribute
			will be removed.
			@return {self}
			*/
		
		Imba.Tag.prototype.setAttribute = function (name,value){
			// should this not return self?
			var old = this.dom().getAttribute(name);
			
			if (old == value) {
				return value;
			} else if (value != null && value !== false) {
				return this.dom().setAttribute(name,value);
			} else {
				return this.dom().removeAttribute(name);
			};
		};
		
		/*
			removes an attribute from the specified tag
			*/
		
		Imba.Tag.prototype.removeAttribute = function (name){
			return this.dom().removeAttribute(name);
		};
		
		/*
			returns the value of an attribute on the tag.
			If the given attribute does not exist, the value returned
			will either be null or "" (the empty string)
			*/
		
		Imba.Tag.prototype.getAttribute = function (name){
			return this.dom().getAttribute(name);
		};
		
		/*
			Override this to provide special wrapping etc.
			@return {self}
			*/
		
		Imba.Tag.prototype.setContent = function (content,type){
			this.setChildren(content,type);
			return this;
		};
		
		/*
			Set the children of node. type param is optional,
			and should only be used by Imba when compiling tag trees. 
			@return {self}
			*/
		
		Imba.Tag.prototype.setChildren = function (nodes,type){
			throw "Not implemented";
		};
		
		/*
			Get text of node. Uses textContent behind the scenes (not innerText)
			[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()
			@return {string} inner text of node
			*/
		
		Imba.Tag.prototype.text = function (v){
			return this._dom.textContent;
		};
		
		/*
			Set text of node. Uses textContent behind the scenes (not innerText)
			[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()
			*/
		
		Imba.Tag.prototype.setText = function (txt){
			this._empty = false;
			this._dom.textContent = txt == null ? (txt = "") : (txt);
			return this;
		};
		
		
		/*
			Method for getting and setting data-attributes. When called with zero
			arguments it will return the actual dataset for the tag.
		
				var node = <div data-name='hello'>
				# get the whole dataset
				node.dataset # {name: 'hello'}
				# get a single value
				node.dataset('name') # 'hello'
				# set a single value
				node.dataset('name','newname') # self
		
		
			*/
		
		Imba.Tag.prototype.dataset = function (key,val){
			throw "Not implemented";
		};
		
		/*
			Empty placeholder. Override to implement custom render behaviour.
			Works much like the familiar render-method in React.
			@return {self}
			*/
		
		Imba.Tag.prototype.render = function (){
			return this;
		};
		
		/*
			Called implicitly through Imba.Tag#end, upon creating a tag. All
			properties will have been set before build is called, including
			setContent.
			@return {self}
			*/
		
		Imba.Tag.prototype.build = function (){
			this.render();
			return this;
		};
		
		/*
			Called implicitly through Imba.Tag#end, for tags that are part of
			a tag tree (that are rendered several times).
			@return {self}
			*/
		
		Imba.Tag.prototype.commit = function (){
			this.render();
			return this;
		};
		
		/*
		
			Called by the tag-scheduler (if this tag is scheduled)
			By default it will call this.render. Do not override unless
			you really understand it.
		
			*/
		
		Imba.Tag.prototype.tick = function (){
			this.render();
			return this;
		};
		
		/*
			
			A very important method that you will practically never manually.
			The tag syntax of Imba compiles to a chain of setters, which always
			ends with .end. `<a.large>` compiles to `tag('a').flag('large').end()`
			
			You are highly adviced to not override its behaviour. The first time
			end is called it will mark the tag as built and call Imba.Tag#build,
			and call Imba.Tag#commit on subsequent calls.
			@return {self}
			*/
		
		Imba.Tag.prototype.end = function (){
			if (this._built) {
				this.commit();
			} else {
				this._built = true;
				this.build();
			};
			return this;
		};
		
		/*
			This is called instead of Imba.Tag#end for `<self>` tag chains.
			Defaults to noop
			@return {self}
			*/
		
		Imba.Tag.prototype.synced = function (){
			return this;
		};
		
		// called when the node is awakened in the dom - either automatically
		// upon attachment to the dom-tree, or the first time imba needs the
		// tag for a domnode that has been rendered on the server
		Imba.Tag.prototype.awaken = function (){
			return this;
		};
		
		/*
			List of flags for this node. 
			*/
		
		Imba.Tag.prototype.flags = function (){
			return this._dom.classList;
		};
		
		/*
			Add speficied flag to current node.
			If a second argument is supplied, it will be coerced into a Boolean,
			and used to indicate whether we should remove the flag instead.
			@return {self}
			*/
		
		Imba.Tag.prototype.flag = function (name,toggler){
			// it is most natural to treat a second undefined argument as a no-switch
			// so we need to check the arguments-length
			if (arguments.length == 2 && !toggler) {
				this._dom.classList.remove(name);
			} else {
				this._dom.classList.add(name);
			};
			return this;
		};
		
		/*
			Remove specified flag from node
			@return {self}
			*/
		
		Imba.Tag.prototype.unflag = function (name){
			this._dom.classList.remove(name);
			return this;
		};
		
		/*
			Toggle specified flag on node
			@return {self}
			*/
		
		Imba.Tag.prototype.toggleFlag = function (name){
			this._dom.classList.toggle(name);
			return this;
		};
		
		/*
			Check whether current node has specified flag
			@return {bool}
			*/
		
		Imba.Tag.prototype.hasFlag = function (name){
			return this._dom.classList.contains(name);
		};
		
		/*
			Get the scheduler for this node. A new scheduler will be created
			if it does not already exist.
		
			@return {Imba.Scheduler}
			*/
		
		Imba.Tag.prototype.scheduler = function (){
			return this._scheduler == null ? (this._scheduler = new Imba.Scheduler(this)) : (this._scheduler);
		};
		
		/*
		
			Shorthand to start scheduling a node. The method will basically
			proxy the arguments through to scheduler.configure, and then
			activate the scheduler.
			
			@return {self}
			*/
		
		Imba.Tag.prototype.schedule = function (options){
			if(options === undefined) options = {};
			this.scheduler().configure(options).activate();
			return this;
		};
		
		/*
			Shorthand for deactivating scheduler (if tag has one).
			@deprecated
			*/
		
		Imba.Tag.prototype.unschedule = function (){
			if (this._scheduler) { this.scheduler().deactivate() };
			return this;
		};
		
		
		/*
			Get the parent of current node
			@return {Imba.Tag} 
			*/
		
		Imba.Tag.prototype.parent = function (){
			return tag$wrap(this.dom().parentNode);
		};
		
		/*
			Shorthand for console.log on elements
			@return {self}
			*/
		
		Imba.Tag.prototype.log = function (){
			var $0 = arguments, i = $0.length;
			var args = new Array(i>0 ? i : 0);
			while(i>0) args[i-1] = $0[--i];
			args.unshift(console);
			Function.prototype.call.apply(console.log,args);
			return this;
		};
		
		
		Imba.Tag.prototype.initialize = Imba.Tag;
		
		HTML_TAGS = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");
		HTML_TAGS_UNSAFE = "article aside header section".split(" ");
		SVG_TAGS = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
		
		
		function extender(obj,sup){
			for (var i = 0, keys = Object.keys(sup), l = keys.length; i < l; i++){
				obj[($1 = keys[i])] == null ? (obj[$1] = sup[keys[i]]) : (obj[$1]);
			};
			
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
			if (sup.inherit) { sup.inherit(obj) };
			return obj;
		};
		
		function Tag(){
			return function(dom) {
				this.setDom(dom);
				return this;
			};
		};
		
		function TagSpawner(type){
			return function() { return type.build(); };
		};
		
		Imba.Tags = function Tags(){
			this;
		};
		
		Imba.Tags.prototype.__clone = function (ns){
			var clone = Object.create(this);
			clone._parent = this;
			return clone;
		};
		
		Imba.Tags.prototype.defineNamespace = function (name){
			var clone = Object.create(this);
			clone._parent = this;
			clone._ns = name;
			this[name.toUpperCase()] = clone;
			return clone;
		};
		
		Imba.Tags.prototype.baseType = function (name){
			return idx$(name,HTML_TAGS) >= 0 ? ('htmlelement') : ('div');
		};
		
		Imba.Tags.prototype.defineTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			supr || (supr = this.baseType(name));
			var supertype = this[supr];
			var tagtype = Tag();
			var norm = name.replace(/\-/g,'_');
			
			
			tagtype._name = name;
			extender(tagtype,supertype);
			
			if (name[0] == '#') {
				this[name] = tagtype;
				Imba.SINGLETONS[name.slice(1)] = tagtype;
			} else {
				this[name] = tagtype;
				this['$' + norm] = TagSpawner(tagtype);
			};
			
			if (body) {
				if (body.length == 2) {
					// create clone
					if (!tagtype.hasOwnProperty('TAGS')) {
						tagtype.TAGS = (supertype.TAGS || this).__clone();
					};
				};
				
				body.call(tagtype,tagtype,tagtype.TAGS || this);
			};
			
			return tagtype;
		};
		
		Imba.Tags.prototype.defineSingleton = function (name,supr,body){
			return this.defineTag(name,supr,body);
		};
		
		Imba.Tags.prototype.extendTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			var klass = ((typeof name=='string'||name instanceof String) ? (this[name]) : (name));
			// allow for private tags here as well?
			if (body) { body && body.call(klass,klass,klass.prototype) };
			return klass;
		};
		
		
		Imba.TAGS = new Imba.Tags();
		Imba.TAGS.element = Imba.Tag;
		
		var svg = Imba.TAGS.defineNamespace('svg');
		
		svg.baseType = function (name){
			return 'svgelement';
		};
		
		
		Imba.SINGLETONS = {};
		
		
		Imba.defineTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			return Imba.TAGS.defineTag(name,supr,body);
		};
		
		Imba.defineSingletonTag = function (id,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = 'div';
			if(supr==undefined) supr = 'div';
			return Imba.TAGS.defineTag(this.name(),supr,body);
		};
		
		Imba.extendTag = function (name,body){
			return Imba.TAGS.extendTag(name,body);
		};
		
		Imba.tag = function (name){
			var typ = Imba.TAGS[name];
			if (!typ) { throw new Error(("tag " + name + " is not defined")) };
			return new typ(typ.createNode());
		};
		
		Imba.tagWithId = function (name,id){
			var typ = Imba.TAGS[name];
			if (!typ) { throw new Error(("tag " + name + " is not defined")) };
			var dom = typ.createNode();
			dom.id = id;
			return new typ(dom);
		};
		
		// TODO: Can we move these out and into dom.imba in a clean way?
		// These methods depends on Imba.document.getElementById
		
		Imba.getTagSingleton = function (id){
			var klass;
			var dom,node;
			
			if (klass = Imba.SINGLETONS[id]) {
				if (klass && klass.Instance) { return klass.Instance };
				
				// no instance - check for element
				if (dom = Imba.document().getElementById(id)) {
					// we have a live instance - when finding it through a selector we should awake it, no?
					// console.log('creating the singleton from existing node in dom?',id,type)
					node = klass.Instance = new klass(dom);
					node.awaken(dom); // should only awaken
					return node;
				};
				
				dom = klass.createNode();
				dom.id = id;
				node = klass.Instance = new klass(dom);
				node.end().awaken(dom);
				return node;
			} else if (dom = Imba.document().getElementById(id)) {
				return Imba.getTagForDom(dom);
			};
		};
		
		var svgSupport = typeof SVGElement !== 'undefined';
		
		Imba.getTagForDom = function (dom){
			var m;
			if (!dom) { return null };
			if (dom._dom) { return dom }; // could use inheritance instead
			if (dom._tag) { return dom._tag };
			if (!dom.nodeName) { return null };
			
			var ns = null;
			var id = dom.id;
			var type = dom.nodeName.toLowerCase();
			var tags = Imba.TAGS;
			var native$ = type;
			var cls = dom.className;
			
			if (id && Imba.SINGLETONS[id]) {
				// FIXME control that it is the same singleton?
				// might collide -- not good?
				return Imba.getTagSingleton(id);
			};
			// look for id - singleton
			
			// need better test here
			if (svgSupport && (dom instanceof SVGElement)) {
				ns = "svg";
				cls = dom.className.baseVal;
				tags = tags.SVG;
			};
			
			var spawner;
			
			if (cls) {
				// there can be several matches here - should choose the last
				// should fall back to less specific later? - otherwise things may fail
				// TODO rework this
				if (m = cls.match(/\b_([a-z\-]+)\b(?!\s*_[a-z\-]+)/)) {
					type = m[1]; // .replace(/-/g,'_')
				};
				
				if (m = cls.match(/\b([A-Z\-]+)_\b/)) {
					ns = m[1];
				};
			};
			
			
			spawner = tags[type] || tags[native$];
			return spawner ? (new spawner(dom).awaken(dom)) : (null);
		};
		
		tag$ = Imba.TAGS;
		t$ = Imba.tag;
		tc$ = Imba.tagWithFlags;
		ti$ = Imba.tagWithId;
		tic$ = Imba.tagWithIdAndFlags;
		id$ = Imba.getTagSingleton;
		return tag$wrap = Imba.getTagForDom;
		
	
	})()

/***/ },
/* 6 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		Imba.document = function (){
			return window.document;
		};
		
		/*
		Returns the body element wrapped in an Imba.Tag
		*/
		
		Imba.root = function (){
			return tag$wrap(Imba.document().body);
		};
		
		tag$.defineTag('htmlelement', 'element', function(tag){
			
			/*
				Called when a tag type is being subclassed.
				*/
			
			tag.inherit = function (child){
				child.prototype._empty = true;
				child._protoDom = null;
				
				if (this._nodeType) {
					child._nodeType = this._nodeType;
					
					var className = "_" + child._name.replace(/_/g,'-');
					if (child._name[0] != '#') { return child._classes = this._classes.concat(className) };
				} else {
					child._nodeType = child._name;
					return child._classes = [];
				};
			};
			
			tag.buildNode = function (){
				var dom = Imba.document().createElement(this._nodeType);
				var cls = this._classes.join(" ");
				if (cls) { dom.className = cls };
				return dom;
			};
			
			tag.createNode = function (){
				var proto = (this._protoDom || (this._protoDom = this.buildNode()));
				return proto.cloneNode(false);
			};
			
			tag.dom = function (){
				return this._protoDom || (this._protoDom = this.buildNode());
			};
			
			
			
			tag.prototype.id = function(v){ return this.getAttribute('id'); }
			tag.prototype.setId = function(v){ this.setAttribute('id',v); return this; };
			
			
			tag.prototype.tabindex = function(v){ return this.getAttribute('tabindex'); }
			tag.prototype.setTabindex = function(v){ this.setAttribute('tabindex',v); return this; };
			
			
			tag.prototype.title = function(v){ return this.getAttribute('title'); }
			tag.prototype.setTitle = function(v){ this.setAttribute('title',v); return this; };
			
			
			tag.prototype.role = function(v){ return this.getAttribute('role'); }
			tag.prototype.setRole = function(v){ this.setAttribute('role',v); return this; };
			
			tag.prototype.width = function (){
				return this._dom.offsetWidth;
			};
			
			tag.prototype.height = function (){
				return this._dom.offsetHeight;
			};
			
			tag.prototype.setChildren = function (nodes,type){
				this._empty ? (this.append(nodes)) : (this.empty().append(nodes));
				this._children = null;
				return this;
			};
			
			/*
				Set inner html of node
				*/
			
			tag.prototype.setHtml = function (html){
				this._dom.innerHTML = html;
				return this;
			};
			
			/*
				Get inner html of node
				*/
			
			tag.prototype.html = function (){
				return this._dom.innerHTML;
			};
			
			/*
				Remove all content inside node
				*/
			
			tag.prototype.empty = function (){
				while (this._dom.firstChild){
					this._dom.removeChild(this._dom.firstChild);
				};
				this._children = null;
				this._empty = true;
				return this;
			};
			
			/*
				Remove specified child from current node.
				*/
			
			tag.prototype.remove = function (child){
				var par = this.dom();
				var el = child && child.dom();
				if (el && el.parentNode == par) { par.removeChild(el) };
				return this;
			};
			
			tag.prototype.emit = function (name,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var data = pars.data !== undefined ? pars.data : null;
				var bubble = pars.bubble !== undefined ? pars.bubble : true;
				Imba.Events.trigger(name,this,{data: data,bubble: bubble});
				return this;
			};
			
			tag.prototype.css = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.css(keys[i],key[keys[i]]);
					};
				} else if (val == null) {
					this.dom().style.removeProperty(key);
				} else if (val == undefined) {
					return this.dom().style[key];
				} else {
					if ((typeof val=='number'||val instanceof Number) && key.match(/width|height|left|right|top|bottom/)) {
						val = val + "px";
					};
					this.dom().style[key] = val;
				};
				return this;
			};
			
			tag.prototype.dataset = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.dataset(keys[i],key[keys[i]]);
					};
					return this;
				};
				
				if (arguments.length == 2) {
					this.setAttribute(("data-" + key),val);
					return this;
				};
				
				if (key) {
					return this.getAttribute(("data-" + key));
				};
				
				var dataset = this.dom().dataset;
				
				if (!dataset) {
					dataset = {};
					for (var i1 = 0, ary = iter$(this.dom().attributes), len = ary.length, atr; i1 < len; i1++) {
						atr = ary[i1];
						if (atr.name.substr(0,5) == 'data-') {
							dataset[Imba.toCamelCase(atr.name.slice(5))] = atr.value;
						};
					};
				};
				
				return dataset;
			};
			
			/*
				Get descendants of current node, optionally matching selector
				@return {Imba.Selector}
				*/
			
			tag.prototype.find = function (sel){
				return new Imba.Selector(sel,this);
			};
			
			/*
				Get the first matching child of node
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.first = function (sel){
				return sel ? (this.find(sel).first()) : (tag$wrap(this.dom().firstElementChild));
			};
			
			/*
				Get the last matching child of node
			
					node.last # returns the last child of node
					node.last %span # returns the last span inside node
					node.last do |el| el.text == 'Hi' # return last node with text Hi
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.last = function (sel){
				return sel ? (this.find(sel).last()) : (tag$wrap(this.dom().lastElementChild));
			};
			
			/*
				Get the child at index
				*/
			
			tag.prototype.child = function (i){
				return tag$wrap(this.dom().children[i || 0]);
			};
			
			tag.prototype.children = function (sel){
				var nodes = new Imba.Selector(null,this,this._dom.children);
				return sel ? (nodes.filter(sel)) : (nodes);
			};
			
			tag.prototype.orphanize = function (){
				var par;
				if (par = this.dom().parentNode) { par.removeChild(this._dom) };
				return this;
			};
			
			tag.prototype.matches = function (sel){
				var fn;
				if (sel instanceof Function) {
					return sel(this);
				};
				
				if (sel.query) { sel = sel.query() };
				if (fn = (this._dom.webkitMatchesSelector || this._dom.matches)) { return fn.call(this._dom,sel) };
				// TODO support other browsers etc?
			};
			
			/*
				Get the first element matching supplied selector / filter
				traversing upwards, but including the node itself.
				@return {Imba.Tag}
				*/
			
			tag.prototype.closest = function (sel){
				if (!sel) { return this.parent() }; // should return self?!
				var node = this;
				if (sel.query) { sel = sel.query() };
				
				while (node){
					if (node.matches(sel)) { return node };
					node = node.parent();
				};
				return null;
			};
			
			/*
				Get the closest ancestor of node that matches
				specified selector / matcher.
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.up = function (sel){
				if (!sel) { return this.parent() };
				return this.parent() && this.parent().closest(sel);
			};
			
			tag.prototype.path = function (sel){
				var node = this;
				var nodes = [];
				if (sel && sel.query) { sel = sel.query() };
				
				while (node){
					if (!sel || node.matches(sel)) { nodes.push(node) };
					node = node.parent();
				};
				return nodes;
			};
			
			tag.prototype.parents = function (sel){
				var par = this.parent();
				return par ? (par.path(sel)) : ([]);
			};
			
			
			
			tag.prototype.siblings = function (sel){
				var par, self = this;
				if (!(par = this.parent())) { return [] }; // FIXME
				var ary = this.dom().parentNode.children;
				var nodes = new Imba.Selector(null,this,ary);
				return nodes.filter(function(n) { return n != self && (!sel || n.matches(sel)); });
			};
			
			/*
				Get the immediately following sibling of node.
				*/
			
			tag.prototype.next = function (sel){
				if (sel) {
					var el = this;
					while (el = el.next()){
						if (el.matches(sel)) { return el };
					};
					return null;
				};
				return tag$wrap(this.dom().nextElementSibling);
			};
			
			/*
				Get the immediately preceeding sibling of node.
				*/
			
			tag.prototype.prev = function (sel){
				if (sel) {
					var el = this;
					while (el = el.prev()){
						if (el.matches(sel)) { return el };
					};
					return null;
				};
				return tag$wrap(this.dom().previousElementSibling);
			};
			
			tag.prototype.contains = function (node){
				return this.dom().contains(node && node._dom || node);
			};
			
			tag.prototype.index = function (){
				var i = 0;
				var el = this.dom();
				while (el.previousSibling){
					el = el.previousSibling;
					i++;
				};
				return i;
			};
			
			
			/*
				
				@deprecated
				*/
			
			tag.prototype.insert = function (node,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var before = pars.before !== undefined ? pars.before : null;
				var after = pars.after !== undefined ? pars.after : null;
				if (after) { before = after.next() };
				if (node instanceof Array) {
					node = (tag$.$fragment().setContent(node,0).end());
				};
				if (before) {
					this.dom().insertBefore(node.dom(),before.dom());
				} else {
					this.append(node);
				};
				return this;
			};
			
			/*
				Focus on current node
				@return {self}
				*/
			
			tag.prototype.focus = function (){
				this.dom().focus();
				return this;
			};
			
			/*
				Remove focus from current node
				@return {self}
				*/
			
			tag.prototype.blur = function (){
				this.dom().blur();
				return this;
			};
			
			tag.prototype.template = function (){
				return null;
			};
			
			/*
				@todo Should support multiple arguments like append
			
				The .prepend method inserts the specified content as the first
				child of the target node. If the content is already a child of 
				node it will be moved to the start.
				
			    	node.prepend <div.top> # prepend node
			    	node.prepend "some text" # prepend text
			    	node.prepend [<ul>,<ul>] # prepend array
			
				*/
			
			tag.prototype.prepend = function (item){
				var first = this._dom.childNodes[0];
				first ? (this.insertBefore(item,first)) : (this.appendChild(item));
				return this;
			};
			
			/*
				The .append method inserts the specified content as the last child
				of the target node. If the content is already a child of node it
				will be moved to the end.
				
				# example
				    var root = <div.root>
				    var item = <div.item> "This is an item"
				    root.append item # appends item to the end of root
			
				    root.prepend "some text" # append text
				    root.prepend [<ul>,<ul>] # append array
				*/
			
			tag.prototype.append = function (item){
				// possible to append blank
				// possible to simplify on server?
				if (!item) { return this };
				
				if (item instanceof Array) {
					for (var i = 0, ary = iter$(item), len = ary.length, member; i < len; i++) {
						member = ary[i];
						member && this.append(member);
					};
				} else if ((typeof item=='string'||item instanceof String) || (typeof item=='number'||item instanceof Number)) {
					var node = Imba.document().createTextNode(item);
					this._dom.appendChild(node);
					if (this._empty) { this._empty = false };
				} else {
					this._dom.appendChild(item._dom || item);
					if (this._empty) { this._empty = false };
				};
				
				return this;
			};
			
			/*
				Insert a node into the current node (self), before another.
				The relative node must be a child of current node. 
				*/
			
			tag.prototype.insertBefore = function (node,rel){
				if ((typeof node=='string'||node instanceof String)) { node = Imba.document().createTextNode(node) };
				if (node && rel) { this.dom().insertBefore((node._dom || node),(rel._dom || rel)) };
				return this;
			};
			
			/*
				Append a single item (node or string) to the current node.
				If supplied item is a string it will automatically. This is used
				by Imba internally, but will practically never be used explicitly.
				*/
			
			tag.prototype.appendChild = function (node){
				if ((typeof node=='string'||node instanceof String)) { node = Imba.document().createTextNode(node) };
				if (node) { this.dom().appendChild(node._dom || node) };
				return this;
			};
			
			/*
				Remove a single child from the current node.
				Used by Imba internally.
				*/
			
			tag.prototype.removeChild = function (node){
				if (node) { this.dom().removeChild(node._dom || node) };
				return this;
			};
			
			tag.prototype.toString = function (){
				return this._dom.toString(); // really?
			};
			
			/*
				@deprecated
				*/
			
			tag.prototype.classes = function (){
				console.log('Imba.Tag#classes is deprecated');
				return this._dom.classList;
			};
		});
		
		return tag$.defineTag('svgelement', 'htmlelement');
	
	})()

/***/ },
/* 7 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// Extending Imba.Tag#css to work without prefixes by inspecting
		// the properties of a CSSStyleDeclaration and creating a map
		
		// var prefixes = ['-webkit-','-ms-','-moz-','-o-','-blink-']
		// var props = ['transform','transition','animation']
		
		var styles = window.getComputedStyle(document.documentElement,'');
		
		Imba.CSSKeyMap = {};
		
		for (var i = 0, ary = iter$(styles), len = ary.length, prefixed; i < len; i++) {
			prefixed = ary[i];
			var unprefixed = prefixed.replace(/^-(webkit|ms|moz|o|blink)-/,'');
			var camelCase = unprefixed.replace(/-(\w)/g,function(m,a) { return a.toUpperCase(); });
			
			// if there exists an unprefixed version -- always use this
			if (prefixed != unprefixed) {
				if (styles.hasOwnProperty(unprefixed)) { continue; };
			};
			
			// register the prefixes
			Imba.CSSKeyMap[unprefixed] = Imba.CSSKeyMap[camelCase] = prefixed;
		};
		
		return tag$.extendTag('htmlelement', function(tag){
			
			// override the original css method
			tag.prototype.css = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.css(keys[i],key[keys[i]]);
					};
					return this;
				};
				
				key = Imba.CSSKeyMap[key] || key;
				
				if (val == null) {
					this.dom().style.removeProperty(key);
				} else if (val == undefined) {
					return this.dom().style[key];
				} else {
					if ((typeof val=='number'||val instanceof Number) && key.match(/width|height|left|right|top|bottom/)) {
						val = val + "px";
					};
					this.dom().style[key] = val;
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 8 */
/***/ function(module, exports) {

	(function(){
		
		// predefine all supported html tags
		tag$.defineTag('fragment', 'htmlelement', function(tag){
			
			tag.createNode = function (){
				return Imba.document().createDocumentFragment();
			};
		});
		
		tag$.defineTag('a', function(tag){
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
		});
		
		tag$.defineTag('abbr');
		tag$.defineTag('address');
		tag$.defineTag('area');
		tag$.defineTag('article');
		tag$.defineTag('aside');
		tag$.defineTag('audio');
		tag$.defineTag('b');
		tag$.defineTag('base');
		tag$.defineTag('bdi');
		tag$.defineTag('bdo');
		tag$.defineTag('big');
		tag$.defineTag('blockquote');
		tag$.defineTag('body');
		tag$.defineTag('br');
		
		tag$.defineTag('button', function(tag){
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
		});
		
		tag$.defineTag('canvas', function(tag){
			tag.prototype.setWidth = function (val){
				if (this.width() != val) { this.dom().width = val };
				return this;
			};
			
			tag.prototype.setHeight = function (val){
				if (this.height() != val) { this.dom().height = val };
				return this;
			};
			
			tag.prototype.width = function (){
				return this.dom().width;
			};
			
			tag.prototype.height = function (){
				return this.dom().height;
			};
			
			tag.prototype.context = function (type){
				if(type === undefined) type = '2d';
				return this.dom().getContext(type);
			};
		});
		
		tag$.defineTag('caption');
		tag$.defineTag('cite');
		tag$.defineTag('code');
		tag$.defineTag('col');
		tag$.defineTag('colgroup');
		tag$.defineTag('data');
		tag$.defineTag('datalist');
		tag$.defineTag('dd');
		tag$.defineTag('del');
		tag$.defineTag('details');
		tag$.defineTag('dfn');
		tag$.defineTag('div');
		tag$.defineTag('dl');
		tag$.defineTag('dt');
		tag$.defineTag('em');
		tag$.defineTag('embed');
		tag$.defineTag('fieldset');
		tag$.defineTag('figcaption');
		tag$.defineTag('figure');
		tag$.defineTag('footer');
		
		tag$.defineTag('form', function(tag){
			
			
			tag.prototype.method = function(v){ return this.getAttribute('method'); }
			tag.prototype.setMethod = function(v){ this.setAttribute('method',v); return this; };
			
			
			tag.prototype.action = function(v){ return this.getAttribute('action'); }
			tag.prototype.setAction = function(v){ this.setAttribute('action',v); return this; };
		});
		
		tag$.defineTag('h1');
		tag$.defineTag('h2');
		tag$.defineTag('h3');
		tag$.defineTag('h4');
		tag$.defineTag('h5');
		tag$.defineTag('h6');
		tag$.defineTag('head');
		tag$.defineTag('header');
		tag$.defineTag('hr');
		tag$.defineTag('html');
		tag$.defineTag('i');
		
		tag$.defineTag('iframe', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
		});
		
		tag$.defineTag('img', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
		});
		
		tag$.defineTag('input', function(tag){
			// can use attr instead
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
			
			tag.prototype.setPlaceholder = function (v){
				if (v != this.dom().placeholder) { this.dom().placeholder = v };
				return this;
			};
			
			tag.prototype.placeholder = function (){
				return this.dom().placeholder;
			};
			
			tag.prototype.checked = function (){
				return this.dom().checked;
			};
			
			tag.prototype.setChecked = function (bool){
				if (bool != this.dom().checked) { this.dom().checked = bool };
				return this;
			};
		});
		
		tag$.defineTag('ins');
		tag$.defineTag('kbd');
		tag$.defineTag('keygen');
		tag$.defineTag('label');
		tag$.defineTag('legend');
		tag$.defineTag('li');
		
		tag$.defineTag('link', function(tag){
			
			
			tag.prototype.rel = function(v){ return this.getAttribute('rel'); }
			tag.prototype.setRel = function(v){ this.setAttribute('rel',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
			
			
			tag.prototype.media = function(v){ return this.getAttribute('media'); }
			tag.prototype.setMedia = function(v){ this.setAttribute('media',v); return this; };
		});
		
		tag$.defineTag('main');
		tag$.defineTag('map');
		tag$.defineTag('mark');
		tag$.defineTag('menu');
		tag$.defineTag('menuitem');
		
		tag$.defineTag('meta', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.content = function(v){ return this.getAttribute('content'); }
			tag.prototype.setContent = function(v){ this.setAttribute('content',v); return this; };
			
			
			tag.prototype.charset = function(v){ return this.getAttribute('charset'); }
			tag.prototype.setCharset = function(v){ this.setAttribute('charset',v); return this; };
		});
		
		tag$.defineTag('meter');
		tag$.defineTag('nav');
		tag$.defineTag('noscript');
		tag$.defineTag('object');
		tag$.defineTag('ol');
		tag$.defineTag('optgroup');
		
		tag$.defineTag('option', function(tag){
			
			
			tag.prototype.value = function(v){ return this.getAttribute('value'); }
			tag.prototype.setValue = function(v){ this.setAttribute('value',v); return this; };
		});
		
		tag$.defineTag('output');
		tag$.defineTag('p');
		tag$.defineTag('param');
		tag$.defineTag('pre');
		tag$.defineTag('progress');
		tag$.defineTag('q');
		tag$.defineTag('rp');
		tag$.defineTag('rt');
		tag$.defineTag('ruby');
		tag$.defineTag('s');
		tag$.defineTag('samp');
		
		tag$.defineTag('script', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
		});
		
		tag$.defineTag('section');
		
		tag$.defineTag('select', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.multiple = function(v){ return this.getAttribute('multiple'); }
			tag.prototype.setMultiple = function(v){ this.setAttribute('multiple',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
		});
		
		
		tag$.defineTag('small');
		tag$.defineTag('source');
		tag$.defineTag('span');
		tag$.defineTag('strong');
		tag$.defineTag('style');
		tag$.defineTag('sub');
		tag$.defineTag('summary');
		tag$.defineTag('sup');
		tag$.defineTag('table');
		tag$.defineTag('tbody');
		tag$.defineTag('td');
		
		tag$.defineTag('textarea', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.rows = function(v){ return this.getAttribute('rows'); }
			tag.prototype.setRows = function(v){ this.setAttribute('rows',v); return this; };
			
			
			tag.prototype.cols = function(v){ return this.getAttribute('cols'); }
			tag.prototype.setCols = function(v){ this.setAttribute('cols',v); return this; };
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
			
			tag.prototype.setPlaceholder = function (v){
				if (v != this.dom().placeholder) { this.dom().placeholder = v };
				return this;
			};
			
			tag.prototype.placeholder = function (){
				return this.dom().placeholder;
			};
		});
		
		tag$.defineTag('tfoot');
		tag$.defineTag('th');
		tag$.defineTag('thead');
		tag$.defineTag('time');
		tag$.defineTag('title');
		tag$.defineTag('tr');
		tag$.defineTag('track');
		tag$.defineTag('u');
		tag$.defineTag('ul');
		tag$.defineTag('video');
		return tag$.defineTag('wbr');
	
	})()

/***/ },
/* 9 */
/***/ function(module, exports) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		
		tag$.SVG.defineTag('svgelement', function(tag){
			
			tag.namespaceURI = function (){
				return "http://www.w3.org/2000/svg";
			};
			
			var types = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
			
			tag.buildNode = function (){
				var dom = Imba.document().createElementNS(this.namespaceURI(),this._nodeType);
				var cls = this._classes.join(" ");
				if (cls) { dom.className.baseVal = cls };
				return dom;
			};
			
			tag.inherit = function (child){
				child._protoDom = null;
				
				if (idx$(child._name,types) >= 0) {
					child._nodeType = child._name;
					return child._classes = [];
				} else {
					child._nodeType = this._nodeType;
					var className = "_" + child._name.replace(/_/g,'-');
					return child._classes = this._classes.concat(className);
				};
			};
			
			
			Imba.attr(tag,'x');
			Imba.attr(tag,'y');
			
			Imba.attr(tag,'width');
			Imba.attr(tag,'height');
			
			Imba.attr(tag,'stroke');
			Imba.attr(tag,'stroke-width');
		});
		
		tag$.SVG.defineTag('svg', function(tag){
			Imba.attr(tag,'viewbox');
		});
		
		tag$.SVG.defineTag('rect');
		
		tag$.SVG.defineTag('circle', function(tag){
			Imba.attr(tag,'cx');
			Imba.attr(tag,'cy');
			Imba.attr(tag,'r');
		});
		
		tag$.SVG.defineTag('ellipse', function(tag){
			Imba.attr(tag,'cx');
			Imba.attr(tag,'cy');
			Imba.attr(tag,'rx');
			Imba.attr(tag,'ry');
		});
		
		tag$.SVG.defineTag('path', function(tag){
			Imba.attr(tag,'d');
			Imba.attr(tag,'pathLength');
		});
		
		return tag$.SVG.defineTag('line', function(tag){
			Imba.attr(tag,'x1');
			Imba.attr(tag,'x2');
			Imba.attr(tag,'y1');
			Imba.attr(tag,'y2');
		});
	
	})()

/***/ },
/* 10 */
/***/ function(module, exports) {

	(function(){
		if (!document.documentElement.classList) {
			tag$.extendTag('htmlelement', function(tag){
				
				tag.prototype.hasFlag = function (ref){
					return new RegExp('(^|\\s)' + ref + '(\\s|$)').test(this._dom.className);
				};
				
				tag.prototype.addFlag = function (ref){
					if (this.hasFlag(ref)) { return this };
					this._dom.className += (this._dom.className ? (' ') : ('')) + ref;
					return this;
				};
				
				tag.prototype.unflag = function (ref){
					if (!this.hasFlag(ref)) { return this };
					var regex = new RegExp('(^|\\s)*' + ref + '(\\s|$)*','g');
					this._dom.className = this._dom.className.replace(regex,'');
					return this;
				};
				
				tag.prototype.toggleFlag = function (ref){
					return this.hasFlag(ref) ? (this.unflag(ref)) : (this.flag(ref));
				};
				
				tag.prototype.flag = function (ref,bool){
					if (arguments.length == 2 && !!bool === false) {
						return this.unflag(ref);
					};
					return this.addFlag(ref);
				};
			});
			
			return true;
		};
	
	})()

/***/ },
/* 11 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var doc = document;
		var win = window;
		
		var hasTouchEvents = window && window.ontouchstart !== undefined;
		
		Imba.Pointer = function Pointer(){
			this.setButton(-1);
			this.setEvent({x: 0,y: 0,type: 'uninitialized'});
			return this;
		};
		
		
		
		Imba.Pointer.prototype.phase = function(v){ return this._phase; }
		Imba.Pointer.prototype.setPhase = function(v){ this._phase = v; return this; };
		
		
		Imba.Pointer.prototype.prevEvent = function(v){ return this._prevEvent; }
		Imba.Pointer.prototype.setPrevEvent = function(v){ this._prevEvent = v; return this; };
		
		
		Imba.Pointer.prototype.button = function(v){ return this._button; }
		Imba.Pointer.prototype.setButton = function(v){ this._button = v; return this; };
		
		
		Imba.Pointer.prototype.event = function(v){ return this._event; }
		Imba.Pointer.prototype.setEvent = function(v){ this._event = v; return this; };
		
		
		Imba.Pointer.prototype.dirty = function(v){ return this._dirty; }
		Imba.Pointer.prototype.setDirty = function(v){ this._dirty = v; return this; };
		
		
		Imba.Pointer.prototype.events = function(v){ return this._events; }
		Imba.Pointer.prototype.setEvents = function(v){ this._events = v; return this; };
		
		
		Imba.Pointer.prototype.touch = function(v){ return this._touch; }
		Imba.Pointer.prototype.setTouch = function(v){ this._touch = v; return this; };
		
		Imba.Pointer.prototype.update = function (e){
			this.setEvent(e);
			this.setDirty(true);
			return this;
		};
		
		// this is just for regular mouse now
		Imba.Pointer.prototype.process = function (){
			var e1 = this.event();
			
			if (this.dirty()) {
				this.setPrevEvent(e1);
				this.setDirty(false);
				
				// button should only change on mousedown etc
				if (e1.type == 'mousedown') {
					this.setButton(e1.button);
					
					// do not create touch for right click
					if (this.button() == 2 || (this.touch() && this.button() != 0)) {
						return;
					};
					
					// cancel the previous touch
					if (this.touch()) { this.touch().cancel() };
					this.setTouch(new Imba.Touch(e1,this));
					this.touch().mousedown(e1,e1);
				} else if (e1.type == 'mousemove') {
					if (this.touch()) { this.touch().mousemove(e1,e1) };
				} else if (e1.type == 'mouseup') {
					this.setButton(-1);
					
					if (this.touch() && this.touch().button() == e1.button) {
						this.touch().mouseup(e1,e1);
						this.setTouch(null);
					};
					// trigger pointerup
				};
			} else {
				if (this.touch()) { this.touch().idle() };
			};
			return this;
		};
		
		Imba.Pointer.prototype.cleanup = function (){
			return Imba.POINTERS;
		};
		
		Imba.Pointer.prototype.x = function (){
			return this.event().x;
		};
		Imba.Pointer.prototype.y = function (){
			return this.event().y;
		};
		
		// deprecated -- should remove
		Imba.Pointer.update = function (){
			// console.log('update touch')
			for (var i = 0, ary = iter$(Imba.POINTERS), len = ary.length; i < len; i++) {
				ary[i].process();
			};
			// need to be able to prevent the default behaviour of touch, no?
			win.requestAnimationFrame(Imba.Pointer.update);
			return this;
		};
		
		var lastNativeTouchTimeStamp = 0;
		var lastNativeTouchTimeout = 50;
		
		// Imba.Touch
		// Began	A finger touched the screen.
		// Moved	A finger moved on the screen.
		// Stationary	A finger is touching the screen but hasn't moved.
		// Ended	A finger was lifted from the screen. This is the final phase of a touch.
		// Canceled The system cancelled tracking for the touch.
		
		/*
		Consolidates mouse and touch events. Touch objects persist across a touch,
		from touchstart until end/cancel. When a touch starts, it will traverse
		down from the innermost target, until it finds a node that responds to
		ontouchstart. Unless the touch is explicitly redirected, the touch will
		call ontouchmove and ontouchend / ontouchcancel on the responder when appropriate.
		
			tag draggable
				# called when a touch starts
				def ontouchstart touch
					flag 'dragging'
					self
				
				# called when touch moves - same touch object
				def ontouchmove touch
					# move the node with touch
					css top: touch.dy, left: touch.dx
				
				# called when touch ends
				def ontouchend touch
					unflag 'dragging'
		
		@iname touch
		*/
		
		Imba.Touch = function Touch(event,pointer){
			// @native  = false
			this.setEvent(event);
			this.setData({});
			this.setActive(true);
			this._button = event && event.button || 0;
			this._suppress = false; // deprecated
			this._captured = false;
			this.setBubble(false);
			pointer = pointer;
			this.setUpdates(0);
			return this;
		};
		
		var touches = [];
		var count = 0;
		var identifiers = {};
		
		Imba.Touch.count = function (){
			return count;
		};
		
		Imba.Touch.lookup = function (item){
			return item && (item.__touch__ || identifiers[item.identifier]);
		};
		
		Imba.Touch.release = function (item,touch){
			var v_, $1;
			(((v_ = identifiers[item.identifier]),delete identifiers[item.identifier], v_));
			((($1 = item.__touch__),delete item.__touch__, $1));
			return;
		};
		
		Imba.Touch.ontouchstart = function (e){
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (this.lookup(t)) { continue; };
				var touch = identifiers[t.identifier] = new this(e); // (e)
				t.__touch__ = touch;
				touches.push(touch);
				count++;
				touch.touchstart(e,t);
			};
			return this;
		};
		
		Imba.Touch.ontouchmove = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchmove(e,t);
				};
			};
			
			return this;
		};
		
		Imba.Touch.ontouchend = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchend(e,t);
					this.release(t,touch);
					count--;
				};
			};
			
			// e.preventDefault
			// not always supported!
			// touches = touches.filter(||)
			return this;
		};
		
		Imba.Touch.ontouchcancel = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchcancel(e,t);
					this.release(t,touch);
					count--;
				};
			};
			return this;
		};
		
		Imba.Touch.onmousedown = function (e){
			return this;
		};
		
		Imba.Touch.onmousemove = function (e){
			return this;
		};
		
		Imba.Touch.onmouseup = function (e){
			return this;
		};
		
		
		
		
		Imba.Touch.prototype.phase = function(v){ return this._phase; }
		Imba.Touch.prototype.setPhase = function(v){ this._phase = v; return this; };
		
		
		Imba.Touch.prototype.active = function(v){ return this._active; }
		Imba.Touch.prototype.setActive = function(v){ this._active = v; return this; };
		
		
		Imba.Touch.prototype.event = function(v){ return this._event; }
		Imba.Touch.prototype.setEvent = function(v){ this._event = v; return this; };
		
		
		Imba.Touch.prototype.pointer = function(v){ return this._pointer; }
		Imba.Touch.prototype.setPointer = function(v){ this._pointer = v; return this; };
		
		
		Imba.Touch.prototype.target = function(v){ return this._target; }
		Imba.Touch.prototype.setTarget = function(v){ this._target = v; return this; };
		
		
		Imba.Touch.prototype.handler = function(v){ return this._handler; }
		Imba.Touch.prototype.setHandler = function(v){ this._handler = v; return this; };
		
		
		Imba.Touch.prototype.updates = function(v){ return this._updates; }
		Imba.Touch.prototype.setUpdates = function(v){ this._updates = v; return this; };
		
		
		Imba.Touch.prototype.suppress = function(v){ return this._suppress; }
		Imba.Touch.prototype.setSuppress = function(v){ this._suppress = v; return this; };
		
		
		Imba.Touch.prototype.data = function(v){ return this._data; }
		Imba.Touch.prototype.setData = function(v){ this._data = v; return this; };
		
		Imba.Touch.prototype.__bubble = {chainable: true,name: 'bubble'};
		Imba.Touch.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }
		Imba.Touch.prototype.setBubble = function(v){ this._bubble = v; return this; };
		
		
		
		Imba.Touch.prototype.gestures = function(v){ return this._gestures; }
		Imba.Touch.prototype.setGestures = function(v){ this._gestures = v; return this; };
		
		/*
			
		
			@internal
			@constructor
			*/
		
		Imba.Touch.prototype.capture = function (){
			this._captured = true;
			this._event && this._event.preventDefault();
			return this;
		};
		
		Imba.Touch.prototype.isCaptured = function (){
			return !!this._captured;
		};
		
		/*
			Extend the touch with a plugin / gesture. 
			All events (touchstart,move etc) for the touch
			will be triggered on the plugins in the order they
			are added.
			*/
		
		Imba.Touch.prototype.extend = function (plugin){
			// console.log "added gesture!!!"
			this._gestures || (this._gestures = []);
			this._gestures.push(plugin);
			return this;
		};
		
		/*
			Redirect touch to specified target. ontouchstart will always be
			called on the new target.
			@return {Number}
			*/
		
		Imba.Touch.prototype.redirect = function (target){
			this._redirect = target;
			return this;
		};
		
		/*
			Suppress the default behaviour. Will call preventDefault for
			all native events that are part of the touch.
			*/
		
		Imba.Touch.prototype.suppress = function (){
			// collision with the suppress property
			this._active = false;
			return this;
		};
		
		Imba.Touch.prototype.setSuppress = function (value){
			console.warn('Imba.Touch#suppress= is deprecated');
			this._supress = value;
			return this;
		};
		
		Imba.Touch.prototype.touchstart = function (e,t){
			this._event = e;
			this._touch = t;
			this._button = 0;
			this._x = t.clientX;
			this._y = t.clientY;
			this.began();
			if (e && this.isCaptured()) { e.preventDefault() };
			return this;
		};
		
		Imba.Touch.prototype.touchmove = function (e,t){
			this._event = e;
			this._x = t.clientX;
			this._y = t.clientY;
			this.update();
			if (e && this.isCaptured()) { e.preventDefault() };
			return this;
		};
		
		Imba.Touch.prototype.touchend = function (e,t){
			this._event = e;
			this._x = t.clientX;
			this._y = t.clientY;
			this.ended();
			
			lastNativeTouchTimeStamp = e.timeStamp;
			
			if (this._maxdr < 20) {
				var tap = new Imba.Event(e);
				tap.setType('tap');
				tap.process();
				if (tap._responder) { e.preventDefault() };
			};
			
			if (e && this.isCaptured()) {
				e.preventDefault();
			};
			
			return this;
		};
		
		Imba.Touch.prototype.touchcancel = function (e,t){
			return this.cancel();
		};
		
		Imba.Touch.prototype.mousedown = function (e,t){
			var self = this;
			self._event = e;
			self._button = e.button;
			self._x = t.clientX;
			self._y = t.clientY;
			self.began();
			
			self._mousemove = function(e) { return self.mousemove(e,e); };
			doc.addEventListener('mousemove',self._mousemove,true);
			return self;
		};
		
		Imba.Touch.prototype.mousemove = function (e,t){
			this._x = t.clientX;
			this._y = t.clientY;
			this._event = e;
			if (this.isCaptured()) { e.preventDefault() };
			this.update();
			this.move();
			return this;
		};
		
		Imba.Touch.prototype.mouseup = function (e,t){
			this._x = t.clientX;
			this._y = t.clientY;
			this.ended();
			doc.removeEventListener('mousemove',this._mousemove,true);
			this._mousemove = null;
			return this;
		};
		
		Imba.Touch.prototype.idle = function (){
			return this.update();
		};
		
		Imba.Touch.prototype.began = function (){
			this._maxdr = this._dr = 0;
			this._x0 = this._x;
			this._y0 = this._y;
			
			var dom = this.event().target;
			var node = null;
			
			this._sourceTarget = dom && tag$wrap(dom);
			
			while (dom){
				node = tag$wrap(dom);
				if (node && node.ontouchstart) {
					this._bubble = false;
					this.setTarget(node);
					this.target().ontouchstart(this);
					if (!this._bubble) { break; };
				};
				dom = dom.parentNode;
			};
			
			this._updates++;
			return this;
		};
		
		Imba.Touch.prototype.update = function (){
			var target_;
			if (!this._active) { return this };
			
			var dr = Math.sqrt(this.dx() * this.dx() + this.dy() * this.dy());
			if (dr > this._dr) { this._maxdr = dr };
			this._dr = dr;
			
			// catching a touch-redirect?!?
			if (this._redirect) {
				if (this._target && this._target.ontouchcancel) {
					this._target.ontouchcancel(this);
				};
				this.setTarget(this._redirect);
				this._redirect = null;
				if (this.target().ontouchstart) { this.target().ontouchstart(this) };
			};
			
			
			this._updates++;
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length; i < len; i++) {
					ary[i].ontouchupdate(this);
				};
			};
			
			(target_ = this.target()) && target_.ontouchupdate  &&  target_.ontouchupdate(this);
			return this;
		};
		
		Imba.Touch.prototype.move = function (){
			var target_;
			if (!this._active) { return this };
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length, g; i < len; i++) {
					g = ary[i];
					if (g.ontouchmove) { g.ontouchmove(this,this._event) };
				};
			};
			
			(target_ = this.target()) && target_.ontouchmove  &&  target_.ontouchmove(this,this._event);
			return this;
		};
		
		Imba.Touch.prototype.ended = function (){
			var target_;
			if (!this._active) { return this };
			
			this._updates++;
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length; i < len; i++) {
					ary[i].ontouchend(this);
				};
			};
			
			(target_ = this.target()) && target_.ontouchend  &&  target_.ontouchend(this);
			
			return this;
		};
		
		Imba.Touch.prototype.cancel = function (){
			if (!this._cancelled) {
				this._cancelled = true;
				this.cancelled();
				if (this._mousemove) { doc.removeEventListener('mousemove',this._mousemove,true) };
			};
			return this;
		};
		
		Imba.Touch.prototype.cancelled = function (){
			var target_;
			if (!this._active) { return this };
			
			this._cancelled = true;
			this._updates++;
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length, g; i < len; i++) {
					g = ary[i];
					if (g.ontouchcancel) { g.ontouchcancel(this) };
				};
			};
			
			(target_ = this.target()) && target_.ontouchcancel  &&  target_.ontouchcancel(this);
			return this;
		};
		
		/*
			The absolute distance the touch has moved from starting position 
			@return {Number}
			*/
		
		Imba.Touch.prototype.dr = function (){
			return this._dr;
		};
		
		/*
			The distance the touch has moved horizontally
			@return {Number}
			*/
		
		Imba.Touch.prototype.dx = function (){
			return this._x - this._x0;
		};
		
		/*
			The distance the touch has moved vertically
			@return {Number}
			*/
		
		Imba.Touch.prototype.dy = function (){
			return this._y - this._y0;
		};
		
		/*
			Initial horizontal position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.x0 = function (){
			return this._x0;
		};
		
		/*
			Initial vertical position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.y0 = function (){
			return this._y0;
		};
		
		/*
			Horizontal position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.x = function (){
			return this._x;
		};
		
		/*
			Vertical position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.y = function (){
			return this._y;
		};
		
		/*
			Horizontal position of touch relative to target
			@return {Number}
			*/
		
		Imba.Touch.prototype.tx = function (){
			this._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());
			return this._x - this._targetBox.left;
		};
		
		/*
			Vertical position of touch relative to target
			@return {Number}
			*/
		
		Imba.Touch.prototype.ty = function (){
			this._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());
			return this._y - this._targetBox.top;
		};
		
		/*
			Button pressed in this touch. Native touches defaults to left-click (0)
			@return {Number}
			*/
		
		Imba.Touch.prototype.button = function (){
			return this._button;
		}; // @pointer ? @pointer.button : 0
		
		Imba.Touch.prototype.sourceTarget = function (){
			return this._sourceTarget;
		};
		
		
		Imba.TouchGesture = function TouchGesture(){ };
		
		
		Imba.TouchGesture.prototype.__active = {'default': false,name: 'active'};
		Imba.TouchGesture.prototype.active = function(v){ return this._active; }
		Imba.TouchGesture.prototype.setActive = function(v){ this._active = v; return this; }
		Imba.TouchGesture.prototype._active = false;
		
		Imba.TouchGesture.prototype.ontouchstart = function (e){
			return this;
		};
		
		Imba.TouchGesture.prototype.ontouchupdate = function (e){
			return this;
		};
		
		Imba.TouchGesture.prototype.ontouchend = function (e){
			return this;
		};
		
		
		// A Touch-event is created on mousedown (always)
		// and while it exists, mousemove and mouseup will
		// be delegated to this active event.
		Imba.POINTER = new Imba.Pointer();
		Imba.POINTERS = [Imba.POINTER];
		
		
		// regular event stuff
		Imba.KEYMAP = {
			"8": 'backspace',
			"9": 'tab',
			"13": 'enter',
			"16": 'shift',
			"17": 'ctrl',
			"18": 'alt',
			"19": 'break',
			"20": 'caps',
			"27": 'esc',
			"32": 'space',
			"35": 'end',
			"36": 'home',
			"37": 'larr',
			"38": 'uarr',
			"39": 'rarr',
			"40": 'darr',
			"45": 'insert',
			"46": 'delete',
			"107": 'plus',
			"106": 'mult',
			"91": 'meta'
		};
		
		Imba.CHARMAP = {
			"%": 'modulo',
			"*": 'multiply',
			"+": 'add',
			"-": 'sub',
			"/": 'divide',
			".": 'dot'
		};
		
		/*
		Imba handles all events in the dom through a single manager,
		listening at the root of your document. If Imba finds a tag
		that listens to a certain event, the event will be wrapped 
		in an `Imba.Event`, which normalizes some of the quirks and 
		browser differences.
		
		@iname event
		*/
		
		Imba.Event = function Event(e){
			this.setEvent(e);
			this.setBubble(true);
		};
		
		/* reference to the native event */
		
		
		
		Imba.Event.prototype.event = function(v){ return this._event; }
		Imba.Event.prototype.setEvent = function(v){ this._event = v; return this; };
		
		/* reference to the native event */
		
		
		
		Imba.Event.prototype.prefix = function(v){ return this._prefix; }
		Imba.Event.prototype.setPrefix = function(v){ this._prefix = v; return this; };
		
		
		
		Imba.Event.prototype.data = function(v){ return this._data; }
		Imba.Event.prototype.setData = function(v){ this._data = v; return this; };
		
		/*
			should remove this alltogether?
			@deprecated
			*/
		
		
		
		Imba.Event.prototype.source = function(v){ return this._source; }
		Imba.Event.prototype.setSource = function(v){ this._source = v; return this; };
		
		/* A {Boolean} indicating whether the event bubbles up or not */
		
		
		Imba.Event.prototype.__bubble = {type: Boolean,chainable: true,name: 'bubble'};
		Imba.Event.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }
		Imba.Event.prototype.setBubble = function(v){ this._bubble = v; return this; };
		
		Imba.Event.wrap = function (e){
			return new this(e);
		};
		
		Imba.Event.prototype.setType = function (type){
			this._type = type;
			return this;
		};
		
		/*
			@return {String} The name of the event (case-insensitive)
			*/
		
		Imba.Event.prototype.type = function (){
			return this._type || this.event().type;
		};
		
		Imba.Event.prototype.name = function (){
			return this._name || (this._name = this.type().toLowerCase().replace(/\:/g,''));
		};
		
		// mimc getset
		Imba.Event.prototype.bubble = function (v){
			if (v != undefined) {
				this.setBubble(v);
				return this;
			};
			return this._bubble;
		};
		
		/*
			Prevents further propagation of the current event.
			@return {self}
			*/
		
		Imba.Event.prototype.halt = function (){
			this.setBubble(false);
			return this;
		};
		
		/*
			Cancel the event (if cancelable). In the case of native events it
			will call `preventDefault` on the wrapped event object.
			@return {self}
			*/
		
		Imba.Event.prototype.cancel = function (){
			if (this.event().preventDefault) { this.event().preventDefault() };
			this._cancel = true;
			return this;
		};
		
		/*
			Indicates whether or not event.cancel has been called.
		
			@return {Boolean}
			*/
		
		Imba.Event.prototype.isPrevented = function (){
			return this.event() && this.event().defaultPrevented || this._cancel;
		};
		
		/*
			A reference to the initial target of the event.
			*/
		
		Imba.Event.prototype.target = function (){
			return tag$wrap(this.event()._target || this.event().target);
		};
		
		/*
			A reference to the object responding to the event.
			*/
		
		Imba.Event.prototype.responder = function (){
			return this._responder;
		};
		
		/*
			Redirect the event to new target
			*/
		
		Imba.Event.prototype.redirect = function (node){
			this._redirect = node;
			return this;
		};
		
		/*
			Get the normalized character for KeyboardEvent/TextEvent
			@return {String}
			*/
		
		Imba.Event.prototype.keychar = function (){
			if (this.event() instanceof TextEvent) {
				return this.event().data;
			};
			
			if (this.event() instanceof KeyboardEvent) {
				var ki = this.event().keyIdentifier;
				var sym = Imba.KEYMAP[this.event().keyCode];
				
				// p 'keysym!',ki,sym
				
				if (!sym && ki.substr(0,2) == "U+") {
					sym = String.fromCharCode(parseInt(ki.substr(2),16));
				};
				return sym;
			};
			
			return null;
		};
		
		/*
			@deprecated
			*/
		
		Imba.Event.prototype.keycombo = function (){
			var sym;
			if (!(sym = this.keychar())) { return };
			sym = Imba.CHARMAP[sym] || sym;
			var combo = [],e = this.event();
			if (e.ctrlKey) { combo.push('ctrl') };
			if (e.shiftKey) { combo.push('shift') };
			if (e.altKey) { combo.push('alt') };
			if (e.metaKey) { combo.push('cmd') };
			combo.push(sym);
			return combo.join("_").toLowerCase();
		};
		
		
		Imba.Event.prototype.process = function (){
			var node;
			var meth = ("on" + (this._prefix || '') + this.name());
			var args = null;
			var domtarget = this.event()._target || this.event().target;
			// var node = <{domtarget:_responder or domtarget}>
			// need to clean up and document this behaviour
			
			var domnode = domtarget._responder || domtarget;
			// @todo need to stop infinite redirect-rules here
			
			var $1;while (domnode){
				this._redirect = null;
				if (node = tag$wrap(domnode)) { // not only tag 
					
					if ((typeof node[($1 = meth)]=='string'||node[$1] instanceof String)) {
						// should remember the receiver of the event
						meth = node[meth];
						continue; // should not continue?
					};
					
					if (node[meth] instanceof Array) {
						args = node[meth].concat(node);
						meth = args.shift();
						continue; // should not continue?
					};
					
					if (node[meth] instanceof Function) {
						this._responder || (this._responder = node);
						// should autostop bubble here?
						args ? (node[meth].apply(node,args)) : (node[meth](this,this.data()));
					};
				};
				
				// add node.nextEventResponder as a separate method here?
				if (!(this.bubble() && (domnode = (this._redirect || (node ? (node.parent()) : (domnode.parentNode)))))) {
					break;
				};
			};
			
			this.processed();
			return this;
		};
		
		
		Imba.Event.prototype.processed = function (){
			Imba.emit(Imba,'event',[this]);
			return this;
		};
		
		/*
			Return the x/left coordinate of the mouse / pointer for this event
			@return {Number} x coordinate of mouse / pointer for event
			*/
		
		Imba.Event.prototype.x = function (){
			return this.event().x;
		};
		
		/*
			Return the y/top coordinate of the mouse / pointer for this event
			@return {Number} y coordinate of mouse / pointer for event
			*/
		
		Imba.Event.prototype.y = function (){
			return this.event().y;
		};
		
		/*
			Returns a Number representing a system and implementation
			dependent numeric code identifying the unmodified value of the
			pressed key; this is usually the same as keyCode.
		
			For mouse-events, the returned value indicates which button was
			pressed on the mouse to trigger the event.
		
			@return {Number}
			*/
		
		Imba.Event.prototype.which = function (){
			return this.event().which;
		};
		
		
		/*
		
		Manager for listening to and delegating events in Imba. A single instance
		is always created by Imba (as `Imba.Events`), which handles and delegates all
		events at the very root of the document. Imba does not capture all events
		by default, so if you want to make sure exotic or custom DOMEvents are delegated
		in Imba you will need to register them in `Imba.Events.register(myCustomEventName)`
		
		@iname manager
		
		*/
		
		Imba.EventManager = function EventManager(node,pars){
			var self = this;
			if(!pars||pars.constructor !== Object) pars = {};
			var events = pars.events !== undefined ? pars.events : [];
			self.setRoot(node);
			self.setCount(0);
			self.setListeners([]);
			self.setDelegators({});
			self.setDelegator(function(e) {
				// console.log "delegating event?! {e}"
				self.delegate(e);
				return true;
			});
			
			for (var i = 0, ary = iter$(events), len = ary.length; i < len; i++) {
				self.register(ary[i]);
			};
			
			return self;
		};
		
		
		
		Imba.EventManager.prototype.root = function(v){ return this._root; }
		Imba.EventManager.prototype.setRoot = function(v){ this._root = v; return this; };
		
		
		Imba.EventManager.prototype.count = function(v){ return this._count; }
		Imba.EventManager.prototype.setCount = function(v){ this._count = v; return this; };
		
		Imba.EventManager.prototype.__enabled = {'default': false,watch: 'enabledDidSet',name: 'enabled'};
		Imba.EventManager.prototype.enabled = function(v){ return this._enabled; }
		Imba.EventManager.prototype.setEnabled = function(v){
			var a = this.enabled();
			if(v != a) { this._enabled = v; }
			if(v != a) { this.enabledDidSet && this.enabledDidSet(v,a,this.__enabled) }
			return this;
		}
		Imba.EventManager.prototype._enabled = false;
		
		
		Imba.EventManager.prototype.listeners = function(v){ return this._listeners; }
		Imba.EventManager.prototype.setListeners = function(v){ this._listeners = v; return this; };
		
		
		Imba.EventManager.prototype.delegators = function(v){ return this._delegators; }
		Imba.EventManager.prototype.setDelegators = function(v){ this._delegators = v; return this; };
		
		
		Imba.EventManager.prototype.delegator = function(v){ return this._delegator; }
		Imba.EventManager.prototype.setDelegator = function(v){ this._delegator = v; return this; };
		
		Imba.EventManager.prototype.enabledDidSet = function (bool){
			bool ? (this.onenable()) : (this.ondisable());
			return this;
		};
		
		/*
		
			Tell the current EventManager to intercept and handle event of a certain name.
			By default, Imba.Events will register interceptors for: *keydown*, *keyup*, 
			*keypress*, *textInput*, *input*, *change*, *submit*, *focusin*, *focusout*, 
			*blur*, *contextmenu*, *dblclick*, *mousewheel*, *wheel*
		
			*/
		
		Imba.EventManager.prototype.register = function (name,handler){
			if(handler === undefined) handler = true;
			if (name instanceof Array) {
				for (var i = 0, ary = iter$(name), len = ary.length; i < len; i++) {
					this.register(ary[i],handler);
				};
				return this;
			};
			
			if (this.delegators()[name]) { return this };
			// console.log("register for event {name}")
			var fn = this.delegators()[name] = handler instanceof Function ? (handler) : (this.delegator());
			if (this.enabled()) { return this.root().addEventListener(name,fn,true) };
		};
		
		Imba.EventManager.prototype.listen = function (name,handler,capture){
			if(capture === undefined) capture = true;
			this.listeners().push([name,handler,capture]);
			if (this.enabled()) { this.root().addEventListener(name,handler,capture) };
			return this;
		};
		
		Imba.EventManager.prototype.delegate = function (e){
			this.setCount(this.count() + 1);
			var event = Imba.Event.wrap(e);
			event.process();
			return this;
		};
		
		Imba.EventManager.prototype.create = function (type,target,pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var data = pars.data !== undefined ? pars.data : null;
			var source = pars.source !== undefined ? pars.source : null;
			var event = Imba.Event.wrap({type: type,target: target});
			if (data) { (event.setData(data),data) };
			if (source) { (event.setSource(source),source) };
			return event;
		};
		
		// use create instead?
		Imba.EventManager.prototype.trigger = function (){
			return this.create.apply(this,arguments).process();
		};
		
		Imba.EventManager.prototype.onenable = function (){
			for (var o = this.delegators(), i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				this.root().addEventListener(keys[i],o[keys[i]],true);
			};
			
			for (var j = 0, ary = iter$(this.listeners()), len = ary.length, item; j < len; j++) {
				item = ary[j];
				this.root().addEventListener(item[0],item[1],item[2]);
			};
			return this;
		};
		
		Imba.EventManager.prototype.ondisable = function (){
			for (var o = this.delegators(), i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				this.root().removeEventListener(keys[i],o[keys[i]],true);
			};
			
			for (var j = 0, ary = iter$(this.listeners()), len = ary.length, item; j < len; j++) {
				item = ary[j];
				this.root().removeEventListener(item[0],item[1],item[2]);
			};
			return this;
		};
		
		
		ED = Imba.Events = new Imba.EventManager(document,{events: [
			'keydown','keyup','keypress','textInput','input','change','submit',
			'focusin','focusout','blur','contextmenu','dblclick',
			'mousewheel','wheel'
		]});
		
		// should set these up inside the Imba.Events object itself
		// so that we can have different EventManager for different roots
		
		if (hasTouchEvents) {
			Imba.Events.listen('touchstart',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchstart(e);
			});
			
			Imba.Events.listen('touchmove',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchmove(e);
			});
			
			Imba.Events.listen('touchend',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchend(e);
			});
			
			Imba.Events.listen('touchcancel',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchcancel(e);
			});
		};
		
		Imba.Events.register('click',function(e) {
			// Only for main mousebutton, no?
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				var tap = new Imba.Event(e);
				tap.setType('tap');
				tap.process();
				if (tap._responder) {
					return e.preventDefault();
				};
			};
			// delegate the real click event
			return Imba.Events.delegate(e);
		});
		
		Imba.Events.listen('mousedown',function(e) {
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				if (Imba.POINTER) { return Imba.POINTER.update(e).process() };
			};
		});
		
		// Imba.Events.listen(:mousemove) do |e|
		// 	# console.log 'mousemove',e:timeStamp
		// 	if (e:timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout
		// 		Imba.POINTER.update(e).process if Imba.POINTER # .process if touch # should not happen? We process through 
		
		Imba.Events.listen('mouseup',function(e) {
			// console.log 'mouseup',e:timeStamp
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				if (Imba.POINTER) { return Imba.POINTER.update(e).process() };
			};
		});
		
		
		Imba.Events.register(['mousedown','mouseup']);
		return (Imba.Events.setEnabled(true),true);
	
	})()

/***/ },
/* 12 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var ImbaTag = Imba.TAGS.element;
		
		function removeNested(root,node,caret){
			// if node/nodes isa String
			// 	we need to use the caret to remove elements
			// 	for now we will simply not support this
			if (node instanceof ImbaTag) {
				root.removeChild(node);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					removeNested(root,ary[i],caret);
				};
			} else {
				// what if this is not null?!?!?
				// take a chance and remove a text-elementng
				var next = caret ? (caret.nextSibling) : (root._dom.firstChild);
				if ((next instanceof Text) && next.textContent == node) {
					root.removeChild(next);
				} else {
					throw 'cannot remove string';
				};
			};
			
			return caret;
		};
		
		function appendNested(root,node){
			if (node instanceof ImbaTag) {
				root.appendChild(node);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					appendNested(root,ary[i]);
				};
			} else if (node != null && node !== false) {
				root.appendChild(Imba.document().createTextNode(node));
			};
			
			return;
		};
		
		
		// insert nodes before a certain node
		// does not need to return any tail, as before
		// will still be correct there
		// before must be an actual domnode
		function insertNestedBefore(root,node,before){
			if (node instanceof ImbaTag) {
				root.insertBefore(node,before);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					insertNestedBefore(root,ary[i],before);
				};
			} else if (node != null && node !== false) {
				root.insertBefore(Imba.document().createTextNode(node),before);
			};
			
			return before;
		};
		
		// after must be an actual domnode
		function insertNestedAfter(root,node,after){
			var before = after ? (after.nextSibling) : (root._dom.firstChild);
			
			if (before) {
				insertNestedBefore(root,node,before);
				return before.previousSibling;
			} else {
				appendNested(root,node);
				return root._dom.lastChild;
			};
		};
		
		function reconcileCollectionChanges(root,new$,old,caret){
			
			var newLen = new$.length;
			var lastNew = new$[newLen - 1];
			
			// This re-order algorithm is based on the following principle:
			// 
			// We build a "chain" which shows which items are already sorted.
			// If we're going from [1, 2, 3] -> [2, 1, 3], the tree looks like:
			//
			// 	3 ->  0 (idx)
			// 	2 -> -1 (idx)
			// 	1 -> -1 (idx)
			//
			// This tells us that we have two chains of ordered items:
			// 
			// 	(1, 3) and (2)
			// 
			// The optimal re-ordering then becomes two keep the longest chain intact,
			// and move all the other items.
			
			var newPosition = [];
			
			// The tree/graph itself
			var prevChain = [];
			// The length of the chain
			var lengthChain = [];
			
			// Keep track of the longest chain
			var maxChainLength = 0;
			var maxChainEnd = 0;
			
			for (var idx = 0, ary = iter$(old), len = ary.length, node; idx < len; idx++) {
				node = ary[idx];
				var newPos = new$.indexOf(node);
				newPosition.push(newPos);
				
				if (newPos == -1) {
					root.removeChild(node);
					prevChain.push(-1);
					lengthChain.push(-1);
					continue;
				};
				
				var prevIdx = newPosition.length - 2;
				
				// Build the chain:
				while (prevIdx >= 0){
					if (newPosition[prevIdx] == -1) {
						prevIdx--;
					} else if (newPos > newPosition[prevIdx]) {
						// Yay, we're bigger than the previous!
						break;
					} else {
						// Nope, let's walk back the chain
						prevIdx = prevChain[prevIdx];
					};
				};
				
				prevChain.push(prevIdx);
				
				var currLength = (prevIdx == -1) ? (0) : (lengthChain[prevIdx] + 1);
				
				if (currLength > maxChainLength) {
					maxChainLength = currLength;
					maxChainEnd = idx;
				};
				
				lengthChain.push(currLength);
			};
			
			var stickyNodes = [];
			
			// Now we can walk the longest chain backwards and mark them as "sticky",
			// which implies that they should not be moved
			var cursor = newPosition.length - 1;
			while (cursor >= 0){
				if (cursor == maxChainEnd && newPosition[cursor] != -1) {
					stickyNodes[newPosition[cursor]] = true;
					maxChainEnd = prevChain[maxChainEnd];
				};
				
				cursor -= 1;
			};
			
			// And let's iterate forward, but only move non-sticky nodes
			for (var idx1 = 0, ary = iter$(new$), len = ary.length; idx1 < len; idx1++) {
				if (!stickyNodes[idx1]) {
					var after = new$[idx1 - 1];
					insertNestedAfter(root,ary[idx1],(after && after._dom) || caret);
				};
			};
			
			// should trust that the last item in new list is the caret
			return lastNew && lastNew._dom || caret;
		};
		
		
		// expects a flat non-sparse array of nodes in both new and old, always
		function reconcileCollection(root,new$,old,caret){
			var k = new$.length;
			var i = k;
			var last = new$[k - 1];
			
			
			if (k == old.length && new$[0] === old[0]) {
				// running through to compare
				while (i--){
					if (new$[i] !== old[i]) { break; };
				};
			};
			
			if (i == -1) {
				return last && last._dom || caret;
			} else {
				return reconcileCollectionChanges(root,new$,old,caret);
			};
		};
		
		// the general reconciler that respects conditions etc
		// caret is the current node we want to insert things after
		function reconcileNested(root,new$,old,caret){
			
			// if new == null or new === false or new === true
			// 	if new === old
			// 		return caret
			// 	if old && new != old
			// 		removeNested(root,old,caret) if old
			// 
			// 	return caret
			
			// var skipnew = new == null or new === false or new === true
			var newIsNull = new$ == null || new$ === false;
			var oldIsNull = old == null || old === false;
			
			
			if (new$ === old) {
				// remember that the caret must be an actual dom element
				// we should instead move the actual caret? - trust
				if (newIsNull) {
					return caret;
				} else if (new$ && new$._dom) {
					return new$._dom;
				} else {
					return caret ? (caret.nextSibling) : (root._dom.firstChild);
				};
			} else if (new$ instanceof Array) {
				if (old instanceof Array) {
					if (new$.static || old.static) {
						// if the static is not nested - we could get a hint from compiler
						// and just skip it
						if (new$.static == old.static) {
							for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
								// this is where we could do the triple equal directly
								caret = reconcileNested(root,ary[i],old[i],caret);
							};
							return caret;
						} else {
							removeNested(root,old,caret);
						};
						
						// if they are not the same we continue through to the default
					} else {
						return reconcileCollection(root,new$,old,caret);
					};
				} else if (old instanceof ImbaTag) {
					root.removeChild(old);
				} else if (!oldIsNull) {
					// old was a string-like object?
					root.removeChild(caret ? (caret.nextSibling) : (root._dom.firstChild));
				};
				
				return insertNestedAfter(root,new$,caret);
				// remove old
			} else if (new$ instanceof ImbaTag) {
				if (!oldIsNull) { removeNested(root,old,caret) };
				insertNestedAfter(root,new$,caret);
				return new$;
			} else if (newIsNull) {
				if (!oldIsNull) { removeNested(root,old,caret) };
				return caret;
			} else {
				// if old did not exist we need to add a new directly
				var nextNode;
				// if old was array or imbatag we need to remove it and then add
				if (old instanceof Array) {
					removeNested(root,old,caret);
				} else if (old instanceof ImbaTag) {
					root.removeChild(old);
				} else if (!oldIsNull) {
					// ...
					nextNode = caret ? (caret.nextSibling) : (root._dom.firstChild);
					if ((nextNode instanceof Text) && nextNode.textContent != new$) {
						nextNode.textContent = new$;
						return nextNode;
					};
				};
				
				// now add the textnode
				return insertNestedAfter(root,new$,caret);
			};
		};
		
		
		return tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.setChildren = function (new$,typ){
				var old = this._children;
				// var isArray = nodes isa Array
				if (new$ === old) {
					return this;
				};
				
				if (!old) {
					this.empty();
					appendNested(this,new$);
				} else if (typ == 2) {
					return this;
				} else if (typ == 1) {
					// here we _know _that it is an array with the same shape
					// every time
					var caret = null;
					for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
						// prev = old[i]
						caret = reconcileNested(this,ary[i],old[i],caret);
					};
				} else if (typ == 3) {
					// this is possibly fully dynamic. It often is
					// but the old or new could be static while the other is not
					// this is not handled now
					// what if it was previously a static array? edgecase - but must work
					if (new$ instanceof ImbaTag) {
						this.empty();
						this.appendChild(new$);
					} else if (new$ instanceof Array) {
						if (old instanceof Array) {
							// is this not the same as setting staticChildren now but with the
							reconcileCollection(this,new$,old,null);
						} else {
							this.empty();
							appendNested(this,new$);
						};
					} else {
						this.setText(new$);
						return this;
					};
				} else if ((new$ instanceof Array) && (old instanceof Array)) {
					reconcileCollection(this,new$,old,null);
				} else {
					this.empty();
					appendNested(this,new$);
				};
				
				this._children = new$;
				return this;
			};
			
			
			// only ever called with array as argument
			tag.prototype.setStaticChildren = function (new$){
				var old = this._children;
				
				var caret = null;
				for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
					// prev = old[i]
					caret = reconcileNested(this,ary[i],old[i],caret);
				};
				
				this._children = new$;
				return this;
			};
			
			tag.prototype.content = function (){
				return this._content || this.children().toArray();
			};
			
			tag.prototype.setText = function (text){
				if (text != this._children) {
					this._children = text;
					this.dom().textContent = text == null || text === false ? ('') : (text);
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 13 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		/*
		The special syntax for selectors in Imba creates Imba.Selector
		instances.
		*/
		
		Imba.Selector = function Selector(sel,scope,nodes){
			
			this._query = sel instanceof Imba.Selector ? (sel.query()) : (sel);
			this._context = scope;
			
			if (nodes) {
				for (var i = 0, ary = iter$(nodes), len = ary.length, res = []; i < len; i++) {
					res.push(tag$wrap(ary[i]));
				};
				this._nodes = res;
			};
			
			this._lazy = !nodes;
			return this;
		};
		
		Imba.Selector.one = function (sel,scope){
			var el = (scope || Imba.document()).querySelector(sel);
			return el && tag$wrap(el) || null;
		};
		
		Imba.Selector.all = function (sel,scope){
			return new Imba.Selector(sel,scope);
		};
		
		
		
		Imba.Selector.prototype.query = function(v){ return this._query; }
		Imba.Selector.prototype.setQuery = function(v){ this._query = v; return this; };
		
		Imba.Selector.prototype.reload = function (){
			this._nodes = null;
			return this;
		};
		
		Imba.Selector.prototype.scope = function (){
			var ctx;
			if (this._scope) { return this._scope };
			if (!(ctx = this._context)) { return Imba.document() };
			return this._scope = ctx.toScope ? (ctx.toScope()) : (ctx);
		};
		
		/*
			@returns {Imba.Tag} first node matching this selector
			*/
		
		Imba.Selector.prototype.first = function (){
			if (this._lazy) { return tag$wrap(this._first || (this._first = this.scope().querySelector(this.query()))) } else {
				return this.nodes()[0];
			};
		};
		
		/*
			@returns {Imba.Tag} last node matching this selector
			*/
		
		Imba.Selector.prototype.last = function (){
			return this.nodes()[this._nodes.length - 1];
		};
		
		/*
			@returns [Imba.Tag] all nodes matching this selector
			*/
		
		Imba.Selector.prototype.nodes = function (){
			if (this._nodes) { return this._nodes };
			var items = this.scope().querySelectorAll(this.query());
			for (var i = 0, ary = iter$(items), len = ary.length, res = []; i < len; i++) {
				res.push(tag$wrap(ary[i]));
			};
			this._nodes = res;
			this._lazy = false;
			return this._nodes;
		};
		
		/*
			The number of nodes matching this selector
			*/
		
		Imba.Selector.prototype.count = function (){
			return this.nodes().length;
		};
		
		Imba.Selector.prototype.len = function (){
			return this.nodes().length;
		};
		
		/*
			@todo Add support for block or selector?
			*/
		
		Imba.Selector.prototype.some = function (){
			return this.count() >= 1;
		};
		
		/*
			Get node at index
			*/
		
		Imba.Selector.prototype.at = function (idx){
			return this.nodes()[idx];
		};
		
		/*
			Loop through nodes
			*/
		
		Imba.Selector.prototype.forEach = function (block){
			this.nodes().forEach(block);
			return this;
		};
		
		/*
			Map nodes
			*/
		
		Imba.Selector.prototype.map = function (block){
			return this.nodes().map(block);
		};
		
		/*
			Returns a plain array containing nodes. Implicitly called
			when iterating over a selector in Imba `(node for node in $(selector))`
			*/
		
		Imba.Selector.prototype.toArray = function (){
			return this.nodes();
		};
		
		// Get the first element that matches the selector, 
		// beginning at the current element and progressing up through the DOM tree
		Imba.Selector.prototype.closest = function (sel){
			// seems strange that we alter this selector?
			this._nodes = this.map(function(node) { return node.closest(sel); });
			return this;
		};
		
		// Get the siblings of each element in the set of matched elements, 
		// optionally filtered by a selector.
		// TODO remove duplicates?
		Imba.Selector.prototype.siblings = function (sel){
			this._nodes = this.map(function(node) { return node.siblings(sel); });
			return this;
		};
		
		// Get the descendants of each element in the current set of matched 
		// elements, filtered by a selector.
		Imba.Selector.prototype.find = function (sel){
			this._nodes = this.__query__(sel.query(),this.nodes());
			return this;
		};
		
		Imba.Selector.prototype.reject = function (blk){
			return this.filter(blk,false);
		};
		
		/*
			Filter the nodes in selector by a function or other selector
			*/
		
		Imba.Selector.prototype.filter = function (blk,bool){
			if(bool === undefined) bool = true;
			var fn = (blk instanceof Function) && blk || function(n) { return n.matches(blk); };
			var ary = this.nodes().filter(function(n) { return fn(n) == bool; });
			// if we want to return a new selector for this, we should do that for
			// others as well
			return new Imba.Selector("",this._scope,ary);
		};
		
		Imba.Selector.prototype.__query__ = function (query,contexts){
			var nodes = [];
			var i = 0;
			var l = contexts.length;
			
			while (i < l){
				nodes.push.apply(nodes,contexts[i++].querySelectorAll(query));
			};
			return nodes;
		};
		
		Imba.Selector.prototype.__matches__ = function (){
			return true;
		};
		
		/*
			Add specified flag to all nodes in selector
			*/
		
		Imba.Selector.prototype.flag = function (flag){
			return this.forEach(function(n) { return n.flag(flag); });
		};
		
		/*
			Remove specified flag from all nodes in selector
			*/
		
		Imba.Selector.prototype.unflag = function (flag){
			return this.forEach(function(n) { return n.unflag(flag); });
		};
		
		
		// def Imba.querySelectorAll
		q$ = function(sel,scope) { return new Imba.Selector(sel,scope); };
		
		// def Imba.Selector.one
		q$$ = function(sel,scope) {
			var el = (scope || Imba.document()).querySelector(sel);
			return el && tag$wrap(el) || null;
		};
		
		
		// extending tags with query-methods
		// must be a better way to reopen classes
		return tag$.extendTag('element', function(tag){
			tag.prototype.querySelectorAll = function (q){
				return this._dom.querySelectorAll(q);
			};
			tag.prototype.querySelector = function (q){
				return this._dom.querySelector(q);
			};
			
			// should be moved to Imba.Tag instead?
			// or we should implement all of them here
			tag.prototype.find = function (sel){
				return new Imba.Selector(sel,this);
			};
		});
		
	
	})()

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var util;
		IMDEBUG = true;
		
		// wtf er alt dette?
		IM = {};
		IM.NEWLINE = '\n';
		IM.CHAR = 0;
		IM.WORD_START = 1;
		IM.WORD_END = 2;
		IM.PUNCTUATION_START = 3;
		IM.PUNCTUATION_END = 4;
		IM.SUB_WORD_START = 5;
		IM.SUB_WORD_END = 6;
		IM.LINE_START = 7;
		IM.LINE_END = 8;
		IM.EMPTY_LINE = 9;
		
		IM.FS = __webpack_require__(15);
		
		var SourceMap = __webpack_require__(16);
		
		// if global:require
		var Region = __webpack_require__(27).Region;
		
		__webpack_require__(28);
		
		__webpack_require__(35);
		__webpack_require__(36);
		__webpack_require__(37);
		
		__webpack_require__(38);
		__webpack_require__(39);
		__webpack_require__(45);
		
		var Highlighter = __webpack_require__(29).Highlighter;
		var ImbacWorker = __webpack_require__(46).ImbacWorker;
		
		IM.worker = function (){
			return this._worker || (this._worker = new ImbacWorker());
		};
		
		module.exports.util = util = __webpack_require__(34);
		// nodes
		__webpack_require__(47);
		
		
		function worker(){
			return IM.worker();
		}; exports.worker = worker;
		
		module.exports.SourceMap = SourceMap;
		module.exports.Region = Region;
		return module.exports.Highlighter = Highlighter;
	
	})()

/***/ },
/* 15 */
/***/ function(module, exports) {

	(function(){
		// externs;
		function save(path,content,encoding,cb){
			if(cb==undefined && typeof encoding == 'function') cb = encoding,encoding = 'utf-8';
			if(encoding==undefined) encoding = 'utf-8';
			console.log('save',path,content,encoding);
			
			return xr.post(path,{body: content}).then(function() {
				console.log('responded');
				return cb && cb(arguments);
			});
		}; exports.save = save;
		
		function readFileAsync(path,encoding,cb){
			if(cb==undefined && typeof encoding == 'function') cb = encoding,encoding = 'utf-8';
			if(encoding==undefined) encoding = 'utf-8';
			console.log('save',path,encoding);
			
			return xr.get(path).then(function(res) {
				console.log('responded',res);
				cb && cb(arguments);
				return res;
			});
		}; exports.readFileAsync = readFileAsync;; return readFileAsync;
	
	})()

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(17).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(23).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(26).SourceNode;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var base64VLQ = __webpack_require__(18);
	  var util = __webpack_require__(20);
	  var ArraySet = __webpack_require__(21).ArraySet;
	  var MappingList = __webpack_require__(22).MappingList;
	
	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. You may pass an object with the following
	   * properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: A root for all relative URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    if (!aArgs) {
	      aArgs = {};
	    }
	    this._file = util.getArg(aArgs, 'file', null);
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = new MappingList();
	    this._sourcesContents = null;
	  }
	
	  SourceMapGenerator.prototype._version = 3;
	
	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap =
	    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	      var sourceRoot = aSourceMapConsumer.sourceRoot;
	      var generator = new SourceMapGenerator({
	        file: aSourceMapConsumer.file,
	        sourceRoot: sourceRoot
	      });
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        var newMapping = {
	          generated: {
	            line: mapping.generatedLine,
	            column: mapping.generatedColumn
	          }
	        };
	
	        if (mapping.source != null) {
	          newMapping.source = mapping.source;
	          if (sourceRoot != null) {
	            newMapping.source = util.relative(sourceRoot, newMapping.source);
	          }
	
	          newMapping.original = {
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          };
	
	          if (mapping.name != null) {
	            newMapping.name = mapping.name;
	          }
	        }
	
	        generator.addMapping(newMapping);
	      });
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          generator.setSourceContent(sourceFile, content);
	        }
	      });
	      return generator;
	    };
	
	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping =
	    function SourceMapGenerator_addMapping(aArgs) {
	      var generated = util.getArg(aArgs, 'generated');
	      var original = util.getArg(aArgs, 'original', null);
	      var source = util.getArg(aArgs, 'source', null);
	      var name = util.getArg(aArgs, 'name', null);
	
	      if (!this._skipValidation) {
	        this._validateMapping(generated, original, source, name);
	      }
	
	      if (source != null && !this._sources.has(source)) {
	        this._sources.add(source);
	      }
	
	      if (name != null && !this._names.has(name)) {
	        this._names.add(name);
	      }
	
	      this._mappings.add({
	        generatedLine: generated.line,
	        generatedColumn: generated.column,
	        originalLine: original != null && original.line,
	        originalColumn: original != null && original.column,
	        source: source,
	        name: name
	      });
	    };
	
	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent =
	    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	      var source = aSourceFile;
	      if (this._sourceRoot != null) {
	        source = util.relative(this._sourceRoot, source);
	      }
	
	      if (aSourceContent != null) {
	        // Add the source content to the _sourcesContents map.
	        // Create a new _sourcesContents map if the property is null.
	        if (!this._sourcesContents) {
	          this._sourcesContents = {};
	        }
	        this._sourcesContents[util.toSetString(source)] = aSourceContent;
	      } else if (this._sourcesContents) {
	        // Remove the source file from the _sourcesContents map.
	        // If the _sourcesContents map is empty, set the property to null.
	        delete this._sourcesContents[util.toSetString(source)];
	        if (Object.keys(this._sourcesContents).length === 0) {
	          this._sourcesContents = null;
	        }
	      }
	    };
	
	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   * @param aSourceMapPath Optional. The dirname of the path to the source map
	   *        to be applied. If relative, it is relative to the SourceMapConsumer.
	   *        This parameter is needed when the two source maps aren't in the same
	   *        directory, and the source map to be applied contains relative source
	   *        paths. If so, those relative source paths need to be rewritten
	   *        relative to the SourceMapGenerator.
	   */
	  SourceMapGenerator.prototype.applySourceMap =
	    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	      var sourceFile = aSourceFile;
	      // If aSourceFile is omitted, we will use the file property of the SourceMap
	      if (aSourceFile == null) {
	        if (aSourceMapConsumer.file == null) {
	          throw new Error(
	            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	            'or the source map\'s "file" property. Both were omitted.'
	          );
	        }
	        sourceFile = aSourceMapConsumer.file;
	      }
	      var sourceRoot = this._sourceRoot;
	      // Make "sourceFile" relative if an absolute Url is passed.
	      if (sourceRoot != null) {
	        sourceFile = util.relative(sourceRoot, sourceFile);
	      }
	      // Applying the SourceMap can add and remove items from the sources and
	      // the names array.
	      var newSources = new ArraySet();
	      var newNames = new ArraySet();
	
	      // Find mappings for the "sourceFile"
	      this._mappings.unsortedForEach(function (mapping) {
	        if (mapping.source === sourceFile && mapping.originalLine != null) {
	          // Check if it can be mapped by the source map, then update the mapping.
	          var original = aSourceMapConsumer.originalPositionFor({
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          });
	          if (original.source != null) {
	            // Copy mapping
	            mapping.source = original.source;
	            if (aSourceMapPath != null) {
	              mapping.source = util.join(aSourceMapPath, mapping.source)
	            }
	            if (sourceRoot != null) {
	              mapping.source = util.relative(sourceRoot, mapping.source);
	            }
	            mapping.originalLine = original.line;
	            mapping.originalColumn = original.column;
	            if (original.name != null) {
	              mapping.name = original.name;
	            }
	          }
	        }
	
	        var source = mapping.source;
	        if (source != null && !newSources.has(source)) {
	          newSources.add(source);
	        }
	
	        var name = mapping.name;
	        if (name != null && !newNames.has(name)) {
	          newNames.add(name);
	        }
	
	      }, this);
	      this._sources = newSources;
	      this._names = newNames;
	
	      // Copy sourcesContents of applied map.
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aSourceMapPath != null) {
	            sourceFile = util.join(aSourceMapPath, sourceFile);
	          }
	          if (sourceRoot != null) {
	            sourceFile = util.relative(sourceRoot, sourceFile);
	          }
	          this.setSourceContent(sourceFile, content);
	        }
	      }, this);
	    };
	
	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping =
	    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                                aName) {
	      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	          && aGenerated.line > 0 && aGenerated.column >= 0
	          && !aOriginal && !aSource && !aName) {
	        // Case 1.
	        return;
	      }
	      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	               && aGenerated.line > 0 && aGenerated.column >= 0
	               && aOriginal.line > 0 && aOriginal.column >= 0
	               && aSource) {
	        // Cases 2 and 3.
	        return;
	      }
	      else {
	        throw new Error('Invalid mapping: ' + JSON.stringify({
	          generated: aGenerated,
	          source: aSource,
	          original: aOriginal,
	          name: aName
	        }));
	      }
	    };
	
	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings =
	    function SourceMapGenerator_serializeMappings() {
	      var previousGeneratedColumn = 0;
	      var previousGeneratedLine = 1;
	      var previousOriginalColumn = 0;
	      var previousOriginalLine = 0;
	      var previousName = 0;
	      var previousSource = 0;
	      var result = '';
	      var mapping;
	      var nameIdx;
	      var sourceIdx;
	
	      var mappings = this._mappings.toArray();
	      for (var i = 0, len = mappings.length; i < len; i++) {
	        mapping = mappings[i];
	
	        if (mapping.generatedLine !== previousGeneratedLine) {
	          previousGeneratedColumn = 0;
	          while (mapping.generatedLine !== previousGeneratedLine) {
	            result += ';';
	            previousGeneratedLine++;
	          }
	        }
	        else {
	          if (i > 0) {
	            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	              continue;
	            }
	            result += ',';
	          }
	        }
	
	        result += base64VLQ.encode(mapping.generatedColumn
	                                   - previousGeneratedColumn);
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (mapping.source != null) {
	          sourceIdx = this._sources.indexOf(mapping.source);
	          result += base64VLQ.encode(sourceIdx - previousSource);
	          previousSource = sourceIdx;
	
	          // lines are stored 0-based in SourceMap spec version 3
	          result += base64VLQ.encode(mapping.originalLine - 1
	                                     - previousOriginalLine);
	          previousOriginalLine = mapping.originalLine - 1;
	
	          result += base64VLQ.encode(mapping.originalColumn
	                                     - previousOriginalColumn);
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (mapping.name != null) {
	            nameIdx = this._names.indexOf(mapping.name);
	            result += base64VLQ.encode(nameIdx - previousName);
	            previousName = nameIdx;
	          }
	        }
	      }
	
	      return result;
	    };
	
	  SourceMapGenerator.prototype._generateSourcesContent =
	    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	      return aSources.map(function (source) {
	        if (!this._sourcesContents) {
	          return null;
	        }
	        if (aSourceRoot != null) {
	          source = util.relative(aSourceRoot, source);
	        }
	        var key = util.toSetString(source);
	        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
	                                                    key)
	          ? this._sourcesContents[key]
	          : null;
	      }, this);
	    };
	
	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON =
	    function SourceMapGenerator_toJSON() {
	      var map = {
	        version: this._version,
	        sources: this._sources.toArray(),
	        names: this._names.toArray(),
	        mappings: this._serializeMappings()
	      };
	      if (this._file != null) {
	        map.file = this._file;
	      }
	      if (this._sourceRoot != null) {
	        map.sourceRoot = this._sourceRoot;
	      }
	      if (this._sourcesContents) {
	        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	      }
	
	      return map;
	    };
	
	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString =
	    function SourceMapGenerator_toString() {
	      return JSON.stringify(this.toJSON());
	    };
	
	  exports.SourceMapGenerator = SourceMapGenerator;
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	{
	  var base64 = __webpack_require__(19);
	
	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011
	
	  var VLQ_BASE_SHIFT = 5;
	
	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0
	      ? ((-aValue) << 1) + 1
	      : (aValue << 1) + 0;
	  }
	
	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative
	      ? -shifted
	      : shifted;
	  }
	
	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  exports.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;
	
	    var vlq = toVLQSigned(aValue);
	
	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);
	
	    return encoded;
	  };
	
	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string via the out parameter.
	   */
	  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;
	
	    do {
	      if (aIndex >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	
	      digit = base64.decode(aStr.charCodeAt(aIndex++));
	      if (digit === -1) {
	        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	      }
	
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);
	
	    aOutParam.value = fromVLQSigned(result);
	    aOutParam.rest = aIndex;
	  };
	}


/***/ },
/* 19 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  exports.encode = function (number) {
	    if (0 <= number && number < intToCharMap.length) {
	      return intToCharMap[number];
	    }
	    throw new TypeError("Must be between 0 and 63: " + number);
	  };
	
	  /**
	   * Decode a single base 64 character code digit to an integer. Returns -1 on
	   * failure.
	   */
	  exports.decode = function (charCode) {
	    var bigA = 65;     // 'A'
	    var bigZ = 90;     // 'Z'
	
	    var littleA = 97;  // 'a'
	    var littleZ = 122; // 'z'
	
	    var zero = 48;     // '0'
	    var nine = 57;     // '9'
	
	    var plus = 43;     // '+'
	    var slash = 47;    // '/'
	
	    var littleOffset = 26;
	    var numberOffset = 52;
	
	    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	    if (bigA <= charCode && charCode <= bigZ) {
	      return (charCode - bigA);
	    }
	
	    // 26 - 51: abcdefghijklmnopqrstuvwxyz
	    if (littleA <= charCode && charCode <= littleZ) {
	      return (charCode - littleA + littleOffset);
	    }
	
	    // 52 - 61: 0123456789
	    if (zero <= charCode && charCode <= nine) {
	      return (charCode - zero + numberOffset);
	    }
	
	    // 62: +
	    if (charCode == plus) {
	      return 62;
	    }
	
	    // 63: /
	    if (charCode == slash) {
	      return 63;
	    }
	
	    // Invalid base64 digit.
	    return -1;
	  };
	}


/***/ },
/* 20 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }
	  exports.getArg = getArg;
	
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;
	
	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);
	    if (!match) {
	      return null;
	    }
	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }
	  exports.urlParse = urlParse;
	
	  function urlGenerate(aParsedUrl) {
	    var url = '';
	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }
	    url += '//';
	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }
	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }
	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port
	    }
	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }
	    return url;
	  }
	  exports.urlGenerate = urlGenerate;
	
	  /**
	   * Normalizes a path, or the path portion of a URL:
	   *
	   * - Replaces consequtive slashes with one slash.
	   * - Removes unnecessary '.' parts.
	   * - Removes unnecessary '<dir>/..' parts.
	   *
	   * Based on code in the Node.js 'path' core module.
	   *
	   * @param aPath The path or url to normalize.
	   */
	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);
	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }
	      path = url.path;
	    }
	    var isAbsolute = exports.isAbsolute(path);
	
	    var parts = path.split(/\/+/);
	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];
	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          // The first part is blank if the path is absolute. Trying to go
	          // above the root is a no-op. Therefore we can remove all '..' parts
	          // directly after the root.
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }
	    path = parts.join('/');
	
	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }
	
	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }
	    return path;
	  }
	  exports.normalize = normalize;
	
	  /**
	   * Joins two paths/URLs.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be joined with the root.
	   *
	   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	   *   first.
	   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	   *   is updated with the result and aRoot is returned. Otherwise the result
	   *   is returned.
	   *   - If aPath is absolute, the result is aPath.
	   *   - Otherwise the two paths are joined with a slash.
	   * - Joining for example 'http://' and 'www.example.com' is also supported.
	   */
	  function join(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	    if (aPath === "") {
	      aPath = ".";
	    }
	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);
	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    }
	
	    // `join(foo, '//www.example.org')`
	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }
	      return urlGenerate(aPathUrl);
	    }
	
	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }
	
	    // `join('http://', 'www.example.com')`
	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }
	
	    var joined = aPath.charAt(0) === '/'
	      ? aPath
	      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }
	    return joined;
	  }
	  exports.join = join;
	
	  exports.isAbsolute = function (aPath) {
	    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	  };
	
	  /**
	   * Make a path relative to a URL or another path.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be made relative to aRoot.
	   */
	  function relative(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	
	    aRoot = aRoot.replace(/\/$/, '');
	
	    // It is possible for the path to be above the root. In this case, simply
	    // checking whether the root is a prefix of the path won't work. Instead, we
	    // need to remove components from the root one by one, until either we find
	    // a prefix that fits, or we run out of components to remove.
	    var level = 0;
	    while (aPath.indexOf(aRoot + '/') !== 0) {
	      var index = aRoot.lastIndexOf("/");
	      if (index < 0) {
	        return aPath;
	      }
	
	      // If the only part of the root that is left is the scheme (i.e. http://,
	      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	      // have exhausted all components, so the path is not relative to the root.
	      aRoot = aRoot.slice(0, index);
	      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	        return aPath;
	      }
	
	      ++level;
	    }
	
	    // Make sure we add a "../" for each component we removed from the root.
	    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	  }
	  exports.relative = relative;
	
	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */
	  function toSetString(aStr) {
	    return '$' + aStr;
	  }
	  exports.toSetString = toSetString;
	
	  function fromSetString(aStr) {
	    return aStr.substr(1);
	  }
	  exports.fromSetString = fromSetString;
	
	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */
	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0 || onlyCompareOriginal) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  }
	  exports.compareByOriginalPositions = compareByOriginalPositions;
	
	  /**
	   * Comparator between two mappings with deflated source and name indices where
	   * the generated positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */
	  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0 || onlyCompareGenerated) {
	      return cmp;
	    }
	
	    cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  }
	  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	  function strcmp(aStr1, aStr2) {
	    if (aStr1 === aStr2) {
	      return 0;
	    }
	
	    if (aStr1 > aStr2) {
	      return 1;
	    }
	
	    return -1;
	  }
	
	  /**
	   * Comparator between two mappings with inflated source and name strings where
	   * the generated positions are compared.
	   */
	  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return strcmp(mappingA.name, mappingB.name);
	  }
	  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	
	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = {};
	  }
	
	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };
	
	  /**
	   * Return how many unique items are in this ArraySet. If duplicates have been
	   * added, than those do not count towards the size.
	   *
	   * @returns Number
	   */
	  ArraySet.prototype.size = function ArraySet_size() {
	    return Object.getOwnPropertyNames(this._set).length;
	  };
	
	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var sStr = util.toSetString(aStr);
	    var isDuplicate = this._set.hasOwnProperty(sStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      this._set[sStr] = idx;
	    }
	  };
	
	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    var sStr = util.toSetString(aStr);
	    return this._set.hasOwnProperty(sStr);
	  };
	
	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    var sStr = util.toSetString(aStr);
	    if (this._set.hasOwnProperty(sStr)) {
	      return this._set[sStr];
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };
	
	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };
	
	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };
	
	  exports.ArraySet = ArraySet;
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	
	  /**
	   * Determine whether mappingB is after mappingA with respect to generated
	   * position.
	   */
	  function generatedPositionAfter(mappingA, mappingB) {
	    // Optimized for most common case
	    var lineA = mappingA.generatedLine;
	    var lineB = mappingB.generatedLine;
	    var columnA = mappingA.generatedColumn;
	    var columnB = mappingB.generatedColumn;
	    return lineB > lineA || lineB == lineA && columnB >= columnA ||
	           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	  }
	
	  /**
	   * A data structure to provide a sorted view of accumulated mappings in a
	   * performance conscious manner. It trades a neglibable overhead in general
	   * case for a large speedup in case of mappings being added in order.
	   */
	  function MappingList() {
	    this._array = [];
	    this._sorted = true;
	    // Serves as infimum
	    this._last = {generatedLine: -1, generatedColumn: 0};
	  }
	
	  /**
	   * Iterate through internal items. This method takes the same arguments that
	   * `Array.prototype.forEach` takes.
	   *
	   * NOTE: The order of the mappings is NOT guaranteed.
	   */
	  MappingList.prototype.unsortedForEach =
	    function MappingList_forEach(aCallback, aThisArg) {
	      this._array.forEach(aCallback, aThisArg);
	    };
	
	  /**
	   * Add the given source mapping.
	   *
	   * @param Object aMapping
	   */
	  MappingList.prototype.add = function MappingList_add(aMapping) {
	    if (generatedPositionAfter(this._last, aMapping)) {
	      this._last = aMapping;
	      this._array.push(aMapping);
	    } else {
	      this._sorted = false;
	      this._array.push(aMapping);
	    }
	  };
	
	  /**
	   * Returns the flat, sorted array of mappings. The mappings are sorted by
	   * generated position.
	   *
	   * WARNING: This method returns internal data without copying, for
	   * performance. The return value must NOT be mutated, and should be treated as
	   * an immutable borrow. If you want to take ownership, you must make your own
	   * copy.
	   */
	  MappingList.prototype.toArray = function MappingList_toArray() {
	    if (!this._sorted) {
	      this._array.sort(util.compareByGeneratedPositionsInflated);
	      this._sorted = true;
	    }
	    return this._array;
	  };
	
	  exports.MappingList = MappingList;
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	  var binarySearch = __webpack_require__(24);
	  var ArraySet = __webpack_require__(21).ArraySet;
	  var base64VLQ = __webpack_require__(18);
	  var quickSort = __webpack_require__(25).quickSort;
	
	  function SourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    return sourceMap.sections != null
	      ? new IndexedSourceMapConsumer(sourceMap)
	      : new BasicSourceMapConsumer(sourceMap);
	  }
	
	  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	  }
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;
	
	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.
	
	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    get: function () {
	      if (!this.__generatedMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__generatedMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    get: function () {
	      if (!this.__originalMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__originalMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype._charIsMappingSeparator =
	    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	      var c = aStr.charAt(index);
	      return c === ";" || c === ",";
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      throw new Error("Subclasses must implement _parseMappings");
	    };
	
	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping =
	    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	      var context = aContext || null;
	      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	      var mappings;
	      switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	      }
	
	      var sourceRoot = this.sourceRoot;
	      mappings.map(function (mapping) {
	        var source = mapping.source === null ? null : this._sources.at(mapping.source);
	        if (source != null && sourceRoot != null) {
	          source = util.join(sourceRoot, source);
	        }
	        return {
	          source: source,
	          generatedLine: mapping.generatedLine,
	          generatedColumn: mapping.generatedColumn,
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: mapping.name === null ? null : this._names.at(mapping.name)
	        };
	      }, this).forEach(aCallback, context);
	    };
	
	  /**
	   * Returns all generated line and column information for the original source,
	   * line, and column provided. If no column is provided, returns all mappings
	   * corresponding to a either the line we are searching for or the next
	   * closest line that has any mappings. Otherwise, returns all mappings
	   * corresponding to the given line and either the column we are searching for
	   * or the next closest column that has any offsets.
	   *
	   * The only argument is an object with the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: Optional. the column number in the original source.
	   *
	   * and an array of objects is returned, each with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  SourceMapConsumer.prototype.allGeneratedPositionsFor =
	    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	      var line = util.getArg(aArgs, 'line');
	
	      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	      // returns the index of the closest mapping less than the needle. By
	      // setting needle.originalColumn to 0, we thus find the last mapping for
	      // the given line, provided such a mapping exists.
	      var needle = {
	        source: util.getArg(aArgs, 'source'),
	        originalLine: line,
	        originalColumn: util.getArg(aArgs, 'column', 0)
	      };
	
	      if (this.sourceRoot != null) {
	        needle.source = util.relative(this.sourceRoot, needle.source);
	      }
	      if (!this._sources.has(needle.source)) {
	        return [];
	      }
	      needle.source = this._sources.indexOf(needle.source);
	
	      var mappings = [];
	
	      var index = this._findMapping(needle,
	                                    this._originalMappings,
	                                    "originalLine",
	                                    "originalColumn",
	                                    util.compareByOriginalPositions,
	                                    binarySearch.LEAST_UPPER_BOUND);
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (aArgs.column === undefined) {
	          var originalLine = mapping.originalLine;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we found. Since
	          // mappings are sorted, this is guaranteed to find all mappings for
	          // the line we found.
	          while (mapping && mapping.originalLine === originalLine) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        } else {
	          var originalColumn = mapping.originalColumn;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we were searching for.
	          // Since mappings are sorted, this is guaranteed to find all mappings for
	          // the line we are searching for.
	          while (mapping &&
	                 mapping.originalLine === line &&
	                 mapping.originalColumn == originalColumn) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        }
	      }
	
	      return mappings;
	    };
	
	  exports.SourceMapConsumer = SourceMapConsumer;
	
	  /**
	   * A BasicSourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The only parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: Optional. The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function BasicSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);
	
	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    sources = sources
	      // Some source maps produce relative source paths like "./foo.js" instead of
	      // "foo.js".  Normalize these first so that future comparisons will succeed.
	      // See bugzil.la/1090768.
	      .map(util.normalize)
	      // Always ensure that absolute sources are internally stored relative to
	      // the source root, if the source root is absolute. Not doing this would
	      // be particularly problematic when the source root is a prefix of the
	      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	      .map(function (source) {
	        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	          ? util.relative(sourceRoot, source)
	          : source;
	      });
	
	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names, true);
	    this._sources = ArraySet.fromArray(sources, true);
	
	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this.file = file;
	  }
	
	  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	  /**
	   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @returns BasicSourceMapConsumer
	   */
	  BasicSourceMapConsumer.fromSourceMap =
	    function SourceMapConsumer_fromSourceMap(aSourceMap) {
	      var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	      smc.sourceRoot = aSourceMap._sourceRoot;
	      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                              smc.sourceRoot);
	      smc.file = aSourceMap._file;
	
	      // Because we are modifying the entries (by converting string sources and
	      // names to indices into the sources and names ArraySets), we have to make
	      // a copy of the entry or else bad things happen. Shared mutable state
	      // strikes again! See github issue #191.
	
	      var generatedMappings = aSourceMap._mappings.toArray().slice();
	      var destGeneratedMappings = smc.__generatedMappings = [];
	      var destOriginalMappings = smc.__originalMappings = [];
	
	      for (var i = 0, length = generatedMappings.length; i < length; i++) {
	        var srcMapping = generatedMappings[i];
	        var destMapping = new Mapping;
	        destMapping.generatedLine = srcMapping.generatedLine;
	        destMapping.generatedColumn = srcMapping.generatedColumn;
	
	        if (srcMapping.source) {
	          destMapping.source = sources.indexOf(srcMapping.source);
	          destMapping.originalLine = srcMapping.originalLine;
	          destMapping.originalColumn = srcMapping.originalColumn;
	
	          if (srcMapping.name) {
	            destMapping.name = names.indexOf(srcMapping.name);
	          }
	
	          destOriginalMappings.push(destMapping);
	        }
	
	        destGeneratedMappings.push(destMapping);
	      }
	
	      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	      return smc;
	    };
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  BasicSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._sources.toArray().map(function (s) {
	        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	      }, this);
	    }
	  });
	
	  /**
	   * Provide the JIT with a nice shape / hidden class.
	   */
	  function Mapping() {
	    this.generatedLine = 0;
	    this.generatedColumn = 0;
	    this.source = null;
	    this.originalLine = null;
	    this.originalColumn = null;
	    this.name = null;
	  }
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  BasicSourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      var generatedLine = 1;
	      var previousGeneratedColumn = 0;
	      var previousOriginalLine = 0;
	      var previousOriginalColumn = 0;
	      var previousSource = 0;
	      var previousName = 0;
	      var length = aStr.length;
	      var index = 0;
	      var cachedSegments = {};
	      var temp = {};
	      var originalMappings = [];
	      var generatedMappings = [];
	      var mapping, str, segment, end, value;
	
	      while (index < length) {
	        if (aStr.charAt(index) === ';') {
	          generatedLine++;
	          index++;
	          previousGeneratedColumn = 0;
	        }
	        else if (aStr.charAt(index) === ',') {
	          index++;
	        }
	        else {
	          mapping = new Mapping();
	          mapping.generatedLine = generatedLine;
	
	          // Because each offset is encoded relative to the previous one,
	          // many segments often have the same encoding. We can exploit this
	          // fact by caching the parsed variable length fields of each segment,
	          // allowing us to avoid a second parse if we encounter the same
	          // segment again.
	          for (end = index; end < length; end++) {
	            if (this._charIsMappingSeparator(aStr, end)) {
	              break;
	            }
	          }
	          str = aStr.slice(index, end);
	
	          segment = cachedSegments[str];
	          if (segment) {
	            index += str.length;
	          } else {
	            segment = [];
	            while (index < end) {
	              base64VLQ.decode(aStr, index, temp);
	              value = temp.value;
	              index = temp.rest;
	              segment.push(value);
	            }
	
	            if (segment.length === 2) {
	              throw new Error('Found a source, but no line and column');
	            }
	
	            if (segment.length === 3) {
	              throw new Error('Found a source and line, but no column');
	            }
	
	            cachedSegments[str] = segment;
	          }
	
	          // Generated column.
	          mapping.generatedColumn = previousGeneratedColumn + segment[0];
	          previousGeneratedColumn = mapping.generatedColumn;
	
	          if (segment.length > 1) {
	            // Original source.
	            mapping.source = previousSource + segment[1];
	            previousSource += segment[1];
	
	            // Original line.
	            mapping.originalLine = previousOriginalLine + segment[2];
	            previousOriginalLine = mapping.originalLine;
	            // Lines are stored 0-based
	            mapping.originalLine += 1;
	
	            // Original column.
	            mapping.originalColumn = previousOriginalColumn + segment[3];
	            previousOriginalColumn = mapping.originalColumn;
	
	            if (segment.length > 4) {
	              // Original name.
	              mapping.name = previousName + segment[4];
	              previousName += segment[4];
	            }
	          }
	
	          generatedMappings.push(mapping);
	          if (typeof mapping.originalLine === 'number') {
	            originalMappings.push(mapping);
	          }
	        }
	      }
	
	      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	      this.__generatedMappings = generatedMappings;
	
	      quickSort(originalMappings, util.compareByOriginalPositions);
	      this.__originalMappings = originalMappings;
	    };
	
	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  BasicSourceMapConsumer.prototype._findMapping =
	    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                           aColumnName, aComparator, aBias) {
	      // To return the position we are searching for, we must first find the
	      // mapping for the given position and then return the opposite position it
	      // points to. Because the mappings are sorted, we can use binary search to
	      // find the best mapping.
	
	      if (aNeedle[aLineName] <= 0) {
	        throw new TypeError('Line must be greater than or equal to 1, got '
	                            + aNeedle[aLineName]);
	      }
	      if (aNeedle[aColumnName] < 0) {
	        throw new TypeError('Column must be greater than or equal to 0, got '
	                            + aNeedle[aColumnName]);
	      }
	
	      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	    };
	
	  /**
	   * Compute the last column for each generated mapping. The last column is
	   * inclusive.
	   */
	  BasicSourceMapConsumer.prototype.computeColumnSpans =
	    function SourceMapConsumer_computeColumnSpans() {
	      for (var index = 0; index < this._generatedMappings.length; ++index) {
	        var mapping = this._generatedMappings[index];
	
	        // Mappings do not contain a field for the last generated columnt. We
	        // can come up with an optimistic estimate, however, by assuming that
	        // mappings are contiguous (i.e. given two consecutive mappings, the
	        // first mapping ends where the second one starts).
	        if (index + 1 < this._generatedMappings.length) {
	          var nextMapping = this._generatedMappings[index + 1];
	
	          if (mapping.generatedLine === nextMapping.generatedLine) {
	            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	            continue;
	          }
	        }
	
	        // The last mapping for each line spans the entire line.
	        mapping.lastGeneratedColumn = Infinity;
	      }
	    };
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  BasicSourceMapConsumer.prototype.originalPositionFor =
	    function SourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._generatedMappings,
	        "generatedLine",
	        "generatedColumn",
	        util.compareByGeneratedPositionsDeflated,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._generatedMappings[index];
	
	        if (mapping.generatedLine === needle.generatedLine) {
	          var source = util.getArg(mapping, 'source', null);
	          if (source !== null) {
	            source = this._sources.at(source);
	            if (this.sourceRoot != null) {
	              source = util.join(this.sourceRoot, source);
	            }
	          }
	          var name = util.getArg(mapping, 'name', null);
	          if (name !== null) {
	            name = this._names.at(name);
	          }
	          return {
	            source: source,
	            line: util.getArg(mapping, 'originalLine', null),
	            column: util.getArg(mapping, 'originalColumn', null),
	            name: name
	          };
	        }
	      }
	
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function BasicSourceMapConsumer_hasContentsOfAllSources() {
	      if (!this.sourcesContent) {
	        return false;
	      }
	      return this.sourcesContent.length >= this._sources.size() &&
	        !this.sourcesContent.some(function (sc) { return sc == null; });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  BasicSourceMapConsumer.prototype.sourceContentFor =
	    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      if (!this.sourcesContent) {
	        return null;
	      }
	
	      if (this.sourceRoot != null) {
	        aSource = util.relative(this.sourceRoot, aSource);
	      }
	
	      if (this._sources.has(aSource)) {
	        return this.sourcesContent[this._sources.indexOf(aSource)];
	      }
	
	      var url;
	      if (this.sourceRoot != null
	          && (url = util.urlParse(this.sourceRoot))) {
	        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	        // many users. We can help them out when they expect file:// URIs to
	        // behave like it would if they were running a local HTTP server. See
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	        if (url.scheme == "file"
	            && this._sources.has(fileUriAbsPath)) {
	          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	        }
	
	        if ((!url.path || url.path == "/")
	            && this._sources.has("/" + aSource)) {
	          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	        }
	      }
	
	      // This function is used recursively from
	      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	      // don't want to throw if we can't find the source - we just want to
	      // return null, so we provide a flag to exit gracefully.
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  BasicSourceMapConsumer.prototype.generatedPositionFor =
	    function SourceMapConsumer_generatedPositionFor(aArgs) {
	      var source = util.getArg(aArgs, 'source');
	      if (this.sourceRoot != null) {
	        source = util.relative(this.sourceRoot, source);
	      }
	      if (!this._sources.has(source)) {
	        return {
	          line: null,
	          column: null,
	          lastColumn: null
	        };
	      }
	      source = this._sources.indexOf(source);
	
	      var needle = {
	        source: source,
	        originalLine: util.getArg(aArgs, 'line'),
	        originalColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._originalMappings,
	        "originalLine",
	        "originalColumn",
	        util.compareByOriginalPositions,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (mapping.source === needle.source) {
	          return {
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          };
	        }
	      }
	
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    };
	
	  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	  /**
	   * An IndexedSourceMapConsumer instance represents a parsed source map which
	   * we can query for information. It differs from BasicSourceMapConsumer in
	   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	   * input.
	   *
	   * The only parameter is a raw source map (either as a JSON string, or already
	   * parsed to an object). According to the spec for indexed source maps, they
	   * have the following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - file: Optional. The generated file this source map is associated with.
	   *   - sections: A list of section definitions.
	   *
	   * Each value under the "sections" field has two fields:
	   *   - offset: The offset into the original specified at which this section
	   *       begins to apply, defined as an object with a "line" and "column"
	   *       field.
	   *   - map: A source map definition. This source map could also be indexed,
	   *       but doesn't have to be.
	   *
	   * Instead of the "map" field, it's also possible to have a "url" field
	   * specifying a URL to retrieve a source map from, but that's currently
	   * unsupported.
	   *
	   * Here's an example source map, taken from the source map spec[0], but
	   * modified to omit a section which uses the "url" field.
	   *
	   *  {
	   *    version : 3,
	   *    file: "app.js",
	   *    sections: [{
	   *      offset: {line:100, column:10},
	   *      map: {
	   *        version : 3,
	   *        file: "section.js",
	   *        sources: ["foo.js", "bar.js"],
	   *        names: ["src", "maps", "are", "fun"],
	   *        mappings: "AAAA,E;;ABCDE;"
	   *      }
	   *    }],
	   *  }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	   */
	  function IndexedSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sections = util.getArg(sourceMap, 'sections');
	
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	
	    var lastOffset = {
	      line: -1,
	      column: 0
	    };
	    this._sections = sections.map(function (s) {
	      if (s.url) {
	        // The url field will require support for asynchronicity.
	        // See https://github.com/mozilla/source-map/issues/16
	        throw new Error('Support for url field in sections not implemented.');
	      }
	      var offset = util.getArg(s, 'offset');
	      var offsetLine = util.getArg(offset, 'line');
	      var offsetColumn = util.getArg(offset, 'column');
	
	      if (offsetLine < lastOffset.line ||
	          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	        throw new Error('Section offsets must be ordered and non-overlapping.');
	      }
	      lastOffset = offset;
	
	      return {
	        generatedOffset: {
	          // The offset fields are 0-based, but we use 1-based indices when
	          // encoding/decoding from VLQ.
	          generatedLine: offsetLine + 1,
	          generatedColumn: offsetColumn + 1
	        },
	        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	      }
	    });
	  }
	
	  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  IndexedSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      var sources = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	          sources.push(this._sections[i].consumer.sources[j]);
	        }
	      }
	      return sources;
	    }
	  });
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  IndexedSourceMapConsumer.prototype.originalPositionFor =
	    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      // Find the section containing the generated position we're trying to map
	      // to an original position.
	      var sectionIndex = binarySearch.search(needle, this._sections,
	        function(needle, section) {
	          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	          if (cmp) {
	            return cmp;
	          }
	
	          return (needle.generatedColumn -
	                  section.generatedOffset.generatedColumn);
	        });
	      var section = this._sections[sectionIndex];
	
	      if (!section) {
	        return {
	          source: null,
	          line: null,
	          column: null,
	          name: null
	        };
	      }
	
	      return section.consumer.originalPositionFor({
	        line: needle.generatedLine -
	          (section.generatedOffset.generatedLine - 1),
	        column: needle.generatedColumn -
	          (section.generatedOffset.generatedLine === needle.generatedLine
	           ? section.generatedOffset.generatedColumn - 1
	           : 0),
	        bias: aArgs.bias
	      });
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	      return this._sections.every(function (s) {
	        return s.consumer.hasContentsOfAllSources();
	      });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  IndexedSourceMapConsumer.prototype.sourceContentFor =
	    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        var content = section.consumer.sourceContentFor(aSource, true);
	        if (content) {
	          return content;
	        }
	      }
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  IndexedSourceMapConsumer.prototype.generatedPositionFor =
	    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        // Only consider this section if the requested source is in the list of
	        // sources of the consumer.
	        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	          continue;
	        }
	        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	        if (generatedPosition) {
	          var ret = {
	            line: generatedPosition.line +
	              (section.generatedOffset.generatedLine - 1),
	            column: generatedPosition.column +
	              (section.generatedOffset.generatedLine === generatedPosition.line
	               ? section.generatedOffset.generatedColumn - 1
	               : 0)
	          };
	          return ret;
	        }
	      }
	
	      return {
	        line: null,
	        column: null
	      };
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  IndexedSourceMapConsumer.prototype._parseMappings =
	    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      this.__generatedMappings = [];
	      this.__originalMappings = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	        var sectionMappings = section.consumer._generatedMappings;
	        for (var j = 0; j < sectionMappings.length; j++) {
	          var mapping = sectionMappings[j];
	
	          var source = section.consumer._sources.at(mapping.source);
	          if (section.consumer.sourceRoot !== null) {
	            source = util.join(section.consumer.sourceRoot, source);
	          }
	          this._sources.add(source);
	          source = this._sources.indexOf(source);
	
	          var name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	
	          // The mappings coming from the consumer for the section have
	          // generated positions relative to the start of the section, so we
	          // need to offset them to be relative to the start of the concatenated
	          // generated file.
	          var adjustedMapping = {
	            source: source,
	            generatedLine: mapping.generatedLine +
	              (section.generatedOffset.generatedLine - 1),
	            generatedColumn: mapping.generatedColumn +
	              (section.generatedOffset.generatedLine === mapping.generatedLine
	              ? section.generatedOffset.generatedColumn - 1
	              : 0),
	            originalLine: mapping.originalLine,
	            originalColumn: mapping.originalColumn,
	            name: name
	          };
	
	          this.__generatedMappings.push(adjustedMapping);
	          if (typeof adjustedMapping.originalLine === 'number') {
	            this.__originalMappings.push(adjustedMapping);
	          }
	        }
	      }
	
	      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	      quickSort(this.__originalMappings, util.compareByOriginalPositions);
	    };
	
	  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	}


/***/ },
/* 24 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  exports.GREATEST_LOWER_BOUND = 1;
	  exports.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Recursive implementation of binary search.
	   *
	   * @param aLow Indices here and lower do not contain the needle.
	   * @param aHigh Indices here and higher do not contain the needle.
	   * @param aNeedle The element being searched for.
	   * @param aHaystack The non-empty array being searched.
	   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   */
	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	    // This function terminates when one of the following is true:
	    //
	    //   1. We find the exact element we are looking for.
	    //
	    //   2. We did not find the exact element, but we can return the index of
	    //      the next-closest element.
	    //
	    //   3. We did not find the exact element, and there is no next-closest
	    //      element than the one we are searching for, so we return -1.
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);
	    if (cmp === 0) {
	      // Found the element we are looking for.
	      return mid;
	    }
	    else if (cmp > 0) {
	      // Our needle is greater than aHaystack[mid].
	      if (aHigh - mid > 1) {
	        // The element is in the upper half.
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // The exact needle element was not found in this haystack. Determine if
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return aHigh < aHaystack.length ? aHigh : -1;
	      } else {
	        return mid;
	      }
	    }
	    else {
	      // Our needle is less than aHaystack[mid].
	      if (mid - aLow > 1) {
	        // The element is in the lower half.
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return mid;
	      } else {
	        return aLow < 0 ? -1 : aLow;
	      }
	    }
	  }
	
	  /**
	   * This is an implementation of binary search which will always try and return
	   * the index of the closest element if there is no exact hit. This is because
	   * mappings between original and generated line/col pairs are single points,
	   * and there is an implicit region between each of them, so a miss just means
	   * that you aren't on the very start of a region.
	   *
	   * @param aNeedle The element you are looking for.
	   * @param aHaystack The array that is being searched.
	   * @param aCompare A function which takes the needle and an element in the
	   *     array and returns -1, 0, or 1 depending on whether the needle is less
	   *     than, equal to, or greater than the element, respectively.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	   */
	  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	    if (aHaystack.length === 0) {
	      return -1;
	    }
	
	    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	    if (index < 0) {
	      return -1;
	    }
	
	    // We have found either the exact element, or the next-closest element than
	    // the one we are searching for. However, there may be more than one such
	    // element. Make sure we always return the smallest of these.
	    while (index - 1 >= 0) {
	      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	        break;
	      }
	      --index;
	    }
	
	    return index;
	  };
	}


/***/ },
/* 25 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  // It turns out that some (most?) JavaScript engines don't self-host
	  // `Array.prototype.sort`. This makes sense because C++ will likely remain
	  // faster than JS when doing raw CPU-intensive sorting. However, when using a
	  // custom comparator function, calling back and forth between the VM's C++ and
	  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
	  // worse generated code for the comparator function than would be optimal. In
	  // fact, when sorting with a comparator, these costs outweigh the benefits of
	  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	  // a ~3500ms mean speed-up in `bench/bench.html`.
	
	  /**
	   * Swap the elements indexed by `x` and `y` in the array `ary`.
	   *
	   * @param {Array} ary
	   *        The array.
	   * @param {Number} x
	   *        The index of the first item.
	   * @param {Number} y
	   *        The index of the second item.
	   */
	  function swap(ary, x, y) {
	    var temp = ary[x];
	    ary[x] = ary[y];
	    ary[y] = temp;
	  }
	
	  /**
	   * Returns a random integer within the range `low .. high` inclusive.
	   *
	   * @param {Number} low
	   *        The lower bound on the range.
	   * @param {Number} high
	   *        The upper bound on the range.
	   */
	  function randomIntInRange(low, high) {
	    return Math.round(low + (Math.random() * (high - low)));
	  }
	
	  /**
	   * The Quick Sort algorithm.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   * @param {Number} p
	   *        Start index of the array
	   * @param {Number} r
	   *        End index of the array
	   */
	  function doQuickSort(ary, comparator, p, r) {
	    // If our lower bound is less than our upper bound, we (1) partition the
	    // array into two pieces and (2) recurse on each half. If it is not, this is
	    // the empty array and our base case.
	
	    if (p < r) {
	      // (1) Partitioning.
	      //
	      // The partitioning chooses a pivot between `p` and `r` and moves all
	      // elements that are less than or equal to the pivot to the before it, and
	      // all the elements that are greater than it after it. The effect is that
	      // once partition is done, the pivot is in the exact place it will be when
	      // the array is put in sorted order, and it will not need to be moved
	      // again. This runs in O(n) time.
	
	      // Always choose a random pivot so that an input array which is reverse
	      // sorted does not cause O(n^2) running time.
	      var pivotIndex = randomIntInRange(p, r);
	      var i = p - 1;
	
	      swap(ary, pivotIndex, r);
	      var pivot = ary[r];
	
	      // Immediately after `j` is incremented in this loop, the following hold
	      // true:
	      //
	      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	      //
	      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	      for (var j = p; j < r; j++) {
	        if (comparator(ary[j], pivot) <= 0) {
	          i += 1;
	          swap(ary, i, j);
	        }
	      }
	
	      swap(ary, i + 1, j);
	      var q = i + 1;
	
	      // (2) Recurse on each half.
	
	      doQuickSort(ary, comparator, p, q - 1);
	      doQuickSort(ary, comparator, q + 1, r);
	    }
	  }
	
	  /**
	   * Sort the given array in-place with the given comparator function.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   */
	  exports.quickSort = function (ary, comparator) {
	    doQuickSort(ary, comparator, 0, ary.length - 1);
	  };
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var SourceMapGenerator = __webpack_require__(17).SourceMapGenerator;
	  var util = __webpack_require__(20);
	
	  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	  // operating systems these days (capturing the result).
	  var REGEX_NEWLINE = /(\r?\n)/;
	
	  // Newline character code for charCodeAt() comparisons
	  var NEWLINE_CODE = 10;
	
	  // Private symbol for identifying `SourceNode`s when multiple versions of
	  // the source-map library are loaded. This MUST NOT CHANGE across
	  // versions!
	  var isSourceNode = "$$$isSourceNode$$$";
	
	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine == null ? null : aLine;
	    this.column = aColumn == null ? null : aColumn;
	    this.source = aSource == null ? null : aSource;
	    this.name = aName == null ? null : aName;
	    this[isSourceNode] = true;
	    if (aChunks != null) this.add(aChunks);
	  }
	
	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   * @param aRelativePath Optional. The path that relative sources in the
	   *        SourceMapConsumer should be relative to.
	   */
	  SourceNode.fromStringWithSourceMap =
	    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	      // The SourceNode we want to fill with the generated code
	      // and the SourceMap
	      var node = new SourceNode();
	
	      // All even indices of this array are one line of the generated code,
	      // while all odd indices are the newlines between two adjacent lines
	      // (since `REGEX_NEWLINE` captures its match).
	      // Processed fragments are removed from this array, by calling `shiftNextLine`.
	      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	      var shiftNextLine = function() {
	        var lineContents = remainingLines.shift();
	        // The last line of a file might not have a newline.
	        var newLine = remainingLines.shift() || "";
	        return lineContents + newLine;
	      };
	
	      // We need to remember the position of "remainingLines"
	      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	      // The generate SourceNodes we need a code range.
	      // To extract it current and last mapping is used.
	      // Here we store the last mapping.
	      var lastMapping = null;
	
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        if (lastMapping !== null) {
	          // We add the code from "lastMapping" to "mapping":
	          // First check if there is a new line in between.
	          if (lastGeneratedLine < mapping.generatedLine) {
	            // Associate first line with "lastMapping"
	            addMappingWithCode(lastMapping, shiftNextLine());
	            lastGeneratedLine++;
	            lastGeneratedColumn = 0;
	            // The remaining code is added without mapping
	          } else {
	            // There is no new line in between.
	            // Associate the code between "lastGeneratedColumn" and
	            // "mapping.generatedColumn" with "lastMapping"
	            var nextLine = remainingLines[0];
	            var code = nextLine.substr(0, mapping.generatedColumn -
	                                          lastGeneratedColumn);
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                                lastGeneratedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	            addMappingWithCode(lastMapping, code);
	            // No more remaining code, continue
	            lastMapping = mapping;
	            return;
	          }
	        }
	        // We add the generated code until the first mapping
	        // to the SourceNode without any mapping.
	        // Each line is added as separate string.
	        while (lastGeneratedLine < mapping.generatedLine) {
	          node.add(shiftNextLine());
	          lastGeneratedLine++;
	        }
	        if (lastGeneratedColumn < mapping.generatedColumn) {
	          var nextLine = remainingLines[0];
	          node.add(nextLine.substr(0, mapping.generatedColumn));
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	        }
	        lastMapping = mapping;
	      }, this);
	      // We have processed all mappings.
	      if (remainingLines.length > 0) {
	        if (lastMapping) {
	          // Associate the remaining code in the current line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	        }
	        // and add the remaining lines without any mapping
	        node.add(remainingLines.join(""));
	      }
	
	      // Copy sourcesContent into SourceNode
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aRelativePath != null) {
	            sourceFile = util.join(aRelativePath, sourceFile);
	          }
	          node.setSourceContent(sourceFile, content);
	        }
	      });
	
	      return node;
	
	      function addMappingWithCode(mapping, code) {
	        if (mapping === null || mapping.source === undefined) {
	          node.add(code);
	        } else {
	          var source = aRelativePath
	            ? util.join(aRelativePath, mapping.source)
	            : mapping.source;
	          node.add(new SourceNode(mapping.originalLine,
	                                  mapping.originalColumn,
	                                  source,
	                                  code,
	                                  mapping.name));
	        }
	      }
	    };
	
	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length-1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk[isSourceNode]) {
	        chunk.walk(aFn);
	      }
	      else {
	        if (chunk !== '') {
	          aFn(chunk, { source: this.source,
	                       line: this.line,
	                       column: this.column,
	                       name: this.name });
	        }
	      }
	    }
	  };
	
	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len-1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };
	
	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild[isSourceNode]) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    }
	    else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    }
	    else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };
	
	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent =
	    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	    };
	
	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents =
	    function SourceNode_walkSourceContents(aFn) {
	      for (var i = 0, len = this.children.length; i < len; i++) {
	        if (this.children[i][isSourceNode]) {
	          this.children[i].walkSourceContents(aFn);
	        }
	      }
	
	      var sources = Object.keys(this.sourceContents);
	      for (var i = 0, len = sources.length; i < len; i++) {
	        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	      }
	    };
	
	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };
	
	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null
	          && original.line !== null
	          && original.column !== null) {
	        if(lastOriginalSource !== original.source
	           || lastOriginalLine !== original.line
	           || lastOriginalColumn !== original.column
	           || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      for (var idx = 0, length = chunk.length; idx < length; idx++) {
	        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	          generated.line++;
	          generated.column = 0;
	          // Mappings end at eol
	          if (idx + 1 === length) {
	            lastOriginalSource = null;
	            sourceMappingActive = false;
	          } else if (sourceMappingActive) {
	            map.addMapping({
	              source: original.source,
	              original: {
	                line: original.line,
	                column: original.column
	              },
	              generated: {
	                line: generated.line,
	                column: generated.column
	              },
	              name: original.name
	            });
	          }
	        } else {
	          generated.column++;
	        }
	      }
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });
	
	    return { code: generated.code, map: map };
	  };
	
	  exports.SourceNode = SourceNode;
	}


/***/ },
/* 27 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		
		function Region(a,b,root,view){
			this._a = a;
			this._b = b;
			this._root = root;
			this._view = view;
			return this;
		};
		
		exports.Region = Region; // export class 
		
		
		Region.prototype.a = function(v){ return this._a; }
		Region.prototype.setA = function(v){ this._a = v; return this; };
		
		
		Region.prototype.b = function(v){ return this._b; }
		Region.prototype.setB = function(v){ this._b = v; return this; };
		
		
		Region.prototype.view = function(v){ return this._view; }
		Region.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Region.prototype.root = function(v){ return this._root; }
		Region.prototype.setRoot = function(v){ this._root = v; return this; };
		
		// remove root from region
		
		Region.normalize = function (val,view){
			var line_;
			if (val instanceof Region) { return val };
			if (val instanceof Array) { return new Region(val[0],val[1],null,view) };
			if ((typeof val=='number'||val instanceof Number)) { return new Region(val,val,null,view) };
			
			if ((val instanceof Object) && (typeof (line_ = val.line)=='number'||line_ instanceof Number)) {
				var lines = view._buffer.lines();
				var loc = 0;
				for (var i = 0, ary = iter$(lines), len = ary.length; i < len; i++) {
					if (i < (val.line - 1)) {
						loc += ary[i].length + 1;
					} else {
						break;
					};
				};
				
				loc += (val.column || 0);
				return new Region(loc,loc,null,view);
			};
		};
		
		
		Region.prototype.start = function (){
			return Math.min(this._a,this._b);
		};
		
		Region.prototype.end = function (){
			return Math.max(this._a,this._b);
		};
		
		Region.prototype.clone = function (ad,bd){
			if(ad === undefined) ad = 0;
			if(bd === undefined) bd = 0;
			return new Region(this._a + ad,this._b + bd,this._root,this._view);
		};
		
		Region.prototype.contains = function (rel){
			if (rel instanceof Region) {
				return this.start() <= rel.start() && this.end() >= rel.end();
			} else if ((typeof rel=='number'||rel instanceof Number)) {
				return this.start() <= rel && this.end() >= rel;
			};
		};
		
		Region.prototype.adjust = function (rel,add){
			if(add === undefined) add = true;
			if (rel.end() < this.start()) {
				add ? (this.move(rel.size())) : (this.move(-rel.size()));
			};
			return this;
		};
		
		Region.prototype.intersects = function (rel){
			// is this decent?
			rel = Region.normalize(rel);
			var a = Math.max(this.start(),rel.start());
			var b = Math.min(this.end(),rel.end());
			return b >= a;
		};
		
		Region.prototype.relativeTo = function (rel){
			// could use move instead
			return new Region(this._a - rel.start(),this._b - rel.start(),this._root,this._view);
		};
		
		Region.prototype.intersection = function (region){
			return this;
		};
		
		Region.prototype.equals = function (region){
			return this.start() == region.start() && this.end() == region.end();
		};
		
		Region.prototype.same = function (region){
			return region && region.a() == this.a() && region.b() == this.b();
		};
		
		Region.prototype.size = function (){
			return this.end() - this.start();
		};
		
		Region.prototype.move = function (num){
			if(num === undefined) num = 1;
			this._a += num;
			this._b += num;
			return this;
		};
		
		Region.prototype.collapsed = function (){
			return this.size() == 0;
		};
		
		Region.prototype.reverse = function (){
			var a = this._a,b = this._b;
			this._a = b;
			this._b = a;
			return this;
		};
		
		Region.prototype.reversed = function (){
			return this._a > this._b;
		};
		
		Region.prototype.normalize = function (){
			var a = this.start();
			var b = this.end();
			this._a = a;
			this._b = b;
			return this;
		};
		
		Region.prototype.collapse = function (forward){
			if(forward === undefined) forward = true;
			if (forward) {
				this._a = this._b = this.end();
				// @a = @b
			} else {
				this._b = this._a;
				this._a = this._b = this.start();
			};
			return this;
		};
		
		// expand to closest /n
		Region.prototype.expand = function (atStart,atEnd){
			if (this.b() < this.a()) {
				this._b += atStart;
				this._a += atEnd;
			} else {
				this._a += atStart;
				this._b += atEnd;
			};
			return this;
		};
		
		Region.prototype.text = function (){
			return this.view().substr(this);
		};
		
		Region.prototype.toString = function (){
			return ("[" + (this._a) + "," + (this._b) + "]");
		};
		
		Region.prototype.insert = function (node){
			return this;
		};
		
		Region.prototype.nodes = function (includeEnds){
			if(includeEnds === undefined) includeEnds = true;
			return this.view().nodesInRegion(this,includeEnds);
		};
		
		Region.prototype.prevNode = function (query){
			var nodes = this.nodes(false);
			var node = nodes.lft;
			if ((query instanceof Imba.Selector) || (typeof query=='string'||query instanceof String)) {
				var $1;while (node){
					if (node.matches(query)) { return node };
					node = ($1 = node) && $1.isLast  &&  $1.isLast() ? (node.parent()) : (null);
				};
				return null;
			};
			return node;
		};
		
		Region.prototype.nextNode = function (query){
			var nodes = this.nodes(false);
			var node = nodes.rgt;
			if ((query instanceof Imba.Selector) || (typeof query=='string'||query instanceof String)) {
				var $1;while (node){
					if (node.matches(query)) { return node };
					node = ($1 = node) && $1.isFirst  &&  $1.isFirst() ? (node.parent()) : (null);
				};
				return null;
			};
			return node;
		};
		
		Region.prototype.scope = function (query){
			var nodes = this.nodes(false);
			var node;
			if (nodes.lft) {
				node = nodes.lft.up(query);
			} else if (nodes.rgt) {
				node || (node = nodes.rgt.up(query));
			} else if (nodes[0]) {
				node || (node = nodes[0].node.closest(query));
			};
			return node;
		};
		
		Region.prototype.buffer = function (){
			return this._root.code();
		};
		
		Region.prototype.startAtLine = function (){
			this.normalize();
			var buffer = this.buffer();
			var a = this.start();
			
			if (buffer[a] == '\n' && this.size() == 0) {
				a--; // if we are at the end of a line
			};
			
			while (a >= 0 && buffer[a] != '\n'){
				a--;
			};
			this._a = a;
			return this;
		};
		
		Region.prototype.endAtLine = function (){
			this.normalize();
			var buffer = this.buffer();
			var b = (this.end() - 1);
			while (b >= 0 && buffer[b] && buffer[b] != '\n'){
				b++;
			};
			this._b = b;
			return this;
		};
		
		Region.prototype.cell = function (){
			return this.view()._buffer.locToCell(this.a());
		};
		
		Region.prototype.row = function (){
			return this.cell()[0];
		};
		
		Region.prototype.col = function (){
			return this.cell()[1];
		};
		
		Region.prototype.peekbehind = function (len){
			if(len === undefined) len = 1;
			return len == 1 ? (this.buffer()[this.start() - 1]) : (this.buffer().substring(this.start() - len,this.start()));
		};
		
		Region.prototype.peekahead = function (len){
			if(len === undefined) len = 1;
			return len == 1 ? (this.buffer()[this.end()]) : (this.buffer().substr(this.end(),len));
		};
		
		Region.prototype.indent = function (){
			return this.clone().startAtLine().text().match(/^\n?(\t*)/)[1];
		};
		
		Region.prototype.peek = function (before,after){
			if(before === undefined) before = 0;
			if(after === undefined) after = 0;
			return this.clone(before,after).text();
		};
		
		Region.prototype.lloc = function (){
			return {startLine: 0,startCol: 2};
		};
		
		Region.prototype.toJSON = function (){
			return [this.a(),this.b()];
		};
		return Region;
	
	})()

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		
		var KEYWORDS = 'var if elif else for while def in isa while until switch when then return class tag let do and or prop attr in prop'.split(' ');
		var OPS = '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ?'.split(' ');
		
		var WHITESPACE = /^[ \t\n]+$/;
		
		IM.HL = {
			newline: "<b class='_imnewline'>\n</b>",
			space: function(m) { return ("<b class='_imspace'>" + m + "</b>"); },
			tab: function(m) { return new Array(m.length + 1).join("<b class='_imtab'>\t</b>"); }
		};
		
		
		var Region = __webpack_require__(27).Region;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		var MATCHERS = {
			keyword: function(v) { return KEYWORDS.indexOf(v) >= 0; },
			self: /^(this|self)$/,
			const: function(v) { return (/^[A-Z][\w\_]*$/).test(v); },
			ivar: function(v) { return (/^@[\w\_]+$/).test(v); },
			bool: function(v) { return (/^(true|yes|false|no|null|undefined)$/).test(v); },
			identifier: /^[\$a-z_][\w\_\$]*(\-[\$\w\_]+)*$/,
			float: /^\d+\.\d+$/,
			int: /^\d+$/,
			comment: /^\#([ \t][^\n]*)?$/
		};
		
		var MODES = {
			all: Object.keys(MATCHERS)
		};
		
		
			
			String.prototype.repeat = function (num){
				return new Array(num + 1).join(this);
			};
			
			String.prototype.ins = function (str,region){
				var text = this.toString();
				if (region == 'append') {
					return text + str;
				} else if (region == 'prepend') {
					return "" + str + text;
				} else if (region instanceof Region) {
					return text.substr(0,region.start()) + str + text.slice(region.end());
				};
			};
		
		
		function isWhitespace(str){
			return WHITESPACE.test(str);
		}; exports.isWhitespace = isWhitespace;
		
		IM.num = function (val){
			return tag$.$imnum().flag('number').setText(val).end();
		};
		
		IM.tab = function (){
			return tag$.$imtab().setText('\t').end();
		};
		
		IM.newline = function (){
			return tag$.$imnewline().setText('\n').end();
		};
		
		IM.op = function (val){
			return tag$.$imop().flag('op').setText(val).end();
		};
		
		
		IM.tok = function (val){
			if (val && val._dom) { return val };
			if (val.match(WHITESPACE)) { return IM.parseWhitespace(val) };
			if (OPS.indexOf(val) >= 0) { return IM.op(val) }; // should use token directly
			// return IM.num(val) if val.match(/^\d+(\.\d+)?$/) # should use token directly
			return tag$.$imtok().setText(val).end();
		};
		
		IM.raw = function (val,ctx){
			return tag$.$imraw().setRaw(val).end();
		};
		
		IM.isWhitespace = function (val){
			return WHITESPACE.test(val);
		};
		
		IM.isOp = function (val){
			return OPS.indexOf(val) >= 0;
		};
		
		IM.parseWhitespace = function (text,rich){
			if(rich === undefined) rich = true;
			var hl = IM.HL;
			
			text = text.replace(/(\n|[ ]+|[\t]+)/g,function(m,l) {
				if (l == '\n') {
					return hl.newline || '\n';
				} else if (l[0] == ' ') {
					return hl.space instanceof Function ? (hl.space(l)) : (l);
				} else if (l[0] == '\t') {
					return hl.tab instanceof Function ? (hl.tab(l)) : (l);
				};
			});
			
			if (rich && text.indexOf('<') >= 0) {
				return tag$.$imfragment().setContent(text,0).end();
			};
			
			return text;
		};
		
		IM.identify = function (val,mode){
			if(mode === undefined) mode = 'all';
			var rules = MODES[mode];
			var res;
			for (var i = 0, ary = iter$(rules), len = ary.length, name; i < len; i++) {
				name = ary[i];
				var rule = MATCHERS[name];
				
				if (rule instanceof Function) {
					res = rule(val,mode);
				} else if (rule instanceof RegExp) {
					res = rule.test(val);
				};
				
				if (res) {
					return res === true ? (name) : (res);
				};
			};
			
			return null;
		};
		
		IM.parse = function (code,context){
			// decide if full?
			// console.log "parse code {code:length} {code.substr(0,20)}"
			if (typeof code != 'string') { return code };
			
			if (WHITESPACE.test(code)) {
				return IM.parseWhitespace(code,false);
			};
			
			var ws = code.match(/^([ \t]*)([^]*?)([ \t]*)$/) || ['','',code,''];
			var hl;
			
			if (ws[1] || ws[3]) {
				code = ws[2];
			};
			
			var id = IM.identify(code);
			
			if (id) {
				var typ = 'span';
				var cls = Highlighter.Mapping[id] || id; // this is the issue, no?
				
				if (cls instanceof Array) {
					typ = cls[0];
					cls = cls[1];
				};
				
				if (!cls.match(/\b_[\w]/)) { cls = '_imtok ' + cls };
				// console.log 'parsed as type',id,cls
				hl = '<' + typ + ' class="' + cls + '">' + code + '</' + typ + '>';
			};
			
			if (!hl) {
				hl = Highlighter.highlight(code);
			};
			
			if (ws) {
				hl = IM.parseWhitespace(ws[1],false) + hl + IM.parseWhitespace(ws[3],false);
			};
			if (hl) {
				return hl;
			} else {
				return code;
			};
		};
		
		
		return IM.textNodes = function (root,mark){
			// console.time('textNodes2')
			if(mark === undefined) mark = false;
			root = root._dom || root;
			var el;
			var nodes = [];
			var pos = 0;
			var walk = document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);
			
			while (el = walk.nextNode()){
				if (mark) {
					var len = el.length;
					el._loc = pos;
					pos += len;
				};
				nodes.push(el);
			};
			return nodes;
		};
	
	})()

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		// var imbac = global.Imbac
		var Lexer = __webpack_require__(30).Lexer;
		
		var util = __webpack_require__(34);
		
		var NODETYPE = 'b';
		var KEYWORDS = [
			'null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','isa','case','nil'
		];
		
		var classes = {
			'+': '_imop op add math',
			'++': '_imop op incr math',
			'--': '_imop op decr math',
			'-': '_imop op sub math',
			'=': '_imop op eq',
			'/': '_imop op div math',
			'*': '_imop op mult math',
			'?': '_imop op ternary',
			',': '_imop op comma',
			':': '_imop op colon',
			'.': '_imop op dot',
			'.:': '_imop op cdot',
			'!': '_imop op unary',
			'?.': '_imop op qdot',
			'[': '_imopen sb sbl',
			']': '_imclose sb sbr',
			'(': '_imopen rb rbl',
			')': '_imclose rb rbr',
			'{': '_imopen cb cbl',
			'}': '_imclose cb cbr',
			'#': '_imop op hash',
			'call_start': '_imopen call rb rbl',
			'call_end': '_imclose call rb rbr',
			'tag_start': '_imopen tag_open',
			'tag_end': '_imclose tag_close',
			
			'true': '_imbool true',
			'yes': '_imbool true',
			'false': '_imbool false',
			'no': '_imbool false',
			
			'{{': '_imopen',
			'}}': '_imclose',
			
			'"': 'doublequote',
			"'": 'singlequote',
			
			'regex': '_imregex regex',
			'identifier': '_imtok _imidentifier identifier',
			
			'compound_assign': 'op assign compound',
			'str': '_imstr string',
			'num': '_imnum number',
			'string': '_imstr string',
			'number': '_imnum number',
			'math': '_imop op math',
			'unary': '_imop op unary',
			'forin': 'keyword in',
			'forof': 'keyword of',
			'own': 'keyword own',
			'compare': '_imop op compare',
			'herecomment': '_herecomment',
			'relation': 'keyword relation',
			'export': 'keyword export',
			'global': 'keyword global',
			'extern': 'keyword global',
			'extend': 'keyword extend',
			'require': 'keyword require',
			'from': 'keyword from',
			'logic': 'keyword logic',
			'post_if': 'keyword if post_if',
			'post_for': 'keyword for post_for',
			'prop': 'keyword prop',
			'attr': 'keyword attr',
			
			'selector_start': '_imopen _imselopen selector_start',
			'selector_end': '_imclose _imselclose selector_end',
			'index_start': '_imopen index_start',
			'index_end': '_imclose index_end',
			'block_param_start': '_imopen',
			'block_param_end': '_imclose',
			
			'string_start': '_imstrstart string_start',
			'string_end': '_imstrend string_end',
			'neostring': '_imtok _imneostring'
		};
		
		var INTERPOLATING = '_imistring';
		
		var OPEN = {
			'tag_start': '_imtagnode tagnode',
			'call_start': '_imparens call',
			'selector_start': '_imsel selector',
			'string_start': '_imistring',
			'index_start': 'index',
			'block_param_start': '_impair _imblockparams',
			// 'indent': '_indent'
			'(': '_imparens paren',
			'{{': '_imiexpr',
			'{': '_imcurly curly',
			'[': '_imsquare square',
			'("': '_imistring'
		};
		
		
		
		var CLOSE = {
			'tag_end': 'tag',
			'call_end': '_imparens call',
			'string_end': '_imistring',
			'selector_end': 'sel',
			'index_end': 'index',
			'block_param_end': '_impair _imblockparams',
			'}}': '_imiexpr',
			')': 'paren',
			']': 'square',
			'}': 'curly',
			'")': 'string'
		};
		
		var OPS = '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ?'.split(' ');
		
		var hlo = {
			newline: "<b class='_imnewline'>\n</b>",
			space: function(m) { return ("<b class='_imspace'>" + m + "</b>"); },
			tab: function(m) { return new Array(m.length + 1).join("<b class='_imtab'>\t</b>"); }
		};
		
		function Stack(){
			this._stack = [];
			return this;
		};
		
		Stack.prototype.push = function (val){
			this._stack.push(val);
			this._current = val;
			return this;
		};
		
		Stack.prototype.pop = function (){
			var len = this._stack.pop();
			this._current = this._stack[len - 1];
			return this;
		};
		
		Stack.prototype.toString = function (){
			return this._current;
		};
		
		function Token(type,value,line,loc,len){
			this._type = type;
			this._value = value;
			this._meta = null;
			this._line = line || 0;
			this._col = -1;
			this._loc = loc || 0;
			this._len = len || 0;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.loc = function (){
			return this._loc;
		};
		
		Token.prototype.len = function (){
			return this._len;
		};
		
		
		
		function Highlighter(code,tokens,ast,o){
			var hl_;
			if(o === undefined) o = {};
			this._code = code;
			this._tokens = tokens;
			this._ast = ast;
			
			o.render || (o.render = {});
			o.hl || (o.hl = {});
			(hl_ = o.hl).newline || (hl_.newline = '<b class="_n">\n</b>');
			this._options = o;
			
			this._options.nextVarCounter || (this._options.nextVarCounter = 0);
			this._varRefs = {};
			
			if (o.mode == 'full' && !ast) {
				this._ast = Imbac.parse(this._tokens,{});
			};
			
			return this;
		};
		
		exports.Highlighter = Highlighter; // export class 
		Highlighter.Mapping = classes;
		
		Highlighter.logger = function (){
			return VIEW.logger();
		};
		
		Highlighter.tokenize = function (code,o){
			// console.log 'tokenize using local lexer'
			if(o === undefined) o = {};
			if (global.Imbac) {
				return Imbac.tokenize(code,o);
			};
			
			this._lexer || (this._lexer = new Lexer());
			this._lexer.reset();
			return this._lexer.tokenize(code,o);
		};
		
		Highlighter.reclassify = function (domnode,type,token,newCode,oldCode){
			
			type = type.toLowerCase();
			// console.log 'reclassify node as type',domnode,type,token
			var cls = IM.Types[type] || Imba.TAGS[("im" + type)] || IM.Types.token;
			
			var node = tag$wrap(domnode);
			
			if (node instanceof cls) {
				return node.reuse(token,newCode,oldCode);
			};
			
			if (cls) {
				node = new cls(domnode).setup(token,newCode,oldCode);
			};
			
			return node;
		};
		
		
		Highlighter.nestTokens = function (tokens,offset){
			var pairing = {
				'TAG_START': 'TAG_END',
				'SELECTOR_START': 'SELECTOR_END',
				'CALL_START': 'CALL_END',
				'INDEX_START': 'INDEX_END',
				'STRING_START': 'STRING_END',
				'BLOCK_PARAM_START': 'BLOCK_PARAM_END',
				'{{': '}}',
				'{': '}',
				'[': ']',
				'(': ')'
			};
			
			var naming = {
				'TAG_START': 'tagnode',
				'SELECTOR_START': 'selector',
				'STRING_START': 'istring',
				'CALL_START': 'parens',
				'INDEX_START': 'square',
				'BLOCK_PARAM_START': 'blockparams',
				'{{': 'iexpr',
				'{': 'curly',
				'[': 'square',
				'(': 'parens'
			};
			
			var idx = 0;
			
			var root = {
				_loc: 0,
				_offset: 0,
				_children: []
			};
			
			var stack = [root];
			var ends = [];
			var offset = 0;
			
			var loc,val,typ,ctx,tok;
			
			while (tok = tokens[idx++]){
				loc = tok._loc;
				val = tok._value;
				typ = tok._type;
				
				// normalizing because we dont rewrite tokens (should start with that)
				if (typ == 'IDENTIFIER' && (val == 'prop' || val == 'attr')) { typ = tok._type = 'KEYWORD' }; // not always
				if (typ == 'INDEX_START') { typ = tok._type = '[' };
				if (typ == 'INDEX_END') { typ = tok._type = ']' };
				if (typ == 'CALL_START') { typ = tok._type = '(' };
				if (typ == 'CALL_END') { typ = tok._type = ')' };
				
				ctx = stack[stack.length - 1];
				
				loc -= ctx._offset;
				// offset relative to context
				var closer = pairing[typ];
				
				if (closer) {
					var group = new Token(naming[typ],'',-1,loc);
					group._offset = ctx._offset + loc;
					offset += loc;
					group._children = [];
					ends.push(closer);
					stack.push(group);
					ctx._children.push(group);
					ctx = group;
				};
				
				tok._loc -= ctx._offset;
				
				// update length at all times
				if (tok._len >= 1) {
					ctx._children.push(tok);
					ctx._len = tok._loc + tok._len;
				};
				
				if (ends[ends.length - 1] == typ) {
					ends.pop();
					ctx._len = tok._loc + tok._len;
					stack.pop();
					// offset -= ctx.@offset
				};
			};
			
			// console.log 'children here',root.@children
			return root._children;
		};
		
		Highlighter.normalizeTokens = function (code,tokens,offset){
			if(offset === undefined) offset = 0;
			var idx = 0;
			var caret = 0;
			var new$ = [];
			var tok,next,typ,val;
			var loc = 0;
			
			var stack = new Stack();
			
			var ws = function() {
				var newtok = null;
				
				while (loc > caret){
					var chr = code[caret];
					if (chr == '\t') {
						newtok = new Token('tab',chr,-1,caret,1);
					} else if (chr == '\n') {
						newtok = new Token('newline',chr,-1,caret,1);
					} else if (chr == ';') {
						newtok = new Token('semicolon',chr,-1,caret,1);
					} else if (chr == ' ') {
						if (newtok && newtok._type == 'whitespace') {
							newtok._value += ' ';
							newtok._len += 1;
							caret++;
							continue;
						};
						newtok = new Token('whitespace',chr,-1,caret,1);
					} else if (chr == '#') {
						var startloc = caret;
						var comment = '';
						while (caret < loc && code[caret] != '\n'){
							comment += code[caret];
							caret++;
						};
						new$.push(new Token('comment',comment,-1,startloc,comment.length));
						continue;
					} else {
						newtok = null;
					};
					
					caret++;
					if (newtok) { new$.push(newtok) };
				};
				return;
			};
			
			var skip = ['TERMINATOR','INDENT','OUTDENT',' ',' \t'];
			
			while (tok = tokens[idx++]){
				next = tokens[idx];
				loc = tok._loc;
				val = tok._value;
				typ = tok._type;
				
				if (typ == '#' && next && next._type == 'IDENTIFIER') {
					next._type = 'IDREF';
				};
				
				if (typ == '(' && val == '("') {
					stack.push(val);
				};
				
				if (skip.indexOf(typ) >= 0) { continue; };
				
				if (loc > caret) { ws() };
				caret = tok._loc + tok._len;
				new$.push(tok);
			};
			
			// move to the end to possibly parse more whitespace
			loc = code.length;
			ws();
			// now nest the tokens
			new$ = this.nestTokens(new$);
			return new$;
		};
		
		Highlighter.whitespaceToTokens = function (str){
			var tok;
			var tokens = [];
			var caret = 0;
			var len = str.length;
			
			while (len > caret){
				var loc = caret;
				var chr = str[caret++];
				if (chr == '\t') {
					tokens.push(tok = new Token('tab',chr,-1,loc,1));
				} else if (chr == '\n') {
					tokens.push(tok = new Token('newline',chr,-1,loc,1));
				} else if (chr == ' ') {
					if (tok && tok._type == 'whitespace') {
						tok._value += ' ';
						tok._len += 1;
						continue;
					};
					tokens.push(tok = new Token('whitespace',chr,-1,loc,1));
				};
			};
			
			return tokens;
		};
		
		Highlighter.reparse = function (o){
			
			var $1;
			if (o instanceof Element) {
				var el = tag$wrap(o);
				if (el) { ($1 = el) && $1.mutated  &&  $1.mutated() };
				return;
			};
			
			var nodes = o.nodes;
			var code = o.code;
			var tokens = o.tokens;
			// should use a global logger-instance
			this.logger().groupCollapsed('reparse %s',JSON.stringify(code));
			
			if (util.isWhitespace(code) && !tokens) {
				console.log('using whitespaceToTokens');
				tokens = this.whitespaceToTokens(code);
			};
			// logger.log nodes.slice
			// big hack - adding a space at the end to close up selectors
			// should rather drop inline and let the parser pair up loose ends?
			if (!tokens) {
				tokens = this.tokenize(code + ' ',{inline: true,silent: true,rewrite: false});
				tokens = this.normalizeTokens(code,tokens);
				this.logger().log(tokens.slice());
			};
			
			this.logger().log(nodes.slice());
			this.applyTokens(code,tokens,nodes,o.nested,o.parent);
			this.logger().groupEnd();
			return;
		};
		
		Highlighter.applyTokens = function (code,tokens,nodes,nested,parent){
			// what about len and loc for inner nodes? Should this be set already?
			
			var self = this;
			var node;
			var prevNode;
			
			var addNode = function(nodes,index,after) {
				self.logger().log('addNode',index);
				var el = document.createElement(NODETYPE);
				
				if (after) {
					if (after.nextSibling) {
						after.parentNode.insertBefore(el,after.nextSibling);
					} else if (after.parentNode) {
						after.parentNode.appendChild(el);
					};
				} else if (parent) {
					parent.appendChild(el);
				};
				
				nodes.splice(index,0,el);
				return el;
			};
			
			var removeNode = function(nodes,index) {
				self.logger().log('removeNode',index);
				var el = nodes[index];
				if (el && el.parentNode) {
					el.parentNode.removeChild(el);
				};
				return nodes.splice(index,1);
			};
			
			// loop through to set the locations of the nodes
			var nloc = 0;
			for (var i = 0, ary = iter$(nodes), len = ary.length, node1; i < len; i++) {
				node1 = ary[i];
				node1._loc = nloc;
				nloc += (node1._len = node1.textContent.length);
			};
			
			for (var i = 0, ary = iter$(tokens), len = ary.length, tok; i < len; i++) {
				tok = ary[i];
				node = nodes[i];
				var tloc = tok._loc;
				nloc = node && node._loc;
				
				while (node && node._len == 0){
					self.logger().log('remove node because it is empty',node);
					removeNode(nodes,i);
					node = nodes[i];
				};
				
				if (!node) {
					// need to insert new node here - 
					node = addNode(nodes,i,prevNode);
				} else if (nloc > tloc) {
					node = addNode(nodes,i,prevNode);
				} else if (tloc > nloc) {
					removeNode(nodes,i);
					node = nodes[i];
				};
				
				// need to insert new node here - 
				if (!node) { node = addNode(nodes,i,prevNode) };
				
				if (tok._type == 'STRING' && tok._value.match(/\{3}/)) {
					if (nested) {
						nested.pop(); // this is the node
						prevNode = node;
						continue;
					};
					
					// want to make sure it is a placeholder for the right thing
				};
				
				var cval = code.substr(tloc,tok._len);
				var cprev = node.textContent;
				var element = self.reclassify(node,tok._type,tok,cval,cprev);
				
				if (tok._children) {
					var cnodes = node.children;
					if (cnodes.length && cnodes.length == node.childNodes.length) {
						self.logger().log('reuse the cnodes(!)',cnodes);
						// otherwise we should remove the textNodes?
						// convert to array
						cnodes = Array.prototype.slice.call(cnodes);
					} else {
						self.logger().log('wrong length');
						for (var j = 0, items = iter$(node.childNodes), len_ = items.length; j < len_; j++) {
							self.logger().log(items[j]);
						};
						// see if previous value is the same?!
						node.innerHTML = '';
						cnodes = [];
					};
					
					// let o =
					// 	code: cval
					// 	nodes: cnodes
					// 	tokens: tok.@children # already parsed
					// 	nested: nested
					// 	parent: node
					
					self.applyTokens(cval,tok._children,cnodes,nested,node);
				} else if (cprev != cval) {
					node.textContent = cval; // tok.@value
					element.reparsed(cval,cprev);
				};
				
				prevNode = node;
				// tok.@len
			};
			
			// loop through tokens? not sure it works due to the issues with whitespace?
			
			// remove excess original nodes
			while (nodes.length > tokens.length){
				node = nodes.pop();
				if (node.parentNode) { node.parentNode.removeChild(node) };
				// node.orphanize
			};
			return self;
		};
		
		// should later be able to rehighlight the text / nodes directly instead
		// probably more efficient
		Highlighter.highlight = function (code,o){
			// first try to parse etc?
			// could highlight single words as well
			if(o === undefined) o = {};
			o.hl || (o.hl = hlo);
			var tokens = o.tokens || null;
			
			if (!tokens) {
				try {
					// sure we dont want to rewrite anything now?
					if (true) { console.time('tokenize') };
					if (o.mode == 'full') {
						tokens = this.tokenize(code,{});
					} else {
						tokens = this.tokenize(code,{inline: true,silent: true,rewrite: false});
					};
					if (true) { console.timeEnd('tokenize') };
				} catch (e) {
					if (e._options) { tokens = e._options.tokens };
				};
			};
			
			var hl = new this(code,tokens,null,o);
			return hl.process();
		};
		
		
		
		Highlighter.prototype.options = function(v){ return this._options; }
		Highlighter.prototype.setOptions = function(v){ this._options = v; return this; };
		
		Highlighter.prototype.varRef = function (variable){
			var $1;
			var i = this._options.nested;
			var pfx = i ? ('i') : ('');
			return this._varRefs[($1 = variable._ref)] || (this._varRefs[$1] = (pfx + this._options.nextVarCounter++));
		};
		
		Highlighter.prototype.parseWhitespace = function (text){
			// parsing comments
			var self = this;
			var hl = this._options.hl;
			var comments = [];
			
			text = text.replace(/(\#)([^\n]*)/g,function(m,s,q) {
				if (self._options.render.comment) {
					m = self._options.render.comment('comment',m);
				};
				var nr = comments.push(("<" + NODETYPE + " class='_im _imcomment'>" + m + "</" + NODETYPE + ">"));
				return ("$" + (nr - 1) + "$");
			});
			
			text = text.replace(/(\n|[ ]+|[\t]+)/g,function(m,l) {
				if (l == '\n') {
					return hl.newline || '\n';
				} else if (l[0] == ' ') {
					return hl.space instanceof Function ? (hl.space(l)) : (l);
				} else if (l[0] == '\t') {
					return hl.tab instanceof Function ? (hl.tab(l)) : (l);
				};
			});
			
			if (comments.length) {
				text = text.replace(/\$(\d+)\$/g,function(m,nr) {
					return comments[parseInt(nr)];
				});
			};
			return text;
		};
		
		Highlighter.prototype.process = function (){
			var tok;
			var o = this.options();
			
			var str = this._code;
			var pos = this._tokens.length;
			
			var stack = [];
			var depth = 0;
			var context = null;
			
			var push = function(ctx) {
				stack.push(ctx);
				depth = stack.length;
				return context = stack[depth - 1];
			};
			
			var pop = function(ctx) {
				stack.pop();
				depth = stack.length;
				return context = stack[depth - 1];
			};
			
			if (this._ast && this._ast.analyze) {
				try {
					this._ast.analyze({});
				} catch (e) {
					null;
				};
			};
			
			var res = "";
			pos = 0;
			var caret = 0;
			
			var open,close;
			
			while (tok = this._tokens[pos++]){
				var next = this._tokens[pos];
				
				if (close) {
					if (!(o.inner && depth == 1)) { res += ("</" + NODETYPE + ">") };
					close = null;
					pop();
				};
				
				var typ = tok._type.toLowerCase();
				var loc = tok._loc;
				var val = tok._value;
				var len = tok._len; // or tok.@value:length
				var meta = tok._meta;
				var attrs = '';
				
				if (loc > caret) {
					var add = str.substring(caret,loc);
					if (context != INTERPOLATING) { add = this.parseWhitespace(add) };
					res += add;
					caret = loc;
				};
				
				close = CLOSE[typ];
				
				if (open = OPEN[typ]) {
					// open = OPEN[val] || open
					push(open);
					if (!(o.inner && depth == 1)) { res += ("<" + NODETYPE + " class='" + open + "'>") };
				};
				
				if (len == 0 || typ == 'terminator' || typ == 'indent' || typ == 'outdent') {
					continue;
				};
				
				if (tok._col == -1 && tok._loc <= 0) {
					continue;
				};
				
				var node = NODETYPE;
				var content = str.substr(loc,len);
				// temporary workaround until we redefine require as an identifier
				if (typ == 'const' && content == 'require') {
					typ = 'require';
				};
				
				
				var cls = classes[typ] || typ;
				
				if (cls instanceof Array) {
					node = cls[0];
					cls = cls[1];
				};
				
				cls = cls.split(" ");
				
				if (KEYWORDS.indexOf(typ) >= 0) {
					cls.unshift('keyword');
				};
				
				caret = loc + len;
				
				if (typ == 'identifier') {
					if (content[0] == '#') {
						cls.push('idref');
					};
					
					if (meta) {
						if (meta.type == 'ACCESS') { cls.push('access') };
					};
					
					if (content == 'log') {
						cls.push('log');
					};
				};
				
				if (tok._variable) {
					
					cls.push('lvar');
					var ref = this.varRef(tok._variable);
					attrs += (" eref='v" + ref + "'");
					// cls.push("ref-"+ref)
				};
				
				if (typ == 'herecomment') {
					var end = ("<" + NODETYPE + ">###</" + NODETYPE + ">");
					content = end + content.slice(3,-3) + end;
				};
				
				if (typ == 'string') {
					if (content.match(/^['"]?\.?\.\//)) { cls.push('pathname') };
				};
				
				var clstr = cls.join(" ");
				if (!clstr.match(/\b\_/)) { clstr = '_imtok ' + clstr };
				res += ("<" + node + " class='" + clstr + "'") + attrs + ">" + content + ("</" + node + ">");
			};
			
			// close after?
			if (close) {
				res += ("</" + NODETYPE + ">");
				close = null;
			};
			
			if (caret < str.length - 1) {
				add = str.slice(caret);
				if (context != INTERPOLATING) { add = this.parseWhitespace(add) };
				res += add;
			};
			
			if (this._tokens.length == 0) {
				res = this._code;
			};
			
			return res;
		};
		return Highlighter;
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		var ALL_KEYWORDS;
		
		var T = __webpack_require__(31);
		var Token = T.Token;
		
		var rw = __webpack_require__(32);
		var Rewriter = rw.Rewriter;
		var INVERSES = rw.INVERSES;
		
		var K = 0;
		
		var ERR = __webpack_require__(33);
		
		// Constants
		// ---------
		
		// Keywords that Imba shares in common with JavaScript.
		var JS_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return'
		];
		
		// new can be used as a keyword in imba, since object initing is done through
		// MyObject.new. new is a very useful varname.
		
		// We want to treat return like any regular call for now
		// Must be careful to throw the exceptions in AST, since the parser
		// wont
		
		// Imba-only keywords. var should move to JS_Keywords
		// some words (like tokid) should be context-specific
		var IMBA_KEYWORDS = [
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import'
		];
		
		var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];
		
		var IMBA_ALIAS_MAP = {
			'and': '&&',
			'or': '||',
			'is': '==',
			'isnt': '!=',
			'not': '!',
			'yes': 'true',
			'no': 'false',
			'isa': 'instanceof',
			'case': 'switch',
			'nil': 'null'
		};
		
		var IMBA_ALIASES = Object.keys(IMBA_ALIAS_MAP);
		IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);
		
		// FixedArray for performance
		// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
		module.exports.ALL_KEYWORDS = ALL_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil'
		];
		
		// The list of keywords that are reserved by JavaScript, but not used, or are
		// used by Imba internally. We throw an error when these are encountered,
		// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
		var RESERVED = ['case','default','function','void','with','const','enum','native'];
		var STRICT_RESERVED = ['case','function','void','const'];
		
		// The superset of both JavaScript keywords and reserved words, none of which may
		// be used as identifiers or properties.
		var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);
		
		var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
		// removed ~=|~| |&(?![&=])
		
		// Token matching regexes.
		// added hyphens to identifiers now - to test
		var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;
		
		var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;
		
		var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;
		
		var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
		var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;
		
		var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;
		
		var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
		var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
		var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;
		
		var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
		var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		
		var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\/\\\:][\w\x7f-\uffff]+)*)|==|\<=\>|\[\]|\[\]\=|\*|[\\/,\\])/;
		
		
		var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
		
		var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;
		
		var OPERATOR = /^(?:[-=]=>|===|->|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;
		
		// FIXME splat should only be allowed when the previous thing is spaced or inside call?
		
		var WHITESPACE = /^[^\n\S]+/;
		
		var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
		// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
		var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;
		
		var CODE = /^[-=]=>/;
		
		var MULTI_DENT = /^(?:\n[^\n\S]*)+/;
		
		var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;
		
		var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;
		
		// Regex-matching-regexes.
		var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;
		
		var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;
		
		var HEREGEX_OMIT = /\s+(?:#.*)?/g;
		
		// Token cleaning regexes.
		var MULTILINER = /\n/g;
		
		var HEREDOC_INDENT = /\n+([^\n\S]*)/g;
		
		var HEREDOC_ILLEGAL = /\*\//;
		
		// expensive?
		var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
		
		var TRAILING_SPACES = /\s+$/;
		
		var CONST_IDENTIFIER = /^[A-Z]/;
		
		var ARGVAR = /^\$\d$/;
		
		// Compound assignment tokens.
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];
		
		// Unary tokens.
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		
		// Logical tokens.
		var LOGIC = ['&&','||','&','|','^'];
		
		// Bit-shifting tokens.
		var SHIFT = ['<<','>>','>>>'];
		
		// Comparison tokens.
		var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];
		
		// Overideable methods
		var OP_METHODS = ['<=>','<<','..'];
		
		// Mathematical tokens.
		var MATH = ['*','/','%','','',''];
		
		// Relational tokens that are negatable with `not` prefix.
		var RELATION = ['IN','OF','INSTANCEOF','ISA'];
		
		// Boolean tokens.
		var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];
		
		// Our list is shorter, due to sans-parentheses method calls.
		var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];
		
		// If the previous token is not spaced, there are more preceding tokens that
		// force a division parse:
		var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];
		
		// Tokens which could legitimately be invoked or indexed. An opening
		// parentheses or bracket following these tokens will be recorded as the start
		// of a function invocation or indexing operation.
		// really?!
		
		var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];
		
		// } should not be callable anymore!!! '}', '::',
		var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];
		// var INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS','}' # are booleans indexable? really?
		// optimize for FixedArray
		var INDEXABLE = [
			'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
			'NUMBER','BOOL','TAG_SELECTOR','IDREF','ARGUMENTS','}','TAG_TYPE'
		];
		
		var GLOBAL_IDENTIFIERS = ['global','exports','require'];
		
		// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
		// occurs at the start of a line. We disambiguate these from trailing whens to
		// avoid an ambiguity in the grammar.
		var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];
		
		
		function LexerError(message,file,line){
			this.message = message;
			this.file = file;
			this.line = line;
			return this;
		};
		subclass$(LexerError,SyntaxError);
		exports.LexerError = LexerError; // export class 
		
		
		
		function last(array,back){
			if(back === undefined) back = 0;
			return array[array.length - back - 1];
		};
		
		function count(str,substr){
			return str.split(substr).length - 1;
		};
		
		function repeatString(str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		var tT = T.typ;
		var tV = T.val;
		var tTs = T.setTyp;
		var tVs = T.setVal;
		
		// The Lexer class reads a stream of Imba and divvies it up into tokidged
		// tokens. Some potential ambiguity in the grammar has been avoided by
		// pushing some extra smarts into the Lexer.
		
		// Based on the original lexer.coffee from CoffeeScript
		function Lexer(){
			this.reset();
			this;
		};
		
		exports.Lexer = Lexer; // export class 
		Lexer.prototype.reset = function (){
			this._code = null;
			this._chunk = null; // The remainder of the source code.
			this._opts = null;
			
			this._indent = 0; // The current indentation level.
			this._indebt = 0; // The over-indentation at the current level.
			this._outdebt = 0; // The under-outdentation at the current level.
			
			this._indents = []; // The stack of all current indentation levels.
			this._ends = []; // The stack for pairing up tokens.
			this._contexts = []; // suplements @ends
			this._scopes = [];
			this._nextScope = null; // the scope to add on the next indent
			// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
			// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
			
			this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
			this._seenFor = false;
			this._loc = 0;
			this._locOffset = 0;
			
			this._end = null;
			this._char = null;
			this._bridge = null;
			this._last = null;
			this._lastTyp = '';
			this._lastVal = null;
			return this;
		};
		
		Lexer.prototype.jisonBridge = function (jison){
			return this._bridge = {
				lex: T.lex,
				setInput: function(tokens) {
					this.tokens = tokens;
					return this.pos = 0;
				},
				
				upcomingInput: function() { return ""; }
			};
		};
		
		
		Lexer.prototype.tokenize = function (code,o){
			
			if(o === undefined) o = {};
			if (code.length == 0) {
				return [];
			};
			
			if (!o.inline) {
				if (WHITESPACE.test(code)) {
					code = ("\n" + code);
					if (code.match(/^\s*$/g)) { return [] };
				};
				
				code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
			};
			
			this._last = null;
			this._lastTyp = null;
			this._lastVal = null;
			
			this._code = code;
			this._opts = o;
			this._locOffset = o.loc || 0;
			// add a reference to the options object
			o._tokens = this._tokens;
			// what about col here?
			
			// @indent  = 0 # The current indentation level.
			// @indebt  = 0 # The over-indentation at the current level.
			// @outdebt = 0 # The under-outdentation at the current level.
			// @indents = [] # The stack of all current indentation levels.
			// @ends    = [] # The stack for pairing up tokens.
			// @tokens  = [] # Stream of parsed tokens in the form `['TYPE', value, line]`.
			// @char = nil
			
			if (o.profile) { console.time("tokenize:lexer") };
			this.parse(code);
			if (!o.inline) this.closeIndentation();
			if (!o.silent && this._ends.length) {
				this.error(("missing " + (this._ends.pop())));
			};
			
			if (o.profile) { console.timeEnd("tokenize:lexer") };
			if (o.rewrite == false || o.norewrite) { return this._tokens };
			return new Rewriter().rewrite(this._tokens,o);
		};
		
		Lexer.prototype.parse = function (code){
			var i = 0;
			var pi = 0;
			
			while (this._chunk = code.slice(i)){
				this._loc = this._locOffset + i;
				pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
				i += pi;
			};
			
			return;
		};
		
		Lexer.prototype.basicContext = function (){
			return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
		};
		
		Lexer.prototype.moveCaret = function (i){
			return this._loc += i;
		};
		
		Lexer.prototype.context = function (){
			return this._ends[this._ends.length - 1];
		};
		
		Lexer.prototype.inContext = function (key){
			var o = this._contexts[this._contexts.length - 1];
			return o && o[key];
		};
		
		Lexer.prototype.pushEnd = function (val){
			// console.log "pushing end",val
			this._ends.push(val);
			this._contexts.push(null);
			this._end = val;
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.popEnd = function (val){
			this._ends.pop();
			this._contexts.pop();
			this._end = this._ends[this._ends.length - 1];
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.refreshScope = function (){
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
		};
		
		
		
		Lexer.prototype.queueScope = function (val){
			// console.log("pushing scope {val} - {@indents} {@indents:length}")
			// @scopes.push(val) # no no
			this._scopes[this._indents.length] = val;
			return this;
		};
		
		Lexer.prototype.popScope = function (val){
			this._scopes.pop();
			return this;
		};
		
		Lexer.prototype.getScope = function (){
			return this._scopes[this._indents.length - 1];
		};
		
		Lexer.prototype.scope = function (sym,opts){
			var len = this._ends.push(this._end = sym);
			this._contexts.push(opts || null);
			return sym;
		};
		
		
		Lexer.prototype.closeSelector = function (){
			if (this._end == '%') {
				this.token('SELECTOR_END','%',0);
				return this.pair('%');
			};
		};
		
		
		Lexer.prototype.openDef = function (){
			return this.pushEnd('DEF');
		};
		
		
		Lexer.prototype.closeDef = function (){
			if (this.context() == 'DEF') {
				var prev = last(this._tokens);
				// console.log "close def {prev}"
				// console.log('closeDef with last>',prev)
				if (tT(prev) == 'DEF_FRAGMENT') {
					true;
				} else if (tT(prev) == 'TERMINATOR') {
					// console.log "here?!??"
					var n = this._tokens.pop();
					// console.log n
					this.token('DEF_BODY','DEF_BODY',0);
					// token('TERMINATOR', '',0) unless n.@value.indexOf('//') >= 0
					this._tokens.push(n);
				} else {
					this.token('DEF_BODY','DEF_BODY',0);
				};
				
				this.pair('DEF');
			};
			return;
		};
		
		Lexer.prototype.tagContextToken = function (){
			var match;
			if (this._chunk[0] == '#') {
				// console.log('found id # in tagContextToken')
				this.token('#','#',1);
				return 1;
			};
			
			if (match = TAG_ATTR.exec(this._chunk)) {
				// console.log 'TAG_SDDSATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			return 0;
		};
		
		Lexer.prototype.tagDefContextToken = function (){
			// console.log "tagContextToken"
			var match;
			if (match = TAG_TYPE.exec(this._chunk)) {
				this.token('TAG_TYPE',match[0],match[0].length);
				return match[0].length;
			};
			
			if (match = TAG_ID.exec(this._chunk)) {
				var input = match[0];
				this.token('TAG_ID',input,input.length);
				return input.length;
			};
			
			return 0;
		};
		
		
		Lexer.prototype.tagToken = function (){
			var match, ary;
			if (!(match = TAG.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
			
			if (type == '<') {
				this.token('TAG_START','<',1);
				this.pushEnd(INVERSES.TAG_START);
				
				if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
					// special case should probably be handled in AST
					if (match[0] != 'self') {
						this.token('TAG_TYPE',match[0],match[0].length,1);
						return input.length + match[0].length;
					};
				};
				
				if (identifier) {
					if (identifier.substr(0,1) == '{') {
						return type.length;
					} else {
						this.token('TAG_NAME',input.substr(1),0);
					};
				};
			};
			
			return input.length;
		};
		
		
		Lexer.prototype.selectorToken = function (){
			var ary, string;
			var match;
			
			// special handling if we are in this context
			if (this._end == '%') {
				var chr = this._chunk.charAt(0);
				var open = this.inContext('open');
				
				// should add for +, ~ etc
				// should maybe rather look for the correct type of character?
				
				if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
					// console.log "close this selector directly"
					this.token('SELECTOR_END','%',0);
					this.pair('%');
					return 0;
				};
				
				if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
					// spaces between? -- include the whole
					this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
					return match[0].length;
				} else if (match = SELECTOR_PART.exec(this._chunk)) {
					var type = match[1];
					var id = match[2];
					
					switch (type) {
						case '.':
							tokid = 'SELECTOR_CLASS';break;
						
						case '#':
							tokid = 'SELECTOR_ID';break;
						
						case ':':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						case '::':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						default:
						
							var tokid = 'SELECTOR_TAG';
					
					};
					
					this.token(tokid,match[2],match[0].length);
					return match[0].length;
				} else if (chr == '[') {
					this.token('[','[',1);
					this.pushEnd(']');
					if (match = SELECTOR_ATTR.exec(this._chunk)) {
						// fuck this length shit
						var idoffset = match[0].indexOf(match[1]);
						var opoffset = match[0].indexOf(match[2]);
						this.token('IDENTIFIER',match[1],match[1].length,idoffset);
						this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
						return match[0].length;
					};
					return 1;
				} else if (chr == '|') {
					var tok = this._tokens[this._tokens.length - 1];
					tTs(tok,'SELECTOR_NS');
					// tok[0] = 'SELECTOR_NS' # FIX
					return 1;
				} else if (chr == ',') {
					this.token('SELECTOR_GROUP',',',1);
					return 1;
				} else if (chr == '*') {
					this.token('UNIVERSAL_SELECTOR','*',1);
					return 1;
				} else if (chr == ')') {
					this.pair('%');
					this.token('SELECTOR_END',')',1);
					return 1;
				} else if (idx$(chr,[')','}',']','']) >= 0) {
					this.pair('%');
					return 0;
				};
			};
			
			if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
			
			// this is a closed selector
			if (kind == '(') {
				// token '(','('
				this.token('SELECTOR_START',id,id.length + 1);
				// self.pushEnd(')') # are we so sure about this?
				this.pushEnd('%');
				
				// @ends.push ')'
				// @ends.push '%'
				return id.length + 1;
			} else if (id == '%') {
				// we are already scoped in on a selector
				if (this.context() == '%') { return 1 };
				this.token('SELECTOR_START',id,id.length);
				// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
				
				this.scope('%',{open: true});
				// @ends.push '%'
				// make sure a terminator breaks out
				return id.length;
			} else {
				return 0;
			};
			
			if ((id == '%' || id == '$') && ['%','$','@','(','['].indexOf(chr) >= 0) {
				var idx = 2;
				
				
				// VERY temporary way of solving this
				if ((chr == '%' || chr == '$' || chr == '@')) {
					id += chr;
					idx = 3;
					chr = this._chunk.charAt(2);
				};
				
				
				if (chr == '(') {
					if (!(string = this.balancedSelector(this._chunk,')'))) { return 0 };
					if (0 < string.indexOf('{',1)) {
						this.token('SELECTOR',id);
						// is this even used anymore? If so - we need to fix it
						this.interpolateString(string.slice(idx,-1));
						return string.length;
					} else {
						this.token('SELECTOR',id);
						this.token('(','(');
						this.token('STRING','"' + string.slice(idx,-1) + '"');
						this.token(')',')');
						return string.length;
					};
				} else if (chr == '[') {
					this.token('SELECTOR',id);
					return 1;
					// token '[','['
					// @ends.push ''
				};
			} else {
				return 0;
			};
		};
		
		// is this really needed? Should be possible to
		// parse the identifiers and = etc i jison?
		// what is special about methodNameToken? really?
		Lexer.prototype.methodNameToken = function (){
			// we can optimize this by after a def simply
			// fetching all the way after the def until a space or (
			// and then add this to the def-token itself (as with fragment)
			if (this._chunk.charAt(0) == ' ') { return 0 };
			
			var match;
			
			if (this._end == ')') {
				var outerctx = this._ends[this._ends.length - 2];
				// weird assumption, no?
				// console.log 'context is inside!!!'
				if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
					this.token('TAG_ATTR_SET',match[1]);
					return match[0].length;
				};
			};
			
			if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			// var prev = last @tokens
			var length = match[0].length;
			
			var id = match[0];
			var ltyp = this._lastTyp;
			var typ = 'IDENTIFIER';
			var pre = id.charAt(0);
			var space = false;
			
			var m4 = match[4]; // might be out of bounds? should rather check charAt
			// drop match 4??
			
			// should this not quit here in practically all cases?
			if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!' || m4 == '?') || match[5])) {
				return 0;
			};
			
			// again, why?
			if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
				return 0;
			};
			
			if (id == 'new') {
				typ = 'NEW';
			};
			
			if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
				return 0;
			};
			
			if (id == '|') {
				// hacky way to implement this
				// with new lexer we'll use { ... } instead, and assume object-context,
				// then go back and correct when we see the context is invalid
				if (ltyp == '(' || ltyp == 'CALL_START') {
					this.token('DO','DO',0);
					this.pushEnd('|');
					// @ends.push '|'
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (ltyp == 'DO' || ltyp == '{') {
					// @ends.push '|'
					this.pushEnd('|');
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (this._ends[this._ends.length - 1] == '|') {
					this.token('BLOCK_PARAM_END','|',1);
					this.pair('|');
					return length;
				} else {
					return 0;
				};
			};
			
			// whaat?
			// console.log("method identifier",id)
			if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
				return 0;
			};
			
			if (OP_METHODS.indexOf(id) >= 0) {
				space = true;
			};
			
			// not even anything we should use?!?
			if (pre == '@') {
				typ = 'IVAR';
			} else if (pre == '$') {
				true;
				// typ = 'GVAR'
			} else if (pre == '#') {
				typ = 'TAGID';
			} else if (CONST_IDENTIFIER.test(pre) || id == 'require' || id == 'global' || id == 'exports') {
				// really? seems very strange
				// console.log('global!!',typ,id)
				typ = 'CONST';
			};
			
			// what is this really for?
			if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING','IDREF'].indexOf(ltyp) >= 0) {
				this.token('.','.',0);
			};
			
			this.token(typ,id,length);
			
			if (space) {
				this._last.spaced = true;
			};
			
			return length;
		};
		
		
		Lexer.prototype.inTag = function (){
			var len = this._ends.length;
			if (len > 0) {
				var ctx0 = this._ends[len - 1];
				var ctx1 = len > 1 ? (this._ends[len - 2]) : (ctx0);
				return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			};
			return false;
		};
		
		Lexer.prototype.isKeyword = function (id){
			if ((id == 'attr' || id == 'prop')) {
				var scop = this.getScope();
				var incls = scop == 'CLASS' || scop == 'TAG';
				// var scopes = @indents.map(|ind,i| @scopes[i] or 'NONE')
				// console.log "id is prop: {scopes.join(" -> ")} | {@indents.join(" -> ")}"
				if (incls) { return true };
			};
			
			return ALL_KEYWORDS.indexOf(id) >= 0;
		};
		
		// Matches identifying literals: variables, keywords, method names, etc.
		// Check to ensure that JavaScript reserved words aren't being used as
		// identifiers. Because Imba reserves a handful of keywords that are
		// allowed in JavaScript, we're careful not to tokid them as keywords when
		// referenced as property names here, so you can still do `jQuery.is()` even
		// though `is` means `===` otherwise.
		Lexer.prototype.identifierToken = function (){
			var ary;
			var match;
			
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			var innerctx = ctx0;
			var typ;
			var reserved = false;
			
			var addLoc = false;
			var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			
			// console.log ctx1,ctx0
			
			if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
				// console.log 'TAG_ATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			
			// see if this is a plain object-key
			// way too much logic going on here?
			// the ast should normalize whether keys
			// are accessable as keys or strings etc
			if (match = OBJECT_KEY.exec(this._chunk)) {
				var id = match[1];
				typ = 'IDENTIFIER';
				
				// FIXME loc of key includes colon
				// moveCaret(id:length)
				// console.log "ok"
				if (true) {
					// console.log "got here? {match}"
					this.token(typ,id,id.length);
					this.moveCaret(id.length);
					this.token(':',':',match[3].length);
					this.moveCaret(-id.length);
					// moveCaret(match[3]:length)
					return match[0].length;
				};
				
				// moveCaret(match[2]:length)
				// return 0
				console.log(match[3].length);
				this.token(typ,id,match[0].length);
				this.token(':',':',1);
				return match[0].length;
			};
			
			if (!(match = IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			
			var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
			var idlen = id.length;
			
			// What is the logic here?
			if (id == 'own' && this.lastTokenType() == 'FOR') {
				this.token('OWN',id,id.length);
				return id.length;
			};
			
			var prev = last(this._tokens);
			var lastTyp = this._lastTyp;
			
			// should we force this to be an identifier even if it is a reserved word?
			// this should only happen for when part of object etc
			// will prev ever be @???
			var forcedIdentifier;
			
			// again
			forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
			
			
			// temp hack! need to solve for other keywords etc as well
			// problem appears with ternary conditions.
			
			// well -- it should still be an indentifier if in object?
			// forcedIdentifier = no if id in ['undefined','break']
			
			if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
			
			// if we are not at the top level? -- hacky
			if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
				forcedIdentifier = true;
			};
			
			var isKeyword = false;
			
			// console.log "match",match
			// console.log "typ is {typ}"
			// little reason to check for this right here? but I guess it is only a simple check
			if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
				// console.log "TYP $"
				if (id == '$0') {
					typ = 'ARGUMENTS';
				} else {
					typ = 'ARGVAR';
					id = id.substr(1);
				};
			} else if (typ == '@') {
				typ = 'IVAR';
				
				// id:reserved = yes if colon
			} else if (typ == '#') {
				// we are trying to move to generic tokens,
				// so we are starting to splitting up the symbols and the items
				// we'll see if that works
				typ = 'IDENTIFIER';
				this.token('#','#');
				id = id.substr(1);
			} else if (typ == '@@') {
				typ = 'CVAR';
			} else if (typ == '$' && !colon) {
				typ = 'IDENTIFIER';
				// typ = 'GVAR'
			} else if (CONST_IDENTIFIER.test(id) || id == 'require' || id == 'global' || id == 'exports') {
				// thous should really be handled by the ast instead
				typ = 'CONST';
			} else if (id == 'elif') {
				this.token('ELSE','elif',id.length);
				this.token('IF','if');
				return id.length;
			} else {
				typ = 'IDENTIFIER';
			};
			
			
			
			// this catches all 
			if (!forcedIdentifier && (isKeyword = this.isKeyword(id))) {
				// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
				typ = id.toUpperCase();
				addLoc = true;
				
				// clumsy - but testing performance
				if (typ == 'YES') {
					typ = 'TRUE';
				} else if (typ == 'NO') {
					typ = 'FALSE';
				} else if (typ == 'NIL') {
					typ = 'NULL';
				} else if (typ == 'VAR') {
					if (this._lastVal == 'export') {
						tTs(prev,'EXPORT');
					};
				} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
					true;
				} else if (typ == 'TAG') {
					this.pushEnd('TAG');
					// @ends.push('TAG')
				} else if (typ == 'DEF') {
					// should probably shift context and optimize this
					this.openDef();
				} else if (typ == 'DO') {
					if (this.context() == 'DEF') this.closeDef();
				} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
					typ = 'LEADING_WHEN';
				} else if (typ == 'FOR') {
					this._seenFor = true;
				} else if (typ == 'UNLESS') {
					typ = 'IF'; // WARN
				} else if (UNARY.indexOf(typ) >= 0) {
					typ = 'UNARY';
				} else if (RELATION.indexOf(typ) >= 0) {
					if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
						typ = 'FOR' + typ; // ?
						this._seenFor = false;
					} else {
						typ = 'RELATION';
						if (String(this.value()) == '!') {
							this._tokens.pop(); // is fucked up??!
							// WARN we need to keep the loc, no?
							id = '!' + id;
						};
					};
				};
			};
			
			if (id == 'super') {
				typ = 'SUPER';
			};
			
			// do we really want to check this here
			if (!forcedIdentifier) {
				// should already have dealt with this
				
				if (isKeyword && IMBA_ALIASES.indexOf(id) >= 0) { id = IMBA_ALIAS_MAP[id] };
				// these really should not go here?!?
				switch (id) {
					case '!':
						typ = 'UNARY';break;
					
					case '==':
					case '!=':
					case '===':
					case '!==':
						typ = 'COMPARE';break;
					
					case '&&':
					case '||':
						typ = 'LOGIC';break;
					
					case 'break':
					case 'continue':
					case 'debugger':
					case 'arguments':
						typ = id.toUpperCase();break;
				
				};
			};
			
			// prev = last @tokens
			var len = input.length;
			
			// should be strict about the order, check this manually instead
			if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
				this.queueScope(typ);
				
				var i = this._tokens.length;
				
				while (i){
					prev = this._tokens[--i];
					var ctrl = "" + tV(prev);
					// console.log("ctrl is {ctrl}")
					// need to coerce to string because of stupid CS ===
					// console.log("prev is",prev[0],prev[1])
					if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
						tTs(prev,ctrl.toUpperCase());
						// prev[0] = ctrl.toUpperCase # FIX
					} else {
						break;
					};
				};
			} else if (typ == 'IF') {
				this.queueScope(typ);
			} else if (typ == 'IMPORT') {
				// could manually parse the whole ting here?
				this.pushEnd('IMPORT');
				// @ends.push 'IMPORT'
			} else if (id == 'from' && ctx0 == 'IMPORT') {
				typ = 'FROM';
				this.pair('IMPORT');
			} else if (id == 'as' && ctx0 == 'IMPORT') {
				typ = 'AS';
				this.pair('IMPORT');
			};
			
			if (typ == 'IDENTIFIER') {
				// see if previous was catch -- belongs in rewriter?
				if (lastTyp == 'CATCH') {
					typ = 'CATCH_VAR';
				};
			};
			
			if (colon) {
				this.token(typ,id,idlen);
				this.moveCaret(idlen);
				// console.log "add colon?"
				this.token(':',':',colon.length);
				this.moveCaret(-idlen);
			} else {
				this.token(typ,id,idlen);
			};
			
			return len;
		};
		
		// Matches numbers, including decimals, hex, and exponential notation.
		// Be careful not to interfere with ranges-in-progress.
		Lexer.prototype.numberToken = function (){
			var binaryLiteral;
			var match,number,lexedLength;
			
			if (!(match = NUMBER.exec(this._chunk))) { return 0 };
			
			number = match[0];
			lexedLength = number.length;
			
			if (binaryLiteral = /0b([01]+)/.exec(number)) {
				
				number = "" + parseInt(binaryLiteral[1],2);
			};
			
			var prev = last(this._tokens);
			
			if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
				// console.log "got here"
				this.token(".",".");
				number = number.substr(1);
			};
			
			
			this.token('NUMBER',number,lexedLength);
			return lexedLength;
		};
		
		Lexer.prototype.symbolToken = function (){
			var match,symbol,prev;
			
			if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
			symbol = match[0].substr(1);
			prev = last(this._tokens);
			
			// is this a property-access?
			// should invert this -- only allow when prev IS .. 
			
			// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
			
			// FIX
			if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR']) == -1) {
				this.token('.:',':',1);
				var sym = symbol.split(/[\:\\\/]/)[0]; // really?
				// token 'SYMBOL', "'#{symbol}'"
				this.token('IDENTIFIER',sym,sym.length,1);
				return (sym.length + 1);
			} else {
				// token 'SYMBOL', "'#{symbol}'"
				this.token('SYMBOL',symbol,match[0].length);
				return match[0].length;
			};
		};
		
		Lexer.prototype.escapeStr = function (str,heredoc,q){
			str = str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
			if (q) {
				var r = RegExp(("\\\\[" + q + "]"),"g");
				str = str.replace(r,q);
				str = str.replace(RegExp(("" + q),"g"),'\\$&');
			};
			return str;
			
			// str = str.replace(MULTILINER, '\\n')
			// str = str.replace(/\t/g, '\\t')
		};
		// Matches strings, including multi-line strings. Ensures that quotation marks
		// are balanced within the string's contents, and within nested interpolations.
		Lexer.prototype.stringToken = function (){
			var match,string;
			
			switch (this._chunk.charAt(0)) {
				case "'":
					if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
					string = match[0];
					this.token('STRING',this.escapeStr(string),string.length);
					// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
					break;
				
				case '"':
					if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
					// what about tripe quoted strings?
					
					if (string.indexOf('{') >= 0) {
						var len = string.length;
						// if this has no interpolation?
						// we are now messing with locations - beware
						this.token('STRING_START',string.charAt(0),1);
						this.interpolateString(string.slice(1,-1));
						this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
					} else {
						len = string.length;
						// string = string.replace(MULTILINER, '\\\n')
						this.token('STRING',this.escapeStr(string),len);
					};
					break;
				
				default:
				
					return 0;
			
			};
			
			this.moveHead(string);
			return string.length;
		};
		
		// Matches heredocs, adjusting indentation to the correct level, as heredocs
		// preserve whitespace, but ignore indentation to the left.
		Lexer.prototype.heredocToken = function (){
			var match,heredoc,quote,doc;
			
			if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
			
			heredoc = match[0];
			quote = heredoc.charAt(0);
			doc = this.sanitizeHeredoc(match[2],{quote: quote,indent: null});
			// console.log "found heredoc {match[0]:length} {doc:length}"
			
			if (quote == '"' && doc.indexOf('{') >= 0) {
				var open = match[1];
				// console.log doc.substr(0,3),match[1]
				this.token('STRING_START',open,open.length);
				this.interpolateString(doc,{heredoc: true,offset: open.length,quote: quote});
				this.token('STRING_END',open,open.length,heredoc.length - open.length);
			} else {
				this.token('STRING',this.makeString(doc,quote,true),0);
			};
			
			this.moveHead(heredoc);
			return heredoc.length;
		};
		
		// Matches and consumes comments.
		Lexer.prototype.commentToken = function (){
			var match,length,comment,indent,prev;
			
			var typ = 'HERECOMMENT';
			
			if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
				// console.log "match inline comment"
				length = match[0].length;
				indent = match[1];
				comment = match[2];
				
				prev = last(this._tokens);
				var pt = prev && tT(prev);
				var note = '//' + comment.substr(1);
				
				if (this._last && this._last.spaced) {
					note = ' ' + note;
					// console.log "the previous node was SPACED"
				};
				// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
				
				if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !pt) {
					// console.log "skip comment"
					// token 'INLINECOMMENT', comment.substr(2)
					// console.log "adding as terminator"
					this.token('TERMINATOR',note,length); // + '\n'
				} else {
					// console.log "add comment ({note})"
					if (pt == 'TERMINATOR') {
						tVs(prev,tV(prev) + note);
						// prev[1] += note
					} else if (pt == 'INDENT') {
						// console.log "adding comment to INDENT: {note}" # why not add directly here?
						this.addLinebreaks(1,note);
					} else {
						// console.log "comment here"
						// should we ever get here?
						this.token(typ,comment.substr(2),length); // are we sure?
					};
				};
				
				return length; // disable now while compiling
			};
			
			// should use exec?
			if (!(match = COMMENT.exec(this._chunk))) { return 0 };
			
			comment = match[0];
			var here = match[1];
			
			if (here) {
				this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
				this.token('TERMINATOR','\n');
			} else {
				this.token('HERECOMMENT',comment,comment.length);
				this.token('TERMINATOR','\n'); // auto? really?
			};
			
			this.moveHead(comment);
			return comment.length;
		};
		
		// Matches JavaScript interpolated directly into the source via backticks.
		Lexer.prototype.jsToken = function (){
			var match,script;
			
			if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
			this.token('JS',(script = match[0]).slice(1,-1));
			return script.length;
		};
		
		// Matches regular expression literals. Lexing regular expressions is difficult
		// to distinguish from division, so we borrow some basic heuristics from
		// JavaScript and Ruby.
		Lexer.prototype.regexToken = function (){
			var ary;
			var match,length,prev;
			
			if (this._chunk.charAt(0) != '/') { return 0 };
			if (match = HEREGEX.exec(this._chunk)) {
				length = this.heregexToken(match);
				this.moveHead(match[0]);
				return length;
			};
			
			prev = last(this._tokens);
			// FIX
			if (prev && (idx$(tT(prev),(prev.spaced ? (
				NOT_REGEX
			) : (
				NOT_SPACED_REGEX
			))) >= 0)) { return 0 };
			if (!(match = REGEX.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
			
			// FIXME
			// if regex[..1] is '/*'
			//	error 'regular expressions cannot begin with `*`'
			
			if (regex == '//') {
				regex = '/(?:)/';
			};
			
			this.token('REGEX',("" + regex + flags),m.length);
			return m.length;
		};
		
		// Matches multiline extended regular expressions.
		// The escaping should rather happen in AST - possibly as an additional flag?
		Lexer.prototype.heregexToken = function (match){
			var ary;
			var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
			
			if (0 > body.indexOf('#{')) {
				
				var re = body.replace(HEREGEX_OMIT,'').replace(/\//g,'\\/');
				
				if (re.match(/^\*/)) {
					this.error('regular expressions cannot begin with `*`');
				};
				
				this.token('REGEX',("/" + (re || '(?:)') + "/" + flags),heregex.length);
				return heregex.length;
			};
			
			// use more basic regex type
			
			this.token('CONST','RegExp');
			this._tokens.push(T.token('CALL_START','(',0));
			var tokens = [];
			
			for (var i = 0, items = iter$(this.interpolateString(body,{regex: true})), len = items.length, pair; i < len; i++) {
				
				pair = items[i];
				var tok = tT(pair); // FIX
				var value = tV(pair); // FIX
				
				if (tok == 'TOKENS') {
					// FIXME what is this?
					tokens.push.apply(tokens,value);
				} else {
					if (!value) {
						console.log("what??");
					};
					
					if (!(value = value.replace(HEREGEX_OMIT,''))) { continue; };
					
					value = value.replace(/\\/g,'\\\\');
					tokens.push(T.token('STRING',this.makeString(value,'"',true),0)); // FIX
				};
				
				tokens.push(T.token('+','+',0)); // FIX
			};
			
			tokens.pop();
			
			// FIX
			if (!(tokens[0] && tT(tokens[0]) == 'STRING')) {
				// FIX
				this._tokens.push(T.token('STRING','""'),T.token('+','+'));
			};
			
			this._tokens.push.apply(this._tokens,tokens); // what is this?
			// FIX
			
			if (flags) {
				this._tokens.push(T.token(',',',',0));
				this._tokens.push(T.token('STRING','"' + flags + '"',0));
			};
			
			this.token(')',')',0);
			
			return heregex.length;
		};
		
		// Matches newlines, indents, and outdents, and determines which is which.
		// If we can detect that the current line is continued onto the the next line,
		// then the newline is suppressed:
		//
		//     elements
		//       .each( ... )
		//       .map( ... )
		//
		// Keeps track of the level of indentation, because a single outdent token
		// can close multiple indents, so we need to know how far in we happen to be.
		Lexer.prototype.lineToken = function (){
			var match;
			
			if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
			// should it not pair by itself token('SELECTOR_END','%',0)
			// if @end == '%'
			// 	console.log "pairing selector in lineToken {@chunk.substr(0,10)}"
			// 	# should not need to add anything here?
			// 	pair('%')
			
			var indent = match[0];
			// var brCount = count indent, '\n'
			var brCount = this.moveHead(indent);
			this._seenFor = false;
			// reset column as well?
			
			var prev = last(this._tokens,1);
			var size = indent.length - 1 - indent.lastIndexOf('\n');
			var noNewlines = this.unfinished();
			
			// console.log "noNewlines",noNewlines
			// console.log "lineToken -- ",@chunk.substr(0,10),"--"
			if ((/^\n#\s/).test(this._chunk)) {
				this.addLinebreaks(1);
				return 0;
			};
			
			if (size - this._indebt == this._indent) {
				if (noNewlines) {
					this.suppressNewlines();
				} else {
					this.newlineToken(brCount);
				};
				return indent.length;
			};
			
			if (size > this._indent) {
				if (noNewlines) {
					this._indebt = size - this._indent;
					this.suppressNewlines();
					return indent.length;
				};
				
				if (this.inTag()) {
					// console.log "indent inside tokid?!?"
					// @indebt = size - @indent
					// suppressNewlines()
					return indent.length;
				};
				
				
				var diff = size - this._indent + this._outdebt;
				this.closeDef();
				
				var immediate = last(this._tokens);
				
				if (immediate && tT(immediate) == 'TERMINATOR') {
					tTs(immediate,'INDENT');
					immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
					
					// should rather add to meta somehow?!?
					// tVs(immediate,tV(immediate) + '%|%') # crazy
				} else {
					this.token('INDENT',"" + diff,0);
				};
				
				// console.log "indenting", prev, last(@tokens,1)
				// if prev and prev[0] == 'TERMINATOR'
				//   console.log "terminator before indent??"
				
				// check for comments as well ?
				
				this._indents.push(diff);
				this.pushEnd('OUTDENT');
				// @ends.push 'OUTDENT'
				this._outdebt = this._indebt = 0;
				this.addLinebreaks(brCount);
			} else {
				this._indebt = 0;
				this.outdentToken(this._indent - size,noNewlines,brCount);
				this.addLinebreaks(brCount - 1);
				// console.log "outdent",noNewlines,tokid()
			};
			
			this._indent = size;
			return indent.length;
		};
		
		// Record an outdent token or multiple tokens, if we happen to be moving back
		// inwards past several recorded indents.
		Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
			// here we should also take care to pop / reset the scope-body
			// or context-type for indentation 
			var dent = 0;
			while (moveOut > 0){
				var len = this._indents.length - 1;
				if (this._indents[len] == undefined) {
					moveOut = 0;
				} else if (this._indents[len] == this._outdebt) {
					moveOut -= this._outdebt;
					this._outdebt = 0;
				} else if (this._indents[len] < this._outdebt) {
					this._outdebt -= this._indents[len];
					moveOut -= this._indents[len];
				} else {
					dent = this._indents.pop() - this._outdebt;
					moveOut -= dent;
					this._outdebt = 0;
					
					if (!noNewlines) { this.addLinebreaks(1) };
					
					this.pair('OUTDENT');
					this.token('OUTDENT',"" + dent,0);
				};
			};
			
			if (dent) { this._outdebt -= moveOut };
			
			while (this.lastTokenValue() == ';'){
				this._tokens.pop();
			};
			
			if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
			
			// capping scopes so they dont hang around 
			this._scopes.length = this._indents.length;
			
			var ctx = this.context();
			if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
			this.closeDef();
			return this;
		};
		
		// Matches and consumes non-meaningful whitespace. tokid the previous token
		// as being "spaced", because there are some cases where it makes a difference.
		Lexer.prototype.whitespaceToken = function (){
			var match,nline,prev;
			if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
			prev = last(this._tokens);
			
			// FIX - why oh why?
			if (prev) {
				if (match) {
					prev.spaced = true;
					return match[0].length;
				} else {
					prev.newLine = true;
					return 0;
				};
			};
		};
		
		Lexer.prototype.addNewline = function (){
			return this.token('TERMINATOR','\n');
		};
		
		Lexer.prototype.moveHead = function (str){
			var br = count(str,'\n');
			return br;
		};
		
		
		Lexer.prototype.addLinebreaks = function (count,raw){
			var br;
			
			if (!raw && count == 0) { return this }; // no terminators?
			
			var prev = this._last;
			
			if (!raw) {
				if (count == 1) {
					br = '\n';
				} else if (count == 2) {
					br = '\n\n';
				} else if (count == 3) {
					br = '\n\n\n';
				} else {
					br = repeatString('\n',count);
				};
			};
			// FIX
			if (prev) {
				var t = prev._type; // @lastTyp
				var v = tV(prev);
				
				// we really want to add this
				if (t == 'INDENT') {
					// TODO we want to add to the indent
					// console.log "add the comment to the indent -- pre? {raw} {br}"
					
					var meta = prev._meta || (prev._meta = {pre: '',post: ''});
					meta.post += (raw || br);
					// tVs(v + (raw or br))
					return this;
				} else if (t == 'TERMINATOR') {
					// console.log "already exists terminator {br} {raw}"
					tVs(prev,v + (raw || br));
					return this;
				};
			};
			
			this.token('TERMINATOR',br,0);
			return;
		};
		
		// Generate a newline token. Consecutive newlines get merged together.
		Lexer.prototype.newlineToken = function (lines){
			// console.log "newlineToken"
			while (this.lastTokenValue() == ';'){
				console.log("pop token",this._tokens[this._tokens.length - 1]);
				this._tokens.pop();
			};
			
			this.addLinebreaks(lines);
			
			var ctx = this.context();
			// WARN now import cannot go over multiple lines
			if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
			this.closeDef(); // close def -- really?
			return this;
		};
		
		// Use a `\` at a line-ending to suppress the newline.
		// The slash is removed here once its job is done.
		Lexer.prototype.suppressNewlines = function (){
			if (this.value() == '\\') { this._tokens.pop() };
			return this;
		};
		
		// We treat all other single characters as a token. E.g.: `( ) , . !`
		// Multi-character operators are also literal tokens, so that Jison can assign
		// the proper order of operations. There are some symbols that we tokid specially
		// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
		// parentheses that indicate a method call from regular parentheses, and so on.
		Lexer.prototype.literalToken = function (){
			var match,value;
			if (match = OPERATOR.exec(this._chunk)) {
				value = match[0];
				if (CODE.test(value)) this.tagParameters();
			} else {
				value = this._chunk.charAt(0);
			};
			
			var end1 = this._ends[this._ends.length - 1];
			var end2 = this._ends[this._ends.length - 2];
			
			var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
			
			var tokid = value;
			var prev = last(this._tokens);
			var pt = prev && tT(prev);
			var pv = prev && tV(prev);
			var length = value.length;
			
			// is this needed?
			if (value == '=' && prev) {
				
				if (pv == '||' || pv == '&&') { // in ['||', '&&']
					tTs(prev,'COMPOUND_ASSIGN');
					tVs(prev,pv + '=');
					// prev[0] = 'COMPOUND_ASSIGN'
					// prev[1] += '='
					return value.length;
				};
			};
			
			if (value == ';') {
				this._seenFor = false;
				tokid = 'TERMINATOR';
			} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
				// console.log 'spaced before ( in tokid'
				// FIXME - should rather add a special token like TAG_PARAMS_START
				this.token(',',',');
			} else if (value == '->' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '/>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && this.context() == 'DEF') {
				// console.log('picked up >!!')
				tokid = 'DEF_FRAGMENT';
				
				// elif value is 'TERMINATOR' and end1 is '%' 
				// 	closeSelector()
			} else if (value == 'TERMINATOR' && end1 == 'DEF') {
				this.closeDef();
			} else if (value == '&' && this.context() == 'DEF') {
				// console.log("okay!")
				tokid = 'BLOCK_ARG';
				// change the next identifier instead?
			} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
				tokid = "SPLAT";
			} else if (value == '') {
				tokid = 'SQRT';
			} else if (value == '') {
				tokid = 'FUNC';
			} else if (idx$(value,MATH) >= 0) {
				tokid = 'MATH';
			} else if (idx$(value,COMPARE) >= 0) {
				tokid = 'COMPARE';
			} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
				tokid = 'COMPOUND_ASSIGN';
			} else if (idx$(value,UNARY) >= 0) {
				tokid = 'UNARY';
			} else if (idx$(value,SHIFT) >= 0) {
				tokid = 'SHIFT';
			} else if (idx$(value,LOGIC) >= 0) {
				tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
			} else if (prev && !prev.spaced) {
				// need a better way to do these
				if (value == '(' && end1 == '%') {
					tokid = 'TAG_ATTRS_START';
				} else if (value == '(' && idx$(pt,CALLABLE) >= 0) {
					// not using this ???
					// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
					tokid = 'CALL_START';
				} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
					tokid = 'INDEX_START';
					if (pt == '?') { tTs(prev,'INDEX_SOAK') };
					// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
				};
			};
			
			switch (value) {
				case '(':
				case '{':
				case '[':
					this.pushEnd(INVERSES[value]);break;
				
				case ')':
				case '}':
				case ']':
					this.pair(value);break;
			
			};
			
			// hacky rule to try to allow for tuple-assignments in blocks
			// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
			//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
			//   console.log("found comma")
			
			this.token(tokid,value,value.length);
			return value.length;
		};
		
		// Token Manipulators
		// ------------------
		
		// Sanitize a heredoc or herecomment by
		// erasing all external indentation on the left-hand side.
		Lexer.prototype.sanitizeHeredoc = function (doc,options){
			var match;
			var indent = options.indent;
			var herecomment = options.herecomment;
			
			if (herecomment) {
				if (HEREDOC_ILLEGAL.test(doc)) {
					this.error("block comment cannot contain '*/' starting");
				};
				if (doc.indexOf('\n') <= 0) { return doc };
			} else {
				var length_;while (match = HEREDOC_INDENT.exec(doc)){
					var attempt = match[1];
					if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
						indent = attempt;
					};
				};
			};
			
			if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
			if (!herecomment) { doc = doc.replace(/^\n/,'') };
			return doc;
		};
		
		// A source of ambiguity in our grammar used to be parameter lists in function
		// definitions versus argument lists in function calls. Walk backwards, tokidging
		// parameters specially in order to make things easier for the parser.
		Lexer.prototype.tagParameters = function (){
			var tok;
			if (this.lastTokenType() != ')') { return this };
			var stack = [];
			var tokens = this._tokens;
			var i = tokens.length;
			
			tTs(tokens[--i],'PARAM_END');
			
			while (tok = tokens[--i]){
				var t = tT(tok);
				switch (t) {
					case ')':
						stack.push(tok);
						break;
					
					case '(':
					case 'CALL_START':
						if (stack.length) {
							stack.pop();
						} else if (t == '(') {
							tTs(tok,'PARAM_START');
							return this;
						} else {
							return this;
						};
						break;
				
				};
			};
			
			return this;
		};
		
		// Close up all remaining open blocks at the end of the file.
		Lexer.prototype.closeIndentation = function (){
			// ctx = context
			// pair(ctx) if ctx in ['%','DEF']
			this.closeDef();
			this.closeSelector();
			return this.outdentToken(this._indent,false,0);
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedString = function (str,end){
			var match,letter,prev;
			
			// console.log 'balancing string!', str, end
			var stack = [end];
			var i = 0;
			
			// could it not happen here?
			while (i < (str.length - 1)){
				i++;
				letter = str.charAt(i);
				switch (letter) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							var v = str.slice(0,i + 1);
							return v;
						};
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				
				if (end == '}' && (letter == '"' || letter == "'")) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
					i += match[0].length - 1;
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == '"' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter;
			};
			
			if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
		};
		
		// Expand variables and expressions inside double-quoted strings using
		// Ruby-like notation for substitution of arbitrary expressions.
		//
		//     "Hello #{name.capitalize()}."
		//
		// If it encounters an interpolation, this method will recursively create a
		// new Lexer, tokenize the interpolated contents, and merge them into the
		// token stream.
		Lexer.prototype.interpolateString = function (str,options){
			// console.log "interpolate string"
			if(options === undefined) options = {};
			var heredoc = options.heredoc;
			var quote = options.quote;
			var regex = options.regex;
			var prefix = options.prefix;
			
			var startLoc = this._loc;
			var tokens = [];
			var pi = 0;
			var i = -1;
			var locOffset = options.offset || 1;
			var strlen = str.length;
			var letter;
			var expr;
			
			var isInterpolated = false;
			// out of bounds
			while (letter = str.charAt(i += 1)){
				if (letter == '\\') {
					i += 1;
					continue;
				};
				
				if (!(str.charAt(i) == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
					continue;
				};
				
				isInterpolated = true;
				
				// these have no real sense of location or anything?
				if (pi < i) {
					// this is the prefix-string - before any item
					var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
					// tok.@loc = @loc + pi
					// tok.@len = i - pi + 2
					tokens.push(tok);
				};
				
				tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
				
				var inner = expr.slice(1,-1);
				// console.log 'inner is',inner
				// remove leading spaces 
				// need to keep track of how much whitespace we dropped from the start
				inner = inner.replace(/^[^\n\S]+/,'');
				
				if (inner.length) {
					// we need to remember the loc we start at
					// console.log('interpolate from loc',@loc,i)
					// really? why not just add to the stack??
					// what about the added 
					// should share with the selector no?
					// console.log "tokenize inner parts of string",inner
					var spaces = 0;
					var offset = this._loc + i + (expr.length - inner.length) - 1;
					// why create a whole new lexer? Should rather reuse one
					// much better to simply move into interpolation mode where
					// we continue parsing until we meet unpaired }
					var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
					// console.log nested.pop
					
					if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
						nested.shift();
					};
					
					if (nested.length) {
						tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
					};
				};
				
				// should rather add the amount by which our lexer has moved?
				i += expr.length - 1;
				tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
				pi = i + 1;
			};
			
			// adding the last part of the string here
			if (i >= pi && pi < str.length) {
				// set the length as well - or?
				// the string after?
				// console.log 'push neostring'
				tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
			};
			
			// console.log tokens:length
			if (regex) { return tokens };
			
			if (!tokens.length) { return this.token('NEOSTRING','""') };
			
			for (var j = 0, len = tokens.length; j < len; j++) {
				this._tokens.push(tokens[j]);
			};
			
			return tokens;
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedSelector = function (str,end){
			var prev;
			var letter;
			var stack = [end];
			// FIXME
			for (var len = str.length, i = 1; i < len; i++) {
				switch (letter = str.charAt(i)) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							return str.slice(0,i + 1);
						};
						
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				if (end == '}' && letter == [')']) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == ')' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter; // what, why?
			};
			
			return this.error(("missing " + (stack.pop()) + ", starting"));
		};
		
		// Pairs up a closing token, ensuring that all listed pairs of tokens are
		// correctly balanced throughout the course of the token stream.
		Lexer.prototype.pair = function (tok){
			var wanted = last(this._ends);
			if (tok != wanted) {
				if ('OUTDENT' != wanted) { this.error(("unmatched " + tok)) };
				var size = last(this._indents);
				this._indent -= size;
				this.outdentToken(size,true,0);
				return this.pair(tok);
			};
			return this.popEnd();
		};
		
		
		// Helpers
		// -------
		
		// Add a token to the results, taking note of the line number.
		Lexer.prototype.token = function (id,value,len,offset){
			this._lastTyp = id;
			this._lastVal = value;
			var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
			this._tokens.push(tok);
			return;
		};
		
		Lexer.prototype.lastTokenType = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (tT(token)) : ('NONE');
		};
		
		Lexer.prototype.lastTokenValue = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (token._value) : ('');
		};
		
		// Peek at a tokid in the current token stream.
		Lexer.prototype.tokid = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tTs(tok,val) };
				return tT(tok);
				// tok.@type = tokid if tokid # why?
				// tok.@type
			} else {
				return null;
			};
		};
		
		// Peek at a value in the current token stream.
		Lexer.prototype.value = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tVs(tok,val) };
				return tV(tok);
				// tok.@value = val if val # why?
				// tok.@value
			} else {
				return null;
			};
		};
		
		
		// Are we in the midst of an unfinished expression?
		Lexer.prototype.unfinished = function (){
			if (LINE_CONTINUER.test(this._chunk)) { return true };
			return UNFINISHED.indexOf(this._lastTyp) >= 0;
		};
		
		// var tokens = ['\\','.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'THROW', 'EXTENDS']
		
		// Converts newlines for string literals.
		Lexer.prototype.escapeLines = function (str,heredoc){
			return str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
		};
		
		// Constructs a string token by escaping quotes and newlines.
		Lexer.prototype.makeString = function (body,quote,heredoc){
			if (!body) { return quote + quote };
			body = body.replace(/\\([\s\S])/g,function(match,contents) {
				return (contents == '\n' || contents == quote) ? (contents) : (match);
			});
			// Does not work now
			body = body.replace(RegExp(("" + quote),"g"),'\\$&');
			return quote + this.escapeLines(body,heredoc) + quote;
		};
		
		// Throws a syntax error on the current `@line`.
		Lexer.prototype.error = function (message,len){
			if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
			
			if (len) {
				message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
			};
			
			var err = new SyntaxError(message);
			err.line = this._line;
			// err:columnNumber
			err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
			err.region = [this._loc,this._loc + (len || 0)];
			throw err;
		};
		return Lexer;
	
	})()

/***/ },
/* 31 */
/***/ function(module, exports) {

	(function(){
		var TOK, LBRACKET, RBRACKET, LPAREN, RPAREN, INDENT, OUTDENT;
		
		
		module.exports.TOK = TOK = {};
		var TTERMINATOR = TOK.TERMINATOR = 1;
		var TIDENTIFIER = TOK.IDENTIFIER = 2;
		TIDENTIFIER = TOK.IVAR = 2;
		var CONST = TOK.CONST = 3;
		var VAR = TOK.VAR = 4;
		var IF = TOK.IF = 5;
		var ELSE = TOK.ELSE = 6;
		var DEF = TOK.DEF = 7;
		
		
		
		function Token(type,value,loc,len){
			this._type = type;
			this._value = value;
			this._loc = loc != null ? (loc) : (-1);
			this._len = len || 0;
			this._meta = null;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.traverse = function (){
			return;
		};
		
		Token.prototype.c = function (){
			return "" + this._value;
		};
		
		Token.prototype.toString = function (){
			return this._value;
		};
		
		Token.prototype.charAt = function (i){
			return this._value.charAt(i);
		};
		
		Token.prototype.slice = function (i){
			return this._value.slice(i);
		};
		
		Token.prototype.region = function (){
			return [this._loc,this._loc + (this._len || this._value.length)];
		};
		
		Token.prototype.sourceMapMarker = function (){
			return this._loc == -1 ? (':') : (("%$" + (this._loc) + "$%"));
			// @col == -1 ? '' : "%%{@line}${@col}%%"
		};
		
		
		function lex(){
			var token = this.tokens[this.pos++];
			var ttag;
			
			if (token) {
				ttag = token._type;
				this.yytext = token;
			} else {
				ttag = '';
			};
			
			return ttag;
		}; exports.lex = lex;
		
		
		// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
		function token(typ,val){
			return new Token(typ,val,-1,0);
		}; exports.token = token;
		
		function typ(tok){
			return tok._type;
		}; exports.typ = typ;
		function val(tok){
			return tok._value;
		}; exports.val = val; // tok[offset + 1]
		function line(tok){
			return tok._line;
		}; exports.line = line; // tok[offset + 2]
		function loc(tok){
			return tok._loc;
		}; exports.loc = loc; // tok[offset + 2]
		
		function setTyp(tok,v){
			return tok._type = v;
		}; exports.setTyp = setTyp;
		function setVal(tok,v){
			return tok._value = v;
		}; exports.setVal = setVal;
		function setLine(tok,v){
			return tok._line = v;
		}; exports.setLine = setLine;
		function setLoc(tok,v){
			return tok._loc = v;
		}; exports.setLoc = setLoc;
		
		
		module.exports.LBRACKET = LBRACKET = new Token('{','{',0,0,0);
		module.exports.RBRACKET = RBRACKET = new Token('}','}',0,0,0);
		
		module.exports.LPAREN = LPAREN = new Token('(','(',0,0,0);
		module.exports.RPAREN = RPAREN = new Token(')',')',0,0,0);
		
		LBRACKET.generated = true;
		RBRACKET.generated = true;
		LPAREN.generated = true;
		RPAREN.generated = true;
		
		module.exports.INDENT = INDENT = new Token('INDENT','2',0,0,0);
		return module.exports.OUTDENT = OUTDENT = new Token('OUTDENT','2',0,0,0);
	
	})()

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var INVERSES, LINEBREAKS;
		
		// The Imba language has a good deal of optional syntax, implicit syntax,
		// and shorthand syntax. This can greatly complicate a grammar and bloat
		// the resulting parse table. Instead of making the parser handle it all, we take
		// a series of passes over the token stream, using this **Rewriter** to convert
		// shorthand into the unambiguous long form, add implicit indentation and
		// parentheses, and generally clean things up.
		
		var T = __webpack_require__(31);
		var Token = T.Token;
		
		// Based on the original rewriter.coffee from CoffeeScript
		function Rewriter(){ };
		
		exports.Rewriter = Rewriter; // export class 
		Rewriter.prototype.tokens = function (){
			return this._tokens;
		};
		
		// Helpful snippet for debugging:
		//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
		// Rewrite the token stream in multiple passes, one logical filter at
		// a time. This could certainly be changed into a single pass through the
		// stream, with a big ol' efficient switch, but it's much nicer to work with
		// like this. The order of these passes matters -- indentation must be
		// corrected before implicit parentheses can be wrapped around blocks of code.
		Rewriter.prototype.rewrite = function (tokens,opts){
			var token;
			if(opts === undefined) opts = {};
			this._tokens = tokens;
			this._options = opts;
			
			// console.log "tokens in: " + tokens:length
			if (opts.profile) { console.time("tokenize:rewrite") };
			
			var i = 0;
			// flag empty methods
			while (token = tokens[i]){
				var next = tokens[i + 1];
				if (token._type == 'DEF_BODY' && next && next._type == 'TERMINATOR') {
					token._type = 'DEF_EMPTY';
				};
				i++;
			};
			
			this.step("ensureFirstLine");
			this.step("removeLeadingNewlines");
			this.step("removeMidExpressionNewlines");
			this.step("tagDefArguments");
			this.step("closeOpenCalls");
			this.step("closeOpenIndexes");
			this.step("closeOpenTags");
			this.step("closeOpenTagAttrLists");
			this.step("addImplicitIndentation");
			this.step("tagPostfixConditionals");
			this.step("addImplicitBraces");
			this.step("addImplicitParentheses");
			
			if (opts.profile) { console.timeEnd("tokenize:rewrite") };
			// console.log "tokens out: " + @tokens:length
			return this._tokens;
		};
		
		Rewriter.prototype.step = function (fn){
			if (this._options.profile) {
				console.log(("---- starting " + fn + " ---- "));
				console.time(fn);
			};
			
			this[fn]();
			
			if (this._options.profile) {
				console.timeEnd(fn);
				console.log("\n\n");
			};
			return;
		};
		
		// Rewrite the token stream, looking one token ahead and behind.
		// Allow the return value of the block to tell us how many tokens to move
		// forwards (or backwards) in the stream, to make sure we don't miss anything
		// as tokens are inserted and removed, and the stream changes length under
		// our feet.
		Rewriter.prototype.scanTokens = function (block){
			var token;
			var tokens = this._tokens;
			
			var i = 0;
			while (token = tokens[i]){
				i += block.call(this,token,i,tokens);
			};
			
			return true;
		};
		
		Rewriter.prototype.detectEnd = function (i,condition,action){
			var tokens = this._tokens;
			var levels = 0;
			var starts = [];
			var token;
			var t,v;
			
			while (token = tokens[i]){
				if (levels == 0 && condition.call(this,token,i,starts)) {
					return action.call(this,token,i);
				};
				if (!token || levels < 0) {
					return action.call(this,token,i - 1);
				};
				
				t = T.typ(token);
				
				if (EXPRESSION_START.indexOf(t) >= 0) {
					if (levels == 0) { starts.push(i) };
					levels += 1;
				} else if (EXPRESSION_END.indexOf(t) >= 0) {
					levels -= 1;
				};
				i += 1;
			};
			return i - 1;
		};
		
		Rewriter.prototype.ensureFirstLine = function (){
			var tok = this._tokens[0];
			
			if (T.typ(tok) == 'TERMINATOR') {
				// console.log "adding bodystart"
				this._tokens = [T.token('BODYSTART','BODYSTART')].concat(this._tokens);
				// T.setTyp(tok,'HEADER')
			};
			return;
		};
		
		// Leading newlines would introduce an ambiguity in the grammar, so we
		// dispatch them here.
		Rewriter.prototype.removeLeadingNewlines = function (){
			var at = 0;
			
			for (var i = 0, ary = iter$(this._tokens), len = ary.length; i < len; i++) {
				if (T.typ(ary[i]) != 'TERMINATOR') {
					at = i;break;
				};
			};
			
			if (at) { this._tokens.splice(0,at) };
			
			return;
		};
		
		// Some blocks occur in the middle of expressions -- when we're expecting
		// this, remove their trailing newlines.
		Rewriter.prototype.removeMidExpressionNewlines = function (){
			var self = this;
			return self.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
				var next = self.tokenType(i + 1);
				
				if (!(T.typ(token) == 'TERMINATOR' && EXPRESSION_CLOSE.indexOf(next) >= 0)) { return 1 };
				if (next == 'OUTDENT') { return 1 };
				tokens.splice(i,1);
				return 0;
			});
		};
		
		
		Rewriter.prototype.tagDefArguments = function (){
			return true;
		};
		
		// The lexer has tagged the opening parenthesis of a method call. Match it with
		// its paired close. We have the mis-nested outdent case included here for
		// calls that close on the same line, just before their outdent.
		Rewriter.prototype.closeOpenCalls = function (){
			var self = this;
			var condition = function(token,i) {
				var t = T.typ(token);
				return (t == ')' || t == 'CALL_END') || t == 'OUTDENT' && self.tokenType(i - 1) == ')';
			};
			
			var action = function(token,i) {
				var t = T.typ(token);
				var tok = self._tokens[t == 'OUTDENT' ? (i - 1) : (i)];
				return T.setTyp(tok,'CALL_END');
			};
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'CALL_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close.
		Rewriter.prototype.closeOpenIndexes = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[']','INDEX_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'INDEX_END'); };
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		
		Rewriter.prototype.closeOpenTagAttrLists = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[')','TAG_ATTRS_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_ATTRS_END'); }; // 'TAG_ATTRS_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_ATTRS_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close. Should be done in lexer directly
		Rewriter.prototype.closeOpenTags = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['>','TAG_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_END'); }; // token[0] = 'TAG_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		Rewriter.prototype.addImplicitCommas = function (){
			return;
		};
		
		Rewriter.prototype.addImplicitBlockCalls = function (){
			var token;
			var i = 1;
			var tokens = this._tokens;
			
			while (token = tokens[i]){
				var t = token._type;
				var v = token._value;
				// hmm
				if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
					tokens.splice(i + 1,0,T.token('CALL_END',')'));
					tokens.splice(i + 1,0,T.token('CALL_START','('));
					i++;
				};
				i++;
			};
			
			return;
		};
		
		// Object literals may be written with implicit braces, for simple cases.
		// Insert the missing braces here, so that the parser doesn't have to.
		Rewriter.prototype.addImplicitBraces = function (){
			var self = this;
			var stack = [];
			var start = null;
			var startIndent = 0;
			var startIdx = null;
			
			var noBraceTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			var noBraceContext = ['IF','TERNARY','FOR'];
			
			var noBrace = false;
			
			var scope = function() {
				return stack[stack.length - 1] || [];
			};
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var open = function(token,i) {
				return self._tokens.splice(i,0,T.LBRACKET);
			};
			
			var close = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var stackToken = function(a,b) {
				return [a,b];
			};
			
			return self.scanTokens(function(token,i,tokens) {
				var type = T.typ(token);
				var v = T.val(token);
				var ctx = stack[stack.length - 1] || [];
				var idx;
				
				if (noBraceContext.indexOf(type) >= 0) {
					// console.log "found noBraceTag {type}"
					stack.push(stackToken(type,i));
					return 1;
				};
				
				if (v == '?') {
					// console.log('TERNARY OPERATOR!')
					stack.push(stackToken('TERNARY',i));
					return 1;
				};
				
				// no need to test for this here as well as in
				if (EXPRESSION_START.indexOf(type) >= 0) {
					if (type == 'INDENT' && noBraceContext.indexOf(ctx[0]) >= 0) {
						stack.pop();
					};
					
					// console.log('expression start',type,ctx[0])
					if (type == 'INDENT' && self.tokenType(i - 1) == '{') {
						// stack ?!? no token
						stack.push(stackToken('{',i)); // should not autogenerate another?
					} else {
						stack.push(stackToken(type,i));
					};
					return 1;
				};
				
				if (EXPRESSION_END.indexOf(type) >= 0) {
					// console.log "EXPRESSION_END at {type} - stack is {ctx[0]}"
					if (ctx[0] == 'TERNARY') { // FIX?
						stack.pop();
					};
					
					start = stack.pop();
					if (!start) {
						console.log("NO STACK!!");
					};
					start[2] = i;
					
					// seems like the stack should use tokens, no?)
					if (start[0] == '{' && start.generated) { //  # type != '}' # and start:generated
						close(token,i);
						return 1;
					};
					
					return 1;
				};
				
				// is this correct? same for if/class etc?
				if (ctx[0] == 'TERNARY' && (type == 'TERMINATOR' || type == 'OUTDENT')) {
					stack.pop();
					return 1;
				};
				
				if (noBraceContext.indexOf(ctx[0]) >= 0 && type == 'INDENT') {
					console.log("popping noBraceContext");
					stack.pop();
					return 1;
				};
				
				
				if (type == ',') {
					// automatically add an ending here if inside:generated scope?
					// it is important that this is:generated(!)
					if (ctx[0] == '{' && ctx.generated) {
						tokens.splice(i,0,T.RBRACKET);
						stack.pop();
						return 2;
					} else {
						return 1;
					};
					true;
				};
				
				// found a type
				if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
					// could just check if the end was right before this?
					
					if (start && start[2] == i - 1) {
						// console.log('this expression was just ending before colon!')
						idx = start[1] - 1; // these are the stackTokens
					} else {
						// console.log "rewrite here? #{i}"
						idx = i - 2; // if start then start[1] - 1 else i - 2
						// idx = idx - 1 if tokenType(idx) is 'TERMINATOR'
					};
					
					while (self.tokenType(idx - 1) == 'HERECOMMENT'){
						idx -= 2;
					};
					
					var t0 = tokens[idx - 1];
					
					if (t0 && T.typ(t0) == '}' && t0.generated) {
						tokens.splice(idx - 1,1);
						var s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
						tokens.splice(idx - 2,1);
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else {
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						open(token,idx + 1);
						return 2;
					};
				};
				
				// we probably need to run through autocall first?!
				
				if (type == 'DO') { // and ctx:generated
					var prev = T.typ(tokens[i - 1]); // [0]
					if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
						
						var tok = T.token(',',',');
						tok.generated = true;
						tokens.splice(i,0,tok);
						
						if (ctx.generated) {
							close(token,i);
							stack.pop();
							return 2;
						};
					};
				};
				
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'DEF_BODY') && ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
				
				return 1;
			});
		};
		
		// Methods may be optionally called without parentheses, for simple cases.
		// Insert the implicit parentheses here, so that the parser doesn't have to
		// deal with them.
		// Practically everything will now be callable this way (every identifier)
		Rewriter.prototype.addImplicitParentheses = function (){
			
			var self = this, token;
			var noCallTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.token('CALL_END',')'));
			};
			
			// console.log "adding implicit parenthesis" # ,self:scanTokens
			var tokens = self._tokens;
			
			var noCall = false;
			var seenFor = false;
			var endCallAtTerminator = false;
			
			var i = 0;
			while (token = tokens[i]){
				
				// to handle cases like:
				// if a(do yes).test
				// 	yes
				// we need to keep a stack for balanced pairs
				// until then you must explicitly end the call like
				// if a(do yes).test()
				// 	yes
				
				var type = token._type;
				
				var prev = tokens[i - 1];
				var current = tokens[i];
				var next = tokens[i + 1];
				
				var pt = prev && prev._type;
				var nt = next && next._type;
				
				// if pt == 'WHEN'
				// Never make these tags implicitly call
				// should we not just remove these from IMPLICIT_FUNC?
				if ((pt == ')' || pt == ']') && type == 'INDENT') {
					noCall = true;
				};
				
				if (noCallTag.indexOf(pt) >= 0) {
					// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
					endCallAtTerminator = true;
					noCall = true;
					if (pt == 'FOR') { seenFor = true };
				};
				
				
				var callObject = false;
				var callIndent = false;
				
				// [prev, current, next] = tokens[i - 1 .. i + 1]
				
				// check for comments
				// console.log "detect end??"
				if (!noCall && type == 'INDENT' && next) {
					var prevImpFunc = pt && IMPLICIT_FUNC.indexOf(pt) >= 0;
					var nextImpCall = nt && IMPLICIT_CALL.indexOf(nt) >= 0;
					callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
					callIndent = nextImpCall && prevImpFunc;
				};
				
				var seenSingle = false;
				var seenControl = false;
				// Hmm ?
				
				// this is not correct if this is inside a block,no?
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'INDENT')) {
					endCallAtTerminator = false;
					noCall = false;
				};
				
				if (type == '?' && prev && !prev.spaced) { token.call = true };
				
				// where does fromThem come from?
				if (token.fromThen) {
					i += 1;continue;
				};
				// here we deal with :spaced and :newLine
				if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC.indexOf(pt) >= 0) && (IMPLICIT_CALL.indexOf(type) >= 0 || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
					i += 1;continue;
				};
				
				
				tokens.splice(i,0,T.token('CALL_START','('));
				// console.log "added ( {prev}"
				var cond = function(token,i) {
					var type = T.typ(token);
					if (!seenSingle && token.fromThen) { return true };
					var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
					if (ifelse || type == 'CATCH') { seenSingle = true };
					if (ifelse || type == 'SWITCH' || type == 'TRY') { seenControl = true };
					var prev = self.tokenType(i - 1);
					
					if ((type == '.' || type == '?.' || type == '::') && prev == 'OUTDENT') { return true };
					if (endCallAtTerminator && (type == 'INDENT' || type == 'TERMINATOR')) { return true };
					if ((type == 'WHEN' || type == 'BY') && !seenFor) {
						// console.log "dont close implicit call outside for"
						return false;
					};
					
					var post = tokens[i + 1];
					var postTyp = post && T.typ(post);
					// WTF
					return !token.generated && prev != ',' && (IMPLICIT_END.indexOf(type) >= 0 || (type == 'INDENT' && !seenControl) || (type == 'DOS' && prev != '=')) && (type != 'INDENT' || (self.tokenType(i - 2) != 'CLASS' && IMPLICIT_BLOCK.indexOf(prev) == -1 && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL.indexOf(postTyp) >= 0))));
				};
				
				// The action for detecting when the call should end
				// console.log "detect end??"
				self.detectEnd(i + 1,cond,action);
				if (T.typ(prev) == '?') { T.setTyp(prev,'FUNC_EXIST') };
				i += 2;
				// need to reset after a match
				endCallAtTerminator = false;
				noCall = false;
				seenFor = false;
			};
			
			
			return;
		};
		
		// Because our grammar is LALR(1), it can't handle some single-line
		// expressions that lack ending delimiters. The **Rewriter** adds the implicit
		// blocks, so it doesn't need to. ')' can close a single-line block,
		// but we need to make sure it's balanced.
		Rewriter.prototype.addImplicitIndentation = function (){
			
			
			var self = this, token;
			var i = 0;
			var tokens = self._tokens;
			while (token = tokens[i]){
				var type = T.typ(token);
				var next = self.tokenType(i + 1);
				
				// why are we removing terminators after then? should be able to handle
				if (type == 'TERMINATOR' && next == 'THEN') {
					tokens.splice(i,1);
					continue;
				};
				
				if (type == 'CATCH' && idx$(self.tokenType(i + 2),['OUTDENT','TERMINATOR','FINALLY']) >= 0) {
					tokens.splice.apply(tokens,[].concat([i + 2,0], [].slice.call(self.indentation(token))));
					i += 4;continue;
				};
				
				if (SINGLE_LINERS.indexOf(type) >= 0 && (next != 'INDENT' && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
					
					var starter = type;
					
					var indent = T.token('INDENT','2');
					var outdent = T.OUTDENT;
					// var indent, outdent = indentation(token)
					if (starter == 'THEN') { indent.fromThen = true }; // setting special values for these -- cannot really reuse?
					indent.generated = true;
					// outdent:generated = true
					tokens.splice(i + 1,0,indent);
					
					var condition = function(token,i) {
						var t = T.typ(token);
						return T.val(token) != ';' && SINGLE_CLOSERS.indexOf(t) >= 0 && !(t == 'ELSE' && starter != 'IF' && starter != 'THEN');
					};
					
					var action = function(token,i) {
						var idx = self.tokenType(i - 1) == ',' ? (i - 1) : (i);
						return tokens.splice(idx,0,outdent);
					};
					
					self.detectEnd(i + 2,condition,action);
					if (type == 'THEN') { tokens.splice(i,1) };
				};
				
				i++;
			};
			
			return;
		};
		
		// Tag postfix conditionals as such, so that we can parse them with a
		// different precedence.
		Rewriter.prototype.tagPostfixConditionals = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['TERMINATOR','INDENT']) >= 0; };
			
			return self.scanTokens(function(token,i) {
				var typ = T.typ(token);
				if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
				var original = token;
				self.detectEnd(i + 1,condition,function(token,i) {
					if (T.typ(token) != 'INDENT') { return T.setTyp(original,'POST_' + T.typ(original)) };
				});
				return 1;
			});
		};
		
		// Generate the indentation tokens, based on another token on the same line.
		Rewriter.prototype.indentation = function (token){
			return [T.token('INDENT','2'),T.token('OUTDENT','2')];
		};
		
		// Look up a type by token index.
		Rewriter.prototype.type = function (i){
			// if i < 0 then return null
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// if tok then tok[0] else null
		};
		
		Rewriter.prototype.tokenType = function (i){
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// return tok and tok[0]
		};
		
		// Constants
		// ---------
		
		// List of the token pairs that must be balanced.
		var BALANCED_PAIRS = [
			['(',')'],
			['[',']'],
			['{','}'],
			['{{','}}'],
			['INDENT','OUTDENT'],
			['CALL_START','CALL_END'],
			['PARAM_START','PARAM_END'],
			['INDEX_START','INDEX_END'],
			['TAG_START','TAG_END'],
			['TAG_PARAM_START','TAG_PARAM_END'],
			['TAG_ATTRS_START','TAG_ATTRS_END'],
			['BLOCK_PARAM_START','BLOCK_PARAM_END']
		];
		
		// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
		// look things up from either end.
		module.exports.INVERSES = INVERSES = {};
		
		// The tokens that signal the start/end of a balanced pair.
		// var EXPRESSION_START = []
		// var EXPRESSION_END   = []
		
		for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
			pair = ary[i];
			var left = pair[0];
			var rite = pair[1];
			INVERSES[rite] = left;
			INVERSES[left] = rite;
		};
		
		var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','TAG_PARAM_START','BLOCK_PARAM_START','STRING_START','{{','TAG_START'];
		var EXPRESSION_END = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','TAG_PARAM_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END'];
		
		var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];
		
		// Tokens that indicate the close of a clause of an expression.
		var EXPRESSION_CLOSE = ['CATCH','WHEN','ELSE','FINALLY'].concat(EXPRESSION_END);
		
		// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
		var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
		'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];
		
		// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
		var IMPLICIT_CALL = [
			'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
			'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
			'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
			'FOR','STRING_START','CONTINUE','BREAK'
		]; // '->', '=>', why does it not work with symbol?
		
		var IMPLICIT_INDENT_CALL = [
			'FOR'
		];
		// is not do an implicit call??
		
		var IMPLICIT_UNSPACED_CALL = ['+','-'];
		
		// Tokens indicating that the implicit call must enclose a block of expressions.
		var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 
		
		var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		var LOGIC = ['&&','||','&','|','^'];
		
		// optimize for fixed arrays
		var NO_IMPLICIT_BLOCK_CALL = [
			'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
			'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
		]; // .concat(COMPOUND_ASSIGN)
		
		
		// console.log NO_IMPLICIT_BLOCK_CALL:length
		// NO_IMPLICIT_BLOCK_CALL
		// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']
		
		var IMPLICIT_COMMA = ['DO'];
		
		// Tokens that always mark the end of an implicit call for single-liners.
		var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];
		
		// Single-line flavors of block expressions that have unclosed endings.
		// The grammar can't disambiguate them, so we insert the implicit indentation.
		var SINGLE_LINERS = ['ELSE','TRY','FINALLY','THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR']; // '->', '=>', really?
		var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
		
		// Tokens that end a line.
		return LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT'];
	
	})()

/***/ },
/* 33 */
/***/ function(module, exports) {

	(function(){
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		// create separate error-types with all the logic
		
		function ImbaParseError(e,o){
			this.error = e;
			this.message = e.message;
			this.filename = e.filename;
			this.line = e.line;
			this._options = o || {};
			this;
		};
		
		subclass$(ImbaParseError,Error);
		exports.ImbaParseError = ImbaParseError; // export class 
		ImbaParseError.wrap = function (err){
			// what about the stacktrace?
			return new ImbaParseError(err);
		};
		
		ImbaParseError.prototype.set = function (opts){
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(opts), l = keys.length; i < l; i++){
				this._options[keys[i]] = opts[keys[i]];
			};
			return this;
		};
		
		ImbaParseError.prototype.start = function (){
			var o = this._options;
			var idx = o.pos - 1;
			var tok = o.tokens && o.tokens[idx];
			while (tok && tok._loc == -1){
				tok = o.tokens[--idx];
			};
			return tok;
		};
		
		ImbaParseError.prototype.desc = function (){
			var o = this._options;
			var msg = this.message;
			if (o.token && o.token._loc == -1) {
				return 'Syntax Error';
			} else {
				return msg;
			};
		};
		
		ImbaParseError.prototype.loc = function (){
			var start_;
			return (start_ = this.start()) && start_.region  &&  start_.region();
		};
		
		ImbaParseError.prototype.toJSON = function (){
			var o = this._options;
			var tok = this.start();
			// var tok = o:tokens and o:tokens[o:pos - 1]
			// var loc = tok and [tok.@loc,tok.@loc + (tok.@len or tok.@value:length)] or [0,0]
			// , col: tok.@col, line: tok.@line
			// get the token itself?
			return {warn: true,message: this.desc(),loc: this.loc()};
		};
		return ImbaParseError;
	
	})()

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var Region = __webpack_require__(27).Region;
		
		
		function isWhitespace(str){
			return (/^[\n\t\ ]+$/).test(str);
		}; exports.isWhitespace = isWhitespace;
		
		function commonAncestor(a,b){
			if (a instanceof Array) {
				var arr = a.slice();
				return arr.reduce(function(prev,curr,i) {
					return commonAncestor(prev,curr);
				},arr.shift());
			};
			
			if (!a || !b) { return (a || b) };
			
			a = a._dom || a;
			b = b._dom || b;
			
			while (!a.contains(b)){
				a = a.parentNode;
			};
			while (!b.contains(a)){
				b = b.parentNode;
			};
			
			return tag$wrap(a);
		}; exports.commonAncestor = commonAncestor;
		
		
		var pairs = {
			'"': '"',
			"'": "'",
			'(': ')',
			'<': '>',
			'[': ']',
			'{': '}'
		};
		
		function wrapText(text,open,close){
			close || (close = pairs[open]);
			if (open == "'") { text = text.replace(/\'/g,"\\'") };
			return (open || '') + text + (close || '');
		}; exports.wrapText = wrapText;
		
		
		function stringIsBalanced(str){
			var opens = '[{("\'';
			var closes = ']})"\'';
			var stack = [];
			var i = 0;
			var s,end;
			
			while (s = str[i++]){
				var oid = opens.indexOf(s);
				
				if (s == end) {
					stack.pop();
					end = stack[stack.length - 1];
				} else if (oid >= 0) {
					stack.push(end = closes[oid]);
				};
			};
			
			return stack.length == 0 ? (true) : (false);
		}; exports.stringIsBalanced = stringIsBalanced;
		
		function colToLoc(line,col,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var ci = 0;
			var rci = 0; // real column
			var char$;
			
			if (col == 0) { return 0 };
			
			while (char$ = line[ci++]){
				if (char$ == '\t') {
					var rest = tabsize - rci % tabsize;
					rci += rest;
				} else {
					rci += 1;
				};
				
				if (rci >= col) {
					return ci;
				};
			};
			
			return line.length;
		}; exports.colToLoc = colToLoc;
		
		function colToViewCol(line,col,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var ci = 0;
			var rci = 0; // real column
			var char$;
			
			if (col == 0) { return 0 };
			
			while (char$ = line[ci++]){
				if (char$ == '\t') {
					var rest = tabsize - rci % tabsize;
					if (rest > 3 && col <= rci + 2) { break; };
					rci += rest;
				} else {
					rci += 1;
				};
				
				if (col <= rci) { break; };
			};
			return rci;
		}; exports.colToViewCol = colToViewCol;
		
		function colsForLine(line,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var col = 0;
			var idx = 0;
			var char$;
			while (char$ = line[idx++]){
				if (char$ == '\t') {
					var rest = tabsize - col % tabsize;
					col += rest;
				} else {
					col += 1;
				};
			};
			return col;
		}; exports.colsForLine = colsForLine;
		
		function rowcol(buf,loc,tabsize){
			if(tabsize === undefined) tabsize = 4;
			buf = buf.toString();
			var pos = loc;
			var col = 0;
			var line = 0;
			var char$;
			
			// go back to start of line
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					break;
				};
				pos--;
			};
			
			// get column for slice
			while ((pos < loc) && (char$ = buf[pos])){
				if (char$ == '\t') {
					var rest = tabsize - (col % tabsize);
					col += rest;
				} else {
					col += 1;
				};
				pos++;
			};
			
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					line++;
				};
				pos--;
			};
			
			return [line,col];
		}; exports.rowcol = rowcol;
		
		function increaseIndent(str){
			var reg = /^(\s*(.*\=\s*)?(export |global |extend )?(class|def|tag|unless|if|else|elif|switch|try|catch|finally|for|while|until|do))/;
			var other = /\b(do)\b/;
			return reg.test(str) || other.test(str);
		}; exports.increaseIndent = increaseIndent;
		
		
		function repeatString(str,count){
			return new Array(count + 1).join(str);
		}; exports.repeatString = repeatString;
		
		
		function patchString(orig,str,mode){
			var region;
			var text = orig.toString();
			
			if (mode == 'append') {
				return text + str;
			} else if (mode == 'prepend') {
				return "" + str + text;
			} else {
				if (region = Region.normalize(mode)) {
					// let region = Region.normalize()
					return text.substr(0,region.start()) + str + text.slice(region.end());
				};
			};
		}; exports.patchString = patchString;; return patchString;
		
		
	
	})()

/***/ },
/* 35 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		function HistoryState(data){
			if(data === undefined) data = {};
			this._timestamp = new Date();
			this._data = data;
			this;
		};
		
		
		
		HistoryState.prototype.data = function(v){ return this._data; }
		HistoryState.prototype.setData = function(v){ this._data = v; return this; };
		
		
		HistoryState.prototype.timestamp = function(v){ return this._timestamp; }
		HistoryState.prototype.setTimestamp = function(v){ this._timestamp = v; return this; };
		
		HistoryState.prototype.apply = function (view){
			return this;
		};
		
		HistoryState.prototype.update = function (data){
			this._data = data;
			this._timestamp = new Date();
			return this;
		};
		
		
		function FullHistoryState(){ return HistoryState.apply(this,arguments) };
		
		subclass$(FullHistoryState,HistoryState);
		FullHistoryState.prototype.apply = function (view){
			view.loadState(this._data);
			return this;
		};
		
		function DiffHistoryState(){ return HistoryState.apply(this,arguments) };
		
		subclass$(DiffHistoryState,HistoryState);
		
		
		var types = {};
		
		function Command(params){
			this._params = params;
		};
		
		
		
		Command.prototype.prev = function(v){ return this._prev; }
		Command.prototype.setPrev = function(v){ this._prev = v; return this; };
		
		
		Command.prototype.next = function(v){ return this._next; }
		Command.prototype.setNext = function(v){ this._next = v; return this; };
		
		
		Command.prototype.frame = function(v){ return this._frame; }
		Command.prototype.setFrame = function(v){ this._frame = v; return this; };
		
		Command.sym = function (sym){
			var $0 = arguments, i = $0.length;
			var pars = new Array(i>1 ? i-1 : 0);
			while(i>1) pars[--i - 1] = $0[i];
			this.prototype._symbol = sym;
			this.prototype._signature = pars;
			types[sym] = this;
			return this;
		};
		
		Command.load = function (o){
			var typ = types[o[0]];
			var frame = o[1];
			var cmd = typ.build(o[2]);
			cmd.setFrame(frame);
			return cmd;
		};
		
		Command.build = function (params){
			return new this(params);
		};
		
		Command.prototype.data = function (){
			return this._data;
		};
		
		Command.prototype.params = function (){
			return this._params;
		};
		
		Command.prototype.undo = function (view){
			return this.prev();
		};
		
		Command.prototype.redo = function (view){
			return this;
		};
		
		Command.prototype.enter = function (view){
			return this;
		};
		
		Command.prototype.remove = function (){
			var v_;
			if (this.prev()) { (this.prev().setNext(v_ = this.next()),v_) };
			if (this.next()) { (this.next().setPrev(v_ = this.prev()),v_) };
			return this;
		};
		
		Command.prototype.toJSON = function (){
			return [this._symbol,this._frame || 0,this.params() || []];
		};
		
		function Mark(){ return Command.apply(this,arguments) };
		
		subclass$(Mark,Command);
		Mark.sym('M','value');
		
		
		function Snapshot(params){
			this._code = params[0];
		};
		
		subclass$(Snapshot,Mark);
		Snapshot.sym('S','code');
		
		Snapshot.prototype.params = function (){
			return [this._code];
		};
		
		Snapshot.prototype.redo = function (view){
			console.log('load',this._code);
			view.load(this._code);
			// must repair? what about annotations?
			return this;
		};
		
		function Selection(params){
			this._old = params[0];
			this._new = params[1];
		};
		
		subclass$(Selection,Command);
		Selection.sym('|','old','new');
		
		Selection.load = function (val){
			return new this(val);
		};
		
		Selection.prototype.params = function (){
			return [this._old,this._new];
		};
		
		Selection.prototype.redo = function (view){
			view.caret().set(JSON.parse(this._new));
			return this;
		};
		
		Selection.prototype.enter = function (view){
			this.redo(view);
			return this;
		};
		
		Selection.prototype.undo = function (view){
			// we need to know about the previous selection for this?
			// can either store both - or traverse backwards to the previous
			// command like this
			var old = JSON.parse(this._old);
			console.log('move selection back to old',old,this.data());
			view.caret().set(old);
			return this.prev();
		};
		
		
		function Insert(pars){
			this._point = pars[0];
			this._str = pars[1];
		};
		
		subclass$(Insert,Command);
		Insert.sym('+','point','str');
		
		Insert.prototype.params = function (){
			return [this._point,this._str];
		};
		
		Insert.prototype.redo = function (view){
			console.log('redo Insert');
			return view.insert(this._point,this._str);
		};
		
		Insert.prototype.undo = function (view){
			console.log('undo Insert');
			view.erase([this._point,this._point + this._str.length]);
			return this.prev();
		};
		
		function Erase(params){
			this._region = params[0];
			this._str = params[1];
		};
		
		subclass$(Erase,Command);
		Erase.sym('-','region','str');
		
		Erase.prototype.params = function (){
			return [this._region,this._str];
		};
		
		Erase.prototype.redo = function (view){
			console.log('redo Erase');
			return view.erase(this._region);
		};
		
		Erase.prototype.undo = function (view){
			// if we dont know the text to 
			console.log('undo Erase');
			view.insert(this._region.start(),this._str);
			return this.prev();
		};
		
		
		function History(view){
			this._mode = 'normal';
			this._view = view;
			this._enabled = true;
			this._active = false;
			this.setCurrent(this._seed = new Mark());
			this;
		};
		
		exports.History = History; // export class 
		
		
		History.prototype.mode = function(v){ return this._mode; }
		History.prototype.setMode = function(v){ this._mode = v; return this; };
		
		
		History.prototype.view = function(v){ return this._view; }
		History.prototype.setView = function(v){ this._view = v; return this; };
		
		
		History.prototype.enabled = function(v){ return this._enabled; }
		History.prototype.setEnabled = function(v){ this._enabled = v; return this; };
		
		
		History.prototype.current = function(v){ return this._current; }
		History.prototype.setCurrent = function(v){ this._current = v; return this; };
		
		
		History.prototype.seed = function(v){ return this._seed; }
		History.prototype.setSeed = function(v){ this._seed = v; return this; };
		
		
		History.prototype.tail = function(v){ return this._tail; }
		History.prototype.setTail = function(v){ this._tail = v; return this; }; // is this behind or in the very front?
		
		History.prototype.add = function (item,move,frame){
			if(move === undefined) move = true;
			if(frame === undefined) frame = this.view().frames();
			item.setFrame(frame);
			
			if (this.current()) {
				// if current has a next event
				// this should be detached here?
				item.setPrev(this.current());
				this.current().setNext(item);
			};
			
			if (move) { (this.setCurrent(item),item) };
			return this;
		};
		
		History.prototype.next = function (){
			var current_;
			return (current_ = this.current()) && current_.next  &&  current_.next();
		};
		
		History.prototype.prev = function (){
			var current_;
			return (current_ = this.current()) && current_.prev  &&  current_.prev();
		};
		
		History.prototype.update = function (o){
			return this;
		};
		
		History.prototype.move = function (dir){
			if(dir === undefined) dir = 1;
			return this;
		};
		
		History.prototype.redo = function (){
			var self = this;
			self.apply(function() {
				var res = [];while (self.next()){
					self.next().redo(self.view(),self);
					self.setCurrent(self.next());
					if (self.current() instanceof Mark) { break; };
				};return res;
			});
			return self;
		};
		
		History.prototype.undo = function (){
			var self = this;
			self.apply(function() {
				// should be possible to undo 
				var res = [], v_, current_;while (self.current()){
					if (self.prev()) { (self.setCurrent(v_ = self.current().undo(self.view(),self)),v_) };
					(current_ = self.current()) && current_.enter  &&  current_.enter(self.view(),self);
					if (self.current() instanceof Mark) { break; };
				};return res;
			});
			
			return self;
		};
		
		History.prototype.apply = function (cb){
			this._active = true;
			cb && cb();
			this._active = false;
			return this;
		};
		
		History.prototype.batch = function (cb){
			return this;
		};
		
		History.prototype.enter = function (state){
			state.apply(this.view());
			return this;
		};
		
		History.prototype.onerase = function (reg,str,edit){
			if (this._active) { return this };
			return this.add(new Erase([reg,str]));
		};
		
		History.prototype.oninsert = function (loc,str,edit){
			if (this._active) { return this };
			return this.add(new Insert([loc,str]));
		};
		
		History.prototype.oncaret = function (old,new$){
			if (this._active) { return this };
			return this.add(new Selection([old,new$]));
		};
		
		History.prototype.onload = function (code){
			if (this._active) { return this };
			var mark = new Snapshot([code]);
			return this.add(mark);
		};
		
		History.prototype.mark = function (value){
			if (this._active) { return this };
			var mark = new Mark([value]);
			return this.add(mark);
		};
		
		History.prototype.tick = function (){
			
			var self = this;
			if (self._mode == 'play') {
				// console.log 'plyaing'
				var frame = self.view().frames() - self._offset;
				// console.log 'history.tick will play',frame,next,current
				self.apply(function() {
					var res = [], v_;while (self.next() && self.next().frame() <= frame){
						// console.log 'history.tick play',frame,next,current
						// console.log 'replay frame!'
						self.next().redo(self.view(),self);
						res.push(((self.setCurrent(v_ = self.next()),v_)));
					};return res;
				});
				
				if (!(self.next())) {
					self.setMode('live');
				};
			};
			return self;
		};
		
		History.prototype.play = function (){
			// should probably happen in a different manager
			var self = this;
			var snap = self.seed();
			while (!(!snap || (snap instanceof Snapshot))){
				snap = snap.next();
			};
			
			self._offset = self.view().frames() - snap.frame();
			console.log("playing from seed",snap,self._offset);
			// console.log 'found snapshot?!? -- offset frame',@offset
			self.apply(function() { var v_;
			return (self.setCurrent(v_ = snap.redo(self.view(),self)),v_); });
			self.setMode('play');
			return self;
		};
		
		History.prototype.toJSON = function (){
			var data = [];
			var step = this._seed;
			
			while (step){
				data.push(step.toJSON());
				step = step.next();
			};
			
			return {commands: data};
		};
		
		History.prototype.load = function (data){
			var step = this.seed();
			for (var i = 0, ary = iter$(data.commands), len = ary.length; i < len; i++) {
				var item = Command.load(ary[i]);
				item.setPrev(step);
				step.setNext(item);
				step = item;
				// console.log 'load item',item
			};
			// console.log 'loaded'
			return this;
		};
		return History;
		
		
	
	})()

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		function Logger(view){
			this._enabled = true;
			this._view = view;
			this;
		};
		
		exports.Logger = Logger; // export class 
		
		
		Logger.prototype.enabled = function(v){ return this._enabled; }
		Logger.prototype.setEnabled = function(v){ this._enabled = v; return this; };
		
		
		Logger.prototype.view = function(v){ return this._view; }
		Logger.prototype.setView = function(v){ this._view = v; return this; };
		
		Logger.prototype.log = function (){
			if (this._enabled || (1)) { console.log.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.warn = function (){
			if (this._enabled || (1)) { console.log.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.group = function (name){
			if (this._enabled || (1)) { console.group.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.groupCollapsed = function (){
			if (this._enabled || (1)) { console.groupCollapsed.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.groupEnd = function (){
			if (this._enabled || (1)) { console.groupEnd() };
			return this;
		};
		return Logger;
		
		
	
	})()

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		var self = this;
		var util = __webpack_require__(34);
		
		var specialKeys = {
			8: "backspace",
			9: "tab",
			10: "return",
			13: "return",
			16: "shift",
			17: "ctrl",
			18: "alt",
			19: "pause",
			20: "capslock",
			27: "esc",
			32: "space",
			33: "pageup",
			34: "pagedown",
			35: "end",
			36: "home",
			37: "left",
			38: "up",
			39: "right",
			40: "down",
			45: "insert",
			46: "del",
			59: ";",
			61: "=",
			96: "0",
			97: "1",
			98: "2",
			99: "3",
			100: "4",
			101: "5",
			102: "6",
			103: "7",
			104: "8",
			105: "9",
			106: "*",
			107: "+",
			109: "-",
			110: ".",
			111: "/",
			112: "f1",
			113: "f2",
			114: "f3",
			115: "f4",
			116: "f5",
			117: "f6",
			118: "f7",
			119: "f8",
			120: "f9",
			121: "f10",
			122: "f11",
			123: "f12",
			144: "numlock",
			145: "scroll",
			173: "-",
			186: ";",
			187: "=",
			188: ",",
			189: "-",
			190: ".",
			191: "/",
			192: "`",
			219: "[",
			220: "\\",
			221: "]",
			222: "'"
		};
		
		var shiftNums = {
			"`": "~",
			"1": "!",
			"2": "@",
			"3": "#",
			"4": "$",
			"5": "%",
			"6": "^",
			"7": "&",
			"8": "*",
			"9": "(",
			"0": ")",
			"-": "_",
			"=": "+",
			";": ": ",
			"'": '"',
			",": "<",
			".": ">",
			"/": "?",
			"\\": "|"
		};
		
		function trigger(key,o){
			if (o instanceof Function) {
				o = {command: o};
			};
			o.trigger = key;
			return o;
		};
		
		function combo(keys,o){
			if (o instanceof Function) { o = {command: o} };
			o.keys = keys;
			return o;
		};
		
		IM.KeyBindings = [
			
			combo(['super+z'],function(sel) { return sel.view().history().undo(); }),
			combo(["super+shift+z"],function(sel) { return sel.view().history().redo(); }),
			combo(["alt+super+p"],function(sel) { return sel.view().history().play(); }),
			// combo ["alt+shift+r"] do |sel| sel.view.history.play
			
			combo(["super+s"],{command: "save"}),
			combo(["super+b"],{command: "run"}),
			combo(["alt+super+s"],{command: "saveSession"}),
			combo(["alt+shift+l"],{command: "reparse"}),
			combo(["alt+shift+k"],{command: "reparseExtent"}),
			
			combo(["super+a"],function(sel) { return sel.selectAll(); }),
			
			
			combo(['tab'],{context: function(sel) { return sel.text().indexOf('\n') >= 0; },
			command: function(sel) {
				sel.expandToLines();
				var region = sel.region();
				var nodes = sel.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline')) {
						console.log('found tab in selection',match);
						if (match.mode != 'start') {
							return match.node.indent();
						};
					};
				});
				return sel.dirty();
			}}),
			
			
			
			combo(["shift+tab"],{context: function(sel) { return sel.text().indexOf('\n') >= 0; },
			command: function(sel) {
				sel.expandToLines();
				var region = sel.region();
				var nodes = sel.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						return match.node.undent();
					};
				});
				return sel.dirty();
			}}),
			
			combo(["shift+tab"],{context: function(e) {
				return true; // String(e.view.selection).indexOf('\n') >= 0
			},
			command: function(sel) {
				console.log('try undent');
				return true;
			}}),
			
			combo(["alt+shift+return"],function(sel) { return console.log('prettify'); }),
			
			combo(["backspace"],{context: function(e) {
				console.log('deleteLeftRight backspace?!?',e.region(),e.region().peek(-1,1));
				return idx$(e.region().peek(-1,1),['[]','{}','<>','()','""',"''"]) >= 0;
			},
			
			command: function(sel) {
				console.log('moving!!');
				sel.expand(-1,1);
				return sel.erase();
			}}),
			
			combo(["backspace"],{context: function(sel,o) {
				var reg = sel.region();
				if (reg.size() == 0) {
					if (o.node = reg.prevNode('._impair,._imstr')) {
						return true;
					};
				};
			},
			
			command: function(sel,o) { var v_;
			return (sel.setRegion(v_ = o.node.region().clone().reverse()),v_); }}),
			
			combo(["backspace"],{context: function(sel,o) {
				if (sel.text() && !util.stringIsBalanced(sel.text())) {
					return true;
				};
			},
			command: function(sel,o) { return true; }}),
			
			combo(["backspace"],function(sel) { return sel.erase(); }),
			combo(["shift+backspace"],function(sel) { return sel.erase(); }),
			combo(["alt+backspace"],function(sel) { return sel.erase(IM.WORD_START); }),
			combo(["super+backspace"],function(sel) { return sel.erase(IM.LINE_START); }),
			
			combo(["return",'shift+return','super+return'],function(sel) {
				var ind = sel.indent();
				if (util.increaseIndent(sel.head().peekbehind())) { ind += '\t' };
				
				// should not happen in string
				if (idx$(sel.region().peek(-1,1),['[]','{}','()']) >= 0) {
					sel.insert('\n\t' + ind);
					sel.view().insert(sel.head().loc(),'\n' + ind);
				} else {
					sel.insert('\n' + ind);
				};
				
				return true;
			}),
			
			
			combo(['space','shift+space'],function(sel) {
				if (sel.region().peek(-1,1) == '<>') {
					sel.move(1).erase();
				};
				
				return sel.insert(' ');
			}),
			
			combo(['tab'],function(sel) { return sel.insert('\t'); }),
			
			
			combo(['super+up'],function(sel) {
				sel.collapse().head().set(0,0).normalize();
				return sel.dirty();
			}),
			
			combo(['super+down'],function(sel) {
				sel.collapse().head().set(100000,0).normalize();
				return sel.dirty();
			}),
			
			combo(['super+u'],function(sel,o) {
				console.log(sel.target(),"found ut!!!");
				return console.log(sel.target().bubble('unwrap',{}));
			}),
			
			combo(['alt+super+r'],function() { return window.location.reload(); })
		];
		
		IM.Triggers = [
			
			trigger('|',{context: function(sel) { return sel.region().peek(-1,1) == '||'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger('[',function(sel) { return sel.insert('[$0]'); }),
			trigger('|',function(sel) { return sel.insert('|$0|'); }),
			trigger('(',function(sel) { return sel.insert('($0)'); }),
			trigger('{',function(sel) { return sel.insert('{$0}'); }),
			
			trigger('<',{context: function(sel) { return !sel.peekbehind(/(\b(tag|if|class) |\d\s*$)/); },
			command: function(sel) { return sel.insert('<$0>'); }}),
			
			trigger('"',{context: function(sel,o) {
				if (sel.region().peek(-1,0) == '\\' && (o.node = sel.region().scope(q$('._imstr',self)))) {
					return true;
				};
			},
			command: function(sel) { return sel.insert('"'); }}),
			
			trigger("'",{context: function(sel,o) { return sel.region().peek(-1,1) == "''"; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger("'",{context: function(sel,o) { return o.node = sel.region().scope(q$('._imstr',self)); },
			command: function(sel) { return sel.insert("\\'"); }}),
			
			trigger('"',function(sel) { return sel.insert('"$0"'); }),
			trigger("'",function(sel) { return sel.insert("'$0'"); }),
			
			trigger(']',{context: function(sel) { return sel.region().peek(0,1) == ']'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger('}',{context: function(sel) { return sel.region().peek(0,1) == '}'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger(')',{context: function(sel) { return sel.region().peek(0,1) == ')'; },
			command: function(sel) { return sel.move(1); }})
		];
		
		function ShortcutManager(view,bindings){
			this._view = view;
			this._bindings = bindings || IM.KeyBindings;
			this;
		};
		
		global.ShortcutManager = ShortcutManager; // global class 
		ShortcutManager.prototype.view = function (){
			return this._view;
		};
		
		ShortcutManager.prototype.keysForEvent = function (e){
			var combo = [];
			var special = specialKeys[e.which];
			var chr = special || String.fromCharCode(e.which);
			
			chr = chr.toLowerCase(); // unless e:shiftKey
			
			if (e.ctrlKey && special != 'ctrl') { combo.push('ctrl') };
			if (e.altKey && special != 'alt') { combo.push('alt') };
			if (e.metaKey && !e.ctrlKey && special !== 'meta') { combo.push('super') };
			if (e.shiftKey && special != 'shift') { combo.push('shift') };
			if (combo.indexOf(chr) < 0) { combo.push(chr) };
			
			return combo.join('+');
		};
		
		ShortcutManager.prototype.commandsForKeys = function (combo){
			return this._bindings.filter(function(binding) { return binding.keys == combo; });
		};
		
		ShortcutManager.prototype.getShortcut = function (e){
			var combo = this.keysForEvent(e.event());
			console.log(combo);
			
			for (var i = 0, ary = iter$(this._bindings), len = ary.length, cmd; i < len; i++) {
				cmd = ary[i];
				if (cmd.keys.indexOf(combo) >= 0) {
					var o = {};
					// console.log 'found shortcut',combo,cmd:keys
					if (!cmd.context || cmd.context.call(this.view(),this.view().caret(),o,e,this.view())) {
						cmd.data = o;
						return cmd;
					};
				};
			};
			
			return null;
		};
		
		ShortcutManager.prototype.getTrigger = function (view,text){
			for (var i = 0, ary = iter$(IM.Triggers), len = ary.length, cmd; i < len; i++) {
				cmd = ary[i];
				if (cmd.trigger == text) {
					var res = cmd.context ? (cmd.context.call(view,view.caret(),view,text)) : (true);
					if (res) { return cmd };
				};
			};
			return null;
		};
		return ShortcutManager;
		
		
		
		
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 38 */
/***/ function(module, exports) {

	(function(){
		return tag$.defineTag('imcaptor', 'input', function(tag){
			
			tag.prototype.select = function (){
				if (!this.dom().value) {
					this.dom().value = 'x';
				};
				this.dom().select();
				return this;
			};
			
			tag.prototype.build = function (){
				var self = this;
				tag.__super__.build.apply(self,arguments);
				self.dom().onfocus = function(e) {
					console.log('dom onfocus!!!!');
					var event = Imba.Event.wrap({type: 'inputfocus',target: self.dom()});
					return event.process();
				};
				
				self.dom().onblur = function(e) {
					console.log('dom onblur!!!!',e);
					var event = Imba.Event.wrap({type: 'inputblur',target: self.dom(),relatedTarget: e.relatedTarget});
					return event.process();
					// Imba.Events.trigger('inputblur',dom)
				};
				
				return self;
			};
		});
	
	})()

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// disabling logs for now
		// console:log = do true
		// externs;
		
		var OPEN = ['"',"'",'(','[','{','<'];
		var CLOSE = ['"',"'",')',']','}','>'];
		
		if (Imba.Events) {
			Imba.Events.register(['copy','paste','cut','beforecut','beforepaste','beforecopy','keypress']);
		};
		
		var Logger = __webpack_require__(36).Logger;
		var History = __webpack_require__(35).History;
		var Buffer = __webpack_require__(40).Buffer;
		var Observer = __webpack_require__(41).Observer;
		
		var Region = __webpack_require__(27).Region;
		var hints$ = __webpack_require__(42), Hints = hints$.Hints, Hint = hints$.Hint;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		var util = __webpack_require__(34);
		
		__webpack_require__(43);
		
		__webpack_require__(44);
		
		tag$.defineTag('imdims', function(tag){
			
			tag.prototype.ch = function (){
				// uncache
				if (this._ow != this.dom().offsetWidth) {
					this._ow = this.dom().offsetWidth;
					this._ch = null;
				};
				
				return this._ch || (this._ch = this.dom().getBoundingClientRect().width);
			};
		});
		
		tag$.defineTag('imviewbody');
		
		tag$.defineTag('imview', function(tag){
			
			
			
			tag.prototype.filename = function(v){ return this._filename; }
			tag.prototype.setFilename = function(v){ this._filename = v; return this; };
			
			
			
			tag.prototype.observer = function(v){ return this._observer; }
			tag.prototype.setObserver = function(v){ this._observer = v; return this; };
			
			
			tag.prototype.history = function(v){ return this._history; }
			tag.prototype.setHistory = function(v){ this._history = v; return this; };
			
			
			tag.prototype.hints = function(v){ return this._hints; }
			tag.prototype.setHints = function(v){ this._hints = v; return this; };
			
			
			tag.prototype.logger = function(v){ return this._logger; }
			tag.prototype.setLogger = function(v){ this._logger = v; return this; };
			
			
			tag.prototype.shortcuts = function(v){ return this._shortcuts; }
			tag.prototype.setShortcuts = function(v){ this._shortcuts = v; return this; };
			
			tag.prototype.__focusNode = {watch: 'focusNodeDidSet',name: 'focusNode'};
			tag.prototype.focusNode = function(v){ return this._focusNode; }
			tag.prototype.setFocusNode = function(v){
				var a = this.focusNode();
				if(v != a) { this._focusNode = v; }
				if(v != a) { this.focusNodeDidSet && this.focusNodeDidSet(v,a,this.__focusNode) }
				return this;
			};
			
			
			tag.prototype.caret = function(v){ return this._caret; }
			tag.prototype.setCaret = function(v){ this._caret = v; return this; };
			
			
			tag.prototype.frames = function(v){ return this._frames; }
			tag.prototype.setFrames = function(v){ this._frames = v; return this; };
			
			
			tag.prototype.readonly = function(v){ return this._readonly; }
			tag.prototype.setReadonly = function(v){ this._readonly = v; return this; };
			
			tag.prototype.highlighter = function (){
				return Highlighter;
			};
			
			tag.prototype.lineHeight = function (){
				return this._dims.dom().offsetHeight;
			};
			
			tag.prototype.charWidth = function (){
				return this._dims.ch();
			};
			
			tag.prototype.isReadOnly = function (){
				return this.history().mode() == 'play';
			};
			
			tag.prototype.tabSize = function (){
				return 4;
			};
			
			tag.prototype.build = function (){
				// console.log 'build imview'
				VIEW = this;
				this.setTabindex(0);
				
				this._readonly = false;
				this._logger = new Logger(this);
				this._frames = 0;
				this._changes = 0;
				
				this._hints = new Hints(this);
				this._buffer = new Buffer(this);
				this._history = new History(this);
				this._shortcuts = new ShortcutManager(this);
				this.render();
				this._observer = new Observer(this);
				this.caret().setRegion(new Region(0,0,this.root(),this));
				
				// bind to mousemove of dom?
				
				this.dom().addEventListener('mouseover',function(e) { return Imba.Events.delegate(e); });
				this.dom().addEventListener('mouseout',function(e) { return Imba.Events.delegate(e); });
				return this;
			};
			
			tag.prototype.onmouseover = function (e){
				return e.halt();
			};
			
			tag.prototype.onmouseout = function (e){
				return e.halt();
			};
			
			tag.prototype.setInput = function (input){
				
				if (input != this._input) {
					this._input = input;
					// console.log 'set input!!!',@input
					this._input.dom()._responder = this.dom();
				};
				return this;
			};
			
			tag.prototype.input = function (){
				return this._input || this._caret.input();
			};
			
			// called every frame - looking for changed nodes to deal with
			// to deal with mutations.
			tag.prototype.tick = function (){
				this._frames++;
				this.history().tick();
				this.render();
				if (this._dirty) this.repair();
				return this;
			};
			
			tag.prototype.commit = function (){
				return this.tick();
			};
			
			tag.prototype.log = function (){
				var logger_;
				(logger_ = this.logger()).log.apply(logger_,arguments);
				return this;
			};
			
			tag.prototype.edited = function (){
				var self = this;
				self._changes++;
				self._dirty = true;
				self._buffer.refresh();
				
				self.view().hints().rem(function(hint) {
					return hint.group() == 'runtime';
				});
				
				self.hints().cleanup();
				
				self.delay('didchange',50,function() {
					return Imba.Events.trigger('edited:async',self,{data: self});
				});
				
				// we can improve how/when we choose to annotate.
				// currently we do it after every edit - but it should
				// really only be needed when we have changed identifiers.
				// should also only reannotate the closest known scope,
				// but this comes later with refactoring from whole files
				// to scopes.
				self.delay('annotate',500,function() { return self.annotate(); });
				self.delay('recompile',-1); // cancel recompilation
				return self;
			};
			
			tag.prototype.dirty = function (){
				return this;
			};
			
			tag.prototype.activate = function (){
				this.flag('active');
				return this;
			};
			
			tag.prototype.deactivate = function (){
				this.unflag('active');
				return this;
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$imviewbody().setRef('body',this)).setContent([
					(this._dims = this._dims || tag$.$imdims().setRef('dims',this)).setText("x").end(),
					(this._caret = this._caret || tag$.$imcaret().setRef('caret',this)).setView(this).end(),
					(this._root = this._root || tag$.$imroot().setRef('root',this).flag('imba')).setView(this).end()
				],2).end();
			};
			
			tag.prototype.header = function (){
				return null;
			};
			
			tag.prototype.footer = function (){
				return null;
			};
			
			tag.prototype.overlays = function (){
				return (this._overlays = this._overlays || tag$.$scrimbla_overlays().setRef('overlays',this)).setView(this).end();
			};
			
			tag.prototype.render = function (){
				return this.flag('readonly',this.isReadOnly()).setChildren([
					this.header(),
					this.body(),
					this.footer()
				],1).synced();
			};
			
			tag.prototype.view = function (){
				return this;
			};
			
			tag.prototype.sel = function (){
				return this.caret();
			};
			
			tag.prototype.root = function (){
				return this._root;
			};
			
			tag.prototype.buffer = function (){
				return this._buffer;
				// root.code
			};
			
			tag.prototype.size = function (){
				return this.root().size();
			};
			
			tag.prototype.load = function (code,o){
				var parsed;
				if(o === undefined) o = {};
				this.setFilename(o.filename);
				// console.log 'loading file with filename',o:filename
				// observer.pause do
				if (o.html) {
					this.root().dom().innerHTML = o.html;
					this._buffer.refresh();
					this.history().onload(this.code());
				} else {
					// should use our new parser
					if (parsed = this.parse(code)) {
						if (parsed.highlighted) {
							this.root().dom().innerHTML = parsed.highlighted;
						} else {
							this.root().dom().textContent = code;
						};
					};
					this._buffer.refresh();
					this.history().onload(code);
					this.annotate();
				};
				return this;
			};
			
			tag.prototype.parse = function (code){
				// here we can parse the full code
				return {highlighted: IM.parse(code)};
			};
			
			tag.prototype.refocus = function (){
				if (document.activeElement != this.input().dom()) { this.input().focus() };
				return this;
			};
			
			tag.prototype.oninputfocus = function (e){
				console.log('oninputfocus!!');
				VIEW = this; // hack
				return this.flag('focus');
			};
			
			tag.prototype.oninputblur = function (e){
				return this.unflag('focus');
			};
			
			tag.prototype.onfocusin = function (e){
				VIEW = this; // hack
				this.flag('focus');
				console.log('focus',e);
				return this;
			};
			
			tag.prototype.onfocusout = function (e){
				this.unflag('focus');
				console.log('unfocus',e);
				return this;
			};
			
			tag.prototype.oninput = function (e){
				return this;
			};
			
			tag.prototype.ontextinput = function (e){
				return this;
			};
			
			tag.prototype.execAction = function (action,keydown){
				var command_;
				if (action.command instanceof Function) {
					return action.command.call(this,this.caret(),action.data || {event: keydown},this);
				} else if ((typeof (command_ = action.command)=='string'||command_ instanceof String)) {
					this.log('command is string',action.command);
					var ev = Imba.Events.trigger(action.command,this,{data: action});
					this.log(ev);
					return this;
				};
			};
			
			tag.prototype.tryCommand = function (cmd,target,params){
				if(params === undefined) params = [];
				if (cmd.context) {
					var guard = cmd.context.apply(target || this,params);
					if (!guard) { return false };
				};
				
				if (cmd.command instanceof Function) {
					return cmd.command.apply(target || this,params);
				};
			};
			
			
			
			tag.prototype.onkeydown = function (e){
				var arr;
				VIEW = this; // hack
				e.halt();
				// var combo = e.keycombo
				var combo = this.shortcuts().keysForEvent(e.event());
				var action = this.shortcuts().getShortcut(e);
				var ins = null;
				
				var shift = (/\bshift\b/).test(combo);
				var alt = (/\balt\b/).test(combo);
				var sup = (/\bsuper\b/).test(combo);
				
				// log 'imview keydown',combo
				
				if (action) {
					// console.log 'action here?!',action
					if (this.execAction(action,e)) { e.cancel() };
					return;
				};
				
				// move these into commands as well
				// thisshould move this into commands instead
				if (arr = combo.match(/\b(left|right|up|down)/)) {
					this.hints().activate();
					
					var isCollapsed = this.caret().isCollapsed();
					var ends = this.caret().ends();
					
					shift ? (this.caret().decollapse()) : (this.caret().collapse());
					
					if (arr[0] == 'down') {
						this.caret().moveDown();
						return e.cancel();
					} else if (arr[0] == 'up') {
						this.caret().moveUp();
						return e.cancel();
					};
					
					var mode = IM.CHARACTERS;
					var dir = 0;
					
					if (arr[0] == 'left') {
						dir = -1;
					};
					
					if (arr[0] == 'right') {
						dir = 1;
					};
					
					if (alt) {
						mode = dir > 0 ? (IM.WORD_END) : (IM.WORD_START);
					} else if (sup) {
						mode = dir > 0 ? (IM.LINE_END) : (IM.LINE_START);
					} else if (!shift && !isCollapsed) {
						this.caret().head().set(dir > 0 ? (ends[1]) : (ends[0]));
						this.caret().dirty(); // should not need to call this all the time
						return e.cancel();
					};
					
					this.caret().move(dir,mode);
					
					return e.cancel();
				};
				
				if (e.event().which == 229) {
					return e.halt();
				};
				
				if (combo.match(/^super\+(c|v|x)$/)) {
					// console.log 'matching combo for copy paste'
					e.halt();
					this._awaitCombo = true;
					this.refocus();
					return;
				};
				
				if (ins != null) {
					e.halt().cancel();
					this.caret().insert(ins);
					return this;
				};
				
				return this;
			};
			
			tag.prototype.onkeypress = function (e){
				if (this._awaitCombo) {
					this._awaitCombo = false;
					return e.halt();
				};
				
				e.halt();
				var text = String.fromCharCode(e.event().charCode);
				e._text = text;
				e.cancel();
				this.ontype(e);
				return this;
			};
			
			tag.prototype.ontextinput = function (e){
				e.halt().cancel();
				e._text = e.event().data;
				this.ontype(e);
				return this;
			};
			
			tag.prototype.onkeyup = function (e){
				e.halt();
				return this;
			};
			
			tag.prototype.oninput = function (e){
				e.halt();
				return this;
			};
			
			tag.prototype.ontype = function (e){
				try {
					var ins = e._text;
					// log 'ontype',e,ins
					
					var spans = this.view().nodesInRegion(this.caret().region(),false,true);
					var target = spans[0];
					var cmd;
					
					if (spans.length == 1) {
						// log 'single node for nodesInRegion',target:node
						if (cmd = target.node[("trigger-" + ins)]) {
							// log "found combo for this!??!",cmd
							if (this.tryCommand(cmd,this.caret(),[target.node,target])) {
								return this;
							};
						};
					};
					
					cmd = this.shortcuts().getTrigger(this,ins);
					
					if (cmd && (cmd.command instanceof Function)) {
						// log 'found command!!',cmd
						// should rather run tryCommand?!?
						return cmd.command(this.caret(),this,ins,e);
					} else {
						if (ins) { return this.caret().insert(ins) };
					};
				} catch (e) {
					return this.log('error from ontype');
				};
			};
			
			tag.prototype.onbackspace = function (e){
				e.cancel().halt();
				this.caret().erase();
				return;
			};
			
			tag.prototype.onbeforecopy = function (e){
				if (true) { console.log('onbeforecopy',e) };
				this.input().select();
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				return e.halt();
			};
			
			tag.prototype.oncopy = function (e){
				if (true) { console.log('oncopy',e,this.caret().text()) };
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				e.halt().cancel();
				this.refocus();
				return;
			};
			
			tag.prototype.oncut = function (e){
				if (true) {
					console.log('oncut',e);
				};
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				e.halt().cancel();
				return this.caret().erase();
			};
			
			tag.prototype.onbeforepaste = function (e){
				return console.log('onbeforepaste',e);
			};
			
			tag.prototype.onpaste = function (e){
				console.log('onpaste',e);
				var data = e.event().clipboardData;
				var text = data.getData('text/plain');
				e.halt().cancel();
				this.caret().insert(text);
				this.refocus();
				return this.repair();
				// edit text: data
			};
			
			tag.prototype.refresh = function (){
				// focusNode = sel.node # only if it is inside the scope?
				// caret.region = sel.region
				this.caret().render();
				return this;
			};
			
			tag.prototype.exec = function (o){
				var fn = o.command;
				var args = o.args || [];
				var ev = new Imba.Event({type: 'command',target: this.dom(),data: o});
				ev.setData(o);
				ev.process();
				
				return;
			};
			
			tag.prototype.ontouchstart = function (touch){
				var ary;
				this._rect = this._body.dom().getBoundingClientRect();
				
				if (touch.button() != 0) { return };
				
				if (touch._touch) {
					// is it not redirected?
					return touch.redirect({});
				};
				
				var e = touch.event();
				e.preventDefault();
				// see if shift is down? should change behaviour
				var shift = e.shiftKey;
				// log 'ontouchstart',touch,touch.x,touch.y,e,touch.button
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				
				if (shift) {
					this.caret().selectable();
				} else {
					this.caret().collapse();
				};
				
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				// console.log 'touch start refocus?'
				this.refocus();
				return this;
			};
			
			tag.prototype.xyToRowCol = function (x,y){
				var col = Math.max(Math.round(x / this.charWidth()),0);
				var row = Math.max(Math.ceil(y / this.lineHeight()),1);
				return [row - 1,col];
			};
			
			tag.prototype.rcForTouch = function (touch){
				var x = Math.max(touch.x() - this._rect.left,0);
				var y = Math.max(touch.y() - this._rect.top,0);
				return this.xyToRowCol(x,y);
			};
			
			tag.prototype.ontouchupdate = function (touch){
				var ary;
				if (touch.button() != 0) { return };
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				this.caret().selectable();
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				return this;
			};
			
			tag.prototype.ontouchend = function (touch){
				var ary;
				if (touch.button() != 0) { return };
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				return this;
			};
			
			tag.prototype.erase = function (reg,edit){
				reg = Region.normalize(reg,this);
				
				var text = reg.text();
				this.history().onerase(reg,text,edit);
				
				var spans = this.nodesInRegion(reg,false,true);
				// gropu the nodes
				this.observer().pause(function() {
					if (spans.length > 1) {
						spans[1].node.setPrev(tag$.$iminsert().flag('dirty').end());
					} else if (spans[0] && spans[0].mode == 'all') {
						console.log('removing single node?!');
						var before = spans[0].node.prev();
						
						spans[0].node.setPrev(tag$.$iminsert().flag('dirty').end());
					};
					
					for (var i = 0, ary = iter$(spans), len = ary.length, sel, res = []; i < len; i++) {
						// buffer need to updated during this?
						sel = ary[i];
						res.push(sel.node.erase(sel.region,sel.mode,edit));
					};
					return res;
				});
				
				// delay('annotate',500) do annotate
				return this.erased(reg);
			};
			
			tag.prototype.inserted = function (loc,str){
				console.log('inserted',loc,str);
				var reg = new Region(loc,loc + str.length,null,this);
				for (var i = 0, ary = iter$(this.hints()), len = ary.length; i < len; i++) {
					ary[i].adjust(reg,true);
				};
				// hints.cleanup
				this.edited();
				if (util.isWhitespace(str)) this.repair();
				return this;
			};
			
			tag.prototype.erased = function (reg){
				for (var i = 0, ary = iter$(this.hints()), len = ary.length; i < len; i++) {
					ary[i].adjust(reg,false);
				};
				this.edited();
				return this.repair(); // repair synchronously
			};
			
			tag.prototype.insert = function (point,str,edit){
				if (point instanceof Region) {
					if (point.size() > 0) {
						this.logger().warn('uncollapsed region in insert is not allowed');
					};
					point = point.start();
				};
				
				this.log('insert',point,str);
				// should maybe create this as a command - and then make it happen?
				
				this.history().oninsert(point,str,edit);
				
				// log 'insert in view'
				var spans = this.nodesInRegion(Region.normalize(point,this),false);
				var mid = spans[0];
				var target = mid || spans.prev || spans.next;
				var lft = spans.lft,rgt = spans.rgt;
				var node;
				var reg;
				
				// log spans,mid,lft,rgt
				this.log('before and after',lft,rgt,str);
				
				if (mid) {
					this.log('insert mid',mid.node);
					mid.node.insert(mid.region,str,edit,mid);
				} else {
					
					while (rgt){
						if (rgt.canPrepend(str)) {
							this.log('prepend',rgt,str);
							rgt.insert('prepend',str,edit);
							return this.inserted(point,str);
						} else if (rgt.isFirst()) {
							rgt = rgt.parent();
							continue;
						};
						
						break;
					};
					
					// find the closest parent
					while (lft){
						if (lft.canAppend(str)) {
							this.log('append',lft,str);
							lft.insert('append',str,edit);
							return this.inserted(point,str);
						} else if (lft.isLast()) {
							lft = lft.parent();
							continue;
						};
						
						break;
					};
					
					node = tag$.$iminsert().end();
					
					if (lft) {
						lft.setNext(node);
					} else if (rgt) {
						rgt.setPrev(node);
					} else {
						// must be empty
						this.root().dom().appendChild(node.dom());
					};
					
					node.insert('append',str,edit);
				};
				
				return this.inserted(point,str);
			};
			
			tag.prototype.onmutations = function (){
				return this;
			};
			
			tag.prototype.repair = function (){
				this._dirty = false;
				var els = this.dom().getElementsByClassName('dirty');
				
				if (els.length) {
					// logger.log "{els:length} dirty nodes to repair"
					
					for (var muts = [], i = 0, ary = iter$(els), len = ary.length; i < len; i++) {
						muts.push(tag$wrap(ary[i]));
					};
					
					for (var i = 0, ary = iter$(muts), len = ary.length, mut; i < len; i++) {
						mut = ary[i];
						mut.unflag('dirty');
						mut.mutated(muts);
					};
				};
				return this;
			};
			
			tag.prototype.code = function (){
				return this._root.dom().textContent;
			};
			
			tag.prototype.focusNodeDidSet = function (new$,old){
				if (!this.root().contains(new$)) { return };
				
				var path = [];
				
				while (new$ && new$ != this.root()){
					path.push(new$);
					new$ = new$.parent();
				};
				
				q$('.focus_',this).map(function(n) {
					if (path.indexOf(n) < 0) { return n.unflag('focus_') };
				});
				
				for (var i = 0, len = path.length; i < len; i++) {
					path[i].flag('focus_');
				};
				return this;
			};
			
			
			tag.prototype.recompile = function (){
				// should happen in a separate thread - and be delayed
				console.log('recompile');
				var res;
				
				try {
					res = Imbac.compile(this.code(),{bare: true});
				} catch (e) { };
				
				if (res) {
					this.compiled(res);
				};
				return this;
			};
			
			tag.prototype.reparse = function (){
				this.log('reparse');
				this.root().rehighlight({inner: true});
				return this;
			};
			
			tag.prototype.compiled = function (res){
				return this;
			};
			
			tag.prototype.onrunerror = function (e){
				console.log('onrunerror',e);
				return this;
			};
			
			tag.prototype.addError = function (msg,loc){
				var node;
				var reg = Region.normalize(loc,this);
				console.log('found warnings',reg,msg,loc);
				if (node = this.nodeAtRegion(reg)) {
					this.log('node at region is?!',node);
					msg = msg.split(/error at (\[[\d\:]*\])\:\s*/).pop();
					node.flag('err');
					node.setAttribute('error',msg);
				};
				this.delay('annotate',-1);
				return this;
			};
			
			
			
			tag.prototype.annotate = function (){
				// console.log 'annotate'
				
				var self = this;
				var state = self.root().codeState();
				var code = state.code;
				
				var apply = function(meta) {
					var vars = [];
					for (var i = 0, ary = iter$(meta.scopes), len = ary.length; i < len; i++) {
						for (var j = 0, items = iter$(ary[i].vars), len_ = items.length; j < len_; j++) {
							vars.push(items[j]);
						};
					};
					
					var warnings = meta.warnings || [];
					var oldWarnings = self.hints().filter(function(hint) { return hint.group() == 'analysis'; });
					
					if (oldWarnings) {
						// could intelligently keep them instead
						self.hints().rem(oldWarnings);
					};
					
					for (var i = 0, ary = iter$(warnings), len = ary.length, warn; i < len; i++) {
						warn = ary[i];
						warn.type || (warn.type = 'error');
						warn.group = 'analysis';
						self.hints().add(warn).activate();
					};
					
					if (warnings.length) { return self };
					
					var nodes = IM.textNodes(self.root().dom(),true);
					// what about removing old warnings?
					
					var map = {};
					for (var i = 0, ary = iter$(nodes), len = ary.length, node; i < len; i++) {
						node = ary[i];
						map[node._loc] = node;
					};
					
					// get textNodes with mapping(!)
					for (var i1 = 0, len = vars.length; i1 < len; i1++) {
						for (var k = 0, ary = iter$(vars[i1].refs), len_ = ary.length, ref; k < len_; k++) {
							ref = ary[k];
							var a = ref.loc[0];
							var b = ref.loc[1];
							var eref = ("v" + i1);
							
							if (map[a]) {
								var dom = map[a].parentNode;
								var oldRef = dom.getAttribute('eref');
								// console.log 'setting the ref for node?',dom,dom.@tag
								tag$wrap(dom).setEref(eref);
								// if dom.@tag
								// 	dom.@tag.eref = eref
								// else
								// 	dom.setAttribute('eref',eref) unless oldRef == eref
								// 	dom:classList.add('lvar')
							};
						};
					};
					
					return;
				};
				
				try {
					
					console.time('analyze');
					IM.worker().analyze(code,{bare: true},function(res) {
						console.log('result from worker analyze');
						console.timeEnd('analyze');
						
						if (res.data) {
							console.time('annotate');
							apply(res.data);
							return console.timeEnd('annotate');
						};
					});
				} catch (e) {
					self.log('error from annotate',e);
				};
				
				return self;
			};
			
			tag.prototype.oncommand = function (e,c){
				if (this[c.command] instanceof Function) {
					this[c.command].call(this,c.args || []);
					e.halt();
				};
				return this;
			};
			
			tag.prototype.dumpState = function (o){
				if(o === undefined) o = {};
				return {
					html: this.root().dom().innerHTML,
					code: this.root().code(),
					selection: this.caret().region(),
					timestamp: new Date()
				};
			};
			
			tag.prototype.loadState = function (o){
				var self = this;
				if(o === undefined) o = {};
				self.observer().pause(function() {
					var v_;
					if (o.html) {
						self.root().dom().innerHTML = o.html;
					} else if (o.code) {
						self.load(o.code);
					};
					if (o.selection) {
						return (self.caret().setRegion(v_ = o.selection),v_);
					};
				});
				return self;
			};
			
			tag.prototype.loadSession = function (session){
				this.history().load(session);
				this.history().play();
				return this;
			};
			
			tag.prototype.textNodes = function (rel){
				if(rel === undefined) rel = this.root();
				return IM.textNodes(rel);
			};
			
			// Should be separate from the viewcode?
			tag.prototype.regionForNode = function (node,rel){
				if(rel === undefined) rel = this.root();
				var el = node._dom || node;
				var len = el.textContent.length;
				var rng = document.createRange();
				rng.setStart(rel._dom || rel,0);
				rng.setEnd(node._dom || node,0);
				var pre = rng.toString();
				return new Region(pre.length,pre.length + len,rel,this);
			};
			
			// Should merge with nodesInRegion
			tag.prototype.nodeAtRegion = function (region,exact){
				if(exact === undefined) exact = false;
				console.time('nodeAtRegion');
				var rel = this.root();
				var a = region.a();
				var b = region.b();
				
				var nodes = this.textNodes(rel);
				// move into region instead?
				var pos = 0;
				var match = null;
				var adist,bdist,str,len;
				
				for (var i = 0, ary = iter$(nodes), len_ = ary.length, node; i < len_; i++) {
					// console.log 'looking through nodes'
					node = ary[i];
					adist = a - pos;
					bdist = b - pos;
					str = node.textContent;
					len = str.length;
					
					if (adist >= 0 && adist < len) {
						// console.log 'found starting point?',node,str,adist
						match = node;
						break;
						// return tag(node:parentNode)
					};
					
					if (bdist >= 0 && bdist < len) {
						// console.log 'found ending point',node,str,bdist
						// range.setEnd(node,bdist)
						break;
					};
					
					
					pos += len;
				};
				
				var el = tag$wrap(match.parentNode);
				// we want to match the one that is full length
				if (exact && len < region.size()) {
					while (el){
						// be careful
						var elreg = el.region();
						if (region.equals(elreg)) { return el };
						el = el.parent();
					};
				};
				
				console.timeEnd('nodeAtRegion');
				return match ? (tag$wrap(match.parentNode)) : (null);
			};
			
			tag.prototype.nodesForEntity = function (ref){
				return q$('[eref="'+("" + ref)+'"]',this);
			};
			
			// does not need to belong to view directly
			tag.prototype.nodesInRegion = function (region,includeEnds,generalize){
				if(includeEnds === undefined) includeEnds = true;
				if(generalize === undefined) generalize = false;
				console.time('nodesInRegion');
				region = Region.normalize(region,this).normalize();
				var a = region.start();
				var b = region.end();
				
				// can be optimized by supplying the regions
				var nodes = IM.textNodes(region.root() || this.root());
				var matches = [];
				var match;
				var el;
				// move into region instead?
				matches.includeEnds = includeEnds;
				matches.region = region;
				
				var pos = 0;
				var ends = [];
				
				for (var i1 = 0, ary = iter$(nodes), len_ = ary.length, node; i1 < len_; i1++) {
					// console.log 'looking through nodes'
					node = ary[i1];
					var adist = a - pos;
					var bdist = b - pos;
					var str = node.textContent;
					var len = str.length;
					
					if ((pos + len) >= a && pos <= b) {
						el = tag$wrap(node.parentNode);
						var start = Math.max(0,a - pos);
						var end = Math.min(len,Math.max(b - pos,0));
						var par;
						
						match = {
							node: el,
							startOffset: start,
							endOffset: end,
							region: new Region(start,end,el,this),
							size: len
						};
						// log "node at {pos} + {len} - looking in range {a} - {b}"
						var mode = 'all';
						
						if (start == len) {
							mode = 'end';
						} else if (end == 0) {
							mode = 'start';
						} else if (start == 0 && end == len) {
							par = el.dom().parentNode;
							var isOpener = par != this._root.dom() && el.dom() == par.firstChild;
							var isCloser = par != this._root.dom() && el.dom() == par.lastChild;
							
							if (isOpener) {
								match.opens = el.parent();
								ends.push(match);
							};
							
							if (isCloser) {
								end = ends[ends.length - 1];
								if (end && end.opens == el.parent()) {
									end.closer = match;
									match.opener = end;
									ends.pop();
								};
								
								match.closes = el.parent();
							};
							
							mode = 'all';
						} else {
							mode = 'partial';
						};
						
						match.mode = mode;
						matches.push(match);
					};
					
					pos += len;
					if (pos > b) { break; };
				};
				
				var first = matches[0];
				var last = matches[matches.length - 1];
				
				if (first && first.mode == 'end') {
					matches.prev = first;
					matches.lft = first.node;
					
					// if first:node isa IM.Types:close
					// 	matches:lft = first:node.parent
					
					if (!includeEnds) { matches.shift() };
				};
				
				if (last && last.mode == 'start') {
					matches.next = last;
					matches.rgt = last.node;
					
					// if last:node isa IM.Types:open
					// 	matches:rgt = last:node.parent
					
					if (!includeEnds) { matches.pop() };
				};
				
				
				// normalize the nodes in groups
				if (generalize) {
					// console.log 'generalize!',matches
					var i = 0;
					var m;
					while (m = matches[i]){
						if (m.closer) {
							var idx = matches.indexOf(m.closer);
							len = m.opens.size();
							var new$ = {
								mode: 'all',
								region: new Region(0,len,m.opens,this),
								startOffset: 0,
								endOffset: len,
								node: m.opens
							};
							var rem = matches.splice(i,idx - i + 1,new$);
							new$.children = rem;
							// console.log 'slice away the items'
						};
						i++;
					};
				};
				
				console.timeEnd('nodesInRegion');
				return matches;
			};
			
			// should move to Buffer class
			tag.prototype.linecount = function (){
				return this.buffer().linecount();
				// buffer.split('\n')[:length]
			};
			
			// Returns the contents of the region as a string.
			// Returns the character to the right of the point.
			tag.prototype.substr = function (region,len){
				return this.buffer().substr(region,len);
			};
			
			// move into Buffer
			tag.prototype.linestr = function (nr){
				return this.buffer().line(nr);
				// if nr isa Number
				// 	buffer.split('\n')[nr] or ''
			};
			
			tag.prototype.expandRegionTo = function (region,match,forward){
				if(forward === undefined) forward = true;
				var buf = this.buffer().toString();
				var pos = region.start();
				var end = region.end();
				
				if (forward) {
					while (buf[end + 1] != match){
						end++;
					};
				} else {
					while (buf[pos - 1] != match){
						pos--;
					};
				};
				
				return new Region(pos,end,this);
			};
		});
		
		
		return VIEW = null;
	
	})()

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var Region = __webpack_require__(27).Region;
		
		function Buffer(view){
			this._view = view;
			this._buffer = '';
			this._cache = {};
			this;
		};
		
		exports.Buffer = Buffer; // export class 
		
		
		Buffer.prototype.view = function(v){ return this._view; }
		Buffer.prototype.setView = function(v){ this._view = v; return this; };
		
		Buffer.prototype.set = function (buffer){
			if (buffer == this._buffer) {
				return this;
			};
			
			this._buffer = buffer;
			this._cache = {};
			this._lines = null;
			return this;
		};
		
		Buffer.prototype.refresh = function (){
			return this.set(this.view().root().code());
		};
		
		Buffer.prototype.lines = function (){
			return this._lines || (this._lines = (true) && (
				this._buffer.split('\n')
			));
		};
		
		Buffer.prototype.split = function (){
			return this._buffer.split.apply(this._buffer,arguments);
		};
		
		Buffer.prototype.linecount = function (){
			return this.lines().length;
		};
		
		Buffer.prototype.line = function (nr){
			if ((typeof nr=='number'||nr instanceof Number)) {
				return this.lines()[nr] || '';
			} else {
				return '';
			};
		};
		
		Buffer.prototype.len = function (){
			return this._buffer.length;
		};
		
		// location to 
		Buffer.prototype.locToRc = function (){
			return this;
		};
		
		Buffer.prototype.location = function (){
			return this;
		};
		
		Buffer.prototype.locToRow = function (loc){
			var ln = 0;
			var len = 0;
			for (var i = 0, ary = iter$(this.lines()), len_ = ary.length; i < len_; i++) {
				len += ary[i].length + 1;
				if (loc < len) { return i };
			};
			return this.lines().length;
		};
		
		Buffer.prototype.locToCell = function (loc){
			if (this._cache[loc]) {
				return this._cache[loc];
			};
			
			var pos = loc;
			var col = 0;
			var row = 0;
			var char$;
			
			var buf = this._buffer;
			var tabsize = this._view.tabSize();
			
			// go back to start of line
			// goes through the whole
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					break;
				};
				pos--;
			};
			
			// get column for slice
			while ((pos < loc) && (char$ = buf[pos])){
				if (char$ == '\t') {
					var rest = tabsize - (col % tabsize);
					col += rest;
				} else {
					col += 1;
				};
				pos++;
			};
			
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					row++;
				};
				pos--;
			};
			
			return this._cache[loc] = [row,col];
		};
		
		Buffer.prototype.substr = function (region,len){
			if (region instanceof Region) {
				return this._buffer.substr(region.start(),region.size());
			} else if ((typeof region=='number'||region instanceof Number)) {
				return this._buffer.substr(region,len || 1);
			} else {
				throw 'must be region or number';
			};
		};
		
		Buffer.prototype.toString = function (){
			return this._buffer || '';
		};
		return Buffer;
	
	})()

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var util = __webpack_require__(34);
		
		function Observer(view,cfg){
			var self = this;
			self._active = false;
			self._view = view;
			self._config = cfg || {attributes: false,childList: true,characterData: true,subtree: true};
			self._observer = new MutationObserver(function(muts) { return self.onmutations(muts); });
			self;
		};
		
		exports.Observer = Observer; // export class 
		
		
		Observer.prototype.view = function(v){ return this._view; }
		Observer.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Observer.prototype.config = function(v){ return this._config; }
		Observer.prototype.setConfig = function(v){ this._config = v; return this; };
		
		
		Observer.prototype.active = function(v){ return this._active; }
		Observer.prototype.setActive = function(v){ this._active = v; return this; };
		
		Observer.prototype.resume = function (){
			if (!this._active) {
				this._observer.observe(this.view().root().dom(),this.config());
				this._active = true;
			};
			return this;
		};
		
		Observer.prototype.pause = function (blk){
			var wasActive = this._active;
			this._active = false;
			if (wasActive) { this._observer.disconnect() };
			
			if (blk instanceof Function) {
				blk();
				if (wasActive) this.resume();
			};
			
			return this;
		};
		
		Observer.prototype.paused = function (){
			return !this._active;
		};
		
		Observer.prototype.onmutations = function (mutations){
			var el;
			this.view().logger().group('mutations');
			
			var deep = false;
			var nodes = [];
			for (var i = 0, ary = iter$(mutations), len = ary.length, mut; i < len; i++) {
				mut = ary[i];
				this.view().log('mutation',mut);
				var type = mut.type;
				var target = mut.previousSibling || mut.target;
				
				if (type == 'characterData') {
					this.view().log(("updated code to " + (target.textContent)));
					target = target.parentNode;
				} else if (type == 'childList') {
					deep = true;
					var add = mut.addedNodes;
					if (add.length == 1 && (add[0] instanceof Element)) {
						target = add[0];
					};
				};
				
				this.view().log(target,tag$wrap(target));
				// var added = mut:addedNodes
				// for node in mut:addedNodes
				// if target and target:parentNode # and target.@tag
				if (el = tag$wrap(target)) {
					this.view().log('add target?!');
					if (nodes.indexOf(el) < 0) { nodes.push(el) };
				};
				
				// if we have added a node instead
			};
			
			// mutations are not registered on node-level but on extent
			// not really how this should happen
			
			var common = util.commonAncestor(nodes);
			
			this.view().log('common container for mutations is',common,nodes);
			
			var extent;
			
			if (nodes.length == 1) {
				this.view().log('a single node was mutated',nodes[0]);
				nodes[0].mutated({deep: deep,mutations: mutations});
			} else {
				// collect extents for all nodes?
				// rather make a region expand 
				for (var i = 0, len = nodes.length, node; i < len; i++) {
					node = nodes[i];
					if (extent && extent.contains(node.dom())) { // :nodes.indexOf(node.dom) >= 0
						this.view().log('this node is already part of the extent',node.dom());
					} else {
						extent = node.dirtyExtent();
					};
					// node?.mutated
				};
				
				if (extent) {
					// console.log 'found extent(!)',extent
					this.pause(function() { return true; });
				};
			};
			
			this.view().logger().groupEnd();
			this.view().onmutations({nodes: nodes,mutations: mutations,extent: extent});
			return this;
		};
		return Observer;
		
	
	})()

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Region = __webpack_require__(27).Region;
		
		var labels = {
			"Unexpected 'TAG_END'": 'Tag closed unexpectedly',
			"Unexpected 'TERMINATOR'": 'Unexpected ',
			"Unexpected 'POST_IF'": 'Missing body in <b>IF</b>'
		};
		
		var rules = [
			[/Uncaught Error: tag (\w+) is not defined/,"tag <b>$1</b> does not exist"]
		];
		
		function Hint(opts,view){
			this._view = view;
			this._data = opts;
			this._active = false;
			this._region = opts.loc ? (Region.normalize(opts.loc,view)) : (null);
			// try to find the node immediately
			this._node = opts.node || this.node();
			this;
		};
		
		exports.Hint = Hint; // export class 
		Hint.build = function (o,view){
			return new this(o,view);
		};
		
		
		
		Hint.prototype.view = function(v){ return this._view; }
		Hint.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Hint.prototype.region = function(v){ return this._region; }
		Hint.prototype.setRegion = function(v){ this._region = v; return this; };
		
		
		Hint.prototype.active = function(v){ return this._active; }
		Hint.prototype.setActive = function(v){ this._active = v; return this; };
		
		Hint.prototype.getAttribute = function (key){
			return this._data[key];
		};
		
		Hint.prototype.setAttribute = function (key,val){
			this._data[key] = val;
			return this;
		};
		
		Hint.prototype.type = function (){
			return this._data.type || 'error';
		};
		
		Hint.prototype.group = function (){
			return this._data.group;
		};
		
		Hint.prototype.ref = function (){
			return this._data.ref;
		};
		
		Hint.prototype.node = function (){
			return this._node || (this._node = this._region && this.view().nodeAtRegion(this._region));
		};
		
		Hint.prototype.row = function (){
			return this.region().row();
		};
		
		Hint.prototype.col = function (){
			return this.region().col();
		};
		
		Hint.prototype.label = function (){
			var lbl;
			return this._label || (this._label = (true) && (
				lbl = this._data.label || this._data.message || 'Hint',
				lbl = lbl.split(/error at (\[[\d\:]*\])\:\s*/).pop(),
				lbl = labels[lbl] || lbl
			));
		};
		
		
		Hint.prototype.activate = function (){
			var node_;
			if (!this._active) {
				// node?.setAttribute('hint',ref)
				this._active = true;
				(node_ = this.node()) && node_.setHint  &&  node_.setHint(this);
			};
			return this;
		};
		
		Hint.prototype.deactivate = function (){
			console.log('deactivate hint!!');
			this.setActive(false);
			return this;
			// cleanup
			// remove
		};
		
		Hint.prototype.prune = function (){
			return this.view().hints().prune(this);
		};
		
		// should make this hint ready to be removed
		Hint.prototype.cleanup = function (){
			if (this._node) {
				if (this._node.hint() == this) { this._node.setHint(null) };
			};
			return this;
		};
		
		Hint.prototype.remove = function (){
			this.view().hints().rem(this);
			return this;
		};
		
		Hint.prototype.changed = function (){
			// console.log 'deactivate on changed!'
			// @deactivate = yes
			this.prune();
			return this;
		};
		
		Hint.prototype.adjust = function (reg,ins){
			if(ins === undefined) ins = true;
			if (this.region().intersects(reg)) {
				// deactivate
				this.prune();
				// @deactivate = yes
			};
			
			this.region().adjust(reg,ins);
			return this;
		};
		
		function Hints(view){
			this._prune = [];
			this._array = [];
			this._map = {};
			this._view = view;
		};
		
		exports.Hints = Hints; // export class 
		var nr = 0;
		
		Hints.prototype.toArray = function (){
			return this._array;
		};
		
		Hints.prototype.get = function (ref){
			return this._map[ref];
		};
		
		Hints.prototype.activate = function (){
			for (var i = 0, ary = iter$(this._array), len = ary.length; i < len; i++) {
				ary[i].activate();
			};
			return this;
		};
		
		// this should take care of deallocating the hint no?
		Hints.prototype.rem = function (hint){
			if (hint instanceof Function) {
				hint = this._array.filter(hint);
			};
			
			if (hint instanceof Array) {
				for (var i = 0, ary = iter$(hint), len = ary.length; i < len; i++) {
					this.rem(ary[i]);
				};
				return hint;
			};
			
			if ((typeof hint=='string'||hint instanceof String)) {
				return this.rem(this.get(hint));
			};
			
			if (this._array.indexOf(hint) >= 0) {
				hint.cleanup();
				this._array.splice(this._array.indexOf(hint),1);
			};
			
			return hint;
		};
		
		Hints.prototype.prune = function (hint){
			if (this._prune.indexOf(hint) < 0) { this._prune.push(hint) };
			return this;
		};
		
		Hints.prototype.clear = function (){
			var arr = this._array;
			this._array = [];
			
			for (var i = 0, ary = iter$(arr), len = ary.length; i < len; i++) {
				ary[i].deactivate();
			};
			return this;
		};
		
		Hints.prototype.cleanup = function (){
			
			var self = this;
			self._array.map(function(item) {
				if (self._prune.indexOf(item) >= 0) {
					item.deactivate();
					return self.rem(item);
				};
			});
			self._prune = [];
			return self;
		};
		
		
		Hints.prototype.filter = function (cb){
			return this._array.filter(cb);
		};
		
		Hints.prototype.add = function (o){
			var ref = o.ref = ("hint" + (nr++));
			if (!((o instanceof Hint))) { o = Hint.build(o,this._view) };
			this._map[ref] = o;
			this._array.push(o);
			return o;
		};
		return Hints;
	
	})()

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var util = __webpack_require__(34);
		var Region = __webpack_require__(27).Region;
		
		function RowCol(row,col,caret){
			if(row === undefined) row = 0;
			if(col === undefined) col = 0;
			if(caret === undefined) caret = null;
			this._row = row;
			this._col = col;
			this._caret = caret;
			this;
		};
		
		
		
		RowCol.prototype.row = function(v){ return this._row; }
		RowCol.prototype.setRow = function(v){ this._row = v; return this; };
		
		
		RowCol.prototype.col = function(v){ return this._col; }
		RowCol.prototype.setCol = function(v){ this._col = v; return this; };
		
		
		RowCol.prototype.caret = function(v){ return this._caret; }
		RowCol.prototype.setCaret = function(v){ this._caret = v; return this; };
		
		RowCol.prototype.view = function (){
			return this.caret().view();
		};
		
		RowCol.prototype.normalize = function (){
			this._col = this.realCol();
			return this;
		};
		
		RowCol.prototype.set = function (row,col){
			var ary;
			if (row instanceof RowCol) {
				col = row.col();
				row = row.row();
				
				// return set(row.row,row.col)
			};
			
			if (row instanceof Region) {
				var ary = iter$(util.rowcol(this.view()._buffer,row.start()));row = ary[0];col = ary[1];
			};
			
			var lc = this.view()._buffer.linecount();
			
			if (row >= lc) {
				row = lc - 1;
				col = 1000;
			};
			
			this._row = row;
			this._col = col;
			return this;
		};
		
		
		RowCol.prototype.move = function (offset){
			this.normalize();
			
			var col = this.realCol() + offset;
			var llen = this.linelen();
			
			var lloc = this.lineloc();
			// find the real offset in characters (not columns)
			
			
			// if offset < 0
			// 	# normalize?
			// 	@col = Math.min(@col,llen)
			
			if (col < 0) {
				if (this._row > 0) {
					this.moveUp();
					this._col = this.linelen();
				} else {
					this._row = 0;
					this._col = 0;
				};
				return this;
			} else if (col > llen) {
				if (this._row >= (this.view()._buffer.linecount() - 1)) {
					return this;
				};
				
				this.moveDown();
				var rest = Math.max(0,col - llen - 1);
				var moves = util.colsForLine(this.linestr().substr(0,rest));
				this._col = moves;
				return this;
			};
			
			// this should work
			this._col = util.colsForLine(this.linestr().substr(0,lloc + offset));
			// @col += offset
			return this;
		};
		
		RowCol.prototype.moveUp = function (len){
			this._row = Math.max(0,this._row - 1);
			return this;
		};
		
		RowCol.prototype.moveDown = function (len){
			console.log('moveDown');
			var lc = this.view()._buffer.linecount(); // split('\n')[:length]
			this._row = this._row + 1;
			if (this._row >= lc) {
				console.log('out of bounds');
				this.setLoc(this.view()._buffer.len());
			};
			return this;
		};
		
		RowCol.prototype.clone = function (){
			return new RowCol(this.row(),this.col(),this.caret());
		};
		
		RowCol.prototype.linelen = function (){
			return util.colsForLine(this.linestr());
		};
		
		RowCol.prototype.lineloc = function (){
			return util.colToLoc(this.linestr(),this.realCol());
		};
		
		RowCol.prototype.realCol = function (){
			var rc = util.colToViewCol(this.linestr(),this._col);
			return rc;
		};
		
		RowCol.prototype.linestr = function (){
			return this.view().linestr(this.row());
		};
		
		RowCol.prototype.peekbehind = function (){
			var str = this.linestr();
			return str.substr(0,util.colToLoc(str,this.realCol()));
		};
		
		RowCol.prototype.peekahead = function (){
			var str = this.linestr();
			return str.slice(util.colToLoc(str,this.realCol()));
		};
		
		RowCol.prototype.setLoc = function (loc){
			var ary;
			var ary = iter$(util.rowcol(this.view()._buffer,loc));var row = ary[0],col = ary[1];
			this.set(row,col);
			return this;
		};
		
		RowCol.prototype.loc = function (){
			// should cache(!)
			var lines = this.view()._buffer.lines();
			// var lines = view.buffer.split('\n')
			var loc = 0;
			for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
				line = ary[i];
				var ln = line.length;
				if (i < this._row) {
					loc += ln + 1; // include newline
				} else if (i == this._row) {
					var viewcol = util.colToViewCol(line,this._col);
					var offset = util.colToLoc(line,viewcol);
					loc += Math.min(ln,offset);
				};
			};
			return loc;
		};
		
		RowCol.prototype.tab = function (){
			// wrong - need to round instead?
			
			var lft = this.col() % 4;
			this.setCol(this.col() + (4 - lft)); // Math.floor(col / 4) * 4 + 4
			console.log('marker tab',lft,this.col(),this.realCol());
			return this;
		};
		
		RowCol.prototype.untab = function (){
			console.log('untab',this.col());
			var rest = 4 - this.col() % 4;
			this.setCol(Math.ceil(this.col() / 4) * 4 - 4);
			return this;
		};
		
		RowCol.prototype.alter = function (mode,dir){
			var $1, $2, $3, $4, $5, $6;
			var nodes = this.caret().view().nodesInRegion(this.loc(),false);
			var node = nodes[0];
			var mid = node && node.node;
			var lft = nodes.prev && nodes.prev.node;
			var rgt = nodes.next && nodes.next.node;
			var part;
			
			// log 'move',offset,mode,nodes
			if (mode == IM.WORD_START) {
				var el = mid || lft;
				if (($1 = lft) && $1.matches  &&  $1.matches(q$('._imclose',this))) {
					this.setLoc(lft.parent().region().start());
				} else if (($2 = lft) && $2.matches  &&  $2.matches(q$('._imstr',this))) {
					this.setLoc(lft.region().start());
				} else {
					var loc = this.loc();
					// let buf = view.buffer
					// console.log 'peekbehind',peekbehind,loc,str
					var str = this.peekbehind().split('').reverse().join('');
					loc -= str.match(/^([\s\t\.]*.+?|)(\b|$)/)[1].length;
					this.setLoc(loc);
				};
			} else if (mode == IM.WORD_END) {
				el = mid || rgt;
				if (($3 = rgt) && $3.matches  &&  $3.matches(q$('._imopen',this))) {
					this.setLoc(rgt.parent().region().end());
				} else if (($4 = rgt) && $4.matches  &&  $4.matches(q$('._imstr',this))) {
					this.setLoc(rgt.region().end());
				} else {
					var loc1 = this.loc();
					// let buf = view.buffer
					
					
					// console.log 'peekahead',peekahead,loc
					loc1 += this.peekahead().match(/^([\s\.]*.+?|)(\b|$)/)[1].length;
					// loc++ until buf[loc].match(/[\n\]/)
					this.setLoc(loc1);
				};
			} else if (mode == IM.LINE_END) {
				this.set(this.row(),1000);
			} else if (mode == IM.LINE_START) {
				// FIXME tabs-for-spaces
				var tabs = this.linestr().match(/^\t*/)[0].length;
				var newcol = tabs * this.view().tabSize();
				this.setCol(this.col() > newcol ? (newcol) : (0));
			} else {
				if (dir < 0 && ($5 = lft) && $5.matches  &&  $5.matches('._imtab')) {
					// head.col = head.col - 4
					// caret.view.log 'right is tab',lft.region
					this.setLoc(lft.region().start());
					// head.untab
				} else if (dir > 0 && ($6 = rgt) && $6.matches  &&  $6.matches('._imtab')) {
					
					// use tab instead
					this.tab();
					// head.col = head.col + 4
				} else {
					// ...
					this.move(dir);
				};
			};
			
			return this;
		};
		
		tag$.defineTag('imcarethead');
		
		// should move into Marker (like Atom)
		return tag$.defineTag('imcaret', function(tag){
			
			
			
			tag.prototype.region = function(v){ return this._region; }
			tag.prototype.setRegion = function(v){ this._region = v; return this; };
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			
			tag.prototype.lines = function(v){ return this._lines; }
			tag.prototype.setLines = function(v){ this._lines = v; return this; };
			
			
			tag.prototype.ranges = function(v){ return this._ranges; }
			tag.prototype.setRanges = function(v){ this._ranges = v; return this; };
			
			tag.prototype.__mode = {watch: 'modeDidSet',name: 'mode'};
			tag.prototype.mode = function(v){ return this._mode; }
			tag.prototype.setMode = function(v){
				var a = this.mode();
				if(v != a) { this._mode = v; }
				if(v != a) { this.modeDidSet && this.modeDidSet(v,a,this.__mode) }
				return this;
			};
			
			tag.prototype.__col = {'default': 0,watch: 'dirty',name: 'col'};
			tag.prototype.col = function(v){ return this._col; }
			tag.prototype.setCol = function(v){
				var a = this.col();
				if(v != a) { this._col = v; }
				if(v != a) { this.dirty && this.dirty(v,a,this.__col) }
				return this;
			}
			tag.prototype._col = 0; // the real column of the caret
			
			tag.prototype.__row = {'default': 0,watch: 'dirty',name: 'row'};
			tag.prototype.row = function(v){ return this._row; }
			tag.prototype.setRow = function(v){
				var a = this.row();
				if(v != a) { this._row = v; }
				if(v != a) { this.dirty && this.dirty(v,a,this.__row) }
				return this;
			}
			tag.prototype._row = 0;
			
			
			tag.prototype.input = function(v){ return this._input; }
			tag.prototype.setInput = function(v){ this._input = v; return this; };
			
			
			
			tag.prototype.tail = function(v){ return this._tail; }
			tag.prototype.setTail = function(v){ this._tail = v; return this; }; // rowcol
			
			
			tag.prototype.head = function(v){ return this._head; }
			tag.prototype.setHead = function(v){ this._head = v; return this; };
			
			
			tag.prototype.hash = function(v){ return this._hash; }
			tag.prototype.setHash = function(v){ this._hash = v; return this; };
			
			tag.prototype.expand = function (lft,rgt){
				var ary;
				if(lft === undefined) lft = 0;
				if(rgt === undefined) rgt = 0;
				this.log('imcaret expand',lft,rgt);
				this.decollapse();
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				a.move(lft);
				b.move(rgt);
				return this;
			};
			
			tag.prototype.toArray = function (){
				if (this.isCollapsed()) {
					return [this.head().row(),this.head().col()];
				} else {
					return [this.head().row(),this.head().col(),this.tail().row(),this.tail().col()];
				};
			};
			
			tag.prototype.toHash = function (){
				return '[' + this.toArray().join(',') + ']';
			};
			
			tag.prototype.set = function (val){
				if (val instanceof IM.Types.Tok) {
					return this.set(val.region());
				};
				
				if (val instanceof Region) {
					return (this.setRegion(val),val);
				};
				
				if (val instanceof Array) {
					this.head().setRow(val[0]);
					this.head().setCol(val[1]);
					
					if (val.length == 4) {
						this.decollapse();
						this.tail().setRow(val[2]);
						this.tail().setCol(val[3]);
					} else {
						this.setTail(this.head());
					};
				};
				this.dirty();
				return this;
			};
			
			tag.prototype.expandToLines = function (){
				var ary;
				this.selectable();
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				a.setCol(0);
				b.setCol(1000);
				return this.dirty();
			};
			
			tag.prototype.selectAll = function (){
				this.decollapse();
				this.tail().setLoc(0);
				this.head().setLoc(this.view()._buffer.len()); // :length
				this.dirty();
				return this;
			};
			
			tag.prototype.selectable = function (){
				this.decollapse();
				return this;
			};
			
			tag.prototype.decollapse = function (){
				var v_;
				if (this.tail() == this.head()) { (this.setTail(v_ = this.head().clone()),v_) };
				return this;
			};
			
			tag.prototype.collapse = function (){
				this.setTail(this.head());
				this.dirty();
				return this;
			};
			
			tag.prototype.collapseToStart = function (){
				if (this.isReversed()) {
					this.setTail(this.head());
				} else {
					this.setHead(this.tail());
				};
				this.dirty();
				return this;
			};
			
			tag.prototype.orientation = function (){
				return this.isReversed() ? ('reversed') : ('normal');
			};
			
			tag.prototype.isCollapsed = function (){
				return this.tail() == this.head();
			};
			
			tag.prototype.isReversed = function (){
				return this.head().row() < this.tail().row() || (this.tail().row() == this.head().row() && this.head().col() < this.tail().col());
			};
			
			tag.prototype.indent = function (){
				var str = this.head().linestr();
				var ind = str.match(/^(\t*)/)[0];
				return ind;
			};
			
			tag.prototype.peekbehind = function (val){
				var str = this.ends()[0].peekbehind();
				if (val instanceof RegExp) { return str.match(val) };
				return str;
			};
			
			tag.prototype.move = function (offset,mode){
				if(offset === undefined) offset = 1;
				if(mode === undefined) mode = 0;
				this.head().alter(mode,offset);
				return this.dirty();
			};
			
			// what if we 
			tag.prototype.moveDown = function (len){
				if(len === undefined) len = 1;
				this.head().moveDown();
				return this.dirty();
			};
			
			tag.prototype.moveUp = function (len){
				if(len === undefined) len = 1;
				this.head().moveUp();
				return this.dirty();
			};
			
			tag.prototype.ends = function (){
				return this.isReversed() ? ([this.head(),this.tail()]) : ([this.tail(),this.head()]);
			};
			
			tag.prototype.text = function (){
				return this.region().text();
			};
			
			tag.prototype.region = function (){
				// get the actual region based on head and tail
				// getting the code might be expensive if done
				// too many times -- but easy to cache
				// send this to util instead
				var ary;
				var code = this.view().code();
				var lines = code.split('\n');
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				
				var start = 0;
				var end = 0;
				var ln = 0;
				
				var ar = a.row(),ac = a.col(),br = b.row(),bc = b.col();
				var char$;
				
				for (var i = 0, items = iter$(lines), len = items.length, line; i < len; i++) {
					line = items[i];
					ln = line.length;
					if (i < ar) {
						start += ln + 1; // include newline
					} else if (i == ar) {
						var offset = util.colToLoc(line,ac);
						start += Math.min(ln,offset);
					};
					
					if (i < br) {
						end += ln + 1; // include newline
					} else if (i == br) {
						offset = util.colToLoc(line,bc);
						end += Math.min(ln,offset);
					} else {
						break;
					};
				};
				
				return new Region(start,end,this.view().root(),this.view());
			};
			
			tag.prototype.setRegion = function (reg){
				var buf = this.view().code();
				var a = util.rowcol(buf,reg.a());
				var b = util.rowcol(buf,reg.b());
				
				this.setHead(new RowCol(b[0],b[1],this));
				
				if (reg.size() == 0) {
					this.setTail(this.head());
				} else {
					this.setTail(new RowCol(a[0],a[1],this));
				};
				return this.dirty();
			};
			
			tag.prototype.nodes = function (reg){
				if(reg === undefined) reg = this.region();
				return this.view().nodesInRegion(reg,this.isCollapsed());
			};
			
			// should rather move this to region itself
			tag.prototype.target = function (reg){
				if(reg === undefined) reg = this.region();
				var nodes = this.nodes(reg);
				if (nodes.length > 2) {
					return util.commonAncestor(nodes.map(function(n) { return n.node; }));
				};
				return nodes[0].node;
			};
			
			tag.prototype.insert = function (text,edit){
				
				var sub = '';
				this.view().history().mark('action');
				
				if (!(this.isCollapsed())) {
					var reg = this.region();
					sub = reg.text();
					this.view().erase(reg);
					this.collapseToStart();
				};
				
				var move = 0;
				var sel;
				
				// need a different syntax for $0 -- can be in regular pasted code
				// should have a separate command for insertSnippet probably.
				if (text.indexOf('$0') >= 0) {
					sel = this.region().clone(0,sub.length).move(text.indexOf('$0'));
					text = text.replace('$0',sub);
				};
				
				edit || (edit = {size: text.length});
				
				this.head().normalize();
				var res = this.view().insert(this.region().start(),text,edit);
				this.view().log('inserted -- now move',edit.size);
				
				if (sel) {
					this.setRegion(sel);
				} else {
					// move locations
					this.head().setLoc(this.head().loc() + edit.size);
					// head.move(edit:size)
				};
				
				this.dirty();
				
				return this;
			};
			
			
			tag.prototype.erase = function (mode){
				this.view().history().mark('action');
				
				if (this.isCollapsed()) {
					this.log('isCollapsed',mode);
					this.decollapse();
					this.head().alter(mode,-1); // 
					
					// dirty
					// return erase # call again now
				};
				console.log('erasing region',this.region());
				this.view().erase(this.region());
				// log 'now collapse region to start',region
				this.collapseToStart();
				// log region
				return this;
				
				var target = this.target(this.reg());
				this.setRegion(this.reg());
				
				return this.view().edit(
					{text: '',
					target: target,
					region: this.reg(),
					caret: this.reg().clone().collapse(false)}
				);
			};
			
			tag.prototype.dirty = function (){
				var $1, $2;
				this._timestamp = new Date();
				// var hash = toArray.join("")
				
				if (this._hash != this.toHash()) {
					// the realCol values could have changed though?
					this.view().history().oncaret(this._hash,this.toHash(),this);
					this._hash = this.toHash();
					// console.log 'caret has actually changed',@hash
				};
				
				var rev = this.isReversed();
				var a = this.tail();
				var b = this.head();
				
				if (rev) { $1 = b,$2 = a,a = $1,b = $2 };
				
				var lc = b.row() - a.row();
				var row = a.row();
				
				var ac = a.realCol(); // Math.min( a.col, util.colsForLine(view.linestr(a.row) ) )
				var bc = b.realCol(); // Math.min( b.col, util.colsForLine(view.linestr(b.row) ) )
				var hc,tc;
				
				if (this.isReversed()) {
					hc = ac;
					tc = bc;
				} else {
					hc = bc;
					tc = ac;
				};
				
				// log 'dirty',region,a.row,a.col,b.row,b.col,hc,tc,head,tail,rev
				
				this.css({transform: ("translate(0px," + (a.row() * 100) + "%)")});
				// convert the row and column to a region (should go both ways)
				this._caret.css({transform: ("translate(" + hc + "ch," + ((this.head().row() - row) * 100) + "%)")});
				this._start.css({marginLeft: ("" + ac + "ch"),width: "auto"});
				this._end.css({width: ("" + bc + "ch")});
				
				if (this.isCollapsed()) {
					this.setMode('collapsed');
				} else if (lc == 0) {
					this.setMode('single');
					this._start.css({width: (bc - ac) + "ch"});
				} else {
					this._mid.setText(lc > 1 ? (('\n').repeat(lc - 1)) : (''));
					this.setMode('multi');
				};
				return this;
			};
			
			tag.prototype.render = function (){
				var elapsed = (new Date() - this._timestamp);
				var flip = Math.round(elapsed / 500) % 2;
				
				if (flip != this._flip) {
					this._caret.flag('blink',flip);
					this._flip = flip;
				};
				
				return this;
			};
			
			tag.prototype.build = function (){
				var v_, t0;
				this.setTail((this.setHead(v_ = new RowCol(0,0,this)),v_));
				
				return this.setChildren([
					// <imcaptor@input value='x'>
					(this.$a = this.$a || tag$.$span().flag('dim')).setText('x').end(),
					(this._caret = this._caret || tag$.$imcarethead().setRef('caret',this)).end(),
					(t0 = this._lines=this._lines || tag$.$div().setRef('lines',this)).setContent([
						(this._start = this._start || tag$.$div().setRef('start',this)).setText(" ").end(),
						(this._mid = this._mid || tag$.$div().setRef('mid',this)).end(),
						(this._end = this._end || tag$.$div().setRef('end',this)).setText(" ").end()
					],2).end()
				],2).synced();
			};
			
			tag.prototype.normalize = function (){
				this.head().normalize();
				return this;
			};
			
			tag.prototype.modeDidSet = function (new$,old){
				this.unflag(old);
				return this.flag(new$);
			};
		});
	
	})()

/***/ },
/* 44 */
/***/ function(module, exports) {

	(function(){
		
		tag$.defineTag('scrimbla-overlay', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				return this.setChildren(JSON.stringify(this.object()),3).synced();
			};
		});
		
		return tag$.defineTag('scrimbla-overlays', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.add = function (type,data){
				if(data === undefined) data = {};
				console.log('add overlay!');
				this.append(tag$.$scrimbla_overlay().setView(this.view()).setObject(data).end());
				return this;
			};
			
			tag.prototype.reposition = function (){
				return this;
			};
		});
	
	})()

/***/ },
/* 45 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('imeditor', function(tag){
			
			tag.prototype.build = function (){
				this.render();
				return this;
			};
			
			tag.prototype.render = function (){
				return this.setChildren(
					(this._view = this._view || tag$.$imview().setRef('view',this)).end()
				,2).synced();
			};
			
			tag.prototype.view = function (){
				return this._view;
			};
			
			tag.prototype.activate = function (){
				this.view().activate();
				return this;
			};
			
			tag.prototype.deactivate = function (){
				this.view().deactivate();
				return this;
			};
			
			tag.prototype.load = function (code,opts){
				this.view().load(code,opts);
				return this;
			};
			
			tag.prototype.fs = function (){
				return IM.FS;
			};
			
			tag.prototype.oncommand = function (e,c){
				if (this[c.command] instanceof Function) {
					this[c.command].call(this,c.args || []);
					e.halt();
				};
				return this;
			};
			
			tag.prototype.onsavesession = function (){
				console.log("imeditor.saveSession",this);
				var path = this.view().filename().replace(/\.imba$/,'.imbasession');
				var body = JSON.stringify(this.view().history());
				
				return IM.FS.save(path,body,function() {
					return console.log('returned from saving!',path);
				});
			};
		});
	
	})()

/***/ },
/* 46 */
/***/ function(module, exports) {

	(function(){
		
		/*
		Bridge for communicating with the Imba compiler in a worker
		*/
		
		function ImbacWorker(path){
			if(path === undefined) path = "/vendor/imba/imbac.worker.min.js";
			this._path = path;
			this._callbacks = [];
			this;
		};
		
		exports.ImbacWorker = ImbacWorker; // export class 
		ImbacWorker.prototype.worker = function (){
			var self = this, process1;
			return self._worker || (self._worker = (true) && (
				process1 = new Worker(self._path),
				process1.onmessage = function(e) { return self.onmessage(e); },
				process1
			));
		};
		
		ImbacWorker.prototype.onmessage = function (e){
			var fn;
			if (fn = this._callbacks.shift()) {
				return fn(e.data,e);
			};
		};
		
		ImbacWorker.prototype.compile = function (code,o,cb){
			this._callbacks.push(cb);
			this.worker().postMessage(['compile',code,o]);
			return this;
		};
		
		ImbacWorker.prototype.analyze = function (code,o,cb){
			this._callbacks.push(cb);
			this.worker().postMessage(['analyze',code,o]);
			return this;
		};
		return ImbacWorker;
	
	})()

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		__webpack_require__(48);
		__webpack_require__(49);
		__webpack_require__(50);
		__webpack_require__(51);
		__webpack_require__(52);
		__webpack_require__(53);
		__webpack_require__(54);
		__webpack_require__(55);
		return __webpack_require__(56);
	
	})()

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Highlighter = __webpack_require__(29).Highlighter;
		var util = __webpack_require__(34);
		
		// dangerous to extend all htmlelement tags globally
		tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.bubble = function (name,data){
				// log "bubble event",name,data
				var ev = Imba.Events.trigger(name,this,{data: data,bubble: true});
				return ev;
			};
			
			tag.prototype.delay = function (name,time,blk){
				this._timeouts || (this._timeouts = {});
				clearTimeout(this._timeouts[name]);
				if (time != -1) { this._timeouts[name] = setTimeout(blk,time) };
				return this;
			};
			
			tag.prototype.setNext = function (el){
				if (el instanceof IMFragment) {
					el = Array.prototype.slice.call(el.dom().childNodes);
				};
				
				if (el instanceof Array) {
					for (var i = 0, ary = iter$(el.reverse()), len = ary.length; i < len; i++) {
						this.setNext(ary[i]);
					};
					return this;
				};
				
				var curr = this.dom().nextSibling;
				if ((typeof el=='string'||el instanceof String)) {
					el = document.createTextNode(el);
				};
				
				if (curr) {
					this.parent().insertBefore(el,curr);
				} else {
					this.parent().appendChild(el);
				};
				
				return el;
			};
			
			tag.prototype.setPrev = function (el){
				if (el instanceof IMFragment) {
					el = Array.prototype.slice.call(el.dom().childNodes);
					// el = [].concat(el.dom:childNodes)
				};
				
				if (el instanceof Array) {
					for (var i = 0, ary = iter$(el), len = ary.length; i < len; i++) {
						this.setPrev(ary[i]);
					};
					return this;
				};
				
				var curr = this.dom().prevSibling;
				if ((typeof el=='string'||el instanceof String)) {
					el = document.createTextNode(el);
				};
				this.parent().insertBefore(el,this);
				// parent.insert(el, before: self)
				return el;
			};
			
			tag.prototype.nextNode = function (){
				return this.dom().nextSibling;
			};
			
			tag.prototype.prevNode = function (){
				return this.dom().prevSibling;
			};
		});
		
		IM.Types = {};
		
		tag$.defineTag('im', 'b', function(tag){
			
			tag.key = function (key,handler){
				this.prototype[("handle" + key)] = handler;
				return this;
			};
			
			tag.native = function (typ){
				this._nativeType = typ;
				return this;
			};
			
			tag.type = function (typ){
				IM.Types[typ] = this;
				this._type = typ;
				this.prototype._type = typ;
				// @domFlags.push(typ) if @domFlags
				return this;
			};
			
			tag.type('Tok');
			
			tag.alias = function (typ){
				IM.Types[typ] = this;
				return this;
			};
			
			tag.trigger = function (match,cmd){
				if (cmd instanceof Function) {
					cmd = {command: cmd};
				};
				
				cmd.trigger = match;
				return this.prototype[("trigger-" + match)] = cmd;
			};
			
			tag.prototype.setHint = function (hint){
				if (hint && hint != this._hint) {
					this.setAttribute('hint',hint.ref());
					this.setAttribute("hint-type",hint.type());
				} else {
					this.removeAttribute('hint');
					this.removeAttribute('hint-type');
				};
				return this._hint = hint;
			};
			
			tag.prototype.hint = function (){
				// strange no?		
				return this._hint || this.view().hints().get(this.getAttribute('hint'));
			};
			
			// go over to using this 
			tag.prototype.walkTextNodes = function (mark){
				if(mark === undefined) mark = false;
				this.setRoot(this.dom());
				var el;
				var nodes = [];
				var pos = 0;
				var walk = document.createTreeWalker(this.root(),NodeFilter.SHOW_TEXT,null,false);
				
				while (el = walk.nextNode()){
					if (mark) {
						var len = el.length;
						el._loc = pos;
						pos += len;
					};
					nodes.push(el);
				};
				
				return nodes;
			};
			
			
			tag.prototype.util = function (){
				return util;
			};
			
			tag.prototype.select = function (){
				return this.view().caret().set(this.region());
			};
			
			tag.prototype.canPrepend = function (text){
				return false;
			};
			
			tag.prototype.canAppend = function (text){
				return false;
			};
			
			tag.prototype.log = function (){
				var logger_;
				(logger_ = this.view().logger()).log.apply(logger_,arguments);
				return this;
			};
			
			tag.prototype.toString = function (){
				return this.dom().outerHTML;
			};
			
			tag.prototype.spaced = function (){
				if (this.dom().nextSibling instanceof Text) {
					return (/[\t ]/).test(this.dom().nextSibling.textContent[0]);
				};
				return false;
			};
			
			tag.prototype.unspaced = function (){
				return !(this.spaced());
			};
			
			tag.prototype.nextImmediate = function (){
				// could be text as well?
				return this.dom().nextSibling instanceof Text ? (null) : (this.next());
			};
			
			tag.prototype.prevImmediate = function (){
				// could be text as well?
				return this.dom().previousSibling instanceof Text ? (null) : (this.prev());
			};
			
			tag.prototype.repair = function (){
				return this;
			};
			
			tag.prototype.text = function (){
				return this.dom().textContent;
			};
			
			tag.prototype.setText = function (text){
				this.dom().textContent = text;
				return this;
			};
			
			tag.prototype.code = function (){
				return this.dom().textContent;
			};
			
			tag.prototype.setCode = function (code,silent){
				var hint_;
				if(silent === undefined) silent = false;
				var prev = this.code();
				
				if (this._dom.firstChild == this._dom.lastChild && (this._dom.firstChild instanceof Text)) {
					// still set if it has not changed?
					this._dom.firstChild.textContent = code;
				} else {
					this._dom.textContent = code;
				};
				
				if (code != prev) {
					(hint_ = this.hint()) && hint_.changed  &&  hint_.changed();
					if (!silent) { this.onchanged(code,prev) };
				};
				return this;
			};
			
			tag.prototype.onchanged = function (code,prev){
				return this.flag('dirty');
			};
			
			tag.prototype.size = function (){
				return this.code().length;
			};
			
			tag.prototype.view = function (){
				var parent_;
				return this._view || ((parent_ = this.parent()) && parent_.view  &&  parent_.view()) || VIEW;
			};
			
			tag.prototype.sel = function (){
				return this.view().caret();
			};
			
			tag.prototype.region = function (){
				return this.view().regionForNode(this);
			};
			
			tag.prototype.loc = function (){
				return this.region().loc();
			};
			
			tag.prototype.load = function (){
				return this;
			};
			
			tag.prototype.decreaseIndent = function (pre,state){
				return false;
			};
			
			tag.prototype.increaseIndent = function (pre,state){
				var reg = /^(\s*(.*\=\s*)?(class|def|tag|unless|if|else|elif|switch|try|catch|finally|for|while|until|do))/;
				return reg.test(pre);
			};
			
			tag.prototype.erase = function (region,mode){
				if (mode == 'all') {
					this.orphanize();
				} else {
					this.setCode(util.patchString(this.code(),'',region)); // code.ins('',region)
				};
				return this;
			};
			
			tag.prototype.insert = function (region,str,edit,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var mode = pars.mode !== undefined ? pars.mode : null;
				this.setCode(util.patchString(this.code(),str,region));
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				return this;
			};
			
			tag.prototype.oncommand = function (e,cmd){
				var name = cmd.command;
				var fn = this[name];
				this.log('run oncommand',name,cmd);
				
				if (fn instanceof Function) {
					fn.call(this,e,cmd);
				};
				return this;
			};
			
			tag.prototype.indentBlock = function (e){
				this.log('im.indentBlock',arguments,this);
				return this;
			};
			
			tag.prototype.clone = function (val){
				return IM.tok(val).classify();
			};
			
			tag.prototype.validate = function (code){
				return false;
			};
			
			tag.prototype.isFirst = function (){
				var par = this.parent();
				return (par instanceof IM.Types.Tok) && par.dom().firstChild == this.dom();
			};
			
			tag.prototype.isLast = function (){
				var par = this.parent();
				return (par instanceof IM.Types.Tok) && par.dom().lastChild == this.dom();
			};
			
			tag.prototype.isValid = function (code){
				if(code === undefined) code = this.text();
				return this.validate(code);
			};
			
			tag.prototype.markInvalid = function (){
				this.flag('invalid');
				return this;
			};
			
			tag.prototype.markValid = function (){
				this.unflag('invalid');
				return this;
			};
			
			tag.prototype.isInvalid = function (){
				return this.hasFlag('invalid');
			};
			
			tag.prototype.classify = function (){
				return this;
			};
			
			// unwrap / remove this node from parent
			tag.prototype.unwrap = function (){
				var el = this.dom();
				var par = el.parentNode;
				
				while (el.firstChild){
					par.insertBefore(el.firstChild,el);
				};
				return this;
			};
			
			tag.prototype.replaceWith = function (other){
				this.setPrev(other);
				return this.orphanize();
			};
			
			tag.prototype.scope = function (){
				return this.closest(q$('._indent',this));
			};
			
			tag.prototype.mutated = function (muts){
				// remove node if it is orphanized
				var self = this;
				if (self.code() == '') {
					self.log('remove whole node');
					// should possibly
					return self.orphanize();
				} else {
					self.log('mutated -- reparse');
					return self.view().observer().pause(function() {
						return self.view().highlighter().reparse(self.dirtyExtent());
					});
				};
			};
			
			
			tag.prototype.reclassify = function (type){
				// reclassify should happen through the highlighter
				// log 'reclassify node as type',type
				var cls = IM.Types[type] || Imba.TAGS[("im" + type)];
				
				if (cls) {
					// log 'found class to reclassify as',cls,self:constructor
					if (cls == this.constructor) {
						return this;
					};
					
					// log 'found class to reclassify as',cls
					var node = new cls(this.dom()).setup();
					return node;
				};
				return this;
			};
			
			tag.prototype.reparsed = function (){
				return this;
			};
			
			tag.prototype.baseClasses = function (){
				var cls = this.constructor.dom().className;
				if (this._type) { cls += ' ' + this._type };
				return cls;
			};
			
			tag.prototype.setup = function (){
				this._dom.className = this.baseClasses();
				return this;
			};
			
			tag.prototype.reuse = function (){
				return this.setup.apply(this,arguments);
			};
			
			tag.prototype.isAtomic = function (){
				return false;
			};
			
			// find the nodes / region that should be reparsed if this element has changed
			// this is currently quote 
			
			tag.prototype.dirtyExtent = function (){
				// 3log "get dirty extent for",dom
				var self = this, sel, sel1, sel2, $1;
				if (sel = self.up(q$('.selector',self))) {
					return sel.dirtyExtent();
				} else if (sel1 = self.up(q$('._imtagnode',self))) {
					return sel1.dirtyExtent();
				} else if (sel2 = self.up(q$('._imistring',self))) {
					return sel2.dirtyExtent();
				};
				
				if (self.isAtomic()) { // hmm
					return {
						nodes: [self.dom()],
						code: self.code(),
						contains: function(el) { return self.dom().contains(el._dom || el); }
					};
				};
				
				var start = self.dom();
				var end = self.dom();
				
				var prev,next;
				var nodes = [self.dom()];
				var opener,closer;
				
				while (prev = start.previousSibling){
					if (prev instanceof Text) {
						break;
					} else if (prev.matches('._imnewline,._imtab')) { // ,._imopen,._imclose
						break;
					};
					
					if (prev.matches('._imopen')) {
						opener = prev;
					};
					
					start = prev;
					nodes.unshift(start);
				};
				
				while (next = end.nextSibling){
					if (next instanceof Text) {
						break;
					} else if (next.matches('._imnewline')) { // ._imopen,._imclose
						break;
					};
					
					if (next.matches('._imclose')) {
						closer = next;
					};
					
					end = next;
					nodes.push(end);
				};
				
				// see if we include an open or close-tag
				
				var result = {
					nodes: nodes,
					code: "",
					target: self.dom(),
					nested: [],
					contains: function(node) { return this.nodes.indexOf(node) >= 0; }
				};
				
				if (opener || closer) {
					// log "includes opener and / or closer",opener,closer
					var par = tag$wrap((opener || closer).parentNode);
					if (($1 = par) && $1.isAtomic  &&  $1.isAtomic()) {
						// log 'return the parent dirty extent',par
						return par.dirtyExtent();
					};
					
					for (var nodes = [], i = 0, ary = iter$((opener || closer).parentNode.children), len_ = ary.length; i < len_; i++) {
						nodes.push(ary[i]);
					};
				};
				
				var loc = 0;
				
				// should use the tags directly
				for (var i = 0, ary = iter$(nodes), len_ = ary.length, node; i < len_; i++) {
					node = ary[i];
					var rich = tag$wrap(node);
					var text = node.textContent;
					var len = text.length;
					
					if (false) {
						text = "''";
						len = 5;
						self.log("added node as nested reference",rich.dom());
						// this is fucked up
						// this really does mess up the rich nodes here(?!)
						result.nested.push(rich);
					};
					
					result.code += text;
					loc += len;
				};
				
				result.nodes = nodes;
				return result;
			};
			
			tag.prototype.reparseExtent = function (e){
				var self = this;
				return self.view().observer().pause(function() {
					var dirty = self.dirtyExtent();
					if (e) { e.handled() };
					return Highlighter.reparse(dirty);
				});
			};
		});
		
		
		// piece of unparsed code
		tag$.defineTag('imraw', 'im', function(tag){
			tag.type('raw');
			tag.alias('@');
			
			tag.prototype.setRaw = function (raw){
				this._raw = raw;
				this._dom.textContent = raw;
				return this;
			};
			
			tag.prototype.onedit = function (e){
				this.setCode(e.patch(this));
				return e.handled();
			};
		});
		
		tag$.defineTag('imfragment', 'imraw', function(tag){
			tag.type('fragment');
			
			tag.prototype.setContent = function (content){
				if (typeof content == 'string') {
					this.dom().innerHTML = content;
				} else {
					tag.__super__.setContent.apply(this,arguments);
				};
				return this;
			};
			
			tag.prototype.repair = function (){
				this.unwrap();
				this.orphanize();
				return this;
			};
		});
		
		IMFragment = Imba.TAGS.imfragment;
		
		tag$.defineTag('imopen', 'im', function(tag){
			
			// @nodeType = 's'
			tag.type('open');
			
			tag.alias('[');
			tag.alias('(');
			tag.alias('{');
			tag.alias('{{');
			tag.alias('index_start');
			tag.alias('block_param_start');
		});
		
		tag$.defineTag('imclose', 'im', function(tag){
			
			tag.type('close');
			// @nodeType = 's'
			
			tag.alias(']');
			tag.alias(')');
			tag.alias('}');
			tag.alias('}}');
			tag.alias('index_end');
			tag.alias('block_param_end');
		});
		
		tag$.defineTag('imrparen', 'imclose', function(tag){
			tag.type('rparen');
			tag.alias(')');
		});
		
		tag$.defineTag('imtagopen', 'imopen', function(tag){
			tag.type('tag_start');
		});
		
		tag$.defineTag('imtagclose', 'imclose', function(tag){
			tag.type('tag_end');
		});
		
		tag$.defineTag('imselopen', 'imopen', function(tag){
			tag.type('selector_start');
		});
		
		tag$.defineTag('imselclose', 'imclose', function(tag){
			tag.type('selector_end');
		});
		
		tag$.defineTag('imquote', 'im');
		
		tag$.defineTag('imsinglequote', 'imquote', function(tag){
			tag.type("'");
		});
		
		tag$.defineTag('imdoublequote', 'imquote', function(tag){
			tag.type('"');
		});
		
		tag$.defineTag('imstrstart', 'imopen', function(tag){
			tag.type('string_start');
		});
		
		return tag$.defineTag('imstrend', 'imclose', function(tag){
			tag.type('string_end');
		});
	
	})()

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		var Region = __webpack_require__(27).Region;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		
		var keywords = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil','extend','export','own'
		];
		
		// this is really the general token
		tag$.defineTag('imtok', 'im', function(tag){
			tag.alias('token');
			
			
			tag.prototype.__eref = {watch: 'erefDidSet',name: 'eref'};
			tag.prototype.eref = function(v){ return this.getAttribute('eref'); }
			tag.prototype.setEref = function(v){
				var a = this.eref();
				if(v != a) { this.setAttribute('eref',v); }
				if(v != a) { this.erefDidSet && this.erefDidSet(v,a,this.__eref) }
				return this;
			};
			
			tag.prototype.erefDidSet = function (new$,old){
				// experimental
				// console.log 'erefDidSet',new,old
				if (!(new$ && old)) { this.flag('lvar',!(!(new$))) };
				return this;
			};
			
			tag.prototype.isVarRef = function (){
				return this.hasFlag('lvar');
			};
			
			tag.prototype.clearVarRef = function (){
				this.setEref(null);
				return this;
			};
			
			tag.prototype.clone = function (val){
				return IM.tok(val);
			};
			
			tag.prototype.setText = function (text){
				tag.__super__.setText.call(this,text);
				this.classify();
				
				var typ = IM.identify(text);
				
				if (typ) {
					this.log('reclassifying imtok immediately');
					this.setCode(text);
					return this.reclassify(typ);
				};
				
				// return raw token if not classified?
				return this._typ ? (this) : (tag$.$imraw().setRaw(text).end());
			};
			
			tag.prototype.canPrepend = function (text){
				return true;
			};
			
			tag.prototype.canAppend = function (text){
				return true;
			};
			
			tag.prototype.classify = function (map){
				map || (map = IM.identify(this.code()));
				if (map) {
					if (!map.match(/\b_[\w]/)) { map = '_imtok ' + map };
					this.dom().className = map;
					this._typ = map;
				} else {
					this._typ = null;
				};
				return this;
			};
			
			tag.prototype.validate = function (code){
				return false;
			};
			
			tag.prototype.repair = function (){
				this.log('repair');
				this.classify();
				return this;
			};
			
			tag.prototype.split = function (region){
				region = Region.normalize(region);
				var lft = this.code().substring(0,region.start());
				var rgt = this.code().slice(region.end());
				
				this.setCode(lft);
				this.setNext(IM.tok(rgt));
				return this;
			};
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				var dirty = this.dirtyExtent();
				this.view().observer().pause(function() { return Highlighter.reparse(dirty); });
				return this;
			};
			
			tag.prototype.reuse = function (tok,new$,old){
				if (new$ == old) { return this };
				return tag.__super__.reuse.apply(this,arguments);
			};
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && this.validate(this.code())) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
			
			tag.prototype.ondblclick = function (e){
				e.halt();
				return this.select();
			};
			
			tag.prototype.onmouseover = function (e){
				e.halt();
				
				if (this.eref()) {
					return this.view().nodesForEntity(this.eref()).map(function(el) { return el.flag('hl'); });
				};
			};
			
			tag.prototype.onmouseout = function (e){
				e.halt();
				if (this.eref()) {
					return this.view().nodesForEntity(this.eref()).map(function(el) { return el.unflag('hl'); });
				};
			};
		});
		
		
		tag$.defineTag('imidentifier', 'imtok', function(tag){
			tag.type('identifier');
			
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			tag.prototype.validate = function (code){
				// regex for identifier
				return (/^[a-z](-?[\wA-Za-z_\-\x7f-\uffff\$]+)*$/).test(code) && keywords.indexOf(code) == -1;
			};
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'identifier setup',baseClasses
				var v_;
				if (tok && tok._value) { (this.setName(v_ = tok._value),v_) };
				this._dom.className = this.baseClasses();
				return this;
			};
			
			tag.prototype.mutated = function (){
				// console.log 'imidentifier mutated'
				this.setName(this.code());
				if (this.isVarRef()) {
					this.clearVarRef();
				};
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imtagtype', 'imtok', function(tag){
			tag.type('tag_type');
		});
		
		tag$.defineTag('imtagid', 'imtok', function(tag){
			tag.type('tag_id');
			tag.alias('idref');
		});
		
		tag$.defineTag('imconst', 'imtok', function(tag){
			tag.type('const');
			
			tag.prototype.validate = function (code){
				return (/^[A-Z](-?[\wA-Za-z_\-\x7f-\uffff\$]+)*$/).test(code);
			};
			
			// def onchanged code, prev
			// 	# console.log 'imconst onchanged',code,prev
			// 	flag('dirty') unless validate(code)
		});
		
		
		tag$.defineTag('imivar', 'imtok', function(tag){
			tag.type('ivar');
		});
		
		tag$.defineTag('imcvar', 'imtok', function(tag){
			tag.type('cvar');
		});
		
		tag$.defineTag('imkeyword', 'imtok', function(tag){
			tag.type('keyword');
			tag.alias('new');
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'setup imkeyword',tok, new, old
				var cls = this.baseClasses();
				if (tok && tok._value) { cls += ' ' + tok._value };
				this._dom.className = cls;
				return this;
			};
		});
		
		keywords.map(function(keyword) { return IM.Types[keyword] = IM.Types.keyword; });
		
		IM.Types.forin = IM.Types.keyword;
		IM.Types.forof = IM.Types.keyword;
		IM.Types.post_if = IM.Types.keyword;
		IM.Types.post_unless = IM.Types.keyword;
		IM.Types.post_for = IM.Types.keyword;
		IM.Types.post_while = IM.Types.keyword;
		
		tag$.defineTag('imnum', 'imtok', function(tag){
			tag.type('number');
			
			tag.prototype.validate = function (code){
				return (/^\d+(\.\d+)?$/).test(code);
			};
			
			tag.prototype.reuse = function (){
				return this;
			};
		});
		
		tag$.defineTag('imint', 'imnum', function(tag){
			tag.type('int');
		});
		
		tag$.defineTag('imfloat', 'imnum', function(tag){
			tag.type('float');
		});
		
		tag$.defineTag('imbool', 'imtok', function(tag){
			tag.type('bool');
			tag.alias('true');
			tag.alias('false');
		});
		
		// this should be more advanced - no
		tag$.defineTag('imstr', 'imtok', function(tag){
			tag.type('string');
			
			tag.prototype.quote = function (){
				return this.code()[0];
			};
			
			tag.prototype.setQuote = function (quote){
				this.setCode(quote + this.code().slice(1,-1) + quote);
				return this;
			};
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'setup string',tok, new, old
				this._dom.className = this.baseClasses();
				this.setCode(new$);
				return this;
			};
			
			tag.prototype.onunwrap = function (e){
				var v_;
				this.log('imstring onunwrap!!!',e);
				e.halt();
				// look at prev and next as well?
				// should do this through the view
				return (this.setCode(v_ = this.code().slice(1,-1)),v_);
			};
			
			tag.prototype.ondblclick = function (e){
				e.halt();
				return this.select();
			};
			
			tag.prototype.validate = function (code){
				if (code[0] == '"') {
					return (/^\"([^"\{]*)\"$/).test(code);
				} else if (code[0] == "'") {
					return (/^\'([^'\{]*)\'$/).test(code);
				};
			};
			
			tag.trigger('"',function(token,o) {
				if (token.quote() == '"') {
					this.insert('\\"');
					return true;
				} else if (token.quote() == "'" && o.mode == 'all') {
					token.setQuote('"');
					return this;
				};
			});
			
			tag.trigger("'",function(token,o) {
				var v_;
				if (token.quote() == '"') {
					return (token.setQuote(v_ = "'"),v_);
				} else if (token.quote() == "'" && o.mode == 'all') {
					return this.insert("\\'");
				};
			});
		});
		
		
		
		tag$.defineTag('imneostring', 'imtok', function(tag){
			tag.type('neostring');
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && !this.code().match(/[\{\"\']/)) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imsym', 'imtok', function(tag){
			tag.type('symbol');
		});
		
		return tag$.defineTag('imtagattr', 'imtok', function(tag){
			tag.type('tag_attr');
		});
	
	})()

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var Highlighter = __webpack_require__(29).Highlighter;
		var util = __webpack_require__(34);
		
		tag$.defineTag('imblock', 'im', function(tag){
			
			tag.prototype.deleteLeftRight = function (e){
				this.log('imblock deleteLeftRight',e.region().peek(-1,1));
				
				if (e.region().peek(-1,1) == this.code()) {
					this.orphanize();
					return e.handled();
				};
				
				return this;
			};
			
			tag.prototype.indentBlock = function (e){
				var self = this;
				e.handled();
				
				self.view().caret().expandToLines();
				var region = self.view().caret().region();
				var nodes = self.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline')) {
						self.log('found tab in selection',match);
						if (match.mode != 'start') {
							return match.node.indent();
						};
					};
				});
				
				self.view().caret().dirty();
				return self;
			};
			
			tag.prototype.undent = function (e){
				this.log('imblock.undent',arguments);
				var nodes = e.view().nodesInRegion(e.region().clone().startAtLine());
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						return match.node.undent();
						// e.caret.expand(0,-1)
					};
				});
				this.view().caret().expandToLines();
				return e.handled();
			};
			
			tag.prototype.pairable = function (str,e){
				return true;
			};
			
			tag.prototype.wrap = function (node){
				this.setChildren([node]);
				return this;
			};
			
			tag.prototype.repair = function (){
				// log "repair block"
				q$('._imraw',this).map(function(raw) { return raw.repair(); });
				return this;
			};
			
			tag.prototype.rehighlight = function (){
				// var reg = view.sel.region
				var self = this;
				var state = self.codeState();
				var hl = IM.parse(state.code);
				// could send this through load instead
				// what about annotations here?
				throw 'dont rehighlight';
				
				if (hl) {
					self.view().observer().pause(function() {
						self.dom().innerHTML = hl + '\n';
						return state.invalids.map(function(inv) {
							// we could go local instead
							var node;
							if (node = self.view().nodeAtRegion(inv.region,true)) {
								self.log('found node at invalid position',node);
								return node.replaceWith(inv.node);
							};
						});
					});
				};
				return self;
			};
			
			// bad naming
			tag.prototype.codeState = function (){
				var self = this;
				var real = self.code();
				var valid = real;
				var invalids = q$('.invalid',self);
				var ownreg = self.region();
				var selreg = self.view().sel().region();
				
				var remember = invalids.map(function(inv) {
					// multilevel nesting?
					var region = inv.region();
					var relreg = region.relativeTo(ownreg);
					self.log('invalid region',ownreg,'self',region,relreg);
					valid = valid.ins(inv.placeholder(),relreg);
					return {region: region,placeholder: inv.placeholder(),raw: inv.code(),node: inv,root: self,relRegion: relreg};
				});
				
				return {
					region: ownreg,
					marker: (selreg.intersects(ownreg) ? (selreg) : (null)),
					raw: real,
					code: valid,
					invalids: remember
				};
			};
		});
		
		
		tag$.defineTag('iminterpolated', 'imblock');
		
		tag$.defineTag('indent', 'imblock', function(tag){
			
			tag.prototype.variables = function (){
				var map = {};
				var vars = [];
				q$('._lvar',this).map(function(lvar) {
					var name = lvar.text();
					if (!map[name]) {
						map[name] = true;
						return vars.push(name);
					};
				});
				return vars;
			};
		});
		
		tag$.defineTag('impair', 'imblock', function(tag){
			tag.type('pair');
			
			tag.pair = function (open,close){
				this.prototype._open = open;
				this.prototype._close = close;
				return this;
			};
			
			tag.prototype.open = function (){
				return this._open || '';
			};
			tag.prototype.close = function (){
				return this._close || '';
			};
			
			tag.prototype.build = function (){
				this.gen();
				return this;
			};
			
			tag.prototype.setContent = function (content){
				throw 'should not get here';
				this.dom().innerHTML = this.open() + IM.parse(content) + this.close();
				return this;
			};
			
			tag.prototype.isEmpty = function (){
				return this.code().replace(/[\s\t \n]/,'') == (this.open() + this.close());
			};
			
			tag.prototype.isPaired = function (){
				var code = this.code();
				return code[0] == this.open() && code[code.length - 1] == this.close();
			};
			
			tag.prototype.isOpened = function (){
				return this.code()[0] == this.open();
			};
			
			tag.prototype.isClosed = function (){
				return this.code()[this.code().length - 1] == this.close();
			};
			
			tag.prototype.unwrap = function (){
				if (this.isEmpty()) {
					this.log('remove the whole thing');
					this.orphanize();
				} else {
					var el;
					var par = this.parent();
					while (el = this._dom.firstChild){
						par.dom().insertBefore(el,this._dom);
					};
					// remove self as well
				};
				return this;
			};
			
			tag.prototype.onunwrap = function (e){
				this.log('impair onunwrap!!!',e);
				return e.halt();
			};
			
			tag.prototype.gen = function (){
				this.setChildren([
					tag$.$imopen().setContent(this.open(),0).end(),
					tag$.$imclose().setContent(this.close(),0).end()
				]);
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				e.setCaret(this.region().collapse(false).move(1));
				return this;
			};
			
			tag.prototype.select = function (){
				return this;
			};
			
			tag.prototype.onlinebreak = function (e){
				var pre = e.linestr('pre');
				var indent = e.indent();
				var new$ = this.text().ins('',e.relRegion());
				
				// this is a special case - no?
				if (new$ == (this.open() + this.close())) {
					var prefix = '\n' + indent + '\t';
					var post = '\n' + indent;
					this.onwhitespace(e,prefix + post);
					e.caret().collapse(false).move(-post.length);
					return e.handled();
				};
				
				// need to first consider the splitting, no?
				if (this.increaseIndent(pre)) { indent += '\t' };
				if (this.decreaseIndent(pre)) { indent = indent.slice(1) };
				this.onwhitespace(e,'\n' + indent);
				return e.handled();
			};
			
			tag.prototype.repair = function (){
				this.log('repair imtag');
				if (!(this.isPaired())) { this.revalidate(true) };
				return this;
			};
			
			tag.prototype.mutated = function (){
				this.log('impair mutated');
				return this.revalidate();
			};
			
			tag.prototype.defaultValidationMode = function (){
				return 'tokenize';
			};
			
			tag.prototype.rehighlight = function (){
				return this;
			};
			
			tag.prototype.revalidate = function (mode,write){
				// tricky motherfucker -- mostly useful for validations
				// I suppose we can do this a simpler way -- by turning
				// off observers -- temporarily replacing inner code etc
				
				// when a block checks validity it should probably
				// substitute inner invalid parts - so that the block
				// thing is still valid
				var self = this, hl;
				if(mode === undefined) mode = self.defaultValidationMode();
				if(write === undefined) write = false;
				var wasInvalid = self.hasFlag('invalid');
				var oldState = self.hasFlag('invalid');
				var state = self.codeState();
				var code = state.code;
				
				if (!(self.isPaired())) {
					return self.markInvalid();
				};
				
				console.log('will revalidate with code',code);
				console.time('revalidate');
				
				try {
					if (mode == 'compile') {
						self._output = Imbac.compile(code,{bare: true});
						self._tokens = self._output.options._tokens;
					} else {
						self._tokens = Imbac.tokenize(code,{bare: true});
					};
					self.markValid();
				} catch (e) {
					self._tokens = null;
					self.markInvalid();
				};
				
				console.timeEnd('revalidate');
				
				if (wasInvalid && self._tokens) {
					// need to fix inner for root
					if (hl = Highlighter.highlight(code,{tokens: self._tokens,inner: true})) {
						// this should be refactored out into a separate method
						// possibly do loadState / dumpState
						self.view().observer().pause(function() {
							self.dom().innerHTML = hl;
							state.invalids.map(function(inv) {
								var node;
								if (node = self.view().nodeAtRegion(inv.region,true)) {
									return node.replaceWith(inv.node);
								};
							});
							if (state.marker) { return self.view().sel().set(state.marker) };
						});
					};
				};
				
				return self;
			};
			
			tag.prototype.placeholder = function (){
				return this.open() + (' ').repeat(this.size() - 2) + this.close();
			};
			
			tag.prototype.isAtomic = function (){
				return true;
			};
			
			tag.prototype.mutated = function (){
				this.log('muated imcurly');
				this.view().highlighter().reparse(this.dirtyExtent());
				return this;
			};
		});
		
		tag$.defineTag('imcurly', 'impair', function(tag){
			tag.type('curly');
			tag.pair('{','}');
		});
		
		tag$.defineTag('imsquare', 'impair', function(tag){
			tag.type('square');
			tag.pair('[',']');
			
			tag.prototype.prettify = function (e){
				var self = this;
				self.log('prettify!');
				e.handled();
				var ind = e.region().indent();
				self.log('with indentation',ind,ind.length);
				
				self.view().observer().pause(function() {
					for (var i = 0, ary = iter$(self.children()), len = ary.length, child, res = []; i < len; i++) {
						child = ary[i];
						res.push(child.matches('.comma,._imopen') ? (
							child.setNext('\n' + ind + '\t')
						) : ((child.matches('._imclose')) && (
							child.setPrev('\n' + ind)
						)));
					};
					return res;
				});
				
				return true;
			};
		});
		
		tag$.defineTag('imparens', 'impair', function(tag){
			tag.type('parens');
			tag.pair('(',')');
			
			tag.prototype.onunwrap = function (e){
				this.log('impair onunwrap!!!',e);
				e.halt();
				// look at prev and next as well?
				// should do this through the view
				this.setCode(' ' + this.code().slice(1,-1));
				return this.view().repair();
			};
		});
		
		tag$.defineTag('imistring', 'impair', function(tag){
			tag.type('istring');
			tag.pair('"','"');
		});
		
		tag$.defineTag('imiexpr', 'impair', function(tag){
			tag.type('iexpr');
			tag.pair('{','}');
		});
		
		tag$.defineTag('imblockparams', 'impair', function(tag){
			tag.type('blockparams');
			tag.pair('|','|');
		});
		
		return tag$.defineTag('imtagnode', 'impair', function(tag){
			tag.type('tagnode');
			tag.pair('<','>');
			
			tag.prototype.pairable = function (str,e){
				return idx$(str,['{','[','(','"',"'"]) >= 0;
			};
			
			tag.prototype.placeholder = function (){
				return this.open() + ('x').repeat(this.size() - 2) + this.close();
			};
			
			tag.prototype.defaultValidationMode = function (){
				return 'compile';
			};
		});
	
	})()

/***/ },
/* 51 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('imroot', 'imblock', function(tag){
			
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag._nodeType = 'code';
			// def self.dom
			//	@dom ||= document.createElement('code')
			
			tag.prototype.tryUndent = function (e){
				var self = this;
				self.log('tryUndent');
				var nodes = e.view().nodesInRegion(e.region().clone().startAtLine());
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						match.node.undent();
						return self.view().caret().move(-1);
						// e.caret.move(-1)
						// e.caret.expand(0,-1)
					};
				});
				
				// e.moveCaret = 0
				e.handled();
				return self;
			};
			
			tag.prototype.build = function (){
				tag.__super__.build.apply(this,arguments);
				
				this.dom().addEventListener('');
				return this;
			};
			
			tag.prototype.commit = function (){
				return this;
			};
			
			tag.prototype.setNext = function (node){
				this.appendChild(node);
				return node;
			};
			
			tag.prototype.setPrev = function (node){
				var first = this.dom().firstChild;
				first ? (this.insertBefore(node,first)) : (this.appendChild(node));
				return node;
			};
			
			tag.prototype.onlinebreak = function (e){
				var pre = e.linestr('pre');
				var indent = e.indent();
				var new$ = this.text().ins('',e.relRegion());
				// need to first consider the splitting, no?
				if (this.increaseIndent(pre)) { indent += '\t' };
				if (this.decreaseIndent(pre)) { indent = indent.slice(1) };
				this.onwhitespace(e,'\n' + indent);
				return e.handled();
			};
			
			tag.prototype.mutated = function (){
				this.log('imroot mutated');
				return this;
			};
			
			tag.prototype.dirtyExtent = function (){
				var self = this;
				self.log('imroot dirtyExtent');
				// super
				var nodes = self.children().map(function(n) { return n.dom(); });
				
				return {
					code: self.code(),
					nodes: nodes,
					parent: self.dom(),
					contains: function(el) { return self.dom().contains(el._dom || el); }
				};
			};
		});
	
	})()

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		// externs;
		
		var util = __webpack_require__(34);
		
		var SINGLE_STR = /^'[^']*'$/;
		var DOUBLE_STR = /^"[^"\{]*"$/;
		var COMMENT = /^\#[ \t][^\n]*$/;
		
		DOUBLE_STR = /^"([^\\"\{]|\\\\|\\")*"$/;
		
		tag$.defineTag('imlit', 'im', function(tag){
			
			tag.prototype.validate = function (code){
				return false;
			};
		});
		
		return tag$.defineTag('imregex', 'imlit', function(tag){
			
			tag.type('regex');
			
			tag.prototype.validate = function (value){
				return true;
			};
			
			tag.prototype.pairing = function (chr){
				return this;
			};
			
			tag.prototype.revalidate = function (){
				var reg = this.code();
				try {
					var obj = eval(reg);
				} catch (e) { };
				this.log('regex is',reg,obj);
				this.flag('invalid',!obj);
				return this;
			};
			
			tag.prototype.mutated = function (){
				this.log('regex mutated');
				return this.revalidate();
			};
			
			tag.prototype.placeholder = function (){
				return '/' + 'R'.repeat(this.size() - 2) + '/';
			};
			
			tag.prototype.isAtomic = function (){
				return true;
			};
		});
		
	
	})()

/***/ },
/* 53 */
/***/ function(module, exports) {

	(function(){
		
		// should rather reconcile into token - or something like it
		var names = {
			'.': 'dot',
			'=': 'eq',
			'?': 'q',
			'!': 'unary',
			':': 'colon',
			',': 'comma',
			'#': 'hash',
			'*': 'mult',
			'>>': 'bitshift'
		};
		
		tag$.defineTag('imop', 'im', function(tag){
			
			tag.type('op');
			tag.alias('relation');
			tag.alias('compare');
			tag.alias('compound_assign');
			tag.alias('assign');
			tag.alias('block_arg');
			tag.alias('splat');
			tag.alias('logic');
			tag.alias('math');
			tag.alias('shift');
			tag.alias('unary');
			
			tag.prototype.validate = function (code){
				return IM.isOp(code);
			};
			
			tag.prototype.baseClasses = function (){
				return tag.__super__.baseClasses.apply(this,arguments) + ' ' + (names[this.code()] || '');
			};
			
			tag.prototype.setup = function (token){
				var val = token && token._value || this.code();
				this.dom().className = ("_im _imop op " + (names[val] || ''));
				return this;
			};
			
			// should merge with a more generic version for token in general
			// same goes for text etc
			tag.prototype.insert = function (){
				tag.__super__.insert.apply(this,arguments);
				
				if (this.code() == '//') {
					this.log('is a regex!!');
					return this.reclassify('regex');
				};
			};
		});
		
		// link regular ops to op-node
		return '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ? &= ||= &&= ?. ?: , ! .. ... .: >> << #'.split(' ').map(function(op) {
			return IM.Types[op] = IM.Types.op;
		});
		
		
		// IM.Types:logic = IM.Types:op
		// IM.Types:compare = IM.Types:op
		// IM.Types:math = IM.Types:op
		// IM.Types:shift = IM.Types:op
		
	
	})()

/***/ },
/* 54 */
/***/ function(module, exports) {

	(function(){
		
		// this should be more advanced than this, no?
		tag$.defineTag('imsel', 'imtok', function(tag){
			tag.type('selector');
			
			tag.prototype.isAtomic = function (){
				return true;
			};
			
			tag.prototype.reparsed = function (code,old){
				this.log("imsel reparsed",code,old);
				return this;
			};
		});
		
		tag$.defineTag('imseltag', 'imtok', function(tag){
			tag.type('selector_tag');
		});
		
		tag$.defineTag('imselclass', 'imtok', function(tag){
			tag.type('selector_class');
		});
		
		tag$.defineTag('imselcomb', 'imtok', function(tag){
			tag.type('selector_combinator');
		});
		
		tag$.defineTag('imselattrop', 'imtok', function(tag){
			tag.type('selector_attr_op');
		});
		
		return tag$.defineTag('imselattrop', 'imtok', function(tag){
			tag.type('selector_attr_op');
		});
	
	})()

/***/ },
/* 55 */
/***/ function(module, exports) {

	(function(){
		tag$.defineTag('iminsert', 'im', function(tag){
			
			tag.prototype.canAppend = function (){
				return true;
			};
			
			tag.prototype.canPrepend = function (){
				return true;
			};
			
			tag.prototype.insert = function (reg,ins){
				console.log('insert code into iminsert!!',ins,reg);
				
				if (ins instanceof IM.Types.fragment) {
					ins = ins.code();
				} else if (ins instanceof IM.Types.raw) {
					ins = ins._raw;
				} else if ((typeof ins=='string'||ins instanceof String)) {
					ins = (this.code() || "").ins(ins,reg);
				};
				
				this.setCode(ins);
				return this;
			};
			
			tag.prototype.isWhitespace = function (){
				return this.code().match(/^[\n\t\ ]+$/);
			};
			
			tag.prototype.mutated = function (){
				this.log('iminsert mutated');
				
				var dirty = this.dirtyExtent();
				this.view().highlighter().reparse(dirty);
				return this;
			};
		});
		
		tag$.defineTag('imwhitespace', 'im', function(tag){
			
			tag.prototype.canPrepend = function (str){
				return this.validate(str + this.code());
			};
			
			tag.prototype.canAppend = function (str){
				return this.validate(this.code() + str);
			};
			
			tag.prototype.validate = function (){
				return false;
			};
		});
		
		tag$.defineTag('imnewline', 'imwhitespace', function(tag){
			
			tag.type('newline');
			tag.alias('\n');
			
			tag.prototype.canPrepend = function (str){
				if (str.match(/^[\n\t\ ]+$/)) {
					// should not really be able to prepend here
					// it shold rather insert a new newline in
					// an iminsert, and that should be able to
					// decide that no reparse is needed
					return true;
				};
				return false;
			};
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return val == '\n';
			};
			
			tag.prototype.indent = function (){
				this.view().insert(this.region().end(),'\t');
				return this;
			};
			
			tag.prototype.undent = function (){
				this.log('undent newline');
				var reg = this.region().clone().collapse(true).clone(0,1);
				if (reg.text() == '\t') {
					this.log('can undent!!');
					this.view().erase(reg);
				};
				
				// view.observer.pause do
				//	next.orphanize if next?.matches('._imtab')
				return this;
			};
			
			tag.prototype.mutated = function (){
				// log 'imnewline mutated!!'
				// remove node if it is orphanized
				if (this.code() == '') {
					this.log('remove whole node');
					return this.orphanize();
				} else {
					this.log('reparse newline');
					return this.view().highlighter().reparse({nodes: [this.dom()],code: this.code()});
				};
			};
		});
		
		
		
		tag$.defineTag('imspace', 'imwhitespace', function(tag){
			
			tag.type('whitespace');
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return (/^[ ]+$/).test(val);
			};
			
			// this should be the default for all nodes, no?
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && this.validate(this.code())) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imsemicolon', 'imwhitespace', function(tag){
			tag.type('semicolon');
			tag.alias(';');
		});
		
		tag$.defineTag('imtab', 'imwhitespace', function(tag){
			
			tag.type('tab');
			tag.alias('\t');
			
			tag.prototype.onedit = function (e){
				if (e.isSurrounded()) {
					this.log('delete tab?!?');
					if (e.text()) { // otherwise we really are done
						e.redirect(this.prev() || this.next() || this.parent());
					} else {
						e.handled();
					};
					
					e.region().collapse(false);
					this.orphanize();
					return;
				};
			};
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return val == '\t';
			};
		});
		
		tag$.defineTag('imcomment', 'im', function(tag){
			
			tag.type('comment');
			
			tag.prototype.validate = function (code){
				return COMMENT.test(code);
			};
			
			tag.prototype.mutated = function (){
				this.log('imcomment mutated');
				return tag.__super__.mutated.apply(this,arguments);
			};
			
			tag.prototype.repair = function (){
				this;
				this.log('repair comment');
				var region = this.region().endAtLine();
				var full = region.text(); // should not include the last line?
				var nodes = region.nodes(false);
				this.log('whole region should be',region,full,nodes);
				this.log('all nodes',nodes);
				
				// VERY temporary
				if (nodes.length > 1) {
					this.setCode(full);
					while (nodes.length > 1){
						var el = nodes.pop();
						el.node.orphanize();
					};
				};
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				return this.repair();
			};
			
			tag.prototype.canPrepend = function (text){
				return false;
			};
			
			tag.prototype.canAppend = function (text){
				if (!text.match(/[\n]/)) { return true };
			};
		});
		
		
		// allow inserting additional tabs directly here?
		
		return tag$.defineTag('eof');
	
	})()

/***/ },
/* 56 */
/***/ function(module, exports) {

	(function(){
		
		
		tag$.defineTag('imwarn', 'im', function(tag){
			
			
			
			tag.prototype.message = function(v){ return this.getAttribute('message'); }
			tag.prototype.setMessage = function(v){ this.setAttribute('message',v); return this; };
			
			tag.prototype.build = function (){
				this.log('built error with error',this.object());
				return this;
			};
		});
		
		return tag$.defineTag('imerr', 'imwarn');
	
	})()

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var Router = __webpack_require__(58).Router;
		
		function App(){
			this.setCache({});
			this.setDeps({});
			this.reset();
			this.tick();
			this;
		};
		
		exports.App = App; // export class 
		
		
		App.prototype.req = function(v){ return this._req; }
		App.prototype.setReq = function(v){ this._req = v; return this; };
		
		
		App.prototype.res = function(v){ return this._res; }
		App.prototype.setRes = function(v){ this._res = v; return this; };
		
		
		App.prototype.deps = function(v){ return this._deps; }
		App.prototype.setDeps = function(v){ this._deps = v; return this; };
		
		
		App.prototype.site = function(v){ return this._site; }
		App.prototype.setSite = function(v){ this._site = v; return this; };
		
		
		App.prototype.cache = function(v){ return this._cache; }
		App.prototype.setCache = function(v){ this._cache = v; return this; };
		
		App.prototype.reset = function (){
			this.setCache({});
			return this;
		};
		
		App.prototype.router = function (){
			return this._router || (this._router = new Router(this));
		};
		
		App.prototype.path = function (){
			return  false ? (this.req().path) : (this._path);
		};
		
		App.prototype.hash = function (){
			return '';
		};
		
		App.prototype.hash = function (){
			return  false ? ('') : (document.location.hash.substr(1));
		};
		
		App.prototype.tick = function (){
			if (true) {
				this._path = document.location.pathname;
			};
			
			return this;
		};
		
		App.prototype.schedule = function (){
			Imba.schedule(this);
			return this;
		};
		
		App.prototype.unschedule = function (){
			Imba.unschedule(this);
			return this;
		};
		
		App.prototype.fetchDocument = function (src,cb){
			
			var deps_, $1, $3, $2;
			if (false) {
				console.log('fetch document',src);
				
				var fs = require('fs');
				var path = require('path');
				
				var filepath = ("" + __dirname + "/../docs/" + src).replace(/\/\//g,'/');
				
				var res = this.deps()[src];
				
				if (!res) {
					var body = fs.readFileSync(filepath,'utf-8');
					
					if (src.match(/\.md$/)) {
						res = this.Markdown.render(body);
					} else if (src.match(/\.json$/)) {
						res = JSON.parse(body);
					} else if (src.match(/\.imba$/)) {
						var html = this.Highlighter.highlight(body,{mode: 'full'});
						res = {body: body,html: html};
					};
				};
				
				(deps_ = this.deps())[($1 = src)] || (deps_[$1] = res);
				
				if (this.site()) {
					($3 = this.site().deps())[($2 = src)] || ($3[$2] = res);
				};
				cb && cb(res);
			} else {
				if (DEPS[src]) {
					cb && cb(DEPS[src]);
					return {then: function(v) { return v(res); }}; // fake promise hack
				};
				
				var xhr = new XMLHttpRequest();
				xhr.addEventListener('load',function(res) {
					DEPS[src] = JSON.parse(xhr.responseText);
					return cb && cb(DEPS[src]);
					// XHR = xhr
					// console.log 'response here',xhr:responseText
				});
				xhr.open("GET",src);
				xhr.send();
			};
			
			
			
			return this;
		};
		return App;
	
	})()

/***/ },
/* 58 */
/***/ function(module, exports) {

	(function(){
		// externs;
		
		function Router(app){
			var self = this;
			self._app = app;
			
			if (Imba.isClient()) {
				window.onpopstate = function(e) {
					self.refresh();
					console.log('popstate');
					return Imba.setTimeout(0,function() { return true; });
				};
			};
			self;
		};
		
		exports.Router = Router; // export class 
		
		
		Router.prototype.path = function(v){ return this._path; }
		Router.prototype.setPath = function(v){ this._path = v; return this; };
		
		Router.slug = function (str){
			str = str.replace(/^\s+|\s+$/g,'').toLowerCase(); // trim
			// remove accents, swap  for n, etc
			var from = "/_,:;";
			var to = "aaaaaeeeeiiiioooouuuunc------";
			
			// for (var i=0, l=from.length ; i<l ; i++)
			// 	str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
			
			str = str.replace(/[^a-z0-9 -]/g,''); // remove invalid chars
			str = str.replace(/\s+/g,'-'); // collapse whitespace and replace by -
			str = str.replace(/-+/g,'-'); // collapse dashes
			
			return str;
		};
		
		Router.prototype.refresh = function (){
			return this;
		};
		
		Router.prototype.path = function (){
			return this._app.path();
		};
		
		Router.prototype.hash = function (){
			return this._app.hash();
		};
		
		Router.prototype.ext = function (){
			var path = this.path();
			var m = path.match(/\.([^\/]+)$/);
			return m && m[1] || '';
		};
		
		Router.prototype.go = function (href,state,replace){
			if(state === undefined) state = {};
			if(replace === undefined) replace = false;
			if (href == '/install') {
				// redirects here
				href = '/guides#toc-getting-started-installation';
			};
			
			if (replace) {
				history.replaceState(state,null,href);
			} else {
				history.pushState(state,null,href);
			};
			
			if (!href.match(/\#/)) {
				window.scrollTo(0,0);
			};
			
			return this;
		};
		
		Router.prototype.scoped = function (reg,part){
			var path = this.path() + '#' + this.hash();
			if ((typeof reg=='string'||reg instanceof String)) {
				var nxt = path[reg.length];
				return path.substr(0,reg.length) == reg && (!nxt || nxt == '-' || nxt == '/' || nxt == '#' || nxt == '?' || nxt == '_');
			} else if (reg instanceof RegExp) {
				var m = path.match(reg);
				return part && m ? (m[part]) : (m);
			} else {
				return false;
			};
		};
		
		Router.prototype.match = function (reg,part){
			var path = this.path() + '#' + this.hash();
			
			if ((typeof reg=='string'||reg instanceof String)) {
				return path == reg;
			} else if (reg instanceof RegExp) {
				var m = path.match(reg);
				return part && m ? (m[part]) : (m);
			} else {
				return false;
			};
		};
		return Router;
		
	
	})()

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		__webpack_require__(60);
		__webpack_require__(61);
		
		__webpack_require__(63);
		__webpack_require__(64);
		__webpack_require__(65);
		__webpack_require__(66);
		__webpack_require__(67);
		__webpack_require__(68);
		__webpack_require__(69);
		return __webpack_require__(70);
	
	})()

/***/ },
/* 60 */
/***/ function(module, exports) {

	(function(){
		tag$.extendTag('element', function(tag){
			
			
			tag.prototype.route = function(v){ return this.getAttribute('route'); }
			tag.prototype.setRoute = function(v){ this.setAttribute('route',v); return this; };
			
			tag.prototype.setHtml = function (html){
				this._dom.innerHTML = html;
				return this;
			};
			
			tag.prototype.go = function (route){
				return this;
			};
			
			tag.prototype.router = function (){
				return APP.router();
			};
			
			tag.prototype.reroute = function (){
				this.flag('scoped',this.router().scoped(this.route(),this));
				return this.flag('selected',this.router().match(this.route(),this));
			};
			
			tag.prototype.setTransform = function (value){
				this.css('transform',value);
				return this;
			};
			
			tag.prototype.transform = function (){
				return this.css('transform');
			};
		});
		
		tag$.extendTag('script', function(tag){
			
			tag.prototype.setChildren = function (value){
				this._children = value;
				this.dom().innerHTML = value;
				return this;
			};
		});
		
		tag$.extendTag('canvas', function(tag){
			
			tag.prototype.dpr = function (){
				return this._dpr || (this._dpr = window.devicePixelRatio || 1);
			};
			
			tag.prototype.setWidth = function (width){
				if (width != this._width) {
					this.dom().width = width * this.dpr();
					this.css({width: width});
					this._width = width;
				};
				return this;
			};
			
			tag.prototype.setHeight = function (height){
				if (height != this._height) {
					this.dom().height = height * this.dpr();
					this.css({height: height});
					this._height = height;
				};
				return this;
			};
		});
		
		return tag$.extendTag('a', function(tag){
			
			tag.prototype.route = function (){
				return this._route || this.href();
			};
			
			tag.prototype.ontap = function (e){
				if (e.event().metaKey || e.event().altKey) {
					e._responder = null;
					return e.halt();
				};
				
				if (this.href()[0] == '#' || this.href()[0] == '/') {
					e.cancel().halt();
					this.router().go(this.href(),{});
					Imba.Events.trigger('route',this);
				} else {
					return e.halt();
				};
				return this;
			};
			
			tag.prototype.render = function (){
				return this.reroute();
			};
		});
	
	})()

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// for markdown rendering
		tag$.defineTag('md', function(tag){
			
			
			tag.prototype.__src = {watch: 'reload',name: 'src'};
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){
				var a = this.src();
				if(v != a) { this.setAttribute('src',v); }
				if(v != a) { this.reload && this.reload(v,a,this.__src) }
				return this;
			};
			
			tag.prototype.__html = {watch: 'htmlDidSet',name: 'html'};
			tag.prototype.html = function(v){ return this._html; }
			tag.prototype.setHtml = function(v){
				var a = this.html();
				if(v != a) { this._html = v; }
				if(v != a) { this.htmlDidSet && this.htmlDidSet(v,a,this.__html) }
				return this;
			};
			
			
			tag.prototype.doc = function(v){ return this._doc; }
			tag.prototype.setDoc = function(v){ this._doc = v; return this; };
			
			tag.prototype.body = function (){
				return this;
			};
			
			tag.prototype.setup = function (){
				return this;
			};
			
			tag.prototype.ghsrc = function (){
				return ("https://github.com/somebee/imba.io/blob/master/docs" + this.src());
			};
			
			tag.prototype.htmlDidSet = function (html){
				this.body().dom().innerHTML = html;
				this.setup();
				return this;
			};
			
			tag.prototype.render = function (){
				var self = this;
				if (false) {
					APP.fetchDocument(self.src() + '.md',function(doc) {
						return self.assemble(doc);
					});
				} else if (self._snippets) {
					for (var i = 0, ary = iter$(self._snippets), len = ary.length; i < len; i++) {
						ary[i].end(); // simulate real rendering here?
					};
				};
				return self;
			};
			
			// not on frontpage?!
			tag.prototype.assemble = function (doc){
				return this.flag('md').setHtml(doc.body).synced();
			};
			
			tag.prototype.build = function (){
				tag.__super__.build.apply(this,arguments);
				if (Imba.isClient() && this.src()) { return this.reload() };
			};
			
			tag.prototype.awaken = function (){
				// log "awakened md from client(!)"
				this._snippets = q$('._snippet',this).toArray();
				return this;
			};
			
			tag.prototype.preload = function (html){
				this._dom.innerHTML = html;
				this._snippets = q$('._snippet',this).toArray();
				return this;
			};
			
			tag.prototype.reload = function (){
				var self = this;
				if (Imba.isClient()) {
					// console.log 'reloading markdown'
					self._snippets = [];
					APP.fetchDocument(self.src() + '.md',function(res) {
						// console.log 'returned from markdown here?!',res
						self.assemble((self.setDoc(res),res));
						self._snippets = q$('._snippet',self).toArray();
						self.parent().dom().scrollTop = 0;
						return self;
					});
				};
				return self;
			};
		});
		
		// define renderer
		var marked = __webpack_require__(62);
		var mdr = new (marked.Renderer)();
		
		mdr.heading = function (text,lvl){
			return ("<h" + lvl + ">" + text + "</h" + lvl + ">");
		};
		
		return tag$.defineTag('marked', function(tag){
			
			tag.prototype.renderer = function (){
				return this;
			};
			
			tag.prototype.setText = function (text){
				return this.setContent(text,0);
			};
			
			tag.prototype.setContent = function (val,typ){
				if (val != this._content) {
					this._content = val;
					this.dom().innerHTML = marked(val,{renderer: mdr});
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * marked - a markdown parser
	 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/chjj/marked
	 */
	
	;(function() {
	
	/**
	 * Block-Level Grammar
	 */
	
	var block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: noop,
	  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
	  nptable: noop,
	  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
	  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
	  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
	  table: noop,
	  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
	  text: /^[^\n]+/
	};
	
	block.bullet = /(?:[*+-]|\d+\.)/;
	block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
	block.item = replace(block.item, 'gm')
	  (/bull/g, block.bullet)
	  ();
	
	block.list = replace(block.list)
	  (/bull/g, block.bullet)
	  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
	  ('def', '\\n+(?=' + block.def.source + ')')
	  ();
	
	block.blockquote = replace(block.blockquote)
	  ('def', block.def)
	  ();
	
	block._tag = '(?!(?:'
	  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
	  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
	  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
	
	block.html = replace(block.html)
	  ('comment', /<!--[\s\S]*?-->/)
	  ('closed', /<(tag)[\s\S]+?<\/\1>/)
	  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
	  (/tag/g, block._tag)
	  ();
	
	block.paragraph = replace(block.paragraph)
	  ('hr', block.hr)
	  ('heading', block.heading)
	  ('lheading', block.lheading)
	  ('blockquote', block.blockquote)
	  ('tag', '<' + block._tag)
	  ('def', block.def)
	  ();
	
	/**
	 * Normal Block Grammar
	 */
	
	block.normal = merge({}, block);
	
	/**
	 * GFM Block Grammar
	 */
	
	block.gfm = merge({}, block.normal, {
	  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
	  paragraph: /^/,
	  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
	});
	
	block.gfm.paragraph = replace(block.paragraph)
	  ('(?!', '(?!'
	    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
	    + block.list.source.replace('\\1', '\\3') + '|')
	  ();
	
	/**
	 * GFM + Tables Block Grammar
	 */
	
	block.tables = merge({}, block.gfm, {
	  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
	  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
	});
	
	/**
	 * Block Lexer
	 */
	
	function Lexer(options) {
	  this.tokens = [];
	  this.tokens.links = {};
	  this.options = options || marked.defaults;
	  this.rules = block.normal;
	
	  if (this.options.gfm) {
	    if (this.options.tables) {
	      this.rules = block.tables;
	    } else {
	      this.rules = block.gfm;
	    }
	  }
	}
	
	/**
	 * Expose Block Rules
	 */
	
	Lexer.rules = block;
	
	/**
	 * Static Lex Method
	 */
	
	Lexer.lex = function(src, options) {
	  var lexer = new Lexer(options);
	  return lexer.lex(src);
	};
	
	/**
	 * Preprocessing
	 */
	
	Lexer.prototype.lex = function(src) {
	  src = src
	    .replace(/\r\n|\r/g, '\n')
	    .replace(/\t/g, '    ')
	    .replace(/\u00a0/g, ' ')
	    .replace(/\u2424/g, '\n');
	
	  return this.token(src, true);
	};
	
	/**
	 * Lexing
	 */
	
	Lexer.prototype.token = function(src, top, bq) {
	  var src = src.replace(/^ +$/gm, '')
	    , next
	    , loose
	    , cap
	    , bull
	    , b
	    , item
	    , space
	    , i
	    , l;
	
	  while (src) {
	    // newline
	    if (cap = this.rules.newline.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[0].length > 1) {
	        this.tokens.push({
	          type: 'space'
	        });
	      }
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      cap = cap[0].replace(/^ {4}/gm, '');
	      this.tokens.push({
	        type: 'code',
	        text: !this.options.pedantic
	          ? cap.replace(/\n+$/, '')
	          : cap
	      });
	      continue;
	    }
	
	    // fences (gfm)
	    if (cap = this.rules.fences.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'code',
	        lang: cap[2],
	        text: cap[3] || ''
	      });
	      continue;
	    }
	
	    // heading
	    if (cap = this.rules.heading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[1].length,
	        text: cap[2]
	      });
	      continue;
	    }
	
	    // table no leading pipe (gfm)
	    if (top && (cap = this.rules.nptable.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i].split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // lheading
	    if (cap = this.rules.lheading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[2] === '=' ? 1 : 2,
	        text: cap[1]
	      });
	      continue;
	    }
	
	    // hr
	    if (cap = this.rules.hr.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'hr'
	      });
	      continue;
	    }
	
	    // blockquote
	    if (cap = this.rules.blockquote.exec(src)) {
	      src = src.substring(cap[0].length);
	
	      this.tokens.push({
	        type: 'blockquote_start'
	      });
	
	      cap = cap[0].replace(/^ *> ?/gm, '');
	
	      // Pass `top` to keep the current
	      // "toplevel" state. This is exactly
	      // how markdown.pl works.
	      this.token(cap, top, true);
	
	      this.tokens.push({
	        type: 'blockquote_end'
	      });
	
	      continue;
	    }
	
	    // list
	    if (cap = this.rules.list.exec(src)) {
	      src = src.substring(cap[0].length);
	      bull = cap[2];
	
	      this.tokens.push({
	        type: 'list_start',
	        ordered: bull.length > 1
	      });
	
	      // Get each top-level item.
	      cap = cap[0].match(this.rules.item);
	
	      next = false;
	      l = cap.length;
	      i = 0;
	
	      for (; i < l; i++) {
	        item = cap[i];
	
	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+\.) +/, '');
	
	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }
	
	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (this.options.smartLists && i !== l - 1) {
	          b = block.bullet.exec(cap[i + 1])[0];
	          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
	            src = cap.slice(i + 1).join('\n') + src;
	            i = l - 1;
	          }
	        }
	
	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) loose = next;
	        }
	
	        this.tokens.push({
	          type: loose
	            ? 'loose_item_start'
	            : 'list_item_start'
	        });
	
	        // Recurse.
	        this.token(item, false, bq);
	
	        this.tokens.push({
	          type: 'list_item_end'
	        });
	      }
	
	      this.tokens.push({
	        type: 'list_end'
	      });
	
	      continue;
	    }
	
	    // html
	    if (cap = this.rules.html.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: this.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        pre: !this.options.sanitizer
	          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	        text: cap[0]
	      });
	      continue;
	    }
	
	    // def
	    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.links[cap[1].toLowerCase()] = {
	        href: cap[2],
	        title: cap[3]
	      };
	      continue;
	    }
	
	    // table (gfm)
	    if (top && (cap = this.rules.table.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i]
	          .replace(/^ *\| *| *\| *$/g, '')
	          .split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // top-level paragraph
	    if (top && (cap = this.rules.paragraph.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'paragraph',
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      });
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      // Top-level should never reach here.
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'text',
	        text: cap[0]
	      });
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return this.tokens;
	};
	
	/**
	 * Inline-Level Grammar
	 */
	
	var inline = {
	  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
	  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
	  url: noop,
	  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
	  link: /^!?\[(inside)\]\(href\)/,
	  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
	  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
	  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
	  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
	  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
	  br: /^ {2,}\n(?!\s*$)/,
	  del: noop,
	  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
	};
	
	inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
	inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
	
	inline.link = replace(inline.link)
	  ('inside', inline._inside)
	  ('href', inline._href)
	  ();
	
	inline.reflink = replace(inline.reflink)
	  ('inside', inline._inside)
	  ();
	
	/**
	 * Normal Inline Grammar
	 */
	
	inline.normal = merge({}, inline);
	
	/**
	 * Pedantic Inline Grammar
	 */
	
	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
	});
	
	/**
	 * GFM Inline Grammar
	 */
	
	inline.gfm = merge({}, inline.normal, {
	  escape: replace(inline.escape)('])', '~|])')(),
	  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
	  del: /^~~(?=\S)([\s\S]*?\S)~~/,
	  text: replace(inline.text)
	    (']|', '~]|')
	    ('|', '|https?://|')
	    ()
	});
	
	/**
	 * GFM + Line Breaks Inline Grammar
	 */
	
	inline.breaks = merge({}, inline.gfm, {
	  br: replace(inline.br)('{2,}', '*')(),
	  text: replace(inline.gfm.text)('{2,}', '*')()
	});
	
	/**
	 * Inline Lexer & Compiler
	 */
	
	function InlineLexer(links, options) {
	  this.options = options || marked.defaults;
	  this.links = links;
	  this.rules = inline.normal;
	  this.renderer = this.options.renderer || new Renderer;
	  this.renderer.options = this.options;
	
	  if (!this.links) {
	    throw new
	      Error('Tokens array requires a `links` property.');
	  }
	
	  if (this.options.gfm) {
	    if (this.options.breaks) {
	      this.rules = inline.breaks;
	    } else {
	      this.rules = inline.gfm;
	    }
	  } else if (this.options.pedantic) {
	    this.rules = inline.pedantic;
	  }
	}
	
	/**
	 * Expose Inline Rules
	 */
	
	InlineLexer.rules = inline;
	
	/**
	 * Static Lexing/Compiling Method
	 */
	
	InlineLexer.output = function(src, links, options) {
	  var inline = new InlineLexer(links, options);
	  return inline.output(src);
	};
	
	/**
	 * Lexing/Compiling
	 */
	
	InlineLexer.prototype.output = function(src) {
	  var out = ''
	    , link
	    , text
	    , href
	    , cap;
	
	  while (src) {
	    // escape
	    if (cap = this.rules.escape.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += cap[1];
	      continue;
	    }
	
	    // autolink
	    if (cap = this.rules.autolink.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = cap[1].charAt(6) === ':'
	          ? this.mangle(cap[1].substring(7))
	          : this.mangle(cap[1]);
	        href = this.mangle('mailto:') + text;
	      } else {
	        text = escape(cap[1]);
	        href = text;
	      }
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // url (gfm)
	    if (!this.inLink && (cap = this.rules.url.exec(src))) {
	      src = src.substring(cap[0].length);
	      text = escape(cap[1]);
	      href = text;
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // tag
	    if (cap = this.rules.tag.exec(src)) {
	      if (!this.inLink && /^<a /i.test(cap[0])) {
	        this.inLink = true;
	      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	        this.inLink = false;
	      }
	      src = src.substring(cap[0].length);
	      out += this.options.sanitize
	        ? this.options.sanitizer
	          ? this.options.sanitizer(cap[0])
	          : escape(cap[0])
	        : cap[0]
	      continue;
	    }
	
	    // link
	    if (cap = this.rules.link.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.inLink = true;
	      out += this.outputLink(cap, {
	        href: cap[2],
	        title: cap[3]
	      });
	      this.inLink = false;
	      continue;
	    }
	
	    // reflink, nolink
	    if ((cap = this.rules.reflink.exec(src))
	        || (cap = this.rules.nolink.exec(src))) {
	      src = src.substring(cap[0].length);
	      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = this.links[link.toLowerCase()];
	      if (!link || !link.href) {
	        out += cap[0].charAt(0);
	        src = cap[0].substring(1) + src;
	        continue;
	      }
	      this.inLink = true;
	      out += this.outputLink(cap, link);
	      this.inLink = false;
	      continue;
	    }
	
	    // strong
	    if (cap = this.rules.strong.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.strong(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // em
	    if (cap = this.rules.em.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.em(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.codespan(escape(cap[2], true));
	      continue;
	    }
	
	    // br
	    if (cap = this.rules.br.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.br();
	      continue;
	    }
	
	    // del (gfm)
	    if (cap = this.rules.del.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.del(this.output(cap[1]));
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.text(escape(this.smartypants(cap[0])));
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return out;
	};
	
	/**
	 * Compile Link
	 */
	
	InlineLexer.prototype.outputLink = function(cap, link) {
	  var href = escape(link.href)
	    , title = link.title ? escape(link.title) : null;
	
	  return cap[0].charAt(0) !== '!'
	    ? this.renderer.link(href, title, this.output(cap[1]))
	    : this.renderer.image(href, title, escape(cap[1]));
	};
	
	/**
	 * Smartypants Transformations
	 */
	
	InlineLexer.prototype.smartypants = function(text) {
	  if (!this.options.smartypants) return text;
	  return text
	    // em-dashes
	    .replace(/---/g, '\u2014')
	    // en-dashes
	    .replace(/--/g, '\u2013')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	};
	
	/**
	 * Mangle Links
	 */
	
	InlineLexer.prototype.mangle = function(text) {
	  if (!this.options.mangle) return text;
	  var out = ''
	    , l = text.length
	    , i = 0
	    , ch;
	
	  for (; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }
	
	  return out;
	};
	
	/**
	 * Renderer
	 */
	
	function Renderer(options) {
	  this.options = options || {};
	}
	
	Renderer.prototype.code = function(code, lang, escaped) {
	  if (this.options.highlight) {
	    var out = this.options.highlight(code, lang);
	    if (out != null && out !== code) {
	      escaped = true;
	      code = out;
	    }
	  }
	
	  if (!lang) {
	    return '<pre><code>'
	      + (escaped ? code : escape(code, true))
	      + '\n</code></pre>';
	  }
	
	  return '<pre><code class="'
	    + this.options.langPrefix
	    + escape(lang, true)
	    + '">'
	    + (escaped ? code : escape(code, true))
	    + '\n</code></pre>\n';
	};
	
	Renderer.prototype.blockquote = function(quote) {
	  return '<blockquote>\n' + quote + '</blockquote>\n';
	};
	
	Renderer.prototype.html = function(html) {
	  return html;
	};
	
	Renderer.prototype.heading = function(text, level, raw) {
	  return '<h'
	    + level
	    + ' id="'
	    + this.options.headerPrefix
	    + raw.toLowerCase().replace(/[^\w]+/g, '-')
	    + '">'
	    + text
	    + '</h'
	    + level
	    + '>\n';
	};
	
	Renderer.prototype.hr = function() {
	  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	};
	
	Renderer.prototype.list = function(body, ordered) {
	  var type = ordered ? 'ol' : 'ul';
	  return '<' + type + '>\n' + body + '</' + type + '>\n';
	};
	
	Renderer.prototype.listitem = function(text) {
	  return '<li>' + text + '</li>\n';
	};
	
	Renderer.prototype.paragraph = function(text) {
	  return '<p>' + text + '</p>\n';
	};
	
	Renderer.prototype.table = function(header, body) {
	  return '<table>\n'
	    + '<thead>\n'
	    + header
	    + '</thead>\n'
	    + '<tbody>\n'
	    + body
	    + '</tbody>\n'
	    + '</table>\n';
	};
	
	Renderer.prototype.tablerow = function(content) {
	  return '<tr>\n' + content + '</tr>\n';
	};
	
	Renderer.prototype.tablecell = function(content, flags) {
	  var type = flags.header ? 'th' : 'td';
	  var tag = flags.align
	    ? '<' + type + ' style="text-align:' + flags.align + '">'
	    : '<' + type + '>';
	  return tag + content + '</' + type + '>\n';
	};
	
	// span level renderer
	Renderer.prototype.strong = function(text) {
	  return '<strong>' + text + '</strong>';
	};
	
	Renderer.prototype.em = function(text) {
	  return '<em>' + text + '</em>';
	};
	
	Renderer.prototype.codespan = function(text) {
	  return '<code>' + text + '</code>';
	};
	
	Renderer.prototype.br = function() {
	  return this.options.xhtml ? '<br/>' : '<br>';
	};
	
	Renderer.prototype.del = function(text) {
	  return '<del>' + text + '</del>';
	};
	
	Renderer.prototype.link = function(href, title, text) {
	  if (this.options.sanitize) {
	    try {
	      var prot = decodeURIComponent(unescape(href))
	        .replace(/[^\w:]/g, '')
	        .toLowerCase();
	    } catch (e) {
	      return '';
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
	      return '';
	    }
	  }
	  var out = '<a href="' + href + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += '>' + text + '</a>';
	  return out;
	};
	
	Renderer.prototype.image = function(href, title, text) {
	  var out = '<img src="' + href + '" alt="' + text + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += this.options.xhtml ? '/>' : '>';
	  return out;
	};
	
	Renderer.prototype.text = function(text) {
	  return text;
	};
	
	/**
	 * Parsing & Compiling
	 */
	
	function Parser(options) {
	  this.tokens = [];
	  this.token = null;
	  this.options = options || marked.defaults;
	  this.options.renderer = this.options.renderer || new Renderer;
	  this.renderer = this.options.renderer;
	  this.renderer.options = this.options;
	}
	
	/**
	 * Static Parse Method
	 */
	
	Parser.parse = function(src, options, renderer) {
	  var parser = new Parser(options, renderer);
	  return parser.parse(src);
	};
	
	/**
	 * Parse Loop
	 */
	
	Parser.prototype.parse = function(src) {
	  this.inline = new InlineLexer(src.links, this.options, this.renderer);
	  this.tokens = src.reverse();
	
	  var out = '';
	  while (this.next()) {
	    out += this.tok();
	  }
	
	  return out;
	};
	
	/**
	 * Next Token
	 */
	
	Parser.prototype.next = function() {
	  return this.token = this.tokens.pop();
	};
	
	/**
	 * Preview Next Token
	 */
	
	Parser.prototype.peek = function() {
	  return this.tokens[this.tokens.length - 1] || 0;
	};
	
	/**
	 * Parse Text Tokens
	 */
	
	Parser.prototype.parseText = function() {
	  var body = this.token.text;
	
	  while (this.peek().type === 'text') {
	    body += '\n' + this.next().text;
	  }
	
	  return this.inline.output(body);
	};
	
	/**
	 * Parse Current Token
	 */
	
	Parser.prototype.tok = function() {
	  switch (this.token.type) {
	    case 'space': {
	      return '';
	    }
	    case 'hr': {
	      return this.renderer.hr();
	    }
	    case 'heading': {
	      return this.renderer.heading(
	        this.inline.output(this.token.text),
	        this.token.depth,
	        this.token.text);
	    }
	    case 'code': {
	      return this.renderer.code(this.token.text,
	        this.token.lang,
	        this.token.escaped);
	    }
	    case 'table': {
	      var header = ''
	        , body = ''
	        , i
	        , row
	        , cell
	        , flags
	        , j;
	
	      // header
	      cell = '';
	      for (i = 0; i < this.token.header.length; i++) {
	        flags = { header: true, align: this.token.align[i] };
	        cell += this.renderer.tablecell(
	          this.inline.output(this.token.header[i]),
	          { header: true, align: this.token.align[i] }
	        );
	      }
	      header += this.renderer.tablerow(cell);
	
	      for (i = 0; i < this.token.cells.length; i++) {
	        row = this.token.cells[i];
	
	        cell = '';
	        for (j = 0; j < row.length; j++) {
	          cell += this.renderer.tablecell(
	            this.inline.output(row[j]),
	            { header: false, align: this.token.align[j] }
	          );
	        }
	
	        body += this.renderer.tablerow(cell);
	      }
	      return this.renderer.table(header, body);
	    }
	    case 'blockquote_start': {
	      var body = '';
	
	      while (this.next().type !== 'blockquote_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.blockquote(body);
	    }
	    case 'list_start': {
	      var body = ''
	        , ordered = this.token.ordered;
	
	      while (this.next().type !== 'list_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.list(body, ordered);
	    }
	    case 'list_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.token.type === 'text'
	          ? this.parseText()
	          : this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'loose_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'html': {
	      var html = !this.token.pre && !this.options.pedantic
	        ? this.inline.output(this.token.text)
	        : this.token.text;
	      return this.renderer.html(html);
	    }
	    case 'paragraph': {
	      return this.renderer.paragraph(this.inline.output(this.token.text));
	    }
	    case 'text': {
	      return this.renderer.paragraph(this.parseText());
	    }
	  }
	};
	
	/**
	 * Helpers
	 */
	
	function escape(html, encode) {
	  return html
	    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#39;');
	}
	
	function unescape(html) {
	  return html.replace(/&([#\w]+);/g, function(_, n) {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}
	
	function replace(regex, opt) {
	  regex = regex.source;
	  opt = opt || '';
	  return function self(name, val) {
	    if (!name) return new RegExp(regex, opt);
	    val = val.source || val;
	    val = val.replace(/(^|[^\[])\^/g, '$1');
	    regex = regex.replace(name, val);
	    return self;
	  };
	}
	
	function noop() {}
	noop.exec = noop;
	
	function merge(obj) {
	  var i = 1
	    , target
	    , key;
	
	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }
	
	  return obj;
	}
	
	
	/**
	 * Marked
	 */
	
	function marked(src, opt, callback) {
	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }
	
	    opt = merge({}, marked.defaults, opt || {});
	
	    var highlight = opt.highlight
	      , tokens
	      , pending
	      , i = 0;
	
	    try {
	      tokens = Lexer.lex(src, opt)
	    } catch (e) {
	      return callback(e);
	    }
	
	    pending = tokens.length;
	
	    var done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }
	
	      var out;
	
	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }
	
	      opt.highlight = highlight;
	
	      return err
	        ? callback(err)
	        : callback(null, out);
	    };
	
	    if (!highlight || highlight.length < 3) {
	      return done();
	    }
	
	    delete opt.highlight;
	
	    if (!pending) return done();
	
	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) return done(err);
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }
	
	    return;
	  }
	  try {
	    if (opt) opt = merge({}, marked.defaults, opt);
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/chjj/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occured:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}
	
	/**
	 * Options
	 */
	
	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  return marked;
	};
	
	marked.defaults = {
	  gfm: true,
	  tables: true,
	  breaks: false,
	  pedantic: false,
	  sanitize: false,
	  sanitizer: null,
	  mangle: true,
	  smartLists: false,
	  silent: false,
	  highlight: null,
	  langPrefix: 'lang-',
	  smartypants: false,
	  headerPrefix: '',
	  renderer: new Renderer,
	  xhtml: false
	};
	
	/**
	 * Expose
	 */
	
	marked.Parser = Parser;
	marked.parser = Parser.parse;
	
	marked.Renderer = Renderer;
	
	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;
	
	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;
	
	marked.parse = marked;
	
	if (true) {
	  module.exports = marked;
	} else if (typeof define === 'function' && define.amd) {
	  define(function() { return marked; });
	} else {
	  this.marked = marked;
	}
	
	}).call(function() {
	  return this || ( true ? window : global);
	}());


/***/ },
/* 63 */
/***/ function(module, exports) {

	(function(){
		tag$.defineTag('site', 'html', function(tag){
			
			
			
			tag.prototype.deps = function(v){ return this._deps; }
			tag.prototype.setDeps = function(v){ this._deps = v; return this; };
			
			tag.prototype.head = function (){
				return tag$.$head().setContent([
					tag$.$title().setText("imba").end(),
					tag$.$meta().setCharset("utf-8").end(),
					tag$.$meta().setName("viewport").setContent("width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1").end(),
					tag$.$meta().setName("Description").setContent("Imba is a rich programming language for the web.").end(),
					tag$.$meta().setName("keywords").setContent("imba javascript language js").end(),
					tag$.$link().setHref('http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600').setRel('stylesheet').setType('text/css').end(),
					tag$.$link().setRel("stylesheet").setHref("/css/site.css").setMedia("screen").end(),
					tag$.$script().setText('DEPS = {};').end(),
					tag$.$script().setSrc("/vendor/ga.js").end()
				],2).end();
			};
			
			tag.prototype.body = function (){
				return tag$.$body().setId('site').setContent([
					tag$.$site_nav().setId('header').flag('awaken').end(),
					tag$.$home().setRoute('/home').end(),
					tag$.$guides().setRoute('/guides').end(),
					tag$.$docs().setRoute('/docs').end(),
					tag$.$blog().setRoute('/blog').end()
				],2).end();
			};
			
			tag.prototype.scripts = function (){
				var self = this, t0;
				return tag$.$div().flag('scripts').setContent([
					(function(t0) {
						for (var o = self.deps(), i = 0, keys = Object.keys(o), l = keys.length, res = []; i < l; i++){
							res.push(tag$.$script().setType("text/javascript").setSrc((keys[i] + '.dep')).end());
						};
						return res;
					})(t0),
					tag$.$script().setSrc("/vendor/hl.js").end(),
					tag$.$script().setSrc("/client.js").end()
				],0).end();
			};
			
			tag.prototype.render = function (){
				// dirty workarounds
				APP.setSite(this);
				this.setDeps({});
				APP.fetchDocument('/guides.md');
				var body = this.body();
				body.append(this.scripts());
				
				this.flag('light').setChildren([
					this.head(),
					body
				],1).synced();
				APP.setSite(null);
				return this;
			};
		});
		
		
		return tag$.defineTag('site-nav', function(tag){
			
			tag.prototype.toggleMenu = function (){
				return q$$('body').toggleFlag('menu');
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, t5, t6, t7;
				return this.setChildren(
					(t0 = this.$a=this.$a || tag$.$nav().flag('content')).setContent([
						(t1 = t0.$$a=t0.$$a || tag$.$a().flag('menu').setHandler('tap','toggleMenu',this)).setContent((t1.$$a = t1.$$a || tag$.$b()).end(),2).end(),
						(t2 = t0.$$b=t0.$$b || tag$.$a().flag('tab').flag('logo').setHref('/home')).setContent((t2.$$a = t2.$$a || tag$.$i()).setText('imba').end(),2).end(),
						(t0.$$c = t0.$$c || tag$.$span().flag('greedy')).end(),
						(t3 = t0.$$d=t0.$$d || tag$.$a().flag('tab').flag('home').setHref('/home')).setContent((t3.$$a = t3.$$a || tag$.$i()).setText('home').end(),2).end(),
						(t4 = t0.$$e=t0.$$e || tag$.$a().flag('tab').flag('guides').setHref('/guides')).setContent((t4.$$a = t4.$$a || tag$.$i()).setText('guides').end(),2).end(),
						(t5 = t0.$$f=t0.$$f || tag$.$a().flag('tab').flag('docs').setHref('/docs')).setContent((t5.$$a = t5.$$a || tag$.$i()).setText('docs').end(),2).end(),
						(t6 = t0.$$g=t0.$$g || tag$.$a().flag('tab').flag('blog').setHref('/blog')).setContent((t6.$$a = t6.$$a || tag$.$i()).setText('blog').end(),2).end(),
						
						(t7 = t0.$$h=t0.$$h || tag$.$a().flag('github').setHref('https://github.com/somebee/imba')).setContent((t7.$$a = t7.$$a || tag$.$i()).setText('github').end(),2).end()
					],2).end()
				,2).synced();
			};
			
			tag.prototype.awaken = function (){
				return this.schedule({fps: 0});
			};
		});
	
	})()

/***/ },
/* 64 */
/***/ function(module, exports) {

	(function(){
		
		
		tag$.defineTag('navmenu', function(tag){
			
			tag.prototype.onroute = function (e){
				console.log('navmenu onroute',e);
				document.body.classList.remove('menu');
				return this;
			};
		});
		
		tag$.defineTag('nav-list');
		
		tag$.defineTag('nav-link', function(tag){
			
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren((t0 = this.$a=this.$a || tag$.$a()).setHref(this.href()).setContent(this._content,3).end(),2).synced();
			};
		});
		
		return tag$.defineTag('toc', function(tag){
			
			tag.prototype.toggle = function (){
				return this.toggleFlag('collapsed');
			};
		});
	
	})()

/***/ },
/* 65 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('page', function(tag){
			tag.prototype.body = function (){
				return (this._body = this._body || tag$.$div().setRef('body',this)).setText("Content here").end();
			};
			
			tag.prototype.nav = function (){
				return (this._nav = this._nav || tag$.$div().setRef('nav',this)).setText("Navigation here").end();
			};
			
			tag.prototype.assemble = function (){
				return this.setChildren([
					this.nav(),
					this.body()
				],1).synced();
			};
			
			tag.prototype.ready = function (){
				return true;
			};
			
			tag.prototype.render = function (){
				// log 'render page',route
				var scoped = this.router().scoped(this.route(),this);
				this.flag('scoped',scoped);
				this.flag('selected',this.router().match(this.route(),this));
				
				if (!(scoped && this.ready())) { return this };
				return this.assemble();
			};
			
			tag.prototype.awaken = function (){
				return this.schedule({fps: 1});
			};
		});
	
	})()

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function shuffle(array){
			var counter = array.length,temp,index;
			
			// While there are elements in the array
			while (counter > 0){
				// Pick a random index
				index = Math.floor(Math.random() * counter);
				counter--; // Decrease counter by 1
				
				// And swap the last element with it
				temp = array[counter];
				array[counter] = array[index];
				array[index] = temp;
			};
			
			return array;
		};
		
		tag$.defineTag('pattern', function(tag){
			
			tag.prototype.build = function (){
				if (false) { return this };
				
				var parts = {tags: [],keywords: [],methods: []};
				var items = [];
				var lines = [];
				
				for (var o = Imba.Tag.prototype, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
					k = keys[i];items.push(("<em>" + k + "</em>"));
					parts.methods.push(("<em>" + k + "</em>"));
				};
				
				for (var j = 0, ary = iter$(HTML_TAGS), len_ = ary.length, k1; j < len_; j++) {
					// for own k,v of Imba.TAGS
					// if v and v:prototype isa Imba.Tag
					k1 = ary[j];
					items.push(("<u>&lt;" + k1 + "&gt;</u>"));
					parts.tags.push(("<u>&lt;" + k1 + "&gt;</u>"));
				};
				
				var words = "def if else elif while until for in of var let class extend export import tag global";
				
				for (var j = 0, ary = iter$(words.split(" ")), len_ = ary.length, k2; j < len_; j++) {
					k2 = ary[j];
					items.push(("<i>" + k2 + "</i>"));
					parts.keywords.push(("<i>" + k2 + "</i>"));
				};
				
				var shuffled = shuffle(items);
				var all = [].concat(shuffled);
				var count = items.length - 1;
				
				for (var len = 12, ln = 0; ln <= len; ln++) {
					var chars = 0;
					lines[ln] = [];
					while (chars < 300){
						var item = (shuffled.pop() || all[Math.floor(count * Math.random())]);
						if (item) {
							chars += item.length;
							lines[ln].push(item);
						} else {
							chars = 400;
						};
					};
				};
				
				this.dom().innerHTML = '<div>' + lines.map(function(ln) {
					return '<div class="line">' + ln.join(" ") + '</div>';
				}).join('') + '</div>';
				return this;
			};
			
			tag.prototype.awaken = function (){
				this.log('awakening pattern!!');
				return this;
				
				for (var i = 0, ary = iter$(q$('.line',this)), len = ary.length; i < len; i++) {
					var z = 20 + i * 10;
					// z = parseInt(-z + Math.random * z * 2)
					ary[i].css('transform',("translateZ(" + z + "px)"));
				};
				return this;
			};
		});
		
		return tag$.defineTag('home', 'page', function(tag){
			
			var todos = {demo: true,autorun: true};
			var clock = {demo: true,autorun: true};
			var reminders = {demo: true,autorun: true};
			var hero = {autorun: true};
			var canvas = {demo: true,autorun: true};
			
			tag.prototype.awaken = function (){
				var snippets = document.querySelectorAll('code[data-src]');
				for (var i = 0, ary = iter$(snippets), len = ary.length, snippet; i < len; i++) {
					snippet = ary[i];
					var src = snippet.getAttribute('data-src');
					// console.log 'fetching snippet for ',src
					DEPS[src] = {html: snippet.innerHTML};
				};
				
				return tag.__super__.awaken.apply(this,arguments);
			};
			
			tag.prototype.nav = function (){
				return null;
			};
			
			tag.prototype.body = function (){
				var t0, t1, t2, t3, t4;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this)).setContent([
					(t1 = t0.$$a=t0.$$a || tag$.$div().setId('hero').flag('dark')).setContent([
						(this._pattern = this._pattern || tag$.$pattern().setRef('pattern',this).flag('awaken')).end(),
						(t1.$$b = t1.$$b || tag$.$example().flag('hero').flag('dark').setSrc('/home/examples/hero.imba')).end()
					],2).end(),
					
					(t2 = this._content=this._content || tag$.$div().setRef('content',this)).setContent([
						(t2.$$a = t2.$$a || tag$.$marked().flag('section').flag('md').flag('welcome').flag('huge').flag('light')).setText("# Ruby, Python and React got together. Nine months later, Imba was born.\n\nImba is a new programming language for the web that compiles to highly \nperformant and readable JavaScript. It has language level support for defining, \nextending, subclassing, instantiating and rendering dom nodes. For a semi-complex \napplication like TodoMVC, it is more than \n[10 times faster than React](http://somebee.github.io/todomvc-render-benchmark/index.html) \nwith less code, and a much smaller library.\n\n---\n\n- ## Imba.inspiration\n  Imba brings the best from Ruby, Python, and React (+ JSX) together in a clean language and runtime.\n\n- ## Imba.interoperability\n  Imba compiles down to clean and readable JavaScript. Use any JS library in Imba and vica-versa.\n\n- ## Imba.performance\n  Build your application views using Imba's native tags for unprecedented performance.\n").end(),
						
						(t2.$$b = t2.$$b || tag$.$example().flag('dark').setHeading("Simple reminders").setSrc('/home/examples/reminders.imba')).end(),
						
						(t2.$$c = t2.$$c || tag$.$marked().flag('section').flag('md')).setText("## Reusable components\n\nA custom tag / component can maintain internal state and control how to render itself.\nWith the performance of DOM reconciliation in Imba, you can use one-way declarative binding,\neven for animations. Write all your views in a straight-forward linear fashion as if you could\nrerender your whole application on **every single** data/state change.").end(),
						
						(t2.$$d = t2.$$d || tag$.$example().flag('dark').setHeading("World clock").setSrc('/home/examples/clock.imba')).end(),
						
						(t2.$$e = t2.$$e || tag$.$marked().flag('section').flag('md')).setText("## Extend native tags\n\nIn addition to defining custom tags, you can also extend native tags, or inherit from them.\nBinding to dom events is as simple as defining methods on your tags; all events will be\nefficiently delegated and handled by Imba. Let's define a simple sketchpad...").end(),
						
						(t2.$$f = t2.$$f || tag$.$example().flag('dark').setHeading("Custom canvas").setSrc('/home/examples/canvas.imba')).end(),
						
						(t3 = t2.$$g=t2.$$g || tag$.$footer()).setContent(
							(t4 = t3.$$a=t3.$$a || tag$.$nav()).setContent([
								(t4.$$a = t4.$$a || tag$.$a().flag('button').flag('huge').flag('main').setHref('/install')).setText("Install").end(),
								(t4.$$b = t4.$$b || tag$.$a().flag('button').flag('huge').setHref('/guides')).setText("Learn more").end()
							],2).end()
						,2).end()
					],2).end()
				],2).end();
			};
			
			// def awaken
			// 	# awaken the snippets
			// 	schedule
			// 	for el in %(snippet)
			// 		el
			// 	self
			
			// def tick
			// 	log 'home.tick'
			// 	self
			
			// def assemble
			// 	return self if Imba.isClient
			// 	super
			// 	# flag('scoped',router.scoped(route,self))
			// 	# flag('selected',router.match(route,self))
		});
	
	})()

/***/ },
/* 67 */
/***/ function(module, exports) {

	(function(){
		
		tag$.defineTag('blog', 'page', function(tag){
			
			tag.prototype.nav = function (){
				var t0, t1;
				return (t0 = this._nav=this._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent(
						(t1.$$a = t1.$$a || tag$.$h1()).setText("No items?").end()
					,2).end()
				,2).end();
			};
			tag.prototype.body = function (){
				return (this._body = this._body || tag$.$div().setRef('body',this)).setText(
					"No posts"
				).end();
			};
		});
		
		return tag$.defineTag('blogpost', 'article', function(tag){
			
			tag.prototype.render = function (){
				var t0, t1, t2;
				return this.setChildren([
					(t0 = this.$a=this.$a || tag$.$header()).setContent((t1 = t0.$$a=t0.$$a || tag$.$h1()).setContent(this.object().title,3).end(),2).end(),
					(t2 = this.$b=this.$b || tag$.$section().flag('md')).setContent(this.object().body,3).end()
				],2).synced();
			};
		});
	
	})()

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		__webpack_require__(65);
		
		function Guide(path){
			this._path = path;
			this._ready = false;
			this.fetch();
			this;
		};
		
		var cache = {};
		
		Guide.get = function (path){
			var $1;
			var cache = APP.cache();
			return cache[($1 = 'guide-' + path)] || (cache[$1] = new this(path));
		};
		
		
		
		Guide.prototype.path = function(v){ return this._path; }
		Guide.prototype.setPath = function(v){ this._path = v; return this; };
		
		Guide.prototype.ready = function (){
			return this._ready;
		};
		
		Guide.prototype.fetch = function (){
			var self = this;
			if (false) {
				// console.log 'fetch Guide on server',path
				return APP.fetchDocument(self._path + '.md',function(res) {
					// console.log 'fetch Guide on server done',path
					return self.load(res);
				});
			};
			
			return self._promise || (self._promise = APP.fetchDocument(self._path + '.md',function(res) {
				return self.load(res);
			}));
		};
		
		Guide.prototype.load = function (doc){
			this._object = doc;
			this._meta = doc.meta || {};
			this._ready = true;
			return this;
		};
		
		Guide.prototype.title = function (){
			return this._object.title || 'path';
		};
		
		Guide.prototype.toc = function (){
			return this._object && this._object.toc[0];
		};
		
		Guide.prototype.body = function (){
			return this._object && this._object.body;
		};
		
		
		tag$.defineTag('guide-toc', 'toc', function(tag){
			
			
			
			tag.prototype.toc = function(v){ return this._toc; }
			tag.prototype.setToc = function(v){ this._toc = v; return this; };
			
			
			tag.prototype.level = function(v){ return this.getAttribute('level'); }
			tag.prototype.setLevel = function(v){ this.setAttribute('level',v); return this; };
			
			
			tag.prototype.route = function(v){ return this.getAttribute('route'); }
			tag.prototype.setRoute = function(v){ this.setAttribute('route',v); return this; };
			
			tag.prototype.toc = function (){
				return this._toc || this.object().toc();
			};
			
			tag.prototype.route = function (){
				return ("" + (this.object().path()) + "#" + (this.toc().slug));
			};
			
			tag.prototype.toggle = function (){
				return this.toggleFlag('collapsed');
			};
			
			tag.prototype.render = function (){
				var t0, t1, self = this, t2, t3;
				if (!this.object().ready()) { return this };
				
				this.reroute();
				
				return this.flag('entry').setLevel((this.toc().level)).setChildren([
					this.toc().children.length && this.toc().level < 2 ? (Imba.static([
						(t0 = this.$a=this.$a || tag$.$div().flag('header').setHandler('tap','toggle',this)).setContent(
							(t1 = t0.$$a=t0.$$a || tag$.$a()).setHref(this.route()).setContent(this.toc().title,3).end()
						,2).end(),
						(t2 = self.$b=self.$b || tag$.$div().flag('content')).setContent(
							(function(t2) {
								for (var i = 0, ary = iter$(self.toc().children), len = ary.length, res = []; i < len; i++) {
									res.push((t2['$$a' + i] = t2['$$a' + i] || tag$.$guide_toc()).setToc(ary[i]).setObject(self.object()).end());
								};
								return res;
							})(t2)
						,3).end()
					],2)) : (
						(t3 = self.$c=self.$c || tag$.$a()).setHref(self.route()).setContent(self.toc().title,3).end()
					)
				],1).synced();
			};
		});
		
		
		tag$.defineTag('guide', function(tag){
			
			tag.prototype.render = function (){
				var object_;
				if (!(object_ = this.object()) && object_.ready  &&  object_.ready()) { return this };
				return this.flag('md').setBody((this.object().body())).synced();
			};
			
			tag.prototype.setBody = function (body){
				if (body != this._body) {
					this._body = body;
					this.dom().innerHTML = body;
					if (Imba.isClient()) this.reawaken();
				};
				return this;
			};
			
			tag.prototype.reawaken = function (){
				for (var i = 0, ary = iter$(q$('._snippet',this)), len = ary.length; i < len; i++) {
					ary[i];
				};
				return this;
			};
		});
		
		
		return tag$.defineTag('guides', 'page', function(tag){
			
			tag.prototype.nav = function (){
				var t0, t1;
				return (t0 = this._nav=this._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent([
						(t1.$$a = t1.$$a || tag$.$guide_toc()).setObject(Guide.get('/guides')).end(),
						(t1.$$b = t1.$$b || tag$.$guide_toc()).setObject(Guide.get('/guides/language')).end()
					// <guide-toc[Guide.get('/guides/tips')]>
					],2).end()
				,2).end();
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this).flag('light')).setContent([
					(this.guide()) ? ((t0.$$a = t0.$$a || tag$.$guide()).setObject(this.guide()).end()) : void(0)
				// <guide@doc.md.l src="{router.path}">
				],1).end();
			};
			
			tag.prototype.onroute = function (e){
				var self = this;
				self.log('onroute guides',self.router().hash());
				e.halt();
				
				if (self.router().hash()) {
					setTimeout(function() {
						var el;
						if (el = self.first('#' + self.router().hash())) {
							self.log('found element?!?',el);
							el.dom().scrollIntoView(true);
							return self._scrollFreeze = window.scrollY;
						};
					},0);
				};
				return self;
			};
			
			tag.prototype.guide = function (){
				if (this.router().scoped('/guides')) {
					return Guide.get(this.router().path());
				};
			};
			
			
			tag.prototype.awaken = function (){
				var self = this;
				if (Imba.isClient()) {
					// @doc = %%(guide)
					self.schedule({fps: 1});
					window.addEventListener('scroll',function() {
						// console.log 'check scrolling'
						return self.scrolled();
					});
				};
				return self;
			};
			
			tag.prototype.scrolled = function (){
				if (!this.hasFlag('scoped')) { return };
				
				var items = q$('[id]',this);
				var match;
				
				// should probably cache these periodically
				var scrollTop = window.scrollY;
				var wh = window.innerHeight;
				var dh = document.body.scrollHeight;
				
				if (this._scrollFreeze >= 0) {
					var diff = Math.abs(scrollTop - this._scrollFreeze);
					if (diff < 50) { return this };
					this._scrollFreeze = -1;
				};
				
				var scrollBottom = dh - (scrollTop + wh);
				
				// console.log scrollTop,wh,dh,scrollBottom
				
				if (scrollBottom == 0) {
					match = items.last();
				} else {
					for (var i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
						item = ary[i];
						var t = (item.dom().offsetTop + 30 + 60); // hack
						var dist = scrollTop - t;
						// console.log "{item.id} {t} {dist}"
						
						if (dist < 0) {
							match = item;break;
						};
					};
				};
				
				if (match) {
					// console.log "match is {match.id}"
					if (this._hash != match.id()) {
						this._hash = match.id();
						this.router().go('#' + this._hash,{},true);
						this.render();
					};
				};
				return this;
			};
			
			tag.prototype.tick = function (){
				this.render();
				return this;
			};
		});
	
	})()

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function pathToAnchor(path){
			return 'api-' + path.replace(/\./g,'_').replace(/\#/g,'__');
		};
		
		tag$.defineTag('api-desc', function(tag){
			
			tag.prototype.setHtml = function (html){
				if (html != this._html) {
					this.dom().innerHTML = this._html = html;
				};
				return this;
			};
		});
		
		tag$.defineTag('api-ref', function(tag){
			
			tag.prototype.render = function (){
				return this.synced();
			};
		});
		
		tag$.defineTag('api-item');
		
		tag$.defineTag('api-path', 'span', function(tag){
			
			tag.prototype.build = function (){
				var object_;
				var items = [];
				if ((typeof (object_ = this.object())=='string'||object_ instanceof String)) {
					this.setHtml(this.object().replace(/\b([\w]+|\.|\#)\b/g,function(m,i) {
						if (i == '.' || i == '#') {
							return ("<i>" + i + "</i>");
						} else if (i[0] == i[0].toUpperCase()) {
							return ("<b class='const'>" + i + "</b>");
						} else {
							return ("<b class='id'>" + i + "</b>");
						};
					}));
				};
				return this;
			};
		});
		
		
		tag$.defineTag('api-link', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren([
					(this.$a = this.$a || tag$.$api_path().flag('value')).setObject(this.object().value).end(),
					(t0 = this.$b=this.$b || tag$.$span().flag('desc')).setContent(this.object().desc,3).end()
				],2).synced();
			};
		});
		
		tag$.defineTag('api-return', 'api-link');
		
		tag$.defineTag('api-class', 'api-item', function(tag){
			
			
			tag.prototype.__object = {watch: 'parse',name: 'object'};
			tag.prototype.object = function(v){ return this._object; }
			tag.prototype.setObject = function(v){
				var a = this.object();
				if(v != a) { this._object = v; }
				if(v != a) { this.parse && this.parse(v,a,this.__object) }
				return this;
			};
			
			tag.prototype.parse = function (){
				for (var i = 0, ary = iter$(this.object()['.']), len = ary.length, m, res = []; i < len; i++) {
					m = ary[i];
					if (!m.desc) { continue; };
					res.push(m);
				};
				this._statics = res;
				for (var i = 0, ary = iter$(this.object()['#']), len = ary.length, m1, res = []; i < len; i++) {
					m1 = ary[i];
					if (!m1.desc) { continue; };
					res.push(m1);
				};
				this._methods = res;
				this._properties = [];
				return this;
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, self = this, t5, t6, t7;
				return this.setChildren([
					(this.$a = this.$a || tag$.$span().flag('toc-anchor')).setId(pathToAnchor(this.object().namepath)).end(),
					(t0 = this.$b=this.$b || tag$.$div().flag('header')).setContent((t1 = t0.$$a=t0.$$a || tag$.$div().flag('title')).setContent((t1.$$a = t1.$$a || tag$.$api_path()).setObject(this.object().namepath).end(),2).end(),2).end(),
					(this.$c = this.$c || tag$.$api_desc()).setHtml(this.object().html).end(),
					(this.object().ctor) ? (
						(t2 = this.$d=this.$d || tag$.$div().flag('content').flag('ctor')).setContent(
							(t2.$$a = t2.$$a || tag$.$api_method()).setPath((this.object().namepath + '.new')).setObject(this.object().ctor).end()
						,2).end()
					) : void(0),
					
					(t3 = self.$e=self.$e || tag$.$div().flag('content')).setContent([
						(this._statics.length > 0) ? (
							(t4 = t3.$$a=t3.$$a || tag$.$div().flag('section')).setContent([
								(t4.$$a = t4.$$a || tag$.$h2().flag('header')).setText('Static Methods').end(),
								(t5 = t4.$$b=t4.$$b || tag$.$div().flag('content').flag('list')).setContent((function(t5) {
									for (var i = 0, ary = iter$(self._statics), len = ary.length, res = []; i < len; i++) {
										res.push((t5['$$a' + i] = t5['$$a' + i] || tag$.$api_method().flag('doc')).setIname(self.object().namepath).setObject(ary[i]).end());
									};
									return res;
								})(t5),3).end()
							],2).end()
						) : void(0),
						
						(self._methods.length > 0) ? (
							(t6 = t3.$$b=t3.$$b || tag$.$div().flag('section')).setContent([
								(t6.$$a = t6.$$a || tag$.$h2().flag('header')).setText('Instance Methods').end(),
								(t7 = t6.$$b=t6.$$b || tag$.$div().flag('content').flag('list')).setContent((function(t7) {
									for (var i = 0, ary = iter$(self._methods), len = ary.length, res = []; i < len; i++) {
										res.push((t7['$$a' + i] = t7['$$a' + i] || tag$.$api_method().flag('doc')).setIname(self.object().iname).setObject(ary[i]).end());
									};
									return res;
								})(t7),3).end()
							],2).end()
						) : void(0)
					],1).end()
				],1).synced();
			};
		});
		
		tag$.defineTag('api-value', function(tag){
			
			tag.prototype.render = function (){
				var object_, $1;
				if (this.object().type) {
					this.flag(this.object().type).setChildren(
						this.object().value
					,3).synced();
				} else if ((typeof (object_ = this.object())=='string'||object_ instanceof String)) {
					this.flag('str').setText(this.object()).synced();
				} else if ((typeof ($1 = this.object())=='number'||$1 instanceof Number)) {
					this.flag('num').setText(this.object()).synced();
				};
				return this;
			};
		});
		
		
		tag$.defineTag('api-param', function(tag){
			
			tag.prototype.type = function (){
				return this.object().type;
			};
			
			tag.prototype.render = function (){
				var self = this, t0, t1;
				return this.flag(self.type()).setChildren([
					self.type() == 'NamedParams' ? (
						(function(self) {
							for (var i = 0, ary = iter$(self.object().nodes), len = ary.length, res = []; i < len; i++) {
								res.push((self['$a' + i] = self['$a' + i] || tag$.$api_param()).setObject(ary[i]).end());
							};
							return res;
						})(self)
					) : (Imba.static([
						(t0 = self.$b=self.$b || tag$.$div().flag('name')).setContent(self.object().name,3).end(),
						(self.object().defaults) ? (Imba.static([
							(t1 = self.$c=self.$c || tag$.$i()).setContent([self.type() == 'NamedParam' ? (': ') : (' = ')],1).end(),
							(self.$d = self.$d || tag$.$api_value()).setObject(self.object().defaults).end()
						],2)) : void(0)
					],3))
				],1).synced();
			};
		});
		
		tag$.defineTag('api-method', 'api-item', function(tag){
			
			
			
			tag.prototype.iname = function(v){ return this._iname; }
			tag.prototype.setIname = function(v){ this._iname = v; return this; };
			
			
			tag.prototype.path = function(v){ return this._path; }
			tag.prototype.setPath = function(v){ this._path = v; return this; };
			
			tag.prototype.tags = function (){
				var t0;
				return (t0 = this._tags=this._tags || tag$.$div().setRef('tags',this)).setContent([
					(this.object().deprecated) ? (
						(t0.$$a = t0.$$a || tag$.$div().flag('deprecated').flag('red')).setText('Method is deprecated').end()
					) : void(0),
					(this.object().return) ? ((t0.$$b = t0.$$b || tag$.$api_return().setName('returns')).setObject(this.object().return).end()) : void(0)
				],1).end();
			};
			
			tag.prototype.path = function (){
				return this._path || (this.iname() + '.' + this.object().name);
			};
			
			tag.prototype.slug = function (){
				return pathToAnchor(this.object().namepath);
			};
			
			tag.prototype.render = function (){
				var t0, self = this, t1;
				return this.flag('deprecated',this.object().deprecated).setChildren([
					(this.$a = this.$a || tag$.$span().flag('toc-anchor')).setId(this.slug()).end(),
					(t0 = self.$b=self.$b || tag$.$div().flag('header')).setContent([
						(t0.$$a = t0.$$a || tag$.$api_path()).setObject(this.path()).end(),
						(t1 = t0.$$b=t0.$$b || tag$.$div().flag('params')).setContent((function(t1) {
							for (var i = 0, ary = iter$(self.object().params), len = ary.length, res = []; i < len; i++) {
								res.push((t1['$$a' + i] = t1['$$a' + i] || tag$.$api_param()).setObject(ary[i]).end());
							};
							return res;
						})(t1),3).end(),
						(t0.$$c = t0.$$c || tag$.$div().flag('grow')).end()
					],2).end(),
					(self.$c = self.$c || tag$.$api_desc().flag('md')).setHtml(self.object().html).end(),
					self.tags()
				],1).synced();
			};
		});
		
		tag$.defineTag('doc-link', 'a', function(tag){
			
			tag.prototype.render = function (){
				this.setHref(("/docs#" + pathToAnchor(this.object().namepath))).setChildren((this.$a = this.$a || tag$.$api_path()).setObject(this.object().namepath).end(),2).synced();
				return tag.__super__.render.apply(this,arguments);
			};
			
			tag.prototype.ontap = function (){
				tag.__super__.ontap.apply(this,arguments);
				return this.up(q$('._docs',this)).refocus();
			};
		});
		
		tag$.defineTag('doc-group', 'toc', function(tag){
			
			tag.prototype.ontap = function (){
				return this.toggleFlag('collapsed');
			};
		});
		
		
		return tag$.defineTag('docs', 'page', function(tag){
			
			
			tag.prototype.__version = {'default': '0.14.1',name: 'version'};
			tag.prototype.version = function(v){ return this._version; }
			tag.prototype.setVersion = function(v){ this._version = v; return this; }
			tag.prototype._version = '0.14.1';
			
			
			tag.prototype.roots = function(v){ return this._roots; }
			tag.prototype.setRoots = function(v){ this._roots = v; return this; };
			
			tag.prototype.src = function (){
				return ("/api/" + this.version() + ".json");
			};
			
			tag.prototype.docs = function (){
				return this._docs;
			};
			
			tag.prototype.awaken = function (){
				this.load();
				this.schedule();
				return this;
			};
			
			tag.prototype.build = function (){
				this.load();
				return tag.__super__.build.apply(this,arguments);
			};
			
			tag.prototype.load = function (){
				var self = this;
				if (false) {
					// return self
					APP.fetchDocument(self.src(),function(res) {
						self._docs = JSON.parse(JSON.stringify(res));
						return self.generate();
					});
					return self;
				};
				
				return self._request || (self._request = APP.fetchDocument(self.src(),function(res) {
					DOCS = self._docs = res;
					DOCMAP = self._docs.entities;
					self.generate();
					return self.loaded();
				}));
			};
			
			tag.prototype.loaded = function (){
				var el;
				this.render();
				// really?
				if (document.location.hash) {
					if (el = this.first(document.location.hash)) {
						// console.log 'should scroll here?!?!?!',el
						el.dom().scrollIntoView();
					};
				};
				return this;
			};
			
			tag.prototype.refocus = function (){
				var el;
				if (el = this.first(document.location.hash)) {
					el.dom().scrollIntoView();
				};
				return this;
			};
			
			tag.prototype.lookup = function (path){
				return this.docs().entities[path];
			};
			
			tag.prototype.generate = function (){
				this._roots = [];
				var ents = this._docs.entities;
				
				for (var o = this.docs().entities, item, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
					item = o[keys[i]];if (item.type == 'class' || keys[i] == 'Imba') {
						item['.'] = (item['.'] || []).sort().map(function(path) { return ents[path]; }).filter(function(v) { return v.type == 'method' && v.desc; });
						item['#'] = (item['#'] || []).sort().map(function(path) { return ents[path]; }).filter(function(v) { return v.type == 'method' && v.desc; });
						
						if (item.desc) { this._roots.push(item) };
					};
				};
				return this;
			};
			
			tag.prototype.render = function (){
				if (!(this.docs())) { return this };
				return tag.__super__.render.apply(this,arguments);
			};
			
			tag.prototype.body = function (){
				var self = this, t0;
				return (t0 = self._body=self._body || tag$.$div().setRef('body',this).flag('light')).setContent(
					(function(t0) {
						for (var i = 0, ary = iter$(self.roots()), len = ary.length, res = []; i < len; i++) {
							res.push((t0['$$a' + i] = t0['$$a' + i] || tag$.$api_class().flag('doc').flag('l')).setObject(ary[i]).end());
						};
						return res;
					})(t0)
				,3).end();
			};
			tag.prototype.nav = function (){
				var t0, self = this, t1;
				return (t0 = self._nav=self._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent(
						(function(t1) {
							var t2, t3, t4, t5, t6;
							for (var i = 0, ary = iter$(self.roots()), len = ary.length, root, res = []; i < len; i++) {
								root = ary[i];
								res.push((t2 = t1['$$a' + i]=t1['$$a' + i] || tag$.$doc_group().flag('class').flag('section').flag('compact')).setContent([
									(t3 = t2.$$a=t2.$$a || tag$.$div().flag('header')).setContent((t3.$$a = t3.$$a || tag$.$doc_link().flag('class')).setObject(root).end(),2).end(),
									(t4 = t2.$$b=t2.$$b || tag$.$div().flag('content')).setContent([
										(t5 = t4.$$a=t4.$$a || tag$.$div().flag('static')).setContent(
											(function(t5) {
												var t6;
												for (var j = 0, items = iter$(root['.']), len_ = items.length, meth, res1 = []; j < len_; j++) {
													meth = items[j];
													if (!meth.desc) { continue; };
													res1.push((t6 = t5['$$a' + j]=t5['$$a' + j] || tag$.$div().flag('entry')).setContent((t6.$$a = t6.$$a || tag$.$doc_link()).setObject(meth).end(),2).end());
												};
												return res1;
											})(t5)
										,3).end(),
										(t6 = t4.$$b=t4.$$b || tag$.$div().flag('instance')).setContent(
											(function(t6) {
												var t7;
												for (var j = 0, items = iter$(root['#']), len_ = items.length, meth, res1 = []; j < len_; j++) {
													meth = items[j];
													if (!meth.desc) { continue; };
													res1.push((t7 = t6['$$a' + j]=t6['$$a' + j] || tag$.$div().flag('entry')).setContent((t7.$$a = t7.$$a || tag$.$doc_link()).setObject(meth).end(),2).end());
												};
												return res1;
											})(t6)
										,3).end()
									],2).end()
								],2).end());
							};
							return res;
						})(t1)
					,3).end()
				,2).end();
			};
		});
		
		
	
	})()

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// externs;
		
		// var hljs = require 'highlight.js'
		
		tag$.defineTag('tool', 'button', function(tag){
			
			
			tag.prototype.action = function(v){ return this._action; }
			tag.prototype.setAction = function(v){ this._action = v; return this; };
			
			tag.prototype.render = function (){
				return this.flag('sym').synced();
			};
			
			tag.prototype.onclick = function (e){
				this.log('button click',e);
				return e.halt();
			};
			
			tag.prototype.ontouchstart = function (e){
				this.log('touchstart');
				true;
				return e.event().preventDefault();
			};
		});
		
		tag$.defineTag('snippet-hint', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				return this.setText("I am a hint!!").synced();
			};
		});
		
		tag$.defineTag('overlays', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				var root;
				if (root = this.view()._root) {
					var left = 0,top = 0,el = root.dom();
					
					while (el && !el.contains(this._dom)){
						left += el.offsetLeft;
						top += el.offsetTop - el.scrollTop;
						el = el.parentNode;
					};
					
					this._dom.style.left = left + 'px';
					this._dom.style.top = top + 'px';
				};
				
				return this;
			};
		});
		
		tag$.defineTag('hint-label', function(tag){
			
			tag.prototype.setLabel = function (text){
				if (text != this._label) {
					this._label = text;
					this.dom().innerHTML = text;
				};
				return this;
			};
		});
		
		tag$.defineTag('overlay-hint', function(tag){
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.__row = {watch: 'rowDidSet',name: 'row'};
			tag.prototype.row = function(v){ return this._row; }
			tag.prototype.setRow = function(v){
				var a = this.row();
				if(v != a) { this._row = v; }
				if(v != a) { this.rowDidSet && this.rowDidSet(v,a,this.__row) }
				return this;
			};
			
			tag.prototype.__col = {watch: 'colDidSet',name: 'col'};
			tag.prototype.col = function(v){ return this._col; }
			tag.prototype.setCol = function(v){
				var a = this.col();
				if(v != a) { this._col = v; }
				if(v != a) { this.colDidSet && this.colDidSet(v,a,this.__col) }
				return this;
			};
			
			tag.prototype.__len = {watch: 'lenDidSet',name: 'len'};
			tag.prototype.len = function(v){ return this._len; }
			tag.prototype.setLen = function(v){
				var a = this.len();
				if(v != a) { this._len = v; }
				if(v != a) { this.lenDidSet && this.lenDidSet(v,a,this.__len) }
				return this;
			};
			
			tag.prototype.rowDidSet = function (new$,old){
				var val = ("" + (this.object().row() * this.view().lineHeight()) + "px");
				return this._dom.style.top = val;
			};
			
			tag.prototype.colDidSet = function (new$,old){
				var val = ("" + (this.object().col() * this.view().charWidth()) + "px");
				return this._dom.style.left = val;
			};
			
			tag.prototype.lenDidSet = function (new$,old){
				var width = ("" + (new$ * this.view().charWidth()) + "px");
				return this._dom.style.width = width;
			};
			
			tag.prototype.render = function (){
				// console.log 'hint at',object.row
				var reg = this.object().region();
				
				if (reg) {
					this.setRow(this.object().row());
					this.setCol(this.object().col());
					this.setLen(reg.size());
				};
				
				return this.flag('warn').flag('global',(!reg)).setType((this.object().type())).setChildren(
					(this.$a = this.$a || tag$.$hint_label().flag('label')).setLabel(this.object().label()).end()
				,2).synced();
			};
		});
		
		tag$.defineTag('jsview', function(tag){
			
			tag.prototype.render = function (){
				return this.setChildren((this._code = this._code || tag$.$code().setRef('code',this)).end(),2).synced();
			};
			
			tag.prototype.load = function (code,cb){
				// should compile bare
				var self = this;
				code = code.replace(/\/\/\# sourceMapping(.*)$/,'');
				code = code.replace(/^\(function\(\)\{\n/,'');
				code = code.replace(/\n?\}\)\(\)\n?$/,'');
				// code = code.replace(/^\t/mg,'')
				this._code.textContent = code;
				
				this.flag('huge',code.length > 1000);
				
				setTimeout(function() {
					hljs.configure({classPrefix: ''});
					var hl = hljs.highlight('javascript',code);
					self._code.setHtml(hl.value);
					return cb && cb(self);
				},0);
				
				return self;
			};
		});
		
		tag$.defineTag('console', function(tag){
			
			
			tag.prototype.editor = function(v){ return this._editor; }
			tag.prototype.setEditor = function(v){ this._editor = v; return this; };
			
			tag.prototype.reset = function (){
				this.empty();
				return this;
			};
			
			tag.prototype.log = function (val){
				console.log.apply(console,arguments);
				
				if (this.editor()) {
					this.editor().flag('console');
				};
				// console.log 'logging val',val
				
				if (val == this) {
					return;
				};
				
				if (val && val.dom) {
					val = val.dom().outerHTML;
				} else if (val instanceof Object) {
					val = JSON.stringify(val);
				};
				
				if (val != undefined) {
					this.append(tag$.$div().flag('json').setContent(val,0).end());
				};
				
				return;
			};
		});
		
		
		// this is basically like an editor
		tag$.defineTag('snippet', function(tag){
			
			var counter = 0;
			
			
			
			tag.prototype.imba = function(v){ return this._imba; }
			tag.prototype.setImba = function(v){ this._imba = v; return this; };
			
			
			tag.prototype.config = function(v){ return this._config; }
			tag.prototype.setConfig = function(v){ this._config = v; return this; };
			
			tag.prototype.__src = {watch: 'reload',name: 'src'};
			tag.prototype.src = function(v){ return this._src; }
			tag.prototype.setSrc = function(v){
				var a = this.src();
				if(v != a) { this._src = v; }
				if(v != a) { this.reload && this.reload(v,a,this.__src) }
				return this;
			};
			
			
			
			tag.prototype.heading = function(v){ return this.getAttribute('heading'); }
			tag.prototype.setHeading = function(v){ this.setAttribute('heading',v); return this; };
			
			
			tag.prototype.layout = function(v){ return this.getAttribute('layout'); }
			tag.prototype.setLayout = function(v){ this.setAttribute('layout',v); return this; };
			
			
			tag.prototype.tab = function(v){ return this.getAttribute('tab'); }
			tag.prototype.setTab = function(v){ this.setAttribute('tab',v); return this; };
			
			
			tag.prototype.__active = {watch: 'activeDidSet',name: 'active'};
			tag.prototype.active = function(v){ return this._active; }
			tag.prototype.setActive = function(v){
				var a = this.active();
				if(v != a) { this._active = v; }
				if(v != a) { this.activeDidSet && this.activeDidSet(v,a,this.__active) }
				return this;
			};
			
			tag.prototype.id = function (){
				var dom_;
				return (dom_ = this.dom()).id || (dom_.id = ("snippet" + (counter++)));
			};
			
			tag.prototype.activeDidSet = function (bool){
				return bool ? (this.schedule({fps: 60})) : (this.unschedule());
			};
			
			tag.prototype.input = function (){
				return (this._input = this._input || tag$.$imcaptor().setRef('input',this)).end();
			};
			
			tag.prototype.view = function (){
				return this._view || (this._view = (this._view = this._view || tag$.$imview().setRef('view',this)).setInput(this.input()).end());
			};
			
			tag.prototype.build = function (){
				
				var self = this, t0, t1, t2, t3, t4, t5;
				if (false) {
					if (self.src() && self.src().match(/\.imba$/)) {
						APP.fetchDocument(self.src(),function(res) {
							var v_;
							return (self.setImba(v_ = res.html),v_);
						});
					};
					// prerender shell
					self.setChildren([
						(t0 = self._main=self._main || tag$.$section().setRef('main',self)).setContent([
							(t1 = self._header=self._header || tag$.$header().setRef('header',self)).setContent([
								(t2 = t1.$$a=t1.$$a || tag$.$div().flag('title').flag('path')).setContent(self.heading(),3).end(),
								(t3 = t1.$$b=t1.$$b || tag$.$div().flag('tools')).setContent([
									(t3.$$a = t3.$$a || tag$.$tool().flag('reset').setTitle('reset').setHandler('tap','reset',self)).setText('reset').end(),
									(t3.$$b = t3.$$b || tag$.$tool().flag('js').setTitle('show js').setHandler('tap','toggleJS',self)).setText('show js').end(),
									(t3.$$c = t3.$$c || tag$.$tool().flag('run').setTitle('run').setHandler('tap','run',self)).setText('run').end()
								],2).end()
							],2).end(),
							(t4 = self._view=self._view || tag$.$div().setRef('view',self)).setContent((t5 = t4.$$a=t4.$$a || tag$.$code().flag('imbacode')).dataset('src',(self.src())).setContent(self.imba(),3).end(),2).end()
						],2).end(),
						(self._inspector = self._inspector || tag$.$div().setRef('inspector',self)).end()
					],2).synced();
					return self;
				};
				
				tag.__super__.build.apply(self,arguments);
				if (self.src()) { return self.reload() };
			};
			
			tag.prototype.setConfig = function (cfg){
				var v_;
				if (cfg != this._options) {
					this._options = cfg;
					if (cfg.title) { (this.setHeading(v_ = cfg.title),v_) };
				};
				return this;
			};
			
			tag.prototype.copts = function (){
				return this._copts || (this._copts = {
					bare: false,
					standalone: false,
					sourceMapInline: true,
					filename: ("" + this.id() + ".imba"),
					targetPath: ("" + this.id() + ".js"),
					sourcePath: ("" + this.id() + ".imba")
				});
			};
			
			tag.prototype.option = function (key){
				return this._options ? (this._options[key]) : (null);
			};
			
			tag.prototype.configure = function (o){
				this._options = o;
				return this.render();
			};
			
			tag.prototype.awaken = function (){
				var config = {};
				try {
					var code = q$$('.imbacode',this).dom().innerHTML;
				} catch (e) { };
				
				if (code) {
					config.html = code;
					this.view().load(null,{html: code});
					this.configure(config);
				};
				
				return this;
			};
			
			tag.prototype.load = function (code,o){
				if(o === undefined) o = {};
				if (code || o.html) { this.view().load(code,o) };
				return this;
			};
			
			tag.prototype.code = function (){
				return this.view().code();
			};
			
			tag.prototype.compile = function (code,o,blk){
				// cache latest compilation - return?
				if(blk==undefined && typeof o == 'function') blk = o,o = this.copts();
				if(o==undefined) o = this.copts();
				return Scrimbla.worker().compile(code,o,blk);
			};
			
			tag.prototype.overlays = function (){
				for (var i = 0, ary = iter$(this.view().hints()), len = ary.length, hint, res = []; i < len; i++) {
					hint = ary[i];
					if (!hint.active()) { continue; };
					res.push((this['_' + 'hint' + i] = this['_' + 'hint' + i] || tag$.$overlay_hint()).setView(this.view()).setObject(hint).end());
				};
				return res;
			};
			
			tag.prototype.toggleJS = function (){
				if (this.tab() != 'js') {
					this.showjs();
				} else {
					this.setTab('imba');
				};
				return this;
			};
			
			tag.prototype.oninputfocus = function (e){
				VIEW = this; // hack
				this.flag('focus');
				return (this.setActive(true),true);
			};
			
			tag.prototype.oninputblur = function (e){
				this.unflag('focus');
				var rel = e.event().relatedTarget;
				if (!(rel && this.dom().contains(rel))) {
					this.unflag('focus');
					this.setActive(false);
				};
				return this;
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, t5;
				if (false) { return this };
				
				return this.setChildren([
					this._input,
					(t0 = this._main=this._main || tag$.$section().setRef('main',this)).setContent([
						(t1 = this._header=this._header || tag$.$header().setRef('header',this)).setContent([
							(t2 = t1.$$a=t1.$$a || tag$.$div().flag('title').flag('path')).setContent(this.heading(),3).end(),
							(t3 = t1.$$b=t1.$$b || tag$.$div().flag('tools')).setContent([
								(t3.$$a = t3.$$a || tag$.$tool().flag('reset').setTitle('reset').setHandler('tap','reset',this)).setText('reset').end(),
								(t3.$$b = t3.$$b || tag$.$tool().flag('js').setTitle('show js').setHandler('tap','toggleJS',this)).setText('show js').end(),
								(t3.$$c = t3.$$c || tag$.$tool().flag('run').setTitle('run').setHandler('tap','run',this)).setText('run').end()
							],2).end()
						],2).end(),
						(t4 = this._overlays=this._overlays || tag$.$overlays().setRef('overlays',this)).setView(this.view()).setContent(this.overlays(),3).end(),
						(this._jsview = this._jsview || tag$.$jsview().setRef('jsview',this)).end(),
						this._view.end(),
						(this._console = this._console || tag$.$console().setRef('console',this).flag('dark')).setEditor(this).end()
					],1).end(),
					(t5 = this._inspector=this._inspector || tag$.$div().setRef('inspector',this)).setContent(this.playground(),3).end()
				],1).synced();
			};
			
			tag.prototype.sandbox = function (){
				return (this._sandbox = this._sandbox || tag$.$sandbox().setRef('sandbox',this).flag('playground')).setEditor(this).end();
			};
			
			tag.prototype.playground = function (){
				return this.sandbox();
			};
			
			tag.prototype.reload = function (){
				var self = this;
				if (!self._built) { return };
				
				if (DEPS[self.src()]) {
					var res = DEPS[self.src()];
					self.view().load(null,{html: res.html,filename: self.src()});
					if (self.autorun()) {
						setTimeout(function() { return self.run(); },50);
					};
					return self;
				};
				
				// get imba document?!?
				APP.fetchDocument(self.src(),function(res) {
					self.view().load(res.body,{filename: self.src()});
					if (self.autorun()) {
						return setTimeout(function() { return self.run(); },50);
					};
				});
				return self;
			};
			
			tag.prototype.onrun = function (){
				return this.run();
			};
			
			tag.prototype.autorun = function (){
				return false;
			};
			
			tag.prototype.oneditedasync = function (){
				this.flag('dirty');
				return this;
			};
			
			tag.prototype.onsave = function (){
				this.view().hints().clear();
				return this.run();
			};
			
			tag.prototype.reset = function (e){
				this._console.reset();
				if (this._options.html) {
					this.view().load(null,{html: this._options.html});
				};
				if (e) {
					e.cancel();
				};
				this.unflag('dirty');
				this.view().caret().normalize().dirty();
				return this;
			};
			
			tag.prototype.run = function (){
				var self = this;
				self.flag('running');
				self.compile(self.code(),self.copts(),function(res) {
					self.view().hints().rem(function(hint) { return hint.group() == 'runtime'; });
					
					if (res.data && res.data.code) {
						// @jsview.load(res:data:code) if res:data
						try {
							return self._sandbox.run(res.data);
						} catch (e) {
							return console.log('error');
						};
					};
				});
				return self;
			};
			
			tag.prototype.showjs = function (){
				var self = this;
				var o = {bare: true,standalone: false,filename: 'a.imba'};
				
				return self.compile(self.code(),o,function(res) {
					if (res.data && res.data.code) {
						return self._jsview.load(res.data.code,function() { var v_;
						return (self.setTab(v_ = 'js'),v_); });
					} else if (res.data && res.data.error) {
						return console.log('has error');
					};
				});
			};
			
			tag.prototype.runError = function (o){
				o.type = 'error';
				o.group = 'runtime';
				// console.log 'runError',o
				// only show error if we have a line and column
				return this.view().hints().add(o).activate();
			};
			
			tag.prototype.runLog = function (o){
				o.type = 'log';
				o.group = 'runtime';
				o.message || (o.message = JSON.stringify(o.params[0]));
				// console.log 'runLog',o
				
				if (o.nr != null && !o.loc) {
					var logs = this.view().find('.identifier.log,.identifier[name="log"]').toArray();
					var node = logs[o.nr];
					
					o.node = node;
					
					if (node) {
						var reg = node.region(); // node.next ? node.next.region : 
						console.log('found loc!!',node,reg);
						// let col = view.buffer.line(reg.row)[:length]
						o.loc = reg.endAtLine().collapse(); // {line: reg.row, column: col} #  reg.toJSON # {line: reg.row, column: 100}
						
						// o:loc = logs[o:nr].region.toJSON
					};
				};
				return this.view().hints().add(o).activate();
			};
			
			tag.prototype.runResult = function (o){
				// console.log 'runResult',o
				this.flag('repl',!!o);
				this._console.log(o);
				return this;
			};
		});
		
		tag$.defineTag('example', 'snippet', function(tag){
			
			tag.prototype.autorun = function (){
				return true;
			};
		});
		
		if (true) {
			Imba.Event.PROCESSING;
			
			
				
				var prev = Imba.Event.prototype.process;
				
				Imba.Event.prototype.process = function (){
					Imba.Event.PROCESSING = this;
					return prev.call(this);
				};
			
		};
		
		
		return tag$.defineTag('sandbox', function(tag){
			
			
			
			tag.prototype.editor = function(v){ return this._editor; }
			tag.prototype.setEditor = function(v){ this._editor = v; return this; };
			
			tag.prototype.render = function (){
				return this;
			};
			
			tag.prototype.console = function (){
				return this.editor()._console;
			};
			
			tag.prototype.onerror = function (msg,url,line,col,err){
				
				var stack_;
				if (url.match(/snippet(\d+)\.(imba|js)/)) {
					
					var id = url.split('.').shift();
					var snippet = tag$wrap(document.getElementById(id));
					
					if (snippet) {
						snippet.playground().onerror(msg,'',line,col,err);
						return;
					};
				} else if (url == 'undefined') {
					// safari?
					var ev = Imba.Event.PROCESSING;
					console.log('last event target',ev && ev.target());
					if (ev && ev.target()) {
						snippet = ev.target().closest(q$('._snippet',this));
						if (snippet) {
							return snippet.playground().onerror(msg,'',line,col,err);
						};
					};
				};
				
				console.log('caught the error here!!!',arguments,this);
				var locs = [];
				
				err && (stack_ = err.stack) && stack_.replace  &&  stack_.replace(/(\<anonymous\>|snippet\d+\.imba)\:(\d+):(\d+)/g,function(m,source,line,col) {
					locs.push({line: parseInt(line),column: parseInt(col)});
					return "";
				});
				
				locs.push({line: line,column: col});
				
				if (locs[0]) {
					var map = this.object().sourcemap;
					var consumer = Scrimbla.SourceMap.SourceMapConsumer(map);
					var loc = consumer.originalPositionFor(locs[0]);
					console.log('original location is',loc);
					this.editor().runError({message: msg,loc: loc});
				};
				
				return true;
			};
			
			tag.prototype.onlog = function (nr,pars){
				this.editor().runLog({nr: nr,params: pars});
				return this;
			};
			
			tag.prototype.empty = function (){
				for (var i = 0, ary = iter$(q$('.scheduled_',this)), len = ary.length; i < len; i++) {
					ary[i].unschedule();
				};
				return tag.__super__.empty.apply(this,arguments);
			};
			
			tag.prototype.present = function (res){
				var node;
				if (res && (res.prototype instanceof Imba.Tag)) {
					node = new res(res.createNode());
				} else if (res instanceof Imba.Tag) {
					node = res;
				};
				
				if (node) {
					this.empty().append(node);
					node.end();
				};
				
				return this.console().log(node || res);
			};
			
			tag.prototype.run = function (src){
				var self = this;
				var code = src.code;
				if (!code) { return self };
				
				self._object = src;
				
				try {
					window.onerror = function(msg,url,line,col,err) {
						console.log('caught error',msg,url,line,col,err,this);
						return self.onerror(msg,url,line,col,err);
					};
					
					code = code + '\n//# sourceURL=' + self.editor().id() + '.imba';
					var tag$ = Imba.TAGS.__clone();
					var console = self.console();
					var res = eval(code);
					self.present(res);
				} catch (e) {
					self.log('immediate error in eval-inline',e);
					self.onerror(e.message,'',e.lineNr || e.line || 0,e.column,e);
				};
				
				return self;
			};
		});
	
	})()

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDBiNzMzYTdmNDhmMzlkOTAyODQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvaW1iYS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9jb3JlLmV2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9zY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvdGFnLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9kb20uY2xpZW50LmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5odG1sLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5zdmcuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvZG9tLmxlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9kb20uZXZlbnRzLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5zdGF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9pbmRleC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9mcy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9yZWdpb24uaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2hlbHBlcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlnaGxpZ2h0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvbGV4ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvcmV3cml0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvZXJyb3JzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL3V0aWwuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlzdG9yeS5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9sb2dnZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvc2hvcnRjdXRzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy92aWV3cy9jYXB0b3IuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL3ZpZXcuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvYnVmZmVyLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL29ic2VydmVyLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL2hpbnRzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL2NhcmV0LmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy92aWV3cy9vdmVybGF5cy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvZWRpdG9yLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL3dvcmtlci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvaW5kZXguaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Jhc2UuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL3Rva2VuLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9ibG9jay5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvcm9vdC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvbGl0ZXJhbHMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL29wZXJhdG9ycy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvc2VsZWN0b3IuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL3doaXRlc3BhY2UuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Fubm90YXRpb25zLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC5pbWJhIiwid2VicGFjazovLy8uL3NyYy9yb3V0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaW5kZXguaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYmFzZS5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9tYXJrZG93bi5pbWJhIiwid2VicGFjazovLy8uL34vbWFya2VkL2xpYi9tYXJrZWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3NpdGUuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbmF2LmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3BhZ2UuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaG9tZS5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9ibG9nLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2d1aWRlcy5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9kb2NzLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3NuaXBwZXQuaW1iYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWdDLFdBQVcsRUFBRTtBQUM3Qyx5Q0FBd0MsV0FBVyxFQUFFOztBQUVyRCxFQUFDLEc7Ozs7OztBQ2hCRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBVyxTO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtB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O0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaFhBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdkdBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDL0VBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qix3Q0FBd0M7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxtQkFBbUIsRUFBRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xIQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTCxhQUFZO0FBQ1o7O0FBRUE7QUFDQTs7Ozs7OztBQ3ZaQTtBQUNBLG9CQUFtQiwrQ0FBK0M7OztBQUdsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBeUI7OztBQUd6QixtQ0FBa0MsZ0JBQWdCO0FBQ2xELHNDQUFxQyxhQUFhLGFBQWE7OztBQUcvRCxtQ0FBa0MsZ0JBQWdCO0FBQ2xELHNDQUFxQyxhQUFhLGFBQWE7OztBQUcvRCxzQ0FBcUMsbUJBQW1CO0FBQ3hELHlDQUF3QyxnQkFBZ0IsYUFBYTs7O0FBR3JFLHNDQUFxQyxtQkFBbUI7QUFDeEQseUNBQXdDLGdCQUFnQixhQUFhOztBQUVyRTs7QUFFQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCLDhCQUE2QjtBQUM3Qix1REFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1YsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDViwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEc7Ozs7OztBQ3hTRDtBQUNBLG9CQUFtQiwrQ0FBK0M7OztBQUdsRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBc0IsOENBQThDLEVBQUU7QUFDdEUscUJBQW9CLGlFQUFpRTtBQUNyRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QixpQ0FBaUMsRUFBRTtBQUMzRDtBQUNBLHVCQUFzQixtQ0FBbUMsRUFBRTtBQUMzRCxzQkFBcUIsK0JBQStCLEVBQUU7QUFDdEQsc0JBQXFCLHlEQUF5RCxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHlCQUF3QjtBQUN4QiwrQkFBOEI7QUFDOUIsK0JBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUE4QixZQUFZLEVBQUUsa0JBQWtCO0FBQzlELGlDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDNU1EO0FBQ0Esb0JBQW1CLCtDQUErQzs7QUFFbEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTCxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBc0IsOENBQThDLEVBQUU7QUFDdEUscUJBQW9CLGlFQUFpRTtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNEI7QUFDNUIscUJBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBLG9DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNLE1BQU07QUFDWixNQUFLLEtBQUs7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFpRSwrQkFBK0I7QUFDaEcsK0JBQThCO0FBQzlCLDZCQUE0QjtBQUM1Qiw4QkFBNkI7QUFDN0IsNEJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUssbUJBQW1CO0FBQ3hCO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFnQyxVQUFVOztBQUUxQyxzQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLHlDQUF5QztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQThELFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7O0FBRWYsc0RBQXFELEVBQUU7QUFDdkQ7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsMEVBQXlFLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSiw2QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esb0NBQW1DO0FBQ25DLE1BQUs7QUFDTCxtQ0FBa0MseUNBQXlDO0FBQzNFO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUk7QUFDSixzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQSw4Q0FBNkMsc0JBQXNCO0FBQ25FLGlEQUFnRCxtQkFBbUIsYUFBYTs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEIsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUF5QztBQUN6Qzs7QUFFQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxHOzs7Ozs7O0FDbjBCRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUIsSUFBSTtBQUM3QjtBQUNBLDJEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQSx1R0FBc0csSUFBSTs7QUFFMUc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUhBQWtILElBQUk7O0FBRXRILHFCQUFvQixFQUFFLGFBQWEsRUFBRSxRQUFRLElBQUk7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUsscUNBQXFDO0FBQzFDO0FBQ0EsOEZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7Ozs7QUFJakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUEsb0JBQW1CO0FBQ25CLG9CQUFtQjtBQUNuQixxQkFBb0I7O0FBRXBCLHNCQUFxQjtBQUNyQixtQkFBa0I7QUFDbEIsdUJBQXNCO0FBQ3RCO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUEscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUosK0JBQThCLFdBQVc7QUFDekM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEIsMkNBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBLGtDQUFpQyxJQUFJLElBQUksU0FBUyxFQUFFLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QywwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCOztBQUUvQjtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQSx1Q0FBc0M7O0FBRXRDO0FBQ0EsdUNBQXNDOztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUE4QztBQUM5QywwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTs7QUFFQSxvQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOERBQTZEO0FBQzdELDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJLG9DQUFvQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWlGO0FBQ2pGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLG9CQUFvQixJQUFJLHNCQUFzQjtBQUM5RSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFnRTs7O0FBR2hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBZ0MsNEJBQTRCOztBQUU1RDtBQUNBLHlEQUF3RDtBQUN4RDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTBCLElBQUk7QUFDOUI7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSixnQkFBZTtBQUNmLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0Esb0JBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEM7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvREFBbUQ7QUFDbkQ7QUFDQSwwQ0FBeUM7QUFDekMsMkJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBLElBQUc7QUFDSCwyQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBMkQ7QUFDM0Q7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSx3Q0FBdUMsMEJBQTBCO0FBQ2pFLGtDQUFpQyxnQkFBZ0IsRUFBRSxXQUFXOztBQUU5RCxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLCtDQUErQztBQUM5RTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixLQUFLLFdBQVcsT0FBTyxLQUFLLE9BQU8sRUFBRSxlQUFlOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QyxLQUFJO0FBQ0osbUNBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGlEQUFnRCxLQUFLO0FBQ3JEO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBOEM7QUFDOUM7QUFDQTs7QUFFQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQSw4Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQsNERBQTREO0FBQ25IO0FBQ0EsSUFBRztBQUNIO0FBQ0Esa0NBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0ZBQStFO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkLDRDQUEyQztBQUMzQywwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCOztBQUV6QiwyQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhEQUE2RCxZQUFZLDZCQUE2QixTQUFTOztBQUUvRztBQUNBLHVCQUFzQjtBQUN0Qix5QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEscURBQW9ELFVBQVU7O0FBRTlEO0FBQ0Esc0VBQXFFO0FBQ3JFOztBQUVBLG9DQUFtQztBQUNuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLG1EQUFrRCxvQkFBb0I7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRDQUEyQyw0QkFBNEI7O0FBRXZFO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTs7QUFFYixxQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQSwrREFBOEQ7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE2RjtBQUM3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLDRCQUEyQixlQUFlOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQsSUFBSSxFQUFFLEdBQUc7O0FBRXBFLDZDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLGdEQUErQyxHQUFHLEVBQUUsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxJQUFHLDhEQUE4RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUcsMEdBQTBHO0FBQzdHO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNILG9CQUFtQjtBQUNuQixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQSxXQUFVO0FBQ1Y7QUFDQSxzQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQyxJQUFHO0FBQ0gsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWU7QUFDZixzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFnQjtBQUNoQjtBQUNBLEtBQUksbUJBQW1CO0FBQ3ZCO0FBQ0EsS0FBSSxtQkFBbUIsaUJBQWlCO0FBQ3hDLHdCQUF1QjtBQUN2QixLQUFJLG9DQUFvQztBQUN4Qyx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNEIsSUFBSTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsb0RBQW9EO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNEIsSUFBSTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYzs7QUFFZCx3QkFBdUI7O0FBRXZCLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0EsS0FBSSxtQkFBbUIsaUJBQWlCO0FBQ3hDLHdCQUF1QjtBQUN2QixLQUFJLG9DQUFvQztBQUN4Qyx3QkFBdUI7QUFDdkI7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsOENBQThDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDaG9FRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsTUFBTSxFQUFFLEtBQUs7QUFDeEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRyxtQkFBbUI7QUFDdEI7QUFDQTtBQUNBLElBQUcscUJBQXFCO0FBQ3hCO0FBQ0E7QUFDQSxJQUFHLG1CQUFtQjs7QUFFdEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7OztBQUdILG1EQUFrRCxJQUFJO0FBQ3RELG1EQUFrRCxJQUFJOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBQyxHOzs7Ozs7QUNoSUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLCtDQUErQztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjs7QUFFckIsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1EO0FBQ25EOztBQUVBLGlGQUFnRjtBQUNoRiw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBLElBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLGtEQUFrRDtBQUN2RixtQ0FBa0Msb0NBQW9DOztBQUV0RTtBQUNBLHdDQUF1QztBQUN2QztBQUNBLElBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLHNDQUFxQyxzREFBc0Q7QUFDM0YsbUNBQWtDLHdDQUF3QyxHQUFHOztBQUU3RTtBQUNBLDRDQUEyQztBQUMzQztBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQyxnREFBZ0Q7QUFDckYsbUNBQWtDLGtDQUFrQyxHQUFHOztBQUV2RTtBQUNBLHNDQUFxQztBQUNyQztBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXVEO0FBQ3ZEO0FBQ0EsOEJBQTZCLE1BQU07QUFDbkMsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXVDLEtBQUssYUFBYSxPQUFPO0FBQ2hFLCtCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0IsdUJBQXVCLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QixNQUFLO0FBQ0wsc0NBQXFDLEVBQUU7QUFDdkMsa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE2QjtBQUM3QjtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxNQUFLLGlFQUFpRTtBQUN0RTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBc0I7QUFDdEIscUNBQW9DO0FBQ3BDLG1EQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQyxHQUFHLEdBQUcsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHO0FBQzFEO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7OztBQUdBO0FBQ0EsNkJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBLHlDQUF3QztBQUN4QztBQUNBLHFDQUFvQztBQUNwQyx1REFBc0Q7QUFDdEQ7O0FBRUEsOEVBQTZFO0FBQzdFLDZFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1U0FBc1M7QUFDdFM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLHdEQUF3RDs7QUFFN0Y7QUFDQTtBQUNBLHlDQUF3QztBQUN4QztBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLElBQUk7QUFDVCxPQUFNLEtBQUs7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBcUUsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW1DLDRHQUE0RztBQUMvSSxrQ0FBaUMsaUdBQWlHOztBQUVsSTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBeUIsa0NBQWtDOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQSxxQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFnRztBQUNoRzs7QUFFQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDdnZCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0M7QUFDdEMsNkRBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUEsRUFBQyxHOzs7Ozs7QUMxRUQ7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSSxLQUFLO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBLElBQUc7OztBQUdIO0FBQ0Esa0JBQWlCO0FBQ2pCLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7O0FBRUEsa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7O0FBRUEsa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsT0FBTztBQUM1QztBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLG9DQUFvQzs7OztBQUl2QyxFQUFDLEc7Ozs7OztBQ3RNRDtBQUNBLG9CQUFtQiwrQ0FBK0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsNENBQTJDLG1CQUFtQjtBQUM5RCwrQ0FBOEMsZ0JBQWdCLGFBQWE7OztBQUczRSxpREFBZ0Qsd0JBQXdCO0FBQ3hFLG9EQUFtRCxxQkFBcUIsYUFBYTs7QUFFckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkI7O0FBRTdCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQSx1Q0FBc0MsbUJBQW1CO0FBQ3pELDBDQUF5QyxnQkFBZ0IsYUFBYTs7O0FBR3RFLHVDQUFzQyxtQkFBbUI7QUFDekQsMENBQXlDLGdCQUFnQixhQUFhOzs7QUFHdEUsd0NBQXVDLG9CQUFvQjtBQUMzRCwyQ0FBMEMsaUJBQWlCLGFBQWE7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLHFCQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCOzs7QUFHM0IsdUNBQXNDLG1CQUFtQjtBQUN6RCwwQ0FBeUMsZ0JBQWdCLGFBQWE7OztBQUd0RSx1Q0FBc0MsbUJBQW1CO0FBQ3pELDBDQUF5QyxnQkFBZ0IsYUFBYTs7O0FBR3RFLDBDQUF5QyxzQkFBc0I7QUFDL0QsNkNBQTRDLG1CQUFtQixhQUFhOzs7QUFHNUUsMENBQXlDLHNCQUFzQjtBQUMvRCw2Q0FBNEMsbUJBQW1CLGFBQWE7OztBQUc1RSx1Q0FBc0MsbUJBQW1CO0FBQ3pELDBDQUF5QyxnQkFBZ0IsYUFBYTs7O0FBR3RFLHVDQUFzQyxtQkFBbUI7QUFDekQsMENBQXlDLGdCQUFnQixhQUFhLEdBQUc7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSwwQ0FBeUMsT0FBTztBQUNoRCxNQUFLO0FBQ0wsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUIsdUJBQXNCO0FBQ3RCO0FBQ0EsMENBQXlDLE9BQU87QUFDaEQsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QixpRUFBZ0UsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsZ0VBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxFQUFDLEc7Ozs7OztBQ3piRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUF5Qjs7O0FBR3pCLHlDQUF3QyxzQkFBc0I7QUFDOUQsNENBQTJDLG1CQUFtQixhQUFhOzs7QUFHM0Usc0NBQXFDLG1CQUFtQjtBQUN4RCx5Q0FBd0MsZ0JBQWdCLGFBQWE7O0FBRXJFO0FBQ0EsOEJBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSw4QkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLDhCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0EsOEJBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSw4QkFBK0I7QUFDL0I7QUFDQTtBQUNBOzs7O0FBSUEsRUFBQyxHOzs7Ozs7QUM5Q0Q7QUFDQSxvQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUE4QixNQUFNLFdBQVc7QUFDL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFtQyxvQ0FBb0MsRUFBRTtBQUN6RSwwQ0FBeUMsb0NBQW9DLEVBQUU7QUFDL0Usd0NBQXVDLG9DQUFvQyxFQUFFO0FBQzdFOztBQUVBLHNCQUFxQixnQkFBZ0I7QUFDckMsc0JBQXFCLGVBQWU7QUFDcEMsMEJBQXlCLHVCQUF1QjtBQUNoRCwwQkFBeUIsbUJBQW1CO0FBQzVDLDBCQUF5Qix5QkFBeUI7O0FBRWxELG9DQUFtQyx3QkFBd0IsRUFBRTs7O0FBRzdELGtCQUFpQix3QkFBd0Isc0NBQXNDLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJOzs7O0FBSUosd0JBQXVCLHdCQUF3QixzQ0FBc0MsRUFBRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7O0FBRUosd0JBQXVCO0FBQ3ZCLGdCQUFlO0FBQ2YsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUosNkNBQTRDLGdDQUFnQyxFQUFFOztBQUU5RSx3QkFBdUI7QUFDdkI7QUFDQSwrQ0FBOEM7QUFDOUMsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUosd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUgsNkJBQTRCO0FBQzVCLHFFQUFvRSxHQUFHOztBQUV2RSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILDZCQUE0QixhQUFhLEdBQUc7O0FBRTVDLHNDQUFxQyxvQkFBb0IsRUFBRTtBQUMzRCw0Q0FBMkMsb0JBQW9CLEVBQUU7QUFDakUsMENBQXlDLGlDQUFpQyxFQUFFO0FBQzVFLDRDQUEyQyxpQ0FBaUMsRUFBRTs7QUFFOUU7QUFDQTtBQUNBLHVEQUFzRDs7QUFFdEQ7QUFDQSw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVILGdDQUErQix5QkFBeUIsRUFBRTs7O0FBRzFEO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELElBQUc7O0FBRUgscUNBQW9DLGlDQUFpQyxFQUFFO0FBQ3ZFOztBQUVBOztBQUVBLGdCQUFlLHdCQUF3Qix3Q0FBd0MsRUFBRTtBQUNqRiwyQkFBMEIsb0JBQW9CLEdBQUc7O0FBRWpELDhCQUE2QiwyQkFBMkIsRUFBRTtBQUMxRCw4QkFBNkIsMkJBQTJCLEVBQUU7QUFDMUQsOEJBQTZCLDJCQUEyQixFQUFFO0FBQzFELGFBQVksaUJBQWlCLHFCQUFxQixHQUFHLEdBQUcsRUFBRTs7QUFFMUQsZ0JBQWUsd0JBQXdCLHNEQUFzRCxFQUFFO0FBQy9GLDJCQUEwQiwyQkFBMkIsR0FBRzs7QUFFeEQsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsMkJBQTBCLHdCQUF3QixHQUFHOztBQUVyRCxnQkFBZSwwQkFBMEIsd0NBQXdDLEVBQUU7QUFDbkYsMkJBQTBCLG9CQUFvQixHQUFHOztBQUVqRCxnQkFBZSwwQkFBMEIsd0RBQXdELEVBQUU7QUFDbkcsMkJBQTBCLDBCQUEwQixHQUFHOztBQUV2RCw4QkFBNkIsMkJBQTJCLEVBQUU7QUFDMUQsOEJBQTZCLDJCQUEyQixFQUFFOztBQUUxRCxnQkFBZSx3QkFBd0Isc0NBQXNDLEVBQUU7QUFDL0UsMkJBQTBCLG9CQUFvQixHQUFHOztBQUVqRCxhQUFZLEdBQUcsd0JBQXdCLG9DQUFvQyxFQUFFLEVBQUU7QUFDL0UsMkJBQTBCLG9CQUFvQixHQUFHOztBQUVqRCxnQkFBZSx3QkFBd0Isc0NBQXNDLEVBQUU7QUFDL0UsMkJBQTBCLG9CQUFvQixHQUFHO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEI7O0FBRTFCLHdDQUF1QztBQUN2QyxzQ0FBcUM7QUFDckMsdURBQXNEO0FBQ3RELDBDQUF5QztBQUN6QyxnQ0FBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQSxtREFBa0QsOEJBQThCLEVBQUU7QUFDbEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNFQUFxRSxTQUFTO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBa0UsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUEsRUFBQyxHOzs7Ozs7O0FDcFdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWlDLG9FQUFvRTtBQUNyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUYsRUFBQyxHOzs7Ozs7QUMvQkQ7QUFDQSxvQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBK0I7QUFDL0IsaUNBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7OztBQUlBLHdDQUF1Qyx1QkFBdUI7QUFDOUQsMkNBQTBDLG9CQUFvQixhQUFhOzs7O0FBSTNFLHdDQUF1Qyx1QkFBdUI7QUFDOUQsMkNBQTBDLG9CQUFvQixhQUFhOzs7QUFHM0UsdUNBQXNDLHNCQUFzQjtBQUM1RCwwQ0FBeUMsbUJBQW1CLGFBQWE7OztBQUd6RSxxQ0FBb0Msb0JBQW9CO0FBQ3hELHdDQUF1QyxpQkFBaUIsYUFBYTs7O0FBR3JFLHNDQUFxQyxxQkFBcUI7QUFDMUQseUNBQXdDLGtCQUFrQixhQUFhOzs7QUFHdkUseUNBQXdDLHdCQUF3QjtBQUNoRSw0Q0FBMkMscUJBQXFCLGFBQWE7O0FBRTdFLGdDQUErQjtBQUMvQix5Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQSxnQkFBZSxxQkFBcUI7QUFDcEMsZ0JBQWU7QUFDZjtBQUNBOzs7QUFHQSxxQ0FBb0Msb0JBQW9CO0FBQ3hELHdDQUF1QyxpQkFBaUIsYUFBYTs7O0FBR3JFLHNDQUFxQyxxQkFBcUI7QUFDMUQseUNBQXdDLGtCQUFrQixhQUFhOzs7QUFHdkUsd0NBQXVDLHVCQUF1QjtBQUM5RCwyQ0FBMEMsb0JBQW9CLGFBQWE7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXdELGdDQUFnQyxFQUFFO0FBQzFGLHdEQUF1RCxnQ0FBZ0MsRUFBRTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0EscURBQW9ELFdBQVc7QUFDL0QsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsd0JBQXdCLEVBQUU7QUFDbkUsK0JBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRUFBaUUsZUFBZTtBQUNoRixLQUFJO0FBQ0o7QUFDQSx1REFBc0QsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxnQkFBZTtBQUNmO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QiwyQ0FBMkM7QUFDdkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE2QjtBQUM3Qiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUVBQXdFLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUErRCxTQUFTO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQW9CLFdBQVc7O0FBRS9CLG1FQUFrRSxTQUFTO0FBQzNFO0FBQ0E7O0FBRUEsOERBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUE4QjtBQUM5QixLQUFJOztBQUVKLHNDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQyxXQUFXO0FBQ2hELEtBQUksWUFBWTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTRCLFlBQVk7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQStELFNBQVM7QUFDeEUsc0VBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTBELG1DQUFtQyxFQUFFOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBa0UsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBLGdFQUErRCxTQUFTO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF1QyxVQUFVO0FBQ2pELHlFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBOEIsV0FBVztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUErRCxVQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWdFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0IsSUFBSSxJQUFJLElBQUkscUJBQXFCLEVBQUUsSUFBSSxFQUFFO0FBQy9EOztBQUVBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBdUI7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7O0FBR0Y7O0FBRUEsRUFBQyxHOzs7Ozs7QUNydENEO0FBQ0Esb0JBQW1CLCtDQUErQzs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUF5Qjs7O0FBR3pCLHNDQUFxQyxtQkFBbUI7QUFDeEQseUNBQXdDLGdCQUFnQixhQUFhOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUErRCxVQUFVO0FBQ3pFO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDeElEO0FBQ0Esb0JBQW1CLCtDQUErQztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6Qix5REFBd0QsK0JBQStCLEVBQUU7QUFDekY7QUFDQTs7QUFFQSw4QkFBNkI7OztBQUc3Qix3Q0FBdUMsbUJBQW1CO0FBQzFELDJDQUEwQyxnQkFBZ0IsYUFBYTs7O0FBR3ZFLDBDQUF5QyxxQkFBcUI7QUFDOUQsNkNBQTRDLGtCQUFrQixhQUFhOzs7QUFHM0UsMENBQXlDLHFCQUFxQjtBQUM5RCw2Q0FBNEMsa0JBQWtCLGFBQWE7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixnQ0FBZ0M7QUFDckQsSUFBRztBQUNIO0FBQ0E7QUFDQSw2Q0FBNEMsU0FBUztBQUNyRDtBQUNBLGlEQUFnRDtBQUNoRDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCLGFBQWEsRUFBRTtBQUMxQztBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLGlEQUFpRDtBQUM1RTtBQUNBO0FBQ0E7OztBQUdBLEVBQUMsRzs7Ozs7O0FDN0hEO0FBQ0Esb0JBQW1CLCtDQUErQztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7OztBQUlBLG9DQUFtQyxtQkFBbUI7QUFDdEQsdUNBQXNDLGdCQUFnQixhQUFhOzs7QUFHbkUsc0NBQXFDLHFCQUFxQjtBQUMxRCx5Q0FBd0Msa0JBQWtCLGFBQWE7OztBQUd2RSxzQ0FBcUMscUJBQXFCO0FBQzFELHlDQUF3QyxrQkFBa0IsYUFBYTs7QUFFdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDdk9EO0FBQ0Esb0JBQW1CLCtDQUErQztBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLHFDQUFvQyxrQkFBa0I7QUFDdEQsd0NBQXVDLGVBQWUsYUFBYTs7O0FBR25FLHFDQUFvQyxrQkFBa0I7QUFDdEQsd0NBQXVDLGVBQWUsYUFBYTs7O0FBR25FLHVDQUFzQyxvQkFBb0I7QUFDMUQsMENBQXlDLGlCQUFpQixhQUFhOztBQUV2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWlFLGFBQWE7QUFDOUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEIsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBLHNDQUFxQyxxQkFBcUI7QUFDMUQseUNBQXdDLGtCQUFrQixhQUFhOzs7QUFHdkUsb0NBQW1DLG1CQUFtQjtBQUN0RCx1Q0FBc0MsZ0JBQWdCLGFBQWE7OztBQUduRSxxQ0FBb0Msb0JBQW9CO0FBQ3hELHdDQUF1QyxpQkFBaUIsYUFBYTs7O0FBR3JFLHNDQUFxQyxxQkFBcUI7QUFDMUQseUNBQXdDLGtCQUFrQixhQUFhOztBQUV2RSwyQkFBMEI7QUFDMUIsb0NBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0EsZ0JBQWUsZ0JBQWdCO0FBQy9CLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQSwwQkFBeUI7QUFDekIsbUNBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0EsZ0JBQWUsZUFBZTtBQUM5QixnQkFBZTtBQUNmO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCLDBCQUF5QjtBQUN6QixtQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxnQkFBZSxlQUFlO0FBQzlCLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOzs7QUFHQSxxQ0FBb0Msb0JBQW9CO0FBQ3hELHdDQUF1QyxpQkFBaUIsYUFBYTs7OztBQUlyRSxvQ0FBbUMsbUJBQW1CO0FBQ3RELHVDQUFzQyxnQkFBZ0IsYUFBYSxHQUFHOzs7QUFHdEUsb0NBQW1DLG1CQUFtQjtBQUN0RCx1Q0FBc0MsZ0JBQWdCLGFBQWE7OztBQUduRSxvQ0FBbUMsbUJBQW1CO0FBQ3RELHVDQUFzQyxnQkFBZ0IsYUFBYTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CO0FBQ25CLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRCxlQUFlLEVBQUU7QUFDdkU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixrQkFBa0I7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTs7QUFFYjtBQUNBOztBQUVBLHlCQUF3QjtBQUN4Qix5QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFhLHVEQUF1RDtBQUNwRTtBQUNBLHFCQUFvQixrRkFBa0Y7QUFDdEcscUJBQW9CLDJDQUEyQztBQUMvRCxtQkFBa0Isd0JBQXdCOztBQUUxQztBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0Esc0JBQXFCLHdCQUF3QjtBQUM3QyxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsRUFBQyxHOzs7Ozs7QUNsc0JEOztBQUVBOzs7QUFHQSxvQ0FBbUMsbUJBQW1CO0FBQ3RELHVDQUFzQyxnQkFBZ0IsYUFBYTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7O0FBR0Esb0NBQW1DLG1CQUFtQjtBQUN0RCx1Q0FBc0MsZ0JBQWdCLGFBQWE7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGLEVBQUMsRzs7Ozs7O0FDL0JEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRixFQUFDLEc7Ozs7OztBQ3pERDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQywwQkFBMEIsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDM0NEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDWEQ7QUFDQSxvQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTJDLHdCQUF3QjtBQUNuRTtBQUNBOztBQUVBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsMkNBQTJDO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSyxnREFBZ0Q7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QSxLQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7OztBQUdGLEVBQUMsRzs7Ozs7O0FDdkREOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsRUFBQyxHOzs7Ozs7QUNuRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUYsRUFBQyxHOzs7Ozs7QUNwQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLEVBQUU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQiw4QkFBOEI7QUFDL0Msa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLGtCQUFpQiw2QkFBNkI7QUFDOUM7O0FBRUE7QUFDQSxvQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQWtDLGtCQUFrQjtBQUNwRCx5QkFBd0I7QUFDeEIseUJBQXdCO0FBQ3hCLDJCQUEwQjtBQUMxQiwwQkFBeUI7QUFDekI7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0IsNEJBQTRCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNELHNCQUFxQixlQUFl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QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixFQUFDLEciLCJmaWxlIjoiLi93d3cvY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA0MGI3MzNhN2Y0OGYzOWQ5MDI4NFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRyZXF1aXJlKCdpbWJhL2xpYi9pbWJhL2Jyb3dzZXInKTtcblx0XG5cdC8vIG5lZWQgdG8gdXNlIHdlYnBhY2sgZm9yIHRoaXMgaW5jbHVkZSB0byB3b3JrIGFzIGludGVuZGVkXG5cdFNjcmltYmxhID0gcmVxdWlyZSgnc2NyaW1ibGEvc3JjL2luZGV4Jyk7XG5cdFxuXHR2YXIgQXBwID0gcmVxdWlyZSgnLi9hcHAnKS5BcHA7XG5cdEFQUCA9IG5ldyBBcHAoKTtcblx0QVBQLnNjaGVkdWxlKCk7XG5cdFxuXHRyZXF1aXJlKCcuL3ZpZXdzJyk7XG5cdFxuXHQvLyBhd2FrZW4gcGFnZXMgZXRjXG5cdHEkKCcuX3BhZ2UnKS5tYXAoZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsOyB9KTtcblx0cmV0dXJuIHEkKCcuYXdha2VuJykubWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbDsgfSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NsaWVudC5pbWJhXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRpZiAodHlwZW9mIEltYmEgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmVxdWlyZSgnLi9pbWJhJyk7XG5cdFx0XG5cdFx0SW1iYS5DTElFTlQgPSB0cnVlO1xuXHRcdFxuXHRcdHJlcXVpcmUoJy4vY29yZS5ldmVudHMnKTtcblx0XHRyZXF1aXJlKCcuL3NjaGVkdWxlcicpO1xuXHRcdHJlcXVpcmUoJy4vdGFnJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20nKTtcblx0XHRyZXF1aXJlKCcuL2RvbS5jbGllbnQnKTtcblx0XHRyZXF1aXJlKCcuL2RvbS5odG1sJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uc3ZnJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20ubGVnYWN5Jyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uZXZlbnRzJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uc3RhdGljJyk7XG5cdFx0cmV0dXJuIHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gY29uc29sZS53YXJuKFwiSW1iYSBpcyBhbHJlYWR5IGxvYWRlZFwiKTtcblx0fTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGV4dGVybnM7XG5cdFxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRnbG9iYWwgPSB3aW5kb3c7XG5cdH07XG5cdFxuXHQvKlxuXHRJbWJhIGlzIHRoZSBuYW1lc3BhY2UgZm9yIGFsbCBydW50aW1lIHJlbGF0ZWQgdXRpbGl0aWVzXG5cdEBuYW1lc3BhY2Vcblx0Ki9cblx0XG5cdEltYmEgPSB7XG5cdFx0VkVSU0lPTjogJzAuMTQuMScsXG5cdFx0REVCVUc6IGZhbHNlXG5cdH07XG5cdFxuXHR2YXIgcmVnID0gLy0uL2c7XG5cdFxuXHQvKlxuXHRUcnVlIGlmIHJ1bm5pbmcgaW4gY2xpZW50IGVudmlyb25tZW50LlxuXHRAcmV0dXJuIHtib29sfVxuXHQqL1xuXHRcblx0SW1iYS5pc0NsaWVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBJbWJhLkNMSUVOVCA9PT0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qXG5cdFRydWUgaWYgcnVubmluZyBpbiBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5cdEByZXR1cm4ge2Jvb2x9XG5cdCovXG5cdFxuXHRJbWJhLmlzU2VydmVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIEltYmEuU0VSVkVSID09PSB0cnVlO1xuXHR9O1xuXHRcblx0SW1iYS5zdWJjbGFzcyA9IGZ1bmN0aW9uIChvYmosc3VwKXtcblx0XHQ7XG5cdFx0Zm9yICh2YXIgayBpbiBzdXApe1xuXHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgeyBvYmpba10gPSBzdXBba10gfTtcblx0XHR9O1xuXHRcdFxuXHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0XHRyZXR1cm4gb2JqO1xuXHR9O1xuXHRcblx0Lypcblx0TGlnaHR3ZWlnaHQgbWV0aG9kIGZvciBtYWtpbmcgYW4gb2JqZWN0IGl0ZXJhYmxlIGluIGltYmFzIGZvci9pbiBsb29wcy5cblx0SWYgdGhlIGNvbXBpbGVyIGNhbm5vdCBzYXkgZm9yIGNlcnRhaW4gdGhhdCBhIHRhcmdldCBpbiBhIGZvciBsb29wIGlzIGFuXG5cdGFycmF5LCBpdCB3aWxsIGNhY2hlIHRoZSBpdGVyYWJsZSB2ZXJzaW9uIGJlZm9yZSBsb29waW5nLlxuXHRcblx0YGBgaW1iYVxuXHQjIHRoaXMgaXMgdGhlIHdob2xlIG1ldGhvZFxuXHRkZWYgSW1iYS5pdGVyYWJsZSBvXG5cdFx0cmV0dXJuIG8gPyAobzp0b0FycmF5ID8gby50b0FycmF5IDogbykgOiBbXVxuXHRcblx0Y2xhc3MgQ3VzdG9tSXRlcmFibGVcblx0XHRkZWYgdG9BcnJheVxuXHRcdFx0WzEsMiwzXVxuXHRcblx0IyB3aWxsIHJldHVybiBbMiw0LDZdXG5cdGZvciB4IGluIEN1c3RvbUl0ZXJhYmxlLm5ld1xuXHRcdHggKiAyXG5cdFxuXHRgYGBcblx0Ki9cblx0XG5cdEltYmEuaXRlcmFibGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuIG8gPyAoKG8udG9BcnJheSA/IChvLnRvQXJyYXkoKSkgOiAobykpKSA6IChbXSk7XG5cdH07XG5cdFxuXHQvKlxuXHRDb2VyY2VzIGEgdmFsdWUgaW50byBhIHByb21pc2UuIElmIHZhbHVlIGlzIGFycmF5IGl0IHdpbGxcblx0Y2FsbCBgUHJvbWlzZS5hbGwodmFsdWUpYCwgb3IgaWYgaXQgaXMgbm90IGEgcHJvbWlzZSBpdCB3aWxsXG5cdHdyYXAgdGhlIHZhbHVlIGluIGBQcm9taXNlLnJlc29sdmUodmFsdWUpYC4gVXNlZCBmb3IgZXhwZXJpbWVudGFsXG5cdGF3YWl0IHN5bnRheC5cblx0QHJldHVybiB7UHJvbWlzZX1cblx0Ki9cblx0XG5cdEltYmEuYXdhaXQgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUudGhlbikge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0SW1iYS50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHJldHVybiBzdHIucmVwbGFjZShyZWcsZnVuY3Rpb24obSkgeyByZXR1cm4gbS5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTsgfSk7XG5cdH07XG5cdFxuXHRJbWJhLnRvQ2FtZWxDYXNlID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKHJlZyxmdW5jdGlvbihtKSB7IHJldHVybiBtLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpOyB9KTtcblx0fTtcblx0XG5cdEltYmEuaW5kZXhPZiA9IGZ1bmN0aW9uIChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gKGIuaW5kZXhPZihhKSkgOiAoW10uaW5kZXhPZi5jYWxsKGEsYikpO1xuXHR9O1xuXHRcblx0SW1iYS5wcm9wID0gZnVuY3Rpb24gKHNjb3BlLG5hbWUsb3B0cyl7XG5cdFx0aWYgKHNjb3BlLmRlZmluZVByb3BlcnR5KSB7XG5cdFx0XHRyZXR1cm4gc2NvcGUuZGVmaW5lUHJvcGVydHkobmFtZSxvcHRzKTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdHJldHVybiBJbWJhLmF0dHIgPSBmdW5jdGlvbiAoc2NvcGUsbmFtZSxvcHRzKXtcblx0XHRpZiAoc2NvcGUuZGVmaW5lQXR0cmlidXRlKSB7XG5cdFx0XHRyZXR1cm4gc2NvcGUuZGVmaW5lQXR0cmlidXRlKG5hbWUsb3B0cyk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgZ2V0TmFtZSA9IEltYmEudG9DYW1lbENhc2UobmFtZSk7XG5cdFx0dmFyIHNldE5hbWUgPSBJbWJhLnRvQ2FtZWxDYXNlKCdzZXQtJyArIG5hbWUpO1xuXHRcdFxuXHRcdHNjb3BlLnByb3RvdHlwZVtnZXROYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0c2NvcGUucHJvdG90eXBlW3NldE5hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsdmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvaW1iYS5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0XG5cdGZ1bmN0aW9uIGVtaXRfXyhldmVudCxhcmdzLG5vZGUpe1xuXHRcdC8vIHZhciBub2RlID0gY2JzW2V2ZW50XVxuXHRcdHZhciBwcmV2LGNiLHJldDtcblx0XHRcblx0XHR3aGlsZSAoKHByZXYgPSBub2RlKSAmJiAobm9kZSA9IG5vZGUubmV4dCkpe1xuXHRcdFx0aWYgKGNiID0gbm9kZS5saXN0ZW5lcikge1xuXHRcdFx0XHRpZiAobm9kZS5wYXRoICYmIGNiW25vZGUucGF0aF0pIHtcblx0XHRcdFx0XHRyZXQgPSBhcmdzID8gKGNiW25vZGUucGF0aF0uYXBwbHkoY2IsYXJncykpIDogKGNiW25vZGUucGF0aF0oKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgaXQgaXMgYSBtZXRob2Q/XG5cdFx0XHRcdFx0cmV0ID0gYXJncyA/IChjYi5hcHBseShub2RlLGFyZ3MpKSA6IChjYi5jYWxsKG5vZGUpKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChub2RlLnRpbWVzICYmIC0tbm9kZS50aW1lcyA8PSAwKSB7XG5cdFx0XHRcdHByZXYubmV4dCA9IG5vZGUubmV4dDtcblx0XHRcdFx0bm9kZS5saXN0ZW5lciA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gbWV0aG9kIGZvciByZWdpc3RlcmluZyBhIGxpc3RlbmVyIG9uIG9iamVjdFxuXHRJbWJhLmxpc3RlbiA9IGZ1bmN0aW9uIChvYmosZXZlbnQsbGlzdGVuZXIscGF0aCl7XG5cdFx0dmFyICQxO1xuXHRcdHZhciBjYnMsbGlzdCx0YWlsO1xuXHRcdGNicyA9IG9iai5fX2xpc3RlbmVyc19fIHx8IChvYmouX19saXN0ZW5lcnNfXyA9IHt9KTtcblx0XHRsaXN0ID0gY2JzWygkMSA9IGV2ZW50KV0gfHwgKGNic1skMV0gPSB7fSk7XG5cdFx0dGFpbCA9IGxpc3QudGFpbCB8fCAobGlzdC50YWlsID0gKGxpc3QubmV4dCA9IHt9KSk7XG5cdFx0dGFpbC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuXHRcdHRhaWwucGF0aCA9IHBhdGg7XG5cdFx0bGlzdC50YWlsID0gdGFpbC5uZXh0ID0ge307XG5cdFx0cmV0dXJuIHRhaWw7XG5cdH07XG5cdFxuXHRJbWJhLm9uY2UgPSBmdW5jdGlvbiAob2JqLGV2ZW50LGxpc3RlbmVyKXtcblx0XHR2YXIgdGFpbCA9IEltYmEubGlzdGVuKG9iaixldmVudCxsaXN0ZW5lcik7XG5cdFx0dGFpbC50aW1lcyA9IDE7XG5cdFx0cmV0dXJuIHRhaWw7XG5cdH07XG5cdFxuXHRJbWJhLnVubGlzdGVuID0gZnVuY3Rpb24gKG9iaixldmVudCxjYixtZXRoKXtcblx0XHR2YXIgbm9kZSxwcmV2O1xuXHRcdHZhciBtZXRhID0gb2JqLl9fbGlzdGVuZXJzX187XG5cdFx0aWYgKCFtZXRhKSB7IHJldHVybiB9O1xuXHRcdFxuXHRcdGlmIChub2RlID0gbWV0YVtldmVudF0pIHtcblx0XHRcdHdoaWxlICgocHJldiA9IG5vZGUpICYmIChub2RlID0gbm9kZS5uZXh0KSl7XG5cdFx0XHRcdGlmIChub2RlID09IGNiIHx8IG5vZGUubGlzdGVuZXIgPT0gY2IpIHtcblx0XHRcdFx0XHRwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNvcnJlY3QgcGF0aCBhcyB3ZWxsP1xuXHRcdFx0XHRcdG5vZGUubGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdEltYmEuZW1pdCA9IGZ1bmN0aW9uIChvYmosZXZlbnQscGFyYW1zKXtcblx0XHR2YXIgY2I7XG5cdFx0aWYgKGNiID0gb2JqLl9fbGlzdGVuZXJzX18pIHtcblx0XHRcdGlmIChjYltldmVudF0pIHsgZW1pdF9fKGV2ZW50LHBhcmFtcyxjYltldmVudF0pIH07XG5cdFx0XHRpZiAoY2IuYWxsKSB7IGVtaXRfXyhldmVudCxbZXZlbnQscGFyYW1zXSxjYi5hbGwpIH07IC8vIGFuZCBldmVudCAhPSAnYWxsJ1xuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0cmV0dXJuIEltYmEub2JzZXJ2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9ic2VydmVyLGtleSx0cmlnZ2VyLHRhcmdldCxwcmV2KXtcblx0XHRpZiAocHJldiAmJiB0eXBlb2YgcHJldiA9PSAnb2JqZWN0Jykge1xuXHRcdFx0SW1iYS51bmxpc3RlbihwcmV2LCdhbGwnLG9ic2VydmVyLHRyaWdnZXIpO1xuXHRcdH07XG5cdFx0aWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09ICdvYmplY3QnKSB7XG5cdFx0XHRJbWJhLmxpc3Rlbih0YXJnZXQsJ2FsbCcsb2JzZXJ2ZXIsdHJpZ2dlcik7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9jb3JlLmV2ZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgcmFmOyAvLyB2ZXJ5IHNpbXBsZSByYWYgcG9seWZpbGxcblx0cmFmIHx8IChyYWYgPSBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcblx0cmFmIHx8IChyYWYgPSBnbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcblx0cmFmIHx8IChyYWYgPSBnbG9iYWwubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcblx0cmFmIHx8IChyYWYgPSBmdW5jdGlvbihibGspIHsgcmV0dXJuIHNldFRpbWVvdXQoYmxrLDEwMDAgLyA2MCk7IH0pO1xuXHRcblx0SW1iYS50aWNrID0gZnVuY3Rpb24gKGQpe1xuXHRcdGlmICh0aGlzLl9zY2hlZHVsZWQpIHsgcmFmKEltYmEudGlja2VyKCkpIH07XG5cdFx0dGhpcy5lbWl0KHRoaXMsJ3RpY2snLFtkXSk7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0SW1iYS50aWNrZXIgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0cmV0dXJuIHNlbGYuX3RpY2tlciB8fCAoc2VsZi5fdGlja2VyID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi50aWNrKGUpOyB9KTtcblx0fTtcblx0XG5cdC8qXG5cdFxuXHRHbG9iYWwgYWx0ZXJuYXRpdmUgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBTY2hlZHVsZSBhIHRhcmdldFxuXHR0byB0aWNrIGV2ZXJ5IGZyYW1lLiBZb3UgY2FuIHNwZWNpZnkgd2hpY2ggbWV0aG9kIHRvIGNhbGwgb24gdGhlXG5cdHRhcmdldCAoZGVmYXVsdHMgdG8gdGljaykuXG5cdFxuXHQqL1xuXHRcblx0SW1iYS5zY2hlZHVsZSA9IGZ1bmN0aW9uICh0YXJnZXQsbWV0aG9kKXtcblx0XHRpZihtZXRob2QgPT09IHVuZGVmaW5lZCkgbWV0aG9kID0gJ3RpY2snO1xuXHRcdHRoaXMubGlzdGVuKHRoaXMsJ3RpY2snLHRhcmdldCxtZXRob2QpO1xuXHRcdC8vIHN0YXJ0IHNjaGVkdWxpbmcgbm93IGlmIHRoaXMgd2FzIHRoZSBmaXJzdCBvbmVcblx0XHRpZiAoIXRoaXMuX3NjaGVkdWxlZCkge1xuXHRcdFx0dGhpcy5fc2NoZWR1bGVkID0gdHJ1ZTtcblx0XHRcdHJhZihJbWJhLnRpY2tlcigpKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdFVuc2NoZWR1bGUgYSBwcmV2aW91c2x5IHNjaGVkdWxlZCB0YXJnZXRcblx0XG5cdCovXG5cdFxuXHRJbWJhLnVuc2NoZWR1bGUgPSBmdW5jdGlvbiAodGFyZ2V0LG1ldGhvZCl7XG5cdFx0dGhpcy51bmxpc3Rlbih0aGlzLCd0aWNrJyx0YXJnZXQsbWV0aG9kKTtcblx0XHR2YXIgY2JzID0gdGhpcy5fX2xpc3RlbmVyc19fIHx8ICh0aGlzLl9fbGlzdGVuZXJzX18gPSB7fSk7XG5cdFx0aWYgKCFjYnMudGljayB8fCAhY2JzLnRpY2submV4dCB8fCAhY2JzLnRpY2submV4dC5saXN0ZW5lcikge1xuXHRcdFx0dGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFxuXHRMaWdodCB3cmFwcGVyIGFyb3VuZCBuYXRpdmUgc2V0VGltZW91dCB0aGF0IGV4cGVjdHMgdGhlIGJsb2NrIC8gZnVuY3Rpb25cblx0YXMgbGFzdCBhcmd1bWVudCAoaW5zdGVhZCBvZiBmaXJzdCkuIEl0IGFsc28gdHJpZ2dlcnMgYW4gZXZlbnQgdG8gSW1iYVxuXHRhZnRlciB0aGUgdGltZW91dCB0byBsZXQgc2NoZWR1bGVycyB1cGRhdGUgKHRvIHJlcmVuZGVyIGV0YykgYWZ0ZXJ3YXJkcy5cblx0XG5cdCovXG5cdFxuXHRJbWJhLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoZGVsYXksYmxvY2spe1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0YmxvY2soKTtcblx0XHRcdHJldHVybiBJbWJhLmVtaXQoSW1iYSwndGltZW91dCcsW2Jsb2NrXSk7XG5cdFx0fSxkZWxheSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0TGlnaHQgd3JhcHBlciBhcm91bmQgbmF0aXZlIHNldEludGVydmFsIHRoYXQgZXhwZWN0cyB0aGUgYmxvY2sgLyBmdW5jdGlvblxuXHRhcyBsYXN0IGFyZ3VtZW50IChpbnN0ZWFkIG9mIGZpcnN0KS4gSXQgYWxzbyB0cmlnZ2VycyBhbiBldmVudCB0byBJbWJhXG5cdGFmdGVyIGV2ZXJ5IGludGVydmFsIHRvIGxldCBzY2hlZHVsZXJzIHVwZGF0ZSAodG8gcmVyZW5kZXIgZXRjKSBhZnRlcndhcmRzLlxuXHRcblx0Ki9cblx0XG5cdEltYmEuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwsYmxvY2spe1xuXHRcdHJldHVybiBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblx0XHRcdGJsb2NrKCk7XG5cdFx0XHRyZXR1cm4gSW1iYS5lbWl0KEltYmEsJ2ludGVydmFsJyxbYmxvY2tdKTtcblx0XHR9LGludGVydmFsKTtcblx0fTtcblx0XG5cdC8qXG5cdENsZWFyIGludGVydmFsIHdpdGggc3BlY2lmaWVkIGlkXG5cdCovXG5cdFxuXHRJbWJhLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpe1xuXHRcdHJldHVybiBjbGVhckludGVydmFsKGludGVydmFsKTtcblx0fTtcblx0XG5cdC8qXG5cdENsZWFyIHRpbWVvdXQgd2l0aCBzcGVjaWZpZWQgaWRcblx0Ki9cblx0XG5cdEltYmEuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKHRpbWVvdXQpe1xuXHRcdHJldHVybiBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdH07XG5cdFxuXHQvLyBzaG91bGQgYWRkIGFuIEltYmEucnVuIC8gc2V0SW1tZWRpYXRlIHRoYXRcblx0Ly8gcHVzaGVzIGxpc3RlbmVyIG9udG8gdGhlIHRpY2stcXVldWUgd2l0aCB0aW1lcyAtIG9uY2Vcblx0XG5cdFxuXHQvKlxuXHRcblx0SW5zdGFuY2VzIG9mIEltYmEuU2NoZWR1bGVyIG1hbmFnZXMgd2hlbiB0byBjYWxsIGB0aWNrKClgIG9uIHRoZWlyIHRhcmdldCxcblx0YXQgYSBzcGVjaWZpZWQgZnJhbWVyYXRlIG9yIHdoZW4gY2VydGFpbiBldmVudHMgb2NjdXIuIFJvb3Qtbm9kZXMgaW4geW91clxuXHRhcHBsaWNhdGlvbnMgd2lsbCB1c3VhbGx5IGhhdmUgYSBzY2hlZHVsZXIgdG8gbWFrZSBzdXJlIHRoZXkgcmVyZW5kZXIgd2hlblxuXHRzb21ldGhpbmcgY2hhbmdlcy4gSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBtYWtlIGlubmVyIGNvbXBvbmVudHMgdXNlIHRoZWlyXG5cdG93biBzY2hlZHVsZXJzIHRvIGNvbnRyb2wgd2hlbiB0aGV5IHJlbmRlci5cblx0XG5cdEBpbmFtZSBzY2hlZHVsZXJcblx0XG5cdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlciA9IGZ1bmN0aW9uIFNjaGVkdWxlcih0YXJnZXQpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLl90YXJnZXQgPSB0YXJnZXQ7XG5cdFx0c2VsZi5fbWFya2VkID0gZmFsc2U7XG5cdFx0c2VsZi5fYWN0aXZlID0gZmFsc2U7XG5cdFx0c2VsZi5fbWFya2VyID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm1hcmsoKTsgfTtcblx0XHRzZWxmLl90aWNrZXIgPSBmdW5jdGlvbihlKSB7IHJldHVybiBzZWxmLnRpY2soZSk7IH07XG5cdFx0XG5cdFx0c2VsZi5fZXZlbnRzID0gdHJ1ZTtcblx0XHRzZWxmLl9mcHMgPSAxO1xuXHRcdFxuXHRcdHNlbGYuX2R0ID0gMDtcblx0XHRzZWxmLl90aW1lc3RhbXAgPSAwO1xuXHRcdHNlbGYuX3RpY2tzID0gMDtcblx0XHRzZWxmLl9mbHVzaGVzID0gMDtcblx0fTtcblx0XG5cdC8qXG5cdFx0Q3JlYXRlIGEgbmV3IEltYmEuU2NoZWR1bGVyIGZvciBzcGVjaWZpZWQgdGFyZ2V0XG5cdFx0QHJldHVybiB7SW1iYS5TY2hlZHVsZXJ9XG5cdFx0Ki9cblx0XG5cdC8qXG5cdFx0Q2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBzY2hlZHVsZXIgaXMgYWN0aXZlIG9yIG5vdFxuXHRcdEByZXR1cm4ge2Jvb2x9XG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlO1xuXHR9O1xuXHRcblx0Lypcblx0XHREZWx0YSB0aW1lIGJldHdlZW4gdGhlIHR3byBsYXN0IHRpY2tzXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUuZHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZHQ7XG5cdH07XG5cdFxuXHQvKlxuXHRcdERlbHRhIHRpbWUgYmV0d2VlbiB0aGUgdHdvIGxhc3QgdGlja3Ncblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocGFycyl7XG5cdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdHZhciBmcHMgPSBwYXJzLmZwcyAhPT0gdW5kZWZpbmVkID8gcGFycy5mcHMgOiAxO1xuXHRcdHZhciBldmVudHMgPSBwYXJzLmV2ZW50cyAhPT0gdW5kZWZpbmVkID8gcGFycy5ldmVudHMgOiB0cnVlO1xuXHRcdGlmIChldmVudHMgIT0gbnVsbCkgeyB0aGlzLl9ldmVudHMgPSBldmVudHMgfTtcblx0XHRpZiAoZnBzICE9IG51bGwpIHsgdGhpcy5fZnBzID0gZnBzIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBkZWYgcmVzY2hlZHVsZVxuXHQvLyBcdHJhZihAdGlja2VyKVxuXHQvLyBcdHNlbGZcblx0XG5cdC8qXG5cdFx0TWFyayB0aGUgc2NoZWR1bGVyIGFzIGRpcnR5LiBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXRcblx0XHR0aGUgc2NoZWR1bGVyIGNhbGxzIGB0YXJnZXQudGlja2Agb24gdGhlIG5leHQgZnJhbWVcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX21hcmtlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEluc3RhbnRseSB0cmlnZ2VyIHRhcmdldC50aWNrIGFuZCBtYXJrIHNjaGVkdWxlciBhcyBjbGVhbiAobm90IGRpcnR5L21hcmtlZCkuXG5cdFx0VGhpcyBpcyBjYWxsZWQgaW1wbGljaXRseSBmcm9tIHRpY2ssIGJ1dCBjYW4gYWxzbyBiZSBjYWxsZWQgbWFudWFsbHkgaWYgeW91XG5cdFx0cmVhbGx5IHdhbnQgdG8gZm9yY2UgYSB0aWNrIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIG5leHQgZnJhbWUuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fbWFya2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fZmx1c2hlcysrO1xuXHRcdHRoaXMuX3RhcmdldC50aWNrKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEBmaXhtZSB0aGlzIGV4cGVjdHMgcmFmIHRvIHJ1biBhdCA2MCBmcHMgXG5cdFxuXHRcdENhbGxlZCBhdXRvbWF0aWNhbGx5IG9uIGV2ZXJ5IGZyYW1lIHdoaWxlIHRoZSBzY2hlZHVsZXIgaXMgYWN0aXZlLlxuXHRcdEl0IHdpbGwgb25seSBjYWxsIGB0YXJnZXQudGlja2AgaWYgdGhlIHNjaGVkdWxlciBpcyBtYXJrZWQgZGlydHksXG5cdFx0b3Igd2hlbiBhY2NvcmRpbmcgdG8gQGZwcyBzZXR0aW5nLlxuXHRcblx0XHRJZiB5b3UgaGF2ZSBzZXQgdXAgYSBzY2hlZHVsZXIgd2l0aCBhbiBmcHMgb2YgMSwgdGljayB3aWxsIHN0aWxsIGJlXG5cdFx0Y2FsbGVkIGV2ZXJ5IGZyYW1lLCBidXQgYHRhcmdldC50aWNrYCB3aWxsIG9ubHkgYmUgY2FsbGVkIG9uY2UgZXZlcnlcblx0XHRzZWNvbmQsIGFuZCBpdCB3aWxsICptYWtlIHN1cmUqIGVhY2ggYHRhcmdldC50aWNrYCBoYXBwZW5zIGluIHNlcGFyYXRlXG5cdFx0c2Vjb25kcyBhY2NvcmRpbmcgdG8gRGF0ZS4gU28gaWYgeW91IGhhdmUgYSBub2RlIHRoYXQgcmVuZGVycyBhIGNsb2NrXG5cdFx0YmFzZWQgb24gRGF0ZS5ub3cgKG9yIHNvbWV0aGluZyBzaW1pbGFyKSwgeW91IGNhbiBzY2hlZHVsZSBpdCB3aXRoIDFmcHMsXG5cdFx0bmV2ZXIgbmVlZGluZyB0byB3b3JyeSBhYm91dCB0d28gdGlja3MgaGFwcGVuaW5nIHdpdGhpbiB0aGUgc2FtZSBzZWNvbmQuXG5cdFx0VGhlIHNhbWUgZ29lcyBmb3IgNGZwcywgMTBmcHMgZXRjLlxuXHRcblx0XHRAcHJvdGVjdGVkXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoZGVsdGEpe1xuXHRcdHRoaXMuX3RpY2tzKys7XG5cdFx0dGhpcy5fZHQgPSBkZWx0YTtcblx0XHRcblx0XHR2YXIgZnBzID0gdGhpcy5fZnBzO1xuXHRcdFxuXHRcdGlmIChmcHMgPT0gNjApIHtcblx0XHRcdHRoaXMuX21hcmtlZCA9IHRydWU7XG5cdFx0fSBlbHNlIGlmIChmcHMgPT0gMzApIHtcblx0XHRcdGlmICh0aGlzLl90aWNrcyAlIDIpIHsgdGhpcy5fbWFya2VkID0gdHJ1ZSB9O1xuXHRcdH0gZWxzZSBpZiAoZnBzKSB7XG5cdFx0XHQvLyBpZiBpdCBpcyBsZXNzIHJvdW5kIC0gd2UgdHJpZ2dlciBiYXNlZFxuXHRcdFx0Ly8gb24gZGF0ZSwgZm9yIGNvbnNpc3RlbnQgcmVuZGVyaW5nLlxuXHRcdFx0Ly8gaWUsIGlmIHlvdSB3YW50IHRvIHJlbmRlciBldmVyeSBzZWNvbmRcblx0XHRcdC8vIGl0IGlzIGltcG9ydGFudCB0aGF0IG5vIHR3byByZW5kZXJzXG5cdFx0XHQvLyBoYXBwZW4gZHVyaW5nIHRoZSBzYW1lIHNlY29uZCAoYWNjb3JkaW5nIHRvIERhdGUpXG5cdFx0XHR2YXIgcGVyaW9kID0gKCg2MCAvIGZwcykgLyA2MCkgKiAxMDAwO1xuXHRcdFx0dmFyIGJlYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyBwZXJpb2QpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5fYmVhdCAhPSBiZWF0KSB7XG5cdFx0XHRcdHRoaXMuX2JlYXQgPSBiZWF0O1xuXHRcdFx0XHR0aGlzLl9tYXJrZWQgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9tYXJrZWQpIHRoaXMuZmx1c2goKTtcblx0XHQvLyByZXNjaGVkdWxlIGlmIEBhY3RpdmVcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U3RhcnQgdGhlIHNjaGVkdWxlciBpZiBpdCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG5cdFx0KipXaGlsZSBhY3RpdmUqKiwgdGhlIHNjaGVkdWxlciB3aWxsIG92ZXJyaWRlIGB0YXJnZXQuY29tbWl0YFxuXHRcdHRvIGRvIG5vdGhpbmcuIEJ5IGRlZmF1bHQgSW1iYS50YWcjY29tbWl0IGNhbGxzIHJlbmRlciwgc29cblx0XHR0aGF0IHJlbmRlcmluZyBpcyBjYXNjYWRlZCB0aHJvdWdoIHRvIGNoaWxkcmVuIHdoZW4gcmVuZGVyaW5nXG5cdFx0YSBub2RlLiBXaGVuIGEgc2NoZWR1bGVyIGlzIGFjdGl2ZSAoZm9yIGEgbm9kZSksIEltYmEgZGlzYWJsZXNcblx0XHR0aGlzIGF1dG9tYXRpYyByZW5kZXJpbmcuXG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXHRcdFx0Ly8gb3ZlcnJpZGUgdGFyZ2V0I2NvbW1pdCB3aGlsZSB0aGlzIGlzIGFjdGl2ZVxuXHRcdFx0dGhpcy5fY29tbWl0ID0gdGhpcy5fdGFyZ2V0LmNvbW1pdDtcblx0XHRcdHRoaXMuX3RhcmdldC5jb21taXQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XHRJbWJhLnNjaGVkdWxlKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMuX2V2ZW50cykgeyBJbWJhLmxpc3RlbihJbWJhLCdldmVudCcsdGhpcywnb25ldmVudCcpIH07XG5cdFx0XHR0aGlzLl90YXJnZXQgJiYgdGhpcy5fdGFyZ2V0LmZsYWcgICYmICB0aGlzLl90YXJnZXQuZmxhZygnc2NoZWR1bGVkXycpO1xuXHRcdFx0dGhpcy50aWNrKDApOyAvLyBzdGFydCB0aWNraW5nXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U3RvcCB0aGUgc2NoZWR1bGVyIGlmIGl0IGlzIGFjdGl2ZS5cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fYWN0aXZlKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3RhcmdldC5jb21taXQgPSB0aGlzLl9jb21taXQ7XG5cdFx0XHRJbWJhLnVuc2NoZWR1bGUodGhpcyk7XG5cdFx0XHRJbWJhLnVubGlzdGVuKEltYmEsJ2V2ZW50Jyx0aGlzKTtcblx0XHRcdHRoaXMuX3RhcmdldCAmJiB0aGlzLl90YXJnZXQudW5mbGFnICAmJiAgdGhpcy5fdGFyZ2V0LnVuZmxhZygnc2NoZWR1bGVkXycpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbWFya2VyO1xuXHR9O1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpe1xuXHRcdHZhciAkMTtcblx0XHRpZiAodGhpcy5fbWFya2VkKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2V2ZW50cyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRpZiAodGhpcy5fZXZlbnRzKGV2ZW50KSkgdGhpcy5tYXJrKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9ldmVudHMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0aWYgKGlkeCQoKCQxID0gZXZlbnQpICYmICQxLnR5cGUgICYmICAkMS50eXBlKCksdGhpcy5fZXZlbnRzKSA+PSAwKSB0aGlzLm1hcmsoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2V2ZW50cykge1xuXHRcdFx0aWYgKGV2ZW50Ll9yZXNwb25kZXIpIHRoaXMubWFyaygpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBJbWJhLlNjaGVkdWxlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9zY2hlZHVsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRJbWJhLnN0YXRpYyA9IGZ1bmN0aW9uIChpdGVtcyxucil7XG5cdFx0aXRlbXMuc3RhdGljID0gbnI7XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9O1xuXHRcblx0Lypcblx0VGhpcyBpcyB0aGUgYmFzZWNsYXNzIHRoYXQgYWxsIHRhZ3MgaW4gaW1iYSBpbmhlcml0IGZyb20uXG5cdEBpbmFtZSBub2RlXG5cdCovXG5cdFxuXHRJbWJhLlRhZyA9IGZ1bmN0aW9uIFRhZyhkb20pe1xuXHRcdHRoaXMuc2V0RG9tKGRvbSk7XG5cdH07XG5cdFxuXHRJbWJhLlRhZy5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhyb3cgXCJOb3QgaW1wbGVtZW50ZWRcIjtcblx0fTtcblx0XG5cdEltYmEuVGFnLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIG5ldyB0aGlzKHRoaXMuY3JlYXRlTm9kZSgpKTtcblx0fTtcblx0XG5cdFxuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLm9iamVjdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb2JqZWN0OyB9XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXRPYmplY3QgPSBmdW5jdGlvbih2KXsgdGhpcy5fb2JqZWN0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZG9tID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RvbTtcblx0fTtcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXREb20gPSBmdW5jdGlvbiAoZG9tKXtcblx0XHRkb20uX3RhZyA9IHRoaXM7XG5cdFx0dGhpcy5fZG9tID0gZG9tO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRTZXR0aW5nIHJlZmVyZW5jZXMgZm9yIHRhZ3MgbGlrZVxuXHRcdGA8ZGl2QGhlYWRlcj5gIHdpbGwgY29tcGlsZSB0byBgdGFnKCdkaXYnKS5zZXRSZWYoJ2hlYWRlcicsdGhpcykuZW5kKClgXG5cdFx0QnkgZGVmYXVsdCBpdCBhZGRzIHRoZSByZWZlcmVuY2UgYXMgYSBjbGFzc05hbWUgdG8gdGhlIHRhZy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0UmVmID0gZnVuY3Rpb24gKHJlZixjdHgpe1xuXHRcdHRoaXMuZmxhZyh0aGlzLl9yZWYgPSByZWYpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRNZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGNvbXBpbGVkIHRhZy1jaGFpbnMsIGZvclxuXHRcdGJpbmRpbmcgZXZlbnRzIG9uIHRhZ3MgdG8gbWV0aG9kcyBldGMuXG5cdFx0YDxhIDp0YXA9Zm4+YCBjb21waWxlcyB0byBgdGFnKCdhJykuc2V0SGFuZGxlcigndGFwJyxmbix0aGlzKS5lbmQoKWBcblx0XHR3aGVyZSB0aGlzIHJlZmVycyB0byB0aGUgY29udGV4dCBpbiB3aGljaCB0aGUgdGFnIGlzIGNyZWF0ZWQuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNldEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQsaGFuZGxlcixjdHgpe1xuXHRcdHZhciBrZXkgPSAnb24nICsgZXZlbnQ7XG5cdFx0XG5cdFx0aWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0dGhpc1trZXldID0gaGFuZGxlcjtcblx0XHR9IGVsc2UgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dmFyIGZuID0gaGFuZGxlci5zaGlmdCgpO1xuXHRcdFx0dGhpc1trZXldID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gY3R4W2ZuXS5hcHBseShjdHgsaGFuZGxlci5jb25jYXQoZSkpOyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW2tleV0gPSBmdW5jdGlvbihlKSB7IHJldHVybiBjdHhbaGFuZGxlcl0oZSk7IH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIChpZCl7XG5cdFx0dGhpcy5kb20oKS5pZCA9IGlkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZG9tKCkuaWQ7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEFkZHMgYSBuZXcgYXR0cmlidXRlIG9yIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGFuIGV4aXN0aW5nIGF0dHJpYnV0ZVxuXHRcdG9uIHRoZSBzcGVjaWZpZWQgdGFnLiBJZiB0aGUgdmFsdWUgaXMgbnVsbCBvciBmYWxzZSwgdGhlIGF0dHJpYnV0ZVxuXHRcdHdpbGwgYmUgcmVtb3ZlZC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsdmFsdWUpe1xuXHRcdC8vIHNob3VsZCB0aGlzIG5vdCByZXR1cm4gc2VsZj9cblx0XHR2YXIgb2xkID0gdGhpcy5kb20oKS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XG5cdFx0aWYgKG9sZCA9PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnNldEF0dHJpYnV0ZShuYW1lLHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvKlxuXHRcdHJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIHNwZWNpZmllZCB0YWdcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5kb20oKS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdHJldHVybnMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgdGFnLlxuXHRcdElmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZG9lcyBub3QgZXhpc3QsIHRoZSB2YWx1ZSByZXR1cm5lZFxuXHRcdHdpbGwgZWl0aGVyIGJlIG51bGwgb3IgXCJcIiAodGhlIGVtcHR5IHN0cmluZylcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5kb20oKS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdE92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZSBzcGVjaWFsIHdyYXBwaW5nIGV0Yy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50LHR5cGUpe1xuXHRcdHRoaXMuc2V0Q2hpbGRyZW4oY29udGVudCx0eXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U2V0IHRoZSBjaGlsZHJlbiBvZiBub2RlLiB0eXBlIHBhcmFtIGlzIG9wdGlvbmFsLFxuXHRcdGFuZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IEltYmEgd2hlbiBjb21waWxpbmcgdGFnIHRyZWVzLiBcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZXMsdHlwZSl7XG5cdFx0dGhyb3cgXCJOb3QgaW1wbGVtZW50ZWRcIjtcblx0fTtcblx0XG5cdC8qXG5cdFx0R2V0IHRleHQgb2Ygbm9kZS4gVXNlcyB0ZXh0Q29udGVudCBiZWhpbmQgdGhlIHNjZW5lcyAobm90IGlubmVyVGV4dClcblx0XHRbaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvdGV4dENvbnRlbnRdKClcblx0XHRAcmV0dXJuIHtzdHJpbmd9IGlubmVyIHRleHQgb2Ygbm9kZVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICh2KXtcblx0XHRyZXR1cm4gdGhpcy5fZG9tLnRleHRDb250ZW50O1xuXHR9O1xuXHRcblx0Lypcblx0XHRTZXQgdGV4dCBvZiBub2RlLiBVc2VzIHRleHRDb250ZW50IGJlaGluZCB0aGUgc2NlbmVzIChub3QgaW5uZXJUZXh0KVxuXHRcdFtodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS90ZXh0Q29udGVudF0oKVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0eHQpe1xuXHRcdHRoaXMuX2VtcHR5ID0gZmFsc2U7XG5cdFx0dGhpcy5fZG9tLnRleHRDb250ZW50ID0gdHh0ID09IG51bGwgPyAodHh0ID0gXCJcIikgOiAodHh0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHQvKlxuXHRcdE1ldGhvZCBmb3IgZ2V0dGluZyBhbmQgc2V0dGluZyBkYXRhLWF0dHJpYnV0ZXMuIFdoZW4gY2FsbGVkIHdpdGggemVyb1xuXHRcdGFyZ3VtZW50cyBpdCB3aWxsIHJldHVybiB0aGUgYWN0dWFsIGRhdGFzZXQgZm9yIHRoZSB0YWcuXG5cdFxuXHRcdFx0dmFyIG5vZGUgPSA8ZGl2IGRhdGEtbmFtZT0naGVsbG8nPlxuXHRcdFx0IyBnZXQgdGhlIHdob2xlIGRhdGFzZXRcblx0XHRcdG5vZGUuZGF0YXNldCAjIHtuYW1lOiAnaGVsbG8nfVxuXHRcdFx0IyBnZXQgYSBzaW5nbGUgdmFsdWVcblx0XHRcdG5vZGUuZGF0YXNldCgnbmFtZScpICMgJ2hlbGxvJ1xuXHRcdFx0IyBzZXQgYSBzaW5nbGUgdmFsdWVcblx0XHRcdG5vZGUuZGF0YXNldCgnbmFtZScsJ25ld25hbWUnKSAjIHNlbGZcblx0XG5cdFxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZGF0YXNldCA9IGZ1bmN0aW9uIChrZXksdmFsKXtcblx0XHR0aHJvdyBcIk5vdCBpbXBsZW1lbnRlZFwiO1xuXHR9O1xuXHRcblx0Lypcblx0XHRFbXB0eSBwbGFjZWhvbGRlci4gT3ZlcnJpZGUgdG8gaW1wbGVtZW50IGN1c3RvbSByZW5kZXIgYmVoYXZpb3VyLlxuXHRcdFdvcmtzIG11Y2ggbGlrZSB0aGUgZmFtaWxpYXIgcmVuZGVyLW1ldGhvZCBpbiBSZWFjdC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENhbGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggSW1iYS5UYWcjZW5kLCB1cG9uIGNyZWF0aW5nIGEgdGFnLiBBbGxcblx0XHRwcm9wZXJ0aWVzIHdpbGwgaGF2ZSBiZWVuIHNldCBiZWZvcmUgYnVpbGQgaXMgY2FsbGVkLCBpbmNsdWRpbmdcblx0XHRzZXRDb250ZW50LlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENhbGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggSW1iYS5UYWcjZW5kLCBmb3IgdGFncyB0aGF0IGFyZSBwYXJ0IG9mXG5cdFx0YSB0YWcgdHJlZSAodGhhdCBhcmUgcmVuZGVyZWQgc2V2ZXJhbCB0aW1lcykuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0XHRDYWxsZWQgYnkgdGhlIHRhZy1zY2hlZHVsZXIgKGlmIHRoaXMgdGFnIGlzIHNjaGVkdWxlZClcblx0XHRCeSBkZWZhdWx0IGl0IHdpbGwgY2FsbCB0aGlzLnJlbmRlci4gRG8gbm90IG92ZXJyaWRlIHVubGVzc1xuXHRcdHlvdSByZWFsbHkgdW5kZXJzdGFuZCBpdC5cblx0XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0XG5cdFx0QSB2ZXJ5IGltcG9ydGFudCBtZXRob2QgdGhhdCB5b3Ugd2lsbCBwcmFjdGljYWxseSBuZXZlciBtYW51YWxseS5cblx0XHRUaGUgdGFnIHN5bnRheCBvZiBJbWJhIGNvbXBpbGVzIHRvIGEgY2hhaW4gb2Ygc2V0dGVycywgd2hpY2ggYWx3YXlzXG5cdFx0ZW5kcyB3aXRoIC5lbmQuIGA8YS5sYXJnZT5gIGNvbXBpbGVzIHRvIGB0YWcoJ2EnKS5mbGFnKCdsYXJnZScpLmVuZCgpYFxuXHRcdFxuXHRcdFlvdSBhcmUgaGlnaGx5IGFkdmljZWQgdG8gbm90IG92ZXJyaWRlIGl0cyBiZWhhdmlvdXIuIFRoZSBmaXJzdCB0aW1lXG5cdFx0ZW5kIGlzIGNhbGxlZCBpdCB3aWxsIG1hcmsgdGhlIHRhZyBhcyBidWlsdCBhbmQgY2FsbCBJbWJhLlRhZyNidWlsZCxcblx0XHRhbmQgY2FsbCBJbWJhLlRhZyNjb21taXQgb24gc3Vic2VxdWVudCBjYWxscy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2J1aWx0KSB7XG5cdFx0XHR0aGlzLmNvbW1pdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9idWlsdCA9IHRydWU7XG5cdFx0XHR0aGlzLmJ1aWxkKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhpcyBpcyBjYWxsZWQgaW5zdGVhZCBvZiBJbWJhLlRhZyNlbmQgZm9yIGA8c2VsZj5gIHRhZyBjaGFpbnMuXG5cdFx0RGVmYXVsdHMgdG8gbm9vcFxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zeW5jZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIGNhbGxlZCB3aGVuIHRoZSBub2RlIGlzIGF3YWtlbmVkIGluIHRoZSBkb20gLSBlaXRoZXIgYXV0b21hdGljYWxseVxuXHQvLyB1cG9uIGF0dGFjaG1lbnQgdG8gdGhlIGRvbS10cmVlLCBvciB0aGUgZmlyc3QgdGltZSBpbWJhIG5lZWRzIHRoZVxuXHQvLyB0YWcgZm9yIGEgZG9tbm9kZSB0aGF0IGhhcyBiZWVuIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXJcblx0SW1iYS5UYWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRMaXN0IG9mIGZsYWdzIGZvciB0aGlzIG5vZGUuIFxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZmxhZ3MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZG9tLmNsYXNzTGlzdDtcblx0fTtcblx0XG5cdC8qXG5cdFx0QWRkIHNwZWZpY2llZCBmbGFnIHRvIGN1cnJlbnQgbm9kZS5cblx0XHRJZiBhIHNlY29uZCBhcmd1bWVudCBpcyBzdXBwbGllZCwgaXQgd2lsbCBiZSBjb2VyY2VkIGludG8gYSBCb29sZWFuLFxuXHRcdGFuZCB1c2VkIHRvIGluZGljYXRlIHdoZXRoZXIgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgZmxhZyBpbnN0ZWFkLlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5mbGFnID0gZnVuY3Rpb24gKG5hbWUsdG9nZ2xlcil7XG5cdFx0Ly8gaXQgaXMgbW9zdCBuYXR1cmFsIHRvIHRyZWF0IGEgc2Vjb25kIHVuZGVmaW5lZCBhcmd1bWVudCBhcyBhIG5vLXN3aXRjaFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGFyZ3VtZW50cy1sZW5ndGhcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmICF0b2dnbGVyKSB7XG5cdFx0XHR0aGlzLl9kb20uY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC5hZGQobmFtZSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0UmVtb3ZlIHNwZWNpZmllZCBmbGFnIGZyb20gbm9kZVxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS51bmZsYWcgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFRvZ2dsZSBzcGVjaWZpZWQgZmxhZyBvbiBub2RlXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnRvZ2dsZUZsYWcgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC50b2dnbGUobmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENoZWNrIHdoZXRoZXIgY3VycmVudCBub2RlIGhhcyBzcGVjaWZpZWQgZmxhZ1xuXHRcdEByZXR1cm4ge2Jvb2x9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5oYXNGbGFnID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHJldHVybiB0aGlzLl9kb20uY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRHZXQgdGhlIHNjaGVkdWxlciBmb3IgdGhpcyBub2RlLiBBIG5ldyBzY2hlZHVsZXIgd2lsbCBiZSBjcmVhdGVkXG5cdFx0aWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cblx0XG5cdFx0QHJldHVybiB7SW1iYS5TY2hlZHVsZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zY2hlZHVsZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVyID09IG51bGwgPyAodGhpcy5fc2NoZWR1bGVyID0gbmV3IEltYmEuU2NoZWR1bGVyKHRoaXMpKSA6ICh0aGlzLl9zY2hlZHVsZXIpO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdFx0U2hvcnRoYW5kIHRvIHN0YXJ0IHNjaGVkdWxpbmcgYSBub2RlLiBUaGUgbWV0aG9kIHdpbGwgYmFzaWNhbGx5XG5cdFx0cHJveHkgdGhlIGFyZ3VtZW50cyB0aHJvdWdoIHRvIHNjaGVkdWxlci5jb25maWd1cmUsIGFuZCB0aGVuXG5cdFx0YWN0aXZhdGUgdGhlIHNjaGVkdWxlci5cblx0XHRcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAob3B0aW9ucyl7XG5cdFx0aWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG5cdFx0dGhpcy5zY2hlZHVsZXIoKS5jb25maWd1cmUob3B0aW9ucykuYWN0aXZhdGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U2hvcnRoYW5kIGZvciBkZWFjdGl2YXRpbmcgc2NoZWR1bGVyIChpZiB0YWcgaGFzIG9uZSkuXG5cdFx0QGRlcHJlY2F0ZWRcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnVuc2NoZWR1bGUgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fc2NoZWR1bGVyKSB7IHRoaXMuc2NoZWR1bGVyKCkuZGVhY3RpdmF0ZSgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Lypcblx0XHRHZXQgdGhlIHBhcmVudCBvZiBjdXJyZW50IG5vZGVcblx0XHRAcmV0dXJuIHtJbWJhLlRhZ30gXG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJHdyYXAodGhpcy5kb20oKS5wYXJlbnROb2RlKTtcblx0fTtcblx0XG5cdC8qXG5cdFx0U2hvcnRoYW5kIGZvciBjb25zb2xlLmxvZyBvbiBlbGVtZW50c1xuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgJDAgPSBhcmd1bWVudHMsIGkgPSAkMC5sZW5ndGg7XG5cdFx0dmFyIGFyZ3MgPSBuZXcgQXJyYXkoaT4wID8gaSA6IDApO1xuXHRcdHdoaWxlKGk+MCkgYXJnc1tpLTFdID0gJDBbLS1pXTtcblx0XHRhcmdzLnVuc2hpZnQoY29uc29sZSk7XG5cdFx0RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYXBwbHkoY29uc29sZS5sb2csYXJncyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmluaXRpYWxpemUgPSBJbWJhLlRhZztcblx0XG5cdEhUTUxfVEFHUyA9IFwiYSBhYmJyIGFkZHJlc3MgYXJlYSBhcnRpY2xlIGFzaWRlIGF1ZGlvIGIgYmFzZSBiZGkgYmRvIGJpZyBibG9ja3F1b3RlIGJvZHkgYnIgYnV0dG9uIGNhbnZhcyBjYXB0aW9uIGNpdGUgY29kZSBjb2wgY29sZ3JvdXAgZGF0YSBkYXRhbGlzdCBkZCBkZWwgZGV0YWlscyBkZm4gZGl2IGRsIGR0IGVtIGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWQgaGVhZGVyIGhyIGh0bWwgaSBpZnJhbWUgaW1nIGlucHV0IGlucyBrYmQga2V5Z2VuIGxhYmVsIGxlZ2VuZCBsaSBsaW5rIG1haW4gbWFwIG1hcmsgbWVudSBtZW51aXRlbSBtZXRhIG1ldGVyIG5hdiBub3NjcmlwdCBvYmplY3Qgb2wgb3B0Z3JvdXAgb3B0aW9uIG91dHB1dCBwIHBhcmFtIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzbWFsbCBzb3VyY2Ugc3BhbiBzdHJvbmcgc3R5bGUgc3ViIHN1bW1hcnkgc3VwIHRhYmxlIHRib2R5IHRkIHRleHRhcmVhIHRmb290IHRoIHRoZWFkIHRpbWUgdGl0bGUgdHIgdHJhY2sgdSB1bCB2YXIgdmlkZW8gd2JyXCIuc3BsaXQoXCIgXCIpO1xuXHRIVE1MX1RBR1NfVU5TQUZFID0gXCJhcnRpY2xlIGFzaWRlIGhlYWRlciBzZWN0aW9uXCIuc3BsaXQoXCIgXCIpO1xuXHRTVkdfVEFHUyA9IFwiY2lyY2xlIGRlZnMgZWxsaXBzZSBnIGxpbmUgbGluZWFyR3JhZGllbnQgbWFzayBwYXRoIHBhdHRlcm4gcG9seWdvbiBwb2x5bGluZSByYWRpYWxHcmFkaWVudCByZWN0IHN0b3Agc3ZnIHRleHQgdHNwYW5cIi5zcGxpdChcIiBcIik7XG5cdFxuXHRcblx0ZnVuY3Rpb24gZXh0ZW5kZXIob2JqLHN1cCl7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhzdXApLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0b2JqWygkMSA9IGtleXNbaV0pXSA9PSBudWxsID8gKG9ialskMV0gPSBzdXBba2V5c1tpXV0pIDogKG9ialskMV0pO1xuXHRcdH07XG5cdFx0XG5cdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHRcdGlmIChzdXAuaW5oZXJpdCkgeyBzdXAuaW5oZXJpdChvYmopIH07XG5cdFx0cmV0dXJuIG9iajtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFRhZygpe1xuXHRcdHJldHVybiBmdW5jdGlvbihkb20pIHtcblx0XHRcdHRoaXMuc2V0RG9tKGRvbSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gVGFnU3Bhd25lcih0eXBlKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlLmJ1aWxkKCk7IH07XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MgPSBmdW5jdGlvbiBUYWdzKCl7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdEltYmEuVGFncy5wcm90b3R5cGUuX19jbG9uZSA9IGZ1bmN0aW9uIChucyl7XG5cdFx0dmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcblx0XHRjbG9uZS5fcGFyZW50ID0gdGhpcztcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZU5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHR2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuXHRcdGNsb25lLl9wYXJlbnQgPSB0aGlzO1xuXHRcdGNsb25lLl9ucyA9IG5hbWU7XG5cdFx0dGhpc1tuYW1lLnRvVXBwZXJDYXNlKCldID0gY2xvbmU7XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9O1xuXHRcblx0SW1iYS5UYWdzLnByb3RvdHlwZS5iYXNlVHlwZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gaWR4JChuYW1lLEhUTUxfVEFHUykgPj0gMCA/ICgnaHRtbGVsZW1lbnQnKSA6ICgnZGl2Jyk7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZVRhZyA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0aWYoYm9keT09dW5kZWZpbmVkICYmIHR5cGVvZiBzdXByID09ICdmdW5jdGlvbicpIGJvZHkgPSBzdXByLHN1cHIgPSAnJztcblx0XHRpZihzdXByPT11bmRlZmluZWQpIHN1cHIgPSAnJztcblx0XHRzdXByIHx8IChzdXByID0gdGhpcy5iYXNlVHlwZShuYW1lKSk7XG5cdFx0dmFyIHN1cGVydHlwZSA9IHRoaXNbc3Vwcl07XG5cdFx0dmFyIHRhZ3R5cGUgPSBUYWcoKTtcblx0XHR2YXIgbm9ybSA9IG5hbWUucmVwbGFjZSgvXFwtL2csJ18nKTtcblx0XHRcblx0XHRcblx0XHR0YWd0eXBlLl9uYW1lID0gbmFtZTtcblx0XHRleHRlbmRlcih0YWd0eXBlLHN1cGVydHlwZSk7XG5cdFx0XG5cdFx0aWYgKG5hbWVbMF0gPT0gJyMnKSB7XG5cdFx0XHR0aGlzW25hbWVdID0gdGFndHlwZTtcblx0XHRcdEltYmEuU0lOR0xFVE9OU1tuYW1lLnNsaWNlKDEpXSA9IHRhZ3R5cGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB0YWd0eXBlO1xuXHRcdFx0dGhpc1snJCcgKyBub3JtXSA9IFRhZ1NwYXduZXIodGFndHlwZSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoYm9keSkge1xuXHRcdFx0aWYgKGJvZHkubGVuZ3RoID09IDIpIHtcblx0XHRcdFx0Ly8gY3JlYXRlIGNsb25lXG5cdFx0XHRcdGlmICghdGFndHlwZS5oYXNPd25Qcm9wZXJ0eSgnVEFHUycpKSB7XG5cdFx0XHRcdFx0dGFndHlwZS5UQUdTID0gKHN1cGVydHlwZS5UQUdTIHx8IHRoaXMpLl9fY2xvbmUoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGJvZHkuY2FsbCh0YWd0eXBlLHRhZ3R5cGUsdGFndHlwZS5UQUdTIHx8IHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRhZ3R5cGU7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0cmV0dXJuIHRoaXMuZGVmaW5lVGFnKG5hbWUsc3Vwcixib2R5KTtcblx0fTtcblx0XG5cdEltYmEuVGFncy5wcm90b3R5cGUuZXh0ZW5kVGFnID0gZnVuY3Rpb24gKG5hbWUsc3Vwcixib2R5KXtcblx0XHRpZihib2R5PT11bmRlZmluZWQgJiYgdHlwZW9mIHN1cHIgPT0gJ2Z1bmN0aW9uJykgYm9keSA9IHN1cHIsc3VwciA9ICcnO1xuXHRcdGlmKHN1cHI9PXVuZGVmaW5lZCkgc3VwciA9ICcnO1xuXHRcdHZhciBrbGFzcyA9ICgodHlwZW9mIG5hbWU9PSdzdHJpbmcnfHxuYW1lIGluc3RhbmNlb2YgU3RyaW5nKSA/ICh0aGlzW25hbWVdKSA6IChuYW1lKSk7XG5cdFx0Ly8gYWxsb3cgZm9yIHByaXZhdGUgdGFncyBoZXJlIGFzIHdlbGw/XG5cdFx0aWYgKGJvZHkpIHsgYm9keSAmJiBib2R5LmNhbGwoa2xhc3Msa2xhc3Msa2xhc3MucHJvdG90eXBlKSB9O1xuXHRcdHJldHVybiBrbGFzcztcblx0fTtcblx0XG5cdFxuXHRJbWJhLlRBR1MgPSBuZXcgSW1iYS5UYWdzKCk7XG5cdEltYmEuVEFHUy5lbGVtZW50ID0gSW1iYS5UYWc7XG5cdFxuXHR2YXIgc3ZnID0gSW1iYS5UQUdTLmRlZmluZU5hbWVzcGFjZSgnc3ZnJyk7XG5cdFxuXHRzdmcuYmFzZVR5cGUgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0cmV0dXJuICdzdmdlbGVtZW50Jztcblx0fTtcblx0XG5cdFxuXHRJbWJhLlNJTkdMRVRPTlMgPSB7fTtcblx0XG5cdFxuXHRJbWJhLmRlZmluZVRhZyA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0aWYoYm9keT09dW5kZWZpbmVkICYmIHR5cGVvZiBzdXByID09ICdmdW5jdGlvbicpIGJvZHkgPSBzdXByLHN1cHIgPSAnJztcblx0XHRpZihzdXByPT11bmRlZmluZWQpIHN1cHIgPSAnJztcblx0XHRyZXR1cm4gSW1iYS5UQUdTLmRlZmluZVRhZyhuYW1lLHN1cHIsYm9keSk7XG5cdH07XG5cdFxuXHRJbWJhLmRlZmluZVNpbmdsZXRvblRhZyA9IGZ1bmN0aW9uIChpZCxzdXByLGJvZHkpe1xuXHRcdGlmKGJvZHk9PXVuZGVmaW5lZCAmJiB0eXBlb2Ygc3VwciA9PSAnZnVuY3Rpb24nKSBib2R5ID0gc3VwcixzdXByID0gJ2Rpdic7XG5cdFx0aWYoc3Vwcj09dW5kZWZpbmVkKSBzdXByID0gJ2Rpdic7XG5cdFx0cmV0dXJuIEltYmEuVEFHUy5kZWZpbmVUYWcodGhpcy5uYW1lKCksc3Vwcixib2R5KTtcblx0fTtcblx0XG5cdEltYmEuZXh0ZW5kVGFnID0gZnVuY3Rpb24gKG5hbWUsYm9keSl7XG5cdFx0cmV0dXJuIEltYmEuVEFHUy5leHRlbmRUYWcobmFtZSxib2R5KTtcblx0fTtcblx0XG5cdEltYmEudGFnID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHZhciB0eXAgPSBJbWJhLlRBR1NbbmFtZV07XG5cdFx0aWYgKCF0eXApIHsgdGhyb3cgbmV3IEVycm9yKChcInRhZyBcIiArIG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSkgfTtcblx0XHRyZXR1cm4gbmV3IHR5cCh0eXAuY3JlYXRlTm9kZSgpKTtcblx0fTtcblx0XG5cdEltYmEudGFnV2l0aElkID0gZnVuY3Rpb24gKG5hbWUsaWQpe1xuXHRcdHZhciB0eXAgPSBJbWJhLlRBR1NbbmFtZV07XG5cdFx0aWYgKCF0eXApIHsgdGhyb3cgbmV3IEVycm9yKChcInRhZyBcIiArIG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSkgfTtcblx0XHR2YXIgZG9tID0gdHlwLmNyZWF0ZU5vZGUoKTtcblx0XHRkb20uaWQgPSBpZDtcblx0XHRyZXR1cm4gbmV3IHR5cChkb20pO1xuXHR9O1xuXHRcblx0Ly8gVE9ETzogQ2FuIHdlIG1vdmUgdGhlc2Ugb3V0IGFuZCBpbnRvIGRvbS5pbWJhIGluIGEgY2xlYW4gd2F5P1xuXHQvLyBUaGVzZSBtZXRob2RzIGRlcGVuZHMgb24gSW1iYS5kb2N1bWVudC5nZXRFbGVtZW50QnlJZFxuXHRcblx0SW1iYS5nZXRUYWdTaW5nbGV0b24gPSBmdW5jdGlvbiAoaWQpe1xuXHRcdHZhciBrbGFzcztcblx0XHR2YXIgZG9tLG5vZGU7XG5cdFx0XG5cdFx0aWYgKGtsYXNzID0gSW1iYS5TSU5HTEVUT05TW2lkXSkge1xuXHRcdFx0aWYgKGtsYXNzICYmIGtsYXNzLkluc3RhbmNlKSB7IHJldHVybiBrbGFzcy5JbnN0YW5jZSB9O1xuXHRcdFx0XG5cdFx0XHQvLyBubyBpbnN0YW5jZSAtIGNoZWNrIGZvciBlbGVtZW50XG5cdFx0XHRpZiAoZG9tID0gSW1iYS5kb2N1bWVudCgpLmdldEVsZW1lbnRCeUlkKGlkKSkge1xuXHRcdFx0XHQvLyB3ZSBoYXZlIGEgbGl2ZSBpbnN0YW5jZSAtIHdoZW4gZmluZGluZyBpdCB0aHJvdWdoIGEgc2VsZWN0b3Igd2Ugc2hvdWxkIGF3YWtlIGl0LCBubz9cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2NyZWF0aW5nIHRoZSBzaW5nbGV0b24gZnJvbSBleGlzdGluZyBub2RlIGluIGRvbT8nLGlkLHR5cGUpXG5cdFx0XHRcdG5vZGUgPSBrbGFzcy5JbnN0YW5jZSA9IG5ldyBrbGFzcyhkb20pO1xuXHRcdFx0XHRub2RlLmF3YWtlbihkb20pOyAvLyBzaG91bGQgb25seSBhd2FrZW5cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRkb20gPSBrbGFzcy5jcmVhdGVOb2RlKCk7XG5cdFx0XHRkb20uaWQgPSBpZDtcblx0XHRcdG5vZGUgPSBrbGFzcy5JbnN0YW5jZSA9IG5ldyBrbGFzcyhkb20pO1xuXHRcdFx0bm9kZS5lbmQoKS5hd2FrZW4oZG9tKTtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH0gZWxzZSBpZiAoZG9tID0gSW1iYS5kb2N1bWVudCgpLmdldEVsZW1lbnRCeUlkKGlkKSkge1xuXHRcdFx0cmV0dXJuIEltYmEuZ2V0VGFnRm9yRG9tKGRvbSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdHZhciBzdmdTdXBwb3J0ID0gdHlwZW9mIFNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXHRcblx0SW1iYS5nZXRUYWdGb3JEb20gPSBmdW5jdGlvbiAoZG9tKXtcblx0XHR2YXIgbTtcblx0XHRpZiAoIWRvbSkgeyByZXR1cm4gbnVsbCB9O1xuXHRcdGlmIChkb20uX2RvbSkgeyByZXR1cm4gZG9tIH07IC8vIGNvdWxkIHVzZSBpbmhlcml0YW5jZSBpbnN0ZWFkXG5cdFx0aWYgKGRvbS5fdGFnKSB7IHJldHVybiBkb20uX3RhZyB9O1xuXHRcdGlmICghZG9tLm5vZGVOYW1lKSB7IHJldHVybiBudWxsIH07XG5cdFx0XG5cdFx0dmFyIG5zID0gbnVsbDtcblx0XHR2YXIgaWQgPSBkb20uaWQ7XG5cdFx0dmFyIHR5cGUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHR2YXIgdGFncyA9IEltYmEuVEFHUztcblx0XHR2YXIgbmF0aXZlJCA9IHR5cGU7XG5cdFx0dmFyIGNscyA9IGRvbS5jbGFzc05hbWU7XG5cdFx0XG5cdFx0aWYgKGlkICYmIEltYmEuU0lOR0xFVE9OU1tpZF0pIHtcblx0XHRcdC8vIEZJWE1FIGNvbnRyb2wgdGhhdCBpdCBpcyB0aGUgc2FtZSBzaW5nbGV0b24/XG5cdFx0XHQvLyBtaWdodCBjb2xsaWRlIC0tIG5vdCBnb29kP1xuXHRcdFx0cmV0dXJuIEltYmEuZ2V0VGFnU2luZ2xldG9uKGlkKTtcblx0XHR9O1xuXHRcdC8vIGxvb2sgZm9yIGlkIC0gc2luZ2xldG9uXG5cdFx0XG5cdFx0Ly8gbmVlZCBiZXR0ZXIgdGVzdCBoZXJlXG5cdFx0aWYgKHN2Z1N1cHBvcnQgJiYgKGRvbSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB7XG5cdFx0XHRucyA9IFwic3ZnXCI7XG5cdFx0XHRjbHMgPSBkb20uY2xhc3NOYW1lLmJhc2VWYWw7XG5cdFx0XHR0YWdzID0gdGFncy5TVkc7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc3Bhd25lcjtcblx0XHRcblx0XHRpZiAoY2xzKSB7XG5cdFx0XHQvLyB0aGVyZSBjYW4gYmUgc2V2ZXJhbCBtYXRjaGVzIGhlcmUgLSBzaG91bGQgY2hvb3NlIHRoZSBsYXN0XG5cdFx0XHQvLyBzaG91bGQgZmFsbCBiYWNrIHRvIGxlc3Mgc3BlY2lmaWMgbGF0ZXI/IC0gb3RoZXJ3aXNlIHRoaW5ncyBtYXkgZmFpbFxuXHRcdFx0Ly8gVE9ETyByZXdvcmsgdGhpc1xuXHRcdFx0aWYgKG0gPSBjbHMubWF0Y2goL1xcYl8oW2EtelxcLV0rKVxcYig/IVxccypfW2EtelxcLV0rKS8pKSB7XG5cdFx0XHRcdHR5cGUgPSBtWzFdOyAvLyAucmVwbGFjZSgvLS9nLCdfJylcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChtID0gY2xzLm1hdGNoKC9cXGIoW0EtWlxcLV0rKV9cXGIvKSkge1xuXHRcdFx0XHRucyA9IG1bMV07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0c3Bhd25lciA9IHRhZ3NbdHlwZV0gfHwgdGFnc1tuYXRpdmUkXTtcblx0XHRyZXR1cm4gc3Bhd25lciA/IChuZXcgc3Bhd25lcihkb20pLmF3YWtlbihkb20pKSA6IChudWxsKTtcblx0fTtcblx0XG5cdHRhZyQgPSBJbWJhLlRBR1M7XG5cdHQkID0gSW1iYS50YWc7XG5cdHRjJCA9IEltYmEudGFnV2l0aEZsYWdzO1xuXHR0aSQgPSBJbWJhLnRhZ1dpdGhJZDtcblx0dGljJCA9IEltYmEudGFnV2l0aElkQW5kRmxhZ3M7XG5cdGlkJCA9IEltYmEuZ2V0VGFnU2luZ2xldG9uO1xuXHRyZXR1cm4gdGFnJHdyYXAgPSBJbWJhLmdldFRhZ0ZvckRvbTtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvdGFnLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHRJbWJhLmRvY3VtZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcblx0fTtcblx0XG5cdC8qXG5cdFJldHVybnMgdGhlIGJvZHkgZWxlbWVudCB3cmFwcGVkIGluIGFuIEltYmEuVGFnXG5cdCovXG5cdFxuXHRJbWJhLnJvb3QgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJHdyYXAoSW1iYS5kb2N1bWVudCgpLmJvZHkpO1xuXHR9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2h0bWxlbGVtZW50JywgJ2VsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRDYWxsZWQgd2hlbiBhIHRhZyB0eXBlIGlzIGJlaW5nIHN1YmNsYXNzZWQuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5pbmhlcml0ID0gZnVuY3Rpb24gKGNoaWxkKXtcblx0XHRcdGNoaWxkLnByb3RvdHlwZS5fZW1wdHkgPSB0cnVlO1xuXHRcdFx0Y2hpbGQuX3Byb3RvRG9tID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX25vZGVUeXBlKSB7XG5cdFx0XHRcdGNoaWxkLl9ub2RlVHlwZSA9IHRoaXMuX25vZGVUeXBlO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9IFwiX1wiICsgY2hpbGQuX25hbWUucmVwbGFjZSgvXy9nLCctJyk7XG5cdFx0XHRcdGlmIChjaGlsZC5fbmFtZVswXSAhPSAnIycpIHsgcmV0dXJuIGNoaWxkLl9jbGFzc2VzID0gdGhpcy5fY2xhc3Nlcy5jb25jYXQoY2xhc3NOYW1lKSB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25vZGVUeXBlID0gY2hpbGQuX25hbWU7XG5cdFx0XHRcdHJldHVybiBjaGlsZC5fY2xhc3NlcyA9IFtdO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5idWlsZE5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBkb20gPSBJbWJhLmRvY3VtZW50KCkuY3JlYXRlRWxlbWVudCh0aGlzLl9ub2RlVHlwZSk7XG5cdFx0XHR2YXIgY2xzID0gdGhpcy5fY2xhc3Nlcy5qb2luKFwiIFwiKTtcblx0XHRcdGlmIChjbHMpIHsgZG9tLmNsYXNzTmFtZSA9IGNscyB9O1xuXHRcdFx0cmV0dXJuIGRvbTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcHJvdG8gPSAodGhpcy5fcHJvdG9Eb20gfHwgKHRoaXMuX3Byb3RvRG9tID0gdGhpcy5idWlsZE5vZGUoKSkpO1xuXHRcdFx0cmV0dXJuIHByb3RvLmNsb25lTm9kZShmYWxzZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcuZG9tID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcHJvdG9Eb20gfHwgKHRoaXMuX3Byb3RvRG9tID0gdGhpcy5idWlsZE5vZGUoKSk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2lkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50YWJpbmRleCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFRhYmluZGV4ID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGl0bGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0aXRsZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndGl0bGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvbGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyb2xlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvbGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLm9mZnNldFdpZHRoO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kb20ub2Zmc2V0SGVpZ2h0O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2Rlcyx0eXBlKXtcblx0XHRcdHRoaXMuX2VtcHR5ID8gKHRoaXMuYXBwZW5kKG5vZGVzKSkgOiAodGhpcy5lbXB0eSgpLmFwcGVuZChub2RlcykpO1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4gPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0U2V0IGlubmVyIGh0bWwgb2Ygbm9kZVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldEh0bWwgPSBmdW5jdGlvbiAoaHRtbCl7XG5cdFx0XHR0aGlzLl9kb20uaW5uZXJIVE1MID0gaHRtbDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCBpbm5lciBodG1sIG9mIG5vZGVcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLmlubmVySFRNTDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgYWxsIGNvbnRlbnQgaW5zaWRlIG5vZGVcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0d2hpbGUgKHRoaXMuX2RvbS5maXJzdENoaWxkKXtcblx0XHRcdFx0dGhpcy5fZG9tLnJlbW92ZUNoaWxkKHRoaXMuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG5cdFx0XHR0aGlzLl9lbXB0eSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgc3BlY2lmaWVkIGNoaWxkIGZyb20gY3VycmVudCBub2RlLlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChjaGlsZCl7XG5cdFx0XHR2YXIgcGFyID0gdGhpcy5kb20oKTtcblx0XHRcdHZhciBlbCA9IGNoaWxkICYmIGNoaWxkLmRvbSgpO1xuXHRcdFx0aWYgKGVsICYmIGVsLnBhcmVudE5vZGUgPT0gcGFyKSB7IHBhci5yZW1vdmVDaGlsZChlbCkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKG5hbWUscGFycyl7XG5cdFx0XHRpZighcGFyc3x8cGFycy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSBwYXJzID0ge307XG5cdFx0XHR2YXIgZGF0YSA9IHBhcnMuZGF0YSAhPT0gdW5kZWZpbmVkID8gcGFycy5kYXRhIDogbnVsbDtcblx0XHRcdHZhciBidWJibGUgPSBwYXJzLmJ1YmJsZSAhPT0gdW5kZWZpbmVkID8gcGFycy5idWJibGUgOiB0cnVlO1xuXHRcdFx0SW1iYS5FdmVudHMudHJpZ2dlcihuYW1lLHRoaXMse2RhdGE6IGRhdGEsYnViYmxlOiBidWJibGV9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0XHRpZiAoa2V5IGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoa2V5KSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHR0aGlzLmNzcyhrZXlzW2ldLGtleVtrZXlzW2ldXSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHZhbCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0XHRcdH0gZWxzZSBpZiAodmFsID09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5zdHlsZVtrZXldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCh0eXBlb2YgdmFsPT0nbnVtYmVyJ3x8dmFsIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBrZXkubWF0Y2goL3dpZHRofGhlaWdodHxsZWZ0fHJpZ2h0fHRvcHxib3R0b20vKSkge1xuXHRcdFx0XHRcdHZhbCA9IHZhbCArIFwicHhcIjtcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5kb20oKS5zdHlsZVtrZXldID0gdmFsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kYXRhc2V0ID0gZnVuY3Rpb24gKGtleSx2YWwpe1xuXHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGtleSksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dGhpcy5kYXRhc2V0KGtleXNbaV0sa2V5W2tleXNbaV1dKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKChcImRhdGEtXCIgKyBrZXkpLHZhbCk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGtleSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoKFwiZGF0YS1cIiArIGtleSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmRvbSgpLmRhdGFzZXQ7XG5cdFx0XHRcblx0XHRcdGlmICghZGF0YXNldCkge1xuXHRcdFx0XHRkYXRhc2V0ID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkxID0gMCwgYXJ5ID0gaXRlciQodGhpcy5kb20oKS5hdHRyaWJ1dGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgYXRyOyBpMSA8IGxlbjsgaTErKykge1xuXHRcdFx0XHRcdGF0ciA9IGFyeVtpMV07XG5cdFx0XHRcdFx0aWYgKGF0ci5uYW1lLnN1YnN0cigwLDUpID09ICdkYXRhLScpIHtcblx0XHRcdFx0XHRcdGRhdGFzZXRbSW1iYS50b0NhbWVsQ2FzZShhdHIubmFtZS5zbGljZSg1KSldID0gYXRyLnZhbHVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZGF0YXNldDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgZGVzY2VuZGFudHMgb2YgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IG1hdGNoaW5nIHNlbGVjdG9yXG5cdFx0XHRAcmV0dXJuIHtJbWJhLlNlbGVjdG9yfVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHJldHVybiBuZXcgSW1iYS5TZWxlY3RvcihzZWwsdGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBmaXJzdCBtYXRjaGluZyBjaGlsZCBvZiBub2RlXG5cdFx0XG5cdFx0XHRAcmV0dXJuIHtJbWJhLlRhZ31cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0cmV0dXJuIHNlbCA/ICh0aGlzLmZpbmQoc2VsKS5maXJzdCgpKSA6ICh0YWckd3JhcCh0aGlzLmRvbSgpLmZpcnN0RWxlbWVudENoaWxkKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBsYXN0IG1hdGNoaW5nIGNoaWxkIG9mIG5vZGVcblx0XHRcblx0XHRcdFx0bm9kZS5sYXN0ICMgcmV0dXJucyB0aGUgbGFzdCBjaGlsZCBvZiBub2RlXG5cdFx0XHRcdG5vZGUubGFzdCAlc3BhbiAjIHJldHVybnMgdGhlIGxhc3Qgc3BhbiBpbnNpZGUgbm9kZVxuXHRcdFx0XHRub2RlLmxhc3QgZG8gfGVsfCBlbC50ZXh0ID09ICdIaScgIyByZXR1cm4gbGFzdCBub2RlIHdpdGggdGV4dCBIaVxuXHRcdFxuXHRcdFx0QHJldHVybiB7SW1iYS5UYWd9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0cmV0dXJuIHNlbCA/ICh0aGlzLmZpbmQoc2VsKS5sYXN0KCkpIDogKHRhZyR3cmFwKHRoaXMuZG9tKCkubGFzdEVsZW1lbnRDaGlsZCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCB0aGUgY2hpbGQgYXQgaW5kZXhcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChpKXtcblx0XHRcdHJldHVybiB0YWckd3JhcCh0aGlzLmRvbSgpLmNoaWxkcmVuW2kgfHwgMF0pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0dmFyIG5vZGVzID0gbmV3IEltYmEuU2VsZWN0b3IobnVsbCx0aGlzLHRoaXMuX2RvbS5jaGlsZHJlbik7XG5cdFx0XHRyZXR1cm4gc2VsID8gKG5vZGVzLmZpbHRlcihzZWwpKSA6IChub2Rlcyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ycGhhbml6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHBhcjtcblx0XHRcdGlmIChwYXIgPSB0aGlzLmRvbSgpLnBhcmVudE5vZGUpIHsgcGFyLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHR2YXIgZm47XG5cdFx0XHRpZiAoc2VsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIHNlbCh0aGlzKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChzZWwucXVlcnkpIHsgc2VsID0gc2VsLnF1ZXJ5KCkgfTtcblx0XHRcdGlmIChmbiA9ICh0aGlzLl9kb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IHRoaXMuX2RvbS5tYXRjaGVzKSkgeyByZXR1cm4gZm4uY2FsbCh0aGlzLl9kb20sc2VsKSB9O1xuXHRcdFx0Ly8gVE9ETyBzdXBwb3J0IG90aGVyIGJyb3dzZXJzIGV0Yz9cblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGZpcnN0IGVsZW1lbnQgbWF0Y2hpbmcgc3VwcGxpZWQgc2VsZWN0b3IgLyBmaWx0ZXJcblx0XHRcdHRyYXZlcnNpbmcgdXB3YXJkcywgYnV0IGluY2x1ZGluZyB0aGUgbm9kZSBpdHNlbGYuXG5cdFx0XHRAcmV0dXJuIHtJbWJhLlRhZ31cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRpZiAoIXNlbCkgeyByZXR1cm4gdGhpcy5wYXJlbnQoKSB9OyAvLyBzaG91bGQgcmV0dXJuIHNlbGY/IVxuXHRcdFx0dmFyIG5vZGUgPSB0aGlzO1xuXHRcdFx0aWYgKHNlbC5xdWVyeSkgeyBzZWwgPSBzZWwucXVlcnkoKSB9O1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAobm9kZSl7XG5cdFx0XHRcdGlmIChub2RlLm1hdGNoZXMoc2VsKSkgeyByZXR1cm4gbm9kZSB9O1xuXHRcdFx0XHRub2RlID0gbm9kZS5wYXJlbnQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2Ygbm9kZSB0aGF0IG1hdGNoZXNcblx0XHRcdHNwZWNpZmllZCBzZWxlY3RvciAvIG1hdGNoZXIuXG5cdFx0XG5cdFx0XHRAcmV0dXJuIHtJbWJhLlRhZ31cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0aWYgKCFzZWwpIHsgcmV0dXJuIHRoaXMucGFyZW50KCkgfTtcblx0XHRcdHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuY2xvc2VzdChzZWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHR2YXIgbm9kZSA9IHRoaXM7XG5cdFx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHRcdGlmIChzZWwgJiYgc2VsLnF1ZXJ5KSB7IHNlbCA9IHNlbC5xdWVyeSgpIH07XG5cdFx0XHRcblx0XHRcdHdoaWxlIChub2RlKXtcblx0XHRcdFx0aWYgKCFzZWwgfHwgbm9kZS5tYXRjaGVzKHNlbCkpIHsgbm9kZXMucHVzaChub2RlKSB9O1xuXHRcdFx0XHRub2RlID0gbm9kZS5wYXJlbnQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbm9kZXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHZhciBwYXIgPSB0aGlzLnBhcmVudCgpO1xuXHRcdFx0cmV0dXJuIHBhciA/IChwYXIucGF0aChzZWwpKSA6IChbXSk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNpYmxpbmdzID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHR2YXIgcGFyLCBzZWxmID0gdGhpcztcblx0XHRcdGlmICghKHBhciA9IHRoaXMucGFyZW50KCkpKSB7IHJldHVybiBbXSB9OyAvLyBGSVhNRVxuXHRcdFx0dmFyIGFyeSA9IHRoaXMuZG9tKCkucGFyZW50Tm9kZS5jaGlsZHJlbjtcblx0XHRcdHZhciBub2RlcyA9IG5ldyBJbWJhLlNlbGVjdG9yKG51bGwsdGhpcyxhcnkpO1xuXHRcdFx0cmV0dXJuIG5vZGVzLmZpbHRlcihmdW5jdGlvbihuKSB7IHJldHVybiBuICE9IHNlbGYgJiYgKCFzZWwgfHwgbi5tYXRjaGVzKHNlbCkpOyB9KTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGltbWVkaWF0ZWx5IGZvbGxvd2luZyBzaWJsaW5nIG9mIG5vZGUuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0aWYgKHNlbCkge1xuXHRcdFx0XHR2YXIgZWwgPSB0aGlzO1xuXHRcdFx0XHR3aGlsZSAoZWwgPSBlbC5uZXh0KCkpe1xuXHRcdFx0XHRcdGlmIChlbC5tYXRjaGVzKHNlbCkpIHsgcmV0dXJuIGVsIH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0YWckd3JhcCh0aGlzLmRvbSgpLm5leHRFbGVtZW50U2libGluZyk7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBpbW1lZGlhdGVseSBwcmVjZWVkaW5nIHNpYmxpbmcgb2Ygbm9kZS5cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRpZiAoc2VsKSB7XG5cdFx0XHRcdHZhciBlbCA9IHRoaXM7XG5cdFx0XHRcdHdoaWxlIChlbCA9IGVsLnByZXYoKSl7XG5cdFx0XHRcdFx0aWYgKGVsLm1hdGNoZXMoc2VsKSkgeyByZXR1cm4gZWwgfTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRhZyR3cmFwKHRoaXMuZG9tKCkucHJldmlvdXNFbGVtZW50U2libGluZyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuY29udGFpbnMobm9kZSAmJiBub2RlLl9kb20gfHwgbm9kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHR2YXIgZWwgPSB0aGlzLmRvbSgpO1xuXHRcdFx0d2hpbGUgKGVsLnByZXZpb3VzU2libGluZyl7XG5cdFx0XHRcdGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuXHRcdFx0XHRpKys7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKlxuXHRcdFx0XG5cdFx0XHRAZGVwcmVjYXRlZFxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChub2RlLHBhcnMpe1xuXHRcdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdFx0dmFyIGJlZm9yZSA9IHBhcnMuYmVmb3JlICE9PSB1bmRlZmluZWQgPyBwYXJzLmJlZm9yZSA6IG51bGw7XG5cdFx0XHR2YXIgYWZ0ZXIgPSBwYXJzLmFmdGVyICE9PSB1bmRlZmluZWQgPyBwYXJzLmFmdGVyIDogbnVsbDtcblx0XHRcdGlmIChhZnRlcikgeyBiZWZvcmUgPSBhZnRlci5uZXh0KCkgfTtcblx0XHRcdGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0bm9kZSA9ICh0YWckLiRmcmFnbWVudCgpLnNldENvbnRlbnQobm9kZSwwKS5lbmQoKSk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmluc2VydEJlZm9yZShub2RlLmRvbSgpLGJlZm9yZS5kb20oKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFwcGVuZChub2RlKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRGb2N1cyBvbiBjdXJyZW50IG5vZGVcblx0XHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZG9tKCkuZm9jdXMoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdFJlbW92ZSBmb2N1cyBmcm9tIGN1cnJlbnQgbm9kZVxuXHRcdFx0QHJldHVybiB7c2VsZn1cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmRvbSgpLmJsdXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50ZW1wbGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0QHRvZG8gU2hvdWxkIHN1cHBvcnQgbXVsdGlwbGUgYXJndW1lbnRzIGxpa2UgYXBwZW5kXG5cdFx0XG5cdFx0XHRUaGUgLnByZXBlbmQgbWV0aG9kIGluc2VydHMgdGhlIHNwZWNpZmllZCBjb250ZW50IGFzIHRoZSBmaXJzdFxuXHRcdFx0Y2hpbGQgb2YgdGhlIHRhcmdldCBub2RlLiBJZiB0aGUgY29udGVudCBpcyBhbHJlYWR5IGEgY2hpbGQgb2YgXG5cdFx0XHRub2RlIGl0IHdpbGwgYmUgbW92ZWQgdG8gdGhlIHN0YXJ0LlxuXHRcdFx0XG5cdFx0ICAgIFx0bm9kZS5wcmVwZW5kIDxkaXYudG9wPiAjIHByZXBlbmQgbm9kZVxuXHRcdCAgICBcdG5vZGUucHJlcGVuZCBcInNvbWUgdGV4dFwiICMgcHJlcGVuZCB0ZXh0XG5cdFx0ICAgIFx0bm9kZS5wcmVwZW5kIFs8dWw+LDx1bD5dICMgcHJlcGVuZCBhcnJheVxuXHRcdFxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoaXRlbSl7XG5cdFx0XHR2YXIgZmlyc3QgPSB0aGlzLl9kb20uY2hpbGROb2Rlc1swXTtcblx0XHRcdGZpcnN0ID8gKHRoaXMuaW5zZXJ0QmVmb3JlKGl0ZW0sZmlyc3QpKSA6ICh0aGlzLmFwcGVuZENoaWxkKGl0ZW0pKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdFRoZSAuYXBwZW5kIG1ldGhvZCBpbnNlcnRzIHRoZSBzcGVjaWZpZWQgY29udGVudCBhcyB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0b2YgdGhlIHRhcmdldCBub2RlLiBJZiB0aGUgY29udGVudCBpcyBhbHJlYWR5IGEgY2hpbGQgb2Ygbm9kZSBpdFxuXHRcdFx0d2lsbCBiZSBtb3ZlZCB0byB0aGUgZW5kLlxuXHRcdFx0XG5cdFx0XHQjIGV4YW1wbGVcblx0XHRcdCAgICB2YXIgcm9vdCA9IDxkaXYucm9vdD5cblx0XHRcdCAgICB2YXIgaXRlbSA9IDxkaXYuaXRlbT4gXCJUaGlzIGlzIGFuIGl0ZW1cIlxuXHRcdFx0ICAgIHJvb3QuYXBwZW5kIGl0ZW0gIyBhcHBlbmRzIGl0ZW0gdG8gdGhlIGVuZCBvZiByb290XG5cdFx0XG5cdFx0XHQgICAgcm9vdC5wcmVwZW5kIFwic29tZSB0ZXh0XCIgIyBhcHBlbmQgdGV4dFxuXHRcdFx0ICAgIHJvb3QucHJlcGVuZCBbPHVsPiw8dWw+XSAjIGFwcGVuZCBhcnJheVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHRcdC8vIHBvc3NpYmxlIHRvIGFwcGVuZCBibGFua1xuXHRcdFx0Ly8gcG9zc2libGUgdG8gc2ltcGxpZnkgb24gc2VydmVyP1xuXHRcdFx0aWYgKCFpdGVtKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGl0ZW0pLCBsZW4gPSBhcnkubGVuZ3RoLCBtZW1iZXI7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdG1lbWJlciA9IGFyeVtpXTtcblx0XHRcdFx0XHRtZW1iZXIgJiYgdGhpcy5hcHBlbmQobWVtYmVyKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiBpdGVtPT0nc3RyaW5nJ3x8aXRlbSBpbnN0YW5jZW9mIFN0cmluZykgfHwgKHR5cGVvZiBpdGVtPT0nbnVtYmVyJ3x8aXRlbSBpbnN0YW5jZW9mIE51bWJlcikpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSBJbWJhLmRvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUoaXRlbSk7XG5cdFx0XHRcdHRoaXMuX2RvbS5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0aWYgKHRoaXMuX2VtcHR5KSB7IHRoaXMuX2VtcHR5ID0gZmFsc2UgfTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2RvbS5hcHBlbmRDaGlsZChpdGVtLl9kb20gfHwgaXRlbSk7XG5cdFx0XHRcdGlmICh0aGlzLl9lbXB0eSkgeyB0aGlzLl9lbXB0eSA9IGZhbHNlIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRJbnNlcnQgYSBub2RlIGludG8gdGhlIGN1cnJlbnQgbm9kZSAoc2VsZiksIGJlZm9yZSBhbm90aGVyLlxuXHRcdFx0VGhlIHJlbGF0aXZlIG5vZGUgbXVzdCBiZSBhIGNoaWxkIG9mIGN1cnJlbnQgbm9kZS4gXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKG5vZGUscmVsKXtcblx0XHRcdGlmICgodHlwZW9mIG5vZGU9PSdzdHJpbmcnfHxub2RlIGluc3RhbmNlb2YgU3RyaW5nKSkgeyBub2RlID0gSW1iYS5kb2N1bWVudCgpLmNyZWF0ZVRleHROb2RlKG5vZGUpIH07XG5cdFx0XHRpZiAobm9kZSAmJiByZWwpIHsgdGhpcy5kb20oKS5pbnNlcnRCZWZvcmUoKG5vZGUuX2RvbSB8fCBub2RlKSwocmVsLl9kb20gfHwgcmVsKSkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEFwcGVuZCBhIHNpbmdsZSBpdGVtIChub2RlIG9yIHN0cmluZykgdG8gdGhlIGN1cnJlbnQgbm9kZS5cblx0XHRcdElmIHN1cHBsaWVkIGl0ZW0gaXMgYSBzdHJpbmcgaXQgd2lsbCBhdXRvbWF0aWNhbGx5LiBUaGlzIGlzIHVzZWRcblx0XHRcdGJ5IEltYmEgaW50ZXJuYWxseSwgYnV0IHdpbGwgcHJhY3RpY2FsbHkgbmV2ZXIgYmUgdXNlZCBleHBsaWNpdGx5LlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0aWYgKCh0eXBlb2Ygbm9kZT09J3N0cmluZyd8fG5vZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7IG5vZGUgPSBJbWJhLmRvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUobm9kZSkgfTtcblx0XHRcdGlmIChub2RlKSB7IHRoaXMuZG9tKCkuYXBwZW5kQ2hpbGQobm9kZS5fZG9tIHx8IG5vZGUpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgYSBzaW5nbGUgY2hpbGQgZnJvbSB0aGUgY3VycmVudCBub2RlLlxuXHRcdFx0VXNlZCBieSBJbWJhIGludGVybmFsbHkuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0XHRpZiAobm9kZSkgeyB0aGlzLmRvbSgpLnJlbW92ZUNoaWxkKG5vZGUuX2RvbSB8fCBub2RlKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnRvU3RyaW5nKCk7IC8vIHJlYWxseT9cblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRAZGVwcmVjYXRlZFxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsYXNzZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGNvbnNvbGUubG9nKCdJbWJhLlRhZyNjbGFzc2VzIGlzIGRlcHJlY2F0ZWQnKTtcblx0XHRcdHJldHVybiB0aGlzLl9kb20uY2xhc3NMaXN0O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdzdmdlbGVtZW50JywgJ2h0bWxlbGVtZW50Jyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdC8vIEV4dGVuZGluZyBJbWJhLlRhZyNjc3MgdG8gd29yayB3aXRob3V0IHByZWZpeGVzIGJ5IGluc3BlY3Rpbmdcblx0Ly8gdGhlIHByb3BlcnRpZXMgb2YgYSBDU1NTdHlsZURlY2xhcmF0aW9uIGFuZCBjcmVhdGluZyBhIG1hcFxuXHRcblx0Ly8gdmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsJy1tcy0nLCctbW96LScsJy1vLScsJy1ibGluay0nXVxuXHQvLyB2YXIgcHJvcHMgPSBbJ3RyYW5zZm9ybScsJ3RyYW5zaXRpb24nLCdhbmltYXRpb24nXVxuXHRcblx0dmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwnJyk7XG5cdFxuXHRJbWJhLkNTU0tleU1hcCA9IHt9O1xuXHRcblx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHN0eWxlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHByZWZpeGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwcmVmaXhlZCA9IGFyeVtpXTtcblx0XHR2YXIgdW5wcmVmaXhlZCA9IHByZWZpeGVkLnJlcGxhY2UoL14tKHdlYmtpdHxtc3xtb3p8b3xibGluayktLywnJyk7XG5cdFx0dmFyIGNhbWVsQ2FzZSA9IHVucHJlZml4ZWQucmVwbGFjZSgvLShcXHcpL2csZnVuY3Rpb24obSxhKSB7IHJldHVybiBhLnRvVXBwZXJDYXNlKCk7IH0pO1xuXHRcdFxuXHRcdC8vIGlmIHRoZXJlIGV4aXN0cyBhbiB1bnByZWZpeGVkIHZlcnNpb24gLS0gYWx3YXlzIHVzZSB0aGlzXG5cdFx0aWYgKHByZWZpeGVkICE9IHVucHJlZml4ZWQpIHtcblx0XHRcdGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkodW5wcmVmaXhlZCkpIHsgY29udGludWU7IH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyByZWdpc3RlciB0aGUgcHJlZml4ZXNcblx0XHRJbWJhLkNTU0tleU1hcFt1bnByZWZpeGVkXSA9IEltYmEuQ1NTS2V5TWFwW2NhbWVsQ2FzZV0gPSBwcmVmaXhlZDtcblx0fTtcblx0XG5cdHJldHVybiB0YWckLmV4dGVuZFRhZygnaHRtbGVsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdC8vIG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBjc3MgbWV0aG9kXG5cdFx0dGFnLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0XHRpZiAoa2V5IGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoa2V5KSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHR0aGlzLmNzcyhrZXlzW2ldLGtleVtrZXlzW2ldXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0a2V5ID0gSW1iYS5DU1NLZXlNYXBba2V5XSB8fCBrZXk7XG5cdFx0XHRcblx0XHRcdGlmICh2YWwgPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbCA9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuc3R5bGVba2V5XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgodHlwZW9mIHZhbD09J251bWJlcid8fHZhbCBpbnN0YW5jZW9mIE51bWJlcikgJiYga2V5Lm1hdGNoKC93aWR0aHxoZWlnaHR8bGVmdHxyaWdodHx0b3B8Ym90dG9tLykpIHtcblx0XHRcdFx0XHR2YWwgPSB2YWwgKyBcInB4XCI7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuZG9tKCkuc3R5bGVba2V5XSA9IHZhbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20uY2xpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHQvLyBwcmVkZWZpbmUgYWxsIHN1cHBvcnRlZCBodG1sIHRhZ3Ncblx0dGFnJC5kZWZpbmVUYWcoJ2ZyYWdtZW50JywgJ2h0bWxlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEltYmEuZG9jdW1lbnQoKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIcmVmID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdocmVmJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FiYnInKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2FkZHJlc3MnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2FyZWEnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2FydGljbGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2FzaWRlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdhdWRpbycpO1xuXHR0YWckLmRlZmluZVRhZygnYicpO1xuXHR0YWckLmRlZmluZVRhZygnYmFzZScpO1xuXHR0YWckLmRlZmluZVRhZygnYmRpJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdiZG8nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2JpZycpO1xuXHR0YWckLmRlZmluZVRhZygnYmxvY2txdW90ZScpO1xuXHR0YWckLmRlZmluZVRhZygnYm9keScpO1xuXHR0YWckLmRlZmluZVRhZygnYnInKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdidXR0b24nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXV0b2ZvY3VzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnYXV0b2ZvY3VzJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEF1dG9mb2N1cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnYXV0b2ZvY3VzJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdjYW52YXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmICh0aGlzLndpZHRoKCkgIT0gdmFsKSB7IHRoaXMuZG9tKCkud2lkdGggPSB2YWwgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmICh0aGlzLmhlaWdodCgpICE9IHZhbCkgeyB0aGlzLmRvbSgpLmhlaWdodCA9IHZhbCB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS53aWR0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5oZWlnaHQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbiAodHlwZSl7XG5cdFx0XHRpZih0eXBlID09PSB1bmRlZmluZWQpIHR5cGUgPSAnMmQnO1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuZ2V0Q29udGV4dCh0eXBlKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdjYXB0aW9uJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdjaXRlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdjb2RlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdjb2wnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2NvbGdyb3VwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkYXRhJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkYXRhbGlzdCcpO1xuXHR0YWckLmRlZmluZVRhZygnZGQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RlbCcpO1xuXHR0YWckLmRlZmluZVRhZygnZGV0YWlscycpO1xuXHR0YWckLmRlZmluZVRhZygnZGZuJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkaXYnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RsJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkdCcpO1xuXHR0YWckLmRlZmluZVRhZygnZW0nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2VtYmVkJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdmaWVsZHNldCcpO1xuXHR0YWckLmRlZmluZVRhZygnZmlnY2FwdGlvbicpO1xuXHR0YWckLmRlZmluZVRhZygnZmlndXJlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdmb290ZXInKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdmb3JtJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ21ldGhvZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRNZXRob2QgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ21ldGhvZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWN0aW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aW9uJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEFjdGlvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aW9uJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2gxJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoMicpO1xuXHR0YWckLmRlZmluZVRhZygnaDMnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2g0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoNScpO1xuXHR0YWckLmRlZmluZVRhZygnaDYnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2hlYWQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2hlYWRlcicpO1xuXHR0YWckLmRlZmluZVRhZygnaHInKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2h0bWwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2knKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpZnJhbWUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltZycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzcmMnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW5wdXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdC8vIGNhbiB1c2UgYXR0ciBpbnN0ZWFkXG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlcXVpcmVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyZXF1aXJlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF1dG9mb2N1cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnZhbHVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2KXtcblx0XHRcdGlmICh2ICE9IHRoaXMuZG9tKCkudmFsdWUpIHsgdGhpcy5kb20oKS52YWx1ZSA9IHYgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICh2KXtcblx0XHRcdGlmICh2ICE9IHRoaXMuZG9tKCkucGxhY2Vob2xkZXIpIHsgdGhpcy5kb20oKS5wbGFjZWhvbGRlciA9IHYgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucGxhY2Vob2xkZXI7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoZWNrZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLmNoZWNrZWQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENoZWNrZWQgPSBmdW5jdGlvbiAoYm9vbCl7XG5cdFx0XHRpZiAoYm9vbCAhPSB0aGlzLmRvbSgpLmNoZWNrZWQpIHsgdGhpcy5kb20oKS5jaGVja2VkID0gYm9vbCB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW5zJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdrYmQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2tleWdlbicpO1xuXHR0YWckLmRlZmluZVRhZygnbGFiZWwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2xlZ2VuZCcpO1xuXHR0YWckLmRlZmluZVRhZygnbGknKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdsaW5rJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlbCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZWwgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JlbCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndHlwZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaHJlZiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHJlZiA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnaHJlZicsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWVkaWEgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdtZWRpYScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRNZWRpYSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbWVkaWEnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbWFpbicpO1xuXHR0YWckLmRlZmluZVRhZygnbWFwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdtYXJrJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdtZW51Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdtZW51aXRlbScpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ21ldGEnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnY29udGVudCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2hhcnNldCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NoYXJzZXQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2hhcnNldCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnY2hhcnNldCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdtZXRlcicpO1xuXHR0YWckLmRlZmluZVRhZygnbmF2Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdub3NjcmlwdCcpO1xuXHR0YWckLmRlZmluZVRhZygnb2JqZWN0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdvbCcpO1xuXHR0YWckLmRlZmluZVRhZygnb3B0Z3JvdXAnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdvcHRpb24nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnb3V0cHV0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdwYXJhbScpO1xuXHR0YWckLmRlZmluZVRhZygncHJlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdwcm9ncmVzcycpO1xuXHR0YWckLmRlZmluZVRhZygncScpO1xuXHR0YWckLmRlZmluZVRhZygncnAnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3J0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdydWJ5Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzYW1wJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc2NyaXB0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NyYycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndHlwZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdzZWN0aW9uJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc2VsZWN0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11bHRpcGxlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbXVsdGlwbGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TXVsdGlwbGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlcXVpcmVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyZXF1aXJlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS52YWx1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodil7XG5cdFx0XHRpZiAodiAhPSB0aGlzLmRvbSgpLnZhbHVlKSB7IHRoaXMuZG9tKCkudmFsdWUgPSB2IH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc21hbGwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3NvdXJjZScpO1xuXHR0YWckLmRlZmluZVRhZygnc3BhbicpO1xuXHR0YWckLmRlZmluZVRhZygnc3Ryb25nJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzdHlsZScpO1xuXHR0YWckLmRlZmluZVRhZygnc3ViJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzdW1tYXJ5Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzdXAnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RhYmxlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0Ym9keScpO1xuXHR0YWckLmRlZmluZVRhZygndGQnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCd0ZXh0YXJlYScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgncmVxdWlyZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvd3MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyb3dzJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvd3MgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3Jvd3MnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdjb2xzJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldENvbHMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NvbHMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF1dG9mb2N1cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnZhbHVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2KXtcblx0XHRcdGlmICh2ICE9IHRoaXMuZG9tKCkudmFsdWUpIHsgdGhpcy5kb20oKS52YWx1ZSA9IHYgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICh2KXtcblx0XHRcdGlmICh2ICE9IHRoaXMuZG9tKCkucGxhY2Vob2xkZXIpIHsgdGhpcy5kb20oKS5wbGFjZWhvbGRlciA9IHYgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucGxhY2Vob2xkZXI7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygndGZvb3QnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RoJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0aGVhZCcpO1xuXHR0YWckLmRlZmluZVRhZygndGltZScpO1xuXHR0YWckLmRlZmluZVRhZygndGl0bGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RyJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0cmFjaycpO1xuXHR0YWckLmRlZmluZVRhZygndScpO1xuXHR0YWckLmRlZmluZVRhZygndWwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3ZpZGVvJyk7XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnd2JyJyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLmh0bWwuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdzdmdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcubmFtZXNwYWNlVVJJID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHR5cGVzID0gXCJjaXJjbGUgZGVmcyBlbGxpcHNlIGcgbGluZSBsaW5lYXJHcmFkaWVudCBtYXNrIHBhdGggcGF0dGVybiBwb2x5Z29uIHBvbHlsaW5lIHJhZGlhbEdyYWRpZW50IHJlY3Qgc3RvcCBzdmcgdGV4dCB0c3BhblwiLnNwbGl0KFwiIFwiKTtcblx0XHRcblx0XHR0YWcuYnVpbGROb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZG9tID0gSW1iYS5kb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5hbWVzcGFjZVVSSSgpLHRoaXMuX25vZGVUeXBlKTtcblx0XHRcdHZhciBjbHMgPSB0aGlzLl9jbGFzc2VzLmpvaW4oXCIgXCIpO1xuXHRcdFx0aWYgKGNscykgeyBkb20uY2xhc3NOYW1lLmJhc2VWYWwgPSBjbHMgfTtcblx0XHRcdHJldHVybiBkb207XG5cdFx0fTtcblx0XHRcblx0XHR0YWcuaW5oZXJpdCA9IGZ1bmN0aW9uIChjaGlsZCl7XG5cdFx0XHRjaGlsZC5fcHJvdG9Eb20gPSBudWxsO1xuXHRcdFx0XG5cdFx0XHRpZiAoaWR4JChjaGlsZC5fbmFtZSx0eXBlcykgPj0gMCkge1xuXHRcdFx0XHRjaGlsZC5fbm9kZVR5cGUgPSBjaGlsZC5fbmFtZTtcblx0XHRcdFx0cmV0dXJuIGNoaWxkLl9jbGFzc2VzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZC5fbm9kZVR5cGUgPSB0aGlzLl9ub2RlVHlwZTtcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9IFwiX1wiICsgY2hpbGQuX25hbWUucmVwbGFjZSgvXy9nLCctJyk7XG5cdFx0XHRcdHJldHVybiBjaGlsZC5fY2xhc3NlcyA9IHRoaXMuX2NsYXNzZXMuY29uY2F0KGNsYXNzTmFtZSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0SW1iYS5hdHRyKHRhZywneCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3knKTtcblx0XHRcblx0XHRJbWJhLmF0dHIodGFnLCd3aWR0aCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ2hlaWdodCcpO1xuXHRcdFxuXHRcdEltYmEuYXR0cih0YWcsJ3N0cm9rZScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3N0cm9rZS13aWR0aCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuU1ZHLmRlZmluZVRhZygnc3ZnJywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCd2aWV3Ym94Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdyZWN0Jyk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ2NpcmNsZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywnY3gnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdjeScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3InKTtcblx0fSk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ2VsbGlwc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdEltYmEuYXR0cih0YWcsJ2N4Jyk7XG5cdFx0SW1iYS5hdHRyKHRhZywnY3knKTtcblx0XHRJbWJhLmF0dHIodGFnLCdyeCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3J5Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdwYXRoJywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCdkJyk7XG5cdFx0SW1iYS5hdHRyKHRhZywncGF0aExlbmd0aCcpO1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLlNWRy5kZWZpbmVUYWcoJ2xpbmUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdEltYmEuYXR0cih0YWcsJ3gxJyk7XG5cdFx0SW1iYS5hdHRyKHRhZywneDInKTtcblx0XHRJbWJhLmF0dHIodGFnLCd5MScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3kyJyk7XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5zdmcuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0aWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0KSB7XG5cdFx0dGFnJC5leHRlbmRUYWcoJ2h0bWxlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcdFxuXHRcdFx0dGFnLnByb3RvdHlwZS5oYXNGbGFnID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgcmVmICsgJyhcXFxcc3wkKScpLnRlc3QodGhpcy5fZG9tLmNsYXNzTmFtZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YWcucHJvdG90eXBlLmFkZEZsYWcgPSBmdW5jdGlvbiAocmVmKXtcblx0XHRcdFx0aWYgKHRoaXMuaGFzRmxhZyhyZWYpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgKz0gKHRoaXMuX2RvbS5jbGFzc05hbWUgPyAoJyAnKSA6ICgnJykpICsgcmVmO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRhZy5wcm90b3R5cGUudW5mbGFnID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRcdGlmICghdGhpcy5oYXNGbGFnKHJlZikpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFx0dmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKF58XFxcXHMpKicgKyByZWYgKyAnKFxcXFxzfCQpKicsJ2cnKTtcblx0XHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSA9IHRoaXMuX2RvbS5jbGFzc05hbWUucmVwbGFjZShyZWdleCwnJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGFnLnByb3RvdHlwZS50b2dnbGVGbGFnID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRcdHJldHVybiB0aGlzLmhhc0ZsYWcocmVmKSA/ICh0aGlzLnVuZmxhZyhyZWYpKSA6ICh0aGlzLmZsYWcocmVmKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YWcucHJvdG90eXBlLmZsYWcgPSBmdW5jdGlvbiAocmVmLGJvb2wpe1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmICEhYm9vbCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy51bmZsYWcocmVmKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkRmxhZyhyZWYpO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20ubGVnYWN5LmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHR2YXIgZG9jID0gZG9jdW1lbnQ7XG5cdHZhciB3aW4gPSB3aW5kb3c7XG5cdFxuXHR2YXIgaGFzVG91Y2hFdmVudHMgPSB3aW5kb3cgJiYgd2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkO1xuXHRcblx0SW1iYS5Qb2ludGVyID0gZnVuY3Rpb24gUG9pbnRlcigpe1xuXHRcdHRoaXMuc2V0QnV0dG9uKC0xKTtcblx0XHR0aGlzLnNldEV2ZW50KHt4OiAwLHk6IDAsdHlwZTogJ3VuaW5pdGlhbGl6ZWQnfSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUucGhhc2UgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BoYXNlOyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0UGhhc2UgPSBmdW5jdGlvbih2KXsgdGhpcy5fcGhhc2UgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnByZXZFdmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcHJldkV2ZW50OyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0UHJldkV2ZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX3ByZXZFdmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuYnV0dG9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9idXR0b247IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXRCdXR0b24gPSBmdW5jdGlvbih2KXsgdGhpcy5fYnV0dG9uID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXZlbnQ7IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXRFdmVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ldmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RpcnR5OyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGlydHkgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLmV2ZW50cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXZlbnRzOyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0RXZlbnRzID0gZnVuY3Rpb24odil7IHRoaXMuX2V2ZW50cyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RvdWNoOyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0VG91Y2ggPSBmdW5jdGlvbih2KXsgdGhpcy5fdG91Y2ggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGUpe1xuXHRcdHRoaXMuc2V0RXZlbnQoZSk7XG5cdFx0dGhpcy5zZXREaXJ0eSh0cnVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIHRoaXMgaXMganVzdCBmb3IgcmVndWxhciBtb3VzZSBub3dcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGUxID0gdGhpcy5ldmVudCgpO1xuXHRcdFxuXHRcdGlmICh0aGlzLmRpcnR5KCkpIHtcblx0XHRcdHRoaXMuc2V0UHJldkV2ZW50KGUxKTtcblx0XHRcdHRoaXMuc2V0RGlydHkoZmFsc2UpO1xuXHRcdFx0XG5cdFx0XHQvLyBidXR0b24gc2hvdWxkIG9ubHkgY2hhbmdlIG9uIG1vdXNlZG93biBldGNcblx0XHRcdGlmIChlMS50eXBlID09ICdtb3VzZWRvd24nKSB7XG5cdFx0XHRcdHRoaXMuc2V0QnV0dG9uKGUxLmJ1dHRvbik7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBkbyBub3QgY3JlYXRlIHRvdWNoIGZvciByaWdodCBjbGlja1xuXHRcdFx0XHRpZiAodGhpcy5idXR0b24oKSA9PSAyIHx8ICh0aGlzLnRvdWNoKCkgJiYgdGhpcy5idXR0b24oKSAhPSAwKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNhbmNlbCB0aGUgcHJldmlvdXMgdG91Y2hcblx0XHRcdFx0aWYgKHRoaXMudG91Y2goKSkgeyB0aGlzLnRvdWNoKCkuY2FuY2VsKCkgfTtcblx0XHRcdFx0dGhpcy5zZXRUb3VjaChuZXcgSW1iYS5Ub3VjaChlMSx0aGlzKSk7XG5cdFx0XHRcdHRoaXMudG91Y2goKS5tb3VzZWRvd24oZTEsZTEpO1xuXHRcdFx0fSBlbHNlIGlmIChlMS50eXBlID09ICdtb3VzZW1vdmUnKSB7XG5cdFx0XHRcdGlmICh0aGlzLnRvdWNoKCkpIHsgdGhpcy50b3VjaCgpLm1vdXNlbW92ZShlMSxlMSkgfTtcblx0XHRcdH0gZWxzZSBpZiAoZTEudHlwZSA9PSAnbW91c2V1cCcpIHtcblx0XHRcdFx0dGhpcy5zZXRCdXR0b24oLTEpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMudG91Y2goKSAmJiB0aGlzLnRvdWNoKCkuYnV0dG9uKCkgPT0gZTEuYnV0dG9uKSB7XG5cdFx0XHRcdFx0dGhpcy50b3VjaCgpLm1vdXNldXAoZTEsZTEpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VG91Y2gobnVsbCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHRyaWdnZXIgcG9pbnRlcnVwXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy50b3VjaCgpKSB7IHRoaXMudG91Y2goKS5pZGxlKCkgfTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIEltYmEuUE9JTlRFUlM7XG5cdH07XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLng7XG5cdH07XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUueSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmV2ZW50KCkueTtcblx0fTtcblx0XG5cdC8vIGRlcHJlY2F0ZWQgLS0gc2hvdWxkIHJlbW92ZVxuXHRJbWJhLlBvaW50ZXIudXBkYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29uc29sZS5sb2coJ3VwZGF0ZSB0b3VjaCcpXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKEltYmEuUE9JTlRFUlMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFyeVtpXS5wcm9jZXNzKCk7XG5cdFx0fTtcblx0XHQvLyBuZWVkIHRvIGJlIGFibGUgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdG91Y2gsIG5vP1xuXHRcdHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoSW1iYS5Qb2ludGVyLnVwZGF0ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHR2YXIgbGFzdE5hdGl2ZVRvdWNoVGltZVN0YW1wID0gMDtcblx0dmFyIGxhc3ROYXRpdmVUb3VjaFRpbWVvdXQgPSA1MDtcblx0XG5cdC8vIEltYmEuVG91Y2hcblx0Ly8gQmVnYW5cdEEgZmluZ2VyIHRvdWNoZWQgdGhlIHNjcmVlbi5cblx0Ly8gTW92ZWRcdEEgZmluZ2VyIG1vdmVkIG9uIHRoZSBzY3JlZW4uXG5cdC8vIFN0YXRpb25hcnlcdEEgZmluZ2VyIGlzIHRvdWNoaW5nIHRoZSBzY3JlZW4gYnV0IGhhc24ndCBtb3ZlZC5cblx0Ly8gRW5kZWRcdEEgZmluZ2VyIHdhcyBsaWZ0ZWQgZnJvbSB0aGUgc2NyZWVuLiBUaGlzIGlzIHRoZSBmaW5hbCBwaGFzZSBvZiBhIHRvdWNoLlxuXHQvLyBDYW5jZWxlZCBUaGUgc3lzdGVtIGNhbmNlbGxlZCB0cmFja2luZyBmb3IgdGhlIHRvdWNoLlxuXHRcblx0Lypcblx0Q29uc29saWRhdGVzIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuIFRvdWNoIG9iamVjdHMgcGVyc2lzdCBhY3Jvc3MgYSB0b3VjaCxcblx0ZnJvbSB0b3VjaHN0YXJ0IHVudGlsIGVuZC9jYW5jZWwuIFdoZW4gYSB0b3VjaCBzdGFydHMsIGl0IHdpbGwgdHJhdmVyc2Vcblx0ZG93biBmcm9tIHRoZSBpbm5lcm1vc3QgdGFyZ2V0LCB1bnRpbCBpdCBmaW5kcyBhIG5vZGUgdGhhdCByZXNwb25kcyB0b1xuXHRvbnRvdWNoc3RhcnQuIFVubGVzcyB0aGUgdG91Y2ggaXMgZXhwbGljaXRseSByZWRpcmVjdGVkLCB0aGUgdG91Y2ggd2lsbFxuXHRjYWxsIG9udG91Y2htb3ZlIGFuZCBvbnRvdWNoZW5kIC8gb250b3VjaGNhbmNlbCBvbiB0aGUgcmVzcG9uZGVyIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFxuXHRcdHRhZyBkcmFnZ2FibGVcblx0XHRcdCMgY2FsbGVkIHdoZW4gYSB0b3VjaCBzdGFydHNcblx0XHRcdGRlZiBvbnRvdWNoc3RhcnQgdG91Y2hcblx0XHRcdFx0ZmxhZyAnZHJhZ2dpbmcnXG5cdFx0XHRcdHNlbGZcblx0XHRcdFxuXHRcdFx0IyBjYWxsZWQgd2hlbiB0b3VjaCBtb3ZlcyAtIHNhbWUgdG91Y2ggb2JqZWN0XG5cdFx0XHRkZWYgb250b3VjaG1vdmUgdG91Y2hcblx0XHRcdFx0IyBtb3ZlIHRoZSBub2RlIHdpdGggdG91Y2hcblx0XHRcdFx0Y3NzIHRvcDogdG91Y2guZHksIGxlZnQ6IHRvdWNoLmR4XG5cdFx0XHRcblx0XHRcdCMgY2FsbGVkIHdoZW4gdG91Y2ggZW5kc1xuXHRcdFx0ZGVmIG9udG91Y2hlbmQgdG91Y2hcblx0XHRcdFx0dW5mbGFnICdkcmFnZ2luZydcblx0XG5cdEBpbmFtZSB0b3VjaFxuXHQqL1xuXHRcblx0SW1iYS5Ub3VjaCA9IGZ1bmN0aW9uIFRvdWNoKGV2ZW50LHBvaW50ZXIpe1xuXHRcdC8vIEBuYXRpdmUgID0gZmFsc2Vcblx0XHR0aGlzLnNldEV2ZW50KGV2ZW50KTtcblx0XHR0aGlzLnNldERhdGEoe30pO1xuXHRcdHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuXHRcdHRoaXMuX2J1dHRvbiA9IGV2ZW50ICYmIGV2ZW50LmJ1dHRvbiB8fCAwO1xuXHRcdHRoaXMuX3N1cHByZXNzID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcblx0XHR0aGlzLl9jYXB0dXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuc2V0QnViYmxlKGZhbHNlKTtcblx0XHRwb2ludGVyID0gcG9pbnRlcjtcblx0XHR0aGlzLnNldFVwZGF0ZXMoMCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHR2YXIgdG91Y2hlcyA9IFtdO1xuXHR2YXIgY291bnQgPSAwO1xuXHR2YXIgaWRlbnRpZmllcnMgPSB7fTtcblx0XG5cdEltYmEuVG91Y2guY291bnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gY291bnQ7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLmxvb2t1cCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHRyZXR1cm4gaXRlbSAmJiAoaXRlbS5fX3RvdWNoX18gfHwgaWRlbnRpZmllcnNbaXRlbS5pZGVudGlmaWVyXSk7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnJlbGVhc2UgPSBmdW5jdGlvbiAoaXRlbSx0b3VjaCl7XG5cdFx0dmFyIHZfLCAkMTtcblx0XHQoKCh2XyA9IGlkZW50aWZpZXJzW2l0ZW0uaWRlbnRpZmllcl0pLGRlbGV0ZSBpZGVudGlmaWVyc1tpdGVtLmlkZW50aWZpZXJdLCB2XykpO1xuXHRcdCgoKCQxID0gaXRlbS5fX3RvdWNoX18pLGRlbGV0ZSBpdGVtLl9fdG91Y2hfXywgJDEpKTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZS5jaGFuZ2VkVG91Y2hlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dCA9IGFyeVtpXTtcblx0XHRcdGlmICh0aGlzLmxvb2t1cCh0KSkgeyBjb250aW51ZTsgfTtcblx0XHRcdHZhciB0b3VjaCA9IGlkZW50aWZpZXJzW3QuaWRlbnRpZmllcl0gPSBuZXcgdGhpcyhlKTsgLy8gKGUpXG5cdFx0XHR0Ll9fdG91Y2hfXyA9IHRvdWNoO1xuXHRcdFx0dG91Y2hlcy5wdXNoKHRvdWNoKTtcblx0XHRcdGNvdW50Kys7XG5cdFx0XHR0b3VjaC50b3VjaHN0YXJ0KGUsdCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub250b3VjaG1vdmUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIHRvdWNoO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChlLmNoYW5nZWRUb3VjaGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0ID0gYXJ5W2ldO1xuXHRcdFx0aWYgKHRvdWNoID0gdGhpcy5sb29rdXAodCkpIHtcblx0XHRcdFx0dG91Y2gudG91Y2htb3ZlKGUsdCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9udG91Y2hlbmQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIHRvdWNoO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChlLmNoYW5nZWRUb3VjaGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0ID0gYXJ5W2ldO1xuXHRcdFx0aWYgKHRvdWNoID0gdGhpcy5sb29rdXAodCkpIHtcblx0XHRcdFx0dG91Y2gudG91Y2hlbmQoZSx0KTtcblx0XHRcdFx0dGhpcy5yZWxlYXNlKHQsdG91Y2gpO1xuXHRcdFx0XHRjb3VudC0tO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGUucHJldmVudERlZmF1bHRcblx0XHQvLyBub3QgYWx3YXlzIHN1cHBvcnRlZCFcblx0XHQvLyB0b3VjaGVzID0gdG91Y2hlcy5maWx0ZXIofHwpXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9udG91Y2hjYW5jZWwgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIHRvdWNoO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChlLmNoYW5nZWRUb3VjaGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0ID0gYXJ5W2ldO1xuXHRcdFx0aWYgKHRvdWNoID0gdGhpcy5sb29rdXAodCkpIHtcblx0XHRcdFx0dG91Y2gudG91Y2hjYW5jZWwoZSx0KTtcblx0XHRcdFx0dGhpcy5yZWxlYXNlKHQsdG91Y2gpO1xuXHRcdFx0XHRjb3VudC0tO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5vbm1vdXNlZG93biA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnBoYXNlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9waGFzZTsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRQaGFzZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9waGFzZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hY3RpdmUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXZlbnQ7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0RXZlbnQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZXZlbnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5wb2ludGVyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wb2ludGVyOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFBvaW50ZXIgPSBmdW5jdGlvbih2KXsgdGhpcy5fcG9pbnRlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnRhcmdldCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdGFyZ2V0OyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFRhcmdldCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90YXJnZXQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9oYW5kbGVyOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEhhbmRsZXIgPSBmdW5jdGlvbih2KXsgdGhpcy5faGFuZGxlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnVwZGF0ZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3VwZGF0ZXM7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0VXBkYXRlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl91cGRhdGVzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc3VwcHJlc3MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3N1cHByZXNzOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFN1cHByZXNzID0gZnVuY3Rpb24odil7IHRoaXMuX3N1cHByZXNzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24odil7IHRoaXMuX2RhdGEgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLl9fYnViYmxlID0ge2NoYWluYWJsZTogdHJ1ZSxuYW1lOiAnYnViYmxlJ307XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkID8gKHRoaXMuc2V0QnViYmxlKHYpLHRoaXMpIDogdGhpcy5fYnViYmxlOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEJ1YmJsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9idWJibGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZ2VzdHVyZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2dlc3R1cmVzOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEdlc3R1cmVzID0gZnVuY3Rpb24odil7IHRoaXMuX2dlc3R1cmVzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHQvKlxuXHRcdFxuXHRcblx0XHRAaW50ZXJuYWxcblx0XHRAY29uc3RydWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX2NhcHR1cmVkID0gdHJ1ZTtcblx0XHR0aGlzLl9ldmVudCAmJiB0aGlzLl9ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuaXNDYXB0dXJlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAhIXRoaXMuX2NhcHR1cmVkO1xuXHR9O1xuXHRcblx0Lypcblx0XHRFeHRlbmQgdGhlIHRvdWNoIHdpdGggYSBwbHVnaW4gLyBnZXN0dXJlLiBcblx0XHRBbGwgZXZlbnRzICh0b3VjaHN0YXJ0LG1vdmUgZXRjKSBmb3IgdGhlIHRvdWNoXG5cdFx0d2lsbCBiZSB0cmlnZ2VyZWQgb24gdGhlIHBsdWdpbnMgaW4gdGhlIG9yZGVyIHRoZXlcblx0XHRhcmUgYWRkZWQuXG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChwbHVnaW4pe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkZWQgZ2VzdHVyZSEhIVwiXG5cdFx0dGhpcy5fZ2VzdHVyZXMgfHwgKHRoaXMuX2dlc3R1cmVzID0gW10pO1xuXHRcdHRoaXMuX2dlc3R1cmVzLnB1c2gocGx1Z2luKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0UmVkaXJlY3QgdG91Y2ggdG8gc3BlY2lmaWVkIHRhcmdldC4gb250b3VjaHN0YXJ0IHdpbGwgYWx3YXlzIGJlXG5cdFx0Y2FsbGVkIG9uIHRoZSBuZXcgdGFyZ2V0LlxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiAodGFyZ2V0KXtcblx0XHR0aGlzLl9yZWRpcmVjdCA9IHRhcmdldDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U3VwcHJlc3MgdGhlIGRlZmF1bHQgYmVoYXZpb3VyLiBXaWxsIGNhbGwgcHJldmVudERlZmF1bHQgZm9yXG5cdFx0YWxsIG5hdGl2ZSBldmVudHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgdG91Y2guXG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnN1cHByZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29sbGlzaW9uIHdpdGggdGhlIHN1cHByZXNzIHByb3BlcnR5XG5cdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRTdXBwcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0Y29uc29sZS53YXJuKCdJbWJhLlRvdWNoI3N1cHByZXNzPSBpcyBkZXByZWNhdGVkJyk7XG5cdFx0dGhpcy5fc3VwcmVzcyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHRoaXMuX2V2ZW50ID0gZTtcblx0XHR0aGlzLl90b3VjaCA9IHQ7XG5cdFx0dGhpcy5fYnV0dG9uID0gMDtcblx0XHR0aGlzLl94ID0gdC5jbGllbnRYO1xuXHRcdHRoaXMuX3kgPSB0LmNsaWVudFk7XG5cdFx0dGhpcy5iZWdhbigpO1xuXHRcdGlmIChlICYmIHRoaXMuaXNDYXB0dXJlZCgpKSB7IGUucHJldmVudERlZmF1bHQoKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0dGhpcy5fZXZlbnQgPSBlO1xuXHRcdHRoaXMuX3ggPSB0LmNsaWVudFg7XG5cdFx0dGhpcy5feSA9IHQuY2xpZW50WTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdGlmIChlICYmIHRoaXMuaXNDYXB0dXJlZCgpKSB7IGUucHJldmVudERlZmF1bHQoKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR0aGlzLl9ldmVudCA9IGU7XG5cdFx0dGhpcy5feCA9IHQuY2xpZW50WDtcblx0XHR0aGlzLl95ID0gdC5jbGllbnRZO1xuXHRcdHRoaXMuZW5kZWQoKTtcblx0XHRcblx0XHRsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXAgPSBlLnRpbWVTdGFtcDtcblx0XHRcblx0XHRpZiAodGhpcy5fbWF4ZHIgPCAyMCkge1xuXHRcdFx0dmFyIHRhcCA9IG5ldyBJbWJhLkV2ZW50KGUpO1xuXHRcdFx0dGFwLnNldFR5cGUoJ3RhcCcpO1xuXHRcdFx0dGFwLnByb2Nlc3MoKTtcblx0XHRcdGlmICh0YXAuX3Jlc3BvbmRlcikgeyBlLnByZXZlbnREZWZhdWx0KCkgfTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChlICYmIHRoaXMuaXNDYXB0dXJlZCgpKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0cmV0dXJuIHRoaXMuY2FuY2VsKCk7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fZXZlbnQgPSBlO1xuXHRcdHNlbGYuX2J1dHRvbiA9IGUuYnV0dG9uO1xuXHRcdHNlbGYuX3ggPSB0LmNsaWVudFg7XG5cdFx0c2VsZi5feSA9IHQuY2xpZW50WTtcblx0XHRzZWxmLmJlZ2FuKCk7XG5cdFx0XG5cdFx0c2VsZi5fbW91c2Vtb3ZlID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi5tb3VzZW1vdmUoZSxlKTsgfTtcblx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxzZWxmLl9tb3VzZW1vdmUsdHJ1ZSk7XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR0aGlzLl94ID0gdC5jbGllbnRYO1xuXHRcdHRoaXMuX3kgPSB0LmNsaWVudFk7XG5cdFx0dGhpcy5fZXZlbnQgPSBlO1xuXHRcdGlmICh0aGlzLmlzQ2FwdHVyZWQoKSkgeyBlLnByZXZlbnREZWZhdWx0KCkgfTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdHRoaXMubW92ZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUubW91c2V1cCA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHRoaXMuX3ggPSB0LmNsaWVudFg7XG5cdFx0dGhpcy5feSA9IHQuY2xpZW50WTtcblx0XHR0aGlzLmVuZGVkKCk7XG5cdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsdGhpcy5fbW91c2Vtb3ZlLHRydWUpO1xuXHRcdHRoaXMuX21vdXNlbW92ZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5pZGxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5iZWdhbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX21heGRyID0gdGhpcy5fZHIgPSAwO1xuXHRcdHRoaXMuX3gwID0gdGhpcy5feDtcblx0XHR0aGlzLl95MCA9IHRoaXMuX3k7XG5cdFx0XG5cdFx0dmFyIGRvbSA9IHRoaXMuZXZlbnQoKS50YXJnZXQ7XG5cdFx0dmFyIG5vZGUgPSBudWxsO1xuXHRcdFxuXHRcdHRoaXMuX3NvdXJjZVRhcmdldCA9IGRvbSAmJiB0YWckd3JhcChkb20pO1xuXHRcdFxuXHRcdHdoaWxlIChkb20pe1xuXHRcdFx0bm9kZSA9IHRhZyR3cmFwKGRvbSk7XG5cdFx0XHRpZiAobm9kZSAmJiBub2RlLm9udG91Y2hzdGFydCkge1xuXHRcdFx0XHR0aGlzLl9idWJibGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5zZXRUYXJnZXQobm9kZSk7XG5cdFx0XHRcdHRoaXMudGFyZ2V0KCkub250b3VjaHN0YXJ0KHRoaXMpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2J1YmJsZSkgeyBicmVhazsgfTtcblx0XHRcdH07XG5cdFx0XHRkb20gPSBkb20ucGFyZW50Tm9kZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX3VwZGF0ZXMrKztcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0YXJnZXRfO1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0dmFyIGRyID0gTWF0aC5zcXJ0KHRoaXMuZHgoKSAqIHRoaXMuZHgoKSArIHRoaXMuZHkoKSAqIHRoaXMuZHkoKSk7XG5cdFx0aWYgKGRyID4gdGhpcy5fZHIpIHsgdGhpcy5fbWF4ZHIgPSBkciB9O1xuXHRcdHRoaXMuX2RyID0gZHI7XG5cdFx0XG5cdFx0Ly8gY2F0Y2hpbmcgYSB0b3VjaC1yZWRpcmVjdD8hP1xuXHRcdGlmICh0aGlzLl9yZWRpcmVjdCkge1xuXHRcdFx0aWYgKHRoaXMuX3RhcmdldCAmJiB0aGlzLl90YXJnZXQub250b3VjaGNhbmNlbCkge1xuXHRcdFx0XHR0aGlzLl90YXJnZXQub250b3VjaGNhbmNlbCh0aGlzKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnNldFRhcmdldCh0aGlzLl9yZWRpcmVjdCk7XG5cdFx0XHR0aGlzLl9yZWRpcmVjdCA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy50YXJnZXQoKS5vbnRvdWNoc3RhcnQpIHsgdGhpcy50YXJnZXQoKS5vbnRvdWNoc3RhcnQodGhpcykgfTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRoaXMuX3VwZGF0ZXMrKztcblx0XHRpZiAodGhpcy5fZ2VzdHVyZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9nZXN0dXJlcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0ub250b3VjaHVwZGF0ZSh0aGlzKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQodGFyZ2V0XyA9IHRoaXMudGFyZ2V0KCkpICYmIHRhcmdldF8ub250b3VjaHVwZGF0ZSAgJiYgIHRhcmdldF8ub250b3VjaHVwZGF0ZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdGFyZ2V0Xztcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9nZXN0dXJlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2dlc3R1cmVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgZzsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGcgPSBhcnlbaV07XG5cdFx0XHRcdGlmIChnLm9udG91Y2htb3ZlKSB7IGcub250b3VjaG1vdmUodGhpcyx0aGlzLl9ldmVudCkgfTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQodGFyZ2V0XyA9IHRoaXMudGFyZ2V0KCkpICYmIHRhcmdldF8ub250b3VjaG1vdmUgICYmICB0YXJnZXRfLm9udG91Y2htb3ZlKHRoaXMsdGhpcy5fZXZlbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZW5kZWQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdGFyZ2V0Xztcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFxuXHRcdHRoaXMuX3VwZGF0ZXMrKztcblx0XHRcblx0XHRpZiAodGhpcy5fZ2VzdHVyZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9nZXN0dXJlcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0ub250b3VjaGVuZCh0aGlzKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQodGFyZ2V0XyA9IHRoaXMudGFyZ2V0KCkpICYmIHRhcmdldF8ub250b3VjaGVuZCAgJiYgIHRhcmdldF8ub250b3VjaGVuZCh0aGlzKTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghdGhpcy5fY2FuY2VsbGVkKSB7XG5cdFx0XHR0aGlzLl9jYW5jZWxsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5jYW5jZWxsZWQoKTtcblx0XHRcdGlmICh0aGlzLl9tb3VzZW1vdmUpIHsgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsdGhpcy5fbW91c2Vtb3ZlLHRydWUpIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmNhbmNlbGxlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0YXJnZXRfO1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0dGhpcy5fY2FuY2VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLl91cGRhdGVzKys7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2dlc3R1cmVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fZ2VzdHVyZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBnOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0ZyA9IGFyeVtpXTtcblx0XHRcdFx0aWYgKGcub250b3VjaGNhbmNlbCkgeyBnLm9udG91Y2hjYW5jZWwodGhpcykgfTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQodGFyZ2V0XyA9IHRoaXMudGFyZ2V0KCkpICYmIHRhcmdldF8ub250b3VjaGNhbmNlbCAgJiYgIHRhcmdldF8ub250b3VjaGNhbmNlbCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhlIGFic29sdXRlIGRpc3RhbmNlIHRoZSB0b3VjaCBoYXMgbW92ZWQgZnJvbSBzdGFydGluZyBwb3NpdGlvbiBcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmRyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RyO1xuXHR9O1xuXHRcblx0Lypcblx0XHRUaGUgZGlzdGFuY2UgdGhlIHRvdWNoIGhhcyBtb3ZlZCBob3Jpem9udGFsbHlcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmR4ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ggLSB0aGlzLl94MDtcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhlIGRpc3RhbmNlIHRoZSB0b3VjaCBoYXMgbW92ZWQgdmVydGljYWxseVxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5feSAtIHRoaXMuX3kwO1xuXHR9O1xuXHRcblx0Lypcblx0XHRJbml0aWFsIGhvcml6b250YWwgcG9zaXRpb24gb2YgdG91Y2hcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLngwID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3gwO1xuXHR9O1xuXHRcblx0Lypcblx0XHRJbml0aWFsIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRvdWNoXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS55MCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl95MDtcblx0fTtcblx0XG5cdC8qXG5cdFx0SG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0b3VjaFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUueCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9O1xuXHRcblx0Lypcblx0XHRWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0b3VjaFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUueSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9O1xuXHRcblx0Lypcblx0XHRIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRvdWNoIHJlbGF0aXZlIHRvIHRhcmdldFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudHggPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl90YXJnZXRCb3ggfHwgKHRoaXMuX3RhcmdldEJveCA9IHRoaXMuX3RhcmdldC5kb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG5cdFx0cmV0dXJuIHRoaXMuX3ggLSB0aGlzLl90YXJnZXRCb3gubGVmdDtcblx0fTtcblx0XG5cdC8qXG5cdFx0VmVydGljYWwgcG9zaXRpb24gb2YgdG91Y2ggcmVsYXRpdmUgdG8gdGFyZ2V0XG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS50eSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX3RhcmdldEJveCB8fCAodGhpcy5fdGFyZ2V0Qm94ID0gdGhpcy5fdGFyZ2V0LmRvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcblx0XHRyZXR1cm4gdGhpcy5feSAtIHRoaXMuX3RhcmdldEJveC50b3A7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEJ1dHRvbiBwcmVzc2VkIGluIHRoaXMgdG91Y2guIE5hdGl2ZSB0b3VjaGVzIGRlZmF1bHRzIHRvIGxlZnQtY2xpY2sgKDApXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5idXR0b24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYnV0dG9uO1xuXHR9OyAvLyBAcG9pbnRlciA/IEBwb2ludGVyLmJ1dHRvbiA6IDBcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNvdXJjZVRhcmdldCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9zb3VyY2VUYXJnZXQ7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaEdlc3R1cmUgPSBmdW5jdGlvbiBUb3VjaEdlc3R1cmUoKXsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUuX19hY3RpdmUgPSB7J2RlZmF1bHQnOiBmYWxzZSxuYW1lOiAnYWN0aXZlJ307XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24odil7IHRoaXMuX2FjdGl2ZSA9IHY7IHJldHVybiB0aGlzOyB9XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5fYWN0aXZlID0gZmFsc2U7XG5cdFxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaEdlc3R1cmUucHJvdG90eXBlLm9udG91Y2h1cGRhdGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUub250b3VjaGVuZCA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHQvLyBBIFRvdWNoLWV2ZW50IGlzIGNyZWF0ZWQgb24gbW91c2Vkb3duIChhbHdheXMpXG5cdC8vIGFuZCB3aGlsZSBpdCBleGlzdHMsIG1vdXNlbW92ZSBhbmQgbW91c2V1cCB3aWxsXG5cdC8vIGJlIGRlbGVnYXRlZCB0byB0aGlzIGFjdGl2ZSBldmVudC5cblx0SW1iYS5QT0lOVEVSID0gbmV3IEltYmEuUG9pbnRlcigpO1xuXHRJbWJhLlBPSU5URVJTID0gW0ltYmEuUE9JTlRFUl07XG5cdFxuXHRcblx0Ly8gcmVndWxhciBldmVudCBzdHVmZlxuXHRJbWJhLktFWU1BUCA9IHtcblx0XHRcIjhcIjogJ2JhY2tzcGFjZScsXG5cdFx0XCI5XCI6ICd0YWInLFxuXHRcdFwiMTNcIjogJ2VudGVyJyxcblx0XHRcIjE2XCI6ICdzaGlmdCcsXG5cdFx0XCIxN1wiOiAnY3RybCcsXG5cdFx0XCIxOFwiOiAnYWx0Jyxcblx0XHRcIjE5XCI6ICdicmVhaycsXG5cdFx0XCIyMFwiOiAnY2FwcycsXG5cdFx0XCIyN1wiOiAnZXNjJyxcblx0XHRcIjMyXCI6ICdzcGFjZScsXG5cdFx0XCIzNVwiOiAnZW5kJyxcblx0XHRcIjM2XCI6ICdob21lJyxcblx0XHRcIjM3XCI6ICdsYXJyJyxcblx0XHRcIjM4XCI6ICd1YXJyJyxcblx0XHRcIjM5XCI6ICdyYXJyJyxcblx0XHRcIjQwXCI6ICdkYXJyJyxcblx0XHRcIjQ1XCI6ICdpbnNlcnQnLFxuXHRcdFwiNDZcIjogJ2RlbGV0ZScsXG5cdFx0XCIxMDdcIjogJ3BsdXMnLFxuXHRcdFwiMTA2XCI6ICdtdWx0Jyxcblx0XHRcIjkxXCI6ICdtZXRhJ1xuXHR9O1xuXHRcblx0SW1iYS5DSEFSTUFQID0ge1xuXHRcdFwiJVwiOiAnbW9kdWxvJyxcblx0XHRcIipcIjogJ211bHRpcGx5Jyxcblx0XHRcIitcIjogJ2FkZCcsXG5cdFx0XCItXCI6ICdzdWInLFxuXHRcdFwiL1wiOiAnZGl2aWRlJyxcblx0XHRcIi5cIjogJ2RvdCdcblx0fTtcblx0XG5cdC8qXG5cdEltYmEgaGFuZGxlcyBhbGwgZXZlbnRzIGluIHRoZSBkb20gdGhyb3VnaCBhIHNpbmdsZSBtYW5hZ2VyLFxuXHRsaXN0ZW5pbmcgYXQgdGhlIHJvb3Qgb2YgeW91ciBkb2N1bWVudC4gSWYgSW1iYSBmaW5kcyBhIHRhZ1xuXHR0aGF0IGxpc3RlbnMgdG8gYSBjZXJ0YWluIGV2ZW50LCB0aGUgZXZlbnQgd2lsbCBiZSB3cmFwcGVkIFxuXHRpbiBhbiBgSW1iYS5FdmVudGAsIHdoaWNoIG5vcm1hbGl6ZXMgc29tZSBvZiB0aGUgcXVpcmtzIGFuZCBcblx0YnJvd3NlciBkaWZmZXJlbmNlcy5cblx0XG5cdEBpbmFtZSBldmVudFxuXHQqL1xuXHRcblx0SW1iYS5FdmVudCA9IGZ1bmN0aW9uIEV2ZW50KGUpe1xuXHRcdHRoaXMuc2V0RXZlbnQoZSk7XG5cdFx0dGhpcy5zZXRCdWJibGUodHJ1ZSk7XG5cdH07XG5cdFxuXHQvKiByZWZlcmVuY2UgdG8gdGhlIG5hdGl2ZSBldmVudCAqL1xuXHRcblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXZlbnQ7IH1cblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0RXZlbnQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZXZlbnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdC8qIHJlZmVyZW5jZSB0byB0aGUgbmF0aXZlIGV2ZW50ICovXG5cdFxuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnByZWZpeCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcHJlZml4OyB9XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNldFByZWZpeCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wcmVmaXggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24odil7IHRoaXMuX2RhdGEgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdC8qXG5cdFx0c2hvdWxkIHJlbW92ZSB0aGlzIGFsbHRvZ2V0aGVyP1xuXHRcdEBkZXByZWNhdGVkXG5cdFx0Ki9cblx0XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zb3VyY2U7IH1cblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24odil7IHRoaXMuX3NvdXJjZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0LyogQSB7Qm9vbGVhbn0gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBldmVudCBidWJibGVzIHVwIG9yIG5vdCAqL1xuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLl9fYnViYmxlID0ge3R5cGU6IEJvb2xlYW4sY2hhaW5hYmxlOiB0cnVlLG5hbWU6ICdidWJibGUnfTtcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24odil7IHJldHVybiB2ICE9PSB1bmRlZmluZWQgPyAodGhpcy5zZXRCdWJibGUodiksdGhpcykgOiB0aGlzLl9idWJibGU7IH1cblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0QnViYmxlID0gZnVuY3Rpb24odil7IHRoaXMuX2J1YmJsZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SW1iYS5FdmVudC53cmFwID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiBuZXcgdGhpcyhlKTtcblx0fTtcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbiAodHlwZSl7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEByZXR1cm4ge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChjYXNlLWluc2Vuc2l0aXZlKVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgfHwgdGhpcy5ldmVudCgpLnR5cGU7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWUgfHwgKHRoaXMuX25hbWUgPSB0aGlzLnR5cGUoKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcOi9nLCcnKSk7XG5cdH07XG5cdFxuXHQvLyBtaW1jIGdldHNldFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbiAodil7XG5cdFx0aWYgKHYgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldEJ1YmJsZSh2KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMuX2J1YmJsZTtcblx0fTtcblx0XG5cdC8qXG5cdFx0UHJldmVudHMgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgY3VycmVudCBldmVudC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5zZXRCdWJibGUoZmFsc2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRDYW5jZWwgdGhlIGV2ZW50IChpZiBjYW5jZWxhYmxlKS4gSW4gdGhlIGNhc2Ugb2YgbmF0aXZlIGV2ZW50cyBpdFxuXHRcdHdpbGwgY2FsbCBgcHJldmVudERlZmF1bHRgIG9uIHRoZSB3cmFwcGVkIGV2ZW50IG9iamVjdC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5ldmVudCgpLnByZXZlbnREZWZhdWx0KSB7IHRoaXMuZXZlbnQoKS5wcmV2ZW50RGVmYXVsdCgpIH07XG5cdFx0dGhpcy5fY2FuY2VsID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0SW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IGV2ZW50LmNhbmNlbCBoYXMgYmVlbiBjYWxsZWQuXG5cdFxuXHRcdEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmlzUHJldmVudGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQoKSAmJiB0aGlzLmV2ZW50KCkuZGVmYXVsdFByZXZlbnRlZCB8fCB0aGlzLl9jYW5jZWw7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEEgcmVmZXJlbmNlIHRvIHRoZSBpbml0aWFsIHRhcmdldCBvZiB0aGUgZXZlbnQuXG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnRhcmdldCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0YWckd3JhcCh0aGlzLmV2ZW50KCkuX3RhcmdldCB8fCB0aGlzLmV2ZW50KCkudGFyZ2V0KTtcblx0fTtcblx0XG5cdC8qXG5cdFx0QSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCByZXNwb25kaW5nIHRvIHRoZSBldmVudC5cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUucmVzcG9uZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3BvbmRlcjtcblx0fTtcblx0XG5cdC8qXG5cdFx0UmVkaXJlY3QgdGhlIGV2ZW50IHRvIG5ldyB0YXJnZXRcblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0dGhpcy5fcmVkaXJlY3QgPSBub2RlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRHZXQgdGhlIG5vcm1hbGl6ZWQgY2hhcmFjdGVyIGZvciBLZXlib2FyZEV2ZW50L1RleHRFdmVudFxuXHRcdEByZXR1cm4ge1N0cmluZ31cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUua2V5Y2hhciA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLmV2ZW50KCkgaW5zdGFuY2VvZiBUZXh0RXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmV2ZW50KCkuZGF0YTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLmV2ZW50KCkgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG5cdFx0XHR2YXIga2kgPSB0aGlzLmV2ZW50KCkua2V5SWRlbnRpZmllcjtcblx0XHRcdHZhciBzeW0gPSBJbWJhLktFWU1BUFt0aGlzLmV2ZW50KCkua2V5Q29kZV07XG5cdFx0XHRcblx0XHRcdC8vIHAgJ2tleXN5bSEnLGtpLHN5bVxuXHRcdFx0XG5cdFx0XHRpZiAoIXN5bSAmJiBraS5zdWJzdHIoMCwyKSA9PSBcIlUrXCIpIHtcblx0XHRcdFx0c3ltID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChraS5zdWJzdHIoMiksMTYpKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc3ltO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEBkZXByZWNhdGVkXG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmtleWNvbWJvID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHN5bTtcblx0XHRpZiAoIShzeW0gPSB0aGlzLmtleWNoYXIoKSkpIHsgcmV0dXJuIH07XG5cdFx0c3ltID0gSW1iYS5DSEFSTUFQW3N5bV0gfHwgc3ltO1xuXHRcdHZhciBjb21ibyA9IFtdLGUgPSB0aGlzLmV2ZW50KCk7XG5cdFx0aWYgKGUuY3RybEtleSkgeyBjb21iby5wdXNoKCdjdHJsJykgfTtcblx0XHRpZiAoZS5zaGlmdEtleSkgeyBjb21iby5wdXNoKCdzaGlmdCcpIH07XG5cdFx0aWYgKGUuYWx0S2V5KSB7IGNvbWJvLnB1c2goJ2FsdCcpIH07XG5cdFx0aWYgKGUubWV0YUtleSkgeyBjb21iby5wdXNoKCdjbWQnKSB9O1xuXHRcdGNvbWJvLnB1c2goc3ltKTtcblx0XHRyZXR1cm4gY29tYm8uam9pbihcIl9cIikudG9Mb3dlckNhc2UoKTtcblx0fTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG5vZGU7XG5cdFx0dmFyIG1ldGggPSAoXCJvblwiICsgKHRoaXMuX3ByZWZpeCB8fCAnJykgKyB0aGlzLm5hbWUoKSk7XG5cdFx0dmFyIGFyZ3MgPSBudWxsO1xuXHRcdHZhciBkb210YXJnZXQgPSB0aGlzLmV2ZW50KCkuX3RhcmdldCB8fCB0aGlzLmV2ZW50KCkudGFyZ2V0O1xuXHRcdC8vIHZhciBub2RlID0gPHtkb210YXJnZXQ6X3Jlc3BvbmRlciBvciBkb210YXJnZXR9PlxuXHRcdC8vIG5lZWQgdG8gY2xlYW4gdXAgYW5kIGRvY3VtZW50IHRoaXMgYmVoYXZpb3VyXG5cdFx0XG5cdFx0dmFyIGRvbW5vZGUgPSBkb210YXJnZXQuX3Jlc3BvbmRlciB8fCBkb210YXJnZXQ7XG5cdFx0Ly8gQHRvZG8gbmVlZCB0byBzdG9wIGluZmluaXRlIHJlZGlyZWN0LXJ1bGVzIGhlcmVcblx0XHRcblx0XHR2YXIgJDE7d2hpbGUgKGRvbW5vZGUpe1xuXHRcdFx0dGhpcy5fcmVkaXJlY3QgPSBudWxsO1xuXHRcdFx0aWYgKG5vZGUgPSB0YWckd3JhcChkb21ub2RlKSkgeyAvLyBub3Qgb25seSB0YWcgXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoKHR5cGVvZiBub2RlWygkMSA9IG1ldGgpXT09J3N0cmluZyd8fG5vZGVbJDFdIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0XHRcdC8vIHNob3VsZCByZW1lbWJlciB0aGUgcmVjZWl2ZXIgb2YgdGhlIGV2ZW50XG5cdFx0XHRcdFx0bWV0aCA9IG5vZGVbbWV0aF07XG5cdFx0XHRcdFx0Y29udGludWU7IC8vIHNob3VsZCBub3QgY29udGludWU/XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobm9kZVttZXRoXSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0YXJncyA9IG5vZGVbbWV0aF0uY29uY2F0KG5vZGUpO1xuXHRcdFx0XHRcdG1ldGggPSBhcmdzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0Y29udGludWU7IC8vIHNob3VsZCBub3QgY29udGludWU/XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobm9kZVttZXRoXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVzcG9uZGVyIHx8ICh0aGlzLl9yZXNwb25kZXIgPSBub2RlKTtcblx0XHRcdFx0XHQvLyBzaG91bGQgYXV0b3N0b3AgYnViYmxlIGhlcmU/XG5cdFx0XHRcdFx0YXJncyA/IChub2RlW21ldGhdLmFwcGx5KG5vZGUsYXJncykpIDogKG5vZGVbbWV0aF0odGhpcyx0aGlzLmRhdGEoKSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gYWRkIG5vZGUubmV4dEV2ZW50UmVzcG9uZGVyIGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmU/XG5cdFx0XHRpZiAoISh0aGlzLmJ1YmJsZSgpICYmIChkb21ub2RlID0gKHRoaXMuX3JlZGlyZWN0IHx8IChub2RlID8gKG5vZGUucGFyZW50KCkpIDogKGRvbW5vZGUucGFyZW50Tm9kZSkpKSkpKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMucHJvY2Vzc2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2Vzc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0SW1iYS5lbWl0KEltYmEsJ2V2ZW50JyxbdGhpc10pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZXR1cm4gdGhlIHgvbGVmdCBjb29yZGluYXRlIG9mIHRoZSBtb3VzZSAvIHBvaW50ZXIgZm9yIHRoaXMgZXZlbnRcblx0XHRAcmV0dXJuIHtOdW1iZXJ9IHggY29vcmRpbmF0ZSBvZiBtb3VzZSAvIHBvaW50ZXIgZm9yIGV2ZW50XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLng7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJldHVybiB0aGUgeS90b3AgY29vcmRpbmF0ZSBvZiB0aGUgbW91c2UgLyBwb2ludGVyIGZvciB0aGlzIGV2ZW50XG5cdFx0QHJldHVybiB7TnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgbW91c2UgLyBwb2ludGVyIGZvciBldmVudFxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS55ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQoKS55O1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZXR1cm5zIGEgTnVtYmVyIHJlcHJlc2VudGluZyBhIHN5c3RlbSBhbmQgaW1wbGVtZW50YXRpb25cblx0XHRkZXBlbmRlbnQgbnVtZXJpYyBjb2RlIGlkZW50aWZ5aW5nIHRoZSB1bm1vZGlmaWVkIHZhbHVlIG9mIHRoZVxuXHRcdHByZXNzZWQga2V5OyB0aGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgYXMga2V5Q29kZS5cblx0XG5cdFx0Rm9yIG1vdXNlLWV2ZW50cywgdGhlIHJldHVybmVkIHZhbHVlIGluZGljYXRlcyB3aGljaCBidXR0b24gd2FzXG5cdFx0cHJlc3NlZCBvbiB0aGUgbW91c2UgdG8gdHJpZ2dlciB0aGUgZXZlbnQuXG5cdFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUud2hpY2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLndoaWNoO1xuXHR9O1xuXHRcblx0XG5cdC8qXG5cdFxuXHRNYW5hZ2VyIGZvciBsaXN0ZW5pbmcgdG8gYW5kIGRlbGVnYXRpbmcgZXZlbnRzIGluIEltYmEuIEEgc2luZ2xlIGluc3RhbmNlXG5cdGlzIGFsd2F5cyBjcmVhdGVkIGJ5IEltYmEgKGFzIGBJbWJhLkV2ZW50c2ApLCB3aGljaCBoYW5kbGVzIGFuZCBkZWxlZ2F0ZXMgYWxsXG5cdGV2ZW50cyBhdCB0aGUgdmVyeSByb290IG9mIHRoZSBkb2N1bWVudC4gSW1iYSBkb2VzIG5vdCBjYXB0dXJlIGFsbCBldmVudHNcblx0YnkgZGVmYXVsdCwgc28gaWYgeW91IHdhbnQgdG8gbWFrZSBzdXJlIGV4b3RpYyBvciBjdXN0b20gRE9NRXZlbnRzIGFyZSBkZWxlZ2F0ZWRcblx0aW4gSW1iYSB5b3Ugd2lsbCBuZWVkIHRvIHJlZ2lzdGVyIHRoZW0gaW4gYEltYmEuRXZlbnRzLnJlZ2lzdGVyKG15Q3VzdG9tRXZlbnROYW1lKWBcblx0XG5cdEBpbmFtZSBtYW5hZ2VyXG5cdFxuXHQqL1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIgPSBmdW5jdGlvbiBFdmVudE1hbmFnZXIobm9kZSxwYXJzKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdHZhciBldmVudHMgPSBwYXJzLmV2ZW50cyAhPT0gdW5kZWZpbmVkID8gcGFycy5ldmVudHMgOiBbXTtcblx0XHRzZWxmLnNldFJvb3Qobm9kZSk7XG5cdFx0c2VsZi5zZXRDb3VudCgwKTtcblx0XHRzZWxmLnNldExpc3RlbmVycyhbXSk7XG5cdFx0c2VsZi5zZXREZWxlZ2F0b3JzKHt9KTtcblx0XHRzZWxmLnNldERlbGVnYXRvcihmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImRlbGVnYXRpbmcgZXZlbnQ/ISB7ZX1cIlxuXHRcdFx0c2VsZi5kZWxlZ2F0ZShlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChldmVudHMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHNlbGYucmVnaXN0ZXIoYXJ5W2ldKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm9vdDsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0Um9vdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yb290ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb3VudDsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0Q291bnQgPSBmdW5jdGlvbih2KXsgdGhpcy5fY291bnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fX2VuYWJsZWQgPSB7J2RlZmF1bHQnOiBmYWxzZSx3YXRjaDogJ2VuYWJsZWREaWRTZXQnLG5hbWU6ICdlbmFibGVkJ307XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lbmFibGVkOyB9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXRFbmFibGVkID0gZnVuY3Rpb24odil7XG5cdFx0dmFyIGEgPSB0aGlzLmVuYWJsZWQoKTtcblx0XHRpZih2ICE9IGEpIHsgdGhpcy5fZW5hYmxlZCA9IHY7IH1cblx0XHRpZih2ICE9IGEpIHsgdGhpcy5lbmFibGVkRGlkU2V0ICYmIHRoaXMuZW5hYmxlZERpZFNldCh2LGEsdGhpcy5fX2VuYWJsZWQpIH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuX2VuYWJsZWQgPSBmYWxzZTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9saXN0ZW5lcnM7IH1cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnNldExpc3RlbmVycyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9saXN0ZW5lcnMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZGVsZWdhdG9ycyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGVsZWdhdG9yczsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0RGVsZWdhdG9ycyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kZWxlZ2F0b3JzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmRlbGVnYXRvciA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGVsZWdhdG9yOyB9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXREZWxlZ2F0b3IgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGVsZWdhdG9yID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZW5hYmxlZERpZFNldCA9IGZ1bmN0aW9uIChib29sKXtcblx0XHRib29sID8gKHRoaXMub25lbmFibGUoKSkgOiAodGhpcy5vbmRpc2FibGUoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0XHRUZWxsIHRoZSBjdXJyZW50IEV2ZW50TWFuYWdlciB0byBpbnRlcmNlcHQgYW5kIGhhbmRsZSBldmVudCBvZiBhIGNlcnRhaW4gbmFtZS5cblx0XHRCeSBkZWZhdWx0LCBJbWJhLkV2ZW50cyB3aWxsIHJlZ2lzdGVyIGludGVyY2VwdG9ycyBmb3I6ICprZXlkb3duKiwgKmtleXVwKiwgXG5cdFx0KmtleXByZXNzKiwgKnRleHRJbnB1dCosICppbnB1dCosICpjaGFuZ2UqLCAqc3VibWl0KiwgKmZvY3VzaW4qLCAqZm9jdXNvdXQqLCBcblx0XHQqYmx1ciosICpjb250ZXh0bWVudSosICpkYmxjbGljayosICptb3VzZXdoZWVsKiwgKndoZWVsKlxuXHRcblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWUsaGFuZGxlcil7XG5cdFx0aWYoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSBoYW5kbGVyID0gdHJ1ZTtcblx0XHRpZiAobmFtZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobmFtZSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyKGFyeVtpXSxoYW5kbGVyKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLmRlbGVnYXRvcnMoKVtuYW1lXSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdC8vIGNvbnNvbGUubG9nKFwicmVnaXN0ZXIgZm9yIGV2ZW50IHtuYW1lfVwiKVxuXHRcdHZhciBmbiA9IHRoaXMuZGVsZWdhdG9ycygpW25hbWVdID0gaGFuZGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gKGhhbmRsZXIpIDogKHRoaXMuZGVsZWdhdG9yKCkpO1xuXHRcdGlmICh0aGlzLmVuYWJsZWQoKSkgeyByZXR1cm4gdGhpcy5yb290KCkuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLGZuLHRydWUpIH07XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKG5hbWUsaGFuZGxlcixjYXB0dXJlKXtcblx0XHRpZihjYXB0dXJlID09PSB1bmRlZmluZWQpIGNhcHR1cmUgPSB0cnVlO1xuXHRcdHRoaXMubGlzdGVuZXJzKCkucHVzaChbbmFtZSxoYW5kbGVyLGNhcHR1cmVdKTtcblx0XHRpZiAodGhpcy5lbmFibGVkKCkpIHsgdGhpcy5yb290KCkuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLGhhbmRsZXIsY2FwdHVyZSkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5kZWxlZ2F0ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHR0aGlzLnNldENvdW50KHRoaXMuY291bnQoKSArIDEpO1xuXHRcdHZhciBldmVudCA9IEltYmEuRXZlbnQud3JhcChlKTtcblx0XHRldmVudC5wcm9jZXNzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHR5cGUsdGFyZ2V0LHBhcnMpe1xuXHRcdGlmKCFwYXJzfHxwYXJzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHBhcnMgPSB7fTtcblx0XHR2YXIgZGF0YSA9IHBhcnMuZGF0YSAhPT0gdW5kZWZpbmVkID8gcGFycy5kYXRhIDogbnVsbDtcblx0XHR2YXIgc291cmNlID0gcGFycy5zb3VyY2UgIT09IHVuZGVmaW5lZCA/IHBhcnMuc291cmNlIDogbnVsbDtcblx0XHR2YXIgZXZlbnQgPSBJbWJhLkV2ZW50LndyYXAoe3R5cGU6IHR5cGUsdGFyZ2V0OiB0YXJnZXR9KTtcblx0XHRpZiAoZGF0YSkgeyAoZXZlbnQuc2V0RGF0YShkYXRhKSxkYXRhKSB9O1xuXHRcdGlmIChzb3VyY2UpIHsgKGV2ZW50LnNldFNvdXJjZShzb3VyY2UpLHNvdXJjZSkgfTtcblx0XHRyZXR1cm4gZXZlbnQ7XG5cdH07XG5cdFxuXHQvLyB1c2UgY3JlYXRlIGluc3RlYWQ/XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKS5wcm9jZXNzKCk7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUub25lbmFibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRmb3IgKHZhciBvID0gdGhpcy5kZWxlZ2F0b3JzKCksIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMobyksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHR0aGlzLnJvb3QoKS5hZGRFdmVudExpc3RlbmVyKGtleXNbaV0sb1trZXlzW2ldXSx0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdGZvciAodmFyIGogPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmxpc3RlbmVycygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgaXRlbTsgaiA8IGxlbjsgaisrKSB7XG5cdFx0XHRpdGVtID0gYXJ5W2pdO1xuXHRcdFx0dGhpcy5yb290KCkuYWRkRXZlbnRMaXN0ZW5lcihpdGVtWzBdLGl0ZW1bMV0saXRlbVsyXSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5vbmRpc2FibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRmb3IgKHZhciBvID0gdGhpcy5kZWxlZ2F0b3JzKCksIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMobyksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHR0aGlzLnJvb3QoKS5yZW1vdmVFdmVudExpc3RlbmVyKGtleXNbaV0sb1trZXlzW2ldXSx0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdGZvciAodmFyIGogPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmxpc3RlbmVycygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgaXRlbTsgaiA8IGxlbjsgaisrKSB7XG5cdFx0XHRpdGVtID0gYXJ5W2pdO1xuXHRcdFx0dGhpcy5yb290KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihpdGVtWzBdLGl0ZW1bMV0saXRlbVsyXSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRFRCA9IEltYmEuRXZlbnRzID0gbmV3IEltYmEuRXZlbnRNYW5hZ2VyKGRvY3VtZW50LHtldmVudHM6IFtcblx0XHQna2V5ZG93bicsJ2tleXVwJywna2V5cHJlc3MnLCd0ZXh0SW5wdXQnLCdpbnB1dCcsJ2NoYW5nZScsJ3N1Ym1pdCcsXG5cdFx0J2ZvY3VzaW4nLCdmb2N1c291dCcsJ2JsdXInLCdjb250ZXh0bWVudScsJ2RibGNsaWNrJyxcblx0XHQnbW91c2V3aGVlbCcsJ3doZWVsJ1xuXHRdfSk7XG5cdFxuXHQvLyBzaG91bGQgc2V0IHRoZXNlIHVwIGluc2lkZSB0aGUgSW1iYS5FdmVudHMgb2JqZWN0IGl0c2VsZlxuXHQvLyBzbyB0aGF0IHdlIGNhbiBoYXZlIGRpZmZlcmVudCBFdmVudE1hbmFnZXIgZm9yIGRpZmZlcmVudCByb290c1xuXHRcblx0aWYgKGhhc1RvdWNoRXZlbnRzKSB7XG5cdFx0SW1iYS5FdmVudHMubGlzdGVuKCd0b3VjaHN0YXJ0JyxmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgRXZlbnRzXywgdl87XG5cdFx0XHQoKChFdmVudHNfID0gSW1iYS5FdmVudHMpLnNldENvdW50KHZfID0gRXZlbnRzXy5jb3VudCgpICsgMSksdl8pKSAtIDE7XG5cdFx0XHRyZXR1cm4gSW1iYS5Ub3VjaC5vbnRvdWNoc3RhcnQoZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0SW1iYS5FdmVudHMubGlzdGVuKCd0b3VjaG1vdmUnLGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBFdmVudHNfLCB2Xztcblx0XHRcdCgoKEV2ZW50c18gPSBJbWJhLkV2ZW50cykuc2V0Q291bnQodl8gPSBFdmVudHNfLmNvdW50KCkgKyAxKSx2XykpIC0gMTtcblx0XHRcdHJldHVybiBJbWJhLlRvdWNoLm9udG91Y2htb3ZlKGUpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdEltYmEuRXZlbnRzLmxpc3RlbigndG91Y2hlbmQnLGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBFdmVudHNfLCB2Xztcblx0XHRcdCgoKEV2ZW50c18gPSBJbWJhLkV2ZW50cykuc2V0Q291bnQodl8gPSBFdmVudHNfLmNvdW50KCkgKyAxKSx2XykpIC0gMTtcblx0XHRcdHJldHVybiBJbWJhLlRvdWNoLm9udG91Y2hlbmQoZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0SW1iYS5FdmVudHMubGlzdGVuKCd0b3VjaGNhbmNlbCcsZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIEV2ZW50c18sIHZfO1xuXHRcdFx0KCgoRXZlbnRzXyA9IEltYmEuRXZlbnRzKS5zZXRDb3VudCh2XyA9IEV2ZW50c18uY291bnQoKSArIDEpLHZfKSkgLSAxO1xuXHRcdFx0cmV0dXJuIEltYmEuVG91Y2gub250b3VjaGNhbmNlbChlKTtcblx0XHR9KTtcblx0fTtcblx0XG5cdEltYmEuRXZlbnRzLnJlZ2lzdGVyKCdjbGljaycsZnVuY3Rpb24oZSkge1xuXHRcdC8vIE9ubHkgZm9yIG1haW4gbW91c2VidXR0b24sIG5vP1xuXHRcdGlmICgoZS50aW1lU3RhbXAgLSBsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXApID4gbGFzdE5hdGl2ZVRvdWNoVGltZW91dCkge1xuXHRcdFx0dmFyIHRhcCA9IG5ldyBJbWJhLkV2ZW50KGUpO1xuXHRcdFx0dGFwLnNldFR5cGUoJ3RhcCcpO1xuXHRcdFx0dGFwLnByb2Nlc3MoKTtcblx0XHRcdGlmICh0YXAuX3Jlc3BvbmRlcikge1xuXHRcdFx0XHRyZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIGRlbGVnYXRlIHRoZSByZWFsIGNsaWNrIGV2ZW50XG5cdFx0cmV0dXJuIEltYmEuRXZlbnRzLmRlbGVnYXRlKGUpO1xuXHR9KTtcblx0XG5cdEltYmEuRXZlbnRzLmxpc3RlbignbW91c2Vkb3duJyxmdW5jdGlvbihlKSB7XG5cdFx0aWYgKChlLnRpbWVTdGFtcCAtIGxhc3ROYXRpdmVUb3VjaFRpbWVTdGFtcCkgPiBsYXN0TmF0aXZlVG91Y2hUaW1lb3V0KSB7XG5cdFx0XHRpZiAoSW1iYS5QT0lOVEVSKSB7IHJldHVybiBJbWJhLlBPSU5URVIudXBkYXRlKGUpLnByb2Nlc3MoKSB9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0Ly8gSW1iYS5FdmVudHMubGlzdGVuKDptb3VzZW1vdmUpIGRvIHxlfFxuXHQvLyBcdCMgY29uc29sZS5sb2cgJ21vdXNlbW92ZScsZTp0aW1lU3RhbXBcblx0Ly8gXHRpZiAoZTp0aW1lU3RhbXAgLSBsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXApID4gbGFzdE5hdGl2ZVRvdWNoVGltZW91dFxuXHQvLyBcdFx0SW1iYS5QT0lOVEVSLnVwZGF0ZShlKS5wcm9jZXNzIGlmIEltYmEuUE9JTlRFUiAjIC5wcm9jZXNzIGlmIHRvdWNoICMgc2hvdWxkIG5vdCBoYXBwZW4/IFdlIHByb2Nlc3MgdGhyb3VnaCBcblx0XG5cdEltYmEuRXZlbnRzLmxpc3RlbignbW91c2V1cCcsZnVuY3Rpb24oZSkge1xuXHRcdC8vIGNvbnNvbGUubG9nICdtb3VzZXVwJyxlOnRpbWVTdGFtcFxuXHRcdGlmICgoZS50aW1lU3RhbXAgLSBsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXApID4gbGFzdE5hdGl2ZVRvdWNoVGltZW91dCkge1xuXHRcdFx0aWYgKEltYmEuUE9JTlRFUikgeyByZXR1cm4gSW1iYS5QT0lOVEVSLnVwZGF0ZShlKS5wcm9jZXNzKCkgfTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50cy5yZWdpc3RlcihbJ21vdXNlZG93bicsJ21vdXNldXAnXSk7XG5cdHJldHVybiAoSW1iYS5FdmVudHMuc2V0RW5hYmxlZCh0cnVlKSx0cnVlKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20uZXZlbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHR2YXIgSW1iYVRhZyA9IEltYmEuVEFHUy5lbGVtZW50O1xuXHRcblx0ZnVuY3Rpb24gcmVtb3ZlTmVzdGVkKHJvb3Qsbm9kZSxjYXJldCl7XG5cdFx0Ly8gaWYgbm9kZS9ub2RlcyBpc2EgU3RyaW5nXG5cdFx0Ly8gXHR3ZSBuZWVkIHRvIHVzZSB0aGUgY2FyZXQgdG8gcmVtb3ZlIGVsZW1lbnRzXG5cdFx0Ly8gXHRmb3Igbm93IHdlIHdpbGwgc2ltcGx5IG5vdCBzdXBwb3J0IHRoaXNcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdHJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdFx0fSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlbW92ZU5lc3RlZChyb290LGFyeVtpXSxjYXJldCk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB3aGF0IGlmIHRoaXMgaXMgbm90IG51bGw/IT8hP1xuXHRcdFx0Ly8gdGFrZSBhIGNoYW5jZSBhbmQgcmVtb3ZlIGEgdGV4dC1lbGVtZW50bmdcblx0XHRcdHZhciBuZXh0ID0gY2FyZXQgPyAoY2FyZXQubmV4dFNpYmxpbmcpIDogKHJvb3QuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcdGlmICgobmV4dCBpbnN0YW5jZW9mIFRleHQpICYmIG5leHQudGV4dENvbnRlbnQgPT0gbm9kZSkge1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKG5leHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgJ2Nhbm5vdCByZW1vdmUgc3RyaW5nJztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gY2FyZXQ7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBhcHBlbmROZXN0ZWQocm9vdCxub2RlKXtcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdHJvb3QuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0fSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFwcGVuZE5lc3RlZChyb290LGFyeVtpXSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobm9kZSAhPSBudWxsICYmIG5vZGUgIT09IGZhbHNlKSB7XG5cdFx0XHRyb290LmFwcGVuZENoaWxkKEltYmEuZG9jdW1lbnQoKS5jcmVhdGVUZXh0Tm9kZShub2RlKSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRcblx0Ly8gaW5zZXJ0IG5vZGVzIGJlZm9yZSBhIGNlcnRhaW4gbm9kZVxuXHQvLyBkb2VzIG5vdCBuZWVkIHRvIHJldHVybiBhbnkgdGFpbCwgYXMgYmVmb3JlXG5cdC8vIHdpbGwgc3RpbGwgYmUgY29ycmVjdCB0aGVyZVxuXHQvLyBiZWZvcmUgbXVzdCBiZSBhbiBhY3R1YWwgZG9tbm9kZVxuXHRmdW5jdGlvbiBpbnNlcnROZXN0ZWRCZWZvcmUocm9vdCxub2RlLGJlZm9yZSl7XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRyb290Lmluc2VydEJlZm9yZShub2RlLGJlZm9yZSk7XG5cdFx0fSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGluc2VydE5lc3RlZEJlZm9yZShyb290LGFyeVtpXSxiZWZvcmUpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKG5vZGUgIT0gbnVsbCAmJiBub2RlICE9PSBmYWxzZSkge1xuXHRcdFx0cm9vdC5pbnNlcnRCZWZvcmUoSW1iYS5kb2N1bWVudCgpLmNyZWF0ZVRleHROb2RlKG5vZGUpLGJlZm9yZSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gYmVmb3JlO1xuXHR9O1xuXHRcblx0Ly8gYWZ0ZXIgbXVzdCBiZSBhbiBhY3R1YWwgZG9tbm9kZVxuXHRmdW5jdGlvbiBpbnNlcnROZXN0ZWRBZnRlcihyb290LG5vZGUsYWZ0ZXIpe1xuXHRcdHZhciBiZWZvcmUgPSBhZnRlciA/IChhZnRlci5uZXh0U2libGluZykgOiAocm9vdC5fZG9tLmZpcnN0Q2hpbGQpO1xuXHRcdFxuXHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdGluc2VydE5lc3RlZEJlZm9yZShyb290LG5vZGUsYmVmb3JlKTtcblx0XHRcdHJldHVybiBiZWZvcmUucHJldmlvdXNTaWJsaW5nO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcHBlbmROZXN0ZWQocm9vdCxub2RlKTtcblx0XHRcdHJldHVybiByb290Ll9kb20ubGFzdENoaWxkO1xuXHRcdH07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiByZWNvbmNpbGVDb2xsZWN0aW9uQ2hhbmdlcyhyb290LG5ldyQsb2xkLGNhcmV0KXtcblx0XHRcblx0XHR2YXIgbmV3TGVuID0gbmV3JC5sZW5ndGg7XG5cdFx0dmFyIGxhc3ROZXcgPSBuZXckW25ld0xlbiAtIDFdO1xuXHRcdFxuXHRcdC8vIFRoaXMgcmUtb3JkZXIgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgcHJpbmNpcGxlOlxuXHRcdC8vIFxuXHRcdC8vIFdlIGJ1aWxkIGEgXCJjaGFpblwiIHdoaWNoIHNob3dzIHdoaWNoIGl0ZW1zIGFyZSBhbHJlYWR5IHNvcnRlZC5cblx0XHQvLyBJZiB3ZSdyZSBnb2luZyBmcm9tIFsxLCAyLCAzXSAtPiBbMiwgMSwgM10sIHRoZSB0cmVlIGxvb2tzIGxpa2U6XG5cdFx0Ly9cblx0XHQvLyBcdDMgLT4gIDAgKGlkeClcblx0XHQvLyBcdDIgLT4gLTEgKGlkeClcblx0XHQvLyBcdDEgLT4gLTEgKGlkeClcblx0XHQvL1xuXHRcdC8vIFRoaXMgdGVsbHMgdXMgdGhhdCB3ZSBoYXZlIHR3byBjaGFpbnMgb2Ygb3JkZXJlZCBpdGVtczpcblx0XHQvLyBcblx0XHQvLyBcdCgxLCAzKSBhbmQgKDIpXG5cdFx0Ly8gXG5cdFx0Ly8gVGhlIG9wdGltYWwgcmUtb3JkZXJpbmcgdGhlbiBiZWNvbWVzIHR3byBrZWVwIHRoZSBsb25nZXN0IGNoYWluIGludGFjdCxcblx0XHQvLyBhbmQgbW92ZSBhbGwgdGhlIG90aGVyIGl0ZW1zLlxuXHRcdFxuXHRcdHZhciBuZXdQb3NpdGlvbiA9IFtdO1xuXHRcdFxuXHRcdC8vIFRoZSB0cmVlL2dyYXBoIGl0c2VsZlxuXHRcdHZhciBwcmV2Q2hhaW4gPSBbXTtcblx0XHQvLyBUaGUgbGVuZ3RoIG9mIHRoZSBjaGFpblxuXHRcdHZhciBsZW5ndGhDaGFpbiA9IFtdO1xuXHRcdFxuXHRcdC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxvbmdlc3QgY2hhaW5cblx0XHR2YXIgbWF4Q2hhaW5MZW5ndGggPSAwO1xuXHRcdHZhciBtYXhDaGFpbkVuZCA9IDA7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaWR4ID0gMCwgYXJ5ID0gaXRlciQob2xkKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbm9kZTsgaWR4IDwgbGVuOyBpZHgrKykge1xuXHRcdFx0bm9kZSA9IGFyeVtpZHhdO1xuXHRcdFx0dmFyIG5ld1BvcyA9IG5ldyQuaW5kZXhPZihub2RlKTtcblx0XHRcdG5ld1Bvc2l0aW9uLnB1c2gobmV3UG9zKTtcblx0XHRcdFxuXHRcdFx0aWYgKG5ld1BvcyA9PSAtMSkge1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuXHRcdFx0XHRwcmV2Q2hhaW4ucHVzaCgtMSk7XG5cdFx0XHRcdGxlbmd0aENoYWluLnB1c2goLTEpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBwcmV2SWR4ID0gbmV3UG9zaXRpb24ubGVuZ3RoIC0gMjtcblx0XHRcdFxuXHRcdFx0Ly8gQnVpbGQgdGhlIGNoYWluOlxuXHRcdFx0d2hpbGUgKHByZXZJZHggPj0gMCl7XG5cdFx0XHRcdGlmIChuZXdQb3NpdGlvbltwcmV2SWR4XSA9PSAtMSkge1xuXHRcdFx0XHRcdHByZXZJZHgtLTtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXdQb3MgPiBuZXdQb3NpdGlvbltwcmV2SWR4XSkge1xuXHRcdFx0XHRcdC8vIFlheSwgd2UncmUgYmlnZ2VyIHRoYW4gdGhlIHByZXZpb3VzIVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIE5vcGUsIGxldCdzIHdhbGsgYmFjayB0aGUgY2hhaW5cblx0XHRcdFx0XHRwcmV2SWR4ID0gcHJldkNoYWluW3ByZXZJZHhdO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cHJldkNoYWluLnB1c2gocHJldklkeCk7XG5cdFx0XHRcblx0XHRcdHZhciBjdXJyTGVuZ3RoID0gKHByZXZJZHggPT0gLTEpID8gKDApIDogKGxlbmd0aENoYWluW3ByZXZJZHhdICsgMSk7XG5cdFx0XHRcblx0XHRcdGlmIChjdXJyTGVuZ3RoID4gbWF4Q2hhaW5MZW5ndGgpIHtcblx0XHRcdFx0bWF4Q2hhaW5MZW5ndGggPSBjdXJyTGVuZ3RoO1xuXHRcdFx0XHRtYXhDaGFpbkVuZCA9IGlkeDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGxlbmd0aENoYWluLnB1c2goY3Vyckxlbmd0aCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc3RpY2t5Tm9kZXMgPSBbXTtcblx0XHRcblx0XHQvLyBOb3cgd2UgY2FuIHdhbGsgdGhlIGxvbmdlc3QgY2hhaW4gYmFja3dhcmRzIGFuZCBtYXJrIHRoZW0gYXMgXCJzdGlja3lcIixcblx0XHQvLyB3aGljaCBpbXBsaWVzIHRoYXQgdGhleSBzaG91bGQgbm90IGJlIG1vdmVkXG5cdFx0dmFyIGN1cnNvciA9IG5ld1Bvc2l0aW9uLmxlbmd0aCAtIDE7XG5cdFx0d2hpbGUgKGN1cnNvciA+PSAwKXtcblx0XHRcdGlmIChjdXJzb3IgPT0gbWF4Q2hhaW5FbmQgJiYgbmV3UG9zaXRpb25bY3Vyc29yXSAhPSAtMSkge1xuXHRcdFx0XHRzdGlja3lOb2Rlc1tuZXdQb3NpdGlvbltjdXJzb3JdXSA9IHRydWU7XG5cdFx0XHRcdG1heENoYWluRW5kID0gcHJldkNoYWluW21heENoYWluRW5kXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGN1cnNvciAtPSAxO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gQW5kIGxldCdzIGl0ZXJhdGUgZm9yd2FyZCwgYnV0IG9ubHkgbW92ZSBub24tc3RpY2t5IG5vZGVzXG5cdFx0Zm9yICh2YXIgaWR4MSA9IDAsIGFyeSA9IGl0ZXIkKG5ldyQpLCBsZW4gPSBhcnkubGVuZ3RoOyBpZHgxIDwgbGVuOyBpZHgxKyspIHtcblx0XHRcdGlmICghc3RpY2t5Tm9kZXNbaWR4MV0pIHtcblx0XHRcdFx0dmFyIGFmdGVyID0gbmV3JFtpZHgxIC0gMV07XG5cdFx0XHRcdGluc2VydE5lc3RlZEFmdGVyKHJvb3QsYXJ5W2lkeDFdLChhZnRlciAmJiBhZnRlci5fZG9tKSB8fCBjYXJldCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHRydXN0IHRoYXQgdGhlIGxhc3QgaXRlbSBpbiBuZXcgbGlzdCBpcyB0aGUgY2FyZXRcblx0XHRyZXR1cm4gbGFzdE5ldyAmJiBsYXN0TmV3Ll9kb20gfHwgY2FyZXQ7XG5cdH07XG5cdFxuXHRcblx0Ly8gZXhwZWN0cyBhIGZsYXQgbm9uLXNwYXJzZSBhcnJheSBvZiBub2RlcyBpbiBib3RoIG5ldyBhbmQgb2xkLCBhbHdheXNcblx0ZnVuY3Rpb24gcmVjb25jaWxlQ29sbGVjdGlvbihyb290LG5ldyQsb2xkLGNhcmV0KXtcblx0XHR2YXIgayA9IG5ldyQubGVuZ3RoO1xuXHRcdHZhciBpID0gaztcblx0XHR2YXIgbGFzdCA9IG5ldyRbayAtIDFdO1xuXHRcdFxuXHRcdFxuXHRcdGlmIChrID09IG9sZC5sZW5ndGggJiYgbmV3JFswXSA9PT0gb2xkWzBdKSB7XG5cdFx0XHQvLyBydW5uaW5nIHRocm91Z2ggdG8gY29tcGFyZVxuXHRcdFx0d2hpbGUgKGktLSl7XG5cdFx0XHRcdGlmIChuZXckW2ldICE9PSBvbGRbaV0pIHsgYnJlYWs7IH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGkgPT0gLTEpIHtcblx0XHRcdHJldHVybiBsYXN0ICYmIGxhc3QuX2RvbSB8fCBjYXJldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHJlY29uY2lsZUNvbGxlY3Rpb25DaGFuZ2VzKHJvb3QsbmV3JCxvbGQsY2FyZXQpO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvLyB0aGUgZ2VuZXJhbCByZWNvbmNpbGVyIHRoYXQgcmVzcGVjdHMgY29uZGl0aW9ucyBldGNcblx0Ly8gY2FyZXQgaXMgdGhlIGN1cnJlbnQgbm9kZSB3ZSB3YW50IHRvIGluc2VydCB0aGluZ3MgYWZ0ZXJcblx0ZnVuY3Rpb24gcmVjb25jaWxlTmVzdGVkKHJvb3QsbmV3JCxvbGQsY2FyZXQpe1xuXHRcdFxuXHRcdC8vIGlmIG5ldyA9PSBudWxsIG9yIG5ldyA9PT0gZmFsc2Ugb3IgbmV3ID09PSB0cnVlXG5cdFx0Ly8gXHRpZiBuZXcgPT09IG9sZFxuXHRcdC8vIFx0XHRyZXR1cm4gY2FyZXRcblx0XHQvLyBcdGlmIG9sZCAmJiBuZXcgIT0gb2xkXG5cdFx0Ly8gXHRcdHJlbW92ZU5lc3RlZChyb290LG9sZCxjYXJldCkgaWYgb2xkXG5cdFx0Ly8gXG5cdFx0Ly8gXHRyZXR1cm4gY2FyZXRcblx0XHRcblx0XHQvLyB2YXIgc2tpcG5ldyA9IG5ldyA9PSBudWxsIG9yIG5ldyA9PT0gZmFsc2Ugb3IgbmV3ID09PSB0cnVlXG5cdFx0dmFyIG5ld0lzTnVsbCA9IG5ldyQgPT0gbnVsbCB8fCBuZXckID09PSBmYWxzZTtcblx0XHR2YXIgb2xkSXNOdWxsID0gb2xkID09IG51bGwgfHwgb2xkID09PSBmYWxzZTtcblx0XHRcblx0XHRcblx0XHRpZiAobmV3JCA9PT0gb2xkKSB7XG5cdFx0XHQvLyByZW1lbWJlciB0aGF0IHRoZSBjYXJldCBtdXN0IGJlIGFuIGFjdHVhbCBkb20gZWxlbWVudFxuXHRcdFx0Ly8gd2Ugc2hvdWxkIGluc3RlYWQgbW92ZSB0aGUgYWN0dWFsIGNhcmV0PyAtIHRydXN0XG5cdFx0XHRpZiAobmV3SXNOdWxsKSB7XG5cdFx0XHRcdHJldHVybiBjYXJldDtcblx0XHRcdH0gZWxzZSBpZiAobmV3JCAmJiBuZXckLl9kb20pIHtcblx0XHRcdFx0cmV0dXJuIG5ldyQuX2RvbTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjYXJldCA/IChjYXJldC5uZXh0U2libGluZykgOiAocm9vdC5fZG9tLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKG5ldyQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0aWYgKG9sZCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdGlmIChuZXckLnN0YXRpYyB8fCBvbGQuc3RhdGljKSB7XG5cdFx0XHRcdFx0Ly8gaWYgdGhlIHN0YXRpYyBpcyBub3QgbmVzdGVkIC0gd2UgY291bGQgZ2V0IGEgaGludCBmcm9tIGNvbXBpbGVyXG5cdFx0XHRcdFx0Ly8gYW5kIGp1c3Qgc2tpcCBpdFxuXHRcdFx0XHRcdGlmIChuZXckLnN0YXRpYyA9PSBvbGQuc3RhdGljKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobmV3JCksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIGlzIHdoZXJlIHdlIGNvdWxkIGRvIHRoZSB0cmlwbGUgZXF1YWwgZGlyZWN0bHlcblx0XHRcdFx0XHRcdFx0Y2FyZXQgPSByZWNvbmNpbGVOZXN0ZWQocm9vdCxhcnlbaV0sb2xkW2ldLGNhcmV0KTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gY2FyZXQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlbW92ZU5lc3RlZChyb290LG9sZCxjYXJldCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBpZiB0aGV5IGFyZSBub3QgdGhlIHNhbWUgd2UgY29udGludWUgdGhyb3VnaCB0byB0aGUgZGVmYXVsdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiByZWNvbmNpbGVDb2xsZWN0aW9uKHJvb3QsbmV3JCxvbGQsY2FyZXQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmIChvbGQgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRcdHJvb3QucmVtb3ZlQ2hpbGQob2xkKTtcblx0XHRcdH0gZWxzZSBpZiAoIW9sZElzTnVsbCkge1xuXHRcdFx0XHQvLyBvbGQgd2FzIGEgc3RyaW5nLWxpa2Ugb2JqZWN0P1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKGNhcmV0ID8gKGNhcmV0Lm5leHRTaWJsaW5nKSA6IChyb290Ll9kb20uZmlyc3RDaGlsZCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGluc2VydE5lc3RlZEFmdGVyKHJvb3QsbmV3JCxjYXJldCk7XG5cdFx0XHQvLyByZW1vdmUgb2xkXG5cdFx0fSBlbHNlIGlmIChuZXckIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0aWYgKCFvbGRJc051bGwpIHsgcmVtb3ZlTmVzdGVkKHJvb3Qsb2xkLGNhcmV0KSB9O1xuXHRcdFx0aW5zZXJ0TmVzdGVkQWZ0ZXIocm9vdCxuZXckLGNhcmV0KTtcblx0XHRcdHJldHVybiBuZXckO1xuXHRcdH0gZWxzZSBpZiAobmV3SXNOdWxsKSB7XG5cdFx0XHRpZiAoIW9sZElzTnVsbCkgeyByZW1vdmVOZXN0ZWQocm9vdCxvbGQsY2FyZXQpIH07XG5cdFx0XHRyZXR1cm4gY2FyZXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIG9sZCBkaWQgbm90IGV4aXN0IHdlIG5lZWQgdG8gYWRkIGEgbmV3IGRpcmVjdGx5XG5cdFx0XHR2YXIgbmV4dE5vZGU7XG5cdFx0XHQvLyBpZiBvbGQgd2FzIGFycmF5IG9yIGltYmF0YWcgd2UgbmVlZCB0byByZW1vdmUgaXQgYW5kIHRoZW4gYWRkXG5cdFx0XHRpZiAob2xkIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0cmVtb3ZlTmVzdGVkKHJvb3Qsb2xkLGNhcmV0KTtcblx0XHRcdH0gZWxzZSBpZiAob2xkIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKG9sZCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFvbGRJc051bGwpIHtcblx0XHRcdFx0Ly8gLi4uXG5cdFx0XHRcdG5leHROb2RlID0gY2FyZXQgPyAoY2FyZXQubmV4dFNpYmxpbmcpIDogKHJvb3QuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcdFx0aWYgKChuZXh0Tm9kZSBpbnN0YW5jZW9mIFRleHQpICYmIG5leHROb2RlLnRleHRDb250ZW50ICE9IG5ldyQpIHtcblx0XHRcdFx0XHRuZXh0Tm9kZS50ZXh0Q29udGVudCA9IG5ldyQ7XG5cdFx0XHRcdFx0cmV0dXJuIG5leHROb2RlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbm93IGFkZCB0aGUgdGV4dG5vZGVcblx0XHRcdHJldHVybiBpbnNlcnROZXN0ZWRBZnRlcihyb290LG5ldyQsY2FyZXQpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0cmV0dXJuIHRhZyQuZXh0ZW5kVGFnKCdodG1sZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChuZXckLHR5cCl7XG5cdFx0XHR2YXIgb2xkID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHQvLyB2YXIgaXNBcnJheSA9IG5vZGVzIGlzYSBBcnJheVxuXHRcdFx0aWYgKG5ldyQgPT09IG9sZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICghb2xkKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKTtcblx0XHRcdFx0YXBwZW5kTmVzdGVkKHRoaXMsbmV3JCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAyKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gMSkge1xuXHRcdFx0XHQvLyBoZXJlIHdlIF9rbm93IF90aGF0IGl0IGlzIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGVcblx0XHRcdFx0Ly8gZXZlcnkgdGltZVxuXHRcdFx0XHR2YXIgY2FyZXQgPSBudWxsO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobmV3JCksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdC8vIHByZXYgPSBvbGRbaV1cblx0XHRcdFx0XHRjYXJldCA9IHJlY29uY2lsZU5lc3RlZCh0aGlzLGFyeVtpXSxvbGRbaV0sY2FyZXQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gMykge1xuXHRcdFx0XHQvLyB0aGlzIGlzIHBvc3NpYmx5IGZ1bGx5IGR5bmFtaWMuIEl0IG9mdGVuIGlzXG5cdFx0XHRcdC8vIGJ1dCB0aGUgb2xkIG9yIG5ldyBjb3VsZCBiZSBzdGF0aWMgd2hpbGUgdGhlIG90aGVyIGlzIG5vdFxuXHRcdFx0XHQvLyB0aGlzIGlzIG5vdCBoYW5kbGVkIG5vd1xuXHRcdFx0XHQvLyB3aGF0IGlmIGl0IHdhcyBwcmV2aW91c2x5IGEgc3RhdGljIGFycmF5PyBlZGdlY2FzZSAtIGJ1dCBtdXN0IHdvcmtcblx0XHRcdFx0aWYgKG5ldyQgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRcdFx0dGhpcy5lbXB0eSgpO1xuXHRcdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQobmV3JCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV3JCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0aWYgKG9sZCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0XHQvLyBpcyB0aGlzIG5vdCB0aGUgc2FtZSBhcyBzZXR0aW5nIHN0YXRpY0NoaWxkcmVuIG5vdyBidXQgd2l0aCB0aGVcblx0XHRcdFx0XHRcdHJlY29uY2lsZUNvbGxlY3Rpb24odGhpcyxuZXckLG9sZCxudWxsKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5lbXB0eSgpO1xuXHRcdFx0XHRcdFx0YXBwZW5kTmVzdGVkKHRoaXMsbmV3JCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNldFRleHQobmV3JCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKChuZXckIGluc3RhbmNlb2YgQXJyYXkpICYmIChvbGQgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0cmVjb25jaWxlQ29sbGVjdGlvbih0aGlzLG5ldyQsb2xkLG51bGwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpO1xuXHRcdFx0XHRhcHBlbmROZXN0ZWQodGhpcyxuZXckKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuX2NoaWxkcmVuID0gbmV3JDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0Ly8gb25seSBldmVyIGNhbGxlZCB3aXRoIGFycmF5IGFzIGFyZ3VtZW50XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTdGF0aWNDaGlsZHJlbiA9IGZ1bmN0aW9uIChuZXckKXtcblx0XHRcdHZhciBvbGQgPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdFxuXHRcdFx0dmFyIGNhcmV0ID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChuZXckKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdC8vIHByZXYgPSBvbGRbaV1cblx0XHRcdFx0Y2FyZXQgPSByZWNvbmNpbGVOZXN0ZWQodGhpcyxhcnlbaV0sb2xkW2ldLGNhcmV0KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuX2NoaWxkcmVuID0gbmV3JDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29udGVudCB8fCB0aGlzLmNoaWxkcmVuKCkudG9BcnJheSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0aWYgKHRleHQgIT0gdGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdFx0dGhpcy5fY2hpbGRyZW4gPSB0ZXh0O1xuXHRcdFx0XHR0aGlzLmRvbSgpLnRleHRDb250ZW50ID0gdGV4dCA9PSBudWxsIHx8IHRleHQgPT09IGZhbHNlID8gKCcnKSA6ICh0ZXh0KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20uc3RhdGljLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0Lypcblx0VGhlIHNwZWNpYWwgc3ludGF4IGZvciBzZWxlY3RvcnMgaW4gSW1iYSBjcmVhdGVzIEltYmEuU2VsZWN0b3Jcblx0aW5zdGFuY2VzLlxuXHQqL1xuXHRcblx0SW1iYS5TZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKHNlbCxzY29wZSxub2Rlcyl7XG5cdFx0XG5cdFx0dGhpcy5fcXVlcnkgPSBzZWwgaW5zdGFuY2VvZiBJbWJhLlNlbGVjdG9yID8gKHNlbC5xdWVyeSgpKSA6IChzZWwpO1xuXHRcdHRoaXMuX2NvbnRleHQgPSBzY29wZTtcblx0XHRcblx0XHRpZiAobm9kZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzLnB1c2godGFnJHdyYXAoYXJ5W2ldKSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fbm9kZXMgPSByZXM7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9sYXp5ID0gIW5vZGVzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5vbmUgPSBmdW5jdGlvbiAoc2VsLHNjb3BlKXtcblx0XHR2YXIgZWwgPSAoc2NvcGUgfHwgSW1iYS5kb2N1bWVudCgpKS5xdWVyeVNlbGVjdG9yKHNlbCk7XG5cdFx0cmV0dXJuIGVsICYmIHRhZyR3cmFwKGVsKSB8fCBudWxsO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5hbGwgPSBmdW5jdGlvbiAoc2VsLHNjb3BlKXtcblx0XHRyZXR1cm4gbmV3IEltYmEuU2VsZWN0b3Ioc2VsLHNjb3BlKTtcblx0fTtcblx0XG5cdFxuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3F1ZXJ5OyB9XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24odil7IHRoaXMuX3F1ZXJ5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9ub2RlcyA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBjdHg7XG5cdFx0aWYgKHRoaXMuX3Njb3BlKSB7IHJldHVybiB0aGlzLl9zY29wZSB9O1xuXHRcdGlmICghKGN0eCA9IHRoaXMuX2NvbnRleHQpKSB7IHJldHVybiBJbWJhLmRvY3VtZW50KCkgfTtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGUgPSBjdHgudG9TY29wZSA/IChjdHgudG9TY29wZSgpKSA6IChjdHgpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRAcmV0dXJucyB7SW1iYS5UYWd9IGZpcnN0IG5vZGUgbWF0Y2hpbmcgdGhpcyBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9sYXp5KSB7IHJldHVybiB0YWckd3JhcCh0aGlzLl9maXJzdCB8fCAodGhpcy5fZmlyc3QgPSB0aGlzLnNjb3BlKCkucXVlcnlTZWxlY3Rvcih0aGlzLnF1ZXJ5KCkpKSkgfSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLm5vZGVzKClbMF07XG5cdFx0fTtcblx0fTtcblx0XG5cdC8qXG5cdFx0QHJldHVybnMge0ltYmEuVGFnfSBsYXN0IG5vZGUgbWF0Y2hpbmcgdGhpcyBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKVt0aGlzLl9ub2Rlcy5sZW5ndGggLSAxXTtcblx0fTtcblx0XG5cdC8qXG5cdFx0QHJldHVybnMgW0ltYmEuVGFnXSBhbGwgbm9kZXMgbWF0Y2hpbmcgdGhpcyBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9ub2RlcykgeyByZXR1cm4gdGhpcy5fbm9kZXMgfTtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLnNjb3BlKCkucXVlcnlTZWxlY3RvckFsbCh0aGlzLnF1ZXJ5KCkpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChpdGVtcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHJlcy5wdXNoKHRhZyR3cmFwKGFyeVtpXSkpO1xuXHRcdH07XG5cdFx0dGhpcy5fbm9kZXMgPSByZXM7XG5cdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzLl9ub2Rlcztcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhlIG51bWJlciBvZiBub2RlcyBtYXRjaGluZyB0aGlzIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKS5sZW5ndGg7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlcygpLmxlbmd0aDtcblx0fTtcblx0XG5cdC8qXG5cdFx0QHRvZG8gQWRkIHN1cHBvcnQgZm9yIGJsb2NrIG9yIHNlbGVjdG9yP1xuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY291bnQoKSA+PSAxO1xuXHR9O1xuXHRcblx0Lypcblx0XHRHZXQgbm9kZSBhdCBpbmRleFxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpZHgpe1xuXHRcdHJldHVybiB0aGlzLm5vZGVzKClbaWR4XTtcblx0fTtcblx0XG5cdC8qXG5cdFx0TG9vcCB0aHJvdWdoIG5vZGVzXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoYmxvY2spe1xuXHRcdHRoaXMubm9kZXMoKS5mb3JFYWNoKGJsb2NrKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0TWFwIG5vZGVzXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChibG9jayl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKS5tYXAoYmxvY2spO1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZXR1cm5zIGEgcGxhaW4gYXJyYXkgY29udGFpbmluZyBub2Rlcy4gSW1wbGljaXRseSBjYWxsZWRcblx0XHR3aGVuIGl0ZXJhdGluZyBvdmVyIGEgc2VsZWN0b3IgaW4gSW1iYSBgKG5vZGUgZm9yIG5vZGUgaW4gJChzZWxlY3RvcikpYFxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKTtcblx0fTtcblx0XG5cdC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLCBcblx0Ly8gYmVnaW5uaW5nIGF0IHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kIHByb2dyZXNzaW5nIHVwIHRocm91Z2ggdGhlIERPTSB0cmVlXG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHQvLyBzZWVtcyBzdHJhbmdlIHRoYXQgd2UgYWx0ZXIgdGhpcyBzZWxlY3Rvcj9cblx0XHR0aGlzLl9ub2RlcyA9IHRoaXMubWFwKGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2xvc2VzdChzZWwpOyB9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIEdldCB0aGUgc2libGluZ3Mgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cywgXG5cdC8vIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYSBzZWxlY3Rvci5cblx0Ly8gVE9ETyByZW1vdmUgZHVwbGljYXRlcz9cblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuc2libGluZ3MgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHR0aGlzLl9ub2RlcyA9IHRoaXMubWFwKGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIG5vZGUuc2libGluZ3Moc2VsKTsgfSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBHZXQgdGhlIGRlc2NlbmRhbnRzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY3VycmVudCBzZXQgb2YgbWF0Y2hlZCBcblx0Ly8gZWxlbWVudHMsIGZpbHRlcmVkIGJ5IGEgc2VsZWN0b3IuXG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHR0aGlzLl9ub2RlcyA9IHRoaXMuX19xdWVyeV9fKHNlbC5xdWVyeSgpLHRoaXMubm9kZXMoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAoYmxrKXtcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoYmxrLGZhbHNlKTtcblx0fTtcblx0XG5cdC8qXG5cdFx0RmlsdGVyIHRoZSBub2RlcyBpbiBzZWxlY3RvciBieSBhIGZ1bmN0aW9uIG9yIG90aGVyIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChibGssYm9vbCl7XG5cdFx0aWYoYm9vbCA9PT0gdW5kZWZpbmVkKSBib29sID0gdHJ1ZTtcblx0XHR2YXIgZm4gPSAoYmxrIGluc3RhbmNlb2YgRnVuY3Rpb24pICYmIGJsayB8fCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm1hdGNoZXMoYmxrKTsgfTtcblx0XHR2YXIgYXJ5ID0gdGhpcy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbihuKSB7IHJldHVybiBmbihuKSA9PSBib29sOyB9KTtcblx0XHQvLyBpZiB3ZSB3YW50IHRvIHJldHVybiBhIG5ldyBzZWxlY3RvciBmb3IgdGhpcywgd2Ugc2hvdWxkIGRvIHRoYXQgZm9yXG5cdFx0Ly8gb3RoZXJzIGFzIHdlbGxcblx0XHRyZXR1cm4gbmV3IEltYmEuU2VsZWN0b3IoXCJcIix0aGlzLl9zY29wZSxhcnkpO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuX19xdWVyeV9fID0gZnVuY3Rpb24gKHF1ZXJ5LGNvbnRleHRzKXtcblx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIGwgPSBjb250ZXh0cy5sZW5ndGg7XG5cdFx0XG5cdFx0d2hpbGUgKGkgPCBsKXtcblx0XHRcdG5vZGVzLnB1c2guYXBwbHkobm9kZXMsY29udGV4dHNbaSsrXS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gbm9kZXM7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5fX21hdGNoZXNfXyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0Lypcblx0XHRBZGQgc3BlY2lmaWVkIGZsYWcgdG8gYWxsIG5vZGVzIGluIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZsYWcgPSBmdW5jdGlvbiAoZmxhZyl7XG5cdFx0cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihuKSB7IHJldHVybiBuLmZsYWcoZmxhZyk7IH0pO1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZW1vdmUgc3BlY2lmaWVkIGZsYWcgZnJvbSBhbGwgbm9kZXMgaW4gc2VsZWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUudW5mbGFnID0gZnVuY3Rpb24gKGZsYWcpe1xuXHRcdHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24obikgeyByZXR1cm4gbi51bmZsYWcoZmxhZyk7IH0pO1xuXHR9O1xuXHRcblx0XG5cdC8vIGRlZiBJbWJhLnF1ZXJ5U2VsZWN0b3JBbGxcblx0cSQgPSBmdW5jdGlvbihzZWwsc2NvcGUpIHsgcmV0dXJuIG5ldyBJbWJhLlNlbGVjdG9yKHNlbCxzY29wZSk7IH07XG5cdFxuXHQvLyBkZWYgSW1iYS5TZWxlY3Rvci5vbmVcblx0cSQkID0gZnVuY3Rpb24oc2VsLHNjb3BlKSB7XG5cdFx0dmFyIGVsID0gKHNjb3BlIHx8IEltYmEuZG9jdW1lbnQoKSkucXVlcnlTZWxlY3RvcihzZWwpO1xuXHRcdHJldHVybiBlbCAmJiB0YWckd3JhcChlbCkgfHwgbnVsbDtcblx0fTtcblx0XG5cdFxuXHQvLyBleHRlbmRpbmcgdGFncyB3aXRoIHF1ZXJ5LW1ldGhvZHNcblx0Ly8gbXVzdCBiZSBhIGJldHRlciB3YXkgdG8gcmVvcGVuIGNsYXNzZXNcblx0cmV0dXJuIHRhZyQuZXh0ZW5kVGFnKCdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAocSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3JBbGwocSk7XG5cdFx0fTtcblx0XHR0YWcucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBmdW5jdGlvbiAocSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IocSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBzaG91bGQgYmUgbW92ZWQgdG8gSW1iYS5UYWcgaW5zdGVhZD9cblx0XHQvLyBvciB3ZSBzaG91bGQgaW1wbGVtZW50IGFsbCBvZiB0aGVtIGhlcmVcblx0XHR0YWcucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHJldHVybiBuZXcgSW1iYS5TZWxlY3RvcihzZWwsdGhpcyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL3NlbGVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHR2YXIgdXRpbDtcblx0SU1ERUJVRyA9IHRydWU7XG5cdFxuXHQvLyB3dGYgZXIgYWx0IGRldHRlP1xuXHRJTSA9IHt9O1xuXHRJTS5ORVdMSU5FID0gJ1xcbic7XG5cdElNLkNIQVIgPSAwO1xuXHRJTS5XT1JEX1NUQVJUID0gMTtcblx0SU0uV09SRF9FTkQgPSAyO1xuXHRJTS5QVU5DVFVBVElPTl9TVEFSVCA9IDM7XG5cdElNLlBVTkNUVUFUSU9OX0VORCA9IDQ7XG5cdElNLlNVQl9XT1JEX1NUQVJUID0gNTtcblx0SU0uU1VCX1dPUkRfRU5EID0gNjtcblx0SU0uTElORV9TVEFSVCA9IDc7XG5cdElNLkxJTkVfRU5EID0gODtcblx0SU0uRU1QVFlfTElORSA9IDk7XG5cdFxuXHRJTS5GUyA9IHJlcXVpcmUoJy4vY29yZS9mcycpO1xuXHRcblx0dmFyIFNvdXJjZU1hcCA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKTtcblx0XG5cdC8vIGlmIGdsb2JhbDpyZXF1aXJlXG5cdHZhciBSZWdpb24gPSByZXF1aXJlKFwiLi9yZWdpb25cIikuUmVnaW9uO1xuXHRcblx0cmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cdFxuXHRyZXF1aXJlKCcuL2NvcmUvaGlzdG9yeScpO1xuXHRyZXF1aXJlKCcuL2NvcmUvbG9nZ2VyJyk7XG5cdHJlcXVpcmUoJy4vY29yZS9zaG9ydGN1dHMnKTtcblx0XG5cdHJlcXVpcmUoXCIuL3ZpZXdzL2NhcHRvclwiKTtcblx0cmVxdWlyZShcIi4vdmlld1wiKTtcblx0cmVxdWlyZShcIi4vZWRpdG9yXCIpO1xuXHRcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZShcIi4vY29yZS9oaWdobGlnaHRlclwiKS5IaWdobGlnaHRlcjtcblx0dmFyIEltYmFjV29ya2VyID0gcmVxdWlyZShcIi4vY29yZS93b3JrZXJcIikuSW1iYWNXb3JrZXI7XG5cdFxuXHRJTS53b3JrZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fd29ya2VyIHx8ICh0aGlzLl93b3JrZXIgPSBuZXcgSW1iYWNXb3JrZXIoKSk7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy51dGlsID0gdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cdC8vIG5vZGVzXG5cdHJlcXVpcmUoXCIuL25vZGVzL2luZGV4XCIpO1xuXHRcblx0XG5cdGZ1bmN0aW9uIHdvcmtlcigpe1xuXHRcdHJldHVybiBJTS53b3JrZXIoKTtcblx0fTsgZXhwb3J0cy53b3JrZXIgPSB3b3JrZXI7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5Tb3VyY2VNYXAgPSBTb3VyY2VNYXA7XG5cdG1vZHVsZS5leHBvcnRzLlJlZ2lvbiA9IFJlZ2lvbjtcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzLkhpZ2hsaWdodGVyID0gSGlnaGxpZ2h0ZXI7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9pbmRleC5pbWJhXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHQvLyBleHRlcm5zO1xuXHRmdW5jdGlvbiBzYXZlKHBhdGgsY29udGVudCxlbmNvZGluZyxjYil7XG5cdFx0aWYoY2I9PXVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgPT0gJ2Z1bmN0aW9uJykgY2IgPSBlbmNvZGluZyxlbmNvZGluZyA9ICd1dGYtOCc7XG5cdFx0aWYoZW5jb2Rpbmc9PXVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmLTgnO1xuXHRcdGNvbnNvbGUubG9nKCdzYXZlJyxwYXRoLGNvbnRlbnQsZW5jb2RpbmcpO1xuXHRcdFxuXHRcdHJldHVybiB4ci5wb3N0KHBhdGgse2JvZHk6IGNvbnRlbnR9KS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ3Jlc3BvbmRlZCcpO1xuXHRcdFx0cmV0dXJuIGNiICYmIGNiKGFyZ3VtZW50cyk7XG5cdFx0fSk7XG5cdH07IGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5cdFxuXHRmdW5jdGlvbiByZWFkRmlsZUFzeW5jKHBhdGgsZW5jb2RpbmcsY2Ipe1xuXHRcdGlmKGNiPT11bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nID09ICdmdW5jdGlvbicpIGNiID0gZW5jb2RpbmcsZW5jb2RpbmcgPSAndXRmLTgnO1xuXHRcdGlmKGVuY29kaW5nPT11bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0Zi04Jztcblx0XHRjb25zb2xlLmxvZygnc2F2ZScscGF0aCxlbmNvZGluZyk7XG5cdFx0XG5cdFx0cmV0dXJuIHhyLmdldChwYXRoKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0Y29uc29sZS5sb2coJ3Jlc3BvbmRlZCcscmVzKTtcblx0XHRcdGNiICYmIGNiKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0pO1xuXHR9OyBleHBvcnRzLnJlYWRGaWxlQXN5bmMgPSByZWFkRmlsZUFzeW5jOzsgcmV0dXJuIHJlYWRGaWxlQXN5bmM7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL2ZzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gICAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIGlmICghYUFyZ3MpIHtcbiAgICAgIGFBcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgfVxuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICAgKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gICAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICAgKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAgICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICAgKlxuICAgKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gICAqICAgICAgdG9rZW4uXG4gICAqXG4gICAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICAgKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAgIC8vIENhc2UgMS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuICAgICAgdmFyIG5hbWVJZHg7XG4gICAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KVxuICAgICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG57XG4gIHZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4gIC8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuICAvLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbiAgLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4gIC8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbiAgLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4gIC8vXG4gIC8vICAgQ29udGludWF0aW9uXG4gIC8vICAgfCAgICBTaWduXG4gIC8vICAgfCAgICB8XG4gIC8vICAgViAgICBWXG4gIC8vICAgMTAxMDExXG5cbiAgdmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4gIC8vIGJpbmFyeTogMDExMTExXG4gIHZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICAgKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICAgKi9cbiAgZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAgICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gICAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgICAgPyAtc2hpZnRlZFxuICAgICAgOiBzaGlmdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gICAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICAgIHZhciBkaWdpdDtcblxuICAgIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gICAgZG8ge1xuICAgICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICBpZiAodmxxID4gMCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICAgIH1cbiAgICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gICAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgICByZXR1cm4gZW5jb2RlZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gICAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICAgIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICB2YXIgc2hpZnQgPSAwO1xuICAgIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgICAgfVxuXG4gICAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICAgIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gICAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG4gIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gICAqIGZhaWx1cmUuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gICAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gICAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICAgIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICAgIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gICAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gICAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICAgIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgICB9XG5cbiAgICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICAgIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gICAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIDYyOiArXG4gICAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICAgIHJldHVybiA2MjtcbiAgICB9XG5cbiAgICAvLyA2MzogL1xuICAgIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgICAgcmV0dXJuIDYzO1xuICAgIH1cblxuICAgIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICAgIHJldHVybiAtMTtcbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICAgKiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgfVxuICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxuICB2YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbiAgdmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG4gIGZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgICBob3N0OiBtYXRjaFszXSxcbiAgICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgICAgcGF0aDogbWF0Y2hbNV1cbiAgICB9O1xuICB9XG4gIGV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuICBmdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gICAgdmFyIHVybCA9ICcnO1xuICAgIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICB1cmwgKz0gJy8vJztcbiAgICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICAgKlxuICAgKiAtIFJlcGxhY2VzIGNvbnNlcXV0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICAgKlxuICAgKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgICB2YXIgcGF0aCA9IGFQYXRoO1xuICAgIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgaWYgKHVybCkge1xuICAgICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG4gICAgICBwYXRoID0gdXJsLnBhdGg7XG4gICAgfVxuICAgIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICAgIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICB1cCsrO1xuICAgICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgICAgdXAgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICAgIH1cblxuICAgIGlmICh1cmwpIHtcbiAgICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBleHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuICAvKipcbiAgICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gICAqXG4gICAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAgICpcbiAgICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAgICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gICAqICAgZmlyc3QuXG4gICAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICAgKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAgICogICBpcyByZXR1cm5lZC5cbiAgICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICAgKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gICAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuICAgIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgICAgYVBhdGggPSBcIi5cIjtcbiAgICB9XG4gICAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgICAgaWYgKGFSb290VXJsKSB7XG4gICAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gICAgfVxuXG4gICAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gICAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgPyBhUGF0aFxuICAgICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gam9pbmVkO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gICAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8ICEhYVBhdGgubWF0Y2godXJsUmVnZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgYVJvb3QgPSBcIi5cIjtcbiAgICB9XG5cbiAgICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gICAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAgIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAgIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgICB2YXIgbGV2ZWwgPSAwO1xuICAgIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG5cbiAgICAgICsrbGV2ZWw7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xuICB9XG4gIGV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxuICAvKipcbiAgICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICAgKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG4gIGV4cG9ydHMudG9TZXRTdHJpbmcgPSB0b1NldFN0cmluZztcblxuICBmdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gYVN0ci5zdWJzdHIoMSk7XG4gIH1cbiAgZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gZnJvbVNldFN0cmluZztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICAgKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAgICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAgICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHZhciBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbiAgfVxuICBleHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICAgKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbiAgfVxuICBleHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbiAgZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICAgIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gICAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfVxuICBleHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICAgKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAgICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICAgKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NldCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICAgKi9cbiAgQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gICAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICAgKlxuICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICB2YXIgaXNEdXBsaWNhdGUgPSB0aGlzLl9zZXQuaGFzT3duUHJvcGVydHkoc1N0cik7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gICAgfVxuICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiB0aGlzLl9zZXQuaGFzT3duUHJvcGVydHkoc1N0cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmICh0aGlzLl9zZXQuaGFzT3duUHJvcGVydHkoc1N0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gICAqXG4gICAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICAgIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gICAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gICAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG4gIH07XG5cbiAgZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAgICogcG9zaXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICAgIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gICAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG4gIH1cblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICAgKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAgICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAgICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAgICpcbiAgICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICAgIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAgICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKlxuICAgKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAgICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gICAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gICAqIGNvcHkuXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gICAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXJyYXk7XG4gIH07XG5cbiAgZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcClcbiAgICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbiAgfVxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwKSB7XG4gICAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4gIC8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4gIC8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3NcbiAgLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4gIC8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuICAvLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4gIC8vXG4gIC8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4gIC8vXG4gIC8vICAgICB7XG4gIC8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4gIC8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbiAgLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuICAvLyAgICAgICAgICAgICBjb2RlLlxuICAvLyAgICAgfVxuICAvL1xuICAvLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4gIC8vIGBudWxsYC5cbiAgLy9cbiAgLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbiAgLy9cbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuICBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gICAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAgICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAgICogQHBhcmFtIGFPcmRlclxuICAgKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICAgKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAgICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgICAgdmFyIG1hcHBpbmdzO1xuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICAgIH07XG4gICAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICAgKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gICAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAgICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAgICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gICAqXG4gICAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMobmVlZGxlLnNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihuZWVkbGUuc291cmNlKTtcblxuICAgICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcHBpbmdzO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICAgKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAgICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICAgKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gICAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgKlxuICAgKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAgICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAgICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gICAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAgICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gICAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAgICovXG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gICAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gICAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAgIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gICAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICAgIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gICAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gICAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICBzb3VyY2VzID0gc291cmNlc1xuICAgICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICAgIDogc291cmNlO1xuICAgICAgfSk7XG5cbiAgICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gICAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gICAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICAgIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLCB0cnVlKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gICAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICB9XG5cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gICAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gICAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKSB7XG4gICAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc21jO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAgICovXG4gIGZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gICAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAgIC8vIG1hbnkgc2VnbWVudHMgb2Z0ZW4gaGF2ZSB0aGUgc2FtZSBlbmNvZGluZy4gV2UgY2FuIGV4cGxvaXQgdGhpc1xuICAgICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAgIC8vIHNlZ21lbnQgYWdhaW4uXG4gICAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBpbmRleCArPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgICAgaW5kZXggPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlZFNlZ21lbnRzW3N0cl0gPSBzZWdtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAgICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAgICogaW5jbHVzaXZlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgICBuZWVkbGUsXG4gICAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgICApO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gICAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICAgIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGFibGUuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXJsO1xuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgICBuZWVkbGUsXG4gICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgICApO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICBleHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gICAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gICAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICAgKiBpbnB1dC5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gICAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAgICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICAgKlxuICAgKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gICAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICAgKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICAgKiAgICAgICBmaWVsZC5cbiAgICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gICAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gICAqXG4gICAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICAgKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICAgKiB1bnN1cHBvcnRlZC5cbiAgICpcbiAgICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAgICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAgICpcbiAgICogIHtcbiAgICogICAgdmVyc2lvbiA6IDMsXG4gICAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gICAqICAgIHNlY3Rpb25zOiBbe1xuICAgKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICAgKiAgICAgIG1hcDoge1xuICAgKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAgICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICAgKiAgICAgIH1cbiAgICogICAgfV0sXG4gICAqICB9XG4gICAqXG4gICAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAgICovXG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICAgIGxpbmU6IC0xLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMudXJsKSB7XG4gICAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgICAgfVxuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgICAgfSxcbiAgICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJykpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlcztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICB9KTtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgOiAwKSxcbiAgICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gICAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGFibGUuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZXMuaW5kZXhPZih1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgICA6IDApXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdO1xuXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgfTtcblxuICBleHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG4gIGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gICAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAvL1xuICAgIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gICAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICAgIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gICAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gICAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAgICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAgICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICAgKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gICAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKi9cbiAgZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29tcGFyZSwgYUJpYXMgfHwgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAgIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgICAvLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG4gICAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLS1pbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIC8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4gIC8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4gIC8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuICAvLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4gIC8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4gIC8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4gIC8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4gIC8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuICAvKipcbiAgICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgVGhlIGFycmF5LlxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAgICovXG4gIGZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gICAgdmFyIHRlbXAgPSBhcnlbeF07XG4gICAgYXJ5W3hdID0gYXJ5W3ldO1xuICAgIGFyeVt5XSA9IHRlbXA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAgICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gICAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gICAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gICAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gICAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAgICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAgICovXG4gIGZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAgIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAgIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgICBpZiAocCA8IHIpIHtcbiAgICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgICAvLyB0cnVlOlxuICAgICAgLy9cbiAgICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAgIC8vXG4gICAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gICAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gICAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gICAqL1xuICBleHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgdmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbiAgLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxuICB2YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4gIC8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xuICB2YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbiAgLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuICAvLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuICAvLyB2ZXJzaW9ucyFcbiAgdmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbiAgLyoqXG4gICAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAgICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gICAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICAgKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAgICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICAgKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAgICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gICAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICAgIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gICAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICAgIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gICAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICpcbiAgICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICAgKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICAgKi9cbiAgU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIGFycmF5LCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpbmVDb250ZW50cyA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCk7XG4gICAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuICAgICAgfTtcblxuICAgICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChhQ2h1bmspIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICAgKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gICAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgICB2YXIgY2h1bms7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAgICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gICAqXG4gICAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgICB2YXIgbmV3Q2hpbGRyZW47XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICAgIH1cbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAgICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gICAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAgICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICAgKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gICAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgc3RyICs9IGNodW5rO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAgICogbWFwLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgICAgY29kZTogXCJcIixcbiAgICAgIGxpbmU6IDEsXG4gICAgICBjb2x1bW46IDBcbiAgICB9O1xuICAgIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gICAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbiAgfTtcblxuICBleHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFJlZ2lvbihhLGIscm9vdCx2aWV3KXtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9yb290ID0gcm9vdDtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuUmVnaW9uID0gUmVnaW9uOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5hID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9hOyB9XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2V0QSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5iID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9iOyB9XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2V0QiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9iID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb290OyB9XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2V0Um9vdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yb290ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHQvLyByZW1vdmUgcm9vdCBmcm9tIHJlZ2lvblxuXHRcblx0UmVnaW9uLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwsdmlldyl7XG5cdFx0dmFyIGxpbmVfO1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBSZWdpb24pIHsgcmV0dXJuIHZhbCB9O1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgeyByZXR1cm4gbmV3IFJlZ2lvbih2YWxbMF0sdmFsWzFdLG51bGwsdmlldykgfTtcblx0XHRpZiAoKHR5cGVvZiB2YWw9PSdudW1iZXInfHx2YWwgaW5zdGFuY2VvZiBOdW1iZXIpKSB7IHJldHVybiBuZXcgUmVnaW9uKHZhbCx2YWwsbnVsbCx2aWV3KSB9O1xuXHRcdFxuXHRcdGlmICgodmFsIGluc3RhbmNlb2YgT2JqZWN0KSAmJiAodHlwZW9mIChsaW5lXyA9IHZhbC5saW5lKT09J251bWJlcid8fGxpbmVfIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0dmFyIGxpbmVzID0gdmlldy5fYnVmZmVyLmxpbmVzKCk7XG5cdFx0XHR2YXIgbG9jID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChsaW5lcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAoaSA8ICh2YWwubGluZSAtIDEpKSB7XG5cdFx0XHRcdFx0bG9jICs9IGFyeVtpXS5sZW5ndGggKyAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0bG9jICs9ICh2YWwuY29sdW1uIHx8IDApO1xuXHRcdFx0cmV0dXJuIG5ldyBSZWdpb24obG9jLGxvYyxudWxsLHZpZXcpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBNYXRoLm1pbih0aGlzLl9hLHRoaXMuX2IpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gTWF0aC5tYXgodGhpcy5fYSx0aGlzLl9iKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoYWQsYmQpe1xuXHRcdGlmKGFkID09PSB1bmRlZmluZWQpIGFkID0gMDtcblx0XHRpZihiZCA9PT0gdW5kZWZpbmVkKSBiZCA9IDA7XG5cdFx0cmV0dXJuIG5ldyBSZWdpb24odGhpcy5fYSArIGFkLHRoaXMuX2IgKyBiZCx0aGlzLl9yb290LHRoaXMuX3ZpZXcpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChyZWwpe1xuXHRcdGlmIChyZWwgaW5zdGFuY2VvZiBSZWdpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXJ0KCkgPD0gcmVsLnN0YXJ0KCkgJiYgdGhpcy5lbmQoKSA+PSByZWwuZW5kKCk7XG5cdFx0fSBlbHNlIGlmICgodHlwZW9mIHJlbD09J251bWJlcid8fHJlbCBpbnN0YW5jZW9mIE51bWJlcikpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXJ0KCkgPD0gcmVsICYmIHRoaXMuZW5kKCkgPj0gcmVsO1xuXHRcdH07XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmFkanVzdCA9IGZ1bmN0aW9uIChyZWwsYWRkKXtcblx0XHRpZihhZGQgPT09IHVuZGVmaW5lZCkgYWRkID0gdHJ1ZTtcblx0XHRpZiAocmVsLmVuZCgpIDwgdGhpcy5zdGFydCgpKSB7XG5cdFx0XHRhZGQgPyAodGhpcy5tb3ZlKHJlbC5zaXplKCkpKSA6ICh0aGlzLm1vdmUoLXJlbC5zaXplKCkpKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKHJlbCl7XG5cdFx0Ly8gaXMgdGhpcyBkZWNlbnQ/XG5cdFx0cmVsID0gUmVnaW9uLm5vcm1hbGl6ZShyZWwpO1xuXHRcdHZhciBhID0gTWF0aC5tYXgodGhpcy5zdGFydCgpLHJlbC5zdGFydCgpKTtcblx0XHR2YXIgYiA9IE1hdGgubWluKHRoaXMuZW5kKCkscmVsLmVuZCgpKTtcblx0XHRyZXR1cm4gYiA+PSBhO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yZWxhdGl2ZVRvID0gZnVuY3Rpb24gKHJlbCl7XG5cdFx0Ly8gY291bGQgdXNlIG1vdmUgaW5zdGVhZFxuXHRcdHJldHVybiBuZXcgUmVnaW9uKHRoaXMuX2EgLSByZWwuc3RhcnQoKSx0aGlzLl9iIC0gcmVsLnN0YXJ0KCksdGhpcy5fcm9vdCx0aGlzLl92aWV3KTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHJlZ2lvbil7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChyZWdpb24pe1xuXHRcdHJldHVybiB0aGlzLnN0YXJ0KCkgPT0gcmVnaW9uLnN0YXJ0KCkgJiYgdGhpcy5lbmQoKSA9PSByZWdpb24uZW5kKCk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnNhbWUgPSBmdW5jdGlvbiAocmVnaW9uKXtcblx0XHRyZXR1cm4gcmVnaW9uICYmIHJlZ2lvbi5hKCkgPT0gdGhpcy5hKCkgJiYgcmVnaW9uLmIoKSA9PSB0aGlzLmIoKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmVuZCgpIC0gdGhpcy5zdGFydCgpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKG51bSl7XG5cdFx0aWYobnVtID09PSB1bmRlZmluZWQpIG51bSA9IDE7XG5cdFx0dGhpcy5fYSArPSBudW07XG5cdFx0dGhpcy5fYiArPSBudW07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmNvbGxhcHNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnNpemUoKSA9PSAwO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLGIgPSB0aGlzLl9iO1xuXHRcdHRoaXMuX2EgPSBiO1xuXHRcdHRoaXMuX2IgPSBhO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yZXZlcnNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9hID4gdGhpcy5fYjtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGEgPSB0aGlzLnN0YXJ0KCk7XG5cdFx0dmFyIGIgPSB0aGlzLmVuZCgpO1xuXHRcdHRoaXMuX2EgPSBhO1xuXHRcdHRoaXMuX2IgPSBiO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jb2xsYXBzZSA9IGZ1bmN0aW9uIChmb3J3YXJkKXtcblx0XHRpZihmb3J3YXJkID09PSB1bmRlZmluZWQpIGZvcndhcmQgPSB0cnVlO1xuXHRcdGlmIChmb3J3YXJkKSB7XG5cdFx0XHR0aGlzLl9hID0gdGhpcy5fYiA9IHRoaXMuZW5kKCk7XG5cdFx0XHQvLyBAYSA9IEBiXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2IgPSB0aGlzLl9hO1xuXHRcdFx0dGhpcy5fYSA9IHRoaXMuX2IgPSB0aGlzLnN0YXJ0KCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIGV4cGFuZCB0byBjbG9zZXN0IC9uXG5cdFJlZ2lvbi5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKGF0U3RhcnQsYXRFbmQpe1xuXHRcdGlmICh0aGlzLmIoKSA8IHRoaXMuYSgpKSB7XG5cdFx0XHR0aGlzLl9iICs9IGF0U3RhcnQ7XG5cdFx0XHR0aGlzLl9hICs9IGF0RW5kO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9hICs9IGF0U3RhcnQ7XG5cdFx0XHR0aGlzLl9iICs9IGF0RW5kO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52aWV3KCkuc3Vic3RyKHRoaXMpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAoXCJbXCIgKyAodGhpcy5fYSkgKyBcIixcIiArICh0aGlzLl9iKSArIFwiXVwiKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uIChpbmNsdWRlRW5kcyl7XG5cdFx0aWYoaW5jbHVkZUVuZHMgPT09IHVuZGVmaW5lZCkgaW5jbHVkZUVuZHMgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHRoaXMsaW5jbHVkZUVuZHMpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5wcmV2Tm9kZSA9IGZ1bmN0aW9uIChxdWVyeSl7XG5cdFx0dmFyIG5vZGVzID0gdGhpcy5ub2RlcyhmYWxzZSk7XG5cdFx0dmFyIG5vZGUgPSBub2Rlcy5sZnQ7XG5cdFx0aWYgKChxdWVyeSBpbnN0YW5jZW9mIEltYmEuU2VsZWN0b3IpIHx8ICh0eXBlb2YgcXVlcnk9PSdzdHJpbmcnfHxxdWVyeSBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHZhciAkMTt3aGlsZSAobm9kZSl7XG5cdFx0XHRcdGlmIChub2RlLm1hdGNoZXMocXVlcnkpKSB7IHJldHVybiBub2RlIH07XG5cdFx0XHRcdG5vZGUgPSAoJDEgPSBub2RlKSAmJiAkMS5pc0xhc3QgICYmICAkMS5pc0xhc3QoKSA/IChub2RlLnBhcmVudCgpKSA6IChudWxsKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5uZXh0Tm9kZSA9IGZ1bmN0aW9uIChxdWVyeSl7XG5cdFx0dmFyIG5vZGVzID0gdGhpcy5ub2RlcyhmYWxzZSk7XG5cdFx0dmFyIG5vZGUgPSBub2Rlcy5yZ3Q7XG5cdFx0aWYgKChxdWVyeSBpbnN0YW5jZW9mIEltYmEuU2VsZWN0b3IpIHx8ICh0eXBlb2YgcXVlcnk9PSdzdHJpbmcnfHxxdWVyeSBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHZhciAkMTt3aGlsZSAobm9kZSl7XG5cdFx0XHRcdGlmIChub2RlLm1hdGNoZXMocXVlcnkpKSB7IHJldHVybiBub2RlIH07XG5cdFx0XHRcdG5vZGUgPSAoJDEgPSBub2RlKSAmJiAkMS5pc0ZpcnN0ICAmJiAgJDEuaXNGaXJzdCgpID8gKG5vZGUucGFyZW50KCkpIDogKG51bGwpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKHF1ZXJ5KXtcblx0XHR2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKGZhbHNlKTtcblx0XHR2YXIgbm9kZTtcblx0XHRpZiAobm9kZXMubGZ0KSB7XG5cdFx0XHRub2RlID0gbm9kZXMubGZ0LnVwKHF1ZXJ5KTtcblx0XHR9IGVsc2UgaWYgKG5vZGVzLnJndCkge1xuXHRcdFx0bm9kZSB8fCAobm9kZSA9IG5vZGVzLnJndC51cChxdWVyeSkpO1xuXHRcdH0gZWxzZSBpZiAobm9kZXNbMF0pIHtcblx0XHRcdG5vZGUgfHwgKG5vZGUgPSBub2Rlc1swXS5ub2RlLmNsb3Nlc3QocXVlcnkpKTtcblx0XHR9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5idWZmZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fcm9vdC5jb2RlKCk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnN0YXJ0QXRMaW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIoKTtcblx0XHR2YXIgYSA9IHRoaXMuc3RhcnQoKTtcblx0XHRcblx0XHRpZiAoYnVmZmVyW2FdID09ICdcXG4nICYmIHRoaXMuc2l6ZSgpID09IDApIHtcblx0XHRcdGEtLTsgLy8gaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgYSBsaW5lXG5cdFx0fTtcblx0XHRcblx0XHR3aGlsZSAoYSA+PSAwICYmIGJ1ZmZlclthXSAhPSAnXFxuJyl7XG5cdFx0XHRhLS07XG5cdFx0fTtcblx0XHR0aGlzLl9hID0gYTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuZW5kQXRMaW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIoKTtcblx0XHR2YXIgYiA9ICh0aGlzLmVuZCgpIC0gMSk7XG5cdFx0d2hpbGUgKGIgPj0gMCAmJiBidWZmZXJbYl0gJiYgYnVmZmVyW2JdICE9ICdcXG4nKXtcblx0XHRcdGIrKztcblx0XHR9O1xuXHRcdHRoaXMuX2IgPSBiO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jZWxsID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmlldygpLl9idWZmZXIubG9jVG9DZWxsKHRoaXMuYSgpKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY2VsbCgpWzBdO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jb2wgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jZWxsKClbMV07XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnBlZWtiZWhpbmQgPSBmdW5jdGlvbiAobGVuKXtcblx0XHRpZihsZW4gPT09IHVuZGVmaW5lZCkgbGVuID0gMTtcblx0XHRyZXR1cm4gbGVuID09IDEgPyAodGhpcy5idWZmZXIoKVt0aGlzLnN0YXJ0KCkgLSAxXSkgOiAodGhpcy5idWZmZXIoKS5zdWJzdHJpbmcodGhpcy5zdGFydCgpIC0gbGVuLHRoaXMuc3RhcnQoKSkpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5wZWVrYWhlYWQgPSBmdW5jdGlvbiAobGVuKXtcblx0XHRpZihsZW4gPT09IHVuZGVmaW5lZCkgbGVuID0gMTtcblx0XHRyZXR1cm4gbGVuID09IDEgPyAodGhpcy5idWZmZXIoKVt0aGlzLmVuZCgpXSkgOiAodGhpcy5idWZmZXIoKS5zdWJzdHIodGhpcy5lbmQoKSxsZW4pKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydEF0TGluZSgpLnRleHQoKS5tYXRjaCgvXlxcbj8oXFx0KikvKVsxXTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChiZWZvcmUsYWZ0ZXIpe1xuXHRcdGlmKGJlZm9yZSA9PT0gdW5kZWZpbmVkKSBiZWZvcmUgPSAwO1xuXHRcdGlmKGFmdGVyID09PSB1bmRlZmluZWQpIGFmdGVyID0gMDtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZShiZWZvcmUsYWZ0ZXIpLnRleHQoKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUubGxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB7c3RhcnRMaW5lOiAwLHN0YXJ0Q29sOiAyfTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLmEoKSx0aGlzLmIoKV07XG5cdH07XG5cdHJldHVybiBSZWdpb247XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9yZWdpb24uaW1iYVxuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0XG5cdFxuXHR2YXIgS0VZV09SRFMgPSAndmFyIGlmIGVsaWYgZWxzZSBmb3Igd2hpbGUgZGVmIGluIGlzYSB3aGlsZSB1bnRpbCBzd2l0Y2ggd2hlbiB0aGVuIHJldHVybiBjbGFzcyB0YWcgbGV0IGRvIGFuZCBvciBwcm9wIGF0dHIgaW4gcHJvcCcuc3BsaXQoJyAnKTtcblx0dmFyIE9QUyA9ICcrIC0gKiAvID0gKysgLS0gPT0gPT09ICE9ICE9PSA+IDwgPj0gPD0gJiAmJiB8IHx8IG9yIC4gOiA/Jy5zcGxpdCgnICcpO1xuXHRcblx0dmFyIFdISVRFU1BBQ0UgPSAvXlsgXFx0XFxuXSskLztcblx0XG5cdElNLkhMID0ge1xuXHRcdG5ld2xpbmU6IFwiPGIgY2xhc3M9J19pbW5ld2xpbmUnPlxcbjwvYj5cIixcblx0XHRzcGFjZTogZnVuY3Rpb24obSkgeyByZXR1cm4gKFwiPGIgY2xhc3M9J19pbXNwYWNlJz5cIiArIG0gKyBcIjwvYj5cIik7IH0sXG5cdFx0dGFiOiBmdW5jdGlvbihtKSB7IHJldHVybiBuZXcgQXJyYXkobS5sZW5ndGggKyAxKS5qb2luKFwiPGIgY2xhc3M9J19pbXRhYic+XFx0PC9iPlwiKTsgfVxuXHR9O1xuXHRcblx0XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuL3JlZ2lvbicpLlJlZ2lvbjtcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdFxuXHR2YXIgTUFUQ0hFUlMgPSB7XG5cdFx0a2V5d29yZDogZnVuY3Rpb24odikgeyByZXR1cm4gS0VZV09SRFMuaW5kZXhPZih2KSA+PSAwOyB9LFxuXHRcdHNlbGY6IC9eKHRoaXN8c2VsZikkLyxcblx0XHRjb25zdDogZnVuY3Rpb24odikgeyByZXR1cm4gKC9eW0EtWl1bXFx3XFxfXSokLykudGVzdCh2KTsgfSxcblx0XHRpdmFyOiBmdW5jdGlvbih2KSB7IHJldHVybiAoL15AW1xcd1xcX10rJC8pLnRlc3Qodik7IH0sXG5cdFx0Ym9vbDogZnVuY3Rpb24odikgeyByZXR1cm4gKC9eKHRydWV8eWVzfGZhbHNlfG5vfG51bGx8dW5kZWZpbmVkKSQvKS50ZXN0KHYpOyB9LFxuXHRcdGlkZW50aWZpZXI6IC9eW1xcJGEtel9dW1xcd1xcX1xcJF0qKFxcLVtcXCRcXHdcXF9dKykqJC8sXG5cdFx0ZmxvYXQ6IC9eXFxkK1xcLlxcZCskLyxcblx0XHRpbnQ6IC9eXFxkKyQvLFxuXHRcdGNvbW1lbnQ6IC9eXFwjKFsgXFx0XVteXFxuXSopPyQvXG5cdH07XG5cdFxuXHR2YXIgTU9ERVMgPSB7XG5cdFx0YWxsOiBPYmplY3Qua2V5cyhNQVRDSEVSUylcblx0fTtcblx0XG5cdFxuXHRcdFxuXHRcdFN0cmluZy5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKG51bSl7XG5cdFx0XHRyZXR1cm4gbmV3IEFycmF5KG51bSArIDEpLmpvaW4odGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHRTdHJpbmcucHJvdG90eXBlLmlucyA9IGZ1bmN0aW9uIChzdHIscmVnaW9uKXtcblx0XHRcdHZhciB0ZXh0ID0gdGhpcy50b1N0cmluZygpO1xuXHRcdFx0aWYgKHJlZ2lvbiA9PSAnYXBwZW5kJykge1xuXHRcdFx0XHRyZXR1cm4gdGV4dCArIHN0cjtcblx0XHRcdH0gZWxzZSBpZiAocmVnaW9uID09ICdwcmVwZW5kJykge1xuXHRcdFx0XHRyZXR1cm4gXCJcIiArIHN0ciArIHRleHQ7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZ2lvbiBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0XHRyZXR1cm4gdGV4dC5zdWJzdHIoMCxyZWdpb24uc3RhcnQoKSkgKyBzdHIgKyB0ZXh0LnNsaWNlKHJlZ2lvbi5lbmQoKSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKHN0cil7XG5cdFx0cmV0dXJuIFdISVRFU1BBQ0UudGVzdChzdHIpO1xuXHR9OyBleHBvcnRzLmlzV2hpdGVzcGFjZSA9IGlzV2hpdGVzcGFjZTtcblx0XG5cdElNLm51bSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHJldHVybiB0YWckLiRpbW51bSgpLmZsYWcoJ251bWJlcicpLnNldFRleHQodmFsKS5lbmQoKTtcblx0fTtcblx0XG5cdElNLnRhYiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0YWckLiRpbXRhYigpLnNldFRleHQoJ1xcdCcpLmVuZCgpO1xuXHR9O1xuXHRcblx0SU0ubmV3bGluZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0YWckLiRpbW5ld2xpbmUoKS5zZXRUZXh0KCdcXG4nKS5lbmQoKTtcblx0fTtcblx0XG5cdElNLm9wID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0cmV0dXJuIHRhZyQuJGltb3AoKS5mbGFnKCdvcCcpLnNldFRleHQodmFsKS5lbmQoKTtcblx0fTtcblx0XG5cdFxuXHRJTS50b2sgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRpZiAodmFsICYmIHZhbC5fZG9tKSB7IHJldHVybiB2YWwgfTtcblx0XHRpZiAodmFsLm1hdGNoKFdISVRFU1BBQ0UpKSB7IHJldHVybiBJTS5wYXJzZVdoaXRlc3BhY2UodmFsKSB9O1xuXHRcdGlmIChPUFMuaW5kZXhPZih2YWwpID49IDApIHsgcmV0dXJuIElNLm9wKHZhbCkgfTsgLy8gc2hvdWxkIHVzZSB0b2tlbiBkaXJlY3RseVxuXHRcdC8vIHJldHVybiBJTS5udW0odmFsKSBpZiB2YWwubWF0Y2goL15cXGQrKFxcLlxcZCspPyQvKSAjIHNob3VsZCB1c2UgdG9rZW4gZGlyZWN0bHlcblx0XHRyZXR1cm4gdGFnJC4kaW10b2soKS5zZXRUZXh0KHZhbCkuZW5kKCk7XG5cdH07XG5cdFxuXHRJTS5yYXcgPSBmdW5jdGlvbiAodmFsLGN0eCl7XG5cdFx0cmV0dXJuIHRhZyQuJGltcmF3KCkuc2V0UmF3KHZhbCkuZW5kKCk7XG5cdH07XG5cdFxuXHRJTS5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gV0hJVEVTUEFDRS50ZXN0KHZhbCk7XG5cdH07XG5cdFxuXHRJTS5pc09wID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0cmV0dXJuIE9QUy5pbmRleE9mKHZhbCkgPj0gMDtcblx0fTtcblx0XG5cdElNLnBhcnNlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uICh0ZXh0LHJpY2gpe1xuXHRcdGlmKHJpY2ggPT09IHVuZGVmaW5lZCkgcmljaCA9IHRydWU7XG5cdFx0dmFyIGhsID0gSU0uSEw7XG5cdFx0XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvKFxcbnxbIF0rfFtcXHRdKykvZyxmdW5jdGlvbihtLGwpIHtcblx0XHRcdGlmIChsID09ICdcXG4nKSB7XG5cdFx0XHRcdHJldHVybiBobC5uZXdsaW5lIHx8ICdcXG4nO1xuXHRcdFx0fSBlbHNlIGlmIChsWzBdID09ICcgJykge1xuXHRcdFx0XHRyZXR1cm4gaGwuc3BhY2UgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChobC5zcGFjZShsKSkgOiAobCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxbMF0gPT0gJ1xcdCcpIHtcblx0XHRcdFx0cmV0dXJuIGhsLnRhYiBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gKGhsLnRhYihsKSkgOiAobCk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdFxuXHRcdGlmIChyaWNoICYmIHRleHQuaW5kZXhPZignPCcpID49IDApIHtcblx0XHRcdHJldHVybiB0YWckLiRpbWZyYWdtZW50KCkuc2V0Q29udGVudCh0ZXh0LDApLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH07XG5cdFxuXHRJTS5pZGVudGlmeSA9IGZ1bmN0aW9uICh2YWwsbW9kZSl7XG5cdFx0aWYobW9kZSA9PT0gdW5kZWZpbmVkKSBtb2RlID0gJ2FsbCc7XG5cdFx0dmFyIHJ1bGVzID0gTU9ERVNbbW9kZV07XG5cdFx0dmFyIHJlcztcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocnVsZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBuYW1lOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdG5hbWUgPSBhcnlbaV07XG5cdFx0XHR2YXIgcnVsZSA9IE1BVENIRVJTW25hbWVdO1xuXHRcdFx0XG5cdFx0XHRpZiAocnVsZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHJlcyA9IHJ1bGUodmFsLG1vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHRcdHJlcyA9IHJ1bGUudGVzdCh2YWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlcykge1xuXHRcdFx0XHRyZXR1cm4gcmVzID09PSB0cnVlID8gKG5hbWUpIDogKHJlcyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHRJTS5wYXJzZSA9IGZ1bmN0aW9uIChjb2RlLGNvbnRleHQpe1xuXHRcdC8vIGRlY2lkZSBpZiBmdWxsP1xuXHRcdC8vIGNvbnNvbGUubG9nIFwicGFyc2UgY29kZSB7Y29kZTpsZW5ndGh9IHtjb2RlLnN1YnN0cigwLDIwKX1cIlxuXHRcdGlmICh0eXBlb2YgY29kZSAhPSAnc3RyaW5nJykgeyByZXR1cm4gY29kZSB9O1xuXHRcdFxuXHRcdGlmIChXSElURVNQQUNFLnRlc3QoY29kZSkpIHtcblx0XHRcdHJldHVybiBJTS5wYXJzZVdoaXRlc3BhY2UoY29kZSxmYWxzZSk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgd3MgPSBjb2RlLm1hdGNoKC9eKFsgXFx0XSopKFteXSo/KShbIFxcdF0qKSQvKSB8fCBbJycsJycsY29kZSwnJ107XG5cdFx0dmFyIGhsO1xuXHRcdFxuXHRcdGlmICh3c1sxXSB8fCB3c1szXSkge1xuXHRcdFx0Y29kZSA9IHdzWzJdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGlkID0gSU0uaWRlbnRpZnkoY29kZSk7XG5cdFx0XG5cdFx0aWYgKGlkKSB7XG5cdFx0XHR2YXIgdHlwID0gJ3NwYW4nO1xuXHRcdFx0dmFyIGNscyA9IEhpZ2hsaWdodGVyLk1hcHBpbmdbaWRdIHx8IGlkOyAvLyB0aGlzIGlzIHRoZSBpc3N1ZSwgbm8/XG5cdFx0XHRcblx0XHRcdGlmIChjbHMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHR0eXAgPSBjbHNbMF07XG5cdFx0XHRcdGNscyA9IGNsc1sxXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICghY2xzLm1hdGNoKC9cXGJfW1xcd10vKSkgeyBjbHMgPSAnX2ltdG9rICcgKyBjbHMgfTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdwYXJzZWQgYXMgdHlwZScsaWQsY2xzXG5cdFx0XHRobCA9ICc8JyArIHR5cCArICcgY2xhc3M9XCInICsgY2xzICsgJ1wiPicgKyBjb2RlICsgJzwvJyArIHR5cCArICc+Jztcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghaGwpIHtcblx0XHRcdGhsID0gSGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHdzKSB7XG5cdFx0XHRobCA9IElNLnBhcnNlV2hpdGVzcGFjZSh3c1sxXSxmYWxzZSkgKyBobCArIElNLnBhcnNlV2hpdGVzcGFjZSh3c1szXSxmYWxzZSk7XG5cdFx0fTtcblx0XHRpZiAoaGwpIHtcblx0XHRcdHJldHVybiBobDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRyZXR1cm4gSU0udGV4dE5vZGVzID0gZnVuY3Rpb24gKHJvb3QsbWFyayl7XG5cdFx0Ly8gY29uc29sZS50aW1lKCd0ZXh0Tm9kZXMyJylcblx0XHRpZihtYXJrID09PSB1bmRlZmluZWQpIG1hcmsgPSBmYWxzZTtcblx0XHRyb290ID0gcm9vdC5fZG9tIHx8IHJvb3Q7XG5cdFx0dmFyIGVsO1xuXHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdHZhciBwb3MgPSAwO1xuXHRcdHZhciB3YWxrID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihyb290LE5vZGVGaWx0ZXIuU0hPV19URVhULG51bGwsZmFsc2UpO1xuXHRcdFxuXHRcdHdoaWxlIChlbCA9IHdhbGsubmV4dE5vZGUoKSl7XG5cdFx0XHRpZiAobWFyaykge1xuXHRcdFx0XHR2YXIgbGVuID0gZWwubGVuZ3RoO1xuXHRcdFx0XHRlbC5fbG9jID0gcG9zO1xuXHRcdFx0XHRwb3MgKz0gbGVuO1xuXHRcdFx0fTtcblx0XHRcdG5vZGVzLnB1c2goZWwpO1xuXHRcdH07XG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9O1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvaGVscGVycy5pbWJhXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0Ly8gdmFyIGltYmFjID0gZ2xvYmFsLkltYmFjXG5cdHZhciBMZXhlciA9IHJlcXVpcmUoJ2ltYmEvc3JjL2NvbXBpbGVyL2xleGVyJykuTGV4ZXI7XG5cdFxuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXHRcblx0dmFyIE5PREVUWVBFID0gJ2InO1xuXHR2YXIgS0VZV09SRFMgPSBbXG5cdFx0J251bGwnLCd0aGlzJyxcblx0XHQnZGVsZXRlJywndHlwZW9mJywnaW4nLCdpbnN0YW5jZW9mJyxcblx0XHQndGhyb3cnLCdicmVhaycsJ2NvbnRpbnVlJywnZGVidWdnZXInLFxuXHRcdCdpZicsJ2Vsc2UnLCdzd2l0Y2gnLCdmb3InLCd3aGlsZScsJ2RvJywndHJ5JywnY2F0Y2gnLCdmaW5hbGx5Jyxcblx0XHQnY2xhc3MnLCdleHRlbmRzJywnc3VwZXInLCdyZXR1cm4nLFxuXHRcdCd1bmRlZmluZWQnLCd0aGVuJywndW5sZXNzJywndW50aWwnLCdsb29wJywnb2YnLCdieScsXG5cdFx0J3doZW4nLCdkZWYnLCd0YWcnLCdkbycsJ2VsaWYnLCdiZWdpbicsJ3ZhcicsJ2xldCcsJ3NlbGYnLCdhd2FpdCcsJ2ltcG9ydCcsXG5cdFx0J2FuZCcsJ29yJywnaXMnLCdpc250Jywnbm90JywnaXNhJywnY2FzZScsJ25pbCdcblx0XTtcblx0XG5cdHZhciBjbGFzc2VzID0ge1xuXHRcdCcrJzogJ19pbW9wIG9wIGFkZCBtYXRoJyxcblx0XHQnKysnOiAnX2ltb3Agb3AgaW5jciBtYXRoJyxcblx0XHQnLS0nOiAnX2ltb3Agb3AgZGVjciBtYXRoJyxcblx0XHQnLSc6ICdfaW1vcCBvcCBzdWIgbWF0aCcsXG5cdFx0Jz0nOiAnX2ltb3Agb3AgZXEnLFxuXHRcdCcvJzogJ19pbW9wIG9wIGRpdiBtYXRoJyxcblx0XHQnKic6ICdfaW1vcCBvcCBtdWx0IG1hdGgnLFxuXHRcdCc/JzogJ19pbW9wIG9wIHRlcm5hcnknLFxuXHRcdCcsJzogJ19pbW9wIG9wIGNvbW1hJyxcblx0XHQnOic6ICdfaW1vcCBvcCBjb2xvbicsXG5cdFx0Jy4nOiAnX2ltb3Agb3AgZG90Jyxcblx0XHQnLjonOiAnX2ltb3Agb3AgY2RvdCcsXG5cdFx0JyEnOiAnX2ltb3Agb3AgdW5hcnknLFxuXHRcdCc/Lic6ICdfaW1vcCBvcCBxZG90Jyxcblx0XHQnWyc6ICdfaW1vcGVuIHNiIHNibCcsXG5cdFx0J10nOiAnX2ltY2xvc2Ugc2Igc2JyJyxcblx0XHQnKCc6ICdfaW1vcGVuIHJiIHJibCcsXG5cdFx0JyknOiAnX2ltY2xvc2UgcmIgcmJyJyxcblx0XHQneyc6ICdfaW1vcGVuIGNiIGNibCcsXG5cdFx0J30nOiAnX2ltY2xvc2UgY2IgY2JyJyxcblx0XHQnIyc6ICdfaW1vcCBvcCBoYXNoJyxcblx0XHQnY2FsbF9zdGFydCc6ICdfaW1vcGVuIGNhbGwgcmIgcmJsJyxcblx0XHQnY2FsbF9lbmQnOiAnX2ltY2xvc2UgY2FsbCByYiByYnInLFxuXHRcdCd0YWdfc3RhcnQnOiAnX2ltb3BlbiB0YWdfb3BlbicsXG5cdFx0J3RhZ19lbmQnOiAnX2ltY2xvc2UgdGFnX2Nsb3NlJyxcblx0XHRcblx0XHQndHJ1ZSc6ICdfaW1ib29sIHRydWUnLFxuXHRcdCd5ZXMnOiAnX2ltYm9vbCB0cnVlJyxcblx0XHQnZmFsc2UnOiAnX2ltYm9vbCBmYWxzZScsXG5cdFx0J25vJzogJ19pbWJvb2wgZmFsc2UnLFxuXHRcdFxuXHRcdCd7eyc6ICdfaW1vcGVuJyxcblx0XHQnfX0nOiAnX2ltY2xvc2UnLFxuXHRcdFxuXHRcdCdcIic6ICdkb3VibGVxdW90ZScsXG5cdFx0XCInXCI6ICdzaW5nbGVxdW90ZScsXG5cdFx0XG5cdFx0J3JlZ2V4JzogJ19pbXJlZ2V4IHJlZ2V4Jyxcblx0XHQnaWRlbnRpZmllcic6ICdfaW10b2sgX2ltaWRlbnRpZmllciBpZGVudGlmaWVyJyxcblx0XHRcblx0XHQnY29tcG91bmRfYXNzaWduJzogJ29wIGFzc2lnbiBjb21wb3VuZCcsXG5cdFx0J3N0cic6ICdfaW1zdHIgc3RyaW5nJyxcblx0XHQnbnVtJzogJ19pbW51bSBudW1iZXInLFxuXHRcdCdzdHJpbmcnOiAnX2ltc3RyIHN0cmluZycsXG5cdFx0J251bWJlcic6ICdfaW1udW0gbnVtYmVyJyxcblx0XHQnbWF0aCc6ICdfaW1vcCBvcCBtYXRoJyxcblx0XHQndW5hcnknOiAnX2ltb3Agb3AgdW5hcnknLFxuXHRcdCdmb3Jpbic6ICdrZXl3b3JkIGluJyxcblx0XHQnZm9yb2YnOiAna2V5d29yZCBvZicsXG5cdFx0J293bic6ICdrZXl3b3JkIG93bicsXG5cdFx0J2NvbXBhcmUnOiAnX2ltb3Agb3AgY29tcGFyZScsXG5cdFx0J2hlcmVjb21tZW50JzogJ19oZXJlY29tbWVudCcsXG5cdFx0J3JlbGF0aW9uJzogJ2tleXdvcmQgcmVsYXRpb24nLFxuXHRcdCdleHBvcnQnOiAna2V5d29yZCBleHBvcnQnLFxuXHRcdCdnbG9iYWwnOiAna2V5d29yZCBnbG9iYWwnLFxuXHRcdCdleHRlcm4nOiAna2V5d29yZCBnbG9iYWwnLFxuXHRcdCdleHRlbmQnOiAna2V5d29yZCBleHRlbmQnLFxuXHRcdCdyZXF1aXJlJzogJ2tleXdvcmQgcmVxdWlyZScsXG5cdFx0J2Zyb20nOiAna2V5d29yZCBmcm9tJyxcblx0XHQnbG9naWMnOiAna2V5d29yZCBsb2dpYycsXG5cdFx0J3Bvc3RfaWYnOiAna2V5d29yZCBpZiBwb3N0X2lmJyxcblx0XHQncG9zdF9mb3InOiAna2V5d29yZCBmb3IgcG9zdF9mb3InLFxuXHRcdCdwcm9wJzogJ2tleXdvcmQgcHJvcCcsXG5cdFx0J2F0dHInOiAna2V5d29yZCBhdHRyJyxcblx0XHRcblx0XHQnc2VsZWN0b3Jfc3RhcnQnOiAnX2ltb3BlbiBfaW1zZWxvcGVuIHNlbGVjdG9yX3N0YXJ0Jyxcblx0XHQnc2VsZWN0b3JfZW5kJzogJ19pbWNsb3NlIF9pbXNlbGNsb3NlIHNlbGVjdG9yX2VuZCcsXG5cdFx0J2luZGV4X3N0YXJ0JzogJ19pbW9wZW4gaW5kZXhfc3RhcnQnLFxuXHRcdCdpbmRleF9lbmQnOiAnX2ltY2xvc2UgaW5kZXhfZW5kJyxcblx0XHQnYmxvY2tfcGFyYW1fc3RhcnQnOiAnX2ltb3BlbicsXG5cdFx0J2Jsb2NrX3BhcmFtX2VuZCc6ICdfaW1jbG9zZScsXG5cdFx0XG5cdFx0J3N0cmluZ19zdGFydCc6ICdfaW1zdHJzdGFydCBzdHJpbmdfc3RhcnQnLFxuXHRcdCdzdHJpbmdfZW5kJzogJ19pbXN0cmVuZCBzdHJpbmdfZW5kJyxcblx0XHQnbmVvc3RyaW5nJzogJ19pbXRvayBfaW1uZW9zdHJpbmcnXG5cdH07XG5cdFxuXHR2YXIgSU5URVJQT0xBVElORyA9ICdfaW1pc3RyaW5nJztcblx0XG5cdHZhciBPUEVOID0ge1xuXHRcdCd0YWdfc3RhcnQnOiAnX2ltdGFnbm9kZSB0YWdub2RlJyxcblx0XHQnY2FsbF9zdGFydCc6ICdfaW1wYXJlbnMgY2FsbCcsXG5cdFx0J3NlbGVjdG9yX3N0YXJ0JzogJ19pbXNlbCBzZWxlY3RvcicsXG5cdFx0J3N0cmluZ19zdGFydCc6ICdfaW1pc3RyaW5nJyxcblx0XHQnaW5kZXhfc3RhcnQnOiAnaW5kZXgnLFxuXHRcdCdibG9ja19wYXJhbV9zdGFydCc6ICdfaW1wYWlyIF9pbWJsb2NrcGFyYW1zJyxcblx0XHQvLyAnaW5kZW50JzogJ19pbmRlbnQnXG5cdFx0JygnOiAnX2ltcGFyZW5zIHBhcmVuJyxcblx0XHQne3snOiAnX2ltaWV4cHInLFxuXHRcdCd7JzogJ19pbWN1cmx5IGN1cmx5Jyxcblx0XHQnWyc6ICdfaW1zcXVhcmUgc3F1YXJlJyxcblx0XHQnKFwiJzogJ19pbWlzdHJpbmcnXG5cdH07XG5cdFxuXHRcblx0XG5cdHZhciBDTE9TRSA9IHtcblx0XHQndGFnX2VuZCc6ICd0YWcnLFxuXHRcdCdjYWxsX2VuZCc6ICdfaW1wYXJlbnMgY2FsbCcsXG5cdFx0J3N0cmluZ19lbmQnOiAnX2ltaXN0cmluZycsXG5cdFx0J3NlbGVjdG9yX2VuZCc6ICdzZWwnLFxuXHRcdCdpbmRleF9lbmQnOiAnaW5kZXgnLFxuXHRcdCdibG9ja19wYXJhbV9lbmQnOiAnX2ltcGFpciBfaW1ibG9ja3BhcmFtcycsXG5cdFx0J319JzogJ19pbWlleHByJyxcblx0XHQnKSc6ICdwYXJlbicsXG5cdFx0J10nOiAnc3F1YXJlJyxcblx0XHQnfSc6ICdjdXJseScsXG5cdFx0J1wiKSc6ICdzdHJpbmcnXG5cdH07XG5cdFxuXHR2YXIgT1BTID0gJysgLSAqIC8gPSArKyAtLSA9PSA9PT0gIT0gIT09ID4gPCA+PSA8PSAmICYmIHwgfHwgb3IgLiA6ID8nLnNwbGl0KCcgJyk7XG5cdFxuXHR2YXIgaGxvID0ge1xuXHRcdG5ld2xpbmU6IFwiPGIgY2xhc3M9J19pbW5ld2xpbmUnPlxcbjwvYj5cIixcblx0XHRzcGFjZTogZnVuY3Rpb24obSkgeyByZXR1cm4gKFwiPGIgY2xhc3M9J19pbXNwYWNlJz5cIiArIG0gKyBcIjwvYj5cIik7IH0sXG5cdFx0dGFiOiBmdW5jdGlvbihtKSB7IHJldHVybiBuZXcgQXJyYXkobS5sZW5ndGggKyAxKS5qb2luKFwiPGIgY2xhc3M9J19pbXRhYic+XFx0PC9iPlwiKTsgfVxuXHR9O1xuXHRcblx0ZnVuY3Rpb24gU3RhY2soKXtcblx0XHR0aGlzLl9zdGFjayA9IFtdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsKXtcblx0XHR0aGlzLl9zdGFjay5wdXNoKHZhbCk7XG5cdFx0dGhpcy5fY3VycmVudCA9IHZhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbGVuID0gdGhpcy5fc3RhY2sucG9wKCk7XG5cdFx0dGhpcy5fY3VycmVudCA9IHRoaXMuX3N0YWNrW2xlbiAtIDFdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBUb2tlbih0eXBlLHZhbHVlLGxpbmUsbG9jLGxlbil7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLl9tZXRhID0gbnVsbDtcblx0XHR0aGlzLl9saW5lID0gbGluZSB8fCAwO1xuXHRcdHRoaXMuX2NvbCA9IC0xO1xuXHRcdHRoaXMuX2xvYyA9IGxvYyB8fCAwO1xuXHRcdHRoaXMuX2xlbiA9IGxlbiB8fCAwO1xuXHRcdHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5uZXdMaW5lID0gZmFsc2U7XG5cdFx0dGhpcy5zcGFjZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0ZXhwb3J0cy5Ub2tlbiA9IFRva2VuOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRva2VuLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH07XG5cdFxuXHRUb2tlbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cdH07XG5cdFxuXHRUb2tlbi5wcm90b3R5cGUubG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYztcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbGVuO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBIaWdobGlnaHRlcihjb2RlLHRva2Vucyxhc3Qsbyl7XG5cdFx0dmFyIGhsXztcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHR0aGlzLl9jb2RlID0gY29kZTtcblx0XHR0aGlzLl90b2tlbnMgPSB0b2tlbnM7XG5cdFx0dGhpcy5fYXN0ID0gYXN0O1xuXHRcdFxuXHRcdG8ucmVuZGVyIHx8IChvLnJlbmRlciA9IHt9KTtcblx0XHRvLmhsIHx8IChvLmhsID0ge30pO1xuXHRcdChobF8gPSBvLmhsKS5uZXdsaW5lIHx8IChobF8ubmV3bGluZSA9ICc8YiBjbGFzcz1cIl9uXCI+XFxuPC9iPicpO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvO1xuXHRcdFxuXHRcdHRoaXMuX29wdGlvbnMubmV4dFZhckNvdW50ZXIgfHwgKHRoaXMuX29wdGlvbnMubmV4dFZhckNvdW50ZXIgPSAwKTtcblx0XHR0aGlzLl92YXJSZWZzID0ge307XG5cdFx0XG5cdFx0aWYgKG8ubW9kZSA9PSAnZnVsbCcgJiYgIWFzdCkge1xuXHRcdFx0dGhpcy5fYXN0ID0gSW1iYWMucGFyc2UodGhpcy5fdG9rZW5zLHt9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5IaWdobGlnaHRlciA9IEhpZ2hsaWdodGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdEhpZ2hsaWdodGVyLk1hcHBpbmcgPSBjbGFzc2VzO1xuXHRcblx0SGlnaGxpZ2h0ZXIubG9nZ2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFZJRVcubG9nZ2VyKCk7XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci50b2tlbml6ZSA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdC8vIGNvbnNvbGUubG9nICd0b2tlbml6ZSB1c2luZyBsb2NhbCBsZXhlcidcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRpZiAoZ2xvYmFsLkltYmFjKSB7XG5cdFx0XHRyZXR1cm4gSW1iYWMudG9rZW5pemUoY29kZSxvKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX2xleGVyIHx8ICh0aGlzLl9sZXhlciA9IG5ldyBMZXhlcigpKTtcblx0XHR0aGlzLl9sZXhlci5yZXNldCgpO1xuXHRcdHJldHVybiB0aGlzLl9sZXhlci50b2tlbml6ZShjb2RlLG8pO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIucmVjbGFzc2lmeSA9IGZ1bmN0aW9uIChkb21ub2RlLHR5cGUsdG9rZW4sbmV3Q29kZSxvbGRDb2RlKXtcblx0XHRcblx0XHR0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdC8vIGNvbnNvbGUubG9nICdyZWNsYXNzaWZ5IG5vZGUgYXMgdHlwZScsZG9tbm9kZSx0eXBlLHRva2VuXG5cdFx0dmFyIGNscyA9IElNLlR5cGVzW3R5cGVdIHx8IEltYmEuVEFHU1soXCJpbVwiICsgdHlwZSldIHx8IElNLlR5cGVzLnRva2VuO1xuXHRcdFxuXHRcdHZhciBub2RlID0gdGFnJHdyYXAoZG9tbm9kZSk7XG5cdFx0XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBjbHMpIHtcblx0XHRcdHJldHVybiBub2RlLnJldXNlKHRva2VuLG5ld0NvZGUsb2xkQ29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoY2xzKSB7XG5cdFx0XHRub2RlID0gbmV3IGNscyhkb21ub2RlKS5zZXR1cCh0b2tlbixuZXdDb2RlLG9sZENvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cdFxuXHRcblx0SGlnaGxpZ2h0ZXIubmVzdFRva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMsb2Zmc2V0KXtcblx0XHR2YXIgcGFpcmluZyA9IHtcblx0XHRcdCdUQUdfU1RBUlQnOiAnVEFHX0VORCcsXG5cdFx0XHQnU0VMRUNUT1JfU1RBUlQnOiAnU0VMRUNUT1JfRU5EJyxcblx0XHRcdCdDQUxMX1NUQVJUJzogJ0NBTExfRU5EJyxcblx0XHRcdCdJTkRFWF9TVEFSVCc6ICdJTkRFWF9FTkQnLFxuXHRcdFx0J1NUUklOR19TVEFSVCc6ICdTVFJJTkdfRU5EJyxcblx0XHRcdCdCTE9DS19QQVJBTV9TVEFSVCc6ICdCTE9DS19QQVJBTV9FTkQnLFxuXHRcdFx0J3t7JzogJ319Jyxcblx0XHRcdCd7JzogJ30nLFxuXHRcdFx0J1snOiAnXScsXG5cdFx0XHQnKCc6ICcpJ1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIG5hbWluZyA9IHtcblx0XHRcdCdUQUdfU1RBUlQnOiAndGFnbm9kZScsXG5cdFx0XHQnU0VMRUNUT1JfU1RBUlQnOiAnc2VsZWN0b3InLFxuXHRcdFx0J1NUUklOR19TVEFSVCc6ICdpc3RyaW5nJyxcblx0XHRcdCdDQUxMX1NUQVJUJzogJ3BhcmVucycsXG5cdFx0XHQnSU5ERVhfU1RBUlQnOiAnc3F1YXJlJyxcblx0XHRcdCdCTE9DS19QQVJBTV9TVEFSVCc6ICdibG9ja3BhcmFtcycsXG5cdFx0XHQne3snOiAnaWV4cHInLFxuXHRcdFx0J3snOiAnY3VybHknLFxuXHRcdFx0J1snOiAnc3F1YXJlJyxcblx0XHRcdCcoJzogJ3BhcmVucydcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBpZHggPSAwO1xuXHRcdFxuXHRcdHZhciByb290ID0ge1xuXHRcdFx0X2xvYzogMCxcblx0XHRcdF9vZmZzZXQ6IDAsXG5cdFx0XHRfY2hpbGRyZW46IFtdXG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc3RhY2sgPSBbcm9vdF07XG5cdFx0dmFyIGVuZHMgPSBbXTtcblx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHRcblx0XHR2YXIgbG9jLHZhbCx0eXAsY3R4LHRvaztcblx0XHRcblx0XHR3aGlsZSAodG9rID0gdG9rZW5zW2lkeCsrXSl7XG5cdFx0XHRsb2MgPSB0b2suX2xvYztcblx0XHRcdHZhbCA9IHRvay5fdmFsdWU7XG5cdFx0XHR0eXAgPSB0b2suX3R5cGU7XG5cdFx0XHRcblx0XHRcdC8vIG5vcm1hbGl6aW5nIGJlY2F1c2Ugd2UgZG9udCByZXdyaXRlIHRva2VucyAoc2hvdWxkIHN0YXJ0IHdpdGggdGhhdClcblx0XHRcdGlmICh0eXAgPT0gJ0lERU5USUZJRVInICYmICh2YWwgPT0gJ3Byb3AnIHx8IHZhbCA9PSAnYXR0cicpKSB7IHR5cCA9IHRvay5fdHlwZSA9ICdLRVlXT1JEJyB9OyAvLyBub3QgYWx3YXlzXG5cdFx0XHRpZiAodHlwID09ICdJTkRFWF9TVEFSVCcpIHsgdHlwID0gdG9rLl90eXBlID0gJ1snIH07XG5cdFx0XHRpZiAodHlwID09ICdJTkRFWF9FTkQnKSB7IHR5cCA9IHRvay5fdHlwZSA9ICddJyB9O1xuXHRcdFx0aWYgKHR5cCA9PSAnQ0FMTF9TVEFSVCcpIHsgdHlwID0gdG9rLl90eXBlID0gJygnIH07XG5cdFx0XHRpZiAodHlwID09ICdDQUxMX0VORCcpIHsgdHlwID0gdG9rLl90eXBlID0gJyknIH07XG5cdFx0XHRcblx0XHRcdGN0eCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0XG5cdFx0XHRsb2MgLT0gY3R4Ll9vZmZzZXQ7XG5cdFx0XHQvLyBvZmZzZXQgcmVsYXRpdmUgdG8gY29udGV4dFxuXHRcdFx0dmFyIGNsb3NlciA9IHBhaXJpbmdbdHlwXTtcblx0XHRcdFxuXHRcdFx0aWYgKGNsb3Nlcikge1xuXHRcdFx0XHR2YXIgZ3JvdXAgPSBuZXcgVG9rZW4obmFtaW5nW3R5cF0sJycsLTEsbG9jKTtcblx0XHRcdFx0Z3JvdXAuX29mZnNldCA9IGN0eC5fb2Zmc2V0ICsgbG9jO1xuXHRcdFx0XHRvZmZzZXQgKz0gbG9jO1xuXHRcdFx0XHRncm91cC5fY2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0ZW5kcy5wdXNoKGNsb3Nlcik7XG5cdFx0XHRcdHN0YWNrLnB1c2goZ3JvdXApO1xuXHRcdFx0XHRjdHguX2NoaWxkcmVuLnB1c2goZ3JvdXApO1xuXHRcdFx0XHRjdHggPSBncm91cDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRvay5fbG9jIC09IGN0eC5fb2Zmc2V0O1xuXHRcdFx0XG5cdFx0XHQvLyB1cGRhdGUgbGVuZ3RoIGF0IGFsbCB0aW1lc1xuXHRcdFx0aWYgKHRvay5fbGVuID49IDEpIHtcblx0XHRcdFx0Y3R4Ll9jaGlsZHJlbi5wdXNoKHRvayk7XG5cdFx0XHRcdGN0eC5fbGVuID0gdG9rLl9sb2MgKyB0b2suX2xlbjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChlbmRzW2VuZHMubGVuZ3RoIC0gMV0gPT0gdHlwKSB7XG5cdFx0XHRcdGVuZHMucG9wKCk7XG5cdFx0XHRcdGN0eC5fbGVuID0gdG9rLl9sb2MgKyB0b2suX2xlbjtcblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdC8vIG9mZnNldCAtPSBjdHguQG9mZnNldFxuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nICdjaGlsZHJlbiBoZXJlJyxyb290LkBjaGlsZHJlblxuXHRcdHJldHVybiByb290Ll9jaGlsZHJlbjtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLm5vcm1hbGl6ZVRva2VucyA9IGZ1bmN0aW9uIChjb2RlLHRva2VucyxvZmZzZXQpe1xuXHRcdGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xuXHRcdHZhciBpZHggPSAwO1xuXHRcdHZhciBjYXJldCA9IDA7XG5cdFx0dmFyIG5ldyQgPSBbXTtcblx0XHR2YXIgdG9rLG5leHQsdHlwLHZhbDtcblx0XHR2YXIgbG9jID0gMDtcblx0XHRcblx0XHR2YXIgc3RhY2sgPSBuZXcgU3RhY2soKTtcblx0XHRcblx0XHR2YXIgd3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXd0b2sgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAobG9jID4gY2FyZXQpe1xuXHRcdFx0XHR2YXIgY2hyID0gY29kZVtjYXJldF07XG5cdFx0XHRcdGlmIChjaHIgPT0gJ1xcdCcpIHtcblx0XHRcdFx0XHRuZXd0b2sgPSBuZXcgVG9rZW4oJ3RhYicsY2hyLC0xLGNhcmV0LDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnXFxuJykge1xuXHRcdFx0XHRcdG5ld3RvayA9IG5ldyBUb2tlbignbmV3bGluZScsY2hyLC0xLGNhcmV0LDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnOycpIHtcblx0XHRcdFx0XHRuZXd0b2sgPSBuZXcgVG9rZW4oJ3NlbWljb2xvbicsY2hyLC0xLGNhcmV0LDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnICcpIHtcblx0XHRcdFx0XHRpZiAobmV3dG9rICYmIG5ld3Rvay5fdHlwZSA9PSAnd2hpdGVzcGFjZScpIHtcblx0XHRcdFx0XHRcdG5ld3Rvay5fdmFsdWUgKz0gJyAnO1xuXHRcdFx0XHRcdFx0bmV3dG9rLl9sZW4gKz0gMTtcblx0XHRcdFx0XHRcdGNhcmV0Kys7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdG5ld3RvayA9IG5ldyBUb2tlbignd2hpdGVzcGFjZScsY2hyLC0xLGNhcmV0LDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnIycpIHtcblx0XHRcdFx0XHR2YXIgc3RhcnRsb2MgPSBjYXJldDtcblx0XHRcdFx0XHR2YXIgY29tbWVudCA9ICcnO1xuXHRcdFx0XHRcdHdoaWxlIChjYXJldCA8IGxvYyAmJiBjb2RlW2NhcmV0XSAhPSAnXFxuJyl7XG5cdFx0XHRcdFx0XHRjb21tZW50ICs9IGNvZGVbY2FyZXRdO1xuXHRcdFx0XHRcdFx0Y2FyZXQrKztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdG5ldyQucHVzaChuZXcgVG9rZW4oJ2NvbW1lbnQnLGNvbW1lbnQsLTEsc3RhcnRsb2MsY29tbWVudC5sZW5ndGgpKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXd0b2sgPSBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FyZXQrKztcblx0XHRcdFx0aWYgKG5ld3RvaykgeyBuZXckLnB1c2gobmV3dG9rKSB9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybjtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBza2lwID0gWydURVJNSU5BVE9SJywnSU5ERU5UJywnT1VUREVOVCcsJyAnLCcgXFx0J107XG5cdFx0XG5cdFx0d2hpbGUgKHRvayA9IHRva2Vuc1tpZHgrK10pe1xuXHRcdFx0bmV4dCA9IHRva2Vuc1tpZHhdO1xuXHRcdFx0bG9jID0gdG9rLl9sb2M7XG5cdFx0XHR2YWwgPSB0b2suX3ZhbHVlO1xuXHRcdFx0dHlwID0gdG9rLl90eXBlO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwID09ICcjJyAmJiBuZXh0ICYmIG5leHQuX3R5cGUgPT0gJ0lERU5USUZJRVInKSB7XG5cdFx0XHRcdG5leHQuX3R5cGUgPSAnSURSRUYnO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cCA9PSAnKCcgJiYgdmFsID09ICcoXCInKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2godmFsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChza2lwLmluZGV4T2YodHlwKSA+PSAwKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XG5cdFx0XHRpZiAobG9jID4gY2FyZXQpIHsgd3MoKSB9O1xuXHRcdFx0Y2FyZXQgPSB0b2suX2xvYyArIHRvay5fbGVuO1xuXHRcdFx0bmV3JC5wdXNoKHRvayk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBtb3ZlIHRvIHRoZSBlbmQgdG8gcG9zc2libHkgcGFyc2UgbW9yZSB3aGl0ZXNwYWNlXG5cdFx0bG9jID0gY29kZS5sZW5ndGg7XG5cdFx0d3MoKTtcblx0XHQvLyBub3cgbmVzdCB0aGUgdG9rZW5zXG5cdFx0bmV3JCA9IHRoaXMubmVzdFRva2VucyhuZXckKTtcblx0XHRyZXR1cm4gbmV3JDtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLndoaXRlc3BhY2VUb1Rva2VucyA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHZhciB0b2s7XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdHZhciBjYXJldCA9IDA7XG5cdFx0dmFyIGxlbiA9IHN0ci5sZW5ndGg7XG5cdFx0XG5cdFx0d2hpbGUgKGxlbiA+IGNhcmV0KXtcblx0XHRcdHZhciBsb2MgPSBjYXJldDtcblx0XHRcdHZhciBjaHIgPSBzdHJbY2FyZXQrK107XG5cdFx0XHRpZiAoY2hyID09ICdcXHQnKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHRvayA9IG5ldyBUb2tlbigndGFiJyxjaHIsLTEsbG9jLDEpKTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICdcXG4nKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHRvayA9IG5ldyBUb2tlbignbmV3bGluZScsY2hyLC0xLGxvYywxKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnICcpIHtcblx0XHRcdFx0aWYgKHRvayAmJiB0b2suX3R5cGUgPT0gJ3doaXRlc3BhY2UnKSB7XG5cdFx0XHRcdFx0dG9rLl92YWx1ZSArPSAnICc7XG5cdFx0XHRcdFx0dG9rLl9sZW4gKz0gMTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0dG9rZW5zLnB1c2godG9rID0gbmV3IFRva2VuKCd3aGl0ZXNwYWNlJyxjaHIsLTEsbG9jLDEpKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdG9rZW5zO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIucmVwYXJzZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRcblx0XHR2YXIgJDE7XG5cdFx0aWYgKG8gaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdFx0XHR2YXIgZWwgPSB0YWckd3JhcChvKTtcblx0XHRcdGlmIChlbCkgeyAoJDEgPSBlbCkgJiYgJDEubXV0YXRlZCAgJiYgICQxLm11dGF0ZWQoKSB9O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIG5vZGVzID0gby5ub2Rlcztcblx0XHR2YXIgY29kZSA9IG8uY29kZTtcblx0XHR2YXIgdG9rZW5zID0gby50b2tlbnM7XG5cdFx0Ly8gc2hvdWxkIHVzZSBhIGdsb2JhbCBsb2dnZXItaW5zdGFuY2Vcblx0XHR0aGlzLmxvZ2dlcigpLmdyb3VwQ29sbGFwc2VkKCdyZXBhcnNlICVzJyxKU09OLnN0cmluZ2lmeShjb2RlKSk7XG5cdFx0XG5cdFx0aWYgKHV0aWwuaXNXaGl0ZXNwYWNlKGNvZGUpICYmICF0b2tlbnMpIHtcblx0XHRcdGNvbnNvbGUubG9nKCd1c2luZyB3aGl0ZXNwYWNlVG9Ub2tlbnMnKTtcblx0XHRcdHRva2VucyA9IHRoaXMud2hpdGVzcGFjZVRvVG9rZW5zKGNvZGUpO1xuXHRcdH07XG5cdFx0Ly8gbG9nZ2VyLmxvZyBub2Rlcy5zbGljZVxuXHRcdC8vIGJpZyBoYWNrIC0gYWRkaW5nIGEgc3BhY2UgYXQgdGhlIGVuZCB0byBjbG9zZSB1cCBzZWxlY3RvcnNcblx0XHQvLyBzaG91bGQgcmF0aGVyIGRyb3AgaW5saW5lIGFuZCBsZXQgdGhlIHBhcnNlciBwYWlyIHVwIGxvb3NlIGVuZHM/XG5cdFx0aWYgKCF0b2tlbnMpIHtcblx0XHRcdHRva2VucyA9IHRoaXMudG9rZW5pemUoY29kZSArICcgJyx7aW5saW5lOiB0cnVlLHNpbGVudDogdHJ1ZSxyZXdyaXRlOiBmYWxzZX0pO1xuXHRcdFx0dG9rZW5zID0gdGhpcy5ub3JtYWxpemVUb2tlbnMoY29kZSx0b2tlbnMpO1xuXHRcdFx0dGhpcy5sb2dnZXIoKS5sb2codG9rZW5zLnNsaWNlKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5sb2dnZXIoKS5sb2cobm9kZXMuc2xpY2UoKSk7XG5cdFx0dGhpcy5hcHBseVRva2Vucyhjb2RlLHRva2Vucyxub2RlcyxvLm5lc3RlZCxvLnBhcmVudCk7XG5cdFx0dGhpcy5sb2dnZXIoKS5ncm91cEVuZCgpO1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLmFwcGx5VG9rZW5zID0gZnVuY3Rpb24gKGNvZGUsdG9rZW5zLG5vZGVzLG5lc3RlZCxwYXJlbnQpe1xuXHRcdC8vIHdoYXQgYWJvdXQgbGVuIGFuZCBsb2MgZm9yIGlubmVyIG5vZGVzPyBTaG91bGQgdGhpcyBiZSBzZXQgYWxyZWFkeT9cblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIG5vZGU7XG5cdFx0dmFyIHByZXZOb2RlO1xuXHRcdFxuXHRcdHZhciBhZGROb2RlID0gZnVuY3Rpb24obm9kZXMsaW5kZXgsYWZ0ZXIpIHtcblx0XHRcdHNlbGYubG9nZ2VyKCkubG9nKCdhZGROb2RlJyxpbmRleCk7XG5cdFx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KE5PREVUWVBFKTtcblx0XHRcdFxuXHRcdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRcdGlmIChhZnRlci5uZXh0U2libGluZykge1xuXHRcdFx0XHRcdGFmdGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLGFmdGVyLm5leHRTaWJsaW5nKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhZnRlci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0YWZ0ZXIucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmVudCkge1xuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0bm9kZXMuc3BsaWNlKGluZGV4LDAsZWwpO1xuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHJlbW92ZU5vZGUgPSBmdW5jdGlvbihub2RlcyxpbmRleCkge1xuXHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coJ3JlbW92ZU5vZGUnLGluZGV4KTtcblx0XHRcdHZhciBlbCA9IG5vZGVzW2luZGV4XTtcblx0XHRcdGlmIChlbCAmJiBlbC5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBub2Rlcy5zcGxpY2UoaW5kZXgsMSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBsb29wIHRocm91Z2ggdG8gc2V0IHRoZSBsb2NhdGlvbnMgb2YgdGhlIG5vZGVzXG5cdFx0dmFyIG5sb2MgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIG5vZGUxOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdG5vZGUxID0gYXJ5W2ldO1xuXHRcdFx0bm9kZTEuX2xvYyA9IG5sb2M7XG5cdFx0XHRubG9jICs9IChub2RlMS5fbGVuID0gbm9kZTEudGV4dENvbnRlbnQubGVuZ3RoKTtcblx0XHR9O1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0b2tlbnMpLCBsZW4gPSBhcnkubGVuZ3RoLCB0b2s7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dG9rID0gYXJ5W2ldO1xuXHRcdFx0bm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0dmFyIHRsb2MgPSB0b2suX2xvYztcblx0XHRcdG5sb2MgPSBub2RlICYmIG5vZGUuX2xvYztcblx0XHRcdFxuXHRcdFx0d2hpbGUgKG5vZGUgJiYgbm9kZS5fbGVuID09IDApe1xuXHRcdFx0XHRzZWxmLmxvZ2dlcigpLmxvZygncmVtb3ZlIG5vZGUgYmVjYXVzZSBpdCBpcyBlbXB0eScsbm9kZSk7XG5cdFx0XHRcdHJlbW92ZU5vZGUobm9kZXMsaSk7XG5cdFx0XHRcdG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICghbm9kZSkge1xuXHRcdFx0XHQvLyBuZWVkIHRvIGluc2VydCBuZXcgbm9kZSBoZXJlIC0gXG5cdFx0XHRcdG5vZGUgPSBhZGROb2RlKG5vZGVzLGkscHJldk5vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChubG9jID4gdGxvYykge1xuXHRcdFx0XHRub2RlID0gYWRkTm9kZShub2RlcyxpLHByZXZOb2RlKTtcblx0XHRcdH0gZWxzZSBpZiAodGxvYyA+IG5sb2MpIHtcblx0XHRcdFx0cmVtb3ZlTm9kZShub2RlcyxpKTtcblx0XHRcdFx0bm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbmVlZCB0byBpbnNlcnQgbmV3IG5vZGUgaGVyZSAtIFxuXHRcdFx0aWYgKCFub2RlKSB7IG5vZGUgPSBhZGROb2RlKG5vZGVzLGkscHJldk5vZGUpIH07XG5cdFx0XHRcblx0XHRcdGlmICh0b2suX3R5cGUgPT0gJ1NUUklORycgJiYgdG9rLl92YWx1ZS5tYXRjaCgvXFzCp3szfS8pKSB7XG5cdFx0XHRcdGlmIChuZXN0ZWQpIHtcblx0XHRcdFx0XHRuZXN0ZWQucG9wKCk7IC8vIHRoaXMgaXMgdGhlIG5vZGVcblx0XHRcdFx0XHRwcmV2Tm9kZSA9IG5vZGU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyB3YW50IHRvIG1ha2Ugc3VyZSBpdCBpcyBhIHBsYWNlaG9sZGVyIGZvciB0aGUgcmlnaHQgdGhpbmdcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBjdmFsID0gY29kZS5zdWJzdHIodGxvYyx0b2suX2xlbik7XG5cdFx0XHR2YXIgY3ByZXYgPSBub2RlLnRleHRDb250ZW50O1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBzZWxmLnJlY2xhc3NpZnkobm9kZSx0b2suX3R5cGUsdG9rLGN2YWwsY3ByZXYpO1xuXHRcdFx0XG5cdFx0XHRpZiAodG9rLl9jaGlsZHJlbikge1xuXHRcdFx0XHR2YXIgY25vZGVzID0gbm9kZS5jaGlsZHJlbjtcblx0XHRcdFx0aWYgKGNub2Rlcy5sZW5ndGggJiYgY25vZGVzLmxlbmd0aCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coJ3JldXNlIHRoZSBjbm9kZXMoISknLGNub2Rlcyk7XG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNob3VsZCByZW1vdmUgdGhlIHRleHROb2Rlcz9cblx0XHRcdFx0XHQvLyBjb252ZXJ0IHRvIGFycmF5XG5cdFx0XHRcdFx0Y25vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY25vZGVzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmxvZ2dlcigpLmxvZygnd3JvbmcgbGVuZ3RoJyk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGl0ZW1zID0gaXRlciQobm9kZS5jaGlsZE5vZGVzKSwgbGVuXyA9IGl0ZW1zLmxlbmd0aDsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coaXRlbXNbal0pO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gc2VlIGlmIHByZXZpb3VzIHZhbHVlIGlzIHRoZSBzYW1lPyFcblx0XHRcdFx0XHRub2RlLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRcdGNub2RlcyA9IFtdO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gbGV0IG8gPVxuXHRcdFx0XHQvLyBcdGNvZGU6IGN2YWxcblx0XHRcdFx0Ly8gXHRub2RlczogY25vZGVzXG5cdFx0XHRcdC8vIFx0dG9rZW5zOiB0b2suQGNoaWxkcmVuICMgYWxyZWFkeSBwYXJzZWRcblx0XHRcdFx0Ly8gXHRuZXN0ZWQ6IG5lc3RlZFxuXHRcdFx0XHQvLyBcdHBhcmVudDogbm9kZVxuXHRcdFx0XHRcblx0XHRcdFx0c2VsZi5hcHBseVRva2VucyhjdmFsLHRvay5fY2hpbGRyZW4sY25vZGVzLG5lc3RlZCxub2RlKTtcblx0XHRcdH0gZWxzZSBpZiAoY3ByZXYgIT0gY3ZhbCkge1xuXHRcdFx0XHRub2RlLnRleHRDb250ZW50ID0gY3ZhbDsgLy8gdG9rLkB2YWx1ZVxuXHRcdFx0XHRlbGVtZW50LnJlcGFyc2VkKGN2YWwsY3ByZXYpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cHJldk5vZGUgPSBub2RlO1xuXHRcdFx0Ly8gdG9rLkBsZW5cblx0XHR9O1xuXHRcdFxuXHRcdC8vIGxvb3AgdGhyb3VnaCB0b2tlbnM/IG5vdCBzdXJlIGl0IHdvcmtzIGR1ZSB0byB0aGUgaXNzdWVzIHdpdGggd2hpdGVzcGFjZT9cblx0XHRcblx0XHQvLyByZW1vdmUgZXhjZXNzIG9yaWdpbmFsIG5vZGVzXG5cdFx0d2hpbGUgKG5vZGVzLmxlbmd0aCA+IHRva2Vucy5sZW5ndGgpe1xuXHRcdFx0bm9kZSA9IG5vZGVzLnBvcCgpO1xuXHRcdFx0aWYgKG5vZGUucGFyZW50Tm9kZSkgeyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgfTtcblx0XHRcdC8vIG5vZGUub3JwaGFuaXplXG5cdFx0fTtcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdC8vIHNob3VsZCBsYXRlciBiZSBhYmxlIHRvIHJlaGlnaGxpZ2h0IHRoZSB0ZXh0IC8gbm9kZXMgZGlyZWN0bHkgaW5zdGVhZFxuXHQvLyBwcm9iYWJseSBtb3JlIGVmZmljaWVudFxuXHRIaWdobGlnaHRlci5oaWdobGlnaHQgPSBmdW5jdGlvbiAoY29kZSxvKXtcblx0XHQvLyBmaXJzdCB0cnkgdG8gcGFyc2UgZXRjP1xuXHRcdC8vIGNvdWxkIGhpZ2hsaWdodCBzaW5nbGUgd29yZHMgYXMgd2VsbFxuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdG8uaGwgfHwgKG8uaGwgPSBobG8pO1xuXHRcdHZhciB0b2tlbnMgPSBvLnRva2VucyB8fCBudWxsO1xuXHRcdFxuXHRcdGlmICghdG9rZW5zKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBzdXJlIHdlIGRvbnQgd2FudCB0byByZXdyaXRlIGFueXRoaW5nIG5vdz9cblx0XHRcdFx0aWYgKERFQlVHKSB7IGNvbnNvbGUudGltZSgndG9rZW5pemUnKSB9O1xuXHRcdFx0XHRpZiAoby5tb2RlID09ICdmdWxsJykge1xuXHRcdFx0XHRcdHRva2VucyA9IHRoaXMudG9rZW5pemUoY29kZSx7fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG9rZW5zID0gdGhpcy50b2tlbml6ZShjb2RlLHtpbmxpbmU6IHRydWUsc2lsZW50OiB0cnVlLHJld3JpdGU6IGZhbHNlfSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChERUJVRykgeyBjb25zb2xlLnRpbWVFbmQoJ3Rva2VuaXplJykgfTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aWYgKGUuX29wdGlvbnMpIHsgdG9rZW5zID0gZS5fb3B0aW9ucy50b2tlbnMgfTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgaGwgPSBuZXcgdGhpcyhjb2RlLHRva2VucyxudWxsLG8pO1xuXHRcdHJldHVybiBobC5wcm9jZXNzKCk7XG5cdH07XG5cdFxuXHRcblx0XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9vcHRpb25zOyB9XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24odil7IHRoaXMuX29wdGlvbnMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS52YXJSZWYgPSBmdW5jdGlvbiAodmFyaWFibGUpe1xuXHRcdHZhciAkMTtcblx0XHR2YXIgaSA9IHRoaXMuX29wdGlvbnMubmVzdGVkO1xuXHRcdHZhciBwZnggPSBpID8gKCdpJykgOiAoJycpO1xuXHRcdHJldHVybiB0aGlzLl92YXJSZWZzWygkMSA9IHZhcmlhYmxlLl9yZWYpXSB8fCAodGhpcy5fdmFyUmVmc1skMV0gPSAocGZ4ICsgdGhpcy5fb3B0aW9ucy5uZXh0VmFyQ291bnRlcisrKSk7XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci5wcm90b3R5cGUucGFyc2VXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdC8vIHBhcnNpbmcgY29tbWVudHNcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGhsID0gdGhpcy5fb3B0aW9ucy5obDtcblx0XHR2YXIgY29tbWVudHMgPSBbXTtcblx0XHRcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXFwjKShbXlxcbl0qKS9nLGZ1bmN0aW9uKG0scyxxKSB7XG5cdFx0XHRpZiAoc2VsZi5fb3B0aW9ucy5yZW5kZXIuY29tbWVudCkge1xuXHRcdFx0XHRtID0gc2VsZi5fb3B0aW9ucy5yZW5kZXIuY29tbWVudCgnY29tbWVudCcsbSk7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIG5yID0gY29tbWVudHMucHVzaCgoXCI8XCIgKyBOT0RFVFlQRSArIFwiIGNsYXNzPSdfaW0gX2ltY29tbWVudCc+XCIgKyBtICsgXCI8L1wiICsgTk9ERVRZUEUgKyBcIj5cIikpO1xuXHRcdFx0cmV0dXJuIChcIiRcIiArIChuciAtIDEpICsgXCIkXCIpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyhcXG58WyBdK3xbXFx0XSspL2csZnVuY3Rpb24obSxsKSB7XG5cdFx0XHRpZiAobCA9PSAnXFxuJykge1xuXHRcdFx0XHRyZXR1cm4gaGwubmV3bGluZSB8fCAnXFxuJztcblx0XHRcdH0gZWxzZSBpZiAobFswXSA9PSAnICcpIHtcblx0XHRcdFx0cmV0dXJuIGhsLnNwYWNlIGluc3RhbmNlb2YgRnVuY3Rpb24gPyAoaGwuc3BhY2UobCkpIDogKGwpO1xuXHRcdFx0fSBlbHNlIGlmIChsWzBdID09ICdcXHQnKSB7XG5cdFx0XHRcdHJldHVybiBobC50YWIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChobC50YWIobCkpIDogKGwpO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRcblx0XHRpZiAoY29tbWVudHMubGVuZ3RoKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXCQoXFxkKylcXCQvZyxmdW5jdGlvbihtLG5yKSB7XG5cdFx0XHRcdHJldHVybiBjb21tZW50c1twYXJzZUludChucildO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRvaztcblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucygpO1xuXHRcdFxuXHRcdHZhciBzdHIgPSB0aGlzLl9jb2RlO1xuXHRcdHZhciBwb3MgPSB0aGlzLl90b2tlbnMubGVuZ3RoO1xuXHRcdFxuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciBkZXB0aCA9IDA7XG5cdFx0dmFyIGNvbnRleHQgPSBudWxsO1xuXHRcdFxuXHRcdHZhciBwdXNoID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRzdGFjay5wdXNoKGN0eCk7XG5cdFx0XHRkZXB0aCA9IHN0YWNrLmxlbmd0aDtcblx0XHRcdHJldHVybiBjb250ZXh0ID0gc3RhY2tbZGVwdGggLSAxXTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBwb3AgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0ZGVwdGggPSBzdGFjay5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gY29udGV4dCA9IHN0YWNrW2RlcHRoIC0gMV07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5fYXN0ICYmIHRoaXMuX2FzdC5hbmFseXplKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9hc3QuYW5hbHl6ZSh7fSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG51bGw7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHJlcyA9IFwiXCI7XG5cdFx0cG9zID0gMDtcblx0XHR2YXIgY2FyZXQgPSAwO1xuXHRcdFxuXHRcdHZhciBvcGVuLGNsb3NlO1xuXHRcdFxuXHRcdHdoaWxlICh0b2sgPSB0aGlzLl90b2tlbnNbcG9zKytdKXtcblx0XHRcdHZhciBuZXh0ID0gdGhpcy5fdG9rZW5zW3Bvc107XG5cdFx0XHRcblx0XHRcdGlmIChjbG9zZSkge1xuXHRcdFx0XHRpZiAoIShvLmlubmVyICYmIGRlcHRoID09IDEpKSB7IHJlcyArPSAoXCI8L1wiICsgTk9ERVRZUEUgKyBcIj5cIikgfTtcblx0XHRcdFx0Y2xvc2UgPSBudWxsO1xuXHRcdFx0XHRwb3AoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciB0eXAgPSB0b2suX3R5cGUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciBsb2MgPSB0b2suX2xvYztcblx0XHRcdHZhciB2YWwgPSB0b2suX3ZhbHVlO1xuXHRcdFx0dmFyIGxlbiA9IHRvay5fbGVuOyAvLyBvciB0b2suQHZhbHVlOmxlbmd0aFxuXHRcdFx0dmFyIG1ldGEgPSB0b2suX21ldGE7XG5cdFx0XHR2YXIgYXR0cnMgPSAnJztcblx0XHRcdFxuXHRcdFx0aWYgKGxvYyA+IGNhcmV0KSB7XG5cdFx0XHRcdHZhciBhZGQgPSBzdHIuc3Vic3RyaW5nKGNhcmV0LGxvYyk7XG5cdFx0XHRcdGlmIChjb250ZXh0ICE9IElOVEVSUE9MQVRJTkcpIHsgYWRkID0gdGhpcy5wYXJzZVdoaXRlc3BhY2UoYWRkKSB9O1xuXHRcdFx0XHRyZXMgKz0gYWRkO1xuXHRcdFx0XHRjYXJldCA9IGxvYztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNsb3NlID0gQ0xPU0VbdHlwXTtcblx0XHRcdFxuXHRcdFx0aWYgKG9wZW4gPSBPUEVOW3R5cF0pIHtcblx0XHRcdFx0Ly8gb3BlbiA9IE9QRU5bdmFsXSB8fCBvcGVuXG5cdFx0XHRcdHB1c2gob3Blbik7XG5cdFx0XHRcdGlmICghKG8uaW5uZXIgJiYgZGVwdGggPT0gMSkpIHsgcmVzICs9IChcIjxcIiArIE5PREVUWVBFICsgXCIgY2xhc3M9J1wiICsgb3BlbiArIFwiJz5cIikgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChsZW4gPT0gMCB8fCB0eXAgPT0gJ3Rlcm1pbmF0b3InIHx8IHR5cCA9PSAnaW5kZW50JyB8fCB0eXAgPT0gJ291dGRlbnQnKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvay5fY29sID09IC0xICYmIHRvay5fbG9jIDw9IDApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbm9kZSA9IE5PREVUWVBFO1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBzdHIuc3Vic3RyKGxvYyxsZW4pO1xuXHRcdFx0Ly8gdGVtcG9yYXJ5IHdvcmthcm91bmQgdW50aWwgd2UgcmVkZWZpbmUgcmVxdWlyZSBhcyBhbiBpZGVudGlmaWVyXG5cdFx0XHRpZiAodHlwID09ICdjb25zdCcgJiYgY29udGVudCA9PSAncmVxdWlyZScpIHtcblx0XHRcdFx0dHlwID0gJ3JlcXVpcmUnO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHR2YXIgY2xzID0gY2xhc3Nlc1t0eXBdIHx8IHR5cDtcblx0XHRcdFxuXHRcdFx0aWYgKGNscyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdG5vZGUgPSBjbHNbMF07XG5cdFx0XHRcdGNscyA9IGNsc1sxXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNscyA9IGNscy5zcGxpdChcIiBcIik7XG5cdFx0XHRcblx0XHRcdGlmIChLRVlXT1JEUy5pbmRleE9mKHR5cCkgPj0gMCkge1xuXHRcdFx0XHRjbHMudW5zaGlmdCgna2V5d29yZCcpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y2FyZXQgPSBsb2MgKyBsZW47XG5cdFx0XHRcblx0XHRcdGlmICh0eXAgPT0gJ2lkZW50aWZpZXInKSB7XG5cdFx0XHRcdGlmIChjb250ZW50WzBdID09ICcjJykge1xuXHRcdFx0XHRcdGNscy5wdXNoKCdpZHJlZicpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG1ldGEpIHtcblx0XHRcdFx0XHRpZiAobWV0YS50eXBlID09ICdBQ0NFU1MnKSB7IGNscy5wdXNoKCdhY2Nlc3MnKSB9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNvbnRlbnQgPT0gJ2xvZycpIHtcblx0XHRcdFx0XHRjbHMucHVzaCgnbG9nJyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodG9rLl92YXJpYWJsZSkge1xuXHRcdFx0XHRcblx0XHRcdFx0Y2xzLnB1c2goJ2x2YXInKTtcblx0XHRcdFx0dmFyIHJlZiA9IHRoaXMudmFyUmVmKHRvay5fdmFyaWFibGUpO1xuXHRcdFx0XHRhdHRycyArPSAoXCIgZXJlZj0ndlwiICsgcmVmICsgXCInXCIpO1xuXHRcdFx0XHQvLyBjbHMucHVzaChcInJlZi1cIityZWYpXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwID09ICdoZXJlY29tbWVudCcpIHtcblx0XHRcdFx0dmFyIGVuZCA9IChcIjxcIiArIE5PREVUWVBFICsgXCI+IyMjPC9cIiArIE5PREVUWVBFICsgXCI+XCIpO1xuXHRcdFx0XHRjb250ZW50ID0gZW5kICsgY29udGVudC5zbGljZSgzLC0zKSArIGVuZDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0eXAgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYgKGNvbnRlbnQubWF0Y2goL15bJ1wiXT9cXC4/XFwuXFwvLykpIHsgY2xzLnB1c2goJ3BhdGhuYW1lJykgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBjbHN0ciA9IGNscy5qb2luKFwiIFwiKTtcblx0XHRcdGlmICghY2xzdHIubWF0Y2goL1xcYlxcXy8pKSB7IGNsc3RyID0gJ19pbXRvayAnICsgY2xzdHIgfTtcblx0XHRcdHJlcyArPSAoXCI8XCIgKyBub2RlICsgXCIgY2xhc3M9J1wiICsgY2xzdHIgKyBcIidcIikgKyBhdHRycyArIFwiPlwiICsgY29udGVudCArIChcIjwvXCIgKyBub2RlICsgXCI+XCIpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY2xvc2UgYWZ0ZXI/XG5cdFx0aWYgKGNsb3NlKSB7XG5cdFx0XHRyZXMgKz0gKFwiPC9cIiArIE5PREVUWVBFICsgXCI+XCIpO1xuXHRcdFx0Y2xvc2UgPSBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGNhcmV0IDwgc3RyLmxlbmd0aCAtIDEpIHtcblx0XHRcdGFkZCA9IHN0ci5zbGljZShjYXJldCk7XG5cdFx0XHRpZiAoY29udGV4dCAhPSBJTlRFUlBPTEFUSU5HKSB7IGFkZCA9IHRoaXMucGFyc2VXaGl0ZXNwYWNlKGFkZCkgfTtcblx0XHRcdHJlcyArPSBhZGQ7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5fdG9rZW5zLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXMgPSB0aGlzLl9jb2RlO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHJlcztcblx0fTtcblx0cmV0dXJuIEhpZ2hsaWdodGVyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9oaWdobGlnaHRlci5pbWJhXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdC8vIGhlbHBlciBmb3Igc3ViY2xhc3Npbmdcblx0ZnVuY3Rpb24gc3ViY2xhc3MkKG9iaixzdXApIHtcblx0XHRmb3IgKHZhciBrIGluIHN1cCkge1xuXHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgb2JqW2tdID0gc3VwW2tdO1xuXHRcdH07XG5cdFx0Ly8gb2JqLl9fc3VwZXJfXyA9IHN1cDtcblx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xuXHRcdG9iai5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmo7XG5cdH07XG5cdFxuXHR2YXIgQUxMX0tFWVdPUkRTO1xuXHRcblx0dmFyIFQgPSByZXF1aXJlKCcuL3Rva2VuJyk7XG5cdHZhciBUb2tlbiA9IFQuVG9rZW47XG5cdFxuXHR2YXIgcncgPSByZXF1aXJlKCcuL3Jld3JpdGVyJyk7XG5cdHZhciBSZXdyaXRlciA9IHJ3LlJld3JpdGVyO1xuXHR2YXIgSU5WRVJTRVMgPSBydy5JTlZFUlNFUztcblx0XG5cdHZhciBLID0gMDtcblx0XG5cdHZhciBFUlIgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXHRcblx0Ly8gQ29uc3RhbnRzXG5cdC8vIC0tLS0tLS0tLVxuXHRcblx0Ly8gS2V5d29yZHMgdGhhdCBJbWJhIHNoYXJlcyBpbiBjb21tb24gd2l0aCBKYXZhU2NyaXB0LlxuXHR2YXIgSlNfS0VZV09SRFMgPSBbXG5cdFx0J3RydWUnLCdmYWxzZScsJ251bGwnLCd0aGlzJyxcblx0XHQnZGVsZXRlJywndHlwZW9mJywnaW4nLCdpbnN0YW5jZW9mJyxcblx0XHQndGhyb3cnLCdicmVhaycsJ2NvbnRpbnVlJywnZGVidWdnZXInLFxuXHRcdCdpZicsJ2Vsc2UnLCdzd2l0Y2gnLCdmb3InLCd3aGlsZScsJ2RvJywndHJ5JywnY2F0Y2gnLCdmaW5hbGx5Jyxcblx0XHQnY2xhc3MnLCdleHRlbmRzJywnc3VwZXInLCdyZXR1cm4nXG5cdF07XG5cdFxuXHQvLyBuZXcgY2FuIGJlIHVzZWQgYXMgYSBrZXl3b3JkIGluIGltYmEsIHNpbmNlIG9iamVjdCBpbml0aW5nIGlzIGRvbmUgdGhyb3VnaFxuXHQvLyBNeU9iamVjdC5uZXcuIG5ldyBpcyBhIHZlcnkgdXNlZnVsIHZhcm5hbWUuXG5cdFxuXHQvLyBXZSB3YW50IHRvIHRyZWF0IHJldHVybiBsaWtlIGFueSByZWd1bGFyIGNhbGwgZm9yIG5vd1xuXHQvLyBNdXN0IGJlIGNhcmVmdWwgdG8gdGhyb3cgdGhlIGV4Y2VwdGlvbnMgaW4gQVNULCBzaW5jZSB0aGUgcGFyc2VyXG5cdC8vIHdvbnRcblx0XG5cdC8vIEltYmEtb25seSBrZXl3b3Jkcy4gdmFyIHNob3VsZCBtb3ZlIHRvIEpTX0tleXdvcmRzXG5cdC8vIHNvbWUgd29yZHMgKGxpa2UgdG9raWQpIHNob3VsZCBiZSBjb250ZXh0LXNwZWNpZmljXG5cdHZhciBJTUJBX0tFWVdPUkRTID0gW1xuXHRcdCd1bmRlZmluZWQnLCd0aGVuJywndW5sZXNzJywndW50aWwnLCdsb29wJywnb2YnLCdieScsXG5cdFx0J3doZW4nLCdkZWYnLCd0YWcnLCdkbycsJ2VsaWYnLCdiZWdpbicsJ3ZhcicsJ2xldCcsJ3NlbGYnLCdhd2FpdCcsJ2ltcG9ydCdcblx0XTtcblx0XG5cdHZhciBJTUJBX0NPTlRFWFRVQUxfS0VZV09SRFMgPSBbJ2V4dGVuZCcsJ3N0YXRpYycsJ2xvY2FsJywnZXhwb3J0JywnZ2xvYmFsJywncHJvcCddO1xuXHRcblx0dmFyIElNQkFfQUxJQVNfTUFQID0ge1xuXHRcdCdhbmQnOiAnJiYnLFxuXHRcdCdvcic6ICd8fCcsXG5cdFx0J2lzJzogJz09Jyxcblx0XHQnaXNudCc6ICchPScsXG5cdFx0J25vdCc6ICchJyxcblx0XHQneWVzJzogJ3RydWUnLFxuXHRcdCdubyc6ICdmYWxzZScsXG5cdFx0J2lzYSc6ICdpbnN0YW5jZW9mJyxcblx0XHQnY2FzZSc6ICdzd2l0Y2gnLFxuXHRcdCduaWwnOiAnbnVsbCdcblx0fTtcblx0XG5cdHZhciBJTUJBX0FMSUFTRVMgPSBPYmplY3Qua2V5cyhJTUJBX0FMSUFTX01BUCk7XG5cdElNQkFfS0VZV09SRFMgPSBJTUJBX0tFWVdPUkRTLmNvbmNhdChJTUJBX0FMSUFTRVMpO1xuXHRcblx0Ly8gRml4ZWRBcnJheSBmb3IgcGVyZm9ybWFuY2Vcblx0Ly8gdmFyIEFMTF9LRVlXT1JEUyA9IEpTX0tFWVdPUkRTLmNvbmNhdChJTUJBX0tFWVdPUkRTKVxuXHRtb2R1bGUuZXhwb3J0cy5BTExfS0VZV09SRFMgPSBBTExfS0VZV09SRFMgPSBbXG5cdFx0J3RydWUnLCdmYWxzZScsJ251bGwnLCd0aGlzJyxcblx0XHQnZGVsZXRlJywndHlwZW9mJywnaW4nLCdpbnN0YW5jZW9mJyxcblx0XHQndGhyb3cnLCdicmVhaycsJ2NvbnRpbnVlJywnZGVidWdnZXInLFxuXHRcdCdpZicsJ2Vsc2UnLCdzd2l0Y2gnLCdmb3InLCd3aGlsZScsJ2RvJywndHJ5JywnY2F0Y2gnLCdmaW5hbGx5Jyxcblx0XHQnY2xhc3MnLCdleHRlbmRzJywnc3VwZXInLCdyZXR1cm4nLFxuXHRcdCd1bmRlZmluZWQnLCd0aGVuJywndW5sZXNzJywndW50aWwnLCdsb29wJywnb2YnLCdieScsXG5cdFx0J3doZW4nLCdkZWYnLCd0YWcnLCdkbycsJ2VsaWYnLCdiZWdpbicsJ3ZhcicsJ2xldCcsJ3NlbGYnLCdhd2FpdCcsJ2ltcG9ydCcsXG5cdFx0J2FuZCcsJ29yJywnaXMnLCdpc250Jywnbm90JywneWVzJywnbm8nLCdpc2EnLCdjYXNlJywnbmlsJ1xuXHRdO1xuXHRcblx0Ly8gVGhlIGxpc3Qgb2Yga2V5d29yZHMgdGhhdCBhcmUgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdCwgYnV0IG5vdCB1c2VkLCBvciBhcmVcblx0Ly8gdXNlZCBieSBJbWJhIGludGVybmFsbHkuIFdlIHRocm93IGFuIGVycm9yIHdoZW4gdGhlc2UgYXJlIGVuY291bnRlcmVkLFxuXHQvLyB0byBhdm9pZCBoYXZpbmcgYSBKYXZhU2NyaXB0IGVycm9yIGF0IHJ1bnRpbWUuICAjICd2YXInLCAnbGV0JywgLSBub3QgaW5zaWRlIGhlcmVcblx0dmFyIFJFU0VSVkVEID0gWydjYXNlJywnZGVmYXVsdCcsJ2Z1bmN0aW9uJywndm9pZCcsJ3dpdGgnLCdjb25zdCcsJ2VudW0nLCduYXRpdmUnXTtcblx0dmFyIFNUUklDVF9SRVNFUlZFRCA9IFsnY2FzZScsJ2Z1bmN0aW9uJywndm9pZCcsJ2NvbnN0J107XG5cdFxuXHQvLyBUaGUgc3VwZXJzZXQgb2YgYm90aCBKYXZhU2NyaXB0IGtleXdvcmRzIGFuZCByZXNlcnZlZCB3b3Jkcywgbm9uZSBvZiB3aGljaCBtYXlcblx0Ly8gYmUgdXNlZCBhcyBpZGVudGlmaWVycyBvciBwcm9wZXJ0aWVzLlxuXHR2YXIgSlNfRk9SQklEREVOID0gSlNfS0VZV09SRFMuY29uY2F0KFJFU0VSVkVEKTtcblx0XG5cdHZhciBNRVRIT0RfSURFTlRJRklFUiA9IC9eKCgoW1xceDIzXT9bXFwkQS1aYS16X1xceDdmLVxcdWZmZmZdWyRcXC1cXHdcXHg3Zi1cXHVmZmZmXSopKFtcXD1dPykpfCg8PT58XFx8KD8hW1xcfD1dKSkpLztcblx0Ly8gcmVtb3ZlZCB+PXx+fCB8Jig/IVsmPV0pXG5cdFxuXHQvLyBUb2tlbiBtYXRjaGluZyByZWdleGVzLlxuXHQvLyBhZGRlZCBoeXBoZW5zIHRvIGlkZW50aWZpZXJzIG5vdyAtIHRvIHRlc3Rcblx0dmFyIElERU5USUZJRVIgPSAvXigoXFwkfEBAfEB8XFwjKVtcXHdBLVphLXpfXFwtXFx4N2YtXFx1ZmZmZl1bJFxcd1xceDdmLVxcdWZmZmZdKihcXC1bJFxcd1xceDdmLVxcdWZmZmZdKykqfFskQS1aYS16X11bJFxcd1xceDdmLVxcdWZmZmZdKihcXC1bJFxcd1xceDdmLVxcdWZmZmZdKykqKShbXlxcblxcU10qOig/IVtcXCpcXD06JFxcd1xceDdmLVxcdWZmZmZdKSk/Lztcblx0XG5cdHZhciBPQkpFQ1RfS0VZID0gL14oKFxcJHxAQHxAfClbJEEtWmEtel9cXHg3Zi1cXHVmZmZmXFwtXVskXFx3XFx4N2YtXFx1ZmZmZlxcLV0qKShbXlxcblxcU1xcc10qOig/IVtcXCpcXD06JFxcd1xceDdmLVxcdWZmZmZdKSkvO1xuXHRcblx0dmFyIFRBRyA9IC9eKFxcPHwlKSg/PVtBLVphLXpcXCNcXC5cXHtcXEBcXD5dKS87XG5cdFxuXHR2YXIgVEFHX1RZUEUgPSAvXihcXHdbXFx3XFxkXSo6KT8oXFx3W1xcd1xcZF0qKSgtW1xcd1xcZF0rKSovO1xuXHR2YXIgVEFHX0lEID0gL14jKChcXHdbXFx3XFxkXSopKC1bXFx3XFxkXSspKikvO1xuXHRcblx0dmFyIFRBR19BVFRSID0gL14oW1xcLlxcOl0/W1xcd1xcX10rKFtcXC1cXDpdW1xcd10rKSopKFxccykqXFw9Lztcblx0XG5cdHZhciBTRUxFQ1RPUiA9IC9eKFslXFwkXXsxLDJ9KShbXFwoXFx3XFwjXFwuXFxbXSkvO1xuXHR2YXIgU0VMRUNUT1JfUEFSVCA9IC9eKFxcI3xcXC58Onw6Oik/KFtcXHddKyhcXC1bXFx3XSspKikvO1xuXHR2YXIgU0VMRUNUT1JfQ09NQklOQVRPUiA9IC9eIChcXCt8XFw+fFxcfikqXFxzKig/PVtcXHdcXC5cXCNcXDpcXHtcXCpcXFtdKS87XG5cdFxuXHR2YXIgU0VMRUNUT1JfUFNFVURPX0NMQVNTID0gL14oOjo/KShbXFx3XSsoXFwtW1xcd10rKSopLztcblx0dmFyIFNFTEVDVE9SX0FUVFJfT1AgPSAvXihcXCQ9fFxcfj18XFxePXxcXCo9fFxcfD18PXxcXCE9KS87XG5cdHZhciBTRUxFQ1RPUl9BVFRSID0gL15cXFsoW1xcd1xcX1xcLV0rKShcXCQ9fFxcfj18XFxePXxcXCo9fFxcfD18PXxcXCE9KS87XG5cdFxuXHR2YXIgU1lNQk9MID0gL15cXDooKChbXFwqXFxAJFxcd1xceDdmLVxcdWZmZmZdKykrKFtcXC1cXFxcL1xcXFxcXDpdW1xcd1xceDdmLVxcdWZmZmZdKykqKXw9PXxcXDw9XFw+fFxcW1xcXXxcXFtcXF1cXD18XFwqfFtcXFxcLyxcXFxcXSkvO1xuXHRcblx0XG5cdHZhciBOVU1CRVIgPSAvXjB4W1xcZGEtZl0rfF4wYlswMV0rfF5cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8vaTtcblx0XG5cdHZhciBIRVJFRE9DID0gL14oXCJcIlwifCcnJykoW1xcc1xcU10qPykoPzpcXG5bXlxcblxcU10qKT9cXDEvO1xuXHRcblx0dmFyIE9QRVJBVE9SID0gL14oPzpbLT1dPT58PT09fC0+fCE9PXxbLSsqXFwvJTw+JnxeIT89XT18PTx8Pj4+PT98KFstKzpdKVxcMXwoWyZ8PD5dKVxcMj0/fFxcP1xcLnxcXD9cXDp8XFwuezIsM318XFwqKD89W2EtekEtWlxcX10pKS87XG5cdFxuXHQvLyBGSVhNRSBzcGxhdCBzaG91bGQgb25seSBiZSBhbGxvd2VkIHdoZW4gdGhlIHByZXZpb3VzIHRoaW5nIGlzIHNwYWNlZCBvciBpbnNpZGUgY2FsbD9cblx0XG5cdHZhciBXSElURVNQQUNFID0gL15bXlxcblxcU10rLztcblx0XG5cdHZhciBDT01NRU5UID0gL14jIyMoW14jXVtcXHNcXFNdKj8pKD86IyMjW15cXG5cXFNdKnwoPzojIyMpPyQpLztcblx0Ly8gQ09NTUVOVCAgICA9IC9eIyMjKFteI11bXFxzXFxTXSo/KSg/OiMjI1teXFxuXFxTXSp8KD86IyMjKT8kKXxeKD86XFxzKigjXFxzLip8I1xccyokKSkrL1xuXHR2YXIgSU5MSU5FX0NPTU1FTlQgPSAvXihcXHMqKSgjWyBcXHRcXCFdKC4qKXwjWyBcXHRdPyg/PVxcbnwkKSkrLztcblx0XG5cdHZhciBDT0RFID0gL15bLT1dPT4vO1xuXHRcblx0dmFyIE1VTFRJX0RFTlQgPSAvXig/OlxcblteXFxuXFxTXSopKy87XG5cdFxuXHR2YXIgU0lNUExFU1RSID0gL14nW15cXFxcJ10qKD86XFxcXC5bXlxcXFwnXSopKicvO1xuXHRcblx0dmFyIEpTVE9LRU4gPSAvXmBbXlxcXFxgXSooPzpcXFxcLlteXFxcXGBdKikqYC87XG5cdFxuXHQvLyBSZWdleC1tYXRjaGluZy1yZWdleGVzLlxuXHR2YXIgUkVHRVggPSAvXihcXC8oPyFbXFxzPV0pW15bXFwvXFxuXFxcXF0qKD86KD86XFxcXFtcXHNcXFNdfFxcW1teXFxdXFxuXFxcXF0qKD86XFxcXFtcXHNcXFNdW15cXF1cXG5cXFxcXSopKl0pW15bXFwvXFxuXFxcXF0qKSpcXC8pKFtpbWd5XXswLDR9KSg/IVxcdykvO1xuXHRcblx0dmFyIEhFUkVHRVggPSAvXlxcL3szfShbXFxzXFxTXSs/KVxcL3szfShbaW1neV17MCw0fSkoPyFcXHcpLztcblx0XG5cdHZhciBIRVJFR0VYX09NSVQgPSAvXFxzKyg/OiMuKik/L2c7XG5cdFxuXHQvLyBUb2tlbiBjbGVhbmluZyByZWdleGVzLlxuXHR2YXIgTVVMVElMSU5FUiA9IC9cXG4vZztcblx0XG5cdHZhciBIRVJFRE9DX0lOREVOVCA9IC9cXG4rKFteXFxuXFxTXSopL2c7XG5cdFxuXHR2YXIgSEVSRURPQ19JTExFR0FMID0gL1xcKlxcLy87XG5cdFxuXHQvLyBleHBlbnNpdmU/XG5cdHZhciBMSU5FX0NPTlRJTlVFUiA9IC9eXFxzKig/Oix8XFw/P1xcLig/IVsuXFxkXSl8OjopLztcblx0XG5cdHZhciBUUkFJTElOR19TUEFDRVMgPSAvXFxzKyQvO1xuXHRcblx0dmFyIENPTlNUX0lERU5USUZJRVIgPSAvXltBLVpdLztcblx0XG5cdHZhciBBUkdWQVIgPSAvXlxcJFxcZCQvO1xuXHRcblx0Ly8gQ29tcG91bmQgYXNzaWdubWVudCB0b2tlbnMuXG5cdHZhciBDT01QT1VORF9BU1NJR04gPSBbJy09JywnKz0nLCcvPScsJyo9JywnJT0nLCd8fD0nLCcmJj0nLCc/PScsJzw8PScsJz4+PScsJz4+Pj0nLCcmPScsJ149JywnfD0nLCc9PCddO1xuXHRcblx0Ly8gVW5hcnkgdG9rZW5zLlxuXHR2YXIgVU5BUlkgPSBbJyEnLCd+JywnTkVXJywnVFlQRU9GJywnREVMRVRFJ107XG5cdFxuXHQvLyBMb2dpY2FsIHRva2Vucy5cblx0dmFyIExPR0lDID0gWycmJicsJ3x8JywnJicsJ3wnLCdeJ107XG5cdFxuXHQvLyBCaXQtc2hpZnRpbmcgdG9rZW5zLlxuXHR2YXIgU0hJRlQgPSBbJzw8JywnPj4nLCc+Pj4nXTtcblx0XG5cdC8vIENvbXBhcmlzb24gdG9rZW5zLlxuXHR2YXIgQ09NUEFSRSA9IFsnPT09JywnIT09JywnPT0nLCchPScsJzwnLCc+JywnPD0nLCc+PScsJz09PScsJyE9PSddO1xuXHRcblx0Ly8gT3ZlcmlkZWFibGUgbWV0aG9kc1xuXHR2YXIgT1BfTUVUSE9EUyA9IFsnPD0+JywnPDwnLCcuLiddO1xuXHRcblx0Ly8gTWF0aGVtYXRpY2FsIHRva2Vucy5cblx0dmFyIE1BVEggPSBbJyonLCcvJywnJScsJ+KIqicsJ+KIqScsJ+KImiddO1xuXHRcblx0Ly8gUmVsYXRpb25hbCB0b2tlbnMgdGhhdCBhcmUgbmVnYXRhYmxlIHdpdGggYG5vdGAgcHJlZml4LlxuXHR2YXIgUkVMQVRJT04gPSBbJ0lOJywnT0YnLCdJTlNUQU5DRU9GJywnSVNBJ107XG5cdFxuXHQvLyBCb29sZWFuIHRva2Vucy5cblx0dmFyIEJPT0wgPSBbJ1RSVUUnLCdGQUxTRScsJ05VTEwnLCdVTkRFRklORUQnXTtcblx0XG5cdC8vIE91ciBsaXN0IGlzIHNob3J0ZXIsIGR1ZSB0byBzYW5zLXBhcmVudGhlc2VzIG1ldGhvZCBjYWxscy5cblx0dmFyIE5PVF9SRUdFWCA9IFsnTlVNQkVSJywnUkVHRVgnLCdCT09MJywnVFJVRScsJ0ZBTFNFJywnKysnLCctLScsJ10nXTtcblx0XG5cdC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBub3Qgc3BhY2VkLCB0aGVyZSBhcmUgbW9yZSBwcmVjZWRpbmcgdG9rZW5zIHRoYXRcblx0Ly8gZm9yY2UgYSBkaXZpc2lvbiBwYXJzZTpcblx0dmFyIE5PVF9TUEFDRURfUkVHRVggPSBbJ05VTUJFUicsJ1JFR0VYJywnQk9PTCcsJ1RSVUUnLCdGQUxTRScsJysrJywnLS0nLCddJywnKScsJ30nLCdUSElTJywnU0VMRicsJ0lERU5USUZJRVInLCdTVFJJTkcnXTtcblx0XG5cdC8vIFRva2VucyB3aGljaCBjb3VsZCBsZWdpdGltYXRlbHkgYmUgaW52b2tlZCBvciBpbmRleGVkLiBBbiBvcGVuaW5nXG5cdC8vIHBhcmVudGhlc2VzIG9yIGJyYWNrZXQgZm9sbG93aW5nIHRoZXNlIHRva2VucyB3aWxsIGJlIHJlY29yZGVkIGFzIHRoZSBzdGFydFxuXHQvLyBvZiBhIGZ1bmN0aW9uIGludm9jYXRpb24gb3IgaW5kZXhpbmcgb3BlcmF0aW9uLlxuXHQvLyByZWFsbHk/IVxuXHRcblx0dmFyIFVORklOSVNIRUQgPSBbJ1xcXFwnLCcuJywnPy4nLCc/OicsJ1VOQVJZJywnTUFUSCcsJysnLCctJywnU0hJRlQnLCdSRUxBVElPTicsJ0NPTVBBUkUnLCdMT0dJQycsJ0NPTVBPVU5EX0FTU0lHTicsJ1RIUk9XJywnRVhURU5EUyddO1xuXHRcblx0Ly8gfSBzaG91bGQgbm90IGJlIGNhbGxhYmxlIGFueW1vcmUhISEgJ30nLCAnOjonLFxuXHR2YXIgQ0FMTEFCTEUgPSBbJ0lERU5USUZJRVInLCdTVFJJTkcnLCdSRUdFWCcsJyknLCddJywnVEhJUycsJ1NVUEVSJywnVEFHX0VORCcsJ0lWQVInLCdHVkFSJywnU0VMRicsJ0NPTlNUJywnTkVXJywnQVJHVkFSJywnU1lNQk9MJywnUkVUVVJOJ107XG5cdC8vIHZhciBJTkRFWEFCTEUgPSBDQUxMQUJMRS5jb25jYXQgJ05VTUJFUicsICdCT09MJywgJ1RBR19TRUxFQ1RPUicsICdJRFJFRicsICdBUkdVTUVOVFMnLCd9JyAjIGFyZSBib29sZWFucyBpbmRleGFibGU/IHJlYWxseT9cblx0Ly8gb3B0aW1pemUgZm9yIEZpeGVkQXJyYXlcblx0dmFyIElOREVYQUJMRSA9IFtcblx0XHQnSURFTlRJRklFUicsJ1NUUklORycsJ1JFR0VYJywnKScsJ10nLCdUSElTJywnU1VQRVInLCdUQUdfRU5EJywnSVZBUicsJ0dWQVInLCdTRUxGJywnQ09OU1QnLCdORVcnLCdBUkdWQVInLCdTWU1CT0wnLCdSRVRVUk4nLFxuXHRcdCdOVU1CRVInLCdCT09MJywnVEFHX1NFTEVDVE9SJywnSURSRUYnLCdBUkdVTUVOVFMnLCd9JywnVEFHX1RZUEUnXG5cdF07XG5cdFxuXHR2YXIgR0xPQkFMX0lERU5USUZJRVJTID0gWydnbG9iYWwnLCdleHBvcnRzJywncmVxdWlyZSddO1xuXHRcblx0Ly8gVG9rZW5zIHRoYXQsIHdoZW4gaW1tZWRpYXRlbHkgcHJlY2VkaW5nIGEgYFdIRU5gLCBpbmRpY2F0ZSB0aGF0IHRoZSBgV0hFTmBcblx0Ly8gb2NjdXJzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuIFdlIGRpc2FtYmlndWF0ZSB0aGVzZSBmcm9tIHRyYWlsaW5nIHdoZW5zIHRvXG5cdC8vIGF2b2lkIGFuIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hci5cblx0dmFyIExJTkVfQlJFQUsgPSBbJ0lOREVOVCcsJ09VVERFTlQnLCdURVJNSU5BVE9SJ107XG5cdFxuXHRcblx0ZnVuY3Rpb24gTGV4ZXJFcnJvcihtZXNzYWdlLGZpbGUsbGluZSl7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHR0aGlzLmZpbGUgPSBmaWxlO1xuXHRcdHRoaXMubGluZSA9IGxpbmU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHN1YmNsYXNzJChMZXhlckVycm9yLFN5bnRheEVycm9yKTtcblx0ZXhwb3J0cy5MZXhlckVycm9yID0gTGV4ZXJFcnJvcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBsYXN0KGFycmF5LGJhY2spe1xuXHRcdGlmKGJhY2sgPT09IHVuZGVmaW5lZCkgYmFjayA9IDA7XG5cdFx0cmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIGJhY2sgLSAxXTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGNvdW50KHN0cixzdWJzdHIpe1xuXHRcdHJldHVybiBzdHIuc3BsaXQoc3Vic3RyKS5sZW5ndGggLSAxO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gcmVwZWF0U3RyaW5nKHN0cix0aW1lcyl7XG5cdFx0dmFyIHJlcyA9ICcnO1xuXHRcdHdoaWxlICh0aW1lcyA+IDApe1xuXHRcdFx0aWYgKHRpbWVzICUgMiA9PSAxKSB7XG5cdFx0XHRcdHJlcyArPSBzdHI7XG5cdFx0XHR9O1xuXHRcdFx0c3RyICs9IHN0cjtcblx0XHRcdHRpbWVzID4+PSAxO1xuXHRcdH07XG5cdFx0cmV0dXJuIHJlcztcblx0fTtcblx0XG5cdHZhciB0VCA9IFQudHlwO1xuXHR2YXIgdFYgPSBULnZhbDtcblx0dmFyIHRUcyA9IFQuc2V0VHlwO1xuXHR2YXIgdFZzID0gVC5zZXRWYWw7XG5cdFxuXHQvLyBUaGUgTGV4ZXIgY2xhc3MgcmVhZHMgYSBzdHJlYW0gb2YgSW1iYSBhbmQgZGl2dmllcyBpdCB1cCBpbnRvIHRva2lkZ2VkXG5cdC8vIHRva2Vucy4gU29tZSBwb3RlbnRpYWwgYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyIGhhcyBiZWVuIGF2b2lkZWQgYnlcblx0Ly8gcHVzaGluZyBzb21lIGV4dHJhIHNtYXJ0cyBpbnRvIHRoZSBMZXhlci5cblx0XG5cdC8vIEJhc2VkIG9uIHRoZSBvcmlnaW5hbCBsZXhlci5jb2ZmZWUgZnJvbSBDb2ZmZWVTY3JpcHRcblx0ZnVuY3Rpb24gTGV4ZXIoKXtcblx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuTGV4ZXIgPSBMZXhlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRMZXhlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9jb2RlID0gbnVsbDtcblx0XHR0aGlzLl9jaHVuayA9IG51bGw7IC8vIFRoZSByZW1haW5kZXIgb2YgdGhlIHNvdXJjZSBjb2RlLlxuXHRcdHRoaXMuX29wdHMgPSBudWxsO1xuXHRcdFxuXHRcdHRoaXMuX2luZGVudCA9IDA7IC8vIFRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuXHRcdHRoaXMuX2luZGVidCA9IDA7IC8vIFRoZSBvdmVyLWluZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdHRoaXMuX291dGRlYnQgPSAwOyAvLyBUaGUgdW5kZXItb3V0ZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdFxuXHRcdHRoaXMuX2luZGVudHMgPSBbXTsgLy8gVGhlIHN0YWNrIG9mIGFsbCBjdXJyZW50IGluZGVudGF0aW9uIGxldmVscy5cblx0XHR0aGlzLl9lbmRzID0gW107IC8vIFRoZSBzdGFjayBmb3IgcGFpcmluZyB1cCB0b2tlbnMuXG5cdFx0dGhpcy5fY29udGV4dHMgPSBbXTsgLy8gc3VwbGVtZW50cyBAZW5kc1xuXHRcdHRoaXMuX3Njb3BlcyA9IFtdO1xuXHRcdHRoaXMuX25leHRTY29wZSA9IG51bGw7IC8vIHRoZSBzY29wZSB0byBhZGQgb24gdGhlIG5leHQgaW5kZW50XG5cdFx0Ly8gc2hvdWxkIHJhdGhlciBtYWtlIGl0IGxpa2UgYSBzdGF0ZW1hY2hpbmUgdGhhdCBtb3ZlcyBmcm9tIENMQVNTX0RFRiB0byBDTEFTU19CT0RZIGV0Y1xuXHRcdC8vIFRoaW5ncyBzaG91bGQgY29tcGlsZSBkaWZmZXJlbnRseSB3aGVuIHlvdSBhcmUgaW4gYSBDTEFTU19CT0RZIHRoYW4gd2hlbiBpbiBhIERFRl9CT0RZKytcblx0XHRcblx0XHR0aGlzLl90b2tlbnMgPSBbXTsgLy8gU3RyZWFtIG9mIHBhcnNlZCB0b2tlbnMgaW4gdGhlIGZvcm0gYFsnVFlQRScsIHZhbHVlLCBsaW5lXWAuXG5cdFx0dGhpcy5fc2VlbkZvciA9IGZhbHNlO1xuXHRcdHRoaXMuX2xvYyA9IDA7XG5cdFx0dGhpcy5fbG9jT2Zmc2V0ID0gMDtcblx0XHRcblx0XHR0aGlzLl9lbmQgPSBudWxsO1xuXHRcdHRoaXMuX2NoYXIgPSBudWxsO1xuXHRcdHRoaXMuX2JyaWRnZSA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdCA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdFR5cCA9ICcnO1xuXHRcdHRoaXMuX2xhc3RWYWwgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmppc29uQnJpZGdlID0gZnVuY3Rpb24gKGppc29uKXtcblx0XHRyZXR1cm4gdGhpcy5fYnJpZGdlID0ge1xuXHRcdFx0bGV4OiBULmxleCxcblx0XHRcdHNldElucHV0OiBmdW5jdGlvbih0b2tlbnMpIHtcblx0XHRcdFx0dGhpcy50b2tlbnMgPSB0b2tlbnM7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBvcyA9IDA7XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHR1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXCI7IH1cblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdFxuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdGlmIChjb2RlLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIW8uaW5saW5lKSB7XG5cdFx0XHRpZiAoV0hJVEVTUEFDRS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdGNvZGUgPSAoXCJcXG5cIiArIGNvZGUpO1xuXHRcdFx0XHRpZiAoY29kZS5tYXRjaCgvXlxccyokL2cpKSB7IHJldHVybiBbXSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29kZSA9IGNvZGUucmVwbGFjZSgvXFxyL2csJycpLnJlcGxhY2UoL1tcXHQgXSskL2csJycpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fbGFzdCA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdFR5cCA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdFZhbCA9IG51bGw7XG5cdFx0XG5cdFx0dGhpcy5fY29kZSA9IGNvZGU7XG5cdFx0dGhpcy5fb3B0cyA9IG87XG5cdFx0dGhpcy5fbG9jT2Zmc2V0ID0gby5sb2MgfHwgMDtcblx0XHQvLyBhZGQgYSByZWZlcmVuY2UgdG8gdGhlIG9wdGlvbnMgb2JqZWN0XG5cdFx0by5fdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuXHRcdC8vIHdoYXQgYWJvdXQgY29sIGhlcmU/XG5cdFx0XG5cdFx0Ly8gQGluZGVudCAgPSAwICMgVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwuXG5cdFx0Ly8gQGluZGVidCAgPSAwICMgVGhlIG92ZXItaW5kZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0Ly8gQG91dGRlYnQgPSAwICMgVGhlIHVuZGVyLW91dGRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHQvLyBAaW5kZW50cyA9IFtdICMgVGhlIHN0YWNrIG9mIGFsbCBjdXJyZW50IGluZGVudGF0aW9uIGxldmVscy5cblx0XHQvLyBAZW5kcyAgICA9IFtdICMgVGhlIHN0YWNrIGZvciBwYWlyaW5nIHVwIHRva2Vucy5cblx0XHQvLyBAdG9rZW5zICA9IFtdICMgU3RyZWFtIG9mIHBhcnNlZCB0b2tlbnMgaW4gdGhlIGZvcm0gYFsnVFlQRScsIHZhbHVlLCBsaW5lXWAuXG5cdFx0Ly8gQGNoYXIgPSBuaWxcblx0XHRcblx0XHRpZiAoby5wcm9maWxlKSB7IGNvbnNvbGUudGltZShcInRva2VuaXplOmxleGVyXCIpIH07XG5cdFx0dGhpcy5wYXJzZShjb2RlKTtcblx0XHRpZiAoIW8uaW5saW5lKSB0aGlzLmNsb3NlSW5kZW50YXRpb24oKTtcblx0XHRpZiAoIW8uc2lsZW50ICYmIHRoaXMuX2VuZHMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmVycm9yKChcIm1pc3NpbmcgXCIgKyAodGhpcy5fZW5kcy5wb3AoKSkpKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChvLnByb2ZpbGUpIHsgY29uc29sZS50aW1lRW5kKFwidG9rZW5pemU6bGV4ZXJcIikgfTtcblx0XHRpZiAoby5yZXdyaXRlID09IGZhbHNlIHx8IG8ubm9yZXdyaXRlKSB7IHJldHVybiB0aGlzLl90b2tlbnMgfTtcblx0XHRyZXR1cm4gbmV3IFJld3JpdGVyKCkucmV3cml0ZSh0aGlzLl90b2tlbnMsbyk7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBwaSA9IDA7XG5cdFx0XG5cdFx0d2hpbGUgKHRoaXMuX2NodW5rID0gY29kZS5zbGljZShpKSl7XG5cdFx0XHR0aGlzLl9sb2MgPSB0aGlzLl9sb2NPZmZzZXQgKyBpO1xuXHRcdFx0cGkgPSAodGhpcy5fZW5kID09ICdUQUcnICYmIHRoaXMudGFnRGVmQ29udGV4dFRva2VuKCkpIHx8ICh0aGlzLl9pblRhZyAmJiB0aGlzLnRhZ0NvbnRleHRUb2tlbigpKSB8fCB0aGlzLmJhc2ljQ29udGV4dCgpO1xuXHRcdFx0aSArPSBwaTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5iYXNpY0NvbnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RvclRva2VuKCkgfHwgdGhpcy5zeW1ib2xUb2tlbigpIHx8IHRoaXMubWV0aG9kTmFtZVRva2VuKCkgfHwgdGhpcy5pZGVudGlmaWVyVG9rZW4oKSB8fCB0aGlzLndoaXRlc3BhY2VUb2tlbigpIHx8IHRoaXMubGluZVRva2VuKCkgfHwgdGhpcy5jb21tZW50VG9rZW4oKSB8fCB0aGlzLmhlcmVkb2NUb2tlbigpIHx8IHRoaXMudGFnVG9rZW4oKSB8fCB0aGlzLnN0cmluZ1Rva2VuKCkgfHwgdGhpcy5udW1iZXJUb2tlbigpIHx8IHRoaXMucmVnZXhUb2tlbigpIHx8IHRoaXMuanNUb2tlbigpIHx8IHRoaXMubGl0ZXJhbFRva2VuKCkgfHwgMDtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5tb3ZlQ2FyZXQgPSBmdW5jdGlvbiAoaSl7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYyArPSBpO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmluQ29udGV4dCA9IGZ1bmN0aW9uIChrZXkpe1xuXHRcdHZhciBvID0gdGhpcy5fY29udGV4dHNbdGhpcy5fY29udGV4dHMubGVuZ3RoIC0gMV07XG5cdFx0cmV0dXJuIG8gJiYgb1trZXldO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnB1c2hFbmQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcInB1c2hpbmcgZW5kXCIsdmFsXG5cdFx0dGhpcy5fZW5kcy5wdXNoKHZhbCk7XG5cdFx0dGhpcy5fY29udGV4dHMucHVzaChudWxsKTtcblx0XHR0aGlzLl9lbmQgPSB2YWw7XG5cdFx0dGhpcy5yZWZyZXNoU2NvcGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5wb3BFbmQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHR0aGlzLl9lbmRzLnBvcCgpO1xuXHRcdHRoaXMuX2NvbnRleHRzLnBvcCgpO1xuXHRcdHRoaXMuX2VuZCA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0XHR0aGlzLnJlZnJlc2hTY29wZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnJlZnJlc2hTY29wZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBjdHgwID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdO1xuXHRcdHZhciBjdHgxID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDJdO1xuXHRcdHJldHVybiB0aGlzLl9pblRhZyA9IGN0eDAgPT0gJ1RBR19FTkQnIHx8IChjdHgxID09ICdUQUdfRU5EJyAmJiBjdHgwID09ICdPVVRERU5UJyk7XG5cdH07XG5cdFxuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5xdWV1ZVNjb3BlID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJwdXNoaW5nIHNjb3BlIHt2YWx9IC0ge0BpbmRlbnRzfSB7QGluZGVudHM6bGVuZ3RofVwiKVxuXHRcdC8vIEBzY29wZXMucHVzaCh2YWwpICMgbm8gbm9cblx0XHR0aGlzLl9zY29wZXNbdGhpcy5faW5kZW50cy5sZW5ndGhdID0gdmFsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnBvcFNjb3BlID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0dGhpcy5fc2NvcGVzLnBvcCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmdldFNjb3BlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3Blc1t0aGlzLl9pbmRlbnRzLmxlbmd0aCAtIDFdO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKHN5bSxvcHRzKXtcblx0XHR2YXIgbGVuID0gdGhpcy5fZW5kcy5wdXNoKHRoaXMuX2VuZCA9IHN5bSk7XG5cdFx0dGhpcy5fY29udGV4dHMucHVzaChvcHRzIHx8IG51bGwpO1xuXHRcdHJldHVybiBzeW07XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLmNsb3NlU2VsZWN0b3IgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fZW5kID09ICclJykge1xuXHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfRU5EJywnJScsMCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYWlyKCclJyk7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUub3BlbkRlZiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnB1c2hFbmQoJ0RFRicpO1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5jbG9zZURlZiA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLmNvbnRleHQoKSA9PSAnREVGJykge1xuXHRcdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImNsb3NlIGRlZiB7cHJldn1cIlxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2Nsb3NlRGVmIHdpdGggbGFzdD4nLHByZXYpXG5cdFx0XHRpZiAodFQocHJldikgPT0gJ0RFRl9GUkFHTUVOVCcpIHtcblx0XHRcdFx0dHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAodFQocHJldikgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiaGVyZT8hPz9cIlxuXHRcdFx0XHR2YXIgbiA9IHRoaXMuX3Rva2Vucy5wb3AoKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgblxuXHRcdFx0XHR0aGlzLnRva2VuKCdERUZfQk9EWScsJ0RFRl9CT0RZJywwKTtcblx0XHRcdFx0Ly8gdG9rZW4oJ1RFUk1JTkFUT1InLCAnJywwKSB1bmxlc3Mgbi5AdmFsdWUuaW5kZXhPZignLy8nKSA+PSAwXG5cdFx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKG4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy50b2tlbignREVGX0JPRFknLCdERUZfQk9EWScsMCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLnBhaXIoJ0RFRicpO1xuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnRhZ0NvbnRleHRUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaDtcblx0XHRpZiAodGhpcy5fY2h1bmtbMF0gPT0gJyMnKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnZm91bmQgaWQgIyBpbiB0YWdDb250ZXh0VG9rZW4nKVxuXHRcdFx0dGhpcy50b2tlbignIycsJyMnLDEpO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAobWF0Y2ggPSBUQUdfQVRUUi5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ1RBR19TRERTQVRUUiBJTiB0b2tpZCcsbWF0Y2hcblx0XHRcdC8vIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0XHQvLyBpZiB0aGUgcHJldiBpcyBhIHRlcm1pbmF0b3IsIHdlIGRvbnQgcmVhbGx5IG5lZWQgdG8gY2FyZT9cblx0XHRcdGlmICh0aGlzLl9sYXN0VHlwICE9ICdUQUdfTkFNRScpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RUeXAgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ3ByZXYgd2FzIHRlcm1pbmF0b3IgLS0gZHJvcCBpdD8nKVxuXHRcdFx0XHRcdHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbihcIixcIixcIixcIik7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbCA9IG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0dGhpcy50b2tlbignVEFHX0FUVFInLG1hdGNoWzFdLGwgLSAxKTsgLy8gYWRkIHRvIGxvYz9cblx0XHRcdHRoaXMuX2xvYyArPSBsIC0gMTtcblx0XHRcdHRoaXMudG9rZW4oJz0nLCc9JywxKTtcblx0XHRcdHJldHVybiBsO1xuXHRcdH07XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUudGFnRGVmQ29udGV4dFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJ0YWdDb250ZXh0VG9rZW5cIlxuXHRcdHZhciBtYXRjaDtcblx0XHRpZiAobWF0Y2ggPSBUQUdfVFlQRS5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dGhpcy50b2tlbignVEFHX1RZUEUnLG1hdGNoWzBdLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG1hdGNoID0gVEFHX0lELmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHR2YXIgaW5wdXQgPSBtYXRjaFswXTtcblx0XHRcdHRoaXMudG9rZW4oJ1RBR19JRCcsaW5wdXQsaW5wdXQubGVuZ3RoKTtcblx0XHRcdHJldHVybiBpbnB1dC5sZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gMDtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUudGFnVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsIGFyeTtcblx0XHRpZiAoIShtYXRjaCA9IFRBRy5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBpbnB1dCA9IGFyeVswXSx0eXBlID0gYXJ5WzFdLGlkZW50aWZpZXIgPSBhcnlbMl07XG5cdFx0XG5cdFx0aWYgKHR5cGUgPT0gJzwnKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdUQUdfU1RBUlQnLCc8JywxKTtcblx0XHRcdHRoaXMucHVzaEVuZChJTlZFUlNFUy5UQUdfU1RBUlQpO1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2ggPSBUQUdfVFlQRS5leGVjKHRoaXMuX2NodW5rLnN1YnN0cigxLDQwKSkpIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIHNob3VsZCBwcm9iYWJseSBiZSBoYW5kbGVkIGluIEFTVFxuXHRcdFx0XHRpZiAobWF0Y2hbMF0gIT0gJ3NlbGYnKSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignVEFHX1RZUEUnLG1hdGNoWzBdLG1hdGNoWzBdLmxlbmd0aCwxKTtcblx0XHRcdFx0XHRyZXR1cm4gaW5wdXQubGVuZ3RoICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGlkZW50aWZpZXIpIHtcblx0XHRcdFx0aWYgKGlkZW50aWZpZXIuc3Vic3RyKDAsMSkgPT0gJ3snKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHR5cGUubGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1RBR19OQU1FJyxpbnB1dC5zdWJzdHIoMSksMCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGlucHV0Lmxlbmd0aDtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuc2VsZWN0b3JUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhcnksIHN0cmluZztcblx0XHR2YXIgbWF0Y2g7XG5cdFx0XG5cdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBpZiB3ZSBhcmUgaW4gdGhpcyBjb250ZXh0XG5cdFx0aWYgKHRoaXMuX2VuZCA9PSAnJScpIHtcblx0XHRcdHZhciBjaHIgPSB0aGlzLl9jaHVuay5jaGFyQXQoMCk7XG5cdFx0XHR2YXIgb3BlbiA9IHRoaXMuaW5Db250ZXh0KCdvcGVuJyk7XG5cdFx0XHRcblx0XHRcdC8vIHNob3VsZCBhZGQgZm9yICssIH4gZXRjXG5cdFx0XHQvLyBzaG91bGQgbWF5YmUgcmF0aGVyIGxvb2sgZm9yIHRoZSBjb3JyZWN0IHR5cGUgb2YgY2hhcmFjdGVyP1xuXHRcdFx0XG5cdFx0XHRpZiAob3BlbiAmJiAoY2hyID09ICcgJyB8fCBjaHIgPT0gJ1xcbicgfHwgY2hyID09ICcsJyB8fCBjaHIgPT0gJysnIHx8IGNociA9PSAnficgfHwgY2hyID09ICcpJyB8fCBjaHIgPT0gJ10nKSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImNsb3NlIHRoaXMgc2VsZWN0b3IgZGlyZWN0bHlcIlxuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9FTkQnLCclJywwKTtcblx0XHRcdFx0dGhpcy5wYWlyKCclJyk7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG1hdGNoID0gU0VMRUNUT1JfQ09NQklOQVRPUi5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0XHQvLyBzcGFjZXMgYmV0d2Vlbj8gLS0gaW5jbHVkZSB0aGUgd2hvbGVcblx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfQ09NQklOQVRPUicsbWF0Y2hbMV0gfHwgXCIgXCIsbWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBTRUxFQ1RPUl9QQVJULmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gbWF0Y2hbMV07XG5cdFx0XHRcdHZhciBpZCA9IG1hdGNoWzJdO1xuXHRcdFx0XHRcblx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnLic6XG5cdFx0XHRcdFx0XHR0b2tpZCA9ICdTRUxFQ1RPUl9DTEFTUyc7YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSAnIyc6XG5cdFx0XHRcdFx0XHR0b2tpZCA9ICdTRUxFQ1RPUl9JRCc7YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSAnOic6XG5cdFx0XHRcdFx0XHR0b2tpZCA9ICdTRUxFQ1RPUl9QU0VVRE9fQ0xBU1MnO2JyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgJzo6Jzpcblx0XHRcdFx0XHRcdHRva2lkID0gJ1NFTEVDVE9SX1BTRVVET19DTEFTUyc7YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZhciB0b2tpZCA9ICdTRUxFQ1RPUl9UQUcnO1xuXHRcdFx0XHRcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMudG9rZW4odG9raWQsbWF0Y2hbMl0sbWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICdbJykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdbJywnWycsMSk7XG5cdFx0XHRcdHRoaXMucHVzaEVuZCgnXScpO1xuXHRcdFx0XHRpZiAobWF0Y2ggPSBTRUxFQ1RPUl9BVFRSLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRcdFx0Ly8gZnVjayB0aGlzIGxlbmd0aCBzaGl0XG5cdFx0XHRcdFx0dmFyIGlkb2Zmc2V0ID0gbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsxXSk7XG5cdFx0XHRcdFx0dmFyIG9wb2Zmc2V0ID0gbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsyXSk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignSURFTlRJRklFUicsbWF0Y2hbMV0sbWF0Y2hbMV0ubGVuZ3RoLGlkb2Zmc2V0KTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9BVFRSX09QJyxtYXRjaFsyXSxtYXRjaFsyXS5sZW5ndGgsb3BvZmZzZXQpO1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJ3wnKSB7XG5cdFx0XHRcdHZhciB0b2sgPSB0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR0VHModG9rLCdTRUxFQ1RPUl9OUycpO1xuXHRcdFx0XHQvLyB0b2tbMF0gPSAnU0VMRUNUT1JfTlMnICMgRklYXG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJywnKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0dST1VQJywnLCcsMSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJyonKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1VOSVZFUlNBTF9TRUxFQ1RPUicsJyonLDEpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICcpJykge1xuXHRcdFx0XHR0aGlzLnBhaXIoJyUnKTtcblx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfRU5EJywnKScsMSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChpZHgkKGNocixbJyknLCd9JywnXScsJyddKSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMucGFpcignJScpO1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IFNFTEVDVE9SLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdHZhciBhcnkgPSBpdGVyJChtYXRjaCk7dmFyIGlucHV0ID0gYXJ5WzBdLGlkID0gYXJ5WzFdLGtpbmQgPSBhcnlbMl07XG5cdFx0XG5cdFx0Ly8gdGhpcyBpcyBhIGNsb3NlZCBzZWxlY3RvclxuXHRcdGlmIChraW5kID09ICcoJykge1xuXHRcdFx0Ly8gdG9rZW4gJygnLCcoJ1xuXHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfU1RBUlQnLGlkLGlkLmxlbmd0aCArIDEpO1xuXHRcdFx0Ly8gc2VsZi5wdXNoRW5kKCcpJykgIyBhcmUgd2Ugc28gc3VyZSBhYm91dCB0aGlzP1xuXHRcdFx0dGhpcy5wdXNoRW5kKCclJyk7XG5cdFx0XHRcblx0XHRcdC8vIEBlbmRzLnB1c2ggJyknXG5cdFx0XHQvLyBAZW5kcy5wdXNoICclJ1xuXHRcdFx0cmV0dXJuIGlkLmxlbmd0aCArIDE7XG5cdFx0fSBlbHNlIGlmIChpZCA9PSAnJScpIHtcblx0XHRcdC8vIHdlIGFyZSBhbHJlYWR5IHNjb3BlZCBpbiBvbiBhIHNlbGVjdG9yXG5cdFx0XHRpZiAodGhpcy5jb250ZXh0KCkgPT0gJyUnKSB7IHJldHVybiAxIH07XG5cdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9TVEFSVCcsaWQsaWQubGVuZ3RoKTtcblx0XHRcdC8vIHRoaXMgaXMgYSBzZXBhcmF0ZSAtIHNjb3BlLiBGdWxsIHNlbGVjdG9yIHNob3VsZCByYXRoZXIgYmUgJCwgYW5kIGtlZXAgdGhlIHNpbmdsZSBzZWxlY3RvciBhcyAlXG5cdFx0XHRcblx0XHRcdHRoaXMuc2NvcGUoJyUnLHtvcGVuOiB0cnVlfSk7XG5cdFx0XHQvLyBAZW5kcy5wdXNoICclJ1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGEgdGVybWluYXRvciBicmVha3Mgb3V0XG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICgoaWQgPT0gJyUnIHx8IGlkID09ICckJykgJiYgWyclJywnJCcsJ0AnLCcoJywnWyddLmluZGV4T2YoY2hyKSA+PSAwKSB7XG5cdFx0XHR2YXIgaWR4ID0gMjtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBWRVJZIHRlbXBvcmFyeSB3YXkgb2Ygc29sdmluZyB0aGlzXG5cdFx0XHRpZiAoKGNociA9PSAnJScgfHwgY2hyID09ICckJyB8fCBjaHIgPT0gJ0AnKSkge1xuXHRcdFx0XHRpZCArPSBjaHI7XG5cdFx0XHRcdGlkeCA9IDM7XG5cdFx0XHRcdGNociA9IHRoaXMuX2NodW5rLmNoYXJBdCgyKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0aWYgKGNociA9PSAnKCcpIHtcblx0XHRcdFx0aWYgKCEoc3RyaW5nID0gdGhpcy5iYWxhbmNlZFNlbGVjdG9yKHRoaXMuX2NodW5rLCcpJykpKSB7IHJldHVybiAwIH07XG5cdFx0XHRcdGlmICgwIDwgc3RyaW5nLmluZGV4T2YoJ3snLDEpKSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1InLGlkKTtcblx0XHRcdFx0XHQvLyBpcyB0aGlzIGV2ZW4gdXNlZCBhbnltb3JlPyBJZiBzbyAtIHdlIG5lZWQgdG8gZml4IGl0XG5cdFx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVN0cmluZyhzdHJpbmcuc2xpY2UoaWR4LC0xKSk7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1InLGlkKTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCcoJywnKCcpO1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NUUklORycsJ1wiJyArIHN0cmluZy5zbGljZShpZHgsLTEpICsgJ1wiJyk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignKScsJyknKTtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICdbJykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUicsaWQpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0Ly8gdG9rZW4gJ1snLCdbJ1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoICcnXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHR9O1xuXHRcblx0Ly8gaXMgdGhpcyByZWFsbHkgbmVlZGVkPyBTaG91bGQgYmUgcG9zc2libGUgdG9cblx0Ly8gcGFyc2UgdGhlIGlkZW50aWZpZXJzIGFuZCA9IGV0YyBpIGppc29uP1xuXHQvLyB3aGF0IGlzIHNwZWNpYWwgYWJvdXQgbWV0aG9kTmFtZVRva2VuPyByZWFsbHk/XG5cdExleGVyLnByb3RvdHlwZS5tZXRob2ROYW1lVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHQvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyBieSBhZnRlciBhIGRlZiBzaW1wbHlcblx0XHQvLyBmZXRjaGluZyBhbGwgdGhlIHdheSBhZnRlciB0aGUgZGVmIHVudGlsIGEgc3BhY2Ugb3IgKFxuXHRcdC8vIGFuZCB0aGVuIGFkZCB0aGlzIHRvIHRoZSBkZWYtdG9rZW4gaXRzZWxmIChhcyB3aXRoIGZyYWdtZW50KVxuXHRcdGlmICh0aGlzLl9jaHVuay5jaGFyQXQoMCkgPT0gJyAnKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0dmFyIG1hdGNoO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9lbmQgPT0gJyknKSB7XG5cdFx0XHR2YXIgb3V0ZXJjdHggPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMl07XG5cdFx0XHQvLyB3ZWlyZCBhc3N1bXB0aW9uLCBubz9cblx0XHRcdC8vIGNvbnNvbGUubG9nICdjb250ZXh0IGlzIGluc2lkZSEhISdcblx0XHRcdGlmIChvdXRlcmN0eCA9PSAnJScgJiYgKG1hdGNoID0gVEFHX0FUVFIuZXhlYyh0aGlzLl9jaHVuaykpKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1RBR19BVFRSX1NFVCcsbWF0Y2hbMV0pO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gTUVUSE9EX0lERU5USUZJRVIuZXhlYyh0aGlzLl9jaHVuaykpKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdC8vIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIGxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcblx0XHR2YXIgaWQgPSBtYXRjaFswXTtcblx0XHR2YXIgbHR5cCA9IHRoaXMuX2xhc3RUeXA7XG5cdFx0dmFyIHR5cCA9ICdJREVOVElGSUVSJztcblx0XHR2YXIgcHJlID0gaWQuY2hhckF0KDApO1xuXHRcdHZhciBzcGFjZSA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBtNCA9IG1hdGNoWzRdOyAvLyBtaWdodCBiZSBvdXQgb2YgYm91bmRzPyBzaG91bGQgcmF0aGVyIGNoZWNrIGNoYXJBdFxuXHRcdC8vIGRyb3AgbWF0Y2ggND8/XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHRoaXMgbm90IHF1aXQgaGVyZSBpbiBwcmFjdGljYWxseSBhbGwgY2FzZXM/XG5cdFx0aWYgKCEoKGx0eXAgPT0gJy4nIHx8IGx0eXAgPT0gJ0RFRicpIHx8IChtNCA9PSAnIScgfHwgbTQgPT0gJz8nKSB8fCBtYXRjaFs1XSkpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gYWdhaW4sIHdoeT9cblx0XHRpZiAoaWQgPT0gJ3NlbGYnIHx8IGlkID09ICd0aGlzJyB8fCBpZCA9PSAnc3VwZXInKSB7IC8vIGluIFsnU0VMRicsJ1RISVMnXVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaWQgPT0gJ25ldycpIHtcblx0XHRcdHR5cCA9ICdORVcnO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGlkID09ICcuLi4nICYmIFsnLCcsJygnLCdDQUxMX1NUQVJUJywnQkxPQ0tfUEFSQU1fU1RBUlQnLCdQQVJBTV9TVEFSVCddLmluZGV4T2YobHR5cCkgPj0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaWQgPT0gJ3wnKSB7XG5cdFx0XHQvLyBoYWNreSB3YXkgdG8gaW1wbGVtZW50IHRoaXNcblx0XHRcdC8vIHdpdGggbmV3IGxleGVyIHdlJ2xsIHVzZSB7IC4uLiB9IGluc3RlYWQsIGFuZCBhc3N1bWUgb2JqZWN0LWNvbnRleHQsXG5cdFx0XHQvLyB0aGVuIGdvIGJhY2sgYW5kIGNvcnJlY3Qgd2hlbiB3ZSBzZWUgdGhlIGNvbnRleHQgaXMgaW52YWxpZFxuXHRcdFx0aWYgKGx0eXAgPT0gJygnIHx8IGx0eXAgPT0gJ0NBTExfU1RBUlQnKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0RPJywnRE8nLDApO1xuXHRcdFx0XHR0aGlzLnB1c2hFbmQoJ3wnKTtcblx0XHRcdFx0Ly8gQGVuZHMucHVzaCAnfCdcblx0XHRcdFx0dGhpcy50b2tlbignQkxPQ0tfUEFSQU1fU1RBUlQnLGlkLDEpO1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmIChsdHlwID09ICdETycgfHwgbHR5cCA9PSAneycpIHtcblx0XHRcdFx0Ly8gQGVuZHMucHVzaCAnfCdcblx0XHRcdFx0dGhpcy5wdXNoRW5kKCd8Jyk7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0JMT0NLX1BBUkFNX1NUQVJUJyxpZCwxKTtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdID09ICd8Jykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdCTE9DS19QQVJBTV9FTkQnLCd8JywxKTtcblx0XHRcdFx0dGhpcy5wYWlyKCd8Jyk7XG5cdFx0XHRcdHJldHVybiBsZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyB3aGFhdD9cblx0XHQvLyBjb25zb2xlLmxvZyhcIm1ldGhvZCBpZGVudGlmaWVyXCIsaWQpXG5cdFx0aWYgKChbJyYnLCdeJywnPDwnLCc8PDwnLCc+PiddLmluZGV4T2YoaWQpID49IDAgfHwgKGlkID09ICd8JyAmJiB0aGlzLmNvbnRleHQoKSAhPSAnfCcpKSkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoT1BfTUVUSE9EUy5pbmRleE9mKGlkKSA+PSAwKSB7XG5cdFx0XHRzcGFjZSA9IHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBub3QgZXZlbiBhbnl0aGluZyB3ZSBzaG91bGQgdXNlPyE/XG5cdFx0aWYgKHByZSA9PSAnQCcpIHtcblx0XHRcdHR5cCA9ICdJVkFSJztcblx0XHR9IGVsc2UgaWYgKHByZSA9PSAnJCcpIHtcblx0XHRcdHRydWU7XG5cdFx0XHQvLyB0eXAgPSAnR1ZBUidcblx0XHR9IGVsc2UgaWYgKHByZSA9PSAnIycpIHtcblx0XHRcdHR5cCA9ICdUQUdJRCc7XG5cdFx0fSBlbHNlIGlmIChDT05TVF9JREVOVElGSUVSLnRlc3QocHJlKSB8fCBpZCA9PSAncmVxdWlyZScgfHwgaWQgPT0gJ2dsb2JhbCcgfHwgaWQgPT0gJ2V4cG9ydHMnKSB7XG5cdFx0XHQvLyByZWFsbHk/IHNlZW1zIHZlcnkgc3RyYW5nZVxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2dsb2JhbCEhJyx0eXAsaWQpXG5cdFx0XHR0eXAgPSAnQ09OU1QnO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gd2hhdCBpcyB0aGlzIHJlYWxseSBmb3I/XG5cdFx0aWYgKG1hdGNoWzVdICYmIFsnSURFTlRJRklFUicsJ0NPTlNUJywnR1ZBUicsJ0NWQVInLCdJVkFSJywnU0VMRicsJ1RISVMnLCddJywnfScsJyknLCdOVU1CRVInLCdTVFJJTkcnLCdJRFJFRiddLmluZGV4T2YobHR5cCkgPj0gMCkge1xuXHRcdFx0dGhpcy50b2tlbignLicsJy4nLDApO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy50b2tlbih0eXAsaWQsbGVuZ3RoKTtcblx0XHRcblx0XHRpZiAoc3BhY2UpIHtcblx0XHRcdHRoaXMuX2xhc3Quc3BhY2VkID0gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBsZW5ndGg7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLmluVGFnID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGxlbiA9IHRoaXMuX2VuZHMubGVuZ3RoO1xuXHRcdGlmIChsZW4gPiAwKSB7XG5cdFx0XHR2YXIgY3R4MCA9IHRoaXMuX2VuZHNbbGVuIC0gMV07XG5cdFx0XHR2YXIgY3R4MSA9IGxlbiA+IDEgPyAodGhpcy5fZW5kc1tsZW4gLSAyXSkgOiAoY3R4MCk7XG5cdFx0XHRyZXR1cm4gY3R4MCA9PSAnVEFHX0VORCcgfHwgKGN0eDEgPT0gJ1RBR19FTkQnICYmIGN0eDAgPT0gJ09VVERFTlQnKTtcblx0XHR9O1xuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoaWQpe1xuXHRcdGlmICgoaWQgPT0gJ2F0dHInIHx8IGlkID09ICdwcm9wJykpIHtcblx0XHRcdHZhciBzY29wID0gdGhpcy5nZXRTY29wZSgpO1xuXHRcdFx0dmFyIGluY2xzID0gc2NvcCA9PSAnQ0xBU1MnIHx8IHNjb3AgPT0gJ1RBRyc7XG5cdFx0XHQvLyB2YXIgc2NvcGVzID0gQGluZGVudHMubWFwKHxpbmQsaXwgQHNjb3Blc1tpXSBvciAnTk9ORScpXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImlkIGlzIHByb3A6IHtzY29wZXMuam9pbihcIiAtPiBcIil9IHwge0BpbmRlbnRzLmpvaW4oXCIgLT4gXCIpfVwiXG5cdFx0XHRpZiAoaW5jbHMpIHsgcmV0dXJuIHRydWUgfTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBBTExfS0VZV09SRFMuaW5kZXhPZihpZCkgPj0gMDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgaWRlbnRpZnlpbmcgbGl0ZXJhbHM6IHZhcmlhYmxlcywga2V5d29yZHMsIG1ldGhvZCBuYW1lcywgZXRjLlxuXHQvLyBDaGVjayB0byBlbnN1cmUgdGhhdCBKYXZhU2NyaXB0IHJlc2VydmVkIHdvcmRzIGFyZW4ndCBiZWluZyB1c2VkIGFzXG5cdC8vIGlkZW50aWZpZXJzLiBCZWNhdXNlIEltYmEgcmVzZXJ2ZXMgYSBoYW5kZnVsIG9mIGtleXdvcmRzIHRoYXQgYXJlXG5cdC8vIGFsbG93ZWQgaW4gSmF2YVNjcmlwdCwgd2UncmUgY2FyZWZ1bCBub3QgdG8gdG9raWQgdGhlbSBhcyBrZXl3b3JkcyB3aGVuXG5cdC8vIHJlZmVyZW5jZWQgYXMgcHJvcGVydHkgbmFtZXMgaGVyZSwgc28geW91IGNhbiBzdGlsbCBkbyBgalF1ZXJ5LmlzKClgIGV2ZW5cblx0Ly8gdGhvdWdoIGBpc2AgbWVhbnMgYD09PWAgb3RoZXJ3aXNlLlxuXHRMZXhlci5wcm90b3R5cGUuaWRlbnRpZmllclRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyeTtcblx0XHR2YXIgbWF0Y2g7XG5cdFx0XG5cdFx0dmFyIGN0eDAgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0dmFyIGN0eDEgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMl07XG5cdFx0dmFyIGlubmVyY3R4ID0gY3R4MDtcblx0XHR2YXIgdHlwO1xuXHRcdHZhciByZXNlcnZlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBhZGRMb2MgPSBmYWxzZTtcblx0XHR2YXIgaW5UYWcgPSBjdHgwID09ICdUQUdfRU5EJyB8fCAoY3R4MSA9PSAnVEFHX0VORCcgJiYgY3R4MCA9PSAnT1VUREVOVCcpO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIGN0eDEsY3R4MFxuXHRcdFxuXHRcdGlmIChpblRhZyAmJiAobWF0Y2ggPSBUQUdfQVRUUi5leGVjKHRoaXMuX2NodW5rKSkpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdUQUdfQVRUUiBJTiB0b2tpZCcsbWF0Y2hcblx0XHRcdC8vIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0XHQvLyBpZiB0aGUgcHJldiBpcyBhIHRlcm1pbmF0b3IsIHdlIGRvbnQgcmVhbGx5IG5lZWQgdG8gY2FyZT9cblx0XHRcdGlmICh0aGlzLl9sYXN0VHlwICE9ICdUQUdfTkFNRScpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RUeXAgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ3ByZXYgd2FzIHRlcm1pbmF0b3IgLS0gZHJvcCBpdD8nKVxuXHRcdFx0XHRcdHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbihcIixcIixcIixcIik7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbCA9IG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0dGhpcy50b2tlbignVEFHX0FUVFInLG1hdGNoWzFdLGwgLSAxKTsgLy8gYWRkIHRvIGxvYz9cblx0XHRcdHRoaXMuX2xvYyArPSBsIC0gMTtcblx0XHRcdHRoaXMudG9rZW4oJz0nLCc9JywxKTtcblx0XHRcdHJldHVybiBsO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2VlIGlmIHRoaXMgaXMgYSBwbGFpbiBvYmplY3Qta2V5XG5cdFx0Ly8gd2F5IHRvbyBtdWNoIGxvZ2ljIGdvaW5nIG9uIGhlcmU/XG5cdFx0Ly8gdGhlIGFzdCBzaG91bGQgbm9ybWFsaXplIHdoZXRoZXIga2V5c1xuXHRcdC8vIGFyZSBhY2Nlc3NhYmxlIGFzIGtleXMgb3Igc3RyaW5ncyBldGNcblx0XHRpZiAobWF0Y2ggPSBPQkpFQ1RfS0VZLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHR2YXIgaWQgPSBtYXRjaFsxXTtcblx0XHRcdHR5cCA9ICdJREVOVElGSUVSJztcblx0XHRcdFxuXHRcdFx0Ly8gRklYTUUgbG9jIG9mIGtleSBpbmNsdWRlcyBjb2xvblxuXHRcdFx0Ly8gbW92ZUNhcmV0KGlkOmxlbmd0aClcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwib2tcIlxuXHRcdFx0aWYgKHRydWUpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJnb3QgaGVyZT8ge21hdGNofVwiXG5cdFx0XHRcdHRoaXMudG9rZW4odHlwLGlkLGlkLmxlbmd0aCk7XG5cdFx0XHRcdHRoaXMubW92ZUNhcmV0KGlkLmxlbmd0aCk7XG5cdFx0XHRcdHRoaXMudG9rZW4oJzonLCc6JyxtYXRjaFszXS5sZW5ndGgpO1xuXHRcdFx0XHR0aGlzLm1vdmVDYXJldCgtaWQubGVuZ3RoKTtcblx0XHRcdFx0Ly8gbW92ZUNhcmV0KG1hdGNoWzNdOmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG1vdmVDYXJldChtYXRjaFsyXTpsZW5ndGgpXG5cdFx0XHQvLyByZXR1cm4gMFxuXHRcdFx0Y29uc29sZS5sb2cobWF0Y2hbM10ubGVuZ3RoKTtcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKCc6JywnOicsMSk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBJREVOVElGSUVSLmV4ZWModGhpcy5fY2h1bmspKSkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBpbnB1dCA9IGFyeVswXSxpZCA9IGFyeVsxXSx0eXAgPSBhcnlbMl0sbTMgPSBhcnlbM10sbTQgPSBhcnlbNF0sY29sb24gPSBhcnlbNV07XG5cdFx0dmFyIGlkbGVuID0gaWQubGVuZ3RoO1xuXHRcdFxuXHRcdC8vIFdoYXQgaXMgdGhlIGxvZ2ljIGhlcmU/XG5cdFx0aWYgKGlkID09ICdvd24nICYmIHRoaXMubGFzdFRva2VuVHlwZSgpID09ICdGT1InKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdPV04nLGlkLGlkLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0dmFyIGxhc3RUeXAgPSB0aGlzLl9sYXN0VHlwO1xuXHRcdFxuXHRcdC8vIHNob3VsZCB3ZSBmb3JjZSB0aGlzIHRvIGJlIGFuIGlkZW50aWZpZXIgZXZlbiBpZiBpdCBpcyBhIHJlc2VydmVkIHdvcmQ/XG5cdFx0Ly8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gZm9yIHdoZW4gcGFydCBvZiBvYmplY3QgZXRjXG5cdFx0Ly8gd2lsbCBwcmV2IGV2ZXIgYmUgQD8/P1xuXHRcdHZhciBmb3JjZWRJZGVudGlmaWVyO1xuXHRcdFxuXHRcdC8vIGFnYWluXG5cdFx0Zm9yY2VkSWRlbnRpZmllciA9IGNvbG9uIHx8IGxhc3RUeXAgPT0gJy4nIHx8IGxhc3RUeXAgPT0gJz8uJzsgLy8gaW4gWycuJywgJz8uJ1xuXHRcdFxuXHRcdFxuXHRcdC8vIHRlbXAgaGFjayEgbmVlZCB0byBzb2x2ZSBmb3Igb3RoZXIga2V5d29yZHMgZXRjIGFzIHdlbGxcblx0XHQvLyBwcm9ibGVtIGFwcGVhcnMgd2l0aCB0ZXJuYXJ5IGNvbmRpdGlvbnMuXG5cdFx0XG5cdFx0Ly8gd2VsbCAtLSBpdCBzaG91bGQgc3RpbGwgYmUgYW4gaW5kZW50aWZpZXIgaWYgaW4gb2JqZWN0P1xuXHRcdC8vIGZvcmNlZElkZW50aWZpZXIgPSBubyBpZiBpZCBpbiBbJ3VuZGVmaW5lZCcsJ2JyZWFrJ11cblx0XHRcblx0XHRpZiAoY29sb24gJiYgbGFzdFR5cCA9PSAnPycpIHsgZm9yY2VkSWRlbnRpZmllciA9IGZhbHNlIH07IC8vIGZvciB0ZXJuYXJ5XG5cdFx0XG5cdFx0Ly8gaWYgd2UgYXJlIG5vdCBhdCB0aGUgdG9wIGxldmVsPyAtLSBoYWNreVxuXHRcdGlmIChpZCA9PSAndGFnJyAmJiB0aGlzLl9jaHVuay5pbmRleE9mKFwidGFnKFwiKSA9PSAwKSB7IC8vIEBjaHVuay5tYXRjaCgvXnRva2lkXFwoLylcblx0XHRcdGZvcmNlZElkZW50aWZpZXIgPSB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGlzS2V5d29yZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwibWF0Y2hcIixtYXRjaFxuXHRcdC8vIGNvbnNvbGUubG9nIFwidHlwIGlzIHt0eXB9XCJcblx0XHQvLyBsaXR0bGUgcmVhc29uIHRvIGNoZWNrIGZvciB0aGlzIHJpZ2h0IGhlcmU/IGJ1dCBJIGd1ZXNzIGl0IGlzIG9ubHkgYSBzaW1wbGUgY2hlY2tcblx0XHRpZiAodHlwID09ICckJyAmJiBBUkdWQVIudGVzdChpZCkpIHsgLy8gaWQubWF0Y2goL15cXCRcXGQkLylcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiVFlQICRcIlxuXHRcdFx0aWYgKGlkID09ICckMCcpIHtcblx0XHRcdFx0dHlwID0gJ0FSR1VNRU5UUyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXAgPSAnQVJHVkFSJztcblx0XHRcdFx0aWQgPSBpZC5zdWJzdHIoMSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdAJykge1xuXHRcdFx0dHlwID0gJ0lWQVInO1xuXHRcdFx0XG5cdFx0XHQvLyBpZDpyZXNlcnZlZCA9IHllcyBpZiBjb2xvblxuXHRcdH0gZWxzZSBpZiAodHlwID09ICcjJykge1xuXHRcdFx0Ly8gd2UgYXJlIHRyeWluZyB0byBtb3ZlIHRvIGdlbmVyaWMgdG9rZW5zLFxuXHRcdFx0Ly8gc28gd2UgYXJlIHN0YXJ0aW5nIHRvIHNwbGl0dGluZyB1cCB0aGUgc3ltYm9scyBhbmQgdGhlIGl0ZW1zXG5cdFx0XHQvLyB3ZSdsbCBzZWUgaWYgdGhhdCB3b3Jrc1xuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInO1xuXHRcdFx0dGhpcy50b2tlbignIycsJyMnKTtcblx0XHRcdGlkID0gaWQuc3Vic3RyKDEpO1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdAQCcpIHtcblx0XHRcdHR5cCA9ICdDVkFSJztcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnJCcgJiYgIWNvbG9uKSB7XG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0XHQvLyB0eXAgPSAnR1ZBUidcblx0XHR9IGVsc2UgaWYgKENPTlNUX0lERU5USUZJRVIudGVzdChpZCkgfHwgaWQgPT0gJ3JlcXVpcmUnIHx8IGlkID09ICdnbG9iYWwnIHx8IGlkID09ICdleHBvcnRzJykge1xuXHRcdFx0Ly8gdGhvdXMgc2hvdWxkIHJlYWxseSBiZSBoYW5kbGVkIGJ5IHRoZSBhc3QgaW5zdGVhZFxuXHRcdFx0dHlwID0gJ0NPTlNUJztcblx0XHR9IGVsc2UgaWYgKGlkID09ICdlbGlmJykge1xuXHRcdFx0dGhpcy50b2tlbignRUxTRScsJ2VsaWYnLGlkLmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKCdJRicsJ2lmJyk7XG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHQvLyB0aGlzIGNhdGNoZXMgYWxsIFxuXHRcdGlmICghZm9yY2VkSWRlbnRpZmllciAmJiAoaXNLZXl3b3JkID0gdGhpcy5pc0tleXdvcmQoaWQpKSkge1xuXHRcdFx0Ly8gKGlkIGluIEpTX0tFWVdPUkRTIG9yIGlkIGluIElNQkFfS0VZV09SRFMpXG5cdFx0XHR0eXAgPSBpZC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0YWRkTG9jID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0Ly8gY2x1bXN5IC0gYnV0IHRlc3RpbmcgcGVyZm9ybWFuY2Vcblx0XHRcdGlmICh0eXAgPT0gJ1lFUycpIHtcblx0XHRcdFx0dHlwID0gJ1RSVUUnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ05PJykge1xuXHRcdFx0XHR0eXAgPSAnRkFMU0UnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ05JTCcpIHtcblx0XHRcdFx0dHlwID0gJ05VTEwnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1ZBUicpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RWYWwgPT0gJ2V4cG9ydCcpIHtcblx0XHRcdFx0XHR0VHMocHJldiwnRVhQT1JUJyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSUYnIHx8IHR5cCA9PSAnRUxTRScgfHwgdHlwID09ICdUUlVFJyB8fCB0eXAgPT0gJ0ZBTFNFJyB8fCB0eXAgPT0gJ05VTEwnKSB7XG5cdFx0XHRcdHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnVEFHJykge1xuXHRcdFx0XHR0aGlzLnB1c2hFbmQoJ1RBRycpO1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoKCdUQUcnKVxuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0RFRicpIHtcblx0XHRcdFx0Ly8gc2hvdWxkIHByb2JhYmx5IHNoaWZ0IGNvbnRleHQgYW5kIG9wdGltaXplIHRoaXNcblx0XHRcdFx0dGhpcy5vcGVuRGVmKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnRE8nKSB7XG5cdFx0XHRcdGlmICh0aGlzLmNvbnRleHQoKSA9PSAnREVGJykgdGhpcy5jbG9zZURlZigpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1dIRU4nICYmIExJTkVfQlJFQUsuaW5kZXhPZih0aGlzLmxhc3RUb2tlblR5cGUoKSkgPj0gMCkge1xuXHRcdFx0XHR0eXAgPSAnTEVBRElOR19XSEVOJztcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdGT1InKSB7XG5cdFx0XHRcdHRoaXMuX3NlZW5Gb3IgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1VOTEVTUycpIHtcblx0XHRcdFx0dHlwID0gJ0lGJzsgLy8gV0FSTlxuXHRcdFx0fSBlbHNlIGlmIChVTkFSWS5pbmRleE9mKHR5cCkgPj0gMCkge1xuXHRcdFx0XHR0eXAgPSAnVU5BUlknO1xuXHRcdFx0fSBlbHNlIGlmIChSRUxBVElPTi5pbmRleE9mKHR5cCkgPj0gMCkge1xuXHRcdFx0XHRpZiAodHlwICE9ICdJTlNUQU5DRU9GJyAmJiB0eXAgIT0gJ0lTQScgJiYgdGhpcy5fc2VlbkZvcikge1xuXHRcdFx0XHRcdHR5cCA9ICdGT1InICsgdHlwOyAvLyA/XG5cdFx0XHRcdFx0dGhpcy5fc2VlbkZvciA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHR5cCA9ICdSRUxBVElPTic7XG5cdFx0XHRcdFx0aWYgKFN0cmluZyh0aGlzLnZhbHVlKCkpID09ICchJykge1xuXHRcdFx0XHRcdFx0dGhpcy5fdG9rZW5zLnBvcCgpOyAvLyBpcyBmdWNrZWQgdXA/PyFcblx0XHRcdFx0XHRcdC8vIFdBUk4gd2UgbmVlZCB0byBrZWVwIHRoZSBsb2MsIG5vP1xuXHRcdFx0XHRcdFx0aWQgPSAnIScgKyBpZDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpZCA9PSAnc3VwZXInKSB7XG5cdFx0XHR0eXAgPSAnU1VQRVInO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZG8gd2UgcmVhbGx5IHdhbnQgdG8gY2hlY2sgdGhpcyBoZXJlXG5cdFx0aWYgKCFmb3JjZWRJZGVudGlmaWVyKSB7XG5cdFx0XHQvLyBzaG91bGQgYWxyZWFkeSBoYXZlIGRlYWx0IHdpdGggdGhpc1xuXHRcdFx0XG5cdFx0XHRpZiAoaXNLZXl3b3JkICYmIElNQkFfQUxJQVNFUy5pbmRleE9mKGlkKSA+PSAwKSB7IGlkID0gSU1CQV9BTElBU19NQVBbaWRdIH07XG5cdFx0XHQvLyB0aGVzZSByZWFsbHkgc2hvdWxkIG5vdCBnbyBoZXJlPyE/XG5cdFx0XHRzd2l0Y2ggKGlkKSB7XG5cdFx0XHRcdGNhc2UgJyEnOlxuXHRcdFx0XHRcdHR5cCA9ICdVTkFSWSc7YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICc9PSc6XG5cdFx0XHRcdGNhc2UgJyE9Jzpcblx0XHRcdFx0Y2FzZSAnPT09Jzpcblx0XHRcdFx0Y2FzZSAnIT09Jzpcblx0XHRcdFx0XHR0eXAgPSAnQ09NUEFSRSc7YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICcmJic6XG5cdFx0XHRcdGNhc2UgJ3x8Jzpcblx0XHRcdFx0XHR0eXAgPSAnTE9HSUMnO2JyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnYnJlYWsnOlxuXHRcdFx0XHRjYXNlICdjb250aW51ZSc6XG5cdFx0XHRcdGNhc2UgJ2RlYnVnZ2VyJzpcblx0XHRcdFx0Y2FzZSAnYXJndW1lbnRzJzpcblx0XHRcdFx0XHR0eXAgPSBpZC50b1VwcGVyQ2FzZSgpO2JyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdHZhciBsZW4gPSBpbnB1dC5sZW5ndGg7XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIGJlIHN0cmljdCBhYm91dCB0aGUgb3JkZXIsIGNoZWNrIHRoaXMgbWFudWFsbHkgaW5zdGVhZFxuXHRcdGlmICh0eXAgPT0gJ0NMQVNTJyB8fCB0eXAgPT0gJ0RFRicgfHwgdHlwID09ICdUQUcnKSB7XG5cdFx0XHR0aGlzLnF1ZXVlU2NvcGUodHlwKTtcblx0XHRcdFxuXHRcdFx0dmFyIGkgPSB0aGlzLl90b2tlbnMubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoaSl7XG5cdFx0XHRcdHByZXYgPSB0aGlzLl90b2tlbnNbLS1pXTtcblx0XHRcdFx0dmFyIGN0cmwgPSBcIlwiICsgdFYocHJldik7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiY3RybCBpcyB7Y3RybH1cIilcblx0XHRcdFx0Ly8gbmVlZCB0byBjb2VyY2UgdG8gc3RyaW5nIGJlY2F1c2Ugb2Ygc3R1cGlkIENTID09PVxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInByZXYgaXNcIixwcmV2WzBdLHByZXZbMV0pXG5cdFx0XHRcdGlmIChpZHgkKGN0cmwsSU1CQV9DT05URVhUVUFMX0tFWVdPUkRTKSA+PSAwKSB7XG5cdFx0XHRcdFx0dFRzKHByZXYsY3RybC50b1VwcGVyQ2FzZSgpKTtcblx0XHRcdFx0XHQvLyBwcmV2WzBdID0gY3RybC50b1VwcGVyQ2FzZSAjIEZJWFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSUYnKSB7XG5cdFx0XHR0aGlzLnF1ZXVlU2NvcGUodHlwKTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSU1QT1JUJykge1xuXHRcdFx0Ly8gY291bGQgbWFudWFsbHkgcGFyc2UgdGhlIHdob2xlIHRpbmcgaGVyZT9cblx0XHRcdHRoaXMucHVzaEVuZCgnSU1QT1JUJyk7XG5cdFx0XHQvLyBAZW5kcy5wdXNoICdJTVBPUlQnXG5cdFx0fSBlbHNlIGlmIChpZCA9PSAnZnJvbScgJiYgY3R4MCA9PSAnSU1QT1JUJykge1xuXHRcdFx0dHlwID0gJ0ZST00nO1xuXHRcdFx0dGhpcy5wYWlyKCdJTVBPUlQnKTtcblx0XHR9IGVsc2UgaWYgKGlkID09ICdhcycgJiYgY3R4MCA9PSAnSU1QT1JUJykge1xuXHRcdFx0dHlwID0gJ0FTJztcblx0XHRcdHRoaXMucGFpcignSU1QT1JUJyk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodHlwID09ICdJREVOVElGSUVSJykge1xuXHRcdFx0Ly8gc2VlIGlmIHByZXZpb3VzIHdhcyBjYXRjaCAtLSBiZWxvbmdzIGluIHJld3JpdGVyP1xuXHRcdFx0aWYgKGxhc3RUeXAgPT0gJ0NBVENIJykge1xuXHRcdFx0XHR0eXAgPSAnQ0FUQ0hfVkFSJztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoY29sb24pIHtcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLGlkbGVuKTtcblx0XHRcdHRoaXMubW92ZUNhcmV0KGlkbGVuKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkIGNvbG9uP1wiXG5cdFx0XHR0aGlzLnRva2VuKCc6JywnOicsY29sb24ubGVuZ3RoKTtcblx0XHRcdHRoaXMubW92ZUNhcmV0KC1pZGxlbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLGlkbGVuKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBsZW47XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIG51bWJlcnMsIGluY2x1ZGluZyBkZWNpbWFscywgaGV4LCBhbmQgZXhwb25lbnRpYWwgbm90YXRpb24uXG5cdC8vIEJlIGNhcmVmdWwgbm90IHRvIGludGVyZmVyZSB3aXRoIHJhbmdlcy1pbi1wcm9ncmVzcy5cblx0TGV4ZXIucHJvdG90eXBlLm51bWJlclRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGJpbmFyeUxpdGVyYWw7XG5cdFx0dmFyIG1hdGNoLG51bWJlcixsZXhlZExlbmd0aDtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IE5VTUJFUi5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHRudW1iZXIgPSBtYXRjaFswXTtcblx0XHRsZXhlZExlbmd0aCA9IG51bWJlci5sZW5ndGg7XG5cdFx0XG5cdFx0aWYgKGJpbmFyeUxpdGVyYWwgPSAvMGIoWzAxXSspLy5leGVjKG51bWJlcikpIHtcblx0XHRcdFxuXHRcdFx0bnVtYmVyID0gXCJcIiArIHBhcnNlSW50KGJpbmFyeUxpdGVyYWxbMV0sMik7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgcHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcblx0XHRpZiAobWF0Y2hbMF1bMF0gPT0gJy4nICYmIHByZXYgJiYgIXByZXYuc3BhY2VkICYmIFsnSURFTlRJRklFUicsJyknLCd9JywnXScsJ05VTUJFUiddLmluZGV4T2YodFQocHJldikpID49IDApIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZ290IGhlcmVcIlxuXHRcdFx0dGhpcy50b2tlbihcIi5cIixcIi5cIik7XG5cdFx0XHRudW1iZXIgPSBudW1iZXIuc3Vic3RyKDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGhpcy50b2tlbignTlVNQkVSJyxudW1iZXIsbGV4ZWRMZW5ndGgpO1xuXHRcdHJldHVybiBsZXhlZExlbmd0aDtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5zeW1ib2xUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxzeW1ib2wscHJldjtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IFNZTUJPTC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRzeW1ib2wgPSBtYXRjaFswXS5zdWJzdHIoMSk7XG5cdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcblx0XHQvLyBpcyB0aGlzIGEgcHJvcGVydHktYWNjZXNzP1xuXHRcdC8vIHNob3VsZCBpbnZlcnQgdGhpcyAtLSBvbmx5IGFsbG93IHdoZW4gcHJldiBJUyAuLiBcblx0XHRcblx0XHQvLyA6IHNob3VsZCBiZSBhIHRva2VuIGl0c2VsZiwgd2l0aCBhIHNwZWNpZmljYXRpb24gb2Ygc3BhY2luZyAoTFIsUixMLE5PTkUpXG5cdFx0XG5cdFx0Ly8gRklYXG5cdFx0aWYgKHByZXYgJiYgIXByZXYuc3BhY2VkICYmIGlkeCQodFQocHJldiksWycoJywneycsJ1snLCcuJywnQ0FMTF9TVEFSVCcsJ0lOREVYX1NUQVJUJywnLCcsJz0nLCdJTkRFTlQnLCdURVJNSU5BVE9SJ10pID09IC0xKSB7XG5cdFx0XHR0aGlzLnRva2VuKCcuOicsJzonLDEpO1xuXHRcdFx0dmFyIHN5bSA9IHN5bWJvbC5zcGxpdCgvW1xcOlxcXFxcXC9dLylbMF07IC8vIHJlYWxseT9cblx0XHRcdC8vIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRoaXMudG9rZW4oJ0lERU5USUZJRVInLHN5bSxzeW0ubGVuZ3RoLDEpO1xuXHRcdFx0cmV0dXJuIChzeW0ubGVuZ3RoICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRoaXMudG9rZW4oJ1NZTUJPTCcsc3ltYm9sLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH07XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuZXNjYXBlU3RyID0gZnVuY3Rpb24gKHN0cixoZXJlZG9jLHEpe1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKE1VTFRJTElORVIsKGhlcmVkb2MgPyAoJ1xcXFxuJykgOiAoJycpKSk7XG5cdFx0aWYgKHEpIHtcblx0XHRcdHZhciByID0gUmVnRXhwKChcIlxcXFxcXFxcW1wiICsgcSArIFwiXVwiKSxcImdcIik7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZShyLHEpO1xuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoUmVnRXhwKChcIlwiICsgcSksXCJnXCIpLCdcXFxcJCYnKTtcblx0XHR9O1xuXHRcdHJldHVybiBzdHI7XG5cdFx0XG5cdFx0Ly8gc3RyID0gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxuJylcblx0XHQvLyBzdHIgPSBzdHIucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG5cdH07XG5cdC8vIE1hdGNoZXMgc3RyaW5ncywgaW5jbHVkaW5nIG11bHRpLWxpbmUgc3RyaW5ncy4gRW5zdXJlcyB0aGF0IHF1b3RhdGlvbiBtYXJrc1xuXHQvLyBhcmUgYmFsYW5jZWQgd2l0aGluIHRoZSBzdHJpbmcncyBjb250ZW50cywgYW5kIHdpdGhpbiBuZXN0ZWQgaW50ZXJwb2xhdGlvbnMuXG5cdExleGVyLnByb3RvdHlwZS5zdHJpbmdUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxzdHJpbmc7XG5cdFx0XG5cdFx0c3dpdGNoICh0aGlzLl9jaHVuay5jaGFyQXQoMCkpIHtcblx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdGlmICghKG1hdGNoID0gU0lNUExFU1RSLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdFx0XHRzdHJpbmcgPSBtYXRjaFswXTtcblx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HJyx0aGlzLmVzY2FwZVN0cihzdHJpbmcpLHN0cmluZy5sZW5ndGgpO1xuXHRcdFx0XHQvLyB0b2tlbiAnU1RSSU5HJywgKHN0cmluZyA9IG1hdGNoWzBdKS5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJyksIHN0cmluZzpsZW5ndGhcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGNhc2UgJ1wiJzpcblx0XHRcdFx0aWYgKCEoc3RyaW5nID0gdGhpcy5iYWxhbmNlZFN0cmluZyh0aGlzLl9jaHVuaywnXCInKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcdFx0Ly8gd2hhdCBhYm91dCB0cmlwZSBxdW90ZWQgc3RyaW5ncz9cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzdHJpbmcuaW5kZXhPZigneycpID49IDApIHtcblx0XHRcdFx0XHR2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0XHQvLyBpZiB0aGlzIGhhcyBubyBpbnRlcnBvbGF0aW9uP1xuXHRcdFx0XHRcdC8vIHdlIGFyZSBub3cgbWVzc2luZyB3aXRoIGxvY2F0aW9ucyAtIGJld2FyZVxuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NUUklOR19TVEFSVCcsc3RyaW5nLmNoYXJBdCgwKSwxKTtcblx0XHRcdFx0XHR0aGlzLmludGVycG9sYXRlU3RyaW5nKHN0cmluZy5zbGljZSgxLC0xKSk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HX0VORCcsc3RyaW5nLmNoYXJBdChsZW4gLSAxKSwxLHN0cmluZy5sZW5ndGggLSAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZW4gPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJylcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTVFJJTkcnLHRoaXMuZXNjYXBlU3RyKHN0cmluZyksbGVuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLm1vdmVIZWFkKHN0cmluZyk7XG5cdFx0cmV0dXJuIHN0cmluZy5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGhlcmVkb2NzLCBhZGp1c3RpbmcgaW5kZW50YXRpb24gdG8gdGhlIGNvcnJlY3QgbGV2ZWwsIGFzIGhlcmVkb2NzXG5cdC8vIHByZXNlcnZlIHdoaXRlc3BhY2UsIGJ1dCBpZ25vcmUgaW5kZW50YXRpb24gdG8gdGhlIGxlZnQuXG5cdExleGVyLnByb3RvdHlwZS5oZXJlZG9jVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsaGVyZWRvYyxxdW90ZSxkb2M7XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBIRVJFRE9DLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdGhlcmVkb2MgPSBtYXRjaFswXTtcblx0XHRxdW90ZSA9IGhlcmVkb2MuY2hhckF0KDApO1xuXHRcdGRvYyA9IHRoaXMuc2FuaXRpemVIZXJlZG9jKG1hdGNoWzJdLHtxdW90ZTogcXVvdGUsaW5kZW50OiBudWxsfSk7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJmb3VuZCBoZXJlZG9jIHttYXRjaFswXTpsZW5ndGh9IHtkb2M6bGVuZ3RofVwiXG5cdFx0XG5cdFx0aWYgKHF1b3RlID09ICdcIicgJiYgZG9jLmluZGV4T2YoJ3snKSA+PSAwKSB7XG5cdFx0XHR2YXIgb3BlbiA9IG1hdGNoWzFdO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgZG9jLnN1YnN0cigwLDMpLG1hdGNoWzFdXG5cdFx0XHR0aGlzLnRva2VuKCdTVFJJTkdfU1RBUlQnLG9wZW4sb3Blbi5sZW5ndGgpO1xuXHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVN0cmluZyhkb2Mse2hlcmVkb2M6IHRydWUsb2Zmc2V0OiBvcGVuLmxlbmd0aCxxdW90ZTogcXVvdGV9KTtcblx0XHRcdHRoaXMudG9rZW4oJ1NUUklOR19FTkQnLG9wZW4sb3Blbi5sZW5ndGgsaGVyZWRvYy5sZW5ndGggLSBvcGVuLmxlbmd0aCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudG9rZW4oJ1NUUklORycsdGhpcy5tYWtlU3RyaW5nKGRvYyxxdW90ZSx0cnVlKSwwKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMubW92ZUhlYWQoaGVyZWRvYyk7XG5cdFx0cmV0dXJuIGhlcmVkb2MubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBhbmQgY29uc3VtZXMgY29tbWVudHMuXG5cdExleGVyLnByb3RvdHlwZS5jb21tZW50VG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsbGVuZ3RoLGNvbW1lbnQsaW5kZW50LHByZXY7XG5cdFx0XG5cdFx0dmFyIHR5cCA9ICdIRVJFQ09NTUVOVCc7XG5cdFx0XG5cdFx0aWYgKG1hdGNoID0gSU5MSU5FX0NPTU1FTlQuZXhlYyh0aGlzLl9jaHVuaykpIHsgLy8gLm1hdGNoKElOTElORV9DT01NRU5UKVxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJtYXRjaCBpbmxpbmUgY29tbWVudFwiXG5cdFx0XHRsZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRpbmRlbnQgPSBtYXRjaFsxXTtcblx0XHRcdGNvbW1lbnQgPSBtYXRjaFsyXTtcblx0XHRcdFxuXHRcdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcdHZhciBwdCA9IHByZXYgJiYgdFQocHJldik7XG5cdFx0XHR2YXIgbm90ZSA9ICcvLycgKyBjb21tZW50LnN1YnN0cigxKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX2xhc3QgJiYgdGhpcy5fbGFzdC5zcGFjZWQpIHtcblx0XHRcdFx0bm90ZSA9ICcgJyArIG5vdGU7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwidGhlIHByZXZpb3VzIG5vZGUgd2FzIFNQQUNFRFwiXG5cdFx0XHR9O1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJjb21tZW50IHtub3RlfSAtIGluZGVudCh7aW5kZW50fSkgLSB7bGVuZ3RofSB7Y29tbWVudDpsZW5ndGh9XCJcblx0XHRcdFxuXHRcdFx0aWYgKChwdCAmJiBwdCAhPSAnSU5ERU5UJyAmJiBwdCAhPSAnVEVSTUlOQVRPUicpIHx8ICFwdCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcInNraXAgY29tbWVudFwiXG5cdFx0XHRcdC8vIHRva2VuICdJTkxJTkVDT01NRU5UJywgY29tbWVudC5zdWJzdHIoMilcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgYXMgdGVybWluYXRvclwiXG5cdFx0XHRcdHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLG5vdGUsbGVuZ3RoKTsgLy8gKyAnXFxuJ1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGQgY29tbWVudCAoe25vdGV9KVwiXG5cdFx0XHRcdGlmIChwdCA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0XHR0VnMocHJldix0VihwcmV2KSArIG5vdGUpO1xuXHRcdFx0XHRcdC8vIHByZXZbMV0gKz0gbm90ZVxuXHRcdFx0XHR9IGVsc2UgaWYgKHB0ID09ICdJTkRFTlQnKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgY29tbWVudCB0byBJTkRFTlQ6IHtub3RlfVwiICMgd2h5IG5vdCBhZGQgZGlyZWN0bHkgaGVyZT9cblx0XHRcdFx0XHR0aGlzLmFkZExpbmVicmVha3MoMSxub3RlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImNvbW1lbnQgaGVyZVwiXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHdlIGV2ZXIgZ2V0IGhlcmU/XG5cdFx0XHRcdFx0dGhpcy50b2tlbih0eXAsY29tbWVudC5zdWJzdHIoMiksbGVuZ3RoKTsgLy8gYXJlIHdlIHN1cmU/XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGVuZ3RoOyAvLyBkaXNhYmxlIG5vdyB3aGlsZSBjb21waWxpbmdcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCB1c2UgZXhlYz9cblx0XHRpZiAoIShtYXRjaCA9IENPTU1FTlQuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0Y29tbWVudCA9IG1hdGNoWzBdO1xuXHRcdHZhciBoZXJlID0gbWF0Y2hbMV07XG5cdFx0XG5cdFx0aWYgKGhlcmUpIHtcblx0XHRcdHRoaXMudG9rZW4oJ0hFUkVDT01NRU5UJyx0aGlzLnNhbml0aXplSGVyZWRvYyhoZXJlLHtoZXJlY29tbWVudDogdHJ1ZSxpbmRlbnQ6IEFycmF5KHRoaXMuX2luZGVudCArIDEpLmpvaW4oJyAnKX0pLGNvbW1lbnQubGVuZ3RoKTtcblx0XHRcdHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLCdcXG4nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50b2tlbignSEVSRUNPTU1FTlQnLGNvbW1lbnQsY29tbWVudC5sZW5ndGgpO1xuXHRcdFx0dGhpcy50b2tlbignVEVSTUlOQVRPUicsJ1xcbicpOyAvLyBhdXRvPyByZWFsbHk/XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLm1vdmVIZWFkKGNvbW1lbnQpO1xuXHRcdHJldHVybiBjb21tZW50Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgSmF2YVNjcmlwdCBpbnRlcnBvbGF0ZWQgZGlyZWN0bHkgaW50byB0aGUgc291cmNlIHZpYSBiYWNrdGlja3MuXG5cdExleGVyLnByb3RvdHlwZS5qc1Rva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLHNjcmlwdDtcblx0XHRcblx0XHRpZiAoISh0aGlzLl9jaHVuay5jaGFyQXQoMCkgPT0gJ2AnICYmIChtYXRjaCA9IEpTVE9LRU4uZXhlYyh0aGlzLl9jaHVuaykpKSkgeyByZXR1cm4gMCB9O1xuXHRcdHRoaXMudG9rZW4oJ0pTJywoc2NyaXB0ID0gbWF0Y2hbMF0pLnNsaWNlKDEsLTEpKTtcblx0XHRyZXR1cm4gc2NyaXB0Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxzLiBMZXhpbmcgcmVndWxhciBleHByZXNzaW9ucyBpcyBkaWZmaWN1bHRcblx0Ly8gdG8gZGlzdGluZ3Vpc2ggZnJvbSBkaXZpc2lvbiwgc28gd2UgYm9ycm93IHNvbWUgYmFzaWMgaGV1cmlzdGljcyBmcm9tXG5cdC8vIEphdmFTY3JpcHQgYW5kIFJ1YnkuXG5cdExleGVyLnByb3RvdHlwZS5yZWdleFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyeTtcblx0XHR2YXIgbWF0Y2gsbGVuZ3RoLHByZXY7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2NodW5rLmNoYXJBdCgwKSAhPSAnLycpIHsgcmV0dXJuIDAgfTtcblx0XHRpZiAobWF0Y2ggPSBIRVJFR0VYLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRsZW5ndGggPSB0aGlzLmhlcmVnZXhUb2tlbihtYXRjaCk7XG5cdFx0XHR0aGlzLm1vdmVIZWFkKG1hdGNoWzBdKTtcblx0XHRcdHJldHVybiBsZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHRwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdC8vIEZJWFxuXHRcdGlmIChwcmV2ICYmIChpZHgkKHRUKHByZXYpLChwcmV2LnNwYWNlZCA/IChcblx0XHRcdE5PVF9SRUdFWFxuXHRcdCkgOiAoXG5cdFx0XHROT1RfU1BBQ0VEX1JFR0VYXG5cdFx0KSkpID49IDApKSB7IHJldHVybiAwIH07XG5cdFx0aWYgKCEobWF0Y2ggPSBSRUdFWC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBtID0gYXJ5WzBdLHJlZ2V4ID0gYXJ5WzFdLGZsYWdzID0gYXJ5WzJdO1xuXHRcdFxuXHRcdC8vIEZJWE1FXG5cdFx0Ly8gaWYgcmVnZXhbLi4xXSBpcyAnLyonXG5cdFx0Ly9cdGVycm9yICdyZWd1bGFyIGV4cHJlc3Npb25zIGNhbm5vdCBiZWdpbiB3aXRoIGAqYCdcblx0XHRcblx0XHRpZiAocmVnZXggPT0gJy8vJykge1xuXHRcdFx0cmVnZXggPSAnLyg/OikvJztcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMudG9rZW4oJ1JFR0VYJywoXCJcIiArIHJlZ2V4ICsgZmxhZ3MpLG0ubGVuZ3RoKTtcblx0XHRyZXR1cm4gbS5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIG11bHRpbGluZSBleHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuXHQvLyBUaGUgZXNjYXBpbmcgc2hvdWxkIHJhdGhlciBoYXBwZW4gaW4gQVNUIC0gcG9zc2libHkgYXMgYW4gYWRkaXRpb25hbCBmbGFnP1xuXHRMZXhlci5wcm90b3R5cGUuaGVyZWdleFRva2VuID0gZnVuY3Rpb24gKG1hdGNoKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBhcnkgPSBpdGVyJChtYXRjaCk7dmFyIGhlcmVnZXggPSBhcnlbMF0sYm9keSA9IGFyeVsxXSxmbGFncyA9IGFyeVsyXTtcblx0XHRcblx0XHRpZiAoMCA+IGJvZHkuaW5kZXhPZignI3snKSkge1xuXHRcdFx0XG5cdFx0XHR2YXIgcmUgPSBib2R5LnJlcGxhY2UoSEVSRUdFWF9PTUlULCcnKS5yZXBsYWNlKC9cXC8vZywnXFxcXC8nKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlLm1hdGNoKC9eXFwqLykpIHtcblx0XHRcdFx0dGhpcy5lcnJvcigncmVndWxhciBleHByZXNzaW9ucyBjYW5ub3QgYmVnaW4gd2l0aCBgKmAnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMudG9rZW4oJ1JFR0VYJywoXCIvXCIgKyAocmUgfHwgJyg/OiknKSArIFwiL1wiICsgZmxhZ3MpLGhlcmVnZXgubGVuZ3RoKTtcblx0XHRcdHJldHVybiBoZXJlZ2V4Lmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHVzZSBtb3JlIGJhc2ljIHJlZ2V4IHR5cGVcblx0XHRcblx0XHR0aGlzLnRva2VuKCdDT05TVCcsJ1JlZ0V4cCcpO1xuXHRcdHRoaXMuX3Rva2Vucy5wdXNoKFQudG9rZW4oJ0NBTExfU1RBUlQnLCcoJywwKSk7XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBpdGVtcyA9IGl0ZXIkKHRoaXMuaW50ZXJwb2xhdGVTdHJpbmcoYm9keSx7cmVnZXg6IHRydWV9KSksIGxlbiA9IGl0ZW1zLmxlbmd0aCwgcGFpcjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcblx0XHRcdHBhaXIgPSBpdGVtc1tpXTtcblx0XHRcdHZhciB0b2sgPSB0VChwYWlyKTsgLy8gRklYXG5cdFx0XHR2YXIgdmFsdWUgPSB0VihwYWlyKTsgLy8gRklYXG5cdFx0XHRcblx0XHRcdGlmICh0b2sgPT0gJ1RPS0VOUycpIHtcblx0XHRcdFx0Ly8gRklYTUUgd2hhdCBpcyB0aGlzP1xuXHRcdFx0XHR0b2tlbnMucHVzaC5hcHBseSh0b2tlbnMsdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwid2hhdD8/XCIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCEodmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEhFUkVHRVhfT01JVCwnJykpKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csJ1xcXFxcXFxcJyk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKFQudG9rZW4oJ1NUUklORycsdGhpcy5tYWtlU3RyaW5nKHZhbHVlLCdcIicsdHJ1ZSksMCkpOyAvLyBGSVhcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRva2Vucy5wdXNoKFQudG9rZW4oJysnLCcrJywwKSk7IC8vIEZJWFxuXHRcdH07XG5cdFx0XG5cdFx0dG9rZW5zLnBvcCgpO1xuXHRcdFxuXHRcdC8vIEZJWFxuXHRcdGlmICghKHRva2Vuc1swXSAmJiB0VCh0b2tlbnNbMF0pID09ICdTVFJJTkcnKSkge1xuXHRcdFx0Ly8gRklYXG5cdFx0XHR0aGlzLl90b2tlbnMucHVzaChULnRva2VuKCdTVFJJTkcnLCdcIlwiJyksVC50b2tlbignKycsJysnKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl90b2tlbnMucHVzaC5hcHBseSh0aGlzLl90b2tlbnMsdG9rZW5zKTsgLy8gd2hhdCBpcyB0aGlzP1xuXHRcdC8vIEZJWFxuXHRcdFxuXHRcdGlmIChmbGFncykge1xuXHRcdFx0dGhpcy5fdG9rZW5zLnB1c2goVC50b2tlbignLCcsJywnLDApKTtcblx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKFQudG9rZW4oJ1NUUklORycsJ1wiJyArIGZsYWdzICsgJ1wiJywwKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRva2VuKCcpJywnKScsMCk7XG5cdFx0XG5cdFx0cmV0dXJuIGhlcmVnZXgubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBuZXdsaW5lcywgaW5kZW50cywgYW5kIG91dGRlbnRzLCBhbmQgZGV0ZXJtaW5lcyB3aGljaCBpcyB3aGljaC5cblx0Ly8gSWYgd2UgY2FuIGRldGVjdCB0aGF0IHRoZSBjdXJyZW50IGxpbmUgaXMgY29udGludWVkIG9udG8gdGhlIHRoZSBuZXh0IGxpbmUsXG5cdC8vIHRoZW4gdGhlIG5ld2xpbmUgaXMgc3VwcHJlc3NlZDpcblx0Ly9cblx0Ly8gICAgIGVsZW1lbnRzXG5cdC8vICAgICAgIC5lYWNoKCAuLi4gKVxuXHQvLyAgICAgICAubWFwKCAuLi4gKVxuXHQvL1xuXHQvLyBLZWVwcyB0cmFjayBvZiB0aGUgbGV2ZWwgb2YgaW5kZW50YXRpb24sIGJlY2F1c2UgYSBzaW5nbGUgb3V0ZGVudCB0b2tlblxuXHQvLyBjYW4gY2xvc2UgbXVsdGlwbGUgaW5kZW50cywgc28gd2UgbmVlZCB0byBrbm93IGhvdyBmYXIgaW4gd2UgaGFwcGVuIHRvIGJlLlxuXHRMZXhlci5wcm90b3R5cGUubGluZVRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gTVVMVElfREVOVC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHQvLyBzaG91bGQgaXQgbm90IHBhaXIgYnkgaXRzZWxmIHRva2VuKCdTRUxFQ1RPUl9FTkQnLCclJywwKVxuXHRcdC8vIGlmIEBlbmQgPT0gJyUnXG5cdFx0Ly8gXHRjb25zb2xlLmxvZyBcInBhaXJpbmcgc2VsZWN0b3IgaW4gbGluZVRva2VuIHtAY2h1bmsuc3Vic3RyKDAsMTApfVwiXG5cdFx0Ly8gXHQjIHNob3VsZCBub3QgbmVlZCB0byBhZGQgYW55dGhpbmcgaGVyZT9cblx0XHQvLyBcdHBhaXIoJyUnKVxuXHRcdFxuXHRcdHZhciBpbmRlbnQgPSBtYXRjaFswXTtcblx0XHQvLyB2YXIgYnJDb3VudCA9IGNvdW50IGluZGVudCwgJ1xcbidcblx0XHR2YXIgYnJDb3VudCA9IHRoaXMubW92ZUhlYWQoaW5kZW50KTtcblx0XHR0aGlzLl9zZWVuRm9yID0gZmFsc2U7XG5cdFx0Ly8gcmVzZXQgY29sdW1uIGFzIHdlbGw/XG5cdFx0XG5cdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2VucywxKTtcblx0XHR2YXIgc2l6ZSA9IGluZGVudC5sZW5ndGggLSAxIC0gaW5kZW50Lmxhc3RJbmRleE9mKCdcXG4nKTtcblx0XHR2YXIgbm9OZXdsaW5lcyA9IHRoaXMudW5maW5pc2hlZCgpO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwibm9OZXdsaW5lc1wiLG5vTmV3bGluZXNcblx0XHQvLyBjb25zb2xlLmxvZyBcImxpbmVUb2tlbiAtLSBcIixAY2h1bmsuc3Vic3RyKDAsMTApLFwiLS1cIlxuXHRcdGlmICgoL15cXG4jXFxzLykudGVzdCh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHRoaXMuYWRkTGluZWJyZWFrcygxKTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHNpemUgLSB0aGlzLl9pbmRlYnQgPT0gdGhpcy5faW5kZW50KSB7XG5cdFx0XHRpZiAobm9OZXdsaW5lcykge1xuXHRcdFx0XHR0aGlzLnN1cHByZXNzTmV3bGluZXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubmV3bGluZVRva2VuKGJyQ291bnQpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBpbmRlbnQubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHNpemUgPiB0aGlzLl9pbmRlbnQpIHtcblx0XHRcdGlmIChub05ld2xpbmVzKSB7XG5cdFx0XHRcdHRoaXMuX2luZGVidCA9IHNpemUgLSB0aGlzLl9pbmRlbnQ7XG5cdFx0XHRcdHRoaXMuc3VwcHJlc3NOZXdsaW5lcygpO1xuXHRcdFx0XHRyZXR1cm4gaW5kZW50Lmxlbmd0aDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmluVGFnKCkpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJpbmRlbnQgaW5zaWRlIHRva2lkPyE/XCJcblx0XHRcdFx0Ly8gQGluZGVidCA9IHNpemUgLSBAaW5kZW50XG5cdFx0XHRcdC8vIHN1cHByZXNzTmV3bGluZXMoKVxuXHRcdFx0XHRyZXR1cm4gaW5kZW50Lmxlbmd0aDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dmFyIGRpZmYgPSBzaXplIC0gdGhpcy5faW5kZW50ICsgdGhpcy5fb3V0ZGVidDtcblx0XHRcdHRoaXMuY2xvc2VEZWYoKTtcblx0XHRcdFxuXHRcdFx0dmFyIGltbWVkaWF0ZSA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcdFxuXHRcdFx0aWYgKGltbWVkaWF0ZSAmJiB0VChpbW1lZGlhdGUpID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHR0VHMoaW1tZWRpYXRlLCdJTkRFTlQnKTtcblx0XHRcdFx0aW1tZWRpYXRlLl9tZXRhIHx8IChpbW1lZGlhdGUuX21ldGEgPSB7cHJlOiB0VihpbW1lZGlhdGUpLHBvc3Q6ICcnfSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBzaG91bGQgcmF0aGVyIGFkZCB0byBtZXRhIHNvbWVob3c/IT9cblx0XHRcdFx0Ly8gdFZzKGltbWVkaWF0ZSx0VihpbW1lZGlhdGUpICsgJyV8JScpICMgY3Jhenlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0lOREVOVCcsXCJcIiArIGRpZmYsMCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImluZGVudGluZ1wiLCBwcmV2LCBsYXN0KEB0b2tlbnMsMSlcblx0XHRcdC8vIGlmIHByZXYgYW5kIHByZXZbMF0gPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHQvLyAgIGNvbnNvbGUubG9nIFwidGVybWluYXRvciBiZWZvcmUgaW5kZW50Pz9cIlxuXHRcdFx0XG5cdFx0XHQvLyBjaGVjayBmb3IgY29tbWVudHMgYXMgd2VsbCA/XG5cdFx0XHRcblx0XHRcdHRoaXMuX2luZGVudHMucHVzaChkaWZmKTtcblx0XHRcdHRoaXMucHVzaEVuZCgnT1VUREVOVCcpO1xuXHRcdFx0Ly8gQGVuZHMucHVzaCAnT1VUREVOVCdcblx0XHRcdHRoaXMuX291dGRlYnQgPSB0aGlzLl9pbmRlYnQgPSAwO1xuXHRcdFx0dGhpcy5hZGRMaW5lYnJlYWtzKGJyQ291bnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbmRlYnQgPSAwO1xuXHRcdFx0dGhpcy5vdXRkZW50VG9rZW4odGhpcy5faW5kZW50IC0gc2l6ZSxub05ld2xpbmVzLGJyQ291bnQpO1xuXHRcdFx0dGhpcy5hZGRMaW5lYnJlYWtzKGJyQ291bnQgLSAxKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwib3V0ZGVudFwiLG5vTmV3bGluZXMsdG9raWQoKVxuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5faW5kZW50ID0gc2l6ZTtcblx0XHRyZXR1cm4gaW5kZW50Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIFJlY29yZCBhbiBvdXRkZW50IHRva2VuIG9yIG11bHRpcGxlIHRva2VucywgaWYgd2UgaGFwcGVuIHRvIGJlIG1vdmluZyBiYWNrXG5cdC8vIGlud2FyZHMgcGFzdCBzZXZlcmFsIHJlY29yZGVkIGluZGVudHMuXG5cdExleGVyLnByb3RvdHlwZS5vdXRkZW50VG9rZW4gPSBmdW5jdGlvbiAobW92ZU91dCxub05ld2xpbmVzLG5ld2xpbmVDb3VudCl7XG5cdFx0Ly8gaGVyZSB3ZSBzaG91bGQgYWxzbyB0YWtlIGNhcmUgdG8gcG9wIC8gcmVzZXQgdGhlIHNjb3BlLWJvZHlcblx0XHQvLyBvciBjb250ZXh0LXR5cGUgZm9yIGluZGVudGF0aW9uIFxuXHRcdHZhciBkZW50ID0gMDtcblx0XHR3aGlsZSAobW92ZU91dCA+IDApe1xuXHRcdFx0dmFyIGxlbiA9IHRoaXMuX2luZGVudHMubGVuZ3RoIC0gMTtcblx0XHRcdGlmICh0aGlzLl9pbmRlbnRzW2xlbl0gPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG1vdmVPdXQgPSAwO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9pbmRlbnRzW2xlbl0gPT0gdGhpcy5fb3V0ZGVidCkge1xuXHRcdFx0XHRtb3ZlT3V0IC09IHRoaXMuX291dGRlYnQ7XG5cdFx0XHRcdHRoaXMuX291dGRlYnQgPSAwO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9pbmRlbnRzW2xlbl0gPCB0aGlzLl9vdXRkZWJ0KSB7XG5cdFx0XHRcdHRoaXMuX291dGRlYnQgLT0gdGhpcy5faW5kZW50c1tsZW5dO1xuXHRcdFx0XHRtb3ZlT3V0IC09IHRoaXMuX2luZGVudHNbbGVuXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbnQgPSB0aGlzLl9pbmRlbnRzLnBvcCgpIC0gdGhpcy5fb3V0ZGVidDtcblx0XHRcdFx0bW92ZU91dCAtPSBkZW50O1xuXHRcdFx0XHR0aGlzLl9vdXRkZWJ0ID0gMDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghbm9OZXdsaW5lcykgeyB0aGlzLmFkZExpbmVicmVha3MoMSkgfTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMucGFpcignT1VUREVOVCcpO1xuXHRcdFx0XHR0aGlzLnRva2VuKCdPVVRERU5UJyxcIlwiICsgZGVudCwwKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoZGVudCkgeyB0aGlzLl9vdXRkZWJ0IC09IG1vdmVPdXQgfTtcblx0XHRcblx0XHR3aGlsZSAodGhpcy5sYXN0VG9rZW5WYWx1ZSgpID09ICc7Jyl7XG5cdFx0XHR0aGlzLl90b2tlbnMucG9wKCk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoISh0aGlzLmxhc3RUb2tlblR5cGUoKSA9PSAnVEVSTUlOQVRPUicgfHwgbm9OZXdsaW5lcykpIHsgdGhpcy50b2tlbignVEVSTUlOQVRPUicsJ1xcbicsMCkgfTtcblx0XHRcblx0XHQvLyBjYXBwaW5nIHNjb3BlcyBzbyB0aGV5IGRvbnQgaGFuZyBhcm91bmQgXG5cdFx0dGhpcy5fc2NvcGVzLmxlbmd0aCA9IHRoaXMuX2luZGVudHMubGVuZ3RoO1xuXHRcdFxuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQoKTtcblx0XHRpZiAoY3R4ID09ICclJyB8fCBjdHggPT0gJ1RBRycpIHsgdGhpcy5wYWlyKGN0eCkgfTsgLy8gcmVhbGx5P1xuXHRcdHRoaXMuY2xvc2VEZWYoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgYW5kIGNvbnN1bWVzIG5vbi1tZWFuaW5nZnVsIHdoaXRlc3BhY2UuIHRva2lkIHRoZSBwcmV2aW91cyB0b2tlblxuXHQvLyBhcyBiZWluZyBcInNwYWNlZFwiLCBiZWNhdXNlIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIGl0IG1ha2VzIGEgZGlmZmVyZW5jZS5cblx0TGV4ZXIucHJvdG90eXBlLndoaXRlc3BhY2VUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxubGluZSxwcmV2O1xuXHRcdGlmICghKChtYXRjaCA9IFdISVRFU1BBQ0UuZXhlYyh0aGlzLl9jaHVuaykpIHx8IChubGluZSA9IHRoaXMuX2NodW5rLmNoYXJBdCgwKSA9PSAnXFxuJykpKSB7IHJldHVybiAwIH07XG5cdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcblx0XHQvLyBGSVggLSB3aHkgb2ggd2h5P1xuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0cHJldi5zcGFjZWQgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJldi5uZXdMaW5lID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuYWRkTmV3bGluZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnRva2VuKCdURVJNSU5BVE9SJywnXFxuJyk7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUubW92ZUhlYWQgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHR2YXIgYnIgPSBjb3VudChzdHIsJ1xcbicpO1xuXHRcdHJldHVybiBicjtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuYWRkTGluZWJyZWFrcyA9IGZ1bmN0aW9uIChjb3VudCxyYXcpe1xuXHRcdHZhciBicjtcblx0XHRcblx0XHRpZiAoIXJhdyAmJiBjb3VudCA9PSAwKSB7IHJldHVybiB0aGlzIH07IC8vIG5vIHRlcm1pbmF0b3JzP1xuXHRcdFxuXHRcdHZhciBwcmV2ID0gdGhpcy5fbGFzdDtcblx0XHRcblx0XHRpZiAoIXJhdykge1xuXHRcdFx0aWYgKGNvdW50ID09IDEpIHtcblx0XHRcdFx0YnIgPSAnXFxuJztcblx0XHRcdH0gZWxzZSBpZiAoY291bnQgPT0gMikge1xuXHRcdFx0XHRiciA9ICdcXG5cXG4nO1xuXHRcdFx0fSBlbHNlIGlmIChjb3VudCA9PSAzKSB7XG5cdFx0XHRcdGJyID0gJ1xcblxcblxcbic7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiciA9IHJlcGVhdFN0cmluZygnXFxuJyxjb3VudCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Ly8gRklYXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHZhciB0ID0gcHJldi5fdHlwZTsgLy8gQGxhc3RUeXBcblx0XHRcdHZhciB2ID0gdFYocHJldik7XG5cdFx0XHRcblx0XHRcdC8vIHdlIHJlYWxseSB3YW50IHRvIGFkZCB0aGlzXG5cdFx0XHRpZiAodCA9PSAnSU5ERU5UJykge1xuXHRcdFx0XHQvLyBUT0RPIHdlIHdhbnQgdG8gYWRkIHRvIHRoZSBpbmRlbnRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGQgdGhlIGNvbW1lbnQgdG8gdGhlIGluZGVudCAtLSBwcmU/IHtyYXd9IHticn1cIlxuXHRcdFx0XHRcblx0XHRcdFx0dmFyIG1ldGEgPSBwcmV2Ll9tZXRhIHx8IChwcmV2Ll9tZXRhID0ge3ByZTogJycscG9zdDogJyd9KTtcblx0XHRcdFx0bWV0YS5wb3N0ICs9IChyYXcgfHwgYnIpO1xuXHRcdFx0XHQvLyB0VnModiArIChyYXcgb3IgYnIpKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodCA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhbHJlYWR5IGV4aXN0cyB0ZXJtaW5hdG9yIHticn0ge3Jhd31cIlxuXHRcdFx0XHR0VnMocHJldix2ICsgKHJhdyB8fCBicikpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRva2VuKCdURVJNSU5BVE9SJyxiciwwKTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBHZW5lcmF0ZSBhIG5ld2xpbmUgdG9rZW4uIENvbnNlY3V0aXZlIG5ld2xpbmVzIGdldCBtZXJnZWQgdG9nZXRoZXIuXG5cdExleGVyLnByb3RvdHlwZS5uZXdsaW5lVG9rZW4gPSBmdW5jdGlvbiAobGluZXMpe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwibmV3bGluZVRva2VuXCJcblx0XHR3aGlsZSAodGhpcy5sYXN0VG9rZW5WYWx1ZSgpID09ICc7Jyl7XG5cdFx0XHRjb25zb2xlLmxvZyhcInBvcCB0b2tlblwiLHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0dGhpcy5fdG9rZW5zLnBvcCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5hZGRMaW5lYnJlYWtzKGxpbmVzKTtcblx0XHRcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0KCk7XG5cdFx0Ly8gV0FSTiBub3cgaW1wb3J0IGNhbm5vdCBnbyBvdmVyIG11bHRpcGxlIGxpbmVzXG5cdFx0aWYgKGN0eCA9PSAnVEFHJyB8fCBjdHggPT0gJ0lNUE9SVCcpIHsgdGhpcy5wYWlyKGN0eCkgfTtcblx0XHR0aGlzLmNsb3NlRGVmKCk7IC8vIGNsb3NlIGRlZiAtLSByZWFsbHk/XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBVc2UgYSBgXFxgIGF0IGEgbGluZS1lbmRpbmcgdG8gc3VwcHJlc3MgdGhlIG5ld2xpbmUuXG5cdC8vIFRoZSBzbGFzaCBpcyByZW1vdmVkIGhlcmUgb25jZSBpdHMgam9iIGlzIGRvbmUuXG5cdExleGVyLnByb3RvdHlwZS5zdXBwcmVzc05ld2xpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMudmFsdWUoKSA9PSAnXFxcXCcpIHsgdGhpcy5fdG9rZW5zLnBvcCgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBXZSB0cmVhdCBhbGwgb3RoZXIgc2luZ2xlIGNoYXJhY3RlcnMgYXMgYSB0b2tlbi4gRS5nLjogYCggKSAsIC4gIWBcblx0Ly8gTXVsdGktY2hhcmFjdGVyIG9wZXJhdG9ycyBhcmUgYWxzbyBsaXRlcmFsIHRva2Vucywgc28gdGhhdCBKaXNvbiBjYW4gYXNzaWduXG5cdC8vIHRoZSBwcm9wZXIgb3JkZXIgb2Ygb3BlcmF0aW9ucy4gVGhlcmUgYXJlIHNvbWUgc3ltYm9scyB0aGF0IHdlIHRva2lkIHNwZWNpYWxseVxuXHQvLyBoZXJlLiBgO2AgYW5kIG5ld2xpbmVzIGFyZSBib3RoIHRyZWF0ZWQgYXMgYSBgVEVSTUlOQVRPUmAsIHdlIGRpc3Rpbmd1aXNoXG5cdC8vIHBhcmVudGhlc2VzIHRoYXQgaW5kaWNhdGUgYSBtZXRob2QgY2FsbCBmcm9tIHJlZ3VsYXIgcGFyZW50aGVzZXMsIGFuZCBzbyBvbi5cblx0TGV4ZXIucHJvdG90eXBlLmxpdGVyYWxUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCx2YWx1ZTtcblx0XHRpZiAobWF0Y2ggPSBPUEVSQVRPUi5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dmFsdWUgPSBtYXRjaFswXTtcblx0XHRcdGlmIChDT0RFLnRlc3QodmFsdWUpKSB0aGlzLnRhZ1BhcmFtZXRlcnMoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9jaHVuay5jaGFyQXQoMCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgZW5kMSA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgZW5kMiA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAyXTtcblx0XHRcblx0XHR2YXIgaW5UYWcgPSBlbmQxID09ICdUQUdfRU5EJyB8fCBlbmQxID09ICdPVVRERU5UJyAmJiBlbmQyID09ICdUQUdfRU5EJztcblx0XHRcblx0XHR2YXIgdG9raWQgPSB2YWx1ZTtcblx0XHR2YXIgcHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHR2YXIgcHQgPSBwcmV2ICYmIHRUKHByZXYpO1xuXHRcdHZhciBwdiA9IHByZXYgJiYgdFYocHJldik7XG5cdFx0dmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcblx0XHQvLyBpcyB0aGlzIG5lZWRlZD9cblx0XHRpZiAodmFsdWUgPT0gJz0nICYmIHByZXYpIHtcblx0XHRcdFxuXHRcdFx0aWYgKHB2ID09ICd8fCcgfHwgcHYgPT0gJyYmJykgeyAvLyBpbiBbJ3x8JywgJyYmJ11cblx0XHRcdFx0dFRzKHByZXYsJ0NPTVBPVU5EX0FTU0lHTicpO1xuXHRcdFx0XHR0VnMocHJldixwdiArICc9Jyk7XG5cdFx0XHRcdC8vIHByZXZbMF0gPSAnQ09NUE9VTkRfQVNTSUdOJ1xuXHRcdFx0XHQvLyBwcmV2WzFdICs9ICc9J1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh2YWx1ZSA9PSAnOycpIHtcblx0XHRcdHRoaXMuX3NlZW5Gb3IgPSBmYWxzZTtcblx0XHRcdHRva2lkID0gJ1RFUk1JTkFUT1InO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJygnICYmIGluVGFnICYmIHB0ICE9ICc9JyAmJiBwcmV2LnNwYWNlZCkgeyAvLyBGSVhlZFxuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3NwYWNlZCBiZWZvcmUgKCBpbiB0b2tpZCdcblx0XHRcdC8vIEZJWE1FIC0gc2hvdWxkIHJhdGhlciBhZGQgYSBzcGVjaWFsIHRva2VuIGxpa2UgVEFHX1BBUkFNU19TVEFSVFxuXHRcdFx0dGhpcy50b2tlbignLCcsJywnKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICctPicgJiYgaW5UYWcpIHtcblx0XHRcdHRva2lkID0gJ1RBR19FTkQnO1xuXHRcdFx0dGhpcy5wYWlyKCdUQUdfRU5EJyk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnLz4nICYmIGluVGFnKSB7XG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJztcblx0XHRcdHRoaXMucGFpcignVEFHX0VORCcpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJz4nICYmIGluVGFnKSB7XG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJztcblx0XHRcdHRoaXMucGFpcignVEFHX0VORCcpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJz4nICYmIHRoaXMuY29udGV4dCgpID09ICdERUYnKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygncGlja2VkIHVwID4hIScpXG5cdFx0XHR0b2tpZCA9ICdERUZfRlJBR01FTlQnO1xuXHRcdFx0XG5cdFx0XHQvLyBlbGlmIHZhbHVlIGlzICdURVJNSU5BVE9SJyBhbmQgZW5kMSBpcyAnJScgXG5cdFx0XHQvLyBcdGNsb3NlU2VsZWN0b3IoKVxuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJ1RFUk1JTkFUT1InICYmIGVuZDEgPT0gJ0RFRicpIHtcblx0XHRcdHRoaXMuY2xvc2VEZWYoKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICcmJyAmJiB0aGlzLmNvbnRleHQoKSA9PSAnREVGJykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJva2F5IVwiKVxuXHRcdFx0dG9raWQgPSAnQkxPQ0tfQVJHJztcblx0XHRcdC8vIGNoYW5nZSB0aGUgbmV4dCBpZGVudGlmaWVyIGluc3RlYWQ/XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnKicgJiYgdGhpcy5fY2h1bmsuY2hhckF0KDEpLm1hdGNoKC9bQS1aYS16XFxfXFxAXFxbXS8pICYmIChwcmV2LnNwYWNlZCB8fCBbJywnLCcoJywnWycsJ3snLCd8JywnXFxuJywnXFx0J10uaW5kZXhPZihwdikgPj0gMCkpIHtcblx0XHRcdHRva2lkID0gXCJTUExBVFwiO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJ+KImicpIHtcblx0XHRcdHRva2lkID0gJ1NRUlQnO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJ8aSJykge1xuXHRcdFx0dG9raWQgPSAnRlVOQyc7XG5cdFx0fSBlbHNlIGlmIChpZHgkKHZhbHVlLE1BVEgpID49IDApIHtcblx0XHRcdHRva2lkID0gJ01BVEgnO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxDT01QQVJFKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdDT01QQVJFJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsQ09NUE9VTkRfQVNTSUdOKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdDT01QT1VORF9BU1NJR04nO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxVTkFSWSkgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnVU5BUlknO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxTSElGVCkgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnU0hJRlQnO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxMT0dJQykgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnTE9HSUMnOyAvLyBvciB2YWx1ZSBpcyAnPycgYW5kIHByZXY/OnNwYWNlZCBcblx0XHR9IGVsc2UgaWYgKHByZXYgJiYgIXByZXYuc3BhY2VkKSB7XG5cdFx0XHQvLyBuZWVkIGEgYmV0dGVyIHdheSB0byBkbyB0aGVzZVxuXHRcdFx0aWYgKHZhbHVlID09ICcoJyAmJiBlbmQxID09ICclJykge1xuXHRcdFx0XHR0b2tpZCA9ICdUQUdfQVRUUlNfU1RBUlQnO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnKCcgJiYgaWR4JChwdCxDQUxMQUJMRSkgPj0gMCkge1xuXHRcdFx0XHQvLyBub3QgdXNpbmcgdGhpcyA/Pz9cblx0XHRcdFx0Ly8gcHJldlswXSA9ICdGVU5DX0VYSVNUJyBpZiBwcmV2WzBdIGlzICc/J1xuXHRcdFx0XHR0b2tpZCA9ICdDQUxMX1NUQVJUJztcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJ1snICYmIGlkeCQocHQsSU5ERVhBQkxFKSA+PSAwKSB7XG5cdFx0XHRcdHRva2lkID0gJ0lOREVYX1NUQVJUJztcblx0XHRcdFx0aWYgKHB0ID09ICc/JykgeyB0VHMocHJldiwnSU5ERVhfU09BSycpIH07XG5cdFx0XHRcdC8vIHByZXZbMF0gPSAnSU5ERVhfU09BSycgaWYgcHJldlswXSA9PSAnPydcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRzd2l0Y2ggKHZhbHVlKSB7XG5cdFx0XHRjYXNlICcoJzpcblx0XHRcdGNhc2UgJ3snOlxuXHRcdFx0Y2FzZSAnWyc6XG5cdFx0XHRcdHRoaXMucHVzaEVuZChJTlZFUlNFU1t2YWx1ZV0pO2JyZWFrO1xuXHRcdFx0XG5cdFx0XHRjYXNlICcpJzpcblx0XHRcdGNhc2UgJ30nOlxuXHRcdFx0Y2FzZSAnXSc6XG5cdFx0XHRcdHRoaXMucGFpcih2YWx1ZSk7YnJlYWs7XG5cdFx0XG5cdFx0fTtcblx0XHRcblx0XHQvLyBoYWNreSBydWxlIHRvIHRyeSB0byBhbGxvdyBmb3IgdHVwbGUtYXNzaWdubWVudHMgaW4gYmxvY2tzXG5cdFx0Ly8gaWYgdmFsdWUgaXMgJywnIGFuZCBwcmV2WzBdIGlzICdJREVOVElGSUVSJyBhbmQgQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDJdWzBdIGluIFsnVEVSTUlOQVRPUicsJ0lOREVOVCddXG5cdFx0Ly8gICAjIHRva2VuIFwiVFVQTEVcIiwgXCJ0dXBsZVwiICMgc2hvdWxkIHJhdGhlciBpbnNlcnQgaXQgc29tZXdoZXJlIGVsc2UsIG5vP1xuXHRcdC8vICAgY29uc29sZS5sb2coXCJmb3VuZCBjb21tYVwiKVxuXHRcdFxuXHRcdHRoaXMudG9rZW4odG9raWQsdmFsdWUsdmFsdWUubGVuZ3RoKTtcblx0XHRyZXR1cm4gdmFsdWUubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gVG9rZW4gTWFuaXB1bGF0b3JzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcblx0Ly8gU2FuaXRpemUgYSBoZXJlZG9jIG9yIGhlcmVjb21tZW50IGJ5XG5cdC8vIGVyYXNpbmcgYWxsIGV4dGVybmFsIGluZGVudGF0aW9uIG9uIHRoZSBsZWZ0LWhhbmQgc2lkZS5cblx0TGV4ZXIucHJvdG90eXBlLnNhbml0aXplSGVyZWRvYyA9IGZ1bmN0aW9uIChkb2Msb3B0aW9ucyl7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdHZhciBpbmRlbnQgPSBvcHRpb25zLmluZGVudDtcblx0XHR2YXIgaGVyZWNvbW1lbnQgPSBvcHRpb25zLmhlcmVjb21tZW50O1xuXHRcdFxuXHRcdGlmIChoZXJlY29tbWVudCkge1xuXHRcdFx0aWYgKEhFUkVET0NfSUxMRUdBTC50ZXN0KGRvYykpIHtcblx0XHRcdFx0dGhpcy5lcnJvcihcImJsb2NrIGNvbW1lbnQgY2Fubm90IGNvbnRhaW4gJyovJyBzdGFydGluZ1wiKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoZG9jLmluZGV4T2YoJ1xcbicpIDw9IDApIHsgcmV0dXJuIGRvYyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGVuZ3RoXzt3aGlsZSAobWF0Y2ggPSBIRVJFRE9DX0lOREVOVC5leGVjKGRvYykpe1xuXHRcdFx0XHR2YXIgYXR0ZW1wdCA9IG1hdGNoWzFdO1xuXHRcdFx0XHRpZiAoaW5kZW50ID09IG51bGwgfHwgMCA8IChsZW5ndGhfID0gYXR0ZW1wdC5sZW5ndGgpICYmIGxlbmd0aF8gPCBpbmRlbnQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aW5kZW50ID0gYXR0ZW1wdDtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaW5kZW50KSB7IGRvYyA9IGRvYy5yZXBsYWNlKFJlZ0V4cCgoXCJcXFxcblwiICsgaW5kZW50KSxcImdcIiksJ1xcbicpIH07XG5cdFx0aWYgKCFoZXJlY29tbWVudCkgeyBkb2MgPSBkb2MucmVwbGFjZSgvXlxcbi8sJycpIH07XG5cdFx0cmV0dXJuIGRvYztcblx0fTtcblx0XG5cdC8vIEEgc291cmNlIG9mIGFtYmlndWl0eSBpbiBvdXIgZ3JhbW1hciB1c2VkIHRvIGJlIHBhcmFtZXRlciBsaXN0cyBpbiBmdW5jdGlvblxuXHQvLyBkZWZpbml0aW9ucyB2ZXJzdXMgYXJndW1lbnQgbGlzdHMgaW4gZnVuY3Rpb24gY2FsbHMuIFdhbGsgYmFja3dhcmRzLCB0b2tpZGdpbmdcblx0Ly8gcGFyYW1ldGVycyBzcGVjaWFsbHkgaW4gb3JkZXIgdG8gbWFrZSB0aGluZ3MgZWFzaWVyIGZvciB0aGUgcGFyc2VyLlxuXHRMZXhlci5wcm90b3R5cGUudGFnUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0b2s7XG5cdFx0aWYgKHRoaXMubGFzdFRva2VuVHlwZSgpICE9ICcpJykgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7XG5cdFx0dmFyIGkgPSB0b2tlbnMubGVuZ3RoO1xuXHRcdFxuXHRcdHRUcyh0b2tlbnNbLS1pXSwnUEFSQU1fRU5EJyk7XG5cdFx0XG5cdFx0d2hpbGUgKHRvayA9IHRva2Vuc1stLWldKXtcblx0XHRcdHZhciB0ID0gdFQodG9rKTtcblx0XHRcdHN3aXRjaCAodCkge1xuXHRcdFx0XHRjYXNlICcpJzpcblx0XHRcdFx0XHRzdGFjay5wdXNoKHRvayk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICcoJzpcblx0XHRcdFx0Y2FzZSAnQ0FMTF9TVEFSVCc6XG5cdFx0XHRcdFx0aWYgKHN0YWNrLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0ID09ICcoJykge1xuXHRcdFx0XHRcdFx0dFRzKHRvaywnUEFSQU1fU1RBUlQnKTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBDbG9zZSB1cCBhbGwgcmVtYWluaW5nIG9wZW4gYmxvY2tzIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG5cdExleGVyLnByb3RvdHlwZS5jbG9zZUluZGVudGF0aW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY3R4ID0gY29udGV4dFxuXHRcdC8vIHBhaXIoY3R4KSBpZiBjdHggaW4gWyclJywnREVGJ11cblx0XHR0aGlzLmNsb3NlRGVmKCk7XG5cdFx0dGhpcy5jbG9zZVNlbGVjdG9yKCk7XG5cdFx0cmV0dXJuIHRoaXMub3V0ZGVudFRva2VuKHRoaXMuX2luZGVudCxmYWxzZSwwKTtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgYSBiYWxhbmNlZCBncm91cCBzdWNoIGFzIGEgc2luZ2xlIG9yIGRvdWJsZS1xdW90ZWQgc3RyaW5nLiBQYXNzIGluXG5cdC8vIGEgc2VyaWVzIG9mIGRlbGltaXRlcnMsIGFsbCBvZiB3aGljaCBtdXN0IGJlIG5lc3RlZCBjb3JyZWN0bHkgd2l0aGluIHRoZVxuXHQvLyBjb250ZW50cyBvZiB0aGUgc3RyaW5nLiBUaGlzIG1ldGhvZCBhbGxvd3MgdXMgdG8gaGF2ZSBzdHJpbmdzIHdpdGhpblxuXHQvLyBpbnRlcnBvbGF0aW9ucyB3aXRoaW4gc3RyaW5ncywgYWQgaW5maW5pdHVtLlxuXHRMZXhlci5wcm90b3R5cGUuYmFsYW5jZWRTdHJpbmcgPSBmdW5jdGlvbiAoc3RyLGVuZCl7XG5cdFx0dmFyIG1hdGNoLGxldHRlcixwcmV2O1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nICdiYWxhbmNpbmcgc3RyaW5nIScsIHN0ciwgZW5kXG5cdFx0dmFyIHN0YWNrID0gW2VuZF07XG5cdFx0dmFyIGkgPSAwO1xuXHRcdFxuXHRcdC8vIGNvdWxkIGl0IG5vdCBoYXBwZW4gaGVyZT9cblx0XHR3aGlsZSAoaSA8IChzdHIubGVuZ3RoIC0gMSkpe1xuXHRcdFx0aSsrO1xuXHRcdFx0bGV0dGVyID0gc3RyLmNoYXJBdChpKTtcblx0XHRcdHN3aXRjaCAobGV0dGVyKSB7XG5cdFx0XHRcdGNhc2UgJ1xcXFwnOlxuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgZW5kOlxuXHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGlmICghc3RhY2subGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2YXIgdiA9IHN0ci5zbGljZSgwLGkgKyAxKTtcblx0XHRcdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZW5kID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChlbmQgPT0gJ30nICYmIChsZXR0ZXIgPT0gJ1wiJyB8fCBsZXR0ZXIgPT0gXCInXCIpKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gbGV0dGVyKTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID09ICd9JyAmJiBsZXR0ZXIgPT0gJy8nICYmIChtYXRjaCA9IChIRVJFR0VYLmV4ZWMoc3RyLnNsaWNlKGkpKSB8fCBSRUdFWC5leGVjKHN0ci5zbGljZShpKSkpKSkge1xuXHRcdFx0XHRpICs9IG1hdGNoWzBdLmxlbmd0aCAtIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnfScgJiYgbGV0dGVyID09ICd7Jykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9ICd9Jyk7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnXCInICYmIGxldHRlciA9PSAneycpIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSAnfScpO1xuXHRcdFx0fTtcblx0XHRcdHByZXYgPSBsZXR0ZXI7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIXRoaXMuX29wdHMuc2lsZW50KSB7IHJldHVybiB0aGlzLmVycm9yKChcIm1pc3NpbmcgXCIgKyAoc3RhY2sucG9wKCkpICsgXCIsIHN0YXJ0aW5nXCIpKSB9O1xuXHR9O1xuXHRcblx0Ly8gRXhwYW5kIHZhcmlhYmxlcyBhbmQgZXhwcmVzc2lvbnMgaW5zaWRlIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyB1c2luZ1xuXHQvLyBSdWJ5LWxpa2Ugbm90YXRpb24gZm9yIHN1YnN0aXR1dGlvbiBvZiBhcmJpdHJhcnkgZXhwcmVzc2lvbnMuXG5cdC8vXG5cdC8vICAgICBcIkhlbGxvICN7bmFtZS5jYXBpdGFsaXplKCl9LlwiXG5cdC8vXG5cdC8vIElmIGl0IGVuY291bnRlcnMgYW4gaW50ZXJwb2xhdGlvbiwgdGhpcyBtZXRob2Qgd2lsbCByZWN1cnNpdmVseSBjcmVhdGUgYVxuXHQvLyBuZXcgTGV4ZXIsIHRva2VuaXplIHRoZSBpbnRlcnBvbGF0ZWQgY29udGVudHMsIGFuZCBtZXJnZSB0aGVtIGludG8gdGhlXG5cdC8vIHRva2VuIHN0cmVhbS5cblx0TGV4ZXIucHJvdG90eXBlLmludGVycG9sYXRlU3RyaW5nID0gZnVuY3Rpb24gKHN0cixvcHRpb25zKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcImludGVycG9sYXRlIHN0cmluZ1wiXG5cdFx0aWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG5cdFx0dmFyIGhlcmVkb2MgPSBvcHRpb25zLmhlcmVkb2M7XG5cdFx0dmFyIHF1b3RlID0gb3B0aW9ucy5xdW90ZTtcblx0XHR2YXIgcmVnZXggPSBvcHRpb25zLnJlZ2V4O1xuXHRcdHZhciBwcmVmaXggPSBvcHRpb25zLnByZWZpeDtcblx0XHRcblx0XHR2YXIgc3RhcnRMb2MgPSB0aGlzLl9sb2M7XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdHZhciBwaSA9IDA7XG5cdFx0dmFyIGkgPSAtMTtcblx0XHR2YXIgbG9jT2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMTtcblx0XHR2YXIgc3RybGVuID0gc3RyLmxlbmd0aDtcblx0XHR2YXIgbGV0dGVyO1xuXHRcdHZhciBleHByO1xuXHRcdFxuXHRcdHZhciBpc0ludGVycG9sYXRlZCA9IGZhbHNlO1xuXHRcdC8vIG91dCBvZiBib3VuZHNcblx0XHR3aGlsZSAobGV0dGVyID0gc3RyLmNoYXJBdChpICs9IDEpKXtcblx0XHRcdGlmIChsZXR0ZXIgPT0gJ1xcXFwnKSB7XG5cdFx0XHRcdGkgKz0gMTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoIShzdHIuY2hhckF0KGkpID09ICd7JyAmJiAoZXhwciA9IHRoaXMuYmFsYW5jZWRTdHJpbmcoc3RyLnNsaWNlKGkpLCd9JykpKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlzSW50ZXJwb2xhdGVkID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0Ly8gdGhlc2UgaGF2ZSBubyByZWFsIHNlbnNlIG9mIGxvY2F0aW9uIG9yIGFueXRoaW5nP1xuXHRcdFx0aWYgKHBpIDwgaSkge1xuXHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBwcmVmaXgtc3RyaW5nIC0gYmVmb3JlIGFueSBpdGVtXG5cdFx0XHRcdHZhciB0b2sgPSBuZXcgVG9rZW4oJ05FT1NUUklORycsdGhpcy5lc2NhcGVTdHIoc3RyLnNsaWNlKHBpLGkpLGhlcmVkb2MscXVvdGUpLHRoaXMuX2xvYyArIHBpICsgbG9jT2Zmc2V0LGkgLSBwaSk7XG5cdFx0XHRcdC8vIHRvay5AbG9jID0gQGxvYyArIHBpXG5cdFx0XHRcdC8vIHRvay5AbGVuID0gaSAtIHBpICsgMlxuXHRcdFx0XHR0b2tlbnMucHVzaCh0b2spO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dG9rZW5zLnB1c2gobmV3IFRva2VuKCd7eycsJ3snLHRoaXMuX2xvYyArIGkgKyBsb2NPZmZzZXQsMSkpO1xuXHRcdFx0XG5cdFx0XHR2YXIgaW5uZXIgPSBleHByLnNsaWNlKDEsLTEpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2lubmVyIGlzJyxpbm5lclxuXHRcdFx0Ly8gcmVtb3ZlIGxlYWRpbmcgc3BhY2VzIFxuXHRcdFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvdyBtdWNoIHdoaXRlc3BhY2Ugd2UgZHJvcHBlZCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0aW5uZXIgPSBpbm5lci5yZXBsYWNlKC9eW15cXG5cXFNdKy8sJycpO1xuXHRcdFx0XG5cdFx0XHRpZiAoaW5uZXIubGVuZ3RoKSB7XG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIGxvYyB3ZSBzdGFydCBhdFxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnaW50ZXJwb2xhdGUgZnJvbSBsb2MnLEBsb2MsaSlcblx0XHRcdFx0Ly8gcmVhbGx5PyB3aHkgbm90IGp1c3QgYWRkIHRvIHRoZSBzdGFjaz8/XG5cdFx0XHRcdC8vIHdoYXQgYWJvdXQgdGhlIGFkZGVkIFxuXHRcdFx0XHQvLyBzaG91bGQgc2hhcmUgd2l0aCB0aGUgc2VsZWN0b3Igbm8/XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwidG9rZW5pemUgaW5uZXIgcGFydHMgb2Ygc3RyaW5nXCIsaW5uZXJcblx0XHRcdFx0dmFyIHNwYWNlcyA9IDA7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLl9sb2MgKyBpICsgKGV4cHIubGVuZ3RoIC0gaW5uZXIubGVuZ3RoKSAtIDE7XG5cdFx0XHRcdC8vIHdoeSBjcmVhdGUgYSB3aG9sZSBuZXcgbGV4ZXI/IFNob3VsZCByYXRoZXIgcmV1c2Ugb25lXG5cdFx0XHRcdC8vIG11Y2ggYmV0dGVyIHRvIHNpbXBseSBtb3ZlIGludG8gaW50ZXJwb2xhdGlvbiBtb2RlIHdoZXJlXG5cdFx0XHRcdC8vIHdlIGNvbnRpbnVlIHBhcnNpbmcgdW50aWwgd2UgbWVldCB1bnBhaXJlZCB9XG5cdFx0XHRcdHZhciBuZXN0ZWQgPSBuZXcgTGV4ZXIoKS50b2tlbml6ZShpbm5lcix7aW5saW5lOiB0cnVlLHJld3JpdGU6IGZhbHNlLGxvYzogb2Zmc2V0ICsgbG9jT2Zmc2V0fSk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIG5lc3RlZC5wb3Bcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuZXN0ZWRbMF0gJiYgdFQobmVzdGVkWzBdKSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0XHRuZXN0ZWQuc2hpZnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuZXN0ZWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dG9rZW5zLnB1c2guYXBwbHkodG9rZW5zLG5lc3RlZCk7IC8vIFQudG9rZW4oJ1RPS0VOUycsbmVzdGVkLDApXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBzaG91bGQgcmF0aGVyIGFkZCB0aGUgYW1vdW50IGJ5IHdoaWNoIG91ciBsZXhlciBoYXMgbW92ZWQ/XG5cdFx0XHRpICs9IGV4cHIubGVuZ3RoIC0gMTtcblx0XHRcdHRva2Vucy5wdXNoKG5ldyBUb2tlbignfX0nLCd9Jyx0aGlzLl9sb2MgKyBpICsgbG9jT2Zmc2V0LDEpKTtcblx0XHRcdHBpID0gaSArIDE7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBhZGRpbmcgdGhlIGxhc3QgcGFydCBvZiB0aGUgc3RyaW5nIGhlcmVcblx0XHRpZiAoaSA+PSBwaSAmJiBwaSA8IHN0ci5sZW5ndGgpIHtcblx0XHRcdC8vIHNldCB0aGUgbGVuZ3RoIGFzIHdlbGwgLSBvcj9cblx0XHRcdC8vIHRoZSBzdHJpbmcgYWZ0ZXI/XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncHVzaCBuZW9zdHJpbmcnXG5cdFx0XHR0b2tlbnMucHVzaChuZXcgVG9rZW4oJ05FT1NUUklORycsdGhpcy5lc2NhcGVTdHIoc3RyLnNsaWNlKHBpKSxoZXJlZG9jLHF1b3RlKSx0aGlzLl9sb2MgKyBwaSArIGxvY09mZnNldCxzdHIubGVuZ3RoIC0gcGkpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIHRva2VuczpsZW5ndGhcblx0XHRpZiAocmVnZXgpIHsgcmV0dXJuIHRva2VucyB9O1xuXHRcdFxuXHRcdGlmICghdG9rZW5zLmxlbmd0aCkgeyByZXR1cm4gdGhpcy50b2tlbignTkVPU1RSSU5HJywnXCJcIicpIH07XG5cdFx0XG5cdFx0Zm9yICh2YXIgaiA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuXHRcdFx0dGhpcy5fdG9rZW5zLnB1c2godG9rZW5zW2pdKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0b2tlbnM7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGEgYmFsYW5jZWQgZ3JvdXAgc3VjaCBhcyBhIHNpbmdsZSBvciBkb3VibGUtcXVvdGVkIHN0cmluZy4gUGFzcyBpblxuXHQvLyBhIHNlcmllcyBvZiBkZWxpbWl0ZXJzLCBhbGwgb2Ygd2hpY2ggbXVzdCBiZSBuZXN0ZWQgY29ycmVjdGx5IHdpdGhpbiB0aGVcblx0Ly8gY29udGVudHMgb2YgdGhlIHN0cmluZy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIGhhdmUgc3RyaW5ncyB3aXRoaW5cblx0Ly8gaW50ZXJwb2xhdGlvbnMgd2l0aGluIHN0cmluZ3MsIGFkIGluZmluaXR1bS5cblx0TGV4ZXIucHJvdG90eXBlLmJhbGFuY2VkU2VsZWN0b3IgPSBmdW5jdGlvbiAoc3RyLGVuZCl7XG5cdFx0dmFyIHByZXY7XG5cdFx0dmFyIGxldHRlcjtcblx0XHR2YXIgc3RhY2sgPSBbZW5kXTtcblx0XHQvLyBGSVhNRVxuXHRcdGZvciAodmFyIGxlbiA9IHN0ci5sZW5ndGgsIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHN3aXRjaCAobGV0dGVyID0gc3RyLmNoYXJBdChpKSkge1xuXHRcdFx0XHRjYXNlICdcXFxcJzpcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlIGVuZDpcblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRpZiAoIXN0YWNrLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHN0ci5zbGljZSgwLGkgKyAxKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGVuZCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGVuZCA9PSAnfScgJiYgbGV0dGVyID09IFsnKSddKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gbGV0dGVyKTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID09ICd9JyAmJiBsZXR0ZXIgPT0gJ3snKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gJ30nKTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID09ICcpJyAmJiBsZXR0ZXIgPT0gJ3snKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gJ30nKTtcblx0XHRcdH07XG5cdFx0XHRwcmV2ID0gbGV0dGVyOyAvLyB3aGF0LCB3aHk/XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcy5lcnJvcigoXCJtaXNzaW5nIFwiICsgKHN0YWNrLnBvcCgpKSArIFwiLCBzdGFydGluZ1wiKSk7XG5cdH07XG5cdFxuXHQvLyBQYWlycyB1cCBhIGNsb3NpbmcgdG9rZW4sIGVuc3VyaW5nIHRoYXQgYWxsIGxpc3RlZCBwYWlycyBvZiB0b2tlbnMgYXJlXG5cdC8vIGNvcnJlY3RseSBiYWxhbmNlZCB0aHJvdWdob3V0IHRoZSBjb3Vyc2Ugb2YgdGhlIHRva2VuIHN0cmVhbS5cblx0TGV4ZXIucHJvdG90eXBlLnBhaXIgPSBmdW5jdGlvbiAodG9rKXtcblx0XHR2YXIgd2FudGVkID0gbGFzdCh0aGlzLl9lbmRzKTtcblx0XHRpZiAodG9rICE9IHdhbnRlZCkge1xuXHRcdFx0aWYgKCdPVVRERU5UJyAhPSB3YW50ZWQpIHsgdGhpcy5lcnJvcigoXCJ1bm1hdGNoZWQgXCIgKyB0b2spKSB9O1xuXHRcdFx0dmFyIHNpemUgPSBsYXN0KHRoaXMuX2luZGVudHMpO1xuXHRcdFx0dGhpcy5faW5kZW50IC09IHNpemU7XG5cdFx0XHR0aGlzLm91dGRlbnRUb2tlbihzaXplLHRydWUsMCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYWlyKHRvayk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcy5wb3BFbmQoKTtcblx0fTtcblx0XG5cdFxuXHQvLyBIZWxwZXJzXG5cdC8vIC0tLS0tLS1cblx0XG5cdC8vIEFkZCBhIHRva2VuIHRvIHRoZSByZXN1bHRzLCB0YWtpbmcgbm90ZSBvZiB0aGUgbGluZSBudW1iZXIuXG5cdExleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uIChpZCx2YWx1ZSxsZW4sb2Zmc2V0KXtcblx0XHR0aGlzLl9sYXN0VHlwID0gaWQ7XG5cdFx0dGhpcy5fbGFzdFZhbCA9IHZhbHVlO1xuXHRcdHZhciB0b2sgPSB0aGlzLl9sYXN0ID0gbmV3IFRva2VuKGlkLHZhbHVlLHRoaXMuX2xvYyArIChvZmZzZXQgfHwgMCksbGVuIHx8IDApO1xuXHRcdHRoaXMuX3Rva2Vucy5wdXNoKHRvayk7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmxhc3RUb2tlblR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rZW4gPSB0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB0b2tlbiA/ICh0VCh0b2tlbikpIDogKCdOT05FJyk7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUubGFzdFRva2VuVmFsdWUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rZW4gPSB0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB0b2tlbiA/ICh0b2tlbi5fdmFsdWUpIDogKCcnKTtcblx0fTtcblx0XG5cdC8vIFBlZWsgYXQgYSB0b2tpZCBpbiB0aGUgY3VycmVudCB0b2tlbiBzdHJlYW0uXG5cdExleGVyLnByb3RvdHlwZS50b2tpZCA9IGZ1bmN0aW9uIChpbmRleCx2YWwpe1xuXHRcdHZhciB0b2s7XG5cdFx0aWYgKHRvayA9IGxhc3QodGhpcy5fdG9rZW5zLGluZGV4KSkge1xuXHRcdFx0aWYgKHZhbCkgeyB0VHModG9rLHZhbCkgfTtcblx0XHRcdHJldHVybiB0VCh0b2spO1xuXHRcdFx0Ly8gdG9rLkB0eXBlID0gdG9raWQgaWYgdG9raWQgIyB3aHk/XG5cdFx0XHQvLyB0b2suQHR5cGVcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fTtcblx0XG5cdC8vIFBlZWsgYXQgYSB2YWx1ZSBpbiB0aGUgY3VycmVudCB0b2tlbiBzdHJlYW0uXG5cdExleGVyLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChpbmRleCx2YWwpe1xuXHRcdHZhciB0b2s7XG5cdFx0aWYgKHRvayA9IGxhc3QodGhpcy5fdG9rZW5zLGluZGV4KSkge1xuXHRcdFx0aWYgKHZhbCkgeyB0VnModG9rLHZhbCkgfTtcblx0XHRcdHJldHVybiB0Vih0b2spO1xuXHRcdFx0Ly8gdG9rLkB2YWx1ZSA9IHZhbCBpZiB2YWwgIyB3aHk/XG5cdFx0XHQvLyB0b2suQHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0Ly8gQXJlIHdlIGluIHRoZSBtaWRzdCBvZiBhbiB1bmZpbmlzaGVkIGV4cHJlc3Npb24/XG5cdExleGVyLnByb3RvdHlwZS51bmZpbmlzaGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKExJTkVfQ09OVElOVUVSLnRlc3QodGhpcy5fY2h1bmspKSB7IHJldHVybiB0cnVlIH07XG5cdFx0cmV0dXJuIFVORklOSVNIRUQuaW5kZXhPZih0aGlzLl9sYXN0VHlwKSA+PSAwO1xuXHR9O1xuXHRcblx0Ly8gdmFyIHRva2VucyA9IFsnXFxcXCcsJy4nLCAnPy4nLCAnVU5BUlknLCAnTUFUSCcsICcrJywgJy0nLCAnU0hJRlQnLCAnUkVMQVRJT04nLCAnQ09NUEFSRScsICdMT0dJQycsICdDT01QT1VORF9BU1NJR04nLCAnVEhST1cnLCAnRVhURU5EUyddXG5cdFxuXHQvLyBDb252ZXJ0cyBuZXdsaW5lcyBmb3Igc3RyaW5nIGxpdGVyYWxzLlxuXHRMZXhlci5wcm90b3R5cGUuZXNjYXBlTGluZXMgPSBmdW5jdGlvbiAoc3RyLGhlcmVkb2Mpe1xuXHRcdHJldHVybiBzdHIucmVwbGFjZShNVUxUSUxJTkVSLChoZXJlZG9jID8gKCdcXFxcbicpIDogKCcnKSkpO1xuXHR9O1xuXHRcblx0Ly8gQ29uc3RydWN0cyBhIHN0cmluZyB0b2tlbiBieSBlc2NhcGluZyBxdW90ZXMgYW5kIG5ld2xpbmVzLlxuXHRMZXhlci5wcm90b3R5cGUubWFrZVN0cmluZyA9IGZ1bmN0aW9uIChib2R5LHF1b3RlLGhlcmVkb2Mpe1xuXHRcdGlmICghYm9keSkgeyByZXR1cm4gcXVvdGUgKyBxdW90ZSB9O1xuXHRcdGJvZHkgPSBib2R5LnJlcGxhY2UoL1xcXFwoW1xcc1xcU10pL2csZnVuY3Rpb24obWF0Y2gsY29udGVudHMpIHtcblx0XHRcdHJldHVybiAoY29udGVudHMgPT0gJ1xcbicgfHwgY29udGVudHMgPT0gcXVvdGUpID8gKGNvbnRlbnRzKSA6IChtYXRjaCk7XG5cdFx0fSk7XG5cdFx0Ly8gRG9lcyBub3Qgd29yayBub3dcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlKFJlZ0V4cCgoXCJcIiArIHF1b3RlKSxcImdcIiksJ1xcXFwkJicpO1xuXHRcdHJldHVybiBxdW90ZSArIHRoaXMuZXNjYXBlTGluZXMoYm9keSxoZXJlZG9jKSArIHF1b3RlO1xuXHR9O1xuXHRcblx0Ly8gVGhyb3dzIGEgc3ludGF4IGVycm9yIG9uIHRoZSBjdXJyZW50IGBAbGluZWAuXG5cdExleGVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLGxlbil7XG5cdFx0aWYgKCh0eXBlb2YgdGhpcy5fbGluZT09J251bWJlcid8fHRoaXMuX2xpbmUgaW5zdGFuY2VvZiBOdW1iZXIpKSB7IG1lc3NhZ2UgPSAoXCJcIiArIG1lc3NhZ2UgKyBcIiBvbiBsaW5lIFwiICsgKHRoaXMuX2xpbmUpKSB9O1xuXHRcdFxuXHRcdGlmIChsZW4pIHtcblx0XHRcdG1lc3NhZ2UgKz0gKFwiIFtcIiArICh0aGlzLl9sb2MpICsgXCI6XCIgKyAodGhpcy5fbG9jICsgbGVuKSArIFwiXVwiKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG5cdFx0ZXJyLmxpbmUgPSB0aGlzLl9saW5lO1xuXHRcdC8vIGVycjpjb2x1bW5OdW1iZXJcblx0XHRlcnIgPSBuZXcgRVJSLkltYmFQYXJzZUVycm9yKGVycix7dG9rZW5zOiB0aGlzLl90b2tlbnMscG9zOiB0aGlzLl90b2tlbnMubGVuZ3RofSk7XG5cdFx0ZXJyLnJlZ2lvbiA9IFt0aGlzLl9sb2MsdGhpcy5fbG9jICsgKGxlbiB8fCAwKV07XG5cdFx0dGhyb3cgZXJyO1xuXHR9O1xuXHRyZXR1cm4gTGV4ZXI7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvc3JjL2NvbXBpbGVyL2xleGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciBUT0ssIExCUkFDS0VULCBSQlJBQ0tFVCwgTFBBUkVOLCBSUEFSRU4sIElOREVOVCwgT1VUREVOVDtcblx0XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5UT0sgPSBUT0sgPSB7fTtcblx0dmFyIFRURVJNSU5BVE9SID0gVE9LLlRFUk1JTkFUT1IgPSAxO1xuXHR2YXIgVElERU5USUZJRVIgPSBUT0suSURFTlRJRklFUiA9IDI7XG5cdFRJREVOVElGSUVSID0gVE9LLklWQVIgPSAyO1xuXHR2YXIgQ09OU1QgPSBUT0suQ09OU1QgPSAzO1xuXHR2YXIgVkFSID0gVE9LLlZBUiA9IDQ7XG5cdHZhciBJRiA9IFRPSy5JRiA9IDU7XG5cdHZhciBFTFNFID0gVE9LLkVMU0UgPSA2O1xuXHR2YXIgREVGID0gVE9LLkRFRiA9IDc7XG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIFRva2VuKHR5cGUsdmFsdWUsbG9jLGxlbil7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLl9sb2MgPSBsb2MgIT0gbnVsbCA/IChsb2MpIDogKC0xKTtcblx0XHR0aGlzLl9sZW4gPSBsZW4gfHwgMDtcblx0XHR0aGlzLl9tZXRhID0gbnVsbDtcblx0XHR0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuXHRcdHRoaXMubmV3TGluZSA9IGZhbHNlO1xuXHRcdHRoaXMuc3BhY2VkID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLlRva2VuID0gVG9rZW47IC8vIGV4cG9ydCBjbGFzcyBcblx0VG9rZW4ucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFwiXCIgKyB0aGlzLl92YWx1ZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5jaGFyQXQgPSBmdW5jdGlvbiAoaSl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLmNoYXJBdChpKTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChpKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUuc2xpY2UoaSk7XG5cdH07XG5cdFxuXHRUb2tlbi5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLl9sb2MsdGhpcy5fbG9jICsgKHRoaXMuX2xlbiB8fCB0aGlzLl92YWx1ZS5sZW5ndGgpXTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5zb3VyY2VNYXBNYXJrZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbG9jID09IC0xID8gKCc6JykgOiAoKFwiJSRcIiArICh0aGlzLl9sb2MpICsgXCIkJVwiKSk7XG5cdFx0Ly8gQGNvbCA9PSAtMSA/ICcnIDogXCIlJXtAbGluZX0ke0Bjb2x9JSVcIlxuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIGxleCgpe1xuXHRcdHZhciB0b2tlbiA9IHRoaXMudG9rZW5zW3RoaXMucG9zKytdO1xuXHRcdHZhciB0dGFnO1xuXHRcdFxuXHRcdGlmICh0b2tlbikge1xuXHRcdFx0dHRhZyA9IHRva2VuLl90eXBlO1xuXHRcdFx0dGhpcy55eXRleHQgPSB0b2tlbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dHRhZyA9ICcnO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHR0YWc7XG5cdH07IGV4cG9ydHMubGV4ID0gbGV4O1xuXHRcblx0XG5cdC8vIGV4cG9ydCBkZWYgdG9rZW4gdHlwLCB2YWwsIGxpbmUsIGNvbCwgbGVuIGRvIFRva2VuLm5ldyh0eXAsdmFsLGxpbmUsIGNvbCBvciAwLCBsZW4gb3IgMCkgIyBbbnVsbCx0eXAsdmFsLGxvY11cblx0ZnVuY3Rpb24gdG9rZW4odHlwLHZhbCl7XG5cdFx0cmV0dXJuIG5ldyBUb2tlbih0eXAsdmFsLC0xLDApO1xuXHR9OyBleHBvcnRzLnRva2VuID0gdG9rZW47XG5cdFxuXHRmdW5jdGlvbiB0eXAodG9rKXtcblx0XHRyZXR1cm4gdG9rLl90eXBlO1xuXHR9OyBleHBvcnRzLnR5cCA9IHR5cDtcblx0ZnVuY3Rpb24gdmFsKHRvayl7XG5cdFx0cmV0dXJuIHRvay5fdmFsdWU7XG5cdH07IGV4cG9ydHMudmFsID0gdmFsOyAvLyB0b2tbb2Zmc2V0ICsgMV1cblx0ZnVuY3Rpb24gbGluZSh0b2spe1xuXHRcdHJldHVybiB0b2suX2xpbmU7XG5cdH07IGV4cG9ydHMubGluZSA9IGxpbmU7IC8vIHRva1tvZmZzZXQgKyAyXVxuXHRmdW5jdGlvbiBsb2ModG9rKXtcblx0XHRyZXR1cm4gdG9rLl9sb2M7XG5cdH07IGV4cG9ydHMubG9jID0gbG9jOyAvLyB0b2tbb2Zmc2V0ICsgMl1cblx0XG5cdGZ1bmN0aW9uIHNldFR5cCh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fdHlwZSA9IHY7XG5cdH07IGV4cG9ydHMuc2V0VHlwID0gc2V0VHlwO1xuXHRmdW5jdGlvbiBzZXRWYWwodG9rLHYpe1xuXHRcdHJldHVybiB0b2suX3ZhbHVlID0gdjtcblx0fTsgZXhwb3J0cy5zZXRWYWwgPSBzZXRWYWw7XG5cdGZ1bmN0aW9uIHNldExpbmUodG9rLHYpe1xuXHRcdHJldHVybiB0b2suX2xpbmUgPSB2O1xuXHR9OyBleHBvcnRzLnNldExpbmUgPSBzZXRMaW5lO1xuXHRmdW5jdGlvbiBzZXRMb2ModG9rLHYpe1xuXHRcdHJldHVybiB0b2suX2xvYyA9IHY7XG5cdH07IGV4cG9ydHMuc2V0TG9jID0gc2V0TG9jO1xuXHRcblx0XG5cdG1vZHVsZS5leHBvcnRzLkxCUkFDS0VUID0gTEJSQUNLRVQgPSBuZXcgVG9rZW4oJ3snLCd7JywwLDAsMCk7XG5cdG1vZHVsZS5leHBvcnRzLlJCUkFDS0VUID0gUkJSQUNLRVQgPSBuZXcgVG9rZW4oJ30nLCd9JywwLDAsMCk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5MUEFSRU4gPSBMUEFSRU4gPSBuZXcgVG9rZW4oJygnLCcoJywwLDAsMCk7XG5cdG1vZHVsZS5leHBvcnRzLlJQQVJFTiA9IFJQQVJFTiA9IG5ldyBUb2tlbignKScsJyknLDAsMCwwKTtcblx0XG5cdExCUkFDS0VULmdlbmVyYXRlZCA9IHRydWU7XG5cdFJCUkFDS0VULmdlbmVyYXRlZCA9IHRydWU7XG5cdExQQVJFTi5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRSUEFSRU4uZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLklOREVOVCA9IElOREVOVCA9IG5ldyBUb2tlbignSU5ERU5UJywnMicsMCwwLDApO1xuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHMuT1VUREVOVCA9IE9VVERFTlQgPSBuZXcgVG9rZW4oJ09VVERFTlQnLCcyJywwLDAsMCk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvc3JjL2NvbXBpbGVyL3Rva2VuLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIElOVkVSU0VTLCBMSU5FQlJFQUtTO1xuXHRcblx0Ly8gVGhlIEltYmEgbGFuZ3VhZ2UgaGFzIGEgZ29vZCBkZWFsIG9mIG9wdGlvbmFsIHN5bnRheCwgaW1wbGljaXQgc3ludGF4LFxuXHQvLyBhbmQgc2hvcnRoYW5kIHN5bnRheC4gVGhpcyBjYW4gZ3JlYXRseSBjb21wbGljYXRlIGEgZ3JhbW1hciBhbmQgYmxvYXRcblx0Ly8gdGhlIHJlc3VsdGluZyBwYXJzZSB0YWJsZS4gSW5zdGVhZCBvZiBtYWtpbmcgdGhlIHBhcnNlciBoYW5kbGUgaXQgYWxsLCB3ZSB0YWtlXG5cdC8vIGEgc2VyaWVzIG9mIHBhc3NlcyBvdmVyIHRoZSB0b2tlbiBzdHJlYW0sIHVzaW5nIHRoaXMgKipSZXdyaXRlcioqIHRvIGNvbnZlcnRcblx0Ly8gc2hvcnRoYW5kIGludG8gdGhlIHVuYW1iaWd1b3VzIGxvbmcgZm9ybSwgYWRkIGltcGxpY2l0IGluZGVudGF0aW9uIGFuZFxuXHQvLyBwYXJlbnRoZXNlcywgYW5kIGdlbmVyYWxseSBjbGVhbiB0aGluZ3MgdXAuXG5cdFxuXHR2YXIgVCA9IHJlcXVpcmUoJy4vdG9rZW4nKTtcblx0dmFyIFRva2VuID0gVC5Ub2tlbjtcblx0XG5cdC8vIEJhc2VkIG9uIHRoZSBvcmlnaW5hbCByZXdyaXRlci5jb2ZmZWUgZnJvbSBDb2ZmZWVTY3JpcHRcblx0ZnVuY3Rpb24gUmV3cml0ZXIoKXsgfTtcblx0XG5cdGV4cG9ydHMuUmV3cml0ZXIgPSBSZXdyaXRlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRSZXdyaXRlci5wcm90b3R5cGUudG9rZW5zID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Rva2Vucztcblx0fTtcblx0XG5cdC8vIEhlbHBmdWwgc25pcHBldCBmb3IgZGVidWdnaW5nOlxuXHQvLyAgICAgY29uc29sZS5sb2cgKHRbMF0gKyAnLycgKyB0WzFdIGZvciB0IGluIEB0b2tlbnMpLmpvaW4gJyAnXG5cdC8vIFJld3JpdGUgdGhlIHRva2VuIHN0cmVhbSBpbiBtdWx0aXBsZSBwYXNzZXMsIG9uZSBsb2dpY2FsIGZpbHRlciBhdFxuXHQvLyBhIHRpbWUuIFRoaXMgY291bGQgY2VydGFpbmx5IGJlIGNoYW5nZWQgaW50byBhIHNpbmdsZSBwYXNzIHRocm91Z2ggdGhlXG5cdC8vIHN0cmVhbSwgd2l0aCBhIGJpZyBvbCcgZWZmaWNpZW50IHN3aXRjaCwgYnV0IGl0J3MgbXVjaCBuaWNlciB0byB3b3JrIHdpdGhcblx0Ly8gbGlrZSB0aGlzLiBUaGUgb3JkZXIgb2YgdGhlc2UgcGFzc2VzIG1hdHRlcnMgLS0gaW5kZW50YXRpb24gbXVzdCBiZVxuXHQvLyBjb3JyZWN0ZWQgYmVmb3JlIGltcGxpY2l0IHBhcmVudGhlc2VzIGNhbiBiZSB3cmFwcGVkIGFyb3VuZCBibG9ja3Mgb2YgY29kZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLnJld3JpdGUgPSBmdW5jdGlvbiAodG9rZW5zLG9wdHMpe1xuXHRcdHZhciB0b2tlbjtcblx0XHRpZihvcHRzID09PSB1bmRlZmluZWQpIG9wdHMgPSB7fTtcblx0XHR0aGlzLl90b2tlbnMgPSB0b2tlbnM7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG9wdHM7XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJ0b2tlbnMgaW46IFwiICsgdG9rZW5zOmxlbmd0aFxuXHRcdGlmIChvcHRzLnByb2ZpbGUpIHsgY29uc29sZS50aW1lKFwidG9rZW5pemU6cmV3cml0ZVwiKSB9O1xuXHRcdFxuXHRcdHZhciBpID0gMDtcblx0XHQvLyBmbGFnIGVtcHR5IG1ldGhvZHNcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0dmFyIG5leHQgPSB0b2tlbnNbaSArIDFdO1xuXHRcdFx0aWYgKHRva2VuLl90eXBlID09ICdERUZfQk9EWScgJiYgbmV4dCAmJiBuZXh0Ll90eXBlID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHR0b2tlbi5fdHlwZSA9ICdERUZfRU1QVFknO1xuXHRcdFx0fTtcblx0XHRcdGkrKztcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuc3RlcChcImVuc3VyZUZpcnN0TGluZVwiKTtcblx0XHR0aGlzLnN0ZXAoXCJyZW1vdmVMZWFkaW5nTmV3bGluZXNcIik7XG5cdFx0dGhpcy5zdGVwKFwicmVtb3ZlTWlkRXhwcmVzc2lvbk5ld2xpbmVzXCIpO1xuXHRcdHRoaXMuc3RlcChcInRhZ0RlZkFyZ3VtZW50c1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJjbG9zZU9wZW5DYWxsc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJjbG9zZU9wZW5JbmRleGVzXCIpO1xuXHRcdHRoaXMuc3RlcChcImNsb3NlT3BlblRhZ3NcIik7XG5cdFx0dGhpcy5zdGVwKFwiY2xvc2VPcGVuVGFnQXR0ckxpc3RzXCIpO1xuXHRcdHRoaXMuc3RlcChcImFkZEltcGxpY2l0SW5kZW50YXRpb25cIik7XG5cdFx0dGhpcy5zdGVwKFwidGFnUG9zdGZpeENvbmRpdGlvbmFsc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJhZGRJbXBsaWNpdEJyYWNlc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJhZGRJbXBsaWNpdFBhcmVudGhlc2VzXCIpO1xuXHRcdFxuXHRcdGlmIChvcHRzLnByb2ZpbGUpIHsgY29uc29sZS50aW1lRW5kKFwidG9rZW5pemU6cmV3cml0ZVwiKSB9O1xuXHRcdC8vIGNvbnNvbGUubG9nIFwidG9rZW5zIG91dDogXCIgKyBAdG9rZW5zOmxlbmd0aFxuXHRcdHJldHVybiB0aGlzLl90b2tlbnM7XG5cdH07XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIChmbil7XG5cdFx0aWYgKHRoaXMuX29wdGlvbnMucHJvZmlsZSkge1xuXHRcdFx0Y29uc29sZS5sb2coKFwiLS0tLSBzdGFydGluZyBcIiArIGZuICsgXCIgLS0tLSBcIikpO1xuXHRcdFx0Y29uc29sZS50aW1lKGZuKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXNbZm5dKCk7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX29wdGlvbnMucHJvZmlsZSkge1xuXHRcdFx0Y29uc29sZS50aW1lRW5kKGZuKTtcblx0XHRcdGNvbnNvbGUubG9nKFwiXFxuXFxuXCIpO1xuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gUmV3cml0ZSB0aGUgdG9rZW4gc3RyZWFtLCBsb29raW5nIG9uZSB0b2tlbiBhaGVhZCBhbmQgYmVoaW5kLlxuXHQvLyBBbGxvdyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBibG9jayB0byB0ZWxsIHVzIGhvdyBtYW55IHRva2VucyB0byBtb3ZlXG5cdC8vIGZvcndhcmRzIChvciBiYWNrd2FyZHMpIGluIHRoZSBzdHJlYW0sIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nXG5cdC8vIGFzIHRva2VucyBhcmUgaW5zZXJ0ZWQgYW5kIHJlbW92ZWQsIGFuZCB0aGUgc3RyZWFtIGNoYW5nZXMgbGVuZ3RoIHVuZGVyXG5cdC8vIG91ciBmZWV0LlxuXHRSZXdyaXRlci5wcm90b3R5cGUuc2NhblRva2VucyA9IGZ1bmN0aW9uIChibG9jayl7XG5cdFx0dmFyIHRva2VuO1xuXHRcdHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7XG5cdFx0XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHRpICs9IGJsb2NrLmNhbGwodGhpcyx0b2tlbixpLHRva2Vucyk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5kZXRlY3RFbmQgPSBmdW5jdGlvbiAoaSxjb25kaXRpb24sYWN0aW9uKXtcblx0XHR2YXIgdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuXHRcdHZhciBsZXZlbHMgPSAwO1xuXHRcdHZhciBzdGFydHMgPSBbXTtcblx0XHR2YXIgdG9rZW47XG5cdFx0dmFyIHQsdjtcblx0XHRcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0aWYgKGxldmVscyA9PSAwICYmIGNvbmRpdGlvbi5jYWxsKHRoaXMsdG9rZW4saSxzdGFydHMpKSB7XG5cdFx0XHRcdHJldHVybiBhY3Rpb24uY2FsbCh0aGlzLHRva2VuLGkpO1xuXHRcdFx0fTtcblx0XHRcdGlmICghdG9rZW4gfHwgbGV2ZWxzIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmNhbGwodGhpcyx0b2tlbixpIC0gMSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0ID0gVC50eXAodG9rZW4pO1xuXHRcdFx0XG5cdFx0XHRpZiAoRVhQUkVTU0lPTl9TVEFSVC5pbmRleE9mKHQpID49IDApIHtcblx0XHRcdFx0aWYgKGxldmVscyA9PSAwKSB7IHN0YXJ0cy5wdXNoKGkpIH07XG5cdFx0XHRcdGxldmVscyArPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChFWFBSRVNTSU9OX0VORC5pbmRleE9mKHQpID49IDApIHtcblx0XHRcdFx0bGV2ZWxzIC09IDE7XG5cdFx0XHR9O1xuXHRcdFx0aSArPSAxO1xuXHRcdH07XG5cdFx0cmV0dXJuIGkgLSAxO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmVuc3VyZUZpcnN0TGluZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0b2sgPSB0aGlzLl90b2tlbnNbMF07XG5cdFx0XG5cdFx0aWYgKFQudHlwKHRvaykgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImFkZGluZyBib2R5c3RhcnRcIlxuXHRcdFx0dGhpcy5fdG9rZW5zID0gW1QudG9rZW4oJ0JPRFlTVEFSVCcsJ0JPRFlTVEFSVCcpXS5jb25jYXQodGhpcy5fdG9rZW5zKTtcblx0XHRcdC8vIFQuc2V0VHlwKHRvaywnSEVBREVSJylcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIExlYWRpbmcgbmV3bGluZXMgd291bGQgaW50cm9kdWNlIGFuIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hciwgc28gd2Vcblx0Ly8gZGlzcGF0Y2ggdGhlbSBoZXJlLlxuXHRSZXdyaXRlci5wcm90b3R5cGUucmVtb3ZlTGVhZGluZ05ld2xpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGF0ID0gMDtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fdG9rZW5zKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoVC50eXAoYXJ5W2ldKSAhPSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0YXQgPSBpO2JyZWFrO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChhdCkgeyB0aGlzLl90b2tlbnMuc3BsaWNlKDAsYXQpIH07XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gU29tZSBibG9ja3Mgb2NjdXIgaW4gdGhlIG1pZGRsZSBvZiBleHByZXNzaW9ucyAtLSB3aGVuIHdlJ3JlIGV4cGVjdGluZ1xuXHQvLyB0aGlzLCByZW1vdmUgdGhlaXIgdHJhaWxpbmcgbmV3bGluZXMuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5yZW1vdmVNaWRFeHByZXNzaW9uTmV3bGluZXMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpLHRva2VucykgeyAvLyBkbyB8dG9rZW4saSx0b2tlbnN8XG5cdFx0XHR2YXIgbmV4dCA9IHNlbGYudG9rZW5UeXBlKGkgKyAxKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoVC50eXAodG9rZW4pID09ICdURVJNSU5BVE9SJyAmJiBFWFBSRVNTSU9OX0NMT1NFLmluZGV4T2YobmV4dCkgPj0gMCkpIHsgcmV0dXJuIDEgfTtcblx0XHRcdGlmIChuZXh0ID09ICdPVVRERU5UJykgeyByZXR1cm4gMSB9O1xuXHRcdFx0dG9rZW5zLnNwbGljZShpLDEpO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLnRhZ0RlZkFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0Ly8gVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYSBtZXRob2QgY2FsbC4gTWF0Y2ggaXQgd2l0aFxuXHQvLyBpdHMgcGFpcmVkIGNsb3NlLiBXZSBoYXZlIHRoZSBtaXMtbmVzdGVkIG91dGRlbnQgY2FzZSBpbmNsdWRlZCBoZXJlIGZvclxuXHQvLyBjYWxscyB0aGF0IGNsb3NlIG9uIHRoZSBzYW1lIGxpbmUsIGp1c3QgYmVmb3JlIHRoZWlyIG91dGRlbnQuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5jbG9zZU9wZW5DYWxscyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0dmFyIHQgPSBULnR5cCh0b2tlbik7XG5cdFx0XHRyZXR1cm4gKHQgPT0gJyknIHx8IHQgPT0gJ0NBTExfRU5EJykgfHwgdCA9PSAnT1VUREVOVCcgJiYgc2VsZi50b2tlblR5cGUoaSAtIDEpID09ICcpJztcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHR2YXIgdCA9IFQudHlwKHRva2VuKTtcblx0XHRcdHZhciB0b2sgPSBzZWxmLl90b2tlbnNbdCA9PSAnT1VUREVOVCcgPyAoaSAtIDEpIDogKGkpXTtcblx0XHRcdHJldHVybiBULnNldFR5cCh0b2ssJ0NBTExfRU5EJyk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdGlmIChULnR5cCh0b2tlbikgPT0gJ0NBTExfU1RBUlQnKSB7IHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmRpdGlvbixhY3Rpb24pIH07XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdC8vIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGFuIGluZGV4aW5nIG9wZXJhdGlvbiBjYWxsLlxuXHQvLyBNYXRjaCBpdCB3aXRoIGl0cyBwYWlyZWQgY2xvc2UuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5jbG9zZU9wZW5JbmRleGVzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBpZHgkKFQudHlwKHRva2VuKSxbJ10nLCdJTkRFWF9FTkQnXSkgPj0gMDsgfTtcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gVC5zZXRUeXAodG9rZW4sJ0lOREVYX0VORCcpOyB9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0aWYgKFQudHlwKHRva2VuKSA9PSAnSU5ERVhfU1RBUlQnKSB7IHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmRpdGlvbixhY3Rpb24pIH07XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUuY2xvc2VPcGVuVGFnQXR0ckxpc3RzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBpZHgkKFQudHlwKHRva2VuKSxbJyknLCdUQUdfQVRUUlNfRU5EJ10pID49IDA7IH07XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIFQuc2V0VHlwKHRva2VuLCdUQUdfQVRUUlNfRU5EJyk7IH07IC8vICdUQUdfQVRUUlNfRU5EJ1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0aWYgKFQudHlwKHRva2VuKSA9PSAnVEFHX0FUVFJTX1NUQVJUJykgeyBzZWxmLmRldGVjdEVuZChpICsgMSxjb25kaXRpb24sYWN0aW9uKSB9O1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQvLyBUaGUgbGV4ZXIgaGFzIHRhZ2dlZCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvZiBhbiBpbmRleGluZyBvcGVyYXRpb24gY2FsbC5cblx0Ly8gTWF0Y2ggaXQgd2l0aCBpdHMgcGFpcmVkIGNsb3NlLiBTaG91bGQgYmUgZG9uZSBpbiBsZXhlciBkaXJlY3RseVxuXHRSZXdyaXRlci5wcm90b3R5cGUuY2xvc2VPcGVuVGFncyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gaWR4JChULnR5cCh0b2tlbiksWyc+JywnVEFHX0VORCddKSA+PSAwOyB9O1xuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBULnNldFR5cCh0b2tlbiwnVEFHX0VORCcpOyB9OyAvLyB0b2tlblswXSA9ICdUQUdfRU5EJ1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0aWYgKFQudHlwKHRva2VuKSA9PSAnVEFHX1NUQVJUJykgeyBzZWxmLmRldGVjdEVuZChpICsgMSxjb25kaXRpb24sYWN0aW9uKSB9O1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUuYWRkSW1wbGljaXRDb21tYXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUuYWRkSW1wbGljaXRCbG9ja0NhbGxzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRva2VuO1xuXHRcdHZhciBpID0gMTtcblx0XHR2YXIgdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuXHRcdFxuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHR2YXIgdCA9IHRva2VuLl90eXBlO1xuXHRcdFx0dmFyIHYgPSB0b2tlbi5fdmFsdWU7XG5cdFx0XHQvLyBobW1cblx0XHRcdGlmICh0ID09ICdETycgJiYgKHYgPT0gJ0lOREVYX0VORCcgfHwgdiA9PSAnSURFTlRJRklFUicgfHwgdiA9PSAnTkVXJykpIHtcblx0XHRcdFx0dG9rZW5zLnNwbGljZShpICsgMSwwLFQudG9rZW4oJ0NBTExfRU5EJywnKScpKTtcblx0XHRcdFx0dG9rZW5zLnNwbGljZShpICsgMSwwLFQudG9rZW4oJ0NBTExfU1RBUlQnLCcoJykpO1xuXHRcdFx0XHRpKys7XG5cdFx0XHR9O1xuXHRcdFx0aSsrO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gT2JqZWN0IGxpdGVyYWxzIG1heSBiZSB3cml0dGVuIHdpdGggaW1wbGljaXQgYnJhY2VzLCBmb3Igc2ltcGxlIGNhc2VzLlxuXHQvLyBJbnNlcnQgdGhlIG1pc3NpbmcgYnJhY2VzIGhlcmUsIHNvIHRoYXQgdGhlIHBhcnNlciBkb2Vzbid0IGhhdmUgdG8uXG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdEJyYWNlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgc3RhY2sgPSBbXTtcblx0XHR2YXIgc3RhcnQgPSBudWxsO1xuXHRcdHZhciBzdGFydEluZGVudCA9IDA7XG5cdFx0dmFyIHN0YXJ0SWR4ID0gbnVsbDtcblx0XHRcblx0XHR2YXIgbm9CcmFjZVRhZyA9IFsnQ0xBU1MnLCdJRicsJ1VOTEVTUycsJ1RBRycsJ1dISUxFJywnRk9SJywnVU5USUwnLCdDQVRDSCcsJ0ZJTkFMTFknLCdNT0RVTEUnLCdMRUFESU5HX1dIRU4nXTtcblx0XHR2YXIgbm9CcmFjZUNvbnRleHQgPSBbJ0lGJywnVEVSTkFSWScsJ0ZPUiddO1xuXHRcdFxuXHRcdHZhciBub0JyYWNlID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIHNjb3BlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gfHwgW107XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0cmV0dXJuIHNlbGYuX3Rva2Vucy5zcGxpY2UoaSwwLFQuUkJSQUNLRVQpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIG9wZW4gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdG9rZW5zLnNwbGljZShpLDAsVC5MQlJBQ0tFVCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgY2xvc2UgPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdG9rZW5zLnNwbGljZShpLDAsVC5SQlJBQ0tFVCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc3RhY2tUb2tlbiA9IGZ1bmN0aW9uKGEsYikge1xuXHRcdFx0cmV0dXJuIFthLGJdO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpLHRva2Vucykge1xuXHRcdFx0dmFyIHR5cGUgPSBULnR5cCh0b2tlbik7XG5cdFx0XHR2YXIgdiA9IFQudmFsKHRva2VuKTtcblx0XHRcdHZhciBjdHggPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXSB8fCBbXTtcblx0XHRcdHZhciBpZHg7XG5cdFx0XHRcblx0XHRcdGlmIChub0JyYWNlQ29udGV4dC5pbmRleE9mKHR5cGUpID49IDApIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJmb3VuZCBub0JyYWNlVGFnIHt0eXBlfVwiXG5cdFx0XHRcdHN0YWNrLnB1c2goc3RhY2tUb2tlbih0eXBlLGkpKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodiA9PSAnPycpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1RFUk5BUlkgT1BFUkFUT1IhJylcblx0XHRcdFx0c3RhY2sucHVzaChzdGFja1Rva2VuKCdURVJOQVJZJyxpKSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbm8gbmVlZCB0byB0ZXN0IGZvciB0aGlzIGhlcmUgYXMgd2VsbCBhcyBpblxuXHRcdFx0aWYgKEVYUFJFU1NJT05fU1RBUlQuaW5kZXhPZih0eXBlKSA+PSAwKSB7XG5cdFx0XHRcdGlmICh0eXBlID09ICdJTkRFTlQnICYmIG5vQnJhY2VDb250ZXh0LmluZGV4T2YoY3R4WzBdKSA+PSAwKSB7XG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnZXhwcmVzc2lvbiBzdGFydCcsdHlwZSxjdHhbMF0pXG5cdFx0XHRcdGlmICh0eXBlID09ICdJTkRFTlQnICYmIHNlbGYudG9rZW5UeXBlKGkgLSAxKSA9PSAneycpIHtcblx0XHRcdFx0XHQvLyBzdGFjayA/IT8gbm8gdG9rZW5cblx0XHRcdFx0XHRzdGFjay5wdXNoKHN0YWNrVG9rZW4oJ3snLGkpKTsgLy8gc2hvdWxkIG5vdCBhdXRvZ2VuZXJhdGUgYW5vdGhlcj9cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHN0YWNrVG9rZW4odHlwZSxpKSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKEVYUFJFU1NJT05fRU5ELmluZGV4T2YodHlwZSkgPj0gMCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcIkVYUFJFU1NJT05fRU5EIGF0IHt0eXBlfSAtIHN0YWNrIGlzIHtjdHhbMF19XCJcblx0XHRcdFx0aWYgKGN0eFswXSA9PSAnVEVSTkFSWScpIHsgLy8gRklYP1xuXHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0c3RhcnQgPSBzdGFjay5wb3AoKTtcblx0XHRcdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiTk8gU1RBQ0shIVwiKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0c3RhcnRbMl0gPSBpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gc2VlbXMgbGlrZSB0aGUgc3RhY2sgc2hvdWxkIHVzZSB0b2tlbnMsIG5vPylcblx0XHRcdFx0aWYgKHN0YXJ0WzBdID09ICd7JyAmJiBzdGFydC5nZW5lcmF0ZWQpIHsgLy8gICMgdHlwZSAhPSAnfScgIyBhbmQgc3RhcnQ6Z2VuZXJhdGVkXG5cdFx0XHRcdFx0Y2xvc2UodG9rZW4saSk7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGlzIHRoaXMgY29ycmVjdD8gc2FtZSBmb3IgaWYvY2xhc3MgZXRjP1xuXHRcdFx0aWYgKGN0eFswXSA9PSAnVEVSTkFSWScgJiYgKHR5cGUgPT0gJ1RFUk1JTkFUT1InIHx8IHR5cGUgPT0gJ09VVERFTlQnKSkge1xuXHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobm9CcmFjZUNvbnRleHQuaW5kZXhPZihjdHhbMF0pID49IDAgJiYgdHlwZSA9PSAnSU5ERU5UJykge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcInBvcHBpbmcgbm9CcmFjZUNvbnRleHRcIik7XG5cdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGUgPT0gJywnKSB7XG5cdFx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgYWRkIGFuIGVuZGluZyBoZXJlIGlmIGluc2lkZTpnZW5lcmF0ZWQgc2NvcGU/XG5cdFx0XHRcdC8vIGl0IGlzIGltcG9ydGFudCB0aGF0IHRoaXMgaXM6Z2VuZXJhdGVkKCEpXG5cdFx0XHRcdGlmIChjdHhbMF0gPT0gJ3snICYmIGN0eC5nZW5lcmF0ZWQpIHtcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksMCxULlJCUkFDS0VUKTtcblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fTtcblx0XHRcdFx0dHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGZvdW5kIGEgdHlwZVxuXHRcdFx0aWYgKHR5cGUgPT0gJzonICYmIGN0eFswXSAhPSAneycgJiYgY3R4WzBdICE9ICdURVJOQVJZJyAmJiAobm9CcmFjZUNvbnRleHQuaW5kZXhPZihjdHhbMF0pID09IC0xKSkge1xuXHRcdFx0XHQvLyBjb3VsZCBqdXN0IGNoZWNrIGlmIHRoZSBlbmQgd2FzIHJpZ2h0IGJlZm9yZSB0aGlzP1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHN0YXJ0ICYmIHN0YXJ0WzJdID09IGkgLSAxKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ3RoaXMgZXhwcmVzc2lvbiB3YXMganVzdCBlbmRpbmcgYmVmb3JlIGNvbG9uIScpXG5cdFx0XHRcdFx0aWR4ID0gc3RhcnRbMV0gLSAxOyAvLyB0aGVzZSBhcmUgdGhlIHN0YWNrVG9rZW5zXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJyZXdyaXRlIGhlcmU/ICN7aX1cIlxuXHRcdFx0XHRcdGlkeCA9IGkgLSAyOyAvLyBpZiBzdGFydCB0aGVuIHN0YXJ0WzFdIC0gMSBlbHNlIGkgLSAyXG5cdFx0XHRcdFx0Ly8gaWR4ID0gaWR4IC0gMSBpZiB0b2tlblR5cGUoaWR4KSBpcyAnVEVSTUlOQVRPUidcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChzZWxmLnRva2VuVHlwZShpZHggLSAxKSA9PSAnSEVSRUNPTU1FTlQnKXtcblx0XHRcdFx0XHRpZHggLT0gMjtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciB0MCA9IHRva2Vuc1tpZHggLSAxXTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0MCAmJiBULnR5cCh0MCkgPT0gJ30nICYmIHQwLmdlbmVyYXRlZCkge1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaWR4IC0gMSwxKTtcblx0XHRcdFx0XHR2YXIgcyA9IHN0YWNrVG9rZW4oJ3snKTtcblx0XHRcdFx0XHRzLmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChzKTtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fSBlbHNlIGlmICh0MCAmJiBULnR5cCh0MCkgPT0gJywnICYmIHNlbGYudG9rZW5UeXBlKGlkeCAtIDIpID09ICd9Jykge1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaWR4IC0gMiwxKTtcblx0XHRcdFx0XHRzID0gc3RhY2tUb2tlbigneycpO1xuXHRcdFx0XHRcdHMuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHMpO1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHMgPSBzdGFja1Rva2VuKCd7Jyk7XG5cdFx0XHRcdFx0cy5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHN0YWNrLnB1c2gocyk7XG5cdFx0XHRcdFx0b3Blbih0b2tlbixpZHggKyAxKTtcblx0XHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHdlIHByb2JhYmx5IG5lZWQgdG8gcnVuIHRocm91Z2ggYXV0b2NhbGwgZmlyc3Q/IVxuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnRE8nKSB7IC8vIGFuZCBjdHg6Z2VuZXJhdGVkXG5cdFx0XHRcdHZhciBwcmV2ID0gVC50eXAodG9rZW5zW2kgLSAxXSk7IC8vIFswXVxuXHRcdFx0XHRpZiAoWydOVU1CRVInLCdTVFJJTkcnLCdSRUdFWCcsJ1NZTUJPTCcsJ10nLCd9JywnKScsJ1NUUklOR19FTkQnXS5pbmRleE9mKHByZXYpID49IDApIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgdG9rID0gVC50b2tlbignLCcsJywnKTtcblx0XHRcdFx0XHR0b2suZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksMCx0b2spO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChjdHguZ2VuZXJhdGVkKSB7XG5cdFx0XHRcdFx0XHRjbG9zZSh0b2tlbixpKTtcblx0XHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICgodHlwZSA9PSAnVEVSTUlOQVRPUicgfHwgdHlwZSA9PSAnT1VUREVOVCcgfHwgdHlwZSA9PSAnREVGX0JPRFknKSAmJiBjdHguZ2VuZXJhdGVkKSB7XG5cdFx0XHRcdGNsb3NlKHRva2VuLGkpO1xuXHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdC8vIE1ldGhvZHMgbWF5IGJlIG9wdGlvbmFsbHkgY2FsbGVkIHdpdGhvdXQgcGFyZW50aGVzZXMsIGZvciBzaW1wbGUgY2FzZXMuXG5cdC8vIEluc2VydCB0aGUgaW1wbGljaXQgcGFyZW50aGVzZXMgaGVyZSwgc28gdGhhdCB0aGUgcGFyc2VyIGRvZXNuJ3QgaGF2ZSB0b1xuXHQvLyBkZWFsIHdpdGggdGhlbS5cblx0Ly8gUHJhY3RpY2FsbHkgZXZlcnl0aGluZyB3aWxsIG5vdyBiZSBjYWxsYWJsZSB0aGlzIHdheSAoZXZlcnkgaWRlbnRpZmllcilcblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0UGFyZW50aGVzZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHRva2VuO1xuXHRcdHZhciBub0NhbGxUYWcgPSBbJ0NMQVNTJywnSUYnLCdVTkxFU1MnLCdUQUcnLCdXSElMRScsJ0ZPUicsJ1VOVElMJywnQ0FUQ0gnLCdGSU5BTExZJywnTU9EVUxFJywnTEVBRElOR19XSEVOJ107XG5cdFx0XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHJldHVybiBzZWxmLl90b2tlbnMuc3BsaWNlKGksMCxULnRva2VuKCdDQUxMX0VORCcsJyknKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyBcImFkZGluZyBpbXBsaWNpdCBwYXJlbnRoZXNpc1wiICMgLHNlbGY6c2NhblRva2Vuc1xuXHRcdHZhciB0b2tlbnMgPSBzZWxmLl90b2tlbnM7XG5cdFx0XG5cdFx0dmFyIG5vQ2FsbCA9IGZhbHNlO1xuXHRcdHZhciBzZWVuRm9yID0gZmFsc2U7XG5cdFx0dmFyIGVuZENhbGxBdFRlcm1pbmF0b3IgPSBmYWxzZTtcblx0XHRcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdFxuXHRcdFx0Ly8gdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG5cdFx0XHQvLyBpZiBhKGRvIHllcykudGVzdFxuXHRcdFx0Ly8gXHR5ZXNcblx0XHRcdC8vIHdlIG5lZWQgdG8ga2VlcCBhIHN0YWNrIGZvciBiYWxhbmNlZCBwYWlyc1xuXHRcdFx0Ly8gdW50aWwgdGhlbiB5b3UgbXVzdCBleHBsaWNpdGx5IGVuZCB0aGUgY2FsbCBsaWtlXG5cdFx0XHQvLyBpZiBhKGRvIHllcykudGVzdCgpXG5cdFx0XHQvLyBcdHllc1xuXHRcdFx0XG5cdFx0XHR2YXIgdHlwZSA9IHRva2VuLl90eXBlO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHJldiA9IHRva2Vuc1tpIC0gMV07XG5cdFx0XHR2YXIgY3VycmVudCA9IHRva2Vuc1tpXTtcblx0XHRcdHZhciBuZXh0ID0gdG9rZW5zW2kgKyAxXTtcblx0XHRcdFxuXHRcdFx0dmFyIHB0ID0gcHJldiAmJiBwcmV2Ll90eXBlO1xuXHRcdFx0dmFyIG50ID0gbmV4dCAmJiBuZXh0Ll90eXBlO1xuXHRcdFx0XG5cdFx0XHQvLyBpZiBwdCA9PSAnV0hFTidcblx0XHRcdC8vIE5ldmVyIG1ha2UgdGhlc2UgdGFncyBpbXBsaWNpdGx5IGNhbGxcblx0XHRcdC8vIHNob3VsZCB3ZSBub3QganVzdCByZW1vdmUgdGhlc2UgZnJvbSBJTVBMSUNJVF9GVU5DP1xuXHRcdFx0aWYgKChwdCA9PSAnKScgfHwgcHQgPT0gJ10nKSAmJiB0eXBlID09ICdJTkRFTlQnKSB7XG5cdFx0XHRcdG5vQ2FsbCA9IHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobm9DYWxsVGFnLmluZGV4T2YocHQpID49IDApIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJzZWVuIG5vY2FsbCB0YWcge3B0fSAoe3B0fSB7dHlwZX0ge250fSlcIilcblx0XHRcdFx0ZW5kQ2FsbEF0VGVybWluYXRvciA9IHRydWU7XG5cdFx0XHRcdG5vQ2FsbCA9IHRydWU7XG5cdFx0XHRcdGlmIChwdCA9PSAnRk9SJykgeyBzZWVuRm9yID0gdHJ1ZSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHR2YXIgY2FsbE9iamVjdCA9IGZhbHNlO1xuXHRcdFx0dmFyIGNhbGxJbmRlbnQgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Ly8gW3ByZXYsIGN1cnJlbnQsIG5leHRdID0gdG9rZW5zW2kgLSAxIC4uIGkgKyAxXVxuXHRcdFx0XG5cdFx0XHQvLyBjaGVjayBmb3IgY29tbWVudHNcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZGV0ZWN0IGVuZD8/XCJcblx0XHRcdGlmICghbm9DYWxsICYmIHR5cGUgPT0gJ0lOREVOVCcgJiYgbmV4dCkge1xuXHRcdFx0XHR2YXIgcHJldkltcEZ1bmMgPSBwdCAmJiBJTVBMSUNJVF9GVU5DLmluZGV4T2YocHQpID49IDA7XG5cdFx0XHRcdHZhciBuZXh0SW1wQ2FsbCA9IG50ICYmIElNUExJQ0lUX0NBTEwuaW5kZXhPZihudCkgPj0gMDtcblx0XHRcdFx0Y2FsbE9iamVjdCA9ICgobmV4dC5nZW5lcmF0ZWQgJiYgbnQgPT0gJ3snKSB8fCBuZXh0SW1wQ2FsbCkgJiYgcHJldkltcEZ1bmM7XG5cdFx0XHRcdGNhbGxJbmRlbnQgPSBuZXh0SW1wQ2FsbCAmJiBwcmV2SW1wRnVuYztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBzZWVuU2luZ2xlID0gZmFsc2U7XG5cdFx0XHR2YXIgc2VlbkNvbnRyb2wgPSBmYWxzZTtcblx0XHRcdC8vIEhtbSA/XG5cdFx0XHRcblx0XHRcdC8vIHRoaXMgaXMgbm90IGNvcnJlY3QgaWYgdGhpcyBpcyBpbnNpZGUgYSBibG9jayxubz9cblx0XHRcdGlmICgodHlwZSA9PSAnVEVSTUlOQVRPUicgfHwgdHlwZSA9PSAnT1VUREVOVCcgfHwgdHlwZSA9PSAnSU5ERU5UJykpIHtcblx0XHRcdFx0ZW5kQ2FsbEF0VGVybWluYXRvciA9IGZhbHNlO1xuXHRcdFx0XHRub0NhbGwgPSBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlID09ICc/JyAmJiBwcmV2ICYmICFwcmV2LnNwYWNlZCkgeyB0b2tlbi5jYWxsID0gdHJ1ZSB9O1xuXHRcdFx0XG5cdFx0XHQvLyB3aGVyZSBkb2VzIGZyb21UaGVtIGNvbWUgZnJvbT9cblx0XHRcdGlmICh0b2tlbi5mcm9tVGhlbikge1xuXHRcdFx0XHRpICs9IDE7Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gaGVyZSB3ZSBkZWFsIHdpdGggOnNwYWNlZCBhbmQgOm5ld0xpbmVcblx0XHRcdGlmICghKGNhbGxPYmplY3QgfHwgY2FsbEluZGVudCB8fCAocHJldiAmJiBwcmV2LnNwYWNlZCkgJiYgKHByZXYuY2FsbCB8fCBJTVBMSUNJVF9GVU5DLmluZGV4T2YocHQpID49IDApICYmIChJTVBMSUNJVF9DQUxMLmluZGV4T2YodHlwZSkgPj0gMCB8fCAhKHRva2VuLnNwYWNlZCB8fCB0b2tlbi5uZXdMaW5lKSAmJiBJTVBMSUNJVF9VTlNQQUNFRF9DQUxMLmluZGV4T2YodHlwZSkgPj0gMCkpKSB7XG5cdFx0XHRcdGkgKz0gMTtjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dG9rZW5zLnNwbGljZShpLDAsVC50b2tlbignQ0FMTF9TVEFSVCcsJygnKSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImFkZGVkICgge3ByZXZ9XCJcblx0XHRcdHZhciBjb25kID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IFQudHlwKHRva2VuKTtcblx0XHRcdFx0aWYgKCFzZWVuU2luZ2xlICYmIHRva2VuLmZyb21UaGVuKSB7IHJldHVybiB0cnVlIH07XG5cdFx0XHRcdHZhciBpZmVsc2UgPSB0eXBlID09ICdJRicgfHwgdHlwZSA9PSAnVU5MRVNTJyB8fCB0eXBlID09ICdFTFNFJztcblx0XHRcdFx0aWYgKGlmZWxzZSB8fCB0eXBlID09ICdDQVRDSCcpIHsgc2VlblNpbmdsZSA9IHRydWUgfTtcblx0XHRcdFx0aWYgKGlmZWxzZSB8fCB0eXBlID09ICdTV0lUQ0gnIHx8IHR5cGUgPT0gJ1RSWScpIHsgc2VlbkNvbnRyb2wgPSB0cnVlIH07XG5cdFx0XHRcdHZhciBwcmV2ID0gc2VsZi50b2tlblR5cGUoaSAtIDEpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCh0eXBlID09ICcuJyB8fCB0eXBlID09ICc/LicgfHwgdHlwZSA9PSAnOjonKSAmJiBwcmV2ID09ICdPVVRERU5UJykgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoZW5kQ2FsbEF0VGVybWluYXRvciAmJiAodHlwZSA9PSAnSU5ERU5UJyB8fCB0eXBlID09ICdURVJNSU5BVE9SJykpIHsgcmV0dXJuIHRydWUgfTtcblx0XHRcdFx0aWYgKCh0eXBlID09ICdXSEVOJyB8fCB0eXBlID09ICdCWScpICYmICFzZWVuRm9yKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJkb250IGNsb3NlIGltcGxpY2l0IGNhbGwgb3V0c2lkZSBmb3JcIlxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBwb3N0ID0gdG9rZW5zW2kgKyAxXTtcblx0XHRcdFx0dmFyIHBvc3RUeXAgPSBwb3N0ICYmIFQudHlwKHBvc3QpO1xuXHRcdFx0XHQvLyBXVEZcblx0XHRcdFx0cmV0dXJuICF0b2tlbi5nZW5lcmF0ZWQgJiYgcHJldiAhPSAnLCcgJiYgKElNUExJQ0lUX0VORC5pbmRleE9mKHR5cGUpID49IDAgfHwgKHR5cGUgPT0gJ0lOREVOVCcgJiYgIXNlZW5Db250cm9sKSB8fCAodHlwZSA9PSAnRE9TJyAmJiBwcmV2ICE9ICc9JykpICYmICh0eXBlICE9ICdJTkRFTlQnIHx8IChzZWxmLnRva2VuVHlwZShpIC0gMikgIT0gJ0NMQVNTJyAmJiBJTVBMSUNJVF9CTE9DSy5pbmRleE9mKHByZXYpID09IC0xICYmICEocG9zdCAmJiAoKHBvc3QuZ2VuZXJhdGVkICYmIHBvc3RUeXAgPT0gJ3snKSB8fCBJTVBMSUNJVF9DQUxMLmluZGV4T2YocG9zdFR5cCkgPj0gMCkpKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgYWN0aW9uIGZvciBkZXRlY3Rpbmcgd2hlbiB0aGUgY2FsbCBzaG91bGQgZW5kXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImRldGVjdCBlbmQ/P1wiXG5cdFx0XHRzZWxmLmRldGVjdEVuZChpICsgMSxjb25kLGFjdGlvbik7XG5cdFx0XHRpZiAoVC50eXAocHJldikgPT0gJz8nKSB7IFQuc2V0VHlwKHByZXYsJ0ZVTkNfRVhJU1QnKSB9O1xuXHRcdFx0aSArPSAyO1xuXHRcdFx0Ly8gbmVlZCB0byByZXNldCBhZnRlciBhIG1hdGNoXG5cdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0gZmFsc2U7XG5cdFx0XHRub0NhbGwgPSBmYWxzZTtcblx0XHRcdHNlZW5Gb3IgPSBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIEJlY2F1c2Ugb3VyIGdyYW1tYXIgaXMgTEFMUigxKSwgaXQgY2FuJ3QgaGFuZGxlIHNvbWUgc2luZ2xlLWxpbmVcblx0Ly8gZXhwcmVzc2lvbnMgdGhhdCBsYWNrIGVuZGluZyBkZWxpbWl0ZXJzLiBUaGUgKipSZXdyaXRlcioqIGFkZHMgdGhlIGltcGxpY2l0XG5cdC8vIGJsb2Nrcywgc28gaXQgZG9lc24ndCBuZWVkIHRvLiAnKScgY2FuIGNsb3NlIGEgc2luZ2xlLWxpbmUgYmxvY2ssXG5cdC8vIGJ1dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdCdzIGJhbGFuY2VkLlxuXHRSZXdyaXRlci5wcm90b3R5cGUuYWRkSW1wbGljaXRJbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdFxuXHRcdHZhciBzZWxmID0gdGhpcywgdG9rZW47XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciB0b2tlbnMgPSBzZWxmLl90b2tlbnM7XG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdHZhciB0eXBlID0gVC50eXAodG9rZW4pO1xuXHRcdFx0dmFyIG5leHQgPSBzZWxmLnRva2VuVHlwZShpICsgMSk7XG5cdFx0XHRcblx0XHRcdC8vIHdoeSBhcmUgd2UgcmVtb3ZpbmcgdGVybWluYXRvcnMgYWZ0ZXIgdGhlbj8gc2hvdWxkIGJlIGFibGUgdG8gaGFuZGxlXG5cdFx0XHRpZiAodHlwZSA9PSAnVEVSTUlOQVRPUicgJiYgbmV4dCA9PSAnVEhFTicpIHtcblx0XHRcdFx0dG9rZW5zLnNwbGljZShpLDEpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlID09ICdDQVRDSCcgJiYgaWR4JChzZWxmLnRva2VuVHlwZShpICsgMiksWydPVVRERU5UJywnVEVSTUlOQVRPUicsJ0ZJTkFMTFknXSkgPj0gMCkge1xuXHRcdFx0XHR0b2tlbnMuc3BsaWNlLmFwcGx5KHRva2VucyxbXS5jb25jYXQoW2kgKyAyLDBdLCBbXS5zbGljZS5jYWxsKHNlbGYuaW5kZW50YXRpb24odG9rZW4pKSkpO1xuXHRcdFx0XHRpICs9IDQ7Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoU0lOR0xFX0xJTkVSUy5pbmRleE9mKHR5cGUpID49IDAgJiYgKG5leHQgIT0gJ0lOREVOVCcgJiYgbmV4dCAhPSAnQkxPQ0tfUEFSQU1fU1RBUlQnKSAmJiAhKHR5cGUgPT0gJ0VMU0UnICYmIG5leHQgPT0gJ0lGJykgJiYgdHlwZSAhPSAnRUxJRicpIHtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBzdGFydGVyID0gdHlwZTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBpbmRlbnQgPSBULnRva2VuKCdJTkRFTlQnLCcyJyk7XG5cdFx0XHRcdHZhciBvdXRkZW50ID0gVC5PVVRERU5UO1xuXHRcdFx0XHQvLyB2YXIgaW5kZW50LCBvdXRkZW50ID0gaW5kZW50YXRpb24odG9rZW4pXG5cdFx0XHRcdGlmIChzdGFydGVyID09ICdUSEVOJykgeyBpbmRlbnQuZnJvbVRoZW4gPSB0cnVlIH07IC8vIHNldHRpbmcgc3BlY2lhbCB2YWx1ZXMgZm9yIHRoZXNlIC0tIGNhbm5vdCByZWFsbHkgcmV1c2U/XG5cdFx0XHRcdGluZGVudC5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcdFx0XHQvLyBvdXRkZW50OmdlbmVyYXRlZCA9IHRydWVcblx0XHRcdFx0dG9rZW5zLnNwbGljZShpICsgMSwwLGluZGVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0XHRcdHZhciB0ID0gVC50eXAodG9rZW4pO1xuXHRcdFx0XHRcdHJldHVybiBULnZhbCh0b2tlbikgIT0gJzsnICYmIFNJTkdMRV9DTE9TRVJTLmluZGV4T2YodCkgPj0gMCAmJiAhKHQgPT0gJ0VMU0UnICYmIHN0YXJ0ZXIgIT0gJ0lGJyAmJiBzdGFydGVyICE9ICdUSEVOJyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0XHRcdHZhciBpZHggPSBzZWxmLnRva2VuVHlwZShpIC0gMSkgPT0gJywnID8gKGkgLSAxKSA6IChpKTtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLnNwbGljZShpZHgsMCxvdXRkZW50KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHNlbGYuZGV0ZWN0RW5kKGkgKyAyLGNvbmRpdGlvbixhY3Rpb24pO1xuXHRcdFx0XHRpZiAodHlwZSA9PSAnVEhFTicpIHsgdG9rZW5zLnNwbGljZShpLDEpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpKys7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBUYWcgcG9zdGZpeCBjb25kaXRpb25hbHMgYXMgc3VjaCwgc28gdGhhdCB3ZSBjYW4gcGFyc2UgdGhlbSB3aXRoIGFcblx0Ly8gZGlmZmVyZW50IHByZWNlZGVuY2UuXG5cdFJld3JpdGVyLnByb3RvdHlwZS50YWdQb3N0Zml4Q29uZGl0aW9uYWxzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBpZHgkKFQudHlwKHRva2VuKSxbJ1RFUk1JTkFUT1InLCdJTkRFTlQnXSkgPj0gMDsgfTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHZhciB0eXAgPSBULnR5cCh0b2tlbik7XG5cdFx0XHRpZiAoISh0eXAgPT0gJ0lGJyB8fCB0eXAgPT0gJ0ZPUicpKSB7IHJldHVybiAxIH07XG5cdFx0XHR2YXIgb3JpZ2luYWwgPSB0b2tlbjtcblx0XHRcdHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmRpdGlvbixmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRcdGlmIChULnR5cCh0b2tlbikgIT0gJ0lOREVOVCcpIHsgcmV0dXJuIFQuc2V0VHlwKG9yaWdpbmFsLCdQT1NUXycgKyBULnR5cChvcmlnaW5hbCkpIH07XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0Ly8gR2VuZXJhdGUgdGhlIGluZGVudGF0aW9uIHRva2VucywgYmFzZWQgb24gYW5vdGhlciB0b2tlbiBvbiB0aGUgc2FtZSBsaW5lLlxuXHRSZXdyaXRlci5wcm90b3R5cGUuaW5kZW50YXRpb24gPSBmdW5jdGlvbiAodG9rZW4pe1xuXHRcdHJldHVybiBbVC50b2tlbignSU5ERU5UJywnMicpLFQudG9rZW4oJ09VVERFTlQnLCcyJyldO1xuXHR9O1xuXHRcblx0Ly8gTG9vayB1cCBhIHR5cGUgYnkgdG9rZW4gaW5kZXguXG5cdFJld3JpdGVyLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKGkpe1xuXHRcdC8vIGlmIGkgPCAwIHRoZW4gcmV0dXJuIG51bGxcblx0XHR2YXIgdG9rID0gdGhpcy5fdG9rZW5zW2ldO1xuXHRcdHJldHVybiB0b2sgJiYgVC50eXAodG9rKTtcblx0XHQvLyBpZiB0b2sgdGhlbiB0b2tbMF0gZWxzZSBudWxsXG5cdH07XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUudG9rZW5UeXBlID0gZnVuY3Rpb24gKGkpe1xuXHRcdHZhciB0b2sgPSB0aGlzLl90b2tlbnNbaV07XG5cdFx0cmV0dXJuIHRvayAmJiBULnR5cCh0b2spO1xuXHRcdC8vIHJldHVybiB0b2sgYW5kIHRva1swXVxuXHR9O1xuXHRcblx0Ly8gQ29uc3RhbnRzXG5cdC8vIC0tLS0tLS0tLVxuXHRcblx0Ly8gTGlzdCBvZiB0aGUgdG9rZW4gcGFpcnMgdGhhdCBtdXN0IGJlIGJhbGFuY2VkLlxuXHR2YXIgQkFMQU5DRURfUEFJUlMgPSBbXG5cdFx0WycoJywnKSddLFxuXHRcdFsnWycsJ10nXSxcblx0XHRbJ3snLCd9J10sXG5cdFx0Wyd7eycsJ319J10sXG5cdFx0WydJTkRFTlQnLCdPVVRERU5UJ10sXG5cdFx0WydDQUxMX1NUQVJUJywnQ0FMTF9FTkQnXSxcblx0XHRbJ1BBUkFNX1NUQVJUJywnUEFSQU1fRU5EJ10sXG5cdFx0WydJTkRFWF9TVEFSVCcsJ0lOREVYX0VORCddLFxuXHRcdFsnVEFHX1NUQVJUJywnVEFHX0VORCddLFxuXHRcdFsnVEFHX1BBUkFNX1NUQVJUJywnVEFHX1BBUkFNX0VORCddLFxuXHRcdFsnVEFHX0FUVFJTX1NUQVJUJywnVEFHX0FUVFJTX0VORCddLFxuXHRcdFsnQkxPQ0tfUEFSQU1fU1RBUlQnLCdCTE9DS19QQVJBTV9FTkQnXVxuXHRdO1xuXHRcblx0Ly8gVGhlIGludmVyc2UgbWFwcGluZ3Mgb2YgYEJBTEFOQ0VEX1BBSVJTYCB3ZSdyZSB0cnlpbmcgdG8gZml4IHVwLCBzbyB3ZSBjYW5cblx0Ly8gbG9vayB0aGluZ3MgdXAgZnJvbSBlaXRoZXIgZW5kLlxuXHRtb2R1bGUuZXhwb3J0cy5JTlZFUlNFUyA9IElOVkVSU0VTID0ge307XG5cdFxuXHQvLyBUaGUgdG9rZW5zIHRoYXQgc2lnbmFsIHRoZSBzdGFydC9lbmQgb2YgYSBiYWxhbmNlZCBwYWlyLlxuXHQvLyB2YXIgRVhQUkVTU0lPTl9TVEFSVCA9IFtdXG5cdC8vIHZhciBFWFBSRVNTSU9OX0VORCAgID0gW11cblx0XG5cdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChCQUxBTkNFRF9QQUlSUyksIGxlbiA9IGFyeS5sZW5ndGgsIHBhaXI7IGkgPCBsZW47IGkrKykge1xuXHRcdHBhaXIgPSBhcnlbaV07XG5cdFx0dmFyIGxlZnQgPSBwYWlyWzBdO1xuXHRcdHZhciByaXRlID0gcGFpclsxXTtcblx0XHRJTlZFUlNFU1tyaXRlXSA9IGxlZnQ7XG5cdFx0SU5WRVJTRVNbbGVmdF0gPSByaXRlO1xuXHR9O1xuXHRcblx0dmFyIEVYUFJFU1NJT05fU1RBUlQgPSBbJygnLCdbJywneycsJ0lOREVOVCcsJ0NBTExfU1RBUlQnLCdQQVJBTV9TVEFSVCcsJ0lOREVYX1NUQVJUJywnVEFHX1BBUkFNX1NUQVJUJywnQkxPQ0tfUEFSQU1fU1RBUlQnLCdTVFJJTkdfU1RBUlQnLCd7eycsJ1RBR19TVEFSVCddO1xuXHR2YXIgRVhQUkVTU0lPTl9FTkQgPSBbJyknLCddJywnfScsJ09VVERFTlQnLCdDQUxMX0VORCcsJ1BBUkFNX0VORCcsJ0lOREVYX0VORCcsJ1RBR19QQVJBTV9FTkQnLCdCTE9DS19QQVJBTV9FTkQnLCdTVFJJTkdfRU5EJywnfX0nLCdUQUdfRU5EJ107XG5cdFxuXHR2YXIgSURFTlRJRklFUlMgPSBbJ0lERU5USUZJRVInLCdHVkFSJywnSVZBUicsJ0NWQVInLCdDT05TVCcsJ0FSR1ZBUiddO1xuXHRcblx0Ly8gVG9rZW5zIHRoYXQgaW5kaWNhdGUgdGhlIGNsb3NlIG9mIGEgY2xhdXNlIG9mIGFuIGV4cHJlc3Npb24uXG5cdHZhciBFWFBSRVNTSU9OX0NMT1NFID0gWydDQVRDSCcsJ1dIRU4nLCdFTFNFJywnRklOQUxMWSddLmNvbmNhdChFWFBSRVNTSU9OX0VORCk7XG5cdFxuXHQvLyBUb2tlbnMgdGhhdCwgaWYgZm9sbG93ZWQgYnkgYW4gYElNUExJQ0lUX0NBTExgLCBpbmRpY2F0ZSBhIGZ1bmN0aW9uIGludm9jYXRpb24uXG5cdHZhciBJTVBMSUNJVF9GVU5DID0gWydJREVOVElGSUVSJywnU1VQRVInLCdAJywnVEhJUycsJ1NFTEYnLCdFVkVOVCcsJ1RSSUdHRVInLCdUQUdfRU5EJywnSVZBUicsXG5cdCdHVkFSJywnQ09OU1QnLCdBUkdWQVInLCdORVcnLCdCUkVBSycsJ0NPTlRJTlVFJywnUkVUVVJOJ107XG5cdFxuXHQvLyBJZiBwcmVjZWRlZCBieSBhbiBgSU1QTElDSVRfRlVOQ2AsIGluZGljYXRlcyBhIGZ1bmN0aW9uIGludm9jYXRpb24uXG5cdHZhciBJTVBMSUNJVF9DQUxMID0gW1xuXHRcdCdTRUxFQ1RPUicsJ0lERU5USUZJRVInLCdOVU1CRVInLCdTVFJJTkcnLCdTWU1CT0wnLCdKUycsJ1JFR0VYJywnTkVXJywnUEFSQU1fU1RBUlQnLCdDTEFTUycsXG5cdFx0J0lGJywnVU5MRVNTJywnVFJZJywnU1dJVENIJywnVEhJUycsJ0JPT0wnLCdUUlVFJywnRkFMU0UnLCdOVUxMJywnVU5ERUZJTkVEJywnVU5BUlknLCdTVVBFUicsJ0lWQVInLCdHVkFSJywnQ09OU1QnLCdBUkdWQVInLCdTRUxGJyxcblx0XHQnQCcsJ1snLCcoJywneycsJy0tJywnKysnLCdTRUxFQ1RPUicsJ1RBR19TVEFSVCcsJ1RBR0lEJywnIycsJ1NFTEVDVE9SX1NUQVJUJywnSURSRUYnLCdTUExBVCcsJ0RPJywnQkxPQ0tfQVJHJyxcblx0XHQnRk9SJywnU1RSSU5HX1NUQVJUJywnQ09OVElOVUUnLCdCUkVBSydcblx0XTsgLy8gJy0+JywgJz0+Jywgd2h5IGRvZXMgaXQgbm90IHdvcmsgd2l0aCBzeW1ib2w/XG5cdFxuXHR2YXIgSU1QTElDSVRfSU5ERU5UX0NBTEwgPSBbXG5cdFx0J0ZPUidcblx0XTtcblx0Ly8gaXMgbm90IGRvIGFuIGltcGxpY2l0IGNhbGw/P1xuXHRcblx0dmFyIElNUExJQ0lUX1VOU1BBQ0VEX0NBTEwgPSBbJysnLCctJ107XG5cdFxuXHQvLyBUb2tlbnMgaW5kaWNhdGluZyB0aGF0IHRoZSBpbXBsaWNpdCBjYWxsIG11c3QgZW5jbG9zZSBhIGJsb2NrIG9mIGV4cHJlc3Npb25zLlxuXHR2YXIgSU1QTElDSVRfQkxPQ0sgPSBbJ3snLCdbJywnLCcsJ0JMT0NLX1BBUkFNX0VORCcsJ0RPJ107IC8vICctPicsICc9PicsIFxuXHRcblx0dmFyIENPTkRJVElPTkFMX0FTU0lHTiA9IFsnfHw9JywnJiY9JywnPz0nLCcmPScsJ3w9J107XG5cdHZhciBDT01QT1VORF9BU1NJR04gPSBbJy09JywnKz0nLCcvPScsJyo9JywnJT0nLCd8fD0nLCcmJj0nLCc/PScsJzw8PScsJz4+PScsJz4+Pj0nLCcmPScsJ149JywnfD0nXTtcblx0dmFyIFVOQVJZID0gWychJywnficsJ05FVycsJ1RZUEVPRicsJ0RFTEVURSddO1xuXHR2YXIgTE9HSUMgPSBbJyYmJywnfHwnLCcmJywnfCcsJ14nXTtcblx0XG5cdC8vIG9wdGltaXplIGZvciBmaXhlZCBhcnJheXNcblx0dmFyIE5PX0lNUExJQ0lUX0JMT0NLX0NBTEwgPSBbXG5cdFx0J0NBTExfRU5EJywnPScsJ0RFRl9CT0RZJywnKCcsJ0NBTExfU1RBUlQnLCcsJywnOicsJ1JFVFVSTicsXG5cdFx0Jy09JywnKz0nLCcvPScsJyo9JywnJT0nLCd8fD0nLCcmJj0nLCc/PScsJzw8PScsJz4+PScsJz4+Pj0nLCcmPScsJ149JywnfD0nXG5cdF07IC8vIC5jb25jYXQoQ09NUE9VTkRfQVNTSUdOKVxuXHRcblx0XG5cdC8vIGNvbnNvbGUubG9nIE5PX0lNUExJQ0lUX0JMT0NLX0NBTEw6bGVuZ3RoXG5cdC8vIE5PX0lNUExJQ0lUX0JMT0NLX0NBTExcblx0Ly8gSU1QTElDSVRfQ09NTUEgPSBbJy0+JywgJz0+JywgJ3snLCAnWycsICdOVU1CRVInLCAnU1RSSU5HJywgJ1NZTUJPTCcsICdJREVOVElGSUVSJywnRE8nXVxuXHRcblx0dmFyIElNUExJQ0lUX0NPTU1BID0gWydETyddO1xuXHRcblx0Ly8gVG9rZW5zIHRoYXQgYWx3YXlzIG1hcmsgdGhlIGVuZCBvZiBhbiBpbXBsaWNpdCBjYWxsIGZvciBzaW5nbGUtbGluZXJzLlxuXHR2YXIgSU1QTElDSVRfRU5EID0gWydQT1NUX0lGJywnUE9TVF9VTkxFU1MnLCdQT1NUX0ZPUicsJ1dISUxFJywnVU5USUwnLCdXSEVOJywnQlknLCdMT09QJywnVEVSTUlOQVRPUicsJ0RFRl9CT0RZJywnREVGX0ZSQUdNRU5UJ107XG5cdFxuXHQvLyBTaW5nbGUtbGluZSBmbGF2b3JzIG9mIGJsb2NrIGV4cHJlc3Npb25zIHRoYXQgaGF2ZSB1bmNsb3NlZCBlbmRpbmdzLlxuXHQvLyBUaGUgZ3JhbW1hciBjYW4ndCBkaXNhbWJpZ3VhdGUgdGhlbSwgc28gd2UgaW5zZXJ0IHRoZSBpbXBsaWNpdCBpbmRlbnRhdGlvbi5cblx0dmFyIFNJTkdMRV9MSU5FUlMgPSBbJ0VMU0UnLCdUUlknLCdGSU5BTExZJywnVEhFTicsJ0JMT0NLX1BBUkFNX0VORCcsJ0RPJywnQkVHSU4nLCdDQVRDSF9WQVInXTsgLy8gJy0+JywgJz0+JywgcmVhbGx5P1xuXHR2YXIgU0lOR0xFX0NMT1NFUlMgPSBbJ1RFUk1JTkFUT1InLCdDQVRDSCcsJ0ZJTkFMTFknLCdFTFNFJywnT1VUREVOVCcsJ0xFQURJTkdfV0hFTiddO1xuXHRcblx0Ly8gVG9rZW5zIHRoYXQgZW5kIGEgbGluZS5cblx0cmV0dXJuIExJTkVCUkVBS1MgPSBbJ1RFUk1JTkFUT1InLCdJTkRFTlQnLCdPVVRERU5UJ107XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvc3JjL2NvbXBpbGVyL3Jld3JpdGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGhlbHBlciBmb3Igc3ViY2xhc3Npbmdcblx0ZnVuY3Rpb24gc3ViY2xhc3MkKG9iaixzdXApIHtcblx0XHRmb3IgKHZhciBrIGluIHN1cCkge1xuXHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgb2JqW2tdID0gc3VwW2tdO1xuXHRcdH07XG5cdFx0Ly8gb2JqLl9fc3VwZXJfXyA9IHN1cDtcblx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xuXHRcdG9iai5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmo7XG5cdH07XG5cdFxuXHQvLyBjcmVhdGUgc2VwYXJhdGUgZXJyb3ItdHlwZXMgd2l0aCBhbGwgdGhlIGxvZ2ljXG5cdFxuXHRmdW5jdGlvbiBJbWJhUGFyc2VFcnJvcihlLG8pe1xuXHRcdHRoaXMuZXJyb3IgPSBlO1xuXHRcdHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZTtcblx0XHR0aGlzLmZpbGVuYW1lID0gZS5maWxlbmFtZTtcblx0XHR0aGlzLmxpbmUgPSBlLmxpbmU7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG8gfHwge307XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChJbWJhUGFyc2VFcnJvcixFcnJvcik7XG5cdGV4cG9ydHMuSW1iYVBhcnNlRXJyb3IgPSBJbWJhUGFyc2VFcnJvcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbWJhUGFyc2VFcnJvci53cmFwID0gZnVuY3Rpb24gKGVycil7XG5cdFx0Ly8gd2hhdCBhYm91dCB0aGUgc3RhY2t0cmFjZT9cblx0XHRyZXR1cm4gbmV3IEltYmFQYXJzZUVycm9yKGVycik7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdHMpe1xuXHRcdHRoaXMuX29wdGlvbnMgfHwgKHRoaXMuX29wdGlvbnMgPSB7fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvcHRzKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdHRoaXMuX29wdGlvbnNba2V5c1tpXV0gPSBvcHRzW2tleXNbaV1dO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0dmFyIGlkeCA9IG8ucG9zIC0gMTtcblx0XHR2YXIgdG9rID0gby50b2tlbnMgJiYgby50b2tlbnNbaWR4XTtcblx0XHR3aGlsZSAodG9rICYmIHRvay5fbG9jID09IC0xKXtcblx0XHRcdHRvayA9IG8udG9rZW5zWy0taWR4XTtcblx0XHR9O1xuXHRcdHJldHVybiB0b2s7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuZGVzYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBvID0gdGhpcy5fb3B0aW9ucztcblx0XHR2YXIgbXNnID0gdGhpcy5tZXNzYWdlO1xuXHRcdGlmIChvLnRva2VuICYmIG8udG9rZW4uX2xvYyA9PSAtMSkge1xuXHRcdFx0cmV0dXJuICdTeW50YXggRXJyb3InO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbXNnO1xuXHRcdH07XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUubG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHN0YXJ0Xztcblx0XHRyZXR1cm4gKHN0YXJ0XyA9IHRoaXMuc3RhcnQoKSkgJiYgc3RhcnRfLnJlZ2lvbiAgJiYgIHN0YXJ0Xy5yZWdpb24oKTtcblx0fTtcblx0XG5cdEltYmFQYXJzZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0dmFyIHRvayA9IHRoaXMuc3RhcnQoKTtcblx0XHQvLyB2YXIgdG9rID0gbzp0b2tlbnMgYW5kIG86dG9rZW5zW286cG9zIC0gMV1cblx0XHQvLyB2YXIgbG9jID0gdG9rIGFuZCBbdG9rLkBsb2MsdG9rLkBsb2MgKyAodG9rLkBsZW4gb3IgdG9rLkB2YWx1ZTpsZW5ndGgpXSBvciBbMCwwXVxuXHRcdC8vICwgY29sOiB0b2suQGNvbCwgbGluZTogdG9rLkBsaW5lXG5cdFx0Ly8gZ2V0IHRoZSB0b2tlbiBpdHNlbGY/XG5cdFx0cmV0dXJuIHt3YXJuOiB0cnVlLG1lc3NhZ2U6IHRoaXMuZGVzYygpLGxvYzogdGhpcy5sb2MoKX07XG5cdH07XG5cdHJldHVybiBJbWJhUGFyc2VFcnJvcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9zcmMvY29tcGlsZXIvZXJyb3JzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuLi9yZWdpb24nKS5SZWdpb247XG5cdFxuXHRcblx0ZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKHN0cil7XG5cdFx0cmV0dXJuICgvXltcXG5cXHRcXCBdKyQvKS50ZXN0KHN0cik7XG5cdH07IGV4cG9ydHMuaXNXaGl0ZXNwYWNlID0gaXNXaGl0ZXNwYWNlO1xuXHRcblx0ZnVuY3Rpb24gY29tbW9uQW5jZXN0b3IoYSxiKXtcblx0XHRpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR2YXIgYXJyID0gYS5zbGljZSgpO1xuXHRcdFx0cmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24ocHJldixjdXJyLGkpIHtcblx0XHRcdFx0cmV0dXJuIGNvbW1vbkFuY2VzdG9yKHByZXYsY3Vycik7XG5cdFx0XHR9LGFyci5zaGlmdCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghYSB8fCAhYikgeyByZXR1cm4gKGEgfHwgYikgfTtcblx0XHRcblx0XHRhID0gYS5fZG9tIHx8IGE7XG5cdFx0YiA9IGIuX2RvbSB8fCBiO1xuXHRcdFxuXHRcdHdoaWxlICghYS5jb250YWlucyhiKSl7XG5cdFx0XHRhID0gYS5wYXJlbnROb2RlO1xuXHRcdH07XG5cdFx0d2hpbGUgKCFiLmNvbnRhaW5zKGEpKXtcblx0XHRcdGIgPSBiLnBhcmVudE5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGFnJHdyYXAoYSk7XG5cdH07IGV4cG9ydHMuY29tbW9uQW5jZXN0b3IgPSBjb21tb25BbmNlc3Rvcjtcblx0XG5cdFxuXHR2YXIgcGFpcnMgPSB7XG5cdFx0J1wiJzogJ1wiJyxcblx0XHRcIidcIjogXCInXCIsXG5cdFx0JygnOiAnKScsXG5cdFx0JzwnOiAnPicsXG5cdFx0J1snOiAnXScsXG5cdFx0J3snOiAnfSdcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHdyYXBUZXh0KHRleHQsb3BlbixjbG9zZSl7XG5cdFx0Y2xvc2UgfHwgKGNsb3NlID0gcGFpcnNbb3Blbl0pO1xuXHRcdGlmIChvcGVuID09IFwiJ1wiKSB7IHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcJy9nLFwiXFxcXCdcIikgfTtcblx0XHRyZXR1cm4gKG9wZW4gfHwgJycpICsgdGV4dCArIChjbG9zZSB8fCAnJyk7XG5cdH07IGV4cG9ydHMud3JhcFRleHQgPSB3cmFwVGV4dDtcblx0XG5cdFxuXHRmdW5jdGlvbiBzdHJpbmdJc0JhbGFuY2VkKHN0cil7XG5cdFx0dmFyIG9wZW5zID0gJ1t7KFwiXFwnJztcblx0XHR2YXIgY2xvc2VzID0gJ119KVwiXFwnJztcblx0XHR2YXIgc3RhY2sgPSBbXTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHMsZW5kO1xuXHRcdFxuXHRcdHdoaWxlIChzID0gc3RyW2krK10pe1xuXHRcdFx0dmFyIG9pZCA9IG9wZW5zLmluZGV4T2Yocyk7XG5cdFx0XHRcblx0XHRcdGlmIChzID09IGVuZCkge1xuXHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0ZW5kID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHR9IGVsc2UgaWYgKG9pZCA+PSAwKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gY2xvc2VzW29pZF0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzdGFjay5sZW5ndGggPT0gMCA/ICh0cnVlKSA6IChmYWxzZSk7XG5cdH07IGV4cG9ydHMuc3RyaW5nSXNCYWxhbmNlZCA9IHN0cmluZ0lzQmFsYW5jZWQ7XG5cdFxuXHRmdW5jdGlvbiBjb2xUb0xvYyhsaW5lLGNvbCx0YWJzaXplKXtcblx0XHRpZih0YWJzaXplID09PSB1bmRlZmluZWQpIHRhYnNpemUgPSA0O1xuXHRcdHZhciBjaSA9IDA7XG5cdFx0dmFyIHJjaSA9IDA7IC8vIHJlYWwgY29sdW1uXG5cdFx0dmFyIGNoYXIkO1xuXHRcdFxuXHRcdGlmIChjb2wgPT0gMCkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdHdoaWxlIChjaGFyJCA9IGxpbmVbY2krK10pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXHQnKSB7XG5cdFx0XHRcdHZhciByZXN0ID0gdGFic2l6ZSAtIHJjaSAlIHRhYnNpemU7XG5cdFx0XHRcdHJjaSArPSByZXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmNpICs9IDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAocmNpID49IGNvbCkge1xuXHRcdFx0XHRyZXR1cm4gY2k7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGxpbmUubGVuZ3RoO1xuXHR9OyBleHBvcnRzLmNvbFRvTG9jID0gY29sVG9Mb2M7XG5cdFxuXHRmdW5jdGlvbiBjb2xUb1ZpZXdDb2wobGluZSxjb2wsdGFic2l6ZSl7XG5cdFx0aWYodGFic2l6ZSA9PT0gdW5kZWZpbmVkKSB0YWJzaXplID0gNDtcblx0XHR2YXIgY2kgPSAwO1xuXHRcdHZhciByY2kgPSAwOyAvLyByZWFsIGNvbHVtblxuXHRcdHZhciBjaGFyJDtcblx0XHRcblx0XHRpZiAoY29sID09IDApIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHR3aGlsZSAoY2hhciQgPSBsaW5lW2NpKytdKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFx0Jykge1xuXHRcdFx0XHR2YXIgcmVzdCA9IHRhYnNpemUgLSByY2kgJSB0YWJzaXplO1xuXHRcdFx0XHRpZiAocmVzdCA+IDMgJiYgY29sIDw9IHJjaSArIDIpIHsgYnJlYWs7IH07XG5cdFx0XHRcdHJjaSArPSByZXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmNpICs9IDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY29sIDw9IHJjaSkgeyBicmVhazsgfTtcblx0XHR9O1xuXHRcdHJldHVybiByY2k7XG5cdH07IGV4cG9ydHMuY29sVG9WaWV3Q29sID0gY29sVG9WaWV3Q29sO1xuXHRcblx0ZnVuY3Rpb24gY29sc0ZvckxpbmUobGluZSx0YWJzaXplKXtcblx0XHRpZih0YWJzaXplID09PSB1bmRlZmluZWQpIHRhYnNpemUgPSA0O1xuXHRcdHZhciBjb2wgPSAwO1xuXHRcdHZhciBpZHggPSAwO1xuXHRcdHZhciBjaGFyJDtcblx0XHR3aGlsZSAoY2hhciQgPSBsaW5lW2lkeCsrXSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcdCcpIHtcblx0XHRcdFx0dmFyIHJlc3QgPSB0YWJzaXplIC0gY29sICUgdGFic2l6ZTtcblx0XHRcdFx0Y29sICs9IHJlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2wgKz0gMTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRyZXR1cm4gY29sO1xuXHR9OyBleHBvcnRzLmNvbHNGb3JMaW5lID0gY29sc0ZvckxpbmU7XG5cdFxuXHRmdW5jdGlvbiByb3djb2woYnVmLGxvYyx0YWJzaXplKXtcblx0XHRpZih0YWJzaXplID09PSB1bmRlZmluZWQpIHRhYnNpemUgPSA0O1xuXHRcdGJ1ZiA9IGJ1Zi50b1N0cmluZygpO1xuXHRcdHZhciBwb3MgPSBsb2M7XG5cdFx0dmFyIGNvbCA9IDA7XG5cdFx0dmFyIGxpbmUgPSAwO1xuXHRcdHZhciBjaGFyJDtcblx0XHRcblx0XHQvLyBnbyBiYWNrIHRvIHN0YXJ0IG9mIGxpbmVcblx0XHR3aGlsZSAoY2hhciQgPSBidWZbcG9zIC0gMV0pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXG4nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fTtcblx0XHRcdHBvcy0tO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZ2V0IGNvbHVtbiBmb3Igc2xpY2Vcblx0XHR3aGlsZSAoKHBvcyA8IGxvYykgJiYgKGNoYXIkID0gYnVmW3Bvc10pKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFx0Jykge1xuXHRcdFx0XHR2YXIgcmVzdCA9IHRhYnNpemUgLSAoY29sICUgdGFic2l6ZSk7XG5cdFx0XHRcdGNvbCArPSByZXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sICs9IDE7XG5cdFx0XHR9O1xuXHRcdFx0cG9zKys7XG5cdFx0fTtcblx0XHRcblx0XHR3aGlsZSAoY2hhciQgPSBidWZbcG9zIC0gMV0pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXG4nKSB7XG5cdFx0XHRcdGxpbmUrKztcblx0XHRcdH07XG5cdFx0XHRwb3MtLTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBbbGluZSxjb2xdO1xuXHR9OyBleHBvcnRzLnJvd2NvbCA9IHJvd2NvbDtcblx0XG5cdGZ1bmN0aW9uIGluY3JlYXNlSW5kZW50KHN0cil7XG5cdFx0dmFyIHJlZyA9IC9eKFxccyooLipcXD1cXHMqKT8oZXhwb3J0IHxnbG9iYWwgfGV4dGVuZCApPyhjbGFzc3xkZWZ8dGFnfHVubGVzc3xpZnxlbHNlfGVsaWZ8c3dpdGNofHRyeXxjYXRjaHxmaW5hbGx5fGZvcnx3aGlsZXx1bnRpbHxkbykpLztcblx0XHR2YXIgb3RoZXIgPSAvXFxiKGRvKVxcYi87XG5cdFx0cmV0dXJuIHJlZy50ZXN0KHN0cikgfHwgb3RoZXIudGVzdChzdHIpO1xuXHR9OyBleHBvcnRzLmluY3JlYXNlSW5kZW50ID0gaW5jcmVhc2VJbmRlbnQ7XG5cdFxuXHRcblx0ZnVuY3Rpb24gcmVwZWF0U3RyaW5nKHN0cixjb3VudCl7XG5cdFx0cmV0dXJuIG5ldyBBcnJheShjb3VudCArIDEpLmpvaW4oc3RyKTtcblx0fTsgZXhwb3J0cy5yZXBlYXRTdHJpbmcgPSByZXBlYXRTdHJpbmc7XG5cdFxuXHRcblx0ZnVuY3Rpb24gcGF0Y2hTdHJpbmcob3JpZyxzdHIsbW9kZSl7XG5cdFx0dmFyIHJlZ2lvbjtcblx0XHR2YXIgdGV4dCA9IG9yaWcudG9TdHJpbmcoKTtcblx0XHRcblx0XHRpZiAobW9kZSA9PSAnYXBwZW5kJykge1xuXHRcdFx0cmV0dXJuIHRleHQgKyBzdHI7XG5cdFx0fSBlbHNlIGlmIChtb2RlID09ICdwcmVwZW5kJykge1xuXHRcdFx0cmV0dXJuIFwiXCIgKyBzdHIgKyB0ZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAocmVnaW9uID0gUmVnaW9uLm5vcm1hbGl6ZShtb2RlKSkge1xuXHRcdFx0XHQvLyBsZXQgcmVnaW9uID0gUmVnaW9uLm5vcm1hbGl6ZSgpXG5cdFx0XHRcdHJldHVybiB0ZXh0LnN1YnN0cigwLHJlZ2lvbi5zdGFydCgpKSArIHN0ciArIHRleHQuc2xpY2UocmVnaW9uLmVuZCgpKTtcblx0XHRcdH07XG5cdFx0fTtcblx0fTsgZXhwb3J0cy5wYXRjaFN0cmluZyA9IHBhdGNoU3RyaW5nOzsgcmV0dXJuIHBhdGNoU3RyaW5nO1xuXHRcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL3V0aWwuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gaGVscGVyIGZvciBzdWJjbGFzc2luZ1xuXHRmdW5jdGlvbiBzdWJjbGFzcyQob2JqLHN1cCkge1xuXHRcdGZvciAodmFyIGsgaW4gc3VwKSB7XG5cdFx0XHRpZiAoc3VwLmhhc093blByb3BlcnR5KGspKSBvYmpba10gPSBzdXBba107XG5cdFx0fTtcblx0XHQvLyBvYmouX19zdXBlcl9fID0gc3VwO1xuXHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEhpc3RvcnlTdGF0ZShkYXRhKXtcblx0XHRpZihkYXRhID09PSB1bmRlZmluZWQpIGRhdGEgPSB7fTtcblx0XHR0aGlzLl90aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuXHRcdHRoaXMuX2RhdGEgPSBkYXRhO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdEhpc3RvcnlTdGF0ZS5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXHRIaXN0b3J5U3RhdGUucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGF0YSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpc3RvcnlTdGF0ZS5wcm90b3R5cGUudGltZXN0YW1wID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90aW1lc3RhbXA7IH1cblx0SGlzdG9yeVN0YXRlLnByb3RvdHlwZS5zZXRUaW1lc3RhbXAgPSBmdW5jdGlvbih2KXsgdGhpcy5fdGltZXN0YW1wID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRIaXN0b3J5U3RhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeVN0YXRlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSl7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdFx0dGhpcy5fdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBGdWxsSGlzdG9yeVN0YXRlKCl7IHJldHVybiBIaXN0b3J5U3RhdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoRnVsbEhpc3RvcnlTdGF0ZSxIaXN0b3J5U3RhdGUpO1xuXHRGdWxsSGlzdG9yeVN0YXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHR2aWV3LmxvYWRTdGF0ZSh0aGlzLl9kYXRhKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGZ1bmN0aW9uIERpZmZIaXN0b3J5U3RhdGUoKXsgcmV0dXJuIEhpc3RvcnlTdGF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChEaWZmSGlzdG9yeVN0YXRlLEhpc3RvcnlTdGF0ZSk7XG5cdFxuXHRcblx0dmFyIHR5cGVzID0ge307XG5cdFxuXHRmdW5jdGlvbiBDb21tYW5kKHBhcmFtcyl7XG5cdFx0dGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wcmV2OyB9XG5cdENvbW1hbmQucHJvdG90eXBlLnNldFByZXYgPSBmdW5jdGlvbih2KXsgdGhpcy5fcHJldiA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX25leHQ7IH1cblx0Q29tbWFuZC5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9uZXh0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUuZnJhbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2ZyYW1lOyB9XG5cdENvbW1hbmQucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24odil7IHRoaXMuX2ZyYW1lID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRDb21tYW5kLnN5bSA9IGZ1bmN0aW9uIChzeW0pe1xuXHRcdHZhciAkMCA9IGFyZ3VtZW50cywgaSA9ICQwLmxlbmd0aDtcblx0XHR2YXIgcGFycyA9IG5ldyBBcnJheShpPjEgPyBpLTEgOiAwKTtcblx0XHR3aGlsZShpPjEpIHBhcnNbLS1pIC0gMV0gPSAkMFtpXTtcblx0XHR0aGlzLnByb3RvdHlwZS5fc3ltYm9sID0gc3ltO1xuXHRcdHRoaXMucHJvdG90eXBlLl9zaWduYXR1cmUgPSBwYXJzO1xuXHRcdHR5cGVzW3N5bV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5sb2FkID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciB0eXAgPSB0eXBlc1tvWzBdXTtcblx0XHR2YXIgZnJhbWUgPSBvWzFdO1xuXHRcdHZhciBjbWQgPSB0eXAuYnVpbGQob1syXSk7XG5cdFx0Y21kLnNldEZyYW1lKGZyYW1lKTtcblx0XHRyZXR1cm4gY21kO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5idWlsZCA9IGZ1bmN0aW9uIChwYXJhbXMpe1xuXHRcdHJldHVybiBuZXcgdGhpcyhwYXJhbXMpO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmFtcztcblx0fTtcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0cmV0dXJuIHRoaXMucHJldigpO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHZfO1xuXHRcdGlmICh0aGlzLnByZXYoKSkgeyAodGhpcy5wcmV2KCkuc2V0TmV4dCh2XyA9IHRoaXMubmV4dCgpKSx2XykgfTtcblx0XHRpZiAodGhpcy5uZXh0KCkpIHsgKHRoaXMubmV4dCgpLnNldFByZXYodl8gPSB0aGlzLnByZXYoKSksdl8pIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX3N5bWJvbCx0aGlzLl9mcmFtZSB8fCAwLHRoaXMucGFyYW1zKCkgfHwgW11dO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gTWFyaygpeyByZXR1cm4gQ29tbWFuZC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChNYXJrLENvbW1hbmQpO1xuXHRNYXJrLnN5bSgnTScsJ3ZhbHVlJyk7XG5cdFxuXHRcblx0ZnVuY3Rpb24gU25hcHNob3QocGFyYW1zKXtcblx0XHR0aGlzLl9jb2RlID0gcGFyYW1zWzBdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFNuYXBzaG90LE1hcmspO1xuXHRTbmFwc2hvdC5zeW0oJ1MnLCdjb2RlJyk7XG5cdFxuXHRTbmFwc2hvdC5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLl9jb2RlXTtcblx0fTtcblx0XG5cdFNuYXBzaG90LnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdGNvbnNvbGUubG9nKCdsb2FkJyx0aGlzLl9jb2RlKTtcblx0XHR2aWV3LmxvYWQodGhpcy5fY29kZSk7XG5cdFx0Ly8gbXVzdCByZXBhaXI/IHdoYXQgYWJvdXQgYW5ub3RhdGlvbnM/XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBTZWxlY3Rpb24ocGFyYW1zKXtcblx0XHR0aGlzLl9vbGQgPSBwYXJhbXNbMF07XG5cdFx0dGhpcy5fbmV3ID0gcGFyYW1zWzFdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFNlbGVjdGlvbixDb21tYW5kKTtcblx0U2VsZWN0aW9uLnN5bSgnfCcsJ29sZCcsJ25ldycpO1xuXHRcblx0U2VsZWN0aW9uLmxvYWQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gbmV3IHRoaXModmFsKTtcblx0fTtcblx0XG5cdFNlbGVjdGlvbi5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLl9vbGQsdGhpcy5fbmV3XTtcblx0fTtcblx0XG5cdFNlbGVjdGlvbi5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHR2aWV3LmNhcmV0KCkuc2V0KEpTT04ucGFyc2UodGhpcy5fbmV3KSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTZWxlY3Rpb24ucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHRoaXMucmVkbyh2aWV3KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFNlbGVjdGlvbi5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHQvLyB3ZSBuZWVkIHRvIGtub3cgYWJvdXQgdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBmb3IgdGhpcz9cblx0XHQvLyBjYW4gZWl0aGVyIHN0b3JlIGJvdGggLSBvciB0cmF2ZXJzZSBiYWNrd2FyZHMgdG8gdGhlIHByZXZpb3VzXG5cdFx0Ly8gY29tbWFuZCBsaWtlIHRoaXNcblx0XHR2YXIgb2xkID0gSlNPTi5wYXJzZSh0aGlzLl9vbGQpO1xuXHRcdGNvbnNvbGUubG9nKCdtb3ZlIHNlbGVjdGlvbiBiYWNrIHRvIG9sZCcsb2xkLHRoaXMuZGF0YSgpKTtcblx0XHR2aWV3LmNhcmV0KCkuc2V0KG9sZCk7XG5cdFx0cmV0dXJuIHRoaXMucHJldigpO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIEluc2VydChwYXJzKXtcblx0XHR0aGlzLl9wb2ludCA9IHBhcnNbMF07XG5cdFx0dGhpcy5fc3RyID0gcGFyc1sxXTtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChJbnNlcnQsQ29tbWFuZCk7XG5cdEluc2VydC5zeW0oJysnLCdwb2ludCcsJ3N0cicpO1xuXHRcblx0SW5zZXJ0LnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX3BvaW50LHRoaXMuX3N0cl07XG5cdH07XG5cdFxuXHRJbnNlcnQucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Y29uc29sZS5sb2coJ3JlZG8gSW5zZXJ0Jyk7XG5cdFx0cmV0dXJuIHZpZXcuaW5zZXJ0KHRoaXMuX3BvaW50LHRoaXMuX3N0cik7XG5cdH07XG5cdFxuXHRJbnNlcnQucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Y29uc29sZS5sb2coJ3VuZG8gSW5zZXJ0Jyk7XG5cdFx0dmlldy5lcmFzZShbdGhpcy5fcG9pbnQsdGhpcy5fcG9pbnQgKyB0aGlzLl9zdHIubGVuZ3RoXSk7XG5cdFx0cmV0dXJuIHRoaXMucHJldigpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gRXJhc2UocGFyYW1zKXtcblx0XHR0aGlzLl9yZWdpb24gPSBwYXJhbXNbMF07XG5cdFx0dGhpcy5fc3RyID0gcGFyYW1zWzFdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKEVyYXNlLENvbW1hbmQpO1xuXHRFcmFzZS5zeW0oJy0nLCdyZWdpb24nLCdzdHInKTtcblx0XG5cdEVyYXNlLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX3JlZ2lvbix0aGlzLl9zdHJdO1xuXHR9O1xuXHRcblx0RXJhc2UucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Y29uc29sZS5sb2coJ3JlZG8gRXJhc2UnKTtcblx0XHRyZXR1cm4gdmlldy5lcmFzZSh0aGlzLl9yZWdpb24pO1xuXHR9O1xuXHRcblx0RXJhc2UucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Ly8gaWYgd2UgZG9udCBrbm93IHRoZSB0ZXh0IHRvIFxuXHRcdGNvbnNvbGUubG9nKCd1bmRvIEVyYXNlJyk7XG5cdFx0dmlldy5pbnNlcnQodGhpcy5fcmVnaW9uLnN0YXJ0KCksdGhpcy5fc3RyKTtcblx0XHRyZXR1cm4gdGhpcy5wcmV2KCk7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gSGlzdG9yeSh2aWV3KXtcblx0XHR0aGlzLl9tb2RlID0gJ25vcm1hbCc7XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0dGhpcy5zZXRDdXJyZW50KHRoaXMuX3NlZWQgPSBuZXcgTWFyaygpKTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5IaXN0b3J5ID0gSGlzdG9yeTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLm1vZGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX21vZGU7IH1cblx0SGlzdG9yeS5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9tb2RlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lbmFibGVkOyB9XG5cdEhpc3RvcnkucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZW5hYmxlZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7IH1cblx0SGlzdG9yeS5wcm90b3R5cGUuc2V0Q3VycmVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jdXJyZW50ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUuc2VlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2VlZDsgfVxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZXRTZWVkID0gZnVuY3Rpb24odil7IHRoaXMuX3NlZWQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS50YWlsID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90YWlsOyB9XG5cdEhpc3RvcnkucHJvdG90eXBlLnNldFRhaWwgPSBmdW5jdGlvbih2KXsgdGhpcy5fdGFpbCA9IHY7IHJldHVybiB0aGlzOyB9OyAvLyBpcyB0aGlzIGJlaGluZCBvciBpbiB0aGUgdmVyeSBmcm9udD9cblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtLG1vdmUsZnJhbWUpe1xuXHRcdGlmKG1vdmUgPT09IHVuZGVmaW5lZCkgbW92ZSA9IHRydWU7XG5cdFx0aWYoZnJhbWUgPT09IHVuZGVmaW5lZCkgZnJhbWUgPSB0aGlzLnZpZXcoKS5mcmFtZXMoKTtcblx0XHRpdGVtLnNldEZyYW1lKGZyYW1lKTtcblx0XHRcblx0XHRpZiAodGhpcy5jdXJyZW50KCkpIHtcblx0XHRcdC8vIGlmIGN1cnJlbnQgaGFzIGEgbmV4dCBldmVudFxuXHRcdFx0Ly8gdGhpcyBzaG91bGQgYmUgZGV0YWNoZWQgaGVyZT9cblx0XHRcdGl0ZW0uc2V0UHJldih0aGlzLmN1cnJlbnQoKSk7XG5cdFx0XHR0aGlzLmN1cnJlbnQoKS5zZXROZXh0KGl0ZW0pO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG1vdmUpIHsgKHRoaXMuc2V0Q3VycmVudChpdGVtKSxpdGVtKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBjdXJyZW50Xztcblx0XHRyZXR1cm4gKGN1cnJlbnRfID0gdGhpcy5jdXJyZW50KCkpICYmIGN1cnJlbnRfLm5leHQgICYmICBjdXJyZW50Xy5uZXh0KCk7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGN1cnJlbnRfO1xuXHRcdHJldHVybiAoY3VycmVudF8gPSB0aGlzLmN1cnJlbnQoKSkgJiYgY3VycmVudF8ucHJldiAgJiYgIGN1cnJlbnRfLnByZXYoKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoZGlyKXtcblx0XHRpZihkaXIgPT09IHVuZGVmaW5lZCkgZGlyID0gMTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5hcHBseShmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSBbXTt3aGlsZSAoc2VsZi5uZXh0KCkpe1xuXHRcdFx0XHRzZWxmLm5leHQoKS5yZWRvKHNlbGYudmlldygpLHNlbGYpO1xuXHRcdFx0XHRzZWxmLnNldEN1cnJlbnQoc2VsZi5uZXh0KCkpO1xuXHRcdFx0XHRpZiAoc2VsZi5jdXJyZW50KCkgaW5zdGFuY2VvZiBNYXJrKSB7IGJyZWFrOyB9O1xuXHRcdFx0fTtyZXR1cm4gcmVzO1xuXHRcdH0pO1xuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLmFwcGx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVuZG8gXG5cdFx0XHR2YXIgcmVzID0gW10sIHZfLCBjdXJyZW50Xzt3aGlsZSAoc2VsZi5jdXJyZW50KCkpe1xuXHRcdFx0XHRpZiAoc2VsZi5wcmV2KCkpIHsgKHNlbGYuc2V0Q3VycmVudCh2XyA9IHNlbGYuY3VycmVudCgpLnVuZG8oc2VsZi52aWV3KCksc2VsZikpLHZfKSB9O1xuXHRcdFx0XHQoY3VycmVudF8gPSBzZWxmLmN1cnJlbnQoKSkgJiYgY3VycmVudF8uZW50ZXIgICYmICBjdXJyZW50Xy5lbnRlcihzZWxmLnZpZXcoKSxzZWxmKTtcblx0XHRcdFx0aWYgKHNlbGYuY3VycmVudCgpIGluc3RhbmNlb2YgTWFyaykgeyBicmVhazsgfTtcblx0XHRcdH07cmV0dXJuIHJlcztcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGNiKXtcblx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXHRcdGNiICYmIGNiKCk7XG5cdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChjYil7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChzdGF0ZSl7XG5cdFx0c3RhdGUuYXBwbHkodGhpcy52aWV3KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUub25lcmFzZSA9IGZ1bmN0aW9uIChyZWcsc3RyLGVkaXQpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRyZXR1cm4gdGhpcy5hZGQobmV3IEVyYXNlKFtyZWcsc3RyXSkpO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUub25pbnNlcnQgPSBmdW5jdGlvbiAobG9jLHN0cixlZGl0KXtcblx0XHRpZiAodGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0cmV0dXJuIHRoaXMuYWRkKG5ldyBJbnNlcnQoW2xvYyxzdHJdKSk7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5vbmNhcmV0ID0gZnVuY3Rpb24gKG9sZCxuZXckKXtcblx0XHRpZiAodGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0cmV0dXJuIHRoaXMuYWRkKG5ldyBTZWxlY3Rpb24oW29sZCxuZXckXSkpO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUub25sb2FkID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHR2YXIgbWFyayA9IG5ldyBTbmFwc2hvdChbY29kZV0pO1xuXHRcdHJldHVybiB0aGlzLmFkZChtYXJrKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHR2YXIgbWFyayA9IG5ldyBNYXJrKFt2YWx1ZV0pO1xuXHRcdHJldHVybiB0aGlzLmFkZChtYXJrKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYgKHNlbGYuX21vZGUgPT0gJ3BsYXknKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncGx5YWluZydcblx0XHRcdHZhciBmcmFtZSA9IHNlbGYudmlldygpLmZyYW1lcygpIC0gc2VsZi5fb2Zmc2V0O1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2hpc3RvcnkudGljayB3aWxsIHBsYXknLGZyYW1lLG5leHQsY3VycmVudFxuXHRcdFx0c2VsZi5hcHBseShmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJlcyA9IFtdLCB2Xzt3aGlsZSAoc2VsZi5uZXh0KCkgJiYgc2VsZi5uZXh0KCkuZnJhbWUoKSA8PSBmcmFtZSl7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2hpc3RvcnkudGljayBwbGF5JyxmcmFtZSxuZXh0LGN1cnJlbnRcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncmVwbGF5IGZyYW1lISdcblx0XHRcdFx0XHRzZWxmLm5leHQoKS5yZWRvKHNlbGYudmlldygpLHNlbGYpO1xuXHRcdFx0XHRcdHJlcy5wdXNoKCgoc2VsZi5zZXRDdXJyZW50KHZfID0gc2VsZi5uZXh0KCkpLHZfKSkpO1xuXHRcdFx0XHR9O3JldHVybiByZXM7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoc2VsZi5uZXh0KCkpKSB7XG5cdFx0XHRcdHNlbGYuc2V0TW9kZSgnbGl2ZScpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHNob3VsZCBwcm9iYWJseSBoYXBwZW4gaW4gYSBkaWZmZXJlbnQgbWFuYWdlclxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgc25hcCA9IHNlbGYuc2VlZCgpO1xuXHRcdHdoaWxlICghKCFzbmFwIHx8IChzbmFwIGluc3RhbmNlb2YgU25hcHNob3QpKSl7XG5cdFx0XHRzbmFwID0gc25hcC5uZXh0KCk7XG5cdFx0fTtcblx0XHRcblx0XHRzZWxmLl9vZmZzZXQgPSBzZWxmLnZpZXcoKS5mcmFtZXMoKSAtIHNuYXAuZnJhbWUoKTtcblx0XHRjb25zb2xlLmxvZyhcInBsYXlpbmcgZnJvbSBzZWVkXCIsc25hcCxzZWxmLl9vZmZzZXQpO1xuXHRcdC8vIGNvbnNvbGUubG9nICdmb3VuZCBzbmFwc2hvdD8hPyAtLSBvZmZzZXQgZnJhbWUnLEBvZmZzZXRcblx0XHRzZWxmLmFwcGx5KGZ1bmN0aW9uKCkgeyB2YXIgdl87XG5cdFx0cmV0dXJuIChzZWxmLnNldEN1cnJlbnQodl8gPSBzbmFwLnJlZG8oc2VsZi52aWV3KCksc2VsZikpLHZfKTsgfSk7XG5cdFx0c2VsZi5zZXRNb2RlKCdwbGF5Jyk7XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgZGF0YSA9IFtdO1xuXHRcdHZhciBzdGVwID0gdGhpcy5fc2VlZDtcblx0XHRcblx0XHR3aGlsZSAoc3RlcCl7XG5cdFx0XHRkYXRhLnB1c2goc3RlcC50b0pTT04oKSk7XG5cdFx0XHRzdGVwID0gc3RlcC5uZXh0KCk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4ge2NvbW1hbmRzOiBkYXRhfTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoZGF0YSl7XG5cdFx0dmFyIHN0ZXAgPSB0aGlzLnNlZWQoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZGF0YS5jb21tYW5kcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBDb21tYW5kLmxvYWQoYXJ5W2ldKTtcblx0XHRcdGl0ZW0uc2V0UHJldihzdGVwKTtcblx0XHRcdHN0ZXAuc2V0TmV4dChpdGVtKTtcblx0XHRcdHN0ZXAgPSBpdGVtO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2xvYWQgaXRlbScsaXRlbVxuXHRcdH07XG5cdFx0Ly8gY29uc29sZS5sb2cgJ2xvYWRlZCdcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cmV0dXJuIEhpc3Rvcnk7XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlzdG9yeS5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0ZnVuY3Rpb24gTG9nZ2VyKHZpZXcpe1xuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkxvZ2dlciA9IExvZ2dlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdExvZ2dlci5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZW5hYmxlZDsgfVxuXHRMb2dnZXIucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZW5hYmxlZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdExvZ2dlci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRMb2dnZXIucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCBERUJVRykgeyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLGFyZ3VtZW50cykgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9lbmFibGVkIHx8IERFQlVHKSB7IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCBERUJVRykgeyBjb25zb2xlLmdyb3VwLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS5ncm91cENvbGxhcHNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9lbmFibGVkIHx8IERFQlVHKSB7IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMb2dnZXIucHJvdG90eXBlLmdyb3VwRW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgREVCVUcpIHsgY29uc29sZS5ncm91cEVuZCgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBMb2dnZXI7XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvbG9nZ2VyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXHRcblx0dmFyIHNwZWNpYWxLZXlzID0ge1xuXHRcdDg6IFwiYmFja3NwYWNlXCIsXG5cdFx0OTogXCJ0YWJcIixcblx0XHQxMDogXCJyZXR1cm5cIixcblx0XHQxMzogXCJyZXR1cm5cIixcblx0XHQxNjogXCJzaGlmdFwiLFxuXHRcdDE3OiBcImN0cmxcIixcblx0XHQxODogXCJhbHRcIixcblx0XHQxOTogXCJwYXVzZVwiLFxuXHRcdDIwOiBcImNhcHNsb2NrXCIsXG5cdFx0Mjc6IFwiZXNjXCIsXG5cdFx0MzI6IFwic3BhY2VcIixcblx0XHQzMzogXCJwYWdldXBcIixcblx0XHQzNDogXCJwYWdlZG93blwiLFxuXHRcdDM1OiBcImVuZFwiLFxuXHRcdDM2OiBcImhvbWVcIixcblx0XHQzNzogXCJsZWZ0XCIsXG5cdFx0Mzg6IFwidXBcIixcblx0XHQzOTogXCJyaWdodFwiLFxuXHRcdDQwOiBcImRvd25cIixcblx0XHQ0NTogXCJpbnNlcnRcIixcblx0XHQ0NjogXCJkZWxcIixcblx0XHQ1OTogXCI7XCIsXG5cdFx0NjE6IFwiPVwiLFxuXHRcdDk2OiBcIjBcIixcblx0XHQ5NzogXCIxXCIsXG5cdFx0OTg6IFwiMlwiLFxuXHRcdDk5OiBcIjNcIixcblx0XHQxMDA6IFwiNFwiLFxuXHRcdDEwMTogXCI1XCIsXG5cdFx0MTAyOiBcIjZcIixcblx0XHQxMDM6IFwiN1wiLFxuXHRcdDEwNDogXCI4XCIsXG5cdFx0MTA1OiBcIjlcIixcblx0XHQxMDY6IFwiKlwiLFxuXHRcdDEwNzogXCIrXCIsXG5cdFx0MTA5OiBcIi1cIixcblx0XHQxMTA6IFwiLlwiLFxuXHRcdDExMTogXCIvXCIsXG5cdFx0MTEyOiBcImYxXCIsXG5cdFx0MTEzOiBcImYyXCIsXG5cdFx0MTE0OiBcImYzXCIsXG5cdFx0MTE1OiBcImY0XCIsXG5cdFx0MTE2OiBcImY1XCIsXG5cdFx0MTE3OiBcImY2XCIsXG5cdFx0MTE4OiBcImY3XCIsXG5cdFx0MTE5OiBcImY4XCIsXG5cdFx0MTIwOiBcImY5XCIsXG5cdFx0MTIxOiBcImYxMFwiLFxuXHRcdDEyMjogXCJmMTFcIixcblx0XHQxMjM6IFwiZjEyXCIsXG5cdFx0MTQ0OiBcIm51bWxvY2tcIixcblx0XHQxNDU6IFwic2Nyb2xsXCIsXG5cdFx0MTczOiBcIi1cIixcblx0XHQxODY6IFwiO1wiLFxuXHRcdDE4NzogXCI9XCIsXG5cdFx0MTg4OiBcIixcIixcblx0XHQxODk6IFwiLVwiLFxuXHRcdDE5MDogXCIuXCIsXG5cdFx0MTkxOiBcIi9cIixcblx0XHQxOTI6IFwiYFwiLFxuXHRcdDIxOTogXCJbXCIsXG5cdFx0MjIwOiBcIlxcXFxcIixcblx0XHQyMjE6IFwiXVwiLFxuXHRcdDIyMjogXCInXCJcblx0fTtcblx0XG5cdHZhciBzaGlmdE51bXMgPSB7XG5cdFx0XCJgXCI6IFwiflwiLFxuXHRcdFwiMVwiOiBcIiFcIixcblx0XHRcIjJcIjogXCJAXCIsXG5cdFx0XCIzXCI6IFwiI1wiLFxuXHRcdFwiNFwiOiBcIiRcIixcblx0XHRcIjVcIjogXCIlXCIsXG5cdFx0XCI2XCI6IFwiXlwiLFxuXHRcdFwiN1wiOiBcIiZcIixcblx0XHRcIjhcIjogXCIqXCIsXG5cdFx0XCI5XCI6IFwiKFwiLFxuXHRcdFwiMFwiOiBcIilcIixcblx0XHRcIi1cIjogXCJfXCIsXG5cdFx0XCI9XCI6IFwiK1wiLFxuXHRcdFwiO1wiOiBcIjogXCIsXG5cdFx0XCInXCI6ICdcIicsXG5cdFx0XCIsXCI6IFwiPFwiLFxuXHRcdFwiLlwiOiBcIj5cIixcblx0XHRcIi9cIjogXCI/XCIsXG5cdFx0XCJcXFxcXCI6IFwifFwiXG5cdH07XG5cdFxuXHRmdW5jdGlvbiB0cmlnZ2VyKGtleSxvKXtcblx0XHRpZiAobyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRvID0ge2NvbW1hbmQ6IG99O1xuXHRcdH07XG5cdFx0by50cmlnZ2VyID0ga2V5O1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gY29tYm8oa2V5cyxvKXtcblx0XHRpZiAobyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7IG8gPSB7Y29tbWFuZDogb30gfTtcblx0XHRvLmtleXMgPSBrZXlzO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0SU0uS2V5QmluZGluZ3MgPSBbXG5cdFx0XG5cdFx0Y29tYm8oWydzdXBlcit6J10sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudmlldygpLmhpc3RvcnkoKS51bmRvKCk7IH0pLFxuXHRcdGNvbWJvKFtcInN1cGVyK3NoaWZ0K3pcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudmlldygpLmhpc3RvcnkoKS5yZWRvKCk7IH0pLFxuXHRcdGNvbWJvKFtcImFsdCtzdXBlcitwXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnZpZXcoKS5oaXN0b3J5KCkucGxheSgpOyB9KSxcblx0XHQvLyBjb21ibyBbXCJhbHQrc2hpZnQrclwiXSBkbyB8c2VsfCBzZWwudmlldy5oaXN0b3J5LnBsYXlcblx0XHRcblx0XHRjb21ibyhbXCJzdXBlcitzXCJdLHtjb21tYW5kOiBcInNhdmVcIn0pLFxuXHRcdGNvbWJvKFtcInN1cGVyK2JcIl0se2NvbW1hbmQ6IFwicnVuXCJ9KSxcblx0XHRjb21ibyhbXCJhbHQrc3VwZXIrc1wiXSx7Y29tbWFuZDogXCJzYXZlU2Vzc2lvblwifSksXG5cdFx0Y29tYm8oW1wiYWx0K3NoaWZ0K2xcIl0se2NvbW1hbmQ6IFwicmVwYXJzZVwifSksXG5cdFx0Y29tYm8oW1wiYWx0K3NoaWZ0K2tcIl0se2NvbW1hbmQ6IFwicmVwYXJzZUV4dGVudFwifSksXG5cdFx0XG5cdFx0Y29tYm8oW1wic3VwZXIrYVwiXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5zZWxlY3RBbGwoKTsgfSksXG5cdFx0XG5cdFx0XG5cdFx0Y29tYm8oWyd0YWInXSx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudGV4dCgpLmluZGV4T2YoJ1xcbicpID49IDA7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRzZWwuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0dmFyIHJlZ2lvbiA9IHNlbC5yZWdpb24oKTtcblx0XHRcdHZhciBub2RlcyA9IHNlbC52aWV3KCkubm9kZXNJblJlZ2lvbihyZWdpb24pO1xuXHRcdFx0XG5cdFx0XHRub2Rlcy5tYXAoZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0aWYgKG1hdGNoLm5vZGUubWF0Y2hlcygnLl9pbW5ld2xpbmUnKSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdmb3VuZCB0YWIgaW4gc2VsZWN0aW9uJyxtYXRjaCk7XG5cdFx0XHRcdFx0aWYgKG1hdGNoLm1vZGUgIT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoLm5vZGUuaW5kZW50KCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNlbC5kaXJ0eSgpO1xuXHRcdH19KSxcblx0XHRcblx0XHRcblx0XHRcblx0XHRjb21ibyhbXCJzaGlmdCt0YWJcIl0se2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnRleHQoKS5pbmRleE9mKCdcXG4nKSA+PSAwOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0c2VsLmV4cGFuZFRvTGluZXMoKTtcblx0XHRcdHZhciByZWdpb24gPSBzZWwucmVnaW9uKCk7XG5cdFx0XHR2YXIgbm9kZXMgPSBzZWwudmlldygpLm5vZGVzSW5SZWdpb24ocmVnaW9uKTtcblx0XHRcdFxuXHRcdFx0bm9kZXMubWFwKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdGlmIChtYXRjaC5ub2RlLm1hdGNoZXMoJy5faW1uZXdsaW5lJykgJiYgbWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoLm5vZGUudW5kZW50KCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzZWwuZGlydHkoKTtcblx0XHR9fSksXG5cdFx0XG5cdFx0Y29tYm8oW1wic2hpZnQrdGFiXCJdLHtjb250ZXh0OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gU3RyaW5nKGUudmlldy5zZWxlY3Rpb24pLmluZGV4T2YoJ1xcbicpID49IDBcblx0XHR9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ3RyeSB1bmRlbnQnKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJhbHQrc2hpZnQrcmV0dXJuXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gY29uc29sZS5sb2coJ3ByZXR0aWZ5Jyk7IH0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcImJhY2tzcGFjZVwiXSx7Y29udGV4dDogZnVuY3Rpb24oZSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ2RlbGV0ZUxlZnRSaWdodCBiYWNrc3BhY2U/IT8nLGUucmVnaW9uKCksZS5yZWdpb24oKS5wZWVrKC0xLDEpKTtcblx0XHRcdHJldHVybiBpZHgkKGUucmVnaW9uKCkucGVlaygtMSwxKSxbJ1tdJywne30nLCc8PicsJygpJywnXCJcIicsXCInJ1wiXSkgPj0gMDtcblx0XHR9LFxuXHRcdFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ21vdmluZyEhJyk7XG5cdFx0XHRzZWwuZXhwYW5kKC0xLDEpO1xuXHRcdFx0cmV0dXJuIHNlbC5lcmFzZSgpO1xuXHRcdH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJiYWNrc3BhY2VcIl0se2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCxvKSB7XG5cdFx0XHR2YXIgcmVnID0gc2VsLnJlZ2lvbigpO1xuXHRcdFx0aWYgKHJlZy5zaXplKCkgPT0gMCkge1xuXHRcdFx0XHRpZiAoby5ub2RlID0gcmVnLnByZXZOb2RlKCcuX2ltcGFpciwuX2ltc3RyJykpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwsbykgeyB2YXIgdl87XG5cdFx0cmV0dXJuIChzZWwuc2V0UmVnaW9uKHZfID0gby5ub2RlLnJlZ2lvbigpLmNsb25lKCkucmV2ZXJzZSgpKSx2Xyk7IH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJiYWNrc3BhY2VcIl0se2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCxvKSB7XG5cdFx0XHRpZiAoc2VsLnRleHQoKSAmJiAhdXRpbC5zdHJpbmdJc0JhbGFuY2VkKHNlbC50ZXh0KCkpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCxvKSB7IHJldHVybiB0cnVlOyB9fSksXG5cdFx0XG5cdFx0Y29tYm8oW1wiYmFja3NwYWNlXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmVyYXNlKCk7IH0pLFxuXHRcdGNvbWJvKFtcInNoaWZ0K2JhY2tzcGFjZVwiXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5lcmFzZSgpOyB9KSxcblx0XHRjb21ibyhbXCJhbHQrYmFja3NwYWNlXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmVyYXNlKElNLldPUkRfU1RBUlQpOyB9KSxcblx0XHRjb21ibyhbXCJzdXBlcitiYWNrc3BhY2VcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuZXJhc2UoSU0uTElORV9TVEFSVCk7IH0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcInJldHVyblwiLCdzaGlmdCtyZXR1cm4nLCdzdXBlcityZXR1cm4nXSxmdW5jdGlvbihzZWwpIHtcblx0XHRcdHZhciBpbmQgPSBzZWwuaW5kZW50KCk7XG5cdFx0XHRpZiAodXRpbC5pbmNyZWFzZUluZGVudChzZWwuaGVhZCgpLnBlZWtiZWhpbmQoKSkpIHsgaW5kICs9ICdcXHQnIH07XG5cdFx0XHRcblx0XHRcdC8vIHNob3VsZCBub3QgaGFwcGVuIGluIHN0cmluZ1xuXHRcdFx0aWYgKGlkeCQoc2VsLnJlZ2lvbigpLnBlZWsoLTEsMSksWydbXScsJ3t9JywnKCknXSkgPj0gMCkge1xuXHRcdFx0XHRzZWwuaW5zZXJ0KCdcXG5cXHQnICsgaW5kKTtcblx0XHRcdFx0c2VsLnZpZXcoKS5pbnNlcnQoc2VsLmhlYWQoKS5sb2MoKSwnXFxuJyArIGluZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWwuaW5zZXJ0KCdcXG4nICsgaW5kKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pLFxuXHRcdFxuXHRcdFxuXHRcdGNvbWJvKFsnc3BhY2UnLCdzaGlmdCtzcGFjZSddLGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0aWYgKHNlbC5yZWdpb24oKS5wZWVrKC0xLDEpID09ICc8PicpIHtcblx0XHRcdFx0c2VsLm1vdmUoMSkuZXJhc2UoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWwuaW5zZXJ0KCcgJyk7XG5cdFx0fSksXG5cdFx0XG5cdFx0Y29tYm8oWyd0YWInXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJ1xcdCcpOyB9KSxcblx0XHRcblx0XHRcblx0XHRjb21ibyhbJ3N1cGVyK3VwJ10sZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRzZWwuY29sbGFwc2UoKS5oZWFkKCkuc2V0KDAsMCkubm9ybWFsaXplKCk7XG5cdFx0XHRyZXR1cm4gc2VsLmRpcnR5KCk7XG5cdFx0fSksXG5cdFx0XG5cdFx0Y29tYm8oWydzdXBlcitkb3duJ10sZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRzZWwuY29sbGFwc2UoKS5oZWFkKCkuc2V0KDEwMDAwMCwwKS5ub3JtYWxpemUoKTtcblx0XHRcdHJldHVybiBzZWwuZGlydHkoKTtcblx0XHR9KSxcblx0XHRcblx0XHRjb21ibyhbJ3N1cGVyK3UnXSxmdW5jdGlvbihzZWwsbykge1xuXHRcdFx0Y29uc29sZS5sb2coc2VsLnRhcmdldCgpLFwiZm91bmQgdXQhISFcIik7XG5cdFx0XHRyZXR1cm4gY29uc29sZS5sb2coc2VsLnRhcmdldCgpLmJ1YmJsZSgndW53cmFwJyx7fSkpO1xuXHRcdH0pLFxuXHRcdFxuXHRcdGNvbWJvKFsnYWx0K3N1cGVyK3InXSxmdW5jdGlvbigpIHsgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTsgfSlcblx0XTtcblx0XG5cdElNLlRyaWdnZXJzID0gW1xuXHRcdFxuXHRcdHRyaWdnZXIoJ3wnLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5yZWdpb24oKS5wZWVrKC0xLDEpID09ICd8fCc7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwubW92ZSgxKTsgfX0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJ1snLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgnWyQwXScpOyB9KSxcblx0XHR0cmlnZ2VyKCd8JyxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJ3wkMHwnKTsgfSksXG5cdFx0dHJpZ2dlcignKCcsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCcoJDApJyk7IH0pLFxuXHRcdHRyaWdnZXIoJ3snLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgneyQwfScpOyB9KSxcblx0XHRcblx0XHR0cmlnZ2VyKCc8Jyx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiAhc2VsLnBlZWtiZWhpbmQoLyhcXGIodGFnfGlmfGNsYXNzKSB8XFxkXFxzKiQpLyk7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCc8JDA+Jyk7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKCdcIicse2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCxvKSB7XG5cdFx0XHRpZiAoc2VsLnJlZ2lvbigpLnBlZWsoLTEsMCkgPT0gJ1xcXFwnICYmIChvLm5vZGUgPSBzZWwucmVnaW9uKCkuc2NvcGUocSQoJy5faW1zdHInLHNlbGYpKSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCdcIicpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcihcIidcIix7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHsgcmV0dXJuIHNlbC5yZWdpb24oKS5wZWVrKC0xLDEpID09IFwiJydcIjsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5tb3ZlKDEpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcihcIidcIix7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHsgcmV0dXJuIG8ubm9kZSA9IHNlbC5yZWdpb24oKS5zY29wZShxJCgnLl9pbXN0cicsc2VsZikpOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydChcIlxcXFwnXCIpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcignXCInLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgnXCIkMFwiJyk7IH0pLFxuXHRcdHRyaWdnZXIoXCInXCIsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KFwiJyQwJ1wiKTsgfSksXG5cdFx0XG5cdFx0dHJpZ2dlcignXScse2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnJlZ2lvbigpLnBlZWsoMCwxKSA9PSAnXSc7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwubW92ZSgxKTsgfX0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJ30nLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5yZWdpb24oKS5wZWVrKDAsMSkgPT0gJ30nOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLm1vdmUoMSk7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKCcpJyx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwucmVnaW9uKCkucGVlaygwLDEpID09ICcpJzsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5tb3ZlKDEpOyB9fSlcblx0XTtcblx0XG5cdGZ1bmN0aW9uIFNob3J0Y3V0TWFuYWdlcih2aWV3LGJpbmRpbmdzKXtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHR0aGlzLl9iaW5kaW5ncyA9IGJpbmRpbmdzIHx8IElNLktleUJpbmRpbmdzO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRnbG9iYWwuU2hvcnRjdXRNYW5hZ2VyID0gU2hvcnRjdXRNYW5hZ2VyOyAvLyBnbG9iYWwgY2xhc3MgXG5cdFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHR9O1xuXHRcblx0U2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5rZXlzRm9yRXZlbnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIGNvbWJvID0gW107XG5cdFx0dmFyIHNwZWNpYWwgPSBzcGVjaWFsS2V5c1tlLndoaWNoXTtcblx0XHR2YXIgY2hyID0gc3BlY2lhbCB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpO1xuXHRcdFxuXHRcdGNociA9IGNoci50b0xvd2VyQ2FzZSgpOyAvLyB1bmxlc3MgZTpzaGlmdEtleVxuXHRcdFxuXHRcdGlmIChlLmN0cmxLZXkgJiYgc3BlY2lhbCAhPSAnY3RybCcpIHsgY29tYm8ucHVzaCgnY3RybCcpIH07XG5cdFx0aWYgKGUuYWx0S2V5ICYmIHNwZWNpYWwgIT0gJ2FsdCcpIHsgY29tYm8ucHVzaCgnYWx0JykgfTtcblx0XHRpZiAoZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkgJiYgc3BlY2lhbCAhPT0gJ21ldGEnKSB7IGNvbWJvLnB1c2goJ3N1cGVyJykgfTtcblx0XHRpZiAoZS5zaGlmdEtleSAmJiBzcGVjaWFsICE9ICdzaGlmdCcpIHsgY29tYm8ucHVzaCgnc2hpZnQnKSB9O1xuXHRcdGlmIChjb21iby5pbmRleE9mKGNocikgPCAwKSB7IGNvbWJvLnB1c2goY2hyKSB9O1xuXHRcdFxuXHRcdHJldHVybiBjb21iby5qb2luKCcrJyk7XG5cdH07XG5cdFxuXHRTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmNvbW1hbmRzRm9yS2V5cyA9IGZ1bmN0aW9uIChjb21ibyl7XG5cdFx0cmV0dXJuIHRoaXMuX2JpbmRpbmdzLmZpbHRlcihmdW5jdGlvbihiaW5kaW5nKSB7IHJldHVybiBiaW5kaW5nLmtleXMgPT0gY29tYm87IH0pO1xuXHR9O1xuXHRcblx0U2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRTaG9ydGN1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgY29tYm8gPSB0aGlzLmtleXNGb3JFdmVudChlLmV2ZW50KCkpO1xuXHRcdGNvbnNvbGUubG9nKGNvbWJvKTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fYmluZGluZ3MpLCBsZW4gPSBhcnkubGVuZ3RoLCBjbWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y21kID0gYXJ5W2ldO1xuXHRcdFx0aWYgKGNtZC5rZXlzLmluZGV4T2YoY29tYm8pID49IDApIHtcblx0XHRcdFx0dmFyIG8gPSB7fTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZvdW5kIHNob3J0Y3V0Jyxjb21ibyxjbWQ6a2V5c1xuXHRcdFx0XHRpZiAoIWNtZC5jb250ZXh0IHx8IGNtZC5jb250ZXh0LmNhbGwodGhpcy52aWV3KCksdGhpcy52aWV3KCkuY2FyZXQoKSxvLGUsdGhpcy52aWV3KCkpKSB7XG5cdFx0XHRcdFx0Y21kLmRhdGEgPSBvO1xuXHRcdFx0XHRcdHJldHVybiBjbWQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHRTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmdldFRyaWdnZXIgPSBmdW5jdGlvbiAodmlldyx0ZXh0KXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoSU0uVHJpZ2dlcnMpLCBsZW4gPSBhcnkubGVuZ3RoLCBjbWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y21kID0gYXJ5W2ldO1xuXHRcdFx0aWYgKGNtZC50cmlnZ2VyID09IHRleHQpIHtcblx0XHRcdFx0dmFyIHJlcyA9IGNtZC5jb250ZXh0ID8gKGNtZC5jb250ZXh0LmNhbGwodmlldyx2aWV3LmNhcmV0KCksdmlldyx0ZXh0KSkgOiAodHJ1ZSk7XG5cdFx0XHRcdGlmIChyZXMpIHsgcmV0dXJuIGNtZCB9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRyZXR1cm4gU2hvcnRjdXRNYW5hZ2VyO1xuXHRcblx0XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvc2hvcnRjdXRzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW1jYXB0b3InLCAnaW5wdXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAoIXRoaXMuZG9tKCkudmFsdWUpIHtcblx0XHRcdFx0dGhpcy5kb20oKS52YWx1ZSA9ICd4Jztcblx0XHRcdH07XG5cdFx0XHR0aGlzLmRvbSgpLnNlbGVjdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHNlbGYsYXJndW1lbnRzKTtcblx0XHRcdHNlbGYuZG9tKCkub25mb2N1cyA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ2RvbSBvbmZvY3VzISEhIScpO1xuXHRcdFx0XHR2YXIgZXZlbnQgPSBJbWJhLkV2ZW50LndyYXAoe3R5cGU6ICdpbnB1dGZvY3VzJyx0YXJnZXQ6IHNlbGYuZG9tKCl9KTtcblx0XHRcdFx0cmV0dXJuIGV2ZW50LnByb2Nlc3MoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHNlbGYuZG9tKCkub25ibHVyID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnZG9tIG9uYmx1ciEhISEnLGUpO1xuXHRcdFx0XHR2YXIgZXZlbnQgPSBJbWJhLkV2ZW50LndyYXAoe3R5cGU6ICdpbnB1dGJsdXInLHRhcmdldDogc2VsZi5kb20oKSxyZWxhdGVkVGFyZ2V0OiBlLnJlbGF0ZWRUYXJnZXR9KTtcblx0XHRcdFx0cmV0dXJuIGV2ZW50LnByb2Nlc3MoKTtcblx0XHRcdFx0Ly8gSW1iYS5FdmVudHMudHJpZ2dlcignaW5wdXRibHVyJyxkb20pXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL3ZpZXdzL2NhcHRvci5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBkaXNhYmxpbmcgbG9ncyBmb3Igbm93XG5cdC8vIGNvbnNvbGU6bG9nID0gZG8gdHJ1ZVxuXHQvLyBleHRlcm5zO1xuXHRcblx0dmFyIE9QRU4gPSBbJ1wiJyxcIidcIiwnKCcsJ1snLCd7JywnPCddO1xuXHR2YXIgQ0xPU0UgPSBbJ1wiJyxcIidcIiwnKScsJ10nLCd9JywnPiddO1xuXHRcblx0aWYgKEltYmEuRXZlbnRzKSB7XG5cdFx0SW1iYS5FdmVudHMucmVnaXN0ZXIoWydjb3B5JywncGFzdGUnLCdjdXQnLCdiZWZvcmVjdXQnLCdiZWZvcmVwYXN0ZScsJ2JlZm9yZWNvcHknLCdrZXlwcmVzcyddKTtcblx0fTtcblx0XG5cdHZhciBMb2dnZXIgPSByZXF1aXJlKCcuL2NvcmUvbG9nZ2VyJykuTG9nZ2VyO1xuXHR2YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vY29yZS9oaXN0b3J5JykuSGlzdG9yeTtcblx0dmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vY29yZS9idWZmZXInKS5CdWZmZXI7XG5cdHZhciBPYnNlcnZlciA9IHJlcXVpcmUoJy4vY29yZS9vYnNlcnZlcicpLk9ic2VydmVyO1xuXHRcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4vcmVnaW9uJykuUmVnaW9uO1xuXHR2YXIgaGludHMkID0gcmVxdWlyZSgnLi9jb3JlL2hpbnRzJyksIEhpbnRzID0gaGludHMkLkhpbnRzLCBIaW50ID0gaGludHMkLkhpbnQ7XG5cdHZhciBIaWdobGlnaHRlciA9IHJlcXVpcmUoJy4vY29yZS9oaWdobGlnaHRlcicpLkhpZ2hsaWdodGVyO1xuXHRcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXHRcblx0cmVxdWlyZSgnLi9jb3JlL2NhcmV0Jyk7XG5cdFxuXHRyZXF1aXJlKCcuL3ZpZXdzL292ZXJsYXlzJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1kaW1zJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyB1bmNhY2hlXG5cdFx0XHRpZiAodGhpcy5fb3cgIT0gdGhpcy5kb20oKS5vZmZzZXRXaWR0aCkge1xuXHRcdFx0XHR0aGlzLl9vdyA9IHRoaXMuZG9tKCkub2Zmc2V0V2lkdGg7XG5cdFx0XHRcdHRoaXMuX2NoID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9jaCB8fCAodGhpcy5fY2ggPSB0aGlzLmRvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXZpZXdib2R5Jyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW12aWV3JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZpbGVuYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9maWxlbmFtZTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RmlsZW5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5fZmlsZW5hbWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ic2VydmVyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9vYnNlcnZlcjsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0T2JzZXJ2ZXIgPSBmdW5jdGlvbih2KXsgdGhpcy5fb2JzZXJ2ZXIgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2hpc3Rvcnk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhpc3RvcnkgPSBmdW5jdGlvbih2KXsgdGhpcy5faGlzdG9yeSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGludHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2hpbnRzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIaW50cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oaW50cyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9nZ2VyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9sb2dnZXI7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldExvZ2dlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9sb2dnZXIgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNob3J0Y3V0cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2hvcnRjdXRzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTaG9ydGN1dHMgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2hvcnRjdXRzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2ZvY3VzTm9kZSA9IHt3YXRjaDogJ2ZvY3VzTm9kZURpZFNldCcsbmFtZTogJ2ZvY3VzTm9kZSd9O1xuXHRcdHRhZy5wcm90b3R5cGUuZm9jdXNOb2RlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9mb2N1c05vZGU7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEZvY3VzTm9kZSA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmZvY3VzTm9kZSgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2ZvY3VzTm9kZSA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmZvY3VzTm9kZURpZFNldCAmJiB0aGlzLmZvY3VzTm9kZURpZFNldCh2LGEsdGhpcy5fX2ZvY3VzTm9kZSkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhcmV0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jYXJldDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2FyZXQgPSBmdW5jdGlvbih2KXsgdGhpcy5fY2FyZXQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZyYW1lcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZnJhbWVzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRGcmFtZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fZnJhbWVzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWFkb25seSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVhZG9ubHk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlYWRvbmx5ID0gZnVuY3Rpb24odil7IHRoaXMuX3JlYWRvbmx5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oaWdobGlnaHRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEhpZ2hsaWdodGVyO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5saW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGltcy5kb20oKS5vZmZzZXRIZWlnaHQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoYXJXaWR0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RpbXMuY2goKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNSZWFkT25seSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuaGlzdG9yeSgpLm1vZGUoKSA9PSAncGxheSc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRhYlNpemUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiA0O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2J1aWxkIGltdmlldydcblx0XHRcdFZJRVcgPSB0aGlzO1xuXHRcdFx0dGhpcy5zZXRUYWJpbmRleCgwKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5fcmVhZG9ubHkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIodGhpcyk7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSAwO1xuXHRcdFx0dGhpcy5fY2hhbmdlcyA9IDA7XG5cdFx0XHRcblx0XHRcdHRoaXMuX2hpbnRzID0gbmV3IEhpbnRzKHRoaXMpO1xuXHRcdFx0dGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlcih0aGlzKTtcblx0XHRcdHRoaXMuX2hpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzKTtcblx0XHRcdHRoaXMuX3Nob3J0Y3V0cyA9IG5ldyBTaG9ydGN1dE1hbmFnZXIodGhpcyk7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIodGhpcyk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuc2V0UmVnaW9uKG5ldyBSZWdpb24oMCwwLHRoaXMucm9vdCgpLHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0Ly8gYmluZCB0byBtb3VzZW1vdmUgb2YgZG9tP1xuXHRcdFx0XG5cdFx0XHR0aGlzLmRvbSgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsZnVuY3Rpb24oZSkgeyByZXR1cm4gSW1iYS5FdmVudHMuZGVsZWdhdGUoZSk7IH0pO1xuXHRcdFx0dGhpcy5kb20oKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsZnVuY3Rpb24oZSkgeyByZXR1cm4gSW1iYS5FdmVudHMuZGVsZWdhdGUoZSk7IH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCl7XG5cdFx0XHRcblx0XHRcdGlmIChpbnB1dCAhPSB0aGlzLl9pbnB1dCkge1xuXHRcdFx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnc2V0IGlucHV0ISEhJyxAaW5wdXRcblx0XHRcdFx0dGhpcy5faW5wdXQuZG9tKCkuX3Jlc3BvbmRlciA9IHRoaXMuZG9tKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlucHV0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5faW5wdXQgfHwgdGhpcy5fY2FyZXQuaW5wdXQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNhbGxlZCBldmVyeSBmcmFtZSAtIGxvb2tpbmcgZm9yIGNoYW5nZWQgbm9kZXMgdG8gZGVhbCB3aXRoXG5cdFx0Ly8gdG8gZGVhbCB3aXRoIG11dGF0aW9ucy5cblx0XHR0YWcucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuX2ZyYW1lcysrO1xuXHRcdFx0dGhpcy5oaXN0b3J5KCkudGljaygpO1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkgdGhpcy5yZXBhaXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnRpY2soKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgbG9nZ2VyXztcblx0XHRcdChsb2dnZXJfID0gdGhpcy5sb2dnZXIoKSkubG9nLmFwcGx5KGxvZ2dlcl8sYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lZGl0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYuX2NoYW5nZXMrKztcblx0XHRcdHNlbGYuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdHNlbGYuX2J1ZmZlci5yZWZyZXNoKCk7XG5cdFx0XHRcblx0XHRcdHNlbGYudmlldygpLmhpbnRzKCkucmVtKGZ1bmN0aW9uKGhpbnQpIHtcblx0XHRcdFx0cmV0dXJuIGhpbnQuZ3JvdXAoKSA9PSAncnVudGltZSc7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0c2VsZi5oaW50cygpLmNsZWFudXAoKTtcblx0XHRcdFxuXHRcdFx0c2VsZi5kZWxheSgnZGlkY2hhbmdlJyw1MCxmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIEltYmEuRXZlbnRzLnRyaWdnZXIoJ2VkaXRlZDphc3luYycsc2VsZix7ZGF0YTogc2VsZn0pO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIHdlIGNhbiBpbXByb3ZlIGhvdy93aGVuIHdlIGNob29zZSB0byBhbm5vdGF0ZS5cblx0XHRcdC8vIGN1cnJlbnRseSB3ZSBkbyBpdCBhZnRlciBldmVyeSBlZGl0IC0gYnV0IGl0IHNob3VsZFxuXHRcdFx0Ly8gcmVhbGx5IG9ubHkgYmUgbmVlZGVkIHdoZW4gd2UgaGF2ZSBjaGFuZ2VkIGlkZW50aWZpZXJzLlxuXHRcdFx0Ly8gc2hvdWxkIGFsc28gb25seSByZWFubm90YXRlIHRoZSBjbG9zZXN0IGtub3duIHNjb3BlLFxuXHRcdFx0Ly8gYnV0IHRoaXMgY29tZXMgbGF0ZXIgd2l0aCByZWZhY3RvcmluZyBmcm9tIHdob2xlIGZpbGVzXG5cdFx0XHQvLyB0byBzY29wZXMuXG5cdFx0XHRzZWxmLmRlbGF5KCdhbm5vdGF0ZScsNTAwLGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5hbm5vdGF0ZSgpOyB9KTtcblx0XHRcdHNlbGYuZGVsYXkoJ3JlY29tcGlsZScsLTEpOyAvLyBjYW5jZWwgcmVjb21waWxhdGlvblxuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZmxhZygnYWN0aXZlJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy51bmZsYWcoJ2FjdGl2ZScpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiAodDAgPSB0aGlzLl9ib2R5PXRoaXMuX2JvZHkgfHwgdGFnJC4kaW12aWV3Ym9keSgpLnNldFJlZignYm9keScsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodGhpcy5fZGltcyA9IHRoaXMuX2RpbXMgfHwgdGFnJC4kaW1kaW1zKCkuc2V0UmVmKCdkaW1zJyx0aGlzKSkuc2V0VGV4dChcInhcIikuZW5kKCksXG5cdFx0XHRcdCh0aGlzLl9jYXJldCA9IHRoaXMuX2NhcmV0IHx8IHRhZyQuJGltY2FyZXQoKS5zZXRSZWYoJ2NhcmV0Jyx0aGlzKSkuc2V0Vmlldyh0aGlzKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMuX3Jvb3QgPSB0aGlzLl9yb290IHx8IHRhZyQuJGltcm9vdCgpLnNldFJlZigncm9vdCcsdGhpcykuZmxhZygnaW1iYScpKS5zZXRWaWV3KHRoaXMpLmVuZCgpXG5cdFx0XHRdLDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWFkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5mb290ZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vdmVybGF5cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICh0aGlzLl9vdmVybGF5cyA9IHRoaXMuX292ZXJsYXlzIHx8IHRhZyQuJHNjcmltYmxhX292ZXJsYXlzKCkuc2V0UmVmKCdvdmVybGF5cycsdGhpcykpLnNldFZpZXcodGhpcykuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygncmVhZG9ubHknLHRoaXMuaXNSZWFkT25seSgpKS5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHRoaXMuaGVhZGVyKCksXG5cdFx0XHRcdHRoaXMuYm9keSgpLFxuXHRcdFx0XHR0aGlzLmZvb3RlcigpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYXJldCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcm9vdDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyO1xuXHRcdFx0Ly8gcm9vdC5jb2RlXG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnJvb3QoKS5zaXplKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29kZSxvKXtcblx0XHRcdHZhciBwYXJzZWQ7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdHRoaXMuc2V0RmlsZW5hbWUoby5maWxlbmFtZSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9hZGluZyBmaWxlIHdpdGggZmlsZW5hbWUnLG86ZmlsZW5hbWVcblx0XHRcdC8vIG9ic2VydmVyLnBhdXNlIGRvXG5cdFx0XHRpZiAoby5odG1sKSB7XG5cdFx0XHRcdHRoaXMucm9vdCgpLmRvbSgpLmlubmVySFRNTCA9IG8uaHRtbDtcblx0XHRcdFx0dGhpcy5fYnVmZmVyLnJlZnJlc2goKTtcblx0XHRcdFx0dGhpcy5oaXN0b3J5KCkub25sb2FkKHRoaXMuY29kZSgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHNob3VsZCB1c2Ugb3VyIG5ldyBwYXJzZXJcblx0XHRcdFx0aWYgKHBhcnNlZCA9IHRoaXMucGFyc2UoY29kZSkpIHtcblx0XHRcdFx0XHRpZiAocGFyc2VkLmhpZ2hsaWdodGVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJvb3QoKS5kb20oKS5pbm5lckhUTUwgPSBwYXJzZWQuaGlnaGxpZ2h0ZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucm9vdCgpLmRvbSgpLnRleHRDb250ZW50ID0gY29kZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLl9idWZmZXIucmVmcmVzaCgpO1xuXHRcdFx0XHR0aGlzLmhpc3RvcnkoKS5vbmxvYWQoY29kZSk7XG5cdFx0XHRcdHRoaXMuYW5ub3RhdGUoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHQvLyBoZXJlIHdlIGNhbiBwYXJzZSB0aGUgZnVsbCBjb2RlXG5cdFx0XHRyZXR1cm4ge2hpZ2hsaWdodGVkOiBJTS5wYXJzZShjb2RlKX07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlZm9jdXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuaW5wdXQoKS5kb20oKSkgeyB0aGlzLmlucHV0KCkuZm9jdXMoKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5wdXRmb2N1cyA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGNvbnNvbGUubG9nKCdvbmlucHV0Zm9jdXMhIScpO1xuXHRcdFx0VklFVyA9IHRoaXM7IC8vIGhhY2tcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ2ZvY3VzJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5wdXRibHVyID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIHRoaXMudW5mbGFnKCdmb2N1cycpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmZvY3VzaW4gPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRWSUVXID0gdGhpczsgLy8gaGFja1xuXHRcdFx0dGhpcy5mbGFnKCdmb2N1cycpO1xuXHRcdFx0Y29uc29sZS5sb2coJ2ZvY3VzJyxlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmZvY3Vzb3V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy51bmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHRjb25zb2xlLmxvZygndW5mb2N1cycsZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRleHRpbnB1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5leGVjQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbixrZXlkb3duKXtcblx0XHRcdHZhciBjb21tYW5kXztcblx0XHRcdGlmIChhY3Rpb24uY29tbWFuZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBhY3Rpb24uY29tbWFuZC5jYWxsKHRoaXMsdGhpcy5jYXJldCgpLGFjdGlvbi5kYXRhIHx8IHtldmVudDoga2V5ZG93bn0sdGhpcyk7XG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgKGNvbW1hbmRfID0gYWN0aW9uLmNvbW1hbmQpPT0nc3RyaW5nJ3x8Y29tbWFuZF8gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdjb21tYW5kIGlzIHN0cmluZycsYWN0aW9uLmNvbW1hbmQpO1xuXHRcdFx0XHR2YXIgZXYgPSBJbWJhLkV2ZW50cy50cmlnZ2VyKGFjdGlvbi5jb21tYW5kLHRoaXMse2RhdGE6IGFjdGlvbn0pO1xuXHRcdFx0XHR0aGlzLmxvZyhldik7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHJ5Q29tbWFuZCA9IGZ1bmN0aW9uIChjbWQsdGFyZ2V0LHBhcmFtcyl7XG5cdFx0XHRpZihwYXJhbXMgPT09IHVuZGVmaW5lZCkgcGFyYW1zID0gW107XG5cdFx0XHRpZiAoY21kLmNvbnRleHQpIHtcblx0XHRcdFx0dmFyIGd1YXJkID0gY21kLmNvbnRleHQuYXBwbHkodGFyZ2V0IHx8IHRoaXMscGFyYW1zKTtcblx0XHRcdFx0aWYgKCFndWFyZCkgeyByZXR1cm4gZmFsc2UgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjbWQuY29tbWFuZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBjbWQuY29tbWFuZC5hcHBseSh0YXJnZXQgfHwgdGhpcyxwYXJhbXMpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25rZXlkb3duID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIGFycjtcblx0XHRcdFZJRVcgPSB0aGlzOyAvLyBoYWNrXG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdC8vIHZhciBjb21ibyA9IGUua2V5Y29tYm9cblx0XHRcdHZhciBjb21ibyA9IHRoaXMuc2hvcnRjdXRzKCkua2V5c0ZvckV2ZW50KGUuZXZlbnQoKSk7XG5cdFx0XHR2YXIgYWN0aW9uID0gdGhpcy5zaG9ydGN1dHMoKS5nZXRTaG9ydGN1dChlKTtcblx0XHRcdHZhciBpbnMgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHR2YXIgc2hpZnQgPSAoL1xcYnNoaWZ0XFxiLykudGVzdChjb21ibyk7XG5cdFx0XHR2YXIgYWx0ID0gKC9cXGJhbHRcXGIvKS50ZXN0KGNvbWJvKTtcblx0XHRcdHZhciBzdXAgPSAoL1xcYnN1cGVyXFxiLykudGVzdChjb21ibyk7XG5cdFx0XHRcblx0XHRcdC8vIGxvZyAnaW12aWV3IGtleWRvd24nLGNvbWJvXG5cdFx0XHRcblx0XHRcdGlmIChhY3Rpb24pIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2FjdGlvbiBoZXJlPyEnLGFjdGlvblxuXHRcdFx0XHRpZiAodGhpcy5leGVjQWN0aW9uKGFjdGlvbixlKSkgeyBlLmNhbmNlbCgpIH07XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG1vdmUgdGhlc2UgaW50byBjb21tYW5kcyBhcyB3ZWxsXG5cdFx0XHQvLyB0aGlzc2hvdWxkIG1vdmUgdGhpcyBpbnRvIGNvbW1hbmRzIGluc3RlYWRcblx0XHRcdGlmIChhcnIgPSBjb21iby5tYXRjaCgvXFxiKGxlZnR8cmlnaHR8dXB8ZG93bikvKSkge1xuXHRcdFx0XHR0aGlzLmhpbnRzKCkuYWN0aXZhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBpc0NvbGxhcHNlZCA9IHRoaXMuY2FyZXQoKS5pc0NvbGxhcHNlZCgpO1xuXHRcdFx0XHR2YXIgZW5kcyA9IHRoaXMuY2FyZXQoKS5lbmRzKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRzaGlmdCA/ICh0aGlzLmNhcmV0KCkuZGVjb2xsYXBzZSgpKSA6ICh0aGlzLmNhcmV0KCkuY29sbGFwc2UoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYXJyWzBdID09ICdkb3duJykge1xuXHRcdFx0XHRcdHRoaXMuY2FyZXQoKS5tb3ZlRG93bigpO1xuXHRcdFx0XHRcdHJldHVybiBlLmNhbmNlbCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyclswXSA9PSAndXAnKSB7XG5cdFx0XHRcdFx0dGhpcy5jYXJldCgpLm1vdmVVcCgpO1xuXHRcdFx0XHRcdHJldHVybiBlLmNhbmNlbCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIG1vZGUgPSBJTS5DSEFSQUNURVJTO1xuXHRcdFx0XHR2YXIgZGlyID0gMDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhcnJbMF0gPT0gJ2xlZnQnKSB7XG5cdFx0XHRcdFx0ZGlyID0gLTE7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYXJyWzBdID09ICdyaWdodCcpIHtcblx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGFsdCkge1xuXHRcdFx0XHRcdG1vZGUgPSBkaXIgPiAwID8gKElNLldPUkRfRU5EKSA6IChJTS5XT1JEX1NUQVJUKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdXApIHtcblx0XHRcdFx0XHRtb2RlID0gZGlyID4gMCA/IChJTS5MSU5FX0VORCkgOiAoSU0uTElORV9TVEFSVCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXNoaWZ0ICYmICFpc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRcdHRoaXMuY2FyZXQoKS5oZWFkKCkuc2V0KGRpciA+IDAgPyAoZW5kc1sxXSkgOiAoZW5kc1swXSkpO1xuXHRcdFx0XHRcdHRoaXMuY2FyZXQoKS5kaXJ0eSgpOyAvLyBzaG91bGQgbm90IG5lZWQgdG8gY2FsbCB0aGlzIGFsbCB0aGUgdGltZVxuXHRcdFx0XHRcdHJldHVybiBlLmNhbmNlbCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5jYXJldCgpLm1vdmUoZGlyLG1vZGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGUuY2FuY2VsKCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZS5ldmVudCgpLndoaWNoID09IDIyOSkge1xuXHRcdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY29tYm8ubWF0Y2goL15zdXBlclxcKyhjfHZ8eCkkLykpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ21hdGNoaW5nIGNvbWJvIGZvciBjb3B5IHBhc3RlJ1xuXHRcdFx0XHRlLmhhbHQoKTtcblx0XHRcdFx0dGhpcy5fYXdhaXRDb21ibyA9IHRydWU7XG5cdFx0XHRcdHRoaXMucmVmb2N1cygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoaW5zICE9IG51bGwpIHtcblx0XHRcdFx0ZS5oYWx0KCkuY2FuY2VsKCk7XG5cdFx0XHRcdHRoaXMuY2FyZXQoKS5pbnNlcnQoaW5zKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25rZXlwcmVzcyA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmICh0aGlzLl9hd2FpdENvbWJvKSB7XG5cdFx0XHRcdHRoaXMuX2F3YWl0Q29tYm8gPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHR2YXIgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS5ldmVudCgpLmNoYXJDb2RlKTtcblx0XHRcdGUuX3RleHQgPSB0ZXh0O1xuXHRcdFx0ZS5jYW5jZWwoKTtcblx0XHRcdHRoaXMub250eXBlKGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udGV4dGlucHV0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCkuY2FuY2VsKCk7XG5cdFx0XHRlLl90ZXh0ID0gZS5ldmVudCgpLmRhdGE7XG5cdFx0XHR0aGlzLm9udHlwZShlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmtleXVwID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udHlwZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBpbnMgPSBlLl90ZXh0O1xuXHRcdFx0XHQvLyBsb2cgJ29udHlwZScsZSxpbnNcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBzcGFucyA9IHRoaXMudmlldygpLm5vZGVzSW5SZWdpb24odGhpcy5jYXJldCgpLnJlZ2lvbigpLGZhbHNlLHRydWUpO1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gc3BhbnNbMF07XG5cdFx0XHRcdHZhciBjbWQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3BhbnMubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0XHQvLyBsb2cgJ3NpbmdsZSBub2RlIGZvciBub2Rlc0luUmVnaW9uJyx0YXJnZXQ6bm9kZVxuXHRcdFx0XHRcdGlmIChjbWQgPSB0YXJnZXQubm9kZVsoXCJ0cmlnZ2VyLVwiICsgaW5zKV0pIHtcblx0XHRcdFx0XHRcdC8vIGxvZyBcImZvdW5kIGNvbWJvIGZvciB0aGlzIT8/IVwiLGNtZFxuXHRcdFx0XHRcdFx0aWYgKHRoaXMudHJ5Q29tbWFuZChjbWQsdGhpcy5jYXJldCgpLFt0YXJnZXQubm9kZSx0YXJnZXRdKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNtZCA9IHRoaXMuc2hvcnRjdXRzKCkuZ2V0VHJpZ2dlcih0aGlzLGlucyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY21kICYmIChjbWQuY29tbWFuZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuXHRcdFx0XHRcdC8vIGxvZyAnZm91bmQgY29tbWFuZCEhJyxjbWRcblx0XHRcdFx0XHQvLyBzaG91bGQgcmF0aGVyIHJ1biB0cnlDb21tYW5kPyE/XG5cdFx0XHRcdFx0cmV0dXJuIGNtZC5jb21tYW5kKHRoaXMuY2FyZXQoKSx0aGlzLGlucyxlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaW5zKSB7IHJldHVybiB0aGlzLmNhcmV0KCkuaW5zZXJ0KGlucykgfTtcblx0XHRcdFx0fTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubG9nKCdlcnJvciBmcm9tIG9udHlwZScpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25iYWNrc3BhY2UgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmNhbmNlbCgpLmhhbHQoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5lcmFzZSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmJlZm9yZWNvcHkgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoREVCVUcpIHsgY29uc29sZS5sb2coJ29uYmVmb3JlY29weScsZSkgfTtcblx0XHRcdHRoaXMuaW5wdXQoKS5zZWxlY3QoKTtcblx0XHRcdHZhciBkYXRhID0gZS5ldmVudCgpLmNsaXBib2FyZERhdGE7XG5cdFx0XHRkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLHRoaXMuY2FyZXQoKS50ZXh0KCkpO1xuXHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmNvcHkgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoREVCVUcpIHsgY29uc29sZS5sb2coJ29uY29weScsZSx0aGlzLmNhcmV0KCkudGV4dCgpKSB9O1xuXHRcdFx0dmFyIGRhdGEgPSBlLmV2ZW50KCkuY2xpcGJvYXJkRGF0YTtcblx0XHRcdGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsdGhpcy5jYXJldCgpLnRleHQoKSk7XG5cdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdHRoaXMucmVmb2N1cygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmN1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmIChERUJVRykge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnb25jdXQnLGUpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBkYXRhID0gZS5ldmVudCgpLmNsaXBib2FyZERhdGE7XG5cdFx0XHRkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLHRoaXMuY2FyZXQoKS50ZXh0KCkpO1xuXHRcdFx0ZS5oYWx0KCkuY2FuY2VsKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYXJldCgpLmVyYXNlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uYmVmb3JlcGFzdGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gY29uc29sZS5sb2coJ29uYmVmb3JlcGFzdGUnLGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnBhc3RlID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Y29uc29sZS5sb2coJ29ucGFzdGUnLGUpO1xuXHRcdFx0dmFyIGRhdGEgPSBlLmV2ZW50KCkuY2xpcGJvYXJkRGF0YTtcblx0XHRcdHZhciB0ZXh0ID0gZGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG5cdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5pbnNlcnQodGV4dCk7XG5cdFx0XHR0aGlzLnJlZm9jdXMoKTtcblx0XHRcdHJldHVybiB0aGlzLnJlcGFpcigpO1xuXHRcdFx0Ly8gZWRpdCB0ZXh0OiBkYXRhXG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGZvY3VzTm9kZSA9IHNlbC5ub2RlICMgb25seSBpZiBpdCBpcyBpbnNpZGUgdGhlIHNjb3BlP1xuXHRcdFx0Ly8gY2FyZXQucmVnaW9uID0gc2VsLnJlZ2lvblxuXHRcdFx0dGhpcy5jYXJldCgpLnJlbmRlcigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHR2YXIgZm4gPSBvLmNvbW1hbmQ7XG5cdFx0XHR2YXIgYXJncyA9IG8uYXJncyB8fCBbXTtcblx0XHRcdHZhciBldiA9IG5ldyBJbWJhLkV2ZW50KHt0eXBlOiAnY29tbWFuZCcsdGFyZ2V0OiB0aGlzLmRvbSgpLGRhdGE6IG99KTtcblx0XHRcdGV2LnNldERhdGEobyk7XG5cdFx0XHRldi5wcm9jZXNzKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKHRvdWNoKXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHR0aGlzLl9yZWN0ID0gdGhpcy5fYm9keS5kb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvdWNoLmJ1dHRvbigpICE9IDApIHsgcmV0dXJuIH07XG5cdFx0XHRcblx0XHRcdGlmICh0b3VjaC5fdG91Y2gpIHtcblx0XHRcdFx0Ly8gaXMgaXQgbm90IHJlZGlyZWN0ZWQ/XG5cdFx0XHRcdHJldHVybiB0b3VjaC5yZWRpcmVjdCh7fSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgZSA9IHRvdWNoLmV2ZW50KCk7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHQvLyBzZWUgaWYgc2hpZnQgaXMgZG93bj8gc2hvdWxkIGNoYW5nZSBiZWhhdmlvdXJcblx0XHRcdHZhciBzaGlmdCA9IGUuc2hpZnRLZXk7XG5cdFx0XHQvLyBsb2cgJ29udG91Y2hzdGFydCcsdG91Y2gsdG91Y2gueCx0b3VjaC55LGUsdG91Y2guYnV0dG9uXG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5yY0ZvclRvdWNoKHRvdWNoKSk7dmFyIHIgPSBhcnlbMF0sYyA9IGFyeVsxXTtcblx0XHRcdFxuXHRcdFx0aWYgKHNoaWZ0KSB7XG5cdFx0XHRcdHRoaXMuY2FyZXQoKS5zZWxlY3RhYmxlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNhcmV0KCkuY29sbGFwc2UoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuY2FyZXQoKS5oZWFkKCkuc2V0KHIsYykubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICd0b3VjaCBzdGFydCByZWZvY3VzPydcblx0XHRcdHRoaXMucmVmb2N1cygpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnh5VG9Sb3dDb2wgPSBmdW5jdGlvbiAoeCx5KXtcblx0XHRcdHZhciBjb2wgPSBNYXRoLm1heChNYXRoLnJvdW5kKHggLyB0aGlzLmNoYXJXaWR0aCgpKSwwKTtcblx0XHRcdHZhciByb3cgPSBNYXRoLm1heChNYXRoLmNlaWwoeSAvIHRoaXMubGluZUhlaWdodCgpKSwxKTtcblx0XHRcdHJldHVybiBbcm93IC0gMSxjb2xdO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yY0ZvclRvdWNoID0gZnVuY3Rpb24gKHRvdWNoKXtcblx0XHRcdHZhciB4ID0gTWF0aC5tYXgodG91Y2gueCgpIC0gdGhpcy5fcmVjdC5sZWZ0LDApO1xuXHRcdFx0dmFyIHkgPSBNYXRoLm1heCh0b3VjaC55KCkgLSB0aGlzLl9yZWN0LnRvcCwwKTtcblx0XHRcdHJldHVybiB0aGlzLnh5VG9Sb3dDb2woeCx5KTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250b3VjaHVwZGF0ZSA9IGZ1bmN0aW9uICh0b3VjaCl7XG5cdFx0XHR2YXIgYXJ5O1xuXHRcdFx0aWYgKHRvdWNoLmJ1dHRvbigpICE9IDApIHsgcmV0dXJuIH07XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5yY0ZvclRvdWNoKHRvdWNoKSk7dmFyIHIgPSBhcnlbMF0sYyA9IGFyeVsxXTtcblx0XHRcdHRoaXMuY2FyZXQoKS5zZWxlY3RhYmxlKCk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuaGVhZCgpLnNldChyLGMpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5jYXJldCgpLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250b3VjaGVuZCA9IGZ1bmN0aW9uICh0b3VjaCl7XG5cdFx0XHR2YXIgYXJ5O1xuXHRcdFx0aWYgKHRvdWNoLmJ1dHRvbigpICE9IDApIHsgcmV0dXJuIH07XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5yY0ZvclRvdWNoKHRvdWNoKSk7dmFyIHIgPSBhcnlbMF0sYyA9IGFyeVsxXTtcblx0XHRcdHRoaXMuY2FyZXQoKS5oZWFkKCkuc2V0KHIsYykubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lcmFzZSA9IGZ1bmN0aW9uIChyZWcsZWRpdCl7XG5cdFx0XHRyZWcgPSBSZWdpb24ubm9ybWFsaXplKHJlZyx0aGlzKTtcblx0XHRcdFxuXHRcdFx0dmFyIHRleHQgPSByZWcudGV4dCgpO1xuXHRcdFx0dGhpcy5oaXN0b3J5KCkub25lcmFzZShyZWcsdGV4dCxlZGl0KTtcblx0XHRcdFxuXHRcdFx0dmFyIHNwYW5zID0gdGhpcy5ub2Rlc0luUmVnaW9uKHJlZyxmYWxzZSx0cnVlKTtcblx0XHRcdC8vIGdyb3B1IHRoZSBub2Rlc1xuXHRcdFx0dGhpcy5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoc3BhbnMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdHNwYW5zWzFdLm5vZGUuc2V0UHJldih0YWckLiRpbWluc2VydCgpLmZsYWcoJ2RpcnR5JykuZW5kKCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNwYW5zWzBdICYmIHNwYW5zWzBdLm1vZGUgPT0gJ2FsbCcpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygncmVtb3Zpbmcgc2luZ2xlIG5vZGU/IScpO1xuXHRcdFx0XHRcdHZhciBiZWZvcmUgPSBzcGFuc1swXS5ub2RlLnByZXYoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzcGFuc1swXS5ub2RlLnNldFByZXYodGFnJC4kaW1pbnNlcnQoKS5mbGFnKCdkaXJ0eScpLmVuZCgpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzcGFucyksIGxlbiA9IGFyeS5sZW5ndGgsIHNlbCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdC8vIGJ1ZmZlciBuZWVkIHRvIHVwZGF0ZWQgZHVyaW5nIHRoaXM/XG5cdFx0XHRcdFx0c2VsID0gYXJ5W2ldO1xuXHRcdFx0XHRcdHJlcy5wdXNoKHNlbC5ub2RlLmVyYXNlKHNlbC5yZWdpb24sc2VsLm1vZGUsZWRpdCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIGRlbGF5KCdhbm5vdGF0ZScsNTAwKSBkbyBhbm5vdGF0ZVxuXHRcdFx0cmV0dXJuIHRoaXMuZXJhc2VkKHJlZyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluc2VydGVkID0gZnVuY3Rpb24gKGxvYyxzdHIpe1xuXHRcdFx0Y29uc29sZS5sb2coJ2luc2VydGVkJyxsb2Msc3RyKTtcblx0XHRcdHZhciByZWcgPSBuZXcgUmVnaW9uKGxvYyxsb2MgKyBzdHIubGVuZ3RoLG51bGwsdGhpcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5oaW50cygpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFyeVtpXS5hZGp1c3QocmVnLHRydWUpO1xuXHRcdFx0fTtcblx0XHRcdC8vIGhpbnRzLmNsZWFudXBcblx0XHRcdHRoaXMuZWRpdGVkKCk7XG5cdFx0XHRpZiAodXRpbC5pc1doaXRlc3BhY2Uoc3RyKSkgdGhpcy5yZXBhaXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lcmFzZWQgPSBmdW5jdGlvbiAocmVnKXtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmhpbnRzKCkpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldLmFkanVzdChyZWcsZmFsc2UpO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuZWRpdGVkKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXBhaXIoKTsgLy8gcmVwYWlyIHN5bmNocm9ub3VzbHlcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvaW50LHN0cixlZGl0KXtcblx0XHRcdGlmIChwb2ludCBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0XHRpZiAocG9pbnQuc2l6ZSgpID4gMCkge1xuXHRcdFx0XHRcdHRoaXMubG9nZ2VyKCkud2FybigndW5jb2xsYXBzZWQgcmVnaW9uIGluIGluc2VydCBpcyBub3QgYWxsb3dlZCcpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRwb2ludCA9IHBvaW50LnN0YXJ0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLmxvZygnaW5zZXJ0Jyxwb2ludCxzdHIpO1xuXHRcdFx0Ly8gc2hvdWxkIG1heWJlIGNyZWF0ZSB0aGlzIGFzIGEgY29tbWFuZCAtIGFuZCB0aGVuIG1ha2UgaXQgaGFwcGVuP1xuXHRcdFx0XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS5vbmluc2VydChwb2ludCxzdHIsZWRpdCk7XG5cdFx0XHRcblx0XHRcdC8vIGxvZyAnaW5zZXJ0IGluIHZpZXcnXG5cdFx0XHR2YXIgc3BhbnMgPSB0aGlzLm5vZGVzSW5SZWdpb24oUmVnaW9uLm5vcm1hbGl6ZShwb2ludCx0aGlzKSxmYWxzZSk7XG5cdFx0XHR2YXIgbWlkID0gc3BhbnNbMF07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gbWlkIHx8IHNwYW5zLnByZXYgfHwgc3BhbnMubmV4dDtcblx0XHRcdHZhciBsZnQgPSBzcGFucy5sZnQscmd0ID0gc3BhbnMucmd0O1xuXHRcdFx0dmFyIG5vZGU7XG5cdFx0XHR2YXIgcmVnO1xuXHRcdFx0XG5cdFx0XHQvLyBsb2cgc3BhbnMsbWlkLGxmdCxyZ3Rcblx0XHRcdHRoaXMubG9nKCdiZWZvcmUgYW5kIGFmdGVyJyxsZnQscmd0LHN0cik7XG5cdFx0XHRcblx0XHRcdGlmIChtaWQpIHtcblx0XHRcdFx0dGhpcy5sb2coJ2luc2VydCBtaWQnLG1pZC5ub2RlKTtcblx0XHRcdFx0bWlkLm5vZGUuaW5zZXJ0KG1pZC5yZWdpb24sc3RyLGVkaXQsbWlkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocmd0KXtcblx0XHRcdFx0XHRpZiAocmd0LmNhblByZXBlbmQoc3RyKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5sb2coJ3ByZXBlbmQnLHJndCxzdHIpO1xuXHRcdFx0XHRcdFx0cmd0Lmluc2VydCgncHJlcGVuZCcsc3RyLGVkaXQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0ZWQocG9pbnQsc3RyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJndC5pc0ZpcnN0KCkpIHtcblx0XHRcdFx0XHRcdHJndCA9IHJndC5wYXJlbnQoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBmaW5kIHRoZSBjbG9zZXN0IHBhcmVudFxuXHRcdFx0XHR3aGlsZSAobGZ0KXtcblx0XHRcdFx0XHRpZiAobGZ0LmNhbkFwcGVuZChzdHIpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxvZygnYXBwZW5kJyxsZnQsc3RyKTtcblx0XHRcdFx0XHRcdGxmdC5pbnNlcnQoJ2FwcGVuZCcsc3RyLGVkaXQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0ZWQocG9pbnQsc3RyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxmdC5pc0xhc3QoKSkge1xuXHRcdFx0XHRcdFx0bGZ0ID0gbGZ0LnBhcmVudCgpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdG5vZGUgPSB0YWckLiRpbWluc2VydCgpLmVuZCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxmdCkge1xuXHRcdFx0XHRcdGxmdC5zZXROZXh0KG5vZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJndCkge1xuXHRcdFx0XHRcdHJndC5zZXRQcmV2KG5vZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG11c3QgYmUgZW1wdHlcblx0XHRcdFx0XHR0aGlzLnJvb3QoKS5kb20oKS5hcHBlbmRDaGlsZChub2RlLmRvbSgpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdG5vZGUuaW5zZXJ0KCdhcHBlbmQnLHN0cixlZGl0KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmluc2VydGVkKHBvaW50LHN0cik7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubXV0YXRpb25zID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYWlyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0dmFyIGVscyA9IHRoaXMuZG9tKCkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZGlydHknKTtcblx0XHRcdFxuXHRcdFx0aWYgKGVscy5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gbG9nZ2VyLmxvZyBcIntlbHM6bGVuZ3RofSBkaXJ0eSBub2RlcyB0byByZXBhaXJcIlxuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgbXV0cyA9IFtdLCBpID0gMCwgYXJ5ID0gaXRlciQoZWxzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bXV0cy5wdXNoKHRhZyR3cmFwKGFyeVtpXSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG11dHMpLCBsZW4gPSBhcnkubGVuZ3RoLCBtdXQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdG11dCA9IGFyeVtpXTtcblx0XHRcdFx0XHRtdXQudW5mbGFnKCdkaXJ0eScpO1xuXHRcdFx0XHRcdG11dC5tdXRhdGVkKG11dHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcm9vdC5kb20oKS50ZXh0Q29udGVudDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZm9jdXNOb2RlRGlkU2V0ID0gZnVuY3Rpb24gKG5ldyQsb2xkKXtcblx0XHRcdGlmICghdGhpcy5yb290KCkuY29udGFpbnMobmV3JCkpIHsgcmV0dXJuIH07XG5cdFx0XHRcblx0XHRcdHZhciBwYXRoID0gW107XG5cdFx0XHRcblx0XHRcdHdoaWxlIChuZXckICYmIG5ldyQgIT0gdGhpcy5yb290KCkpe1xuXHRcdFx0XHRwYXRoLnB1c2gobmV3JCk7XG5cdFx0XHRcdG5ldyQgPSBuZXckLnBhcmVudCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cSQoJy5mb2N1c18nLHRoaXMpLm1hcChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdGlmIChwYXRoLmluZGV4T2YobikgPCAwKSB7IHJldHVybiBuLnVuZmxhZygnZm9jdXNfJykgfTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwYXRoW2ldLmZsYWcoJ2ZvY3VzXycpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWNvbXBpbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIHNob3VsZCBoYXBwZW4gaW4gYSBzZXBhcmF0ZSB0aHJlYWQgLSBhbmQgYmUgZGVsYXllZFxuXHRcdFx0Y29uc29sZS5sb2coJ3JlY29tcGlsZScpO1xuXHRcdFx0dmFyIHJlcztcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzID0gSW1iYWMuY29tcGlsZSh0aGlzLmNvZGUoKSx7YmFyZTogdHJ1ZX0pO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyB9O1xuXHRcdFx0XG5cdFx0XHRpZiAocmVzKSB7XG5cdFx0XHRcdHRoaXMuY29tcGlsZWQocmVzKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYXJzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ3JlcGFyc2UnKTtcblx0XHRcdHRoaXMucm9vdCgpLnJlaGlnaGxpZ2h0KHtpbm5lcjogdHJ1ZX0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbXBpbGVkID0gZnVuY3Rpb24gKHJlcyl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25ydW5lcnJvciA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGNvbnNvbGUubG9nKCdvbnJ1bmVycm9yJyxlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hZGRFcnJvciA9IGZ1bmN0aW9uIChtc2csbG9jKXtcblx0XHRcdHZhciBub2RlO1xuXHRcdFx0dmFyIHJlZyA9IFJlZ2lvbi5ub3JtYWxpemUobG9jLHRoaXMpO1xuXHRcdFx0Y29uc29sZS5sb2coJ2ZvdW5kIHdhcm5pbmdzJyxyZWcsbXNnLGxvYyk7XG5cdFx0XHRpZiAobm9kZSA9IHRoaXMubm9kZUF0UmVnaW9uKHJlZykpIHtcblx0XHRcdFx0dGhpcy5sb2coJ25vZGUgYXQgcmVnaW9uIGlzPyEnLG5vZGUpO1xuXHRcdFx0XHRtc2cgPSBtc2cuc3BsaXQoL2Vycm9yIGF0IChcXFtbXFxkXFw6XSpcXF0pXFw6XFxzKi8pLnBvcCgpO1xuXHRcdFx0XHRub2RlLmZsYWcoJ2VycicpO1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnZXJyb3InLG1zZyk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5kZWxheSgnYW5ub3RhdGUnLC0xKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hbm5vdGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2Fubm90YXRlJ1xuXHRcdFx0XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWxmLnJvb3QoKS5jb2RlU3RhdGUoKTtcblx0XHRcdHZhciBjb2RlID0gc3RhdGUuY29kZTtcblx0XHRcdFxuXHRcdFx0dmFyIGFwcGx5ID0gZnVuY3Rpb24obWV0YSkge1xuXHRcdFx0XHR2YXIgdmFycyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobWV0YS5zY29wZXMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMCwgaXRlbXMgPSBpdGVyJChhcnlbaV0udmFycyksIGxlbl8gPSBpdGVtcy5sZW5ndGg7IGogPCBsZW5fOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhcnMucHVzaChpdGVtc1tqXSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciB3YXJuaW5ncyA9IG1ldGEud2FybmluZ3MgfHwgW107XG5cdFx0XHRcdHZhciBvbGRXYXJuaW5ncyA9IHNlbGYuaGludHMoKS5maWx0ZXIoZnVuY3Rpb24oaGludCkgeyByZXR1cm4gaGludC5ncm91cCgpID09ICdhbmFseXNpcyc7IH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG9sZFdhcm5pbmdzKSB7XG5cdFx0XHRcdFx0Ly8gY291bGQgaW50ZWxsaWdlbnRseSBrZWVwIHRoZW0gaW5zdGVhZFxuXHRcdFx0XHRcdHNlbGYuaGludHMoKS5yZW0ob2xkV2FybmluZ3MpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHdhcm5pbmdzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgd2FybjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0d2FybiA9IGFyeVtpXTtcblx0XHRcdFx0XHR3YXJuLnR5cGUgfHwgKHdhcm4udHlwZSA9ICdlcnJvcicpO1xuXHRcdFx0XHRcdHdhcm4uZ3JvdXAgPSAnYW5hbHlzaXMnO1xuXHRcdFx0XHRcdHNlbGYuaGludHMoKS5hZGQod2FybikuYWN0aXZhdGUoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh3YXJuaW5ncy5sZW5ndGgpIHsgcmV0dXJuIHNlbGYgfTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBub2RlcyA9IElNLnRleHROb2RlcyhzZWxmLnJvb3QoKS5kb20oKSx0cnVlKTtcblx0XHRcdFx0Ly8gd2hhdCBhYm91dCByZW1vdmluZyBvbGQgd2FybmluZ3M/XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgbWFwID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIG5vZGU7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdG5vZGUgPSBhcnlbaV07XG5cdFx0XHRcdFx0bWFwW25vZGUuX2xvY10gPSBub2RlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZ2V0IHRleHROb2RlcyB3aXRoIG1hcHBpbmcoISlcblx0XHRcdFx0Zm9yICh2YXIgaTEgPSAwLCBsZW4gPSB2YXJzLmxlbmd0aDsgaTEgPCBsZW47IGkxKyspIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gMCwgYXJ5ID0gaXRlciQodmFyc1tpMV0ucmVmcyksIGxlbl8gPSBhcnkubGVuZ3RoLCByZWY7IGsgPCBsZW5fOyBrKyspIHtcblx0XHRcdFx0XHRcdHJlZiA9IGFyeVtrXTtcblx0XHRcdFx0XHRcdHZhciBhID0gcmVmLmxvY1swXTtcblx0XHRcdFx0XHRcdHZhciBiID0gcmVmLmxvY1sxXTtcblx0XHRcdFx0XHRcdHZhciBlcmVmID0gKFwidlwiICsgaTEpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAobWFwW2FdKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBtYXBbYV0ucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdFx0dmFyIG9sZFJlZiA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2VyZWYnKTtcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3NldHRpbmcgdGhlIHJlZiBmb3Igbm9kZT8nLGRvbSxkb20uQHRhZ1xuXHRcdFx0XHRcdFx0XHR0YWckd3JhcChkb20pLnNldEVyZWYoZXJlZik7XG5cdFx0XHRcdFx0XHRcdC8vIGlmIGRvbS5AdGFnXG5cdFx0XHRcdFx0XHRcdC8vIFx0ZG9tLkB0YWcuZXJlZiA9IGVyZWZcblx0XHRcdFx0XHRcdFx0Ly8gZWxzZVxuXHRcdFx0XHRcdFx0XHQvLyBcdGRvbS5zZXRBdHRyaWJ1dGUoJ2VyZWYnLGVyZWYpIHVubGVzcyBvbGRSZWYgPT0gZXJlZlxuXHRcdFx0XHRcdFx0XHQvLyBcdGRvbTpjbGFzc0xpc3QuYWRkKCdsdmFyJylcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zb2xlLnRpbWUoJ2FuYWx5emUnKTtcblx0XHRcdFx0SU0ud29ya2VyKCkuYW5hbHl6ZShjb2RlLHtiYXJlOiB0cnVlfSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygncmVzdWx0IGZyb20gd29ya2VyIGFuYWx5emUnKTtcblx0XHRcdFx0XHRjb25zb2xlLnRpbWVFbmQoJ2FuYWx5emUnKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocmVzLmRhdGEpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUudGltZSgnYW5ub3RhdGUnKTtcblx0XHRcdFx0XHRcdGFwcGx5KHJlcy5kYXRhKTtcblx0XHRcdFx0XHRcdHJldHVybiBjb25zb2xlLnRpbWVFbmQoJ2Fubm90YXRlJyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHNlbGYubG9nKCdlcnJvciBmcm9tIGFubm90YXRlJyxlKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmNvbW1hbmQgPSBmdW5jdGlvbiAoZSxjKXtcblx0XHRcdGlmICh0aGlzW2MuY29tbWFuZF0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHR0aGlzW2MuY29tbWFuZF0uY2FsbCh0aGlzLGMuYXJncyB8fCBbXSk7XG5cdFx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kdW1wU3RhdGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGh0bWw6IHRoaXMucm9vdCgpLmRvbSgpLmlubmVySFRNTCxcblx0XHRcdFx0Y29kZTogdGhpcy5yb290KCkuY29kZSgpLFxuXHRcdFx0XHRzZWxlY3Rpb246IHRoaXMuY2FyZXQoKS5yZWdpb24oKSxcblx0XHRcdFx0dGltZXN0YW1wOiBuZXcgRGF0ZSgpXG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkU3RhdGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdHNlbGYub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZfO1xuXHRcdFx0XHRpZiAoby5odG1sKSB7XG5cdFx0XHRcdFx0c2VsZi5yb290KCkuZG9tKCkuaW5uZXJIVE1MID0gby5odG1sO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG8uY29kZSkge1xuXHRcdFx0XHRcdHNlbGYubG9hZChvLmNvZGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoby5zZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gKHNlbGYuY2FyZXQoKS5zZXRSZWdpb24odl8gPSBvLnNlbGVjdGlvbiksdl8pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbil7XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS5sb2FkKHNlc3Npb24pO1xuXHRcdFx0dGhpcy5oaXN0b3J5KCkucGxheSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRleHROb2RlcyA9IGZ1bmN0aW9uIChyZWwpe1xuXHRcdFx0aWYocmVsID09PSB1bmRlZmluZWQpIHJlbCA9IHRoaXMucm9vdCgpO1xuXHRcdFx0cmV0dXJuIElNLnRleHROb2RlcyhyZWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gU2hvdWxkIGJlIHNlcGFyYXRlIGZyb20gdGhlIHZpZXdjb2RlP1xuXHRcdHRhZy5wcm90b3R5cGUucmVnaW9uRm9yTm9kZSA9IGZ1bmN0aW9uIChub2RlLHJlbCl7XG5cdFx0XHRpZihyZWwgPT09IHVuZGVmaW5lZCkgcmVsID0gdGhpcy5yb290KCk7XG5cdFx0XHR2YXIgZWwgPSBub2RlLl9kb20gfHwgbm9kZTtcblx0XHRcdHZhciBsZW4gPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG5cdFx0XHR2YXIgcm5nID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblx0XHRcdHJuZy5zZXRTdGFydChyZWwuX2RvbSB8fCByZWwsMCk7XG5cdFx0XHRybmcuc2V0RW5kKG5vZGUuX2RvbSB8fCBub2RlLDApO1xuXHRcdFx0dmFyIHByZSA9IHJuZy50b1N0cmluZygpO1xuXHRcdFx0cmV0dXJuIG5ldyBSZWdpb24ocHJlLmxlbmd0aCxwcmUubGVuZ3RoICsgbGVuLHJlbCx0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIFNob3VsZCBtZXJnZSB3aXRoIG5vZGVzSW5SZWdpb25cblx0XHR0YWcucHJvdG90eXBlLm5vZGVBdFJlZ2lvbiA9IGZ1bmN0aW9uIChyZWdpb24sZXhhY3Qpe1xuXHRcdFx0aWYoZXhhY3QgPT09IHVuZGVmaW5lZCkgZXhhY3QgPSBmYWxzZTtcblx0XHRcdGNvbnNvbGUudGltZSgnbm9kZUF0UmVnaW9uJyk7XG5cdFx0XHR2YXIgcmVsID0gdGhpcy5yb290KCk7XG5cdFx0XHR2YXIgYSA9IHJlZ2lvbi5hKCk7XG5cdFx0XHR2YXIgYiA9IHJlZ2lvbi5iKCk7XG5cdFx0XHRcblx0XHRcdHZhciBub2RlcyA9IHRoaXMudGV4dE5vZGVzKHJlbCk7XG5cdFx0XHQvLyBtb3ZlIGludG8gcmVnaW9uIGluc3RlYWQ/XG5cdFx0XHR2YXIgcG9zID0gMDtcblx0XHRcdHZhciBtYXRjaCA9IG51bGw7XG5cdFx0XHR2YXIgYWRpc3QsYmRpc3Qsc3RyLGxlbjtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuXyA9IGFyeS5sZW5ndGgsIG5vZGU7IGkgPCBsZW5fOyBpKyspIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2xvb2tpbmcgdGhyb3VnaCBub2Rlcydcblx0XHRcdFx0bm9kZSA9IGFyeVtpXTtcblx0XHRcdFx0YWRpc3QgPSBhIC0gcG9zO1xuXHRcdFx0XHRiZGlzdCA9IGIgLSBwb3M7XG5cdFx0XHRcdHN0ciA9IG5vZGUudGV4dENvbnRlbnQ7XG5cdFx0XHRcdGxlbiA9IHN0ci5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYWRpc3QgPj0gMCAmJiBhZGlzdCA8IGxlbikge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmb3VuZCBzdGFydGluZyBwb2ludD8nLG5vZGUsc3RyLGFkaXN0XG5cdFx0XHRcdFx0bWF0Y2ggPSBub2RlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdC8vIHJldHVybiB0YWcobm9kZTpwYXJlbnROb2RlKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGJkaXN0ID49IDAgJiYgYmRpc3QgPCBsZW4pIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnZm91bmQgZW5kaW5nIHBvaW50Jyxub2RlLHN0cixiZGlzdFxuXHRcdFx0XHRcdC8vIHJhbmdlLnNldEVuZChub2RlLGJkaXN0KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdHBvcyArPSBsZW47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgZWwgPSB0YWckd3JhcChtYXRjaC5wYXJlbnROb2RlKTtcblx0XHRcdC8vIHdlIHdhbnQgdG8gbWF0Y2ggdGhlIG9uZSB0aGF0IGlzIGZ1bGwgbGVuZ3RoXG5cdFx0XHRpZiAoZXhhY3QgJiYgbGVuIDwgcmVnaW9uLnNpemUoKSkge1xuXHRcdFx0XHR3aGlsZSAoZWwpe1xuXHRcdFx0XHRcdC8vIGJlIGNhcmVmdWxcblx0XHRcdFx0XHR2YXIgZWxyZWcgPSBlbC5yZWdpb24oKTtcblx0XHRcdFx0XHRpZiAocmVnaW9uLmVxdWFscyhlbHJlZykpIHsgcmV0dXJuIGVsIH07XG5cdFx0XHRcdFx0ZWwgPSBlbC5wYXJlbnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnNvbGUudGltZUVuZCgnbm9kZUF0UmVnaW9uJyk7XG5cdFx0XHRyZXR1cm4gbWF0Y2ggPyAodGFnJHdyYXAobWF0Y2gucGFyZW50Tm9kZSkpIDogKG51bGwpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ub2Rlc0ZvckVudGl0eSA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdFx0cmV0dXJuIHEkKCdbZXJlZj1cIicrKFwiXCIgKyByZWYpKydcIl0nLHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZG9lcyBub3QgbmVlZCB0byBiZWxvbmcgdG8gdmlldyBkaXJlY3RseVxuXHRcdHRhZy5wcm90b3R5cGUubm9kZXNJblJlZ2lvbiA9IGZ1bmN0aW9uIChyZWdpb24saW5jbHVkZUVuZHMsZ2VuZXJhbGl6ZSl7XG5cdFx0XHRpZihpbmNsdWRlRW5kcyA9PT0gdW5kZWZpbmVkKSBpbmNsdWRlRW5kcyA9IHRydWU7XG5cdFx0XHRpZihnZW5lcmFsaXplID09PSB1bmRlZmluZWQpIGdlbmVyYWxpemUgPSBmYWxzZTtcblx0XHRcdGNvbnNvbGUudGltZSgnbm9kZXNJblJlZ2lvbicpO1xuXHRcdFx0cmVnaW9uID0gUmVnaW9uLm5vcm1hbGl6ZShyZWdpb24sdGhpcykubm9ybWFsaXplKCk7XG5cdFx0XHR2YXIgYSA9IHJlZ2lvbi5zdGFydCgpO1xuXHRcdFx0dmFyIGIgPSByZWdpb24uZW5kKCk7XG5cdFx0XHRcblx0XHRcdC8vIGNhbiBiZSBvcHRpbWl6ZWQgYnkgc3VwcGx5aW5nIHRoZSByZWdpb25zXG5cdFx0XHR2YXIgbm9kZXMgPSBJTS50ZXh0Tm9kZXMocmVnaW9uLnJvb3QoKSB8fCB0aGlzLnJvb3QoKSk7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IFtdO1xuXHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0Ly8gbW92ZSBpbnRvIHJlZ2lvbiBpbnN0ZWFkP1xuXHRcdFx0bWF0Y2hlcy5pbmNsdWRlRW5kcyA9IGluY2x1ZGVFbmRzO1xuXHRcdFx0bWF0Y2hlcy5yZWdpb24gPSByZWdpb247XG5cdFx0XHRcblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIGVuZHMgPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaTEgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbl8gPSBhcnkubGVuZ3RoLCBub2RlOyBpMSA8IGxlbl87IGkxKyspIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2xvb2tpbmcgdGhyb3VnaCBub2Rlcydcblx0XHRcdFx0bm9kZSA9IGFyeVtpMV07XG5cdFx0XHRcdHZhciBhZGlzdCA9IGEgLSBwb3M7XG5cdFx0XHRcdHZhciBiZGlzdCA9IGIgLSBwb3M7XG5cdFx0XHRcdHZhciBzdHIgPSBub2RlLnRleHRDb250ZW50O1xuXHRcdFx0XHR2YXIgbGVuID0gc3RyLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICgocG9zICsgbGVuKSA+PSBhICYmIHBvcyA8PSBiKSB7XG5cdFx0XHRcdFx0ZWwgPSB0YWckd3JhcChub2RlLnBhcmVudE5vZGUpO1xuXHRcdFx0XHRcdHZhciBzdGFydCA9IE1hdGgubWF4KDAsYSAtIHBvcyk7XG5cdFx0XHRcdFx0dmFyIGVuZCA9IE1hdGgubWluKGxlbixNYXRoLm1heChiIC0gcG9zLDApKTtcblx0XHRcdFx0XHR2YXIgcGFyO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdG1hdGNoID0ge1xuXHRcdFx0XHRcdFx0bm9kZTogZWwsXG5cdFx0XHRcdFx0XHRzdGFydE9mZnNldDogc3RhcnQsXG5cdFx0XHRcdFx0XHRlbmRPZmZzZXQ6IGVuZCxcblx0XHRcdFx0XHRcdHJlZ2lvbjogbmV3IFJlZ2lvbihzdGFydCxlbmQsZWwsdGhpcyksXG5cdFx0XHRcdFx0XHRzaXplOiBsZW5cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIGxvZyBcIm5vZGUgYXQge3Bvc30gKyB7bGVufSAtIGxvb2tpbmcgaW4gcmFuZ2Uge2F9IC0ge2J9XCJcblx0XHRcdFx0XHR2YXIgbW9kZSA9ICdhbGwnO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChzdGFydCA9PSBsZW4pIHtcblx0XHRcdFx0XHRcdG1vZGUgPSAnZW5kJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRtb2RlID0gJ3N0YXJ0Jztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0YXJ0ID09IDAgJiYgZW5kID09IGxlbikge1xuXHRcdFx0XHRcdFx0cGFyID0gZWwuZG9tKCkucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdHZhciBpc09wZW5lciA9IHBhciAhPSB0aGlzLl9yb290LmRvbSgpICYmIGVsLmRvbSgpID09IHBhci5maXJzdENoaWxkO1xuXHRcdFx0XHRcdFx0dmFyIGlzQ2xvc2VyID0gcGFyICE9IHRoaXMuX3Jvb3QuZG9tKCkgJiYgZWwuZG9tKCkgPT0gcGFyLmxhc3RDaGlsZDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGlzT3BlbmVyKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoLm9wZW5zID0gZWwucGFyZW50KCk7XG5cdFx0XHRcdFx0XHRcdGVuZHMucHVzaChtYXRjaCk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoaXNDbG9zZXIpIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdFx0XHRpZiAoZW5kICYmIGVuZC5vcGVucyA9PSBlbC5wYXJlbnQoKSkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZC5jbG9zZXIgPSBtYXRjaDtcblx0XHRcdFx0XHRcdFx0XHRtYXRjaC5vcGVuZXIgPSBlbmQ7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kcy5wb3AoKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdG1hdGNoLmNsb3NlcyA9IGVsLnBhcmVudCgpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0bW9kZSA9ICdhbGwnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtb2RlID0gJ3BhcnRpYWwnO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bWF0Y2gubW9kZSA9IG1vZGU7XG5cdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKG1hdGNoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHBvcyArPSBsZW47XG5cdFx0XHRcdGlmIChwb3MgPiBiKSB7IGJyZWFrOyB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGZpcnN0ID0gbWF0Y2hlc1swXTtcblx0XHRcdHZhciBsYXN0ID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XG5cdFx0XHRpZiAoZmlyc3QgJiYgZmlyc3QubW9kZSA9PSAnZW5kJykge1xuXHRcdFx0XHRtYXRjaGVzLnByZXYgPSBmaXJzdDtcblx0XHRcdFx0bWF0Y2hlcy5sZnQgPSBmaXJzdC5ub2RlO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaWYgZmlyc3Q6bm9kZSBpc2EgSU0uVHlwZXM6Y2xvc2Vcblx0XHRcdFx0Ly8gXHRtYXRjaGVzOmxmdCA9IGZpcnN0Om5vZGUucGFyZW50XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWluY2x1ZGVFbmRzKSB7IG1hdGNoZXMuc2hpZnQoKSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGxhc3QgJiYgbGFzdC5tb2RlID09ICdzdGFydCcpIHtcblx0XHRcdFx0bWF0Y2hlcy5uZXh0ID0gbGFzdDtcblx0XHRcdFx0bWF0Y2hlcy5yZ3QgPSBsYXN0Lm5vZGU7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpZiBsYXN0Om5vZGUgaXNhIElNLlR5cGVzOm9wZW5cblx0XHRcdFx0Ly8gXHRtYXRjaGVzOnJndCA9IGxhc3Q6bm9kZS5wYXJlbnRcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghaW5jbHVkZUVuZHMpIHsgbWF0Y2hlcy5wb3AoKSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBub3JtYWxpemUgdGhlIG5vZGVzIGluIGdyb3Vwc1xuXHRcdFx0aWYgKGdlbmVyYWxpemUpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2dlbmVyYWxpemUhJyxtYXRjaGVzXG5cdFx0XHRcdHZhciBpID0gMDtcblx0XHRcdFx0dmFyIG07XG5cdFx0XHRcdHdoaWxlIChtID0gbWF0Y2hlc1tpXSl7XG5cdFx0XHRcdFx0aWYgKG0uY2xvc2VyKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4ID0gbWF0Y2hlcy5pbmRleE9mKG0uY2xvc2VyKTtcblx0XHRcdFx0XHRcdGxlbiA9IG0ub3BlbnMuc2l6ZSgpO1xuXHRcdFx0XHRcdFx0dmFyIG5ldyQgPSB7XG5cdFx0XHRcdFx0XHRcdG1vZGU6ICdhbGwnLFxuXHRcdFx0XHRcdFx0XHRyZWdpb246IG5ldyBSZWdpb24oMCxsZW4sbS5vcGVucyx0aGlzKSxcblx0XHRcdFx0XHRcdFx0c3RhcnRPZmZzZXQ6IDAsXG5cdFx0XHRcdFx0XHRcdGVuZE9mZnNldDogbGVuLFxuXHRcdFx0XHRcdFx0XHRub2RlOiBtLm9wZW5zXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0dmFyIHJlbSA9IG1hdGNoZXMuc3BsaWNlKGksaWR4IC0gaSArIDEsbmV3JCk7XG5cdFx0XHRcdFx0XHRuZXckLmNoaWxkcmVuID0gcmVtO1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3NsaWNlIGF3YXkgdGhlIGl0ZW1zJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS50aW1lRW5kKCdub2Rlc0luUmVnaW9uJyk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCBtb3ZlIHRvIEJ1ZmZlciBjbGFzc1xuXHRcdHRhZy5wcm90b3R5cGUubGluZWNvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5idWZmZXIoKS5saW5lY291bnQoKTtcblx0XHRcdC8vIGJ1ZmZlci5zcGxpdCgnXFxuJylbOmxlbmd0aF1cblx0XHR9O1xuXHRcdFxuXHRcdC8vIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSByZWdpb24gYXMgYSBzdHJpbmcuXG5cdFx0Ly8gUmV0dXJucyB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodCBvZiB0aGUgcG9pbnQuXG5cdFx0dGFnLnByb3RvdHlwZS5zdWJzdHIgPSBmdW5jdGlvbiAocmVnaW9uLGxlbil7XG5cdFx0XHRyZXR1cm4gdGhpcy5idWZmZXIoKS5zdWJzdHIocmVnaW9uLGxlbik7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBtb3ZlIGludG8gQnVmZmVyXG5cdFx0dGFnLnByb3RvdHlwZS5saW5lc3RyID0gZnVuY3Rpb24gKG5yKXtcblx0XHRcdHJldHVybiB0aGlzLmJ1ZmZlcigpLmxpbmUobnIpO1xuXHRcdFx0Ly8gaWYgbnIgaXNhIE51bWJlclxuXHRcdFx0Ly8gXHRidWZmZXIuc3BsaXQoJ1xcbicpW25yXSBvciAnJ1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5leHBhbmRSZWdpb25UbyA9IGZ1bmN0aW9uIChyZWdpb24sbWF0Y2gsZm9yd2FyZCl7XG5cdFx0XHRpZihmb3J3YXJkID09PSB1bmRlZmluZWQpIGZvcndhcmQgPSB0cnVlO1xuXHRcdFx0dmFyIGJ1ZiA9IHRoaXMuYnVmZmVyKCkudG9TdHJpbmcoKTtcblx0XHRcdHZhciBwb3MgPSByZWdpb24uc3RhcnQoKTtcblx0XHRcdHZhciBlbmQgPSByZWdpb24uZW5kKCk7XG5cdFx0XHRcblx0XHRcdGlmIChmb3J3YXJkKSB7XG5cdFx0XHRcdHdoaWxlIChidWZbZW5kICsgMV0gIT0gbWF0Y2gpe1xuXHRcdFx0XHRcdGVuZCsrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKGJ1Zltwb3MgLSAxXSAhPSBtYXRjaCl7XG5cdFx0XHRcdFx0cG9zLS07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2lvbihwb3MsZW5kLHRoaXMpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHJldHVybiBWSUVXID0gbnVsbDtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL3ZpZXcuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuLi9yZWdpb24nKS5SZWdpb247XG5cdFxuXHRmdW5jdGlvbiBCdWZmZXIodmlldyl7XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdFx0dGhpcy5fYnVmZmVyID0gJyc7XG5cdFx0dGhpcy5fY2FjaGUgPSB7fTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0QnVmZmVyLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGJ1ZmZlcil7XG5cdFx0aWYgKGJ1ZmZlciA9PSB0aGlzLl9idWZmZXIpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuXHRcdHRoaXMuX2NhY2hlID0ge307XG5cdFx0dGhpcy5fbGluZXMgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuc2V0KHRoaXMudmlldygpLnJvb3QoKS5jb2RlKCkpO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5saW5lcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9saW5lcyB8fCAodGhpcy5fbGluZXMgPSAodHJ1ZSkgJiYgKFxuXHRcdFx0dGhpcy5fYnVmZmVyLnNwbGl0KCdcXG4nKVxuXHRcdCkpO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9idWZmZXIuc3BsaXQuYXBwbHkodGhpcy5fYnVmZmVyLGFyZ3VtZW50cyk7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxpbmVjb3VudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmxpbmVzKCkubGVuZ3RoO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5saW5lID0gZnVuY3Rpb24gKG5yKXtcblx0XHRpZiAoKHR5cGVvZiBucj09J251bWJlcid8fG5yIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubGluZXMoKVtucl0gfHwgJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9O1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyLmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIGxvY2F0aW9uIHRvIFxuXHRCdWZmZXIucHJvdG90eXBlLmxvY1RvUmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUubG9jYXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUubG9jVG9Sb3cgPSBmdW5jdGlvbiAobG9jKXtcblx0XHR2YXIgbG4gPSAwO1xuXHRcdHZhciBsZW4gPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmxpbmVzKCkpLCBsZW5fID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbl87IGkrKykge1xuXHRcdFx0bGVuICs9IGFyeVtpXS5sZW5ndGggKyAxO1xuXHRcdFx0aWYgKGxvYyA8IGxlbikgeyByZXR1cm4gaSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMubGluZXMoKS5sZW5ndGg7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxvY1RvQ2VsbCA9IGZ1bmN0aW9uIChsb2Mpe1xuXHRcdGlmICh0aGlzLl9jYWNoZVtsb2NdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FjaGVbbG9jXTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBwb3MgPSBsb2M7XG5cdFx0dmFyIGNvbCA9IDA7XG5cdFx0dmFyIHJvdyA9IDA7XG5cdFx0dmFyIGNoYXIkO1xuXHRcdFxuXHRcdHZhciBidWYgPSB0aGlzLl9idWZmZXI7XG5cdFx0dmFyIHRhYnNpemUgPSB0aGlzLl92aWV3LnRhYlNpemUoKTtcblx0XHRcblx0XHQvLyBnbyBiYWNrIHRvIHN0YXJ0IG9mIGxpbmVcblx0XHQvLyBnb2VzIHRocm91Z2ggdGhlIHdob2xlXG5cdFx0d2hpbGUgKGNoYXIkID0gYnVmW3BvcyAtIDFdKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFxuJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH07XG5cdFx0XHRwb3MtLTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGdldCBjb2x1bW4gZm9yIHNsaWNlXG5cdFx0d2hpbGUgKChwb3MgPCBsb2MpICYmIChjaGFyJCA9IGJ1Zltwb3NdKSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcdCcpIHtcblx0XHRcdFx0dmFyIHJlc3QgPSB0YWJzaXplIC0gKGNvbCAlIHRhYnNpemUpO1xuXHRcdFx0XHRjb2wgKz0gcmVzdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbCArPSAxO1xuXHRcdFx0fTtcblx0XHRcdHBvcysrO1xuXHRcdH07XG5cdFx0XG5cdFx0d2hpbGUgKGNoYXIkID0gYnVmW3BvcyAtIDFdKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFxuJykge1xuXHRcdFx0XHRyb3crKztcblx0XHRcdH07XG5cdFx0XHRwb3MtLTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzLl9jYWNoZVtsb2NdID0gW3Jvdyxjb2xdO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5zdWJzdHIgPSBmdW5jdGlvbiAocmVnaW9uLGxlbil7XG5cdFx0aWYgKHJlZ2lvbiBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2J1ZmZlci5zdWJzdHIocmVnaW9uLnN0YXJ0KCkscmVnaW9uLnNpemUoKSk7XG5cdFx0fSBlbHNlIGlmICgodHlwZW9mIHJlZ2lvbj09J251bWJlcid8fHJlZ2lvbiBpbnN0YW5jZW9mIE51bWJlcikpIHtcblx0XHRcdHJldHVybiB0aGlzLl9idWZmZXIuc3Vic3RyKHJlZ2lvbixsZW4gfHwgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93ICdtdXN0IGJlIHJlZ2lvbiBvciBudW1iZXInO1xuXHRcdH07XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2J1ZmZlciB8fCAnJztcblx0fTtcblx0cmV0dXJuIEJ1ZmZlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvYnVmZmVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cdFxuXHRmdW5jdGlvbiBPYnNlcnZlcih2aWV3LGNmZyl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdHNlbGYuX3ZpZXcgPSB2aWV3O1xuXHRcdHNlbGYuX2NvbmZpZyA9IGNmZyB8fCB7YXR0cmlidXRlczogZmFsc2UsY2hpbGRMaXN0OiB0cnVlLGNoYXJhY3RlckRhdGE6IHRydWUsc3VidHJlZTogdHJ1ZX07XG5cdFx0c2VsZi5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbihtdXRzKSB7IHJldHVybiBzZWxmLm9ubXV0YXRpb25zKG11dHMpOyB9KTtcblx0XHRzZWxmO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5PYnNlcnZlciA9IE9ic2VydmVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0T2JzZXJ2ZXIucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdE9ic2VydmVyLnByb3RvdHlwZS5jb25maWcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvbmZpZzsgfVxuXHRPYnNlcnZlci5wcm90b3R5cGUuc2V0Q29uZmlnID0gZnVuY3Rpb24odil7IHRoaXMuX2NvbmZpZyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdE9ic2VydmVyLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuXHRPYnNlcnZlci5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24odil7IHRoaXMuX2FjdGl2ZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7XG5cdFx0XHR0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMudmlldygpLnJvb3QoKS5kb20oKSx0aGlzLmNvbmZpZygpKTtcblx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE9ic2VydmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChibGspe1xuXHRcdHZhciB3YXNBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0aWYgKHdhc0FjdGl2ZSkgeyB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCkgfTtcblx0XHRcblx0XHRpZiAoYmxrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdGJsaygpO1xuXHRcdFx0aWYgKHdhc0FjdGl2ZSkgdGhpcy5yZXN1bWUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLnBhdXNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAhdGhpcy5fYWN0aXZlO1xuXHR9O1xuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLm9ubXV0YXRpb25zID0gZnVuY3Rpb24gKG11dGF0aW9ucyl7XG5cdFx0dmFyIGVsO1xuXHRcdHRoaXMudmlldygpLmxvZ2dlcigpLmdyb3VwKCdtdXRhdGlvbnMnKTtcblx0XHRcblx0XHR2YXIgZGVlcCA9IGZhbHNlO1xuXHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChtdXRhdGlvbnMpLCBsZW4gPSBhcnkubGVuZ3RoLCBtdXQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0bXV0ID0gYXJ5W2ldO1xuXHRcdFx0dGhpcy52aWV3KCkubG9nKCdtdXRhdGlvbicsbXV0KTtcblx0XHRcdHZhciB0eXBlID0gbXV0LnR5cGU7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gbXV0LnByZXZpb3VzU2libGluZyB8fCBtdXQudGFyZ2V0O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnY2hhcmFjdGVyRGF0YScpIHtcblx0XHRcdFx0dGhpcy52aWV3KCkubG9nKChcInVwZGF0ZWQgY29kZSB0byBcIiArICh0YXJnZXQudGV4dENvbnRlbnQpKSk7XG5cdFx0XHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdjaGlsZExpc3QnKSB7XG5cdFx0XHRcdGRlZXAgPSB0cnVlO1xuXHRcdFx0XHR2YXIgYWRkID0gbXV0LmFkZGVkTm9kZXM7XG5cdFx0XHRcdGlmIChhZGQubGVuZ3RoID09IDEgJiYgKGFkZFswXSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gYWRkWzBdO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy52aWV3KCkubG9nKHRhcmdldCx0YWckd3JhcCh0YXJnZXQpKTtcblx0XHRcdC8vIHZhciBhZGRlZCA9IG11dDphZGRlZE5vZGVzXG5cdFx0XHQvLyBmb3Igbm9kZSBpbiBtdXQ6YWRkZWROb2Rlc1xuXHRcdFx0Ly8gaWYgdGFyZ2V0IGFuZCB0YXJnZXQ6cGFyZW50Tm9kZSAjIGFuZCB0YXJnZXQuQHRhZ1xuXHRcdFx0aWYgKGVsID0gdGFnJHdyYXAodGFyZ2V0KSkge1xuXHRcdFx0XHR0aGlzLnZpZXcoKS5sb2coJ2FkZCB0YXJnZXQ/IScpO1xuXHRcdFx0XHRpZiAobm9kZXMuaW5kZXhPZihlbCkgPCAwKSB7IG5vZGVzLnB1c2goZWwpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBpZiB3ZSBoYXZlIGFkZGVkIGEgbm9kZSBpbnN0ZWFkXG5cdFx0fTtcblx0XHRcblx0XHQvLyBtdXRhdGlvbnMgYXJlIG5vdCByZWdpc3RlcmVkIG9uIG5vZGUtbGV2ZWwgYnV0IG9uIGV4dGVudFxuXHRcdC8vIG5vdCByZWFsbHkgaG93IHRoaXMgc2hvdWxkIGhhcHBlblxuXHRcdFxuXHRcdHZhciBjb21tb24gPSB1dGlsLmNvbW1vbkFuY2VzdG9yKG5vZGVzKTtcblx0XHRcblx0XHR0aGlzLnZpZXcoKS5sb2coJ2NvbW1vbiBjb250YWluZXIgZm9yIG11dGF0aW9ucyBpcycsY29tbW9uLG5vZGVzKTtcblx0XHRcblx0XHR2YXIgZXh0ZW50O1xuXHRcdFxuXHRcdGlmIChub2Rlcy5sZW5ndGggPT0gMSkge1xuXHRcdFx0dGhpcy52aWV3KCkubG9nKCdhIHNpbmdsZSBub2RlIHdhcyBtdXRhdGVkJyxub2Rlc1swXSk7XG5cdFx0XHRub2Rlc1swXS5tdXRhdGVkKHtkZWVwOiBkZWVwLG11dGF0aW9uczogbXV0YXRpb25zfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGNvbGxlY3QgZXh0ZW50cyBmb3IgYWxsIG5vZGVzP1xuXHRcdFx0Ly8gcmF0aGVyIG1ha2UgYSByZWdpb24gZXhwYW5kIFxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdFx0aWYgKGV4dGVudCAmJiBleHRlbnQuY29udGFpbnMobm9kZS5kb20oKSkpIHsgLy8gOm5vZGVzLmluZGV4T2Yobm9kZS5kb20pID49IDBcblx0XHRcdFx0XHR0aGlzLnZpZXcoKS5sb2coJ3RoaXMgbm9kZSBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIGV4dGVudCcsbm9kZS5kb20oKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gbm9kZS5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBub2RlPy5tdXRhdGVkXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZXh0ZW50KSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmb3VuZCBleHRlbnQoISknLGV4dGVudFxuXHRcdFx0XHR0aGlzLnBhdXNlKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy52aWV3KCkubG9nZ2VyKCkuZ3JvdXBFbmQoKTtcblx0XHR0aGlzLnZpZXcoKS5vbm11dGF0aW9ucyh7bm9kZXM6IG5vZGVzLG11dGF0aW9uczogbXV0YXRpb25zLGV4dGVudDogZXh0ZW50fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBPYnNlcnZlcjtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL29ic2VydmVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuLi9yZWdpb24nKS5SZWdpb247XG5cdFxuXHR2YXIgbGFiZWxzID0ge1xuXHRcdFwiVW5leHBlY3RlZCAnVEFHX0VORCdcIjogJ1RhZyBjbG9zZWQgdW5leHBlY3RlZGx5Jyxcblx0XHRcIlVuZXhwZWN0ZWQgJ1RFUk1JTkFUT1InXCI6ICdVbmV4cGVjdGVkIOKPjicsXG5cdFx0XCJVbmV4cGVjdGVkICdQT1NUX0lGJ1wiOiAnTWlzc2luZyBib2R5IGluIDxiPklGPC9iPidcblx0fTtcblx0XG5cdHZhciBydWxlcyA9IFtcblx0XHRbL1VuY2F1Z2h0IEVycm9yOiB0YWcgKFxcdyspIGlzIG5vdCBkZWZpbmVkLyxcInRhZyA8Yj4kMTwvYj4gZG9lcyBub3QgZXhpc3RcIl1cblx0XTtcblx0XG5cdGZ1bmN0aW9uIEhpbnQob3B0cyx2aWV3KXtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHR0aGlzLl9kYXRhID0gb3B0cztcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLl9yZWdpb24gPSBvcHRzLmxvYyA/IChSZWdpb24ubm9ybWFsaXplKG9wdHMubG9jLHZpZXcpKSA6IChudWxsKTtcblx0XHQvLyB0cnkgdG8gZmluZCB0aGUgbm9kZSBpbW1lZGlhdGVseVxuXHRcdHRoaXMuX25vZGUgPSBvcHRzLm5vZGUgfHwgdGhpcy5ub2RlKCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuSGludCA9IEhpbnQ7IC8vIGV4cG9ydCBjbGFzcyBcblx0SGludC5idWlsZCA9IGZ1bmN0aW9uIChvLHZpZXcpe1xuXHRcdHJldHVybiBuZXcgdGhpcyhvLHZpZXcpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRIaW50LnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdEhpbnQucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpbnQucHJvdG90eXBlLnJlZ2lvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVnaW9uOyB9XG5cdEhpbnQucHJvdG90eXBlLnNldFJlZ2lvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZWdpb24gPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaW50LnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuXHRIaW50LnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih2KXsgdGhpcy5fYWN0aXZlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoa2V5KXtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YVtrZXldO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGtleSx2YWwpe1xuXHRcdHRoaXMuX2RhdGFba2V5XSA9IHZhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YS50eXBlIHx8ICdlcnJvcic7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kYXRhLmdyb3VwO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGEucmVmO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9ub2RlIHx8ICh0aGlzLl9ub2RlID0gdGhpcy5fcmVnaW9uICYmIHRoaXMudmlldygpLm5vZGVBdFJlZ2lvbih0aGlzLl9yZWdpb24pKTtcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLnJvdyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnJlZ2lvbigpLnJvdygpO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMucmVnaW9uKCkuY29sKCk7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBsYmw7XG5cdFx0cmV0dXJuIHRoaXMuX2xhYmVsIHx8ICh0aGlzLl9sYWJlbCA9ICh0cnVlKSAmJiAoXG5cdFx0XHRsYmwgPSB0aGlzLl9kYXRhLmxhYmVsIHx8IHRoaXMuX2RhdGEubWVzc2FnZSB8fCAnSGludCcsXG5cdFx0XHRsYmwgPSBsYmwuc3BsaXQoL2Vycm9yIGF0IChcXFtbXFxkXFw6XSpcXF0pXFw6XFxzKi8pLnBvcCgpLFxuXHRcdFx0bGJsID0gbGFiZWxzW2xibF0gfHwgbGJsXG5cdFx0KSk7XG5cdH07XG5cdFxuXHRcblx0SGludC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbm9kZV87XG5cdFx0aWYgKCF0aGlzLl9hY3RpdmUpIHtcblx0XHRcdC8vIG5vZGU/LnNldEF0dHJpYnV0ZSgnaGludCcscmVmKVxuXHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTtcblx0XHRcdChub2RlXyA9IHRoaXMubm9kZSgpKSAmJiBub2RlXy5zZXRIaW50ICAmJiAgbm9kZV8uc2V0SGludCh0aGlzKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGNvbnNvbGUubG9nKCdkZWFjdGl2YXRlIGhpbnQhIScpO1xuXHRcdHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0XHQvLyBjbGVhbnVwXG5cdFx0Ly8gcmVtb3ZlXG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5wcnVuZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnZpZXcoKS5oaW50cygpLnBydW5lKHRoaXMpO1xuXHR9O1xuXHRcblx0Ly8gc2hvdWxkIG1ha2UgdGhpcyBoaW50IHJlYWR5IHRvIGJlIHJlbW92ZWRcblx0SGludC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9ub2RlKSB7XG5cdFx0XHRpZiAodGhpcy5fbm9kZS5oaW50KCkgPT0gdGhpcykgeyB0aGlzLl9ub2RlLnNldEhpbnQobnVsbCkgfTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy52aWV3KCkuaGludHMoKS5yZW0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29uc29sZS5sb2cgJ2RlYWN0aXZhdGUgb24gY2hhbmdlZCEnXG5cdFx0Ly8gQGRlYWN0aXZhdGUgPSB5ZXNcblx0XHR0aGlzLnBydW5lKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5hZGp1c3QgPSBmdW5jdGlvbiAocmVnLGlucyl7XG5cdFx0aWYoaW5zID09PSB1bmRlZmluZWQpIGlucyA9IHRydWU7XG5cdFx0aWYgKHRoaXMucmVnaW9uKCkuaW50ZXJzZWN0cyhyZWcpKSB7XG5cdFx0XHQvLyBkZWFjdGl2YXRlXG5cdFx0XHR0aGlzLnBydW5lKCk7XG5cdFx0XHQvLyBAZGVhY3RpdmF0ZSA9IHllc1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5yZWdpb24oKS5hZGp1c3QocmVnLGlucyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBIaW50cyh2aWV3KXtcblx0XHR0aGlzLl9wcnVuZSA9IFtdO1xuXHRcdHRoaXMuX2FycmF5ID0gW107XG5cdFx0dGhpcy5fbWFwID0ge307XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdH07XG5cdFxuXHRleHBvcnRzLkhpbnRzID0gSGludHM7IC8vIGV4cG9ydCBjbGFzcyBcblx0dmFyIG5yID0gMDtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2FycmF5O1xuXHR9O1xuXHRcblx0SGludHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdHJldHVybiB0aGlzLl9tYXBbcmVmXTtcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9hcnJheSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJ5W2ldLmFjdGl2YXRlKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIHRoaXMgc2hvdWxkIHRha2UgY2FyZSBvZiBkZWFsbG9jYXRpbmcgdGhlIGhpbnQgbm8/XG5cdEhpbnRzLnByb3RvdHlwZS5yZW0gPSBmdW5jdGlvbiAoaGludCl7XG5cdFx0aWYgKGhpbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0aGludCA9IHRoaXMuX2FycmF5LmZpbHRlcihoaW50KTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChoaW50IGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChoaW50KSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMucmVtKGFyeVtpXSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGhpbnQ7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoKHR5cGVvZiBoaW50PT0nc3RyaW5nJ3x8aGludCBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbSh0aGlzLmdldChoaW50KSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5fYXJyYXkuaW5kZXhPZihoaW50KSA+PSAwKSB7XG5cdFx0XHRoaW50LmNsZWFudXAoKTtcblx0XHRcdHRoaXMuX2FycmF5LnNwbGljZSh0aGlzLl9hcnJheS5pbmRleE9mKGhpbnQpLDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGhpbnQ7XG5cdH07XG5cdFxuXHRIaW50cy5wcm90b3R5cGUucHJ1bmUgPSBmdW5jdGlvbiAoaGludCl7XG5cdFx0aWYgKHRoaXMuX3BydW5lLmluZGV4T2YoaGludCkgPCAwKSB7IHRoaXMuX3BydW5lLnB1c2goaGludCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhcnIgPSB0aGlzLl9hcnJheTtcblx0XHR0aGlzLl9hcnJheSA9IFtdO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChhcnIpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFyeVtpXS5kZWFjdGl2YXRlKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCl7XG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYuX2FycmF5Lm1hcChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoc2VsZi5fcHJ1bmUuaW5kZXhPZihpdGVtKSA+PSAwKSB7XG5cdFx0XHRcdGl0ZW0uZGVhY3RpdmF0ZSgpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5yZW0oaXRlbSk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdHNlbGYuX3BydW5lID0gW107XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRcblx0SGludHMucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChjYil7XG5cdFx0cmV0dXJuIHRoaXMuX2FycmF5LmZpbHRlcihjYik7XG5cdH07XG5cdFxuXHRIaW50cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciByZWYgPSBvLnJlZiA9IChcImhpbnRcIiArIChucisrKSk7XG5cdFx0aWYgKCEoKG8gaW5zdGFuY2VvZiBIaW50KSkpIHsgbyA9IEhpbnQuYnVpbGQobyx0aGlzLl92aWV3KSB9O1xuXHRcdHRoaXMuX21hcFtyZWZdID0gbztcblx0XHR0aGlzLl9hcnJheS5wdXNoKG8pO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRyZXR1cm4gSGludHM7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL2hpbnRzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuLi9yZWdpb24nKS5SZWdpb247XG5cdFxuXHRmdW5jdGlvbiBSb3dDb2wocm93LGNvbCxjYXJldCl7XG5cdFx0aWYocm93ID09PSB1bmRlZmluZWQpIHJvdyA9IDA7XG5cdFx0aWYoY29sID09PSB1bmRlZmluZWQpIGNvbCA9IDA7XG5cdFx0aWYoY2FyZXQgPT09IHVuZGVmaW5lZCkgY2FyZXQgPSBudWxsO1xuXHRcdHRoaXMuX3JvdyA9IHJvdztcblx0XHR0aGlzLl9jb2wgPSBjb2w7XG5cdFx0dGhpcy5fY2FyZXQgPSBjYXJldDtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnJvdyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm93OyB9XG5cdFJvd0NvbC5wcm90b3R5cGUuc2V0Um93ID0gZnVuY3Rpb24odil7IHRoaXMuX3JvdyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb2w7IH1cblx0Um93Q29sLnByb3RvdHlwZS5zZXRDb2wgPSBmdW5jdGlvbih2KXsgdGhpcy5fY29sID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0Um93Q29sLnByb3RvdHlwZS5jYXJldCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY2FyZXQ7IH1cblx0Um93Q29sLnByb3RvdHlwZS5zZXRDYXJldCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jYXJldCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY2FyZXQoKS52aWV3KCk7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX2NvbCA9IHRoaXMucmVhbENvbCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocm93LGNvbCl7XG5cdFx0dmFyIGFyeTtcblx0XHRpZiAocm93IGluc3RhbmNlb2YgUm93Q29sKSB7XG5cdFx0XHRjb2wgPSByb3cuY29sKCk7XG5cdFx0XHRyb3cgPSByb3cucm93KCk7XG5cdFx0XHRcblx0XHRcdC8vIHJldHVybiBzZXQocm93LnJvdyxyb3cuY29sKVxuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHJvdyBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0dmFyIGFyeSA9IGl0ZXIkKHV0aWwucm93Y29sKHRoaXMudmlldygpLl9idWZmZXIscm93LnN0YXJ0KCkpKTtyb3cgPSBhcnlbMF07Y29sID0gYXJ5WzFdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGxjID0gdGhpcy52aWV3KCkuX2J1ZmZlci5saW5lY291bnQoKTtcblx0XHRcblx0XHRpZiAocm93ID49IGxjKSB7XG5cdFx0XHRyb3cgPSBsYyAtIDE7XG5cdFx0XHRjb2wgPSAxMDAwO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fcm93ID0gcm93O1xuXHRcdHRoaXMuX2NvbCA9IGNvbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAob2Zmc2V0KXtcblx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdFxuXHRcdHZhciBjb2wgPSB0aGlzLnJlYWxDb2woKSArIG9mZnNldDtcblx0XHR2YXIgbGxlbiA9IHRoaXMubGluZWxlbigpO1xuXHRcdFxuXHRcdHZhciBsbG9jID0gdGhpcy5saW5lbG9jKCk7XG5cdFx0Ly8gZmluZCB0aGUgcmVhbCBvZmZzZXQgaW4gY2hhcmFjdGVycyAobm90IGNvbHVtbnMpXG5cdFx0XG5cdFx0XG5cdFx0Ly8gaWYgb2Zmc2V0IDwgMFxuXHRcdC8vIFx0IyBub3JtYWxpemU/XG5cdFx0Ly8gXHRAY29sID0gTWF0aC5taW4oQGNvbCxsbGVuKVxuXHRcdFxuXHRcdGlmIChjb2wgPCAwKSB7XG5cdFx0XHRpZiAodGhpcy5fcm93ID4gMCkge1xuXHRcdFx0XHR0aGlzLm1vdmVVcCgpO1xuXHRcdFx0XHR0aGlzLl9jb2wgPSB0aGlzLmxpbmVsZW4oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3JvdyA9IDA7XG5cdFx0XHRcdHRoaXMuX2NvbCA9IDA7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSBlbHNlIGlmIChjb2wgPiBsbGVuKSB7XG5cdFx0XHRpZiAodGhpcy5fcm93ID49ICh0aGlzLnZpZXcoKS5fYnVmZmVyLmxpbmVjb3VudCgpIC0gMSkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLm1vdmVEb3duKCk7XG5cdFx0XHR2YXIgcmVzdCA9IE1hdGgubWF4KDAsY29sIC0gbGxlbiAtIDEpO1xuXHRcdFx0dmFyIG1vdmVzID0gdXRpbC5jb2xzRm9yTGluZSh0aGlzLmxpbmVzdHIoKS5zdWJzdHIoMCxyZXN0KSk7XG5cdFx0XHR0aGlzLl9jb2wgPSBtb3Zlcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdGhpcyBzaG91bGQgd29ya1xuXHRcdHRoaXMuX2NvbCA9IHV0aWwuY29sc0ZvckxpbmUodGhpcy5saW5lc3RyKCkuc3Vic3RyKDAsbGxvYyArIG9mZnNldCkpO1xuXHRcdC8vIEBjb2wgKz0gb2Zmc2V0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLm1vdmVVcCA9IGZ1bmN0aW9uIChsZW4pe1xuXHRcdHRoaXMuX3JvdyA9IE1hdGgubWF4KDAsdGhpcy5fcm93IC0gMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24gKGxlbil7XG5cdFx0Y29uc29sZS5sb2coJ21vdmVEb3duJyk7XG5cdFx0dmFyIGxjID0gdGhpcy52aWV3KCkuX2J1ZmZlci5saW5lY291bnQoKTsgLy8gc3BsaXQoJ1xcbicpWzpsZW5ndGhdXG5cdFx0dGhpcy5fcm93ID0gdGhpcy5fcm93ICsgMTtcblx0XHRpZiAodGhpcy5fcm93ID49IGxjKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcycpO1xuXHRcdFx0dGhpcy5zZXRMb2ModGhpcy52aWV3KCkuX2J1ZmZlci5sZW4oKSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gbmV3IFJvd0NvbCh0aGlzLnJvdygpLHRoaXMuY29sKCksdGhpcy5jYXJldCgpKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubGluZWxlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB1dGlsLmNvbHNGb3JMaW5lKHRoaXMubGluZXN0cigpKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubGluZWxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB1dGlsLmNvbFRvTG9jKHRoaXMubGluZXN0cigpLHRoaXMucmVhbENvbCgpKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUucmVhbENvbCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciByYyA9IHV0aWwuY29sVG9WaWV3Q29sKHRoaXMubGluZXN0cigpLHRoaXMuX2NvbCk7XG5cdFx0cmV0dXJuIHJjO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5saW5lc3RyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmlldygpLmxpbmVzdHIodGhpcy5yb3coKSk7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnBlZWtiZWhpbmQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc3RyID0gdGhpcy5saW5lc3RyKCk7XG5cdFx0cmV0dXJuIHN0ci5zdWJzdHIoMCx1dGlsLmNvbFRvTG9jKHN0cix0aGlzLnJlYWxDb2woKSkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5wZWVrYWhlYWQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc3RyID0gdGhpcy5saW5lc3RyKCk7XG5cdFx0cmV0dXJuIHN0ci5zbGljZSh1dGlsLmNvbFRvTG9jKHN0cix0aGlzLnJlYWxDb2woKSkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5zZXRMb2MgPSBmdW5jdGlvbiAobG9jKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBhcnkgPSBpdGVyJCh1dGlsLnJvd2NvbCh0aGlzLnZpZXcoKS5fYnVmZmVyLGxvYykpO3ZhciByb3cgPSBhcnlbMF0sY29sID0gYXJ5WzFdO1xuXHRcdHRoaXMuc2V0KHJvdyxjb2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBzaG91bGQgY2FjaGUoISlcblx0XHR2YXIgbGluZXMgPSB0aGlzLnZpZXcoKS5fYnVmZmVyLmxpbmVzKCk7XG5cdFx0Ly8gdmFyIGxpbmVzID0gdmlldy5idWZmZXIuc3BsaXQoJ1xcbicpXG5cdFx0dmFyIGxvYyA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGxpbmVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbGluZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRsaW5lID0gYXJ5W2ldO1xuXHRcdFx0dmFyIGxuID0gbGluZS5sZW5ndGg7XG5cdFx0XHRpZiAoaSA8IHRoaXMuX3Jvdykge1xuXHRcdFx0XHRsb2MgKz0gbG4gKyAxOyAvLyBpbmNsdWRlIG5ld2xpbmVcblx0XHRcdH0gZWxzZSBpZiAoaSA9PSB0aGlzLl9yb3cpIHtcblx0XHRcdFx0dmFyIHZpZXdjb2wgPSB1dGlsLmNvbFRvVmlld0NvbChsaW5lLHRoaXMuX2NvbCk7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSB1dGlsLmNvbFRvTG9jKGxpbmUsdmlld2NvbCk7XG5cdFx0XHRcdGxvYyArPSBNYXRoLm1pbihsbixvZmZzZXQpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiBsb2M7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnRhYiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHdyb25nIC0gbmVlZCB0byByb3VuZCBpbnN0ZWFkP1xuXHRcdFxuXHRcdHZhciBsZnQgPSB0aGlzLmNvbCgpICUgNDtcblx0XHR0aGlzLnNldENvbCh0aGlzLmNvbCgpICsgKDQgLSBsZnQpKTsgLy8gTWF0aC5mbG9vcihjb2wgLyA0KSAqIDQgKyA0XG5cdFx0Y29uc29sZS5sb2coJ21hcmtlciB0YWInLGxmdCx0aGlzLmNvbCgpLHRoaXMucmVhbENvbCgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUudW50YWIgPSBmdW5jdGlvbiAoKXtcblx0XHRjb25zb2xlLmxvZygndW50YWInLHRoaXMuY29sKCkpO1xuXHRcdHZhciByZXN0ID0gNCAtIHRoaXMuY29sKCkgJSA0O1xuXHRcdHRoaXMuc2V0Q29sKE1hdGguY2VpbCh0aGlzLmNvbCgpIC8gNCkgKiA0IC0gNCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLmFsdGVyID0gZnVuY3Rpb24gKG1vZGUsZGlyKXtcblx0XHR2YXIgJDEsICQyLCAkMywgJDQsICQ1LCAkNjtcblx0XHR2YXIgbm9kZXMgPSB0aGlzLmNhcmV0KCkudmlldygpLm5vZGVzSW5SZWdpb24odGhpcy5sb2MoKSxmYWxzZSk7XG5cdFx0dmFyIG5vZGUgPSBub2Rlc1swXTtcblx0XHR2YXIgbWlkID0gbm9kZSAmJiBub2RlLm5vZGU7XG5cdFx0dmFyIGxmdCA9IG5vZGVzLnByZXYgJiYgbm9kZXMucHJldi5ub2RlO1xuXHRcdHZhciByZ3QgPSBub2Rlcy5uZXh0ICYmIG5vZGVzLm5leHQubm9kZTtcblx0XHR2YXIgcGFydDtcblx0XHRcblx0XHQvLyBsb2cgJ21vdmUnLG9mZnNldCxtb2RlLG5vZGVzXG5cdFx0aWYgKG1vZGUgPT0gSU0uV09SRF9TVEFSVCkge1xuXHRcdFx0dmFyIGVsID0gbWlkIHx8IGxmdDtcblx0XHRcdGlmICgoJDEgPSBsZnQpICYmICQxLm1hdGNoZXMgICYmICAkMS5tYXRjaGVzKHEkKCcuX2ltY2xvc2UnLHRoaXMpKSkge1xuXHRcdFx0XHR0aGlzLnNldExvYyhsZnQucGFyZW50KCkucmVnaW9uKCkuc3RhcnQoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKCgkMiA9IGxmdCkgJiYgJDIubWF0Y2hlcyAgJiYgICQyLm1hdGNoZXMocSQoJy5faW1zdHInLHRoaXMpKSkge1xuXHRcdFx0XHR0aGlzLnNldExvYyhsZnQucmVnaW9uKCkuc3RhcnQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbG9jID0gdGhpcy5sb2MoKTtcblx0XHRcdFx0Ly8gbGV0IGJ1ZiA9IHZpZXcuYnVmZmVyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdwZWVrYmVoaW5kJyxwZWVrYmVoaW5kLGxvYyxzdHJcblx0XHRcdFx0dmFyIHN0ciA9IHRoaXMucGVla2JlaGluZCgpLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG5cdFx0XHRcdGxvYyAtPSBzdHIubWF0Y2goL14oW1xcc1xcdFxcLl0qLis/fCkoXFxifCQpLylbMV0ubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnNldExvYyhsb2MpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKG1vZGUgPT0gSU0uV09SRF9FTkQpIHtcblx0XHRcdGVsID0gbWlkIHx8IHJndDtcblx0XHRcdGlmICgoJDMgPSByZ3QpICYmICQzLm1hdGNoZXMgICYmICAkMy5tYXRjaGVzKHEkKCcuX2ltb3BlbicsdGhpcykpKSB7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKHJndC5wYXJlbnQoKS5yZWdpb24oKS5lbmQoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKCgkNCA9IHJndCkgJiYgJDQubWF0Y2hlcyAgJiYgICQ0Lm1hdGNoZXMocSQoJy5faW1zdHInLHRoaXMpKSkge1xuXHRcdFx0XHR0aGlzLnNldExvYyhyZ3QucmVnaW9uKCkuZW5kKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGxvYzEgPSB0aGlzLmxvYygpO1xuXHRcdFx0XHQvLyBsZXQgYnVmID0gdmlldy5idWZmZXJcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncGVla2FoZWFkJyxwZWVrYWhlYWQsbG9jXG5cdFx0XHRcdGxvYzEgKz0gdGhpcy5wZWVrYWhlYWQoKS5tYXRjaCgvXihbXFxzXFwuXSouKz98KShcXGJ8JCkvKVsxXS5sZW5ndGg7XG5cdFx0XHRcdC8vIGxvYysrIHVudGlsIGJ1Zltsb2NdLm1hdGNoKC9bXFxuXFxdLylcblx0XHRcdFx0dGhpcy5zZXRMb2MobG9jMSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobW9kZSA9PSBJTS5MSU5FX0VORCkge1xuXHRcdFx0dGhpcy5zZXQodGhpcy5yb3coKSwxMDAwKTtcblx0XHR9IGVsc2UgaWYgKG1vZGUgPT0gSU0uTElORV9TVEFSVCkge1xuXHRcdFx0Ly8gRklYTUUgdGFicy1mb3Itc3BhY2VzXG5cdFx0XHR2YXIgdGFicyA9IHRoaXMubGluZXN0cigpLm1hdGNoKC9eXFx0Ki8pWzBdLmxlbmd0aDtcblx0XHRcdHZhciBuZXdjb2wgPSB0YWJzICogdGhpcy52aWV3KCkudGFiU2l6ZSgpO1xuXHRcdFx0dGhpcy5zZXRDb2wodGhpcy5jb2woKSA+IG5ld2NvbCA/IChuZXdjb2wpIDogKDApKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGRpciA8IDAgJiYgKCQ1ID0gbGZ0KSAmJiAkNS5tYXRjaGVzICAmJiAgJDUubWF0Y2hlcygnLl9pbXRhYicpKSB7XG5cdFx0XHRcdC8vIGhlYWQuY29sID0gaGVhZC5jb2wgLSA0XG5cdFx0XHRcdC8vIGNhcmV0LnZpZXcubG9nICdyaWdodCBpcyB0YWInLGxmdC5yZWdpb25cblx0XHRcdFx0dGhpcy5zZXRMb2MobGZ0LnJlZ2lvbigpLnN0YXJ0KCkpO1xuXHRcdFx0XHQvLyBoZWFkLnVudGFiXG5cdFx0XHR9IGVsc2UgaWYgKGRpciA+IDAgJiYgKCQ2ID0gcmd0KSAmJiAkNi5tYXRjaGVzICAmJiAgJDYubWF0Y2hlcygnLl9pbXRhYicpKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyB1c2UgdGFiIGluc3RlYWRcblx0XHRcdFx0dGhpcy50YWIoKTtcblx0XHRcdFx0Ly8gaGVhZC5jb2wgPSBoZWFkLmNvbCArIDRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIC4uLlxuXHRcdFx0XHR0aGlzLm1vdmUoZGlyKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWNhcmV0aGVhZCcpO1xuXHRcblx0Ly8gc2hvdWxkIG1vdmUgaW50byBNYXJrZXIgKGxpa2UgQXRvbSlcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWNhcmV0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlZ2lvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVnaW9uOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZWdpb24gPSBmdW5jdGlvbih2KXsgdGhpcy5fcmVnaW9uID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxpbmVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9saW5lczsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TGluZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fbGluZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJhbmdlcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmFuZ2VzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSYW5nZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fcmFuZ2VzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX21vZGUgPSB7d2F0Y2g6ICdtb2RlRGlkU2V0JyxuYW1lOiAnbW9kZSd9O1xuXHRcdHRhZy5wcm90b3R5cGUubW9kZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbW9kZTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLm1vZGUoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9tb2RlID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMubW9kZURpZFNldCAmJiB0aGlzLm1vZGVEaWRTZXQodixhLHRoaXMuX19tb2RlKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19jb2wgPSB7J2RlZmF1bHQnOiAwLHdhdGNoOiAnZGlydHknLG5hbWU6ICdjb2wnfTtcblx0XHR0YWcucHJvdG90eXBlLmNvbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY29sOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb2wgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5jb2woKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9jb2wgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5kaXJ0eSAmJiB0aGlzLmRpcnR5KHYsYSx0aGlzLl9fY29sKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGFnLnByb3RvdHlwZS5fY29sID0gMDsgLy8gdGhlIHJlYWwgY29sdW1uIG9mIHRoZSBjYXJldFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19yb3cgPSB7J2RlZmF1bHQnOiAwLHdhdGNoOiAnZGlydHknLG5hbWU6ICdyb3cnfTtcblx0XHR0YWcucHJvdG90eXBlLnJvdyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm93OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSb3cgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5yb3coKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9yb3cgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5kaXJ0eSAmJiB0aGlzLmRpcnR5KHYsYSx0aGlzLl9fcm93KSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGFnLnByb3RvdHlwZS5fcm93ID0gMDtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlucHV0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9pbnB1dDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbih2KXsgdGhpcy5faW5wdXQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRhaWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RhaWw7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFRhaWwgPSBmdW5jdGlvbih2KXsgdGhpcy5fdGFpbCA9IHY7IHJldHVybiB0aGlzOyB9OyAvLyByb3djb2xcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2hlYWQ7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhlYWQgPSBmdW5jdGlvbih2KXsgdGhpcy5faGVhZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGFzaDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGFzaCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oYXNoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAobGZ0LHJndCl7XG5cdFx0XHR2YXIgYXJ5O1xuXHRcdFx0aWYobGZ0ID09PSB1bmRlZmluZWQpIGxmdCA9IDA7XG5cdFx0XHRpZihyZ3QgPT09IHVuZGVmaW5lZCkgcmd0ID0gMDtcblx0XHRcdHRoaXMubG9nKCdpbWNhcmV0IGV4cGFuZCcsbGZ0LHJndCk7XG5cdFx0XHR0aGlzLmRlY29sbGFwc2UoKTtcblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLmVuZHMoKSk7dmFyIGEgPSBhcnlbMF0sYiA9IGFyeVsxXTtcblx0XHRcdGEubW92ZShsZnQpO1xuXHRcdFx0Yi5tb3ZlKHJndCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuXHRcdFx0XHRyZXR1cm4gW3RoaXMuaGVhZCgpLnJvdygpLHRoaXMuaGVhZCgpLmNvbCgpXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBbdGhpcy5oZWFkKCkucm93KCksdGhpcy5oZWFkKCkuY29sKCksdGhpcy50YWlsKCkucm93KCksdGhpcy50YWlsKCkuY29sKCldO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gJ1snICsgdGhpcy50b0FycmF5KCkuam9pbignLCcpICsgJ10nO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmICh2YWwgaW5zdGFuY2VvZiBJTS5UeXBlcy5Ub2spIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KHZhbC5yZWdpb24oKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsIGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHRcdHJldHVybiAodGhpcy5zZXRSZWdpb24odmFsKSx2YWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdHRoaXMuaGVhZCgpLnNldFJvdyh2YWxbMF0pO1xuXHRcdFx0XHR0aGlzLmhlYWQoKS5zZXRDb2wodmFsWzFdKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh2YWwubGVuZ3RoID09IDQpIHtcblx0XHRcdFx0XHR0aGlzLmRlY29sbGFwc2UoKTtcblx0XHRcdFx0XHR0aGlzLnRhaWwoKS5zZXRSb3codmFsWzJdKTtcblx0XHRcdFx0XHR0aGlzLnRhaWwoKS5zZXRDb2wodmFsWzNdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNldFRhaWwodGhpcy5oZWFkKCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5leHBhbmRUb0xpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgYXJ5O1xuXHRcdFx0dGhpcy5zZWxlY3RhYmxlKCk7XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5lbmRzKCkpO3ZhciBhID0gYXJ5WzBdLGIgPSBhcnlbMV07XG5cdFx0XHRhLnNldENvbCgwKTtcblx0XHRcdGIuc2V0Q29sKDEwMDApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlydHkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmRlY29sbGFwc2UoKTtcblx0XHRcdHRoaXMudGFpbCgpLnNldExvYygwKTtcblx0XHRcdHRoaXMuaGVhZCgpLnNldExvYyh0aGlzLnZpZXcoKS5fYnVmZmVyLmxlbigpKTsgLy8gOmxlbmd0aFxuXHRcdFx0dGhpcy5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNlbGVjdGFibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlY29sbGFwc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB2Xztcblx0XHRcdGlmICh0aGlzLnRhaWwoKSA9PSB0aGlzLmhlYWQoKSkgeyAodGhpcy5zZXRUYWlsKHZfID0gdGhpcy5oZWFkKCkuY2xvbmUoKSksdl8pIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29sbGFwc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuc2V0VGFpbCh0aGlzLmhlYWQoKSk7XG5cdFx0XHR0aGlzLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29sbGFwc2VUb1N0YXJ0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5pc1JldmVyc2VkKCkpIHtcblx0XHRcdFx0dGhpcy5zZXRUYWlsKHRoaXMuaGVhZCgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0SGVhZCh0aGlzLnRhaWwoKSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9yaWVudGF0aW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1JldmVyc2VkKCkgPyAoJ3JldmVyc2VkJykgOiAoJ25vcm1hbCcpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0NvbGxhcHNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudGFpbCgpID09IHRoaXMuaGVhZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc1JldmVyc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5oZWFkKCkucm93KCkgPCB0aGlzLnRhaWwoKS5yb3coKSB8fCAodGhpcy50YWlsKCkucm93KCkgPT0gdGhpcy5oZWFkKCkucm93KCkgJiYgdGhpcy5oZWFkKCkuY29sKCkgPCB0aGlzLnRhaWwoKS5jb2woKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHN0ciA9IHRoaXMuaGVhZCgpLmxpbmVzdHIoKTtcblx0XHRcdHZhciBpbmQgPSBzdHIubWF0Y2goL14oXFx0KikvKVswXTtcblx0XHRcdHJldHVybiBpbmQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBlZWtiZWhpbmQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdHZhciBzdHIgPSB0aGlzLmVuZHMoKVswXS5wZWVrYmVoaW5kKCk7XG5cdFx0XHRpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7IHJldHVybiBzdHIubWF0Y2godmFsKSB9O1xuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChvZmZzZXQsbW9kZSl7XG5cdFx0XHRpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkgb2Zmc2V0ID0gMTtcblx0XHRcdGlmKG1vZGUgPT09IHVuZGVmaW5lZCkgbW9kZSA9IDA7XG5cdFx0XHR0aGlzLmhlYWQoKS5hbHRlcihtb2RlLG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gd2hhdCBpZiB3ZSBcblx0XHR0YWcucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24gKGxlbil7XG5cdFx0XHRpZihsZW4gPT09IHVuZGVmaW5lZCkgbGVuID0gMTtcblx0XHRcdHRoaXMuaGVhZCgpLm1vdmVEb3duKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tb3ZlVXAgPSBmdW5jdGlvbiAobGVuKXtcblx0XHRcdGlmKGxlbiA9PT0gdW5kZWZpbmVkKSBsZW4gPSAxO1xuXHRcdFx0dGhpcy5oZWFkKCkubW92ZVVwKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lbmRzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1JldmVyc2VkKCkgPyAoW3RoaXMuaGVhZCgpLHRoaXMudGFpbCgpXSkgOiAoW3RoaXMudGFpbCgpLHRoaXMuaGVhZCgpXSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnJlZ2lvbigpLnRleHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBnZXQgdGhlIGFjdHVhbCByZWdpb24gYmFzZWQgb24gaGVhZCBhbmQgdGFpbFxuXHRcdFx0Ly8gZ2V0dGluZyB0aGUgY29kZSBtaWdodCBiZSBleHBlbnNpdmUgaWYgZG9uZVxuXHRcdFx0Ly8gdG9vIG1hbnkgdGltZXMgLS0gYnV0IGVhc3kgdG8gY2FjaGVcblx0XHRcdC8vIHNlbmQgdGhpcyB0byB1dGlsIGluc3RlYWRcblx0XHRcdHZhciBhcnk7XG5cdFx0XHR2YXIgY29kZSA9IHRoaXMudmlldygpLmNvZGUoKTtcblx0XHRcdHZhciBsaW5lcyA9IGNvZGUuc3BsaXQoJ1xcbicpO1xuXHRcdFx0dmFyIGFyeSA9IGl0ZXIkKHRoaXMuZW5kcygpKTt2YXIgYSA9IGFyeVswXSxiID0gYXJ5WzFdO1xuXHRcdFx0XG5cdFx0XHR2YXIgc3RhcnQgPSAwO1xuXHRcdFx0dmFyIGVuZCA9IDA7XG5cdFx0XHR2YXIgbG4gPSAwO1xuXHRcdFx0XG5cdFx0XHR2YXIgYXIgPSBhLnJvdygpLGFjID0gYS5jb2woKSxiciA9IGIucm93KCksYmMgPSBiLmNvbCgpO1xuXHRcdFx0dmFyIGNoYXIkO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaXRlbXMgPSBpdGVyJChsaW5lcyksIGxlbiA9IGl0ZW1zLmxlbmd0aCwgbGluZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGxpbmUgPSBpdGVtc1tpXTtcblx0XHRcdFx0bG4gPSBsaW5lLmxlbmd0aDtcblx0XHRcdFx0aWYgKGkgPCBhcikge1xuXHRcdFx0XHRcdHN0YXJ0ICs9IGxuICsgMTsgLy8gaW5jbHVkZSBuZXdsaW5lXG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA9PSBhcikge1xuXHRcdFx0XHRcdHZhciBvZmZzZXQgPSB1dGlsLmNvbFRvTG9jKGxpbmUsYWMpO1xuXHRcdFx0XHRcdHN0YXJ0ICs9IE1hdGgubWluKGxuLG9mZnNldCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaSA8IGJyKSB7XG5cdFx0XHRcdFx0ZW5kICs9IGxuICsgMTsgLy8gaW5jbHVkZSBuZXdsaW5lXG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA9PSBicikge1xuXHRcdFx0XHRcdG9mZnNldCA9IHV0aWwuY29sVG9Mb2MobGluZSxiYyk7XG5cdFx0XHRcdFx0ZW5kICs9IE1hdGgubWluKGxuLG9mZnNldCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2lvbihzdGFydCxlbmQsdGhpcy52aWV3KCkucm9vdCgpLHRoaXMudmlldygpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmVnaW9uID0gZnVuY3Rpb24gKHJlZyl7XG5cdFx0XHR2YXIgYnVmID0gdGhpcy52aWV3KCkuY29kZSgpO1xuXHRcdFx0dmFyIGEgPSB1dGlsLnJvd2NvbChidWYscmVnLmEoKSk7XG5cdFx0XHR2YXIgYiA9IHV0aWwucm93Y29sKGJ1ZixyZWcuYigpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zZXRIZWFkKG5ldyBSb3dDb2woYlswXSxiWzFdLHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlZy5zaXplKCkgPT0gMCkge1xuXHRcdFx0XHR0aGlzLnNldFRhaWwodGhpcy5oZWFkKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRUYWlsKG5ldyBSb3dDb2woYVswXSxhWzFdLHRoaXMpKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uIChyZWcpe1xuXHRcdFx0aWYocmVnID09PSB1bmRlZmluZWQpIHJlZyA9IHRoaXMucmVnaW9uKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkubm9kZXNJblJlZ2lvbihyZWcsdGhpcy5pc0NvbGxhcHNlZCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCByYXRoZXIgbW92ZSB0aGlzIHRvIHJlZ2lvbiBpdHNlbGZcblx0XHR0YWcucHJvdG90eXBlLnRhcmdldCA9IGZ1bmN0aW9uIChyZWcpe1xuXHRcdFx0aWYocmVnID09PSB1bmRlZmluZWQpIHJlZyA9IHRoaXMucmVnaW9uKCk7XG5cdFx0XHR2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKHJlZyk7XG5cdFx0XHRpZiAobm9kZXMubGVuZ3RoID4gMikge1xuXHRcdFx0XHRyZXR1cm4gdXRpbC5jb21tb25BbmNlc3Rvcihub2Rlcy5tYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbi5ub2RlOyB9KSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIG5vZGVzWzBdLm5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh0ZXh0LGVkaXQpe1xuXHRcdFx0XG5cdFx0XHR2YXIgc3ViID0gJyc7XG5cdFx0XHR0aGlzLnZpZXcoKS5oaXN0b3J5KCkubWFyaygnYWN0aW9uJyk7XG5cdFx0XHRcblx0XHRcdGlmICghKHRoaXMuaXNDb2xsYXBzZWQoKSkpIHtcblx0XHRcdFx0dmFyIHJlZyA9IHRoaXMucmVnaW9uKCk7XG5cdFx0XHRcdHN1YiA9IHJlZy50ZXh0KCk7XG5cdFx0XHRcdHRoaXMudmlldygpLmVyYXNlKHJlZyk7XG5cdFx0XHRcdHRoaXMuY29sbGFwc2VUb1N0YXJ0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbW92ZSA9IDA7XG5cdFx0XHR2YXIgc2VsO1xuXHRcdFx0XG5cdFx0XHQvLyBuZWVkIGEgZGlmZmVyZW50IHN5bnRheCBmb3IgJDAgLS0gY2FuIGJlIGluIHJlZ3VsYXIgcGFzdGVkIGNvZGVcblx0XHRcdC8vIHNob3VsZCBoYXZlIGEgc2VwYXJhdGUgY29tbWFuZCBmb3IgaW5zZXJ0U25pcHBldCBwcm9iYWJseS5cblx0XHRcdGlmICh0ZXh0LmluZGV4T2YoJyQwJykgPj0gMCkge1xuXHRcdFx0XHRzZWwgPSB0aGlzLnJlZ2lvbigpLmNsb25lKDAsc3ViLmxlbmd0aCkubW92ZSh0ZXh0LmluZGV4T2YoJyQwJykpO1xuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCckMCcsc3ViKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGVkaXQgfHwgKGVkaXQgPSB7c2l6ZTogdGV4dC5sZW5ndGh9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5oZWFkKCkubm9ybWFsaXplKCk7XG5cdFx0XHR2YXIgcmVzID0gdGhpcy52aWV3KCkuaW5zZXJ0KHRoaXMucmVnaW9uKCkuc3RhcnQoKSx0ZXh0LGVkaXQpO1xuXHRcdFx0dGhpcy52aWV3KCkubG9nKCdpbnNlcnRlZCAtLSBub3cgbW92ZScsZWRpdC5zaXplKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlbCkge1xuXHRcdFx0XHR0aGlzLnNldFJlZ2lvbihzZWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbW92ZSBsb2NhdGlvbnNcblx0XHRcdFx0dGhpcy5oZWFkKCkuc2V0TG9jKHRoaXMuaGVhZCgpLmxvYygpICsgZWRpdC5zaXplKTtcblx0XHRcdFx0Ly8gaGVhZC5tb3ZlKGVkaXQ6c2l6ZSlcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuZGlydHkoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24gKG1vZGUpe1xuXHRcdFx0dGhpcy52aWV3KCkuaGlzdG9yeSgpLm1hcmsoJ2FjdGlvbicpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdpc0NvbGxhcHNlZCcsbW9kZSk7XG5cdFx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0XHR0aGlzLmhlYWQoKS5hbHRlcihtb2RlLC0xKTsgLy8gXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBkaXJ0eVxuXHRcdFx0XHQvLyByZXR1cm4gZXJhc2UgIyBjYWxsIGFnYWluIG5vd1xuXHRcdFx0fTtcblx0XHRcdGNvbnNvbGUubG9nKCdlcmFzaW5nIHJlZ2lvbicsdGhpcy5yZWdpb24oKSk7XG5cdFx0XHR0aGlzLnZpZXcoKS5lcmFzZSh0aGlzLnJlZ2lvbigpKTtcblx0XHRcdC8vIGxvZyAnbm93IGNvbGxhcHNlIHJlZ2lvbiB0byBzdGFydCcscmVnaW9uXG5cdFx0XHR0aGlzLmNvbGxhcHNlVG9TdGFydCgpO1xuXHRcdFx0Ly8gbG9nIHJlZ2lvblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCh0aGlzLnJlZygpKTtcblx0XHRcdHRoaXMuc2V0UmVnaW9uKHRoaXMucmVnKCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuZWRpdChcblx0XHRcdFx0e3RleHQ6ICcnLFxuXHRcdFx0XHR0YXJnZXQ6IHRhcmdldCxcblx0XHRcdFx0cmVnaW9uOiB0aGlzLnJlZygpLFxuXHRcdFx0XHRjYXJldDogdGhpcy5yZWcoKS5jbG9uZSgpLmNvbGxhcHNlKGZhbHNlKX1cblx0XHRcdCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgJDEsICQyO1xuXHRcdFx0dGhpcy5fdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblx0XHRcdC8vIHZhciBoYXNoID0gdG9BcnJheS5qb2luKFwiXCIpXG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9oYXNoICE9IHRoaXMudG9IYXNoKCkpIHtcblx0XHRcdFx0Ly8gdGhlIHJlYWxDb2wgdmFsdWVzIGNvdWxkIGhhdmUgY2hhbmdlZCB0aG91Z2g/XG5cdFx0XHRcdHRoaXMudmlldygpLmhpc3RvcnkoKS5vbmNhcmV0KHRoaXMuX2hhc2gsdGhpcy50b0hhc2goKSx0aGlzKTtcblx0XHRcdFx0dGhpcy5faGFzaCA9IHRoaXMudG9IYXNoKCk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdjYXJldCBoYXMgYWN0dWFsbHkgY2hhbmdlZCcsQGhhc2hcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciByZXYgPSB0aGlzLmlzUmV2ZXJzZWQoKTtcblx0XHRcdHZhciBhID0gdGhpcy50YWlsKCk7XG5cdFx0XHR2YXIgYiA9IHRoaXMuaGVhZCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAocmV2KSB7ICQxID0gYiwkMiA9IGEsYSA9ICQxLGIgPSAkMiB9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbGMgPSBiLnJvdygpIC0gYS5yb3coKTtcblx0XHRcdHZhciByb3cgPSBhLnJvdygpO1xuXHRcdFx0XG5cdFx0XHR2YXIgYWMgPSBhLnJlYWxDb2woKTsgLy8gTWF0aC5taW4oIGEuY29sLCB1dGlsLmNvbHNGb3JMaW5lKHZpZXcubGluZXN0cihhLnJvdykgKSApXG5cdFx0XHR2YXIgYmMgPSBiLnJlYWxDb2woKTsgLy8gTWF0aC5taW4oIGIuY29sLCB1dGlsLmNvbHNGb3JMaW5lKHZpZXcubGluZXN0cihiLnJvdykgKSApXG5cdFx0XHR2YXIgaGMsdGM7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzUmV2ZXJzZWQoKSkge1xuXHRcdFx0XHRoYyA9IGFjO1xuXHRcdFx0XHR0YyA9IGJjO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGMgPSBiYztcblx0XHRcdFx0dGMgPSBhYztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGxvZyAnZGlydHknLHJlZ2lvbixhLnJvdyxhLmNvbCxiLnJvdyxiLmNvbCxoYyx0YyxoZWFkLHRhaWwscmV2XG5cdFx0XHRcblx0XHRcdHRoaXMuY3NzKHt0cmFuc2Zvcm06IChcInRyYW5zbGF0ZSgwcHgsXCIgKyAoYS5yb3coKSAqIDEwMCkgKyBcIiUpXCIpfSk7XG5cdFx0XHQvLyBjb252ZXJ0IHRoZSByb3cgYW5kIGNvbHVtbiB0byBhIHJlZ2lvbiAoc2hvdWxkIGdvIGJvdGggd2F5cylcblx0XHRcdHRoaXMuX2NhcmV0LmNzcyh7dHJhbnNmb3JtOiAoXCJ0cmFuc2xhdGUoXCIgKyBoYyArIFwiY2gsXCIgKyAoKHRoaXMuaGVhZCgpLnJvdygpIC0gcm93KSAqIDEwMCkgKyBcIiUpXCIpfSk7XG5cdFx0XHR0aGlzLl9zdGFydC5jc3Moe21hcmdpbkxlZnQ6IChcIlwiICsgYWMgKyBcImNoXCIpLHdpZHRoOiBcImF1dG9cIn0pO1xuXHRcdFx0dGhpcy5fZW5kLmNzcyh7d2lkdGg6IChcIlwiICsgYmMgKyBcImNoXCIpfSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcblx0XHRcdFx0dGhpcy5zZXRNb2RlKCdjb2xsYXBzZWQnKTtcblx0XHRcdH0gZWxzZSBpZiAobGMgPT0gMCkge1xuXHRcdFx0XHR0aGlzLnNldE1vZGUoJ3NpbmdsZScpO1xuXHRcdFx0XHR0aGlzLl9zdGFydC5jc3Moe3dpZHRoOiAoYmMgLSBhYykgKyBcImNoXCJ9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX21pZC5zZXRUZXh0KGxjID4gMSA/ICgoJ1xcbicpLnJlcGVhdChsYyAtIDEpKSA6ICgnJykpO1xuXHRcdFx0XHR0aGlzLnNldE1vZGUoJ211bHRpJyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGVsYXBzZWQgPSAobmV3IERhdGUoKSAtIHRoaXMuX3RpbWVzdGFtcCk7XG5cdFx0XHR2YXIgZmxpcCA9IE1hdGgucm91bmQoZWxhcHNlZCAvIDUwMCkgJSAyO1xuXHRcdFx0XG5cdFx0XHRpZiAoZmxpcCAhPSB0aGlzLl9mbGlwKSB7XG5cdFx0XHRcdHRoaXMuX2NhcmV0LmZsYWcoJ2JsaW5rJyxmbGlwKTtcblx0XHRcdFx0dGhpcy5fZmxpcCA9IGZsaXA7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB2XywgdDA7XG5cdFx0XHR0aGlzLnNldFRhaWwoKHRoaXMuc2V0SGVhZCh2XyA9IG5ldyBSb3dDb2woMCwwLHRoaXMpKSx2XykpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdC8vIDxpbWNhcHRvckBpbnB1dCB2YWx1ZT0neCc+XG5cdFx0XHRcdCh0aGlzLiRhID0gdGhpcy4kYSB8fCB0YWckLiRzcGFuKCkuZmxhZygnZGltJykpLnNldFRleHQoJ3gnKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMuX2NhcmV0ID0gdGhpcy5fY2FyZXQgfHwgdGFnJC4kaW1jYXJldGhlYWQoKS5zZXRSZWYoJ2NhcmV0Jyx0aGlzKSkuZW5kKCksXG5cdFx0XHRcdCh0MCA9IHRoaXMuX2xpbmVzPXRoaXMuX2xpbmVzIHx8IHRhZyQuJGRpdigpLnNldFJlZignbGluZXMnLHRoaXMpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodGhpcy5fc3RhcnQgPSB0aGlzLl9zdGFydCB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ3N0YXJ0Jyx0aGlzKSkuc2V0VGV4dChcIiBcIikuZW5kKCksXG5cdFx0XHRcdFx0KHRoaXMuX21pZCA9IHRoaXMuX21pZCB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ21pZCcsdGhpcykpLmVuZCgpLFxuXHRcdFx0XHRcdCh0aGlzLl9lbmQgPSB0aGlzLl9lbmQgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdlbmQnLHRoaXMpKS5zZXRUZXh0KFwiIFwiKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRdLDIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuaGVhZCgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1vZGVEaWRTZXQgPSBmdW5jdGlvbiAobmV3JCxvbGQpe1xuXHRcdFx0dGhpcy51bmZsYWcob2xkKTtcblx0XHRcdHJldHVybiB0aGlzLmZsYWcobmV3JCk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL2NhcmV0LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc2NyaW1ibGEtb3ZlcmxheScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QoKSksMykuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3NjcmltYmxhLW92ZXJsYXlzJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHR5cGUsZGF0YSl7XG5cdFx0XHRpZihkYXRhID09PSB1bmRlZmluZWQpIGRhdGEgPSB7fTtcblx0XHRcdGNvbnNvbGUubG9nKCdhZGQgb3ZlcmxheSEnKTtcblx0XHRcdHRoaXMuYXBwZW5kKHRhZyQuJHNjcmltYmxhX292ZXJsYXkoKS5zZXRWaWV3KHRoaXMudmlldygpKS5zZXRPYmplY3QoZGF0YSkuZW5kKCkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcG9zaXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvdmlld3Mvb3ZlcmxheXMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW1lZGl0b3InLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihcblx0XHRcdFx0KHRoaXMuX3ZpZXcgPSB0aGlzLl92aWV3IHx8IHRhZyQuJGltdmlldygpLnNldFJlZigndmlldycsdGhpcykpLmVuZCgpXG5cdFx0XHQsMikuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy52aWV3KCkuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5kZWFjdGl2YXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb2RlLG9wdHMpe1xuXHRcdFx0dGhpcy52aWV3KCkubG9hZChjb2RlLG9wdHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gSU0uRlM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY29tbWFuZCA9IGZ1bmN0aW9uIChlLGMpe1xuXHRcdFx0aWYgKHRoaXNbYy5jb21tYW5kXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHRoaXNbYy5jb21tYW5kXS5jYWxsKHRoaXMsYy5hcmdzIHx8IFtdKTtcblx0XHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uc2F2ZXNlc3Npb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdGNvbnNvbGUubG9nKFwiaW1lZGl0b3Iuc2F2ZVNlc3Npb25cIix0aGlzKTtcblx0XHRcdHZhciBwYXRoID0gdGhpcy52aWV3KCkuZmlsZW5hbWUoKS5yZXBsYWNlKC9cXC5pbWJhJC8sJy5pbWJhc2Vzc2lvbicpO1xuXHRcdFx0dmFyIGJvZHkgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnZpZXcoKS5oaXN0b3J5KCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gSU0uRlMuc2F2ZShwYXRoLGJvZHksZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBjb25zb2xlLmxvZygncmV0dXJuZWQgZnJvbSBzYXZpbmchJyxwYXRoKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvZWRpdG9yLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHQvKlxuXHRCcmlkZ2UgZm9yIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgSW1iYSBjb21waWxlciBpbiBhIHdvcmtlclxuXHQqL1xuXHRcblx0ZnVuY3Rpb24gSW1iYWNXb3JrZXIocGF0aCl7XG5cdFx0aWYocGF0aCA9PT0gdW5kZWZpbmVkKSBwYXRoID0gXCIvdmVuZG9yL2ltYmEvaW1iYWMud29ya2VyLm1pbi5qc1wiO1xuXHRcdHRoaXMuX3BhdGggPSBwYXRoO1xuXHRcdHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkltYmFjV29ya2VyID0gSW1iYWNXb3JrZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0SW1iYWNXb3JrZXIucHJvdG90eXBlLndvcmtlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcywgcHJvY2VzczE7XG5cdFx0cmV0dXJuIHNlbGYuX3dvcmtlciB8fCAoc2VsZi5fd29ya2VyID0gKHRydWUpICYmIChcblx0XHRcdHByb2Nlc3MxID0gbmV3IFdvcmtlcihzZWxmLl9wYXRoKSxcblx0XHRcdHByb2Nlc3MxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHNlbGYub25tZXNzYWdlKGUpOyB9LFxuXHRcdFx0cHJvY2VzczFcblx0XHQpKTtcblx0fTtcblx0XG5cdEltYmFjV29ya2VyLnByb3RvdHlwZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIGZuO1xuXHRcdGlmIChmbiA9IHRoaXMuX2NhbGxiYWNrcy5zaGlmdCgpKSB7XG5cdFx0XHRyZXR1cm4gZm4oZS5kYXRhLGUpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRJbWJhY1dvcmtlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChjb2RlLG8sY2Ipe1xuXHRcdHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNiKTtcblx0XHR0aGlzLndvcmtlcigpLnBvc3RNZXNzYWdlKFsnY29tcGlsZScsY29kZSxvXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhY1dvcmtlci5wcm90b3R5cGUuYW5hbHl6ZSA9IGZ1bmN0aW9uIChjb2RlLG8sY2Ipe1xuXHRcdHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNiKTtcblx0XHR0aGlzLndvcmtlcigpLnBvc3RNZXNzYWdlKFsnYW5hbHl6ZScsY29kZSxvXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBJbWJhY1dvcmtlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvd29ya2VyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5cdHJlcXVpcmUoXCIuL3Rva2VuXCIpO1xuXHRyZXF1aXJlKFwiLi9ibG9ja1wiKTtcblx0cmVxdWlyZShcIi4vcm9vdFwiKTtcblx0cmVxdWlyZShcIi4vbGl0ZXJhbHNcIik7XG5cdHJlcXVpcmUoXCIuL29wZXJhdG9yc1wiKTtcblx0cmVxdWlyZShcIi4vc2VsZWN0b3JcIik7XG5cdHJlcXVpcmUoXCIuL3doaXRlc3BhY2VcIik7XG5cdHJldHVybiByZXF1aXJlKFwiLi9hbm5vdGF0aW9uc1wiKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL2luZGV4LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBIaWdobGlnaHRlciA9IHJlcXVpcmUoJy4uL2NvcmUvaGlnaGxpZ2h0ZXInKS5IaWdobGlnaHRlcjtcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblx0XG5cdC8vIGRhbmdlcm91cyB0byBleHRlbmQgYWxsIGh0bWxlbGVtZW50IHRhZ3MgZ2xvYmFsbHlcblx0dGFnJC5leHRlbmRUYWcoJ2h0bWxlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIChuYW1lLGRhdGEpe1xuXHRcdFx0Ly8gbG9nIFwiYnViYmxlIGV2ZW50XCIsbmFtZSxkYXRhXG5cdFx0XHR2YXIgZXYgPSBJbWJhLkV2ZW50cy50cmlnZ2VyKG5hbWUsdGhpcyx7ZGF0YTogZGF0YSxidWJibGU6IHRydWV9KTtcblx0XHRcdHJldHVybiBldjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAobmFtZSx0aW1lLGJsayl7XG5cdFx0XHR0aGlzLl90aW1lb3V0cyB8fCAodGhpcy5fdGltZW91dHMgPSB7fSk7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dHNbbmFtZV0pO1xuXHRcdFx0aWYgKHRpbWUgIT0gLTEpIHsgdGhpcy5fdGltZW91dHNbbmFtZV0gPSBzZXRUaW1lb3V0KGJsayx0aW1lKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAoZWwpe1xuXHRcdFx0aWYgKGVsIGluc3RhbmNlb2YgSU1GcmFnbWVudCkge1xuXHRcdFx0XHRlbCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsLmRvbSgpLmNoaWxkTm9kZXMpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGVsLnJldmVyc2UoKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuc2V0TmV4dChhcnlbaV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBjdXJyID0gdGhpcy5kb20oKS5uZXh0U2libGluZztcblx0XHRcdGlmICgodHlwZW9mIGVsPT0nc3RyaW5nJ3x8ZWwgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGN1cnIpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQoKS5pbnNlcnRCZWZvcmUoZWwsY3Vycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBhcmVudCgpLmFwcGVuZENoaWxkKGVsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UHJldiA9IGZ1bmN0aW9uIChlbCl7XG5cdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBJTUZyYWdtZW50KSB7XG5cdFx0XHRcdGVsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuZG9tKCkuY2hpbGROb2Rlcyk7XG5cdFx0XHRcdC8vIGVsID0gW10uY29uY2F0KGVsLmRvbTpjaGlsZE5vZGVzKVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGVsKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRQcmV2KGFyeVtpXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGN1cnIgPSB0aGlzLmRvbSgpLnByZXZTaWJsaW5nO1xuXHRcdFx0aWYgKCh0eXBlb2YgZWw9PSdzdHJpbmcnfHxlbCBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0ZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlbCk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5wYXJlbnQoKS5pbnNlcnRCZWZvcmUoZWwsdGhpcyk7XG5cdFx0XHQvLyBwYXJlbnQuaW5zZXJ0KGVsLCBiZWZvcmU6IHNlbGYpXG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5leHROb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5uZXh0U2libGluZztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJldk5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnByZXZTaWJsaW5nO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0SU0uVHlwZXMgPSB7fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbScsICdiJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcua2V5ID0gZnVuY3Rpb24gKGtleSxoYW5kbGVyKXtcblx0XHRcdHRoaXMucHJvdG90eXBlWyhcImhhbmRsZVwiICsga2V5KV0gPSBoYW5kbGVyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcubmF0aXZlID0gZnVuY3Rpb24gKHR5cCl7XG5cdFx0XHR0aGlzLl9uYXRpdmVUeXBlID0gdHlwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcudHlwZSA9IGZ1bmN0aW9uICh0eXApe1xuXHRcdFx0SU0uVHlwZXNbdHlwXSA9IHRoaXM7XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwO1xuXHRcdFx0dGhpcy5wcm90b3R5cGUuX3R5cGUgPSB0eXA7XG5cdFx0XHQvLyBAZG9tRmxhZ3MucHVzaCh0eXApIGlmIEBkb21GbGFnc1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcudHlwZSgnVG9rJyk7XG5cdFx0XG5cdFx0dGFnLmFsaWFzID0gZnVuY3Rpb24gKHR5cCl7XG5cdFx0XHRJTS5UeXBlc1t0eXBdID0gdGhpcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnRyaWdnZXIgPSBmdW5jdGlvbiAobWF0Y2gsY21kKXtcblx0XHRcdGlmIChjbWQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRjbWQgPSB7Y29tbWFuZDogY21kfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNtZC50cmlnZ2VyID0gbWF0Y2g7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcm90b3R5cGVbKFwidHJpZ2dlci1cIiArIG1hdGNoKV0gPSBjbWQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldEhpbnQgPSBmdW5jdGlvbiAoaGludCl7XG5cdFx0XHRpZiAoaGludCAmJiBoaW50ICE9IHRoaXMuX2hpbnQpIHtcblx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ2hpbnQnLGhpbnQucmVmKCkpO1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShcImhpbnQtdHlwZVwiLGhpbnQudHlwZSgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKCdoaW50Jyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKCdoaW50LXR5cGUnKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcy5faGludCA9IGhpbnQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhpbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIHN0cmFuZ2Ugbm8/XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2hpbnQgfHwgdGhpcy52aWV3KCkuaGludHMoKS5nZXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hpbnQnKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBnbyBvdmVyIHRvIHVzaW5nIHRoaXMgXG5cdFx0dGFnLnByb3RvdHlwZS53YWxrVGV4dE5vZGVzID0gZnVuY3Rpb24gKG1hcmspe1xuXHRcdFx0aWYobWFyayA9PT0gdW5kZWZpbmVkKSBtYXJrID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNldFJvb3QodGhpcy5kb20oKSk7XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIHdhbGsgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHRoaXMucm9vdCgpLE5vZGVGaWx0ZXIuU0hPV19URVhULG51bGwsZmFsc2UpO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoZWwgPSB3YWxrLm5leHROb2RlKCkpe1xuXHRcdFx0XHRpZiAobWFyaykge1xuXHRcdFx0XHRcdHZhciBsZW4gPSBlbC5sZW5ndGg7XG5cdFx0XHRcdFx0ZWwuX2xvYyA9IHBvcztcblx0XHRcdFx0XHRwb3MgKz0gbGVuO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRub2Rlcy5wdXNoKGVsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBub2Rlcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudXRpbCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHV0aWw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLmNhcmV0KCkuc2V0KHRoaXMucmVnaW9uKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGxvZ2dlcl87XG5cdFx0XHQobG9nZ2VyXyA9IHRoaXMudmlldygpLmxvZ2dlcigpKS5sb2cuYXBwbHkobG9nZ2VyXyxhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5vdXRlckhUTUw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNwYWNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKHRoaXMuZG9tKCkubmV4dFNpYmxpbmcgaW5zdGFuY2VvZiBUZXh0KSB7XG5cdFx0XHRcdHJldHVybiAoL1tcXHQgXS8pLnRlc3QodGhpcy5kb20oKS5uZXh0U2libGluZy50ZXh0Q29udGVudFswXSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51bnNwYWNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICEodGhpcy5zcGFjZWQoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5leHRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGNvdWxkIGJlIHRleHQgYXMgd2VsbD9cblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLm5leHRTaWJsaW5nIGluc3RhbmNlb2YgVGV4dCA/IChudWxsKSA6ICh0aGlzLm5leHQoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnByZXZJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGNvdWxkIGJlIHRleHQgYXMgd2VsbD9cblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnByZXZpb3VzU2libGluZyBpbnN0YW5jZW9mIFRleHQgPyAobnVsbCkgOiAodGhpcy5wcmV2KCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS50ZXh0Q29udGVudDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHRoaXMuZG9tKCkudGV4dENvbnRlbnQgPSB0ZXh0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnRleHRDb250ZW50O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb2RlID0gZnVuY3Rpb24gKGNvZGUsc2lsZW50KXtcblx0XHRcdHZhciBoaW50Xztcblx0XHRcdGlmKHNpbGVudCA9PT0gdW5kZWZpbmVkKSBzaWxlbnQgPSBmYWxzZTtcblx0XHRcdHZhciBwcmV2ID0gdGhpcy5jb2RlKCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9kb20uZmlyc3RDaGlsZCA9PSB0aGlzLl9kb20ubGFzdENoaWxkICYmICh0aGlzLl9kb20uZmlyc3RDaGlsZCBpbnN0YW5jZW9mIFRleHQpKSB7XG5cdFx0XHRcdC8vIHN0aWxsIHNldCBpZiBpdCBoYXMgbm90IGNoYW5nZWQ/XG5cdFx0XHRcdHRoaXMuX2RvbS5maXJzdENoaWxkLnRleHRDb250ZW50ID0gY29kZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2RvbS50ZXh0Q29udGVudCA9IGNvZGU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY29kZSAhPSBwcmV2KSB7XG5cdFx0XHRcdChoaW50XyA9IHRoaXMuaGludCgpKSAmJiBoaW50Xy5jaGFuZ2VkICAmJiAgaGludF8uY2hhbmdlZCgpO1xuXHRcdFx0XHRpZiAoIXNpbGVudCkgeyB0aGlzLm9uY2hhbmdlZChjb2RlLHByZXYpIH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY2hhbmdlZCA9IGZ1bmN0aW9uIChjb2RlLHByZXYpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnZGlydHknKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpLmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHBhcmVudF87XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmlldyB8fCAoKHBhcmVudF8gPSB0aGlzLnBhcmVudCgpKSAmJiBwYXJlbnRfLnZpZXcgICYmICBwYXJlbnRfLnZpZXcoKSkgfHwgVklFVztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuY2FyZXQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkucmVnaW9uRm9yTm9kZSh0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWdpb24oKS5sb2MoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlY3JlYXNlSW5kZW50ID0gZnVuY3Rpb24gKHByZSxzdGF0ZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluY3JlYXNlSW5kZW50ID0gZnVuY3Rpb24gKHByZSxzdGF0ZSl7XG5cdFx0XHR2YXIgcmVnID0gL14oXFxzKiguKlxcPVxccyopPyhjbGFzc3xkZWZ8dGFnfHVubGVzc3xpZnxlbHNlfGVsaWZ8c3dpdGNofHRyeXxjYXRjaHxmaW5hbGx5fGZvcnx3aGlsZXx1bnRpbHxkbykpLztcblx0XHRcdHJldHVybiByZWcudGVzdChwcmUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lcmFzZSA9IGZ1bmN0aW9uIChyZWdpb24sbW9kZSl7XG5cdFx0XHRpZiAobW9kZSA9PSAnYWxsJykge1xuXHRcdFx0XHR0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRDb2RlKHV0aWwucGF0Y2hTdHJpbmcodGhpcy5jb2RlKCksJycscmVnaW9uKSk7IC8vIGNvZGUuaW5zKCcnLHJlZ2lvbilcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlZ2lvbixzdHIsZWRpdCxwYXJzKXtcblx0XHRcdGlmKCFwYXJzfHxwYXJzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHBhcnMgPSB7fTtcblx0XHRcdHZhciBtb2RlID0gcGFycy5tb2RlICE9PSB1bmRlZmluZWQgPyBwYXJzLm1vZGUgOiBudWxsO1xuXHRcdFx0dGhpcy5zZXRDb2RlKHV0aWwucGF0Y2hTdHJpbmcodGhpcy5jb2RlKCksc3RyLHJlZ2lvbikpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5zZXJ0ZWQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25jb21tYW5kID0gZnVuY3Rpb24gKGUsY21kKXtcblx0XHRcdHZhciBuYW1lID0gY21kLmNvbW1hbmQ7XG5cdFx0XHR2YXIgZm4gPSB0aGlzW25hbWVdO1xuXHRcdFx0dGhpcy5sb2coJ3J1biBvbmNvbW1hbmQnLG5hbWUsY21kKTtcblx0XHRcdFxuXHRcdFx0aWYgKGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGlzLGUsY21kKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZW50QmxvY2sgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW0uaW5kZW50QmxvY2snLGFyZ3VtZW50cyx0aGlzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0cmV0dXJuIElNLnRvayh2YWwpLmNsYXNzaWZ5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0ZpcnN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcGFyID0gdGhpcy5wYXJlbnQoKTtcblx0XHRcdHJldHVybiAocGFyIGluc3RhbmNlb2YgSU0uVHlwZXMuVG9rKSAmJiBwYXIuZG9tKCkuZmlyc3RDaGlsZCA9PSB0aGlzLmRvbSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0xhc3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBwYXIgPSB0aGlzLnBhcmVudCgpO1xuXHRcdFx0cmV0dXJuIChwYXIgaW5zdGFuY2VvZiBJTS5UeXBlcy5Ub2spICYmIHBhci5kb20oKS5sYXN0Q2hpbGQgPT0gdGhpcy5kb20oKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdGlmKGNvZGUgPT09IHVuZGVmaW5lZCkgY29kZSA9IHRoaXMudGV4dCgpO1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWRhdGUoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1hcmtJbnZhbGlkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmZsYWcoJ2ludmFsaWQnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tYXJrVmFsaWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMudW5mbGFnKCdpbnZhbGlkJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNJbnZhbGlkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYXNGbGFnKCdpbnZhbGlkJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsYXNzaWZ5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHVud3JhcCAvIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSBwYXJlbnRcblx0XHR0YWcucHJvdG90eXBlLnVud3JhcCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGVsID0gdGhpcy5kb20oKTtcblx0XHRcdHZhciBwYXIgPSBlbC5wYXJlbnROb2RlO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoZWwuZmlyc3RDaGlsZCl7XG5cdFx0XHRcdHBhci5pbnNlcnRCZWZvcmUoZWwuZmlyc3RDaGlsZCxlbCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG90aGVyKXtcblx0XHRcdHRoaXMuc2V0UHJldihvdGhlcik7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcnBoYW5pemUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QocSQoJy5faW5kZW50Jyx0aGlzKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAobXV0cyl7XG5cdFx0XHQvLyByZW1vdmUgbm9kZSBpZiBpdCBpcyBvcnBoYW5pemVkXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoc2VsZi5jb2RlKCkgPT0gJycpIHtcblx0XHRcdFx0c2VsZi5sb2coJ3JlbW92ZSB3aG9sZSBub2RlJyk7XG5cdFx0XHRcdC8vIHNob3VsZCBwb3NzaWJseVxuXHRcdFx0XHRyZXR1cm4gc2VsZi5vcnBoYW5pemUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYubG9nKCdtdXRhdGVkIC0tIHJlcGFyc2UnKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYudmlldygpLm9ic2VydmVyKCkucGF1c2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYudmlldygpLmhpZ2hsaWdodGVyKCkucmVwYXJzZShzZWxmLmRpcnR5RXh0ZW50KCkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlY2xhc3NpZnkgPSBmdW5jdGlvbiAodHlwZSl7XG5cdFx0XHQvLyByZWNsYXNzaWZ5IHNob3VsZCBoYXBwZW4gdGhyb3VnaCB0aGUgaGlnaGxpZ2h0ZXJcblx0XHRcdC8vIGxvZyAncmVjbGFzc2lmeSBub2RlIGFzIHR5cGUnLHR5cGVcblx0XHRcdHZhciBjbHMgPSBJTS5UeXBlc1t0eXBlXSB8fCBJbWJhLlRBR1NbKFwiaW1cIiArIHR5cGUpXTtcblx0XHRcdFxuXHRcdFx0aWYgKGNscykge1xuXHRcdFx0XHQvLyBsb2cgJ2ZvdW5kIGNsYXNzIHRvIHJlY2xhc3NpZnkgYXMnLGNscyxzZWxmOmNvbnN0cnVjdG9yXG5cdFx0XHRcdGlmIChjbHMgPT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gbG9nICdmb3VuZCBjbGFzcyB0byByZWNsYXNzaWZ5IGFzJyxjbHNcblx0XHRcdFx0dmFyIG5vZGUgPSBuZXcgY2xzKHRoaXMuZG9tKCkpLnNldHVwKCk7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhcnNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJhc2VDbGFzc2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgY2xzID0gdGhpcy5jb25zdHJ1Y3Rvci5kb20oKS5jbGFzc05hbWU7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSkgeyBjbHMgKz0gJyAnICsgdGhpcy5fdHlwZSB9O1xuXHRcdFx0cmV0dXJuIGNscztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc2VzKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmV1c2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNldHVwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNBdG9taWMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGZpbmQgdGhlIG5vZGVzIC8gcmVnaW9uIHRoYXQgc2hvdWxkIGJlIHJlcGFyc2VkIGlmIHRoaXMgZWxlbWVudCBoYXMgY2hhbmdlZFxuXHRcdC8vIHRoaXMgaXMgY3VycmVudGx5IHF1b3RlIFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlydHlFeHRlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIDNsb2cgXCJnZXQgZGlydHkgZXh0ZW50IGZvclwiLGRvbVxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBzZWwsIHNlbDEsIHNlbDIsICQxO1xuXHRcdFx0aWYgKHNlbCA9IHNlbGYudXAocSQoJy5zZWxlY3Rvcicsc2VsZikpKSB7XG5cdFx0XHRcdHJldHVybiBzZWwuZGlydHlFeHRlbnQoKTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsMSA9IHNlbGYudXAocSQoJy5faW10YWdub2RlJyxzZWxmKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbDEuZGlydHlFeHRlbnQoKTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsMiA9IHNlbGYudXAocSQoJy5faW1pc3RyaW5nJyxzZWxmKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbDIuZGlydHlFeHRlbnQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChzZWxmLmlzQXRvbWljKCkpIHsgLy8gaG1tXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bm9kZXM6IFtzZWxmLmRvbSgpXSxcblx0XHRcdFx0XHRjb2RlOiBzZWxmLmNvZGUoKSxcblx0XHRcdFx0XHRjb250YWluczogZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHNlbGYuZG9tKCkuY29udGFpbnMoZWwuX2RvbSB8fCBlbCk7IH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBzdGFydCA9IHNlbGYuZG9tKCk7XG5cdFx0XHR2YXIgZW5kID0gc2VsZi5kb20oKTtcblx0XHRcdFxuXHRcdFx0dmFyIHByZXYsbmV4dDtcblx0XHRcdHZhciBub2RlcyA9IFtzZWxmLmRvbSgpXTtcblx0XHRcdHZhciBvcGVuZXIsY2xvc2VyO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAocHJldiA9IHN0YXJ0LnByZXZpb3VzU2libGluZyl7XG5cdFx0XHRcdGlmIChwcmV2IGluc3RhbmNlb2YgVGV4dCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXYubWF0Y2hlcygnLl9pbW5ld2xpbmUsLl9pbXRhYicpKSB7IC8vICwuX2ltb3BlbiwuX2ltY2xvc2Vcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwcmV2Lm1hdGNoZXMoJy5faW1vcGVuJykpIHtcblx0XHRcdFx0XHRvcGVuZXIgPSBwcmV2O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0c3RhcnQgPSBwcmV2O1xuXHRcdFx0XHRub2Rlcy51bnNoaWZ0KHN0YXJ0KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHdoaWxlIChuZXh0ID0gZW5kLm5leHRTaWJsaW5nKXtcblx0XHRcdFx0aWYgKG5leHQgaW5zdGFuY2VvZiBUZXh0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV4dC5tYXRjaGVzKCcuX2ltbmV3bGluZScpKSB7IC8vIC5faW1vcGVuLC5faW1jbG9zZVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5leHQubWF0Y2hlcygnLl9pbWNsb3NlJykpIHtcblx0XHRcdFx0XHRjbG9zZXIgPSBuZXh0O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0ZW5kID0gbmV4dDtcblx0XHRcdFx0bm9kZXMucHVzaChlbmQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gc2VlIGlmIHdlIGluY2x1ZGUgYW4gb3BlbiBvciBjbG9zZS10YWdcblx0XHRcdFxuXHRcdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdFx0bm9kZXM6IG5vZGVzLFxuXHRcdFx0XHRjb2RlOiBcIlwiLFxuXHRcdFx0XHR0YXJnZXQ6IHNlbGYuZG9tKCksXG5cdFx0XHRcdG5lc3RlZDogW10sXG5cdFx0XHRcdGNvbnRhaW5zOiBmdW5jdGlvbihub2RlKSB7IHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2Yobm9kZSkgPj0gMDsgfVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG9wZW5lciB8fCBjbG9zZXIpIHtcblx0XHRcdFx0Ly8gbG9nIFwiaW5jbHVkZXMgb3BlbmVyIGFuZCAvIG9yIGNsb3NlclwiLG9wZW5lcixjbG9zZXJcblx0XHRcdFx0dmFyIHBhciA9IHRhZyR3cmFwKChvcGVuZXIgfHwgY2xvc2VyKS5wYXJlbnROb2RlKTtcblx0XHRcdFx0aWYgKCgkMSA9IHBhcikgJiYgJDEuaXNBdG9taWMgICYmICAkMS5pc0F0b21pYygpKSB7XG5cdFx0XHRcdFx0Ly8gbG9nICdyZXR1cm4gdGhlIHBhcmVudCBkaXJ0eSBleHRlbnQnLHBhclxuXHRcdFx0XHRcdHJldHVybiBwYXIuZGlydHlFeHRlbnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAodmFyIG5vZGVzID0gW10sIGkgPSAwLCBhcnkgPSBpdGVyJCgob3BlbmVyIHx8IGNsb3NlcikucGFyZW50Tm9kZS5jaGlsZHJlbiksIGxlbl8gPSBhcnkubGVuZ3RoOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaChhcnlbaV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGxvYyA9IDA7XG5cdFx0XHRcblx0XHRcdC8vIHNob3VsZCB1c2UgdGhlIHRhZ3MgZGlyZWN0bHlcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbl8gPSBhcnkubGVuZ3RoLCBub2RlOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdG5vZGUgPSBhcnlbaV07XG5cdFx0XHRcdHZhciByaWNoID0gdGFnJHdyYXAobm9kZSk7XG5cdFx0XHRcdHZhciB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudDtcblx0XHRcdFx0dmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGZhbHNlICYmIHJpY2ggJiYgKChyaWNoIGluc3RhbmNlb2YgSU0uVHlwZXMucGFpcikgfHwgcmljaC5pc0ludmFsaWQoKSkpIHtcblx0XHRcdFx0XHR0ZXh0ID0gXCInwqfCp8KnJ1wiO1xuXHRcdFx0XHRcdGxlbiA9IDU7XG5cdFx0XHRcdFx0c2VsZi5sb2coXCJhZGRlZCBub2RlIGFzIG5lc3RlZCByZWZlcmVuY2VcIixyaWNoLmRvbSgpKTtcblx0XHRcdFx0XHQvLyB0aGlzIGlzIGZ1Y2tlZCB1cFxuXHRcdFx0XHRcdC8vIHRoaXMgcmVhbGx5IGRvZXMgbWVzcyB1cCB0aGUgcmljaCBub2RlcyBoZXJlKD8hKVxuXHRcdFx0XHRcdHJlc3VsdC5uZXN0ZWQucHVzaChyaWNoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHJlc3VsdC5jb2RlICs9IHRleHQ7XG5cdFx0XHRcdGxvYyArPSBsZW47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXN1bHQubm9kZXMgPSBub2Rlcztcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFyc2VFeHRlbnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRpcnR5ID0gc2VsZi5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0XHRpZiAoZSkgeyBlLmhhbmRsZWQoKSB9O1xuXHRcdFx0XHRyZXR1cm4gSGlnaGxpZ2h0ZXIucmVwYXJzZShkaXJ0eSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHQvLyBwaWVjZSBvZiB1bnBhcnNlZCBjb2RlXG5cdHRhZyQuZGVmaW5lVGFnKCdpbXJhdycsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3JhdycpO1xuXHRcdHRhZy5hbGlhcygnQCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmF3ID0gZnVuY3Rpb24gKHJhdyl7XG5cdFx0XHR0aGlzLl9yYXcgPSByYXc7XG5cdFx0XHR0aGlzLl9kb20udGV4dENvbnRlbnQgPSByYXc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25lZGl0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy5zZXRDb2RlKGUucGF0Y2godGhpcykpO1xuXHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltZnJhZ21lbnQnLCAnaW1yYXcnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdmcmFnbWVudCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KXtcblx0XHRcdGlmICh0eXBlb2YgY29udGVudCA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YWcuX19zdXBlcl9fLnNldENvbnRlbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMudW53cmFwKCk7XG5cdFx0XHR0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRJTUZyYWdtZW50ID0gSW1iYS5UQUdTLmltZnJhZ21lbnQ7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1vcGVuJywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHQvLyBAbm9kZVR5cGUgPSAncydcblx0XHR0YWcudHlwZSgnb3BlbicpO1xuXHRcdFxuXHRcdHRhZy5hbGlhcygnWycpO1xuXHRcdHRhZy5hbGlhcygnKCcpO1xuXHRcdHRhZy5hbGlhcygneycpO1xuXHRcdHRhZy5hbGlhcygne3snKTtcblx0XHR0YWcuYWxpYXMoJ2luZGV4X3N0YXJ0Jyk7XG5cdFx0dGFnLmFsaWFzKCdibG9ja19wYXJhbV9zdGFydCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWNsb3NlJywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnY2xvc2UnKTtcblx0XHQvLyBAbm9kZVR5cGUgPSAncydcblx0XHRcblx0XHR0YWcuYWxpYXMoJ10nKTtcblx0XHR0YWcuYWxpYXMoJyknKTtcblx0XHR0YWcuYWxpYXMoJ30nKTtcblx0XHR0YWcuYWxpYXMoJ319Jyk7XG5cdFx0dGFnLmFsaWFzKCdpbmRleF9lbmQnKTtcblx0XHR0YWcuYWxpYXMoJ2Jsb2NrX3BhcmFtX2VuZCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXJwYXJlbicsICdpbWNsb3NlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgncnBhcmVuJyk7XG5cdFx0dGFnLmFsaWFzKCcpJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltdGFnb3BlbicsICdpbW9wZW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCd0YWdfc3RhcnQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWdjbG9zZScsICdpbWNsb3NlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX2VuZCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbG9wZW4nLCAnaW1vcGVuJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3Jfc3RhcnQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zZWxjbG9zZScsICdpbWNsb3NlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfZW5kJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcXVvdGUnLCAnaW0nKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNpbmdsZXF1b3RlJywgJ2ltcXVvdGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKFwiJ1wiKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1kb3VibGVxdW90ZScsICdpbXF1b3RlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnXCInKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zdHJzdGFydCcsICdpbW9wZW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzdHJpbmdfc3RhcnQnKTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltc3RyZW5kJywgJ2ltY2xvc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzdHJpbmdfZW5kJyk7XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvYmFzZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi4vY29yZS9oaWdobGlnaHRlcicpLkhpZ2hsaWdodGVyO1xuXHRcblx0XG5cdHZhciBrZXl3b3JkcyA9IFtcblx0XHQndHJ1ZScsJ2ZhbHNlJywnbnVsbCcsJ3RoaXMnLFxuXHRcdCdkZWxldGUnLCd0eXBlb2YnLCdpbicsJ2luc3RhbmNlb2YnLFxuXHRcdCd0aHJvdycsJ2JyZWFrJywnY29udGludWUnLCdkZWJ1Z2dlcicsXG5cdFx0J2lmJywnZWxzZScsJ3N3aXRjaCcsJ2ZvcicsJ3doaWxlJywnZG8nLCd0cnknLCdjYXRjaCcsJ2ZpbmFsbHknLFxuXHRcdCdjbGFzcycsJ2V4dGVuZHMnLCdzdXBlcicsJ3JldHVybicsXG5cdFx0J3VuZGVmaW5lZCcsJ3RoZW4nLCd1bmxlc3MnLCd1bnRpbCcsJ2xvb3AnLCdvZicsJ2J5Jyxcblx0XHQnd2hlbicsJ2RlZicsJ3RhZycsJ2RvJywnZWxpZicsJ2JlZ2luJywndmFyJywnbGV0Jywnc2VsZicsJ2F3YWl0JywnaW1wb3J0Jyxcblx0XHQnYW5kJywnb3InLCdpcycsJ2lzbnQnLCdub3QnLCd5ZXMnLCdubycsJ2lzYScsJ2Nhc2UnLCduaWwnLCdleHRlbmQnLCdleHBvcnQnLCdvd24nXG5cdF07XG5cdFxuXHQvLyB0aGlzIGlzIHJlYWxseSB0aGUgZ2VuZXJhbCB0b2tlblxuXHR0YWckLmRlZmluZVRhZygnaW10b2snLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy5hbGlhcygndG9rZW4nKTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fZXJlZiA9IHt3YXRjaDogJ2VyZWZEaWRTZXQnLG5hbWU6ICdlcmVmJ307XG5cdFx0dGFnLnByb3RvdHlwZS5lcmVmID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZXJlZicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRFcmVmID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMuZXJlZigpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuc2V0QXR0cmlidXRlKCdlcmVmJyx2KTsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuZXJlZkRpZFNldCAmJiB0aGlzLmVyZWZEaWRTZXQodixhLHRoaXMuX19lcmVmKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZXJlZkRpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHQvLyBleHBlcmltZW50YWxcblx0XHRcdC8vIGNvbnNvbGUubG9nICdlcmVmRGlkU2V0JyxuZXcsb2xkXG5cdFx0XHRpZiAoIShuZXckICYmIG9sZCkpIHsgdGhpcy5mbGFnKCdsdmFyJywhKCEobmV3JCkpKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzVmFyUmVmID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYXNGbGFnKCdsdmFyJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsZWFyVmFyUmVmID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnNldEVyZWYobnVsbCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdHJldHVybiBJTS50b2sodmFsKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHRhZy5fX3N1cGVyX18uc2V0VGV4dC5jYWxsKHRoaXMsdGV4dCk7XG5cdFx0XHR0aGlzLmNsYXNzaWZ5KCk7XG5cdFx0XHRcblx0XHRcdHZhciB0eXAgPSBJTS5pZGVudGlmeSh0ZXh0KTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cCkge1xuXHRcdFx0XHR0aGlzLmxvZygncmVjbGFzc2lmeWluZyBpbXRvayBpbW1lZGlhdGVseScpO1xuXHRcdFx0XHR0aGlzLnNldENvZGUodGV4dCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlY2xhc3NpZnkodHlwKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHJldHVybiByYXcgdG9rZW4gaWYgbm90IGNsYXNzaWZpZWQ/XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwID8gKHRoaXMpIDogKHRhZyQuJGltcmF3KCkuc2V0UmF3KHRleHQpLmVuZCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2FuUHJlcGVuZCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xhc3NpZnkgPSBmdW5jdGlvbiAobWFwKXtcblx0XHRcdG1hcCB8fCAobWFwID0gSU0uaWRlbnRpZnkodGhpcy5jb2RlKCkpKTtcblx0XHRcdGlmIChtYXApIHtcblx0XHRcdFx0aWYgKCFtYXAubWF0Y2goL1xcYl9bXFx3XS8pKSB7IG1hcCA9ICdfaW10b2sgJyArIG1hcCB9O1xuXHRcdFx0XHR0aGlzLmRvbSgpLmNsYXNzTmFtZSA9IG1hcDtcblx0XHRcdFx0dGhpcy5fdHlwID0gbWFwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdHlwID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ3JlcGFpcicpO1xuXHRcdFx0dGhpcy5jbGFzc2lmeSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHJlZ2lvbil7XG5cdFx0XHRyZWdpb24gPSBSZWdpb24ubm9ybWFsaXplKHJlZ2lvbik7XG5cdFx0XHR2YXIgbGZ0ID0gdGhpcy5jb2RlKCkuc3Vic3RyaW5nKDAscmVnaW9uLnN0YXJ0KCkpO1xuXHRcdFx0dmFyIHJndCA9IHRoaXMuY29kZSgpLnNsaWNlKHJlZ2lvbi5lbmQoKSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuc2V0Q29kZShsZnQpO1xuXHRcdFx0dGhpcy5zZXROZXh0KElNLnRvayhyZ3QpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHR2YXIgZGlydHkgPSB0aGlzLmRpcnR5RXh0ZW50KCk7XG5cdFx0XHR0aGlzLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkgeyByZXR1cm4gSGlnaGxpZ2h0ZXIucmVwYXJzZShkaXJ0eSk7IH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJldXNlID0gZnVuY3Rpb24gKHRvayxuZXckLG9sZCl7XG5cdFx0XHRpZiAobmV3JCA9PSBvbGQpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLnJldXNlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0aWYgKCFvLmRlZXAgJiYgdGhpcy52YWxpZGF0ZSh0aGlzLmNvZGUoKSkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLm11dGF0ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmRibGNsaWNrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWxlY3QoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuZXJlZigpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5ub2Rlc0ZvckVudGl0eSh0aGlzLmVyZWYoKSkubWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC5mbGFnKCdobCcpOyB9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdGlmICh0aGlzLmVyZWYoKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkubm9kZXNGb3JFbnRpdHkodGhpcy5lcmVmKCkpLm1hcChmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwudW5mbGFnKCdobCcpOyB9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaWRlbnRpZmllcicsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2lkZW50aWZpZXInKTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0Ly8gcmVnZXggZm9yIGlkZW50aWZpZXJcblx0XHRcdHJldHVybiAoL15bYS16XSgtP1tcXHdBLVphLXpfXFwtXFx4N2YtXFx1ZmZmZlxcJF0rKSokLykudGVzdChjb2RlKSAmJiBrZXl3b3Jkcy5pbmRleE9mKGNvZGUpID09IC0xO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICh0b2ssbmV3JCxvbGQpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2lkZW50aWZpZXIgc2V0dXAnLGJhc2VDbGFzc2VzXG5cdFx0XHR2YXIgdl87XG5cdFx0XHRpZiAodG9rICYmIHRvay5fdmFsdWUpIHsgKHRoaXMuc2V0TmFtZSh2XyA9IHRvay5fdmFsdWUpLHZfKSB9O1xuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzZXMoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaW1pZGVudGlmaWVyIG11dGF0ZWQnXG5cdFx0XHR0aGlzLnNldE5hbWUodGhpcy5jb2RlKCkpO1xuXHRcdFx0aWYgKHRoaXMuaXNWYXJSZWYoKSkge1xuXHRcdFx0XHR0aGlzLmNsZWFyVmFyUmVmKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ubXV0YXRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWd0eXBlJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX3R5cGUnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWdpZCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3RhZ19pZCcpO1xuXHRcdHRhZy5hbGlhcygnaWRyZWYnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1jb25zdCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2NvbnN0Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdHJldHVybiAoL15bQS1aXSgtP1tcXHdBLVphLXpfXFwtXFx4N2YtXFx1ZmZmZlxcJF0rKSokLykudGVzdChjb2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGRlZiBvbmNoYW5nZWQgY29kZSwgcHJldlxuXHRcdC8vIFx0IyBjb25zb2xlLmxvZyAnaW1jb25zdCBvbmNoYW5nZWQnLGNvZGUscHJldlxuXHRcdC8vIFx0ZmxhZygnZGlydHknKSB1bmxlc3MgdmFsaWRhdGUoY29kZSlcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaXZhcicsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2l2YXInKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1jdmFyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnY3ZhcicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWtleXdvcmQnLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdrZXl3b3JkJyk7XG5cdFx0dGFnLmFsaWFzKCduZXcnKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKHRvayxuZXckLG9sZCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnc2V0dXAgaW1rZXl3b3JkJyx0b2ssIG5ldywgb2xkXG5cdFx0XHR2YXIgY2xzID0gdGhpcy5iYXNlQ2xhc3NlcygpO1xuXHRcdFx0aWYgKHRvayAmJiB0b2suX3ZhbHVlKSB7IGNscyArPSAnICcgKyB0b2suX3ZhbHVlIH07XG5cdFx0XHR0aGlzLl9kb20uY2xhc3NOYW1lID0gY2xzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRrZXl3b3Jkcy5tYXAoZnVuY3Rpb24oa2V5d29yZCkgeyByZXR1cm4gSU0uVHlwZXNba2V5d29yZF0gPSBJTS5UeXBlcy5rZXl3b3JkOyB9KTtcblx0XG5cdElNLlR5cGVzLmZvcmluID0gSU0uVHlwZXMua2V5d29yZDtcblx0SU0uVHlwZXMuZm9yb2YgPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRJTS5UeXBlcy5wb3N0X2lmID0gSU0uVHlwZXMua2V5d29yZDtcblx0SU0uVHlwZXMucG9zdF91bmxlc3MgPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRJTS5UeXBlcy5wb3N0X2ZvciA9IElNLlR5cGVzLmtleXdvcmQ7XG5cdElNLlR5cGVzLnBvc3Rfd2hpbGUgPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltbnVtJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnbnVtYmVyJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdHJldHVybiAoL15cXGQrKFxcLlxcZCspPyQvKS50ZXN0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXVzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pbnQnLCAnaW1udW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdpbnQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1mbG9hdCcsICdpbW51bScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2Zsb2F0Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltYm9vbCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2Jvb2wnKTtcblx0XHR0YWcuYWxpYXMoJ3RydWUnKTtcblx0XHR0YWcuYWxpYXMoJ2ZhbHNlJyk7XG5cdH0pO1xuXHRcblx0Ly8gdGhpcyBzaG91bGQgYmUgbW9yZSBhZHZhbmNlZCAtIG5vXG5cdHRhZyQuZGVmaW5lVGFnKCdpbXN0cicsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N0cmluZycpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucXVvdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNvZGUoKVswXTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UXVvdGUgPSBmdW5jdGlvbiAocXVvdGUpe1xuXHRcdFx0dGhpcy5zZXRDb2RlKHF1b3RlICsgdGhpcy5jb2RlKCkuc2xpY2UoMSwtMSkgKyBxdW90ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAodG9rLG5ldyQsb2xkKXtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdzZXR1cCBzdHJpbmcnLHRvaywgbmV3LCBvbGRcblx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc2VzKCk7XG5cdFx0XHR0aGlzLnNldENvZGUobmV3JCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub251bndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgdl87XG5cdFx0XHR0aGlzLmxvZygnaW1zdHJpbmcgb251bndyYXAhISEnLGUpO1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHQvLyBsb29rIGF0IHByZXYgYW5kIG5leHQgYXMgd2VsbD9cblx0XHRcdC8vIHNob3VsZCBkbyB0aGlzIHRocm91Z2ggdGhlIHZpZXdcblx0XHRcdHJldHVybiAodGhpcy5zZXRDb2RlKHZfID0gdGhpcy5jb2RlKCkuc2xpY2UoMSwtMSkpLHZfKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25kYmxjbGljayA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2VsZWN0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0aWYgKGNvZGVbMF0gPT0gJ1wiJykge1xuXHRcdFx0XHRyZXR1cm4gKC9eXFxcIihbXlwiXFx7XSopXFxcIiQvKS50ZXN0KGNvZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb2RlWzBdID09IFwiJ1wiKSB7XG5cdFx0XHRcdHJldHVybiAoL15cXCcoW14nXFx7XSopXFwnJC8pLnRlc3QoY29kZSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnRyaWdnZXIoJ1wiJyxmdW5jdGlvbih0b2tlbixvKSB7XG5cdFx0XHRpZiAodG9rZW4ucXVvdGUoKSA9PSAnXCInKSB7XG5cdFx0XHRcdHRoaXMuaW5zZXJ0KCdcXFxcXCInKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnF1b3RlKCkgPT0gXCInXCIgJiYgby5tb2RlID09ICdhbGwnKSB7XG5cdFx0XHRcdHRva2VuLnNldFF1b3RlKCdcIicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0XG5cdFx0dGFnLnRyaWdnZXIoXCInXCIsZnVuY3Rpb24odG9rZW4sbykge1xuXHRcdFx0dmFyIHZfO1xuXHRcdFx0aWYgKHRva2VuLnF1b3RlKCkgPT0gJ1wiJykge1xuXHRcdFx0XHRyZXR1cm4gKHRva2VuLnNldFF1b3RlKHZfID0gXCInXCIpLHZfKTtcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4ucXVvdGUoKSA9PSBcIidcIiAmJiBvLm1vZGUgPT0gJ2FsbCcpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0KFwiXFxcXCdcIik7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9KTtcblx0XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltbmVvc3RyaW5nJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnbmVvc3RyaW5nJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoIW8uZGVlcCAmJiAhdGhpcy5jb2RlKCkubWF0Y2goL1tcXHtcXFwiXFwnXS8pKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5tdXRhdGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXN5bScsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N5bWJvbCcpO1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW10YWdhdHRyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX2F0dHInKTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy90b2tlbi5pbWJhXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHR2YXIgSGlnaGxpZ2h0ZXIgPSByZXF1aXJlKCcuLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1ibG9jaycsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWxldGVMZWZ0UmlnaHQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1ibG9jayBkZWxldGVMZWZ0UmlnaHQnLGUucmVnaW9uKCkucGVlaygtMSwxKSk7XG5cdFx0XHRcblx0XHRcdGlmIChlLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gdGhpcy5jb2RlKCkpIHtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluZGVudEJsb2NrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0ZS5oYW5kbGVkKCk7XG5cdFx0XHRcblx0XHRcdHNlbGYudmlldygpLmNhcmV0KCkuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0dmFyIHJlZ2lvbiA9IHNlbGYudmlldygpLmNhcmV0KCkucmVnaW9uKCk7XG5cdFx0XHR2YXIgbm9kZXMgPSBzZWxmLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHJlZ2lvbik7XG5cdFx0XHRcblx0XHRcdG5vZGVzLm1hcChmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRpZiAobWF0Y2gubm9kZS5tYXRjaGVzKCcuX2ltbmV3bGluZScpKSB7XG5cdFx0XHRcdFx0c2VsZi5sb2coJ2ZvdW5kIHRhYiBpbiBzZWxlY3Rpb24nLG1hdGNoKTtcblx0XHRcdFx0XHRpZiAobWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gubm9kZS5pbmRlbnQoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHNlbGYudmlldygpLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51bmRlbnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1ibG9jay51bmRlbnQnLGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgbm9kZXMgPSBlLnZpZXcoKS5ub2Rlc0luUmVnaW9uKGUucmVnaW9uKCkuY2xvbmUoKS5zdGFydEF0TGluZSgpKTtcblx0XHRcdG5vZGVzLm1hcChmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRpZiAobWF0Y2gubm9kZS5tYXRjaGVzKCcuX2ltbmV3bGluZScpICYmIG1hdGNoLm1vZGUgIT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaC5ub2RlLnVuZGVudCgpO1xuXHRcdFx0XHRcdC8vIGUuY2FyZXQuZXhwYW5kKDAsLTEpXG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMudmlldygpLmNhcmV0KCkuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYWlyYWJsZSA9IGZ1bmN0aW9uIChzdHIsZSl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRcdHRoaXMuc2V0Q2hpbGRyZW4oW25vZGVdKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGxvZyBcInJlcGFpciBibG9ja1wiXG5cdFx0XHRxJCgnLl9pbXJhdycsdGhpcykubWFwKGZ1bmN0aW9uKHJhdykgeyByZXR1cm4gcmF3LnJlcGFpcigpOyB9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gdmFyIHJlZyA9IHZpZXcuc2VsLnJlZ2lvblxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5jb2RlU3RhdGUoKTtcblx0XHRcdHZhciBobCA9IElNLnBhcnNlKHN0YXRlLmNvZGUpO1xuXHRcdFx0Ly8gY291bGQgc2VuZCB0aGlzIHRocm91Z2ggbG9hZCBpbnN0ZWFkXG5cdFx0XHQvLyB3aGF0IGFib3V0IGFubm90YXRpb25zIGhlcmU/XG5cdFx0XHR0aHJvdyAnZG9udCByZWhpZ2hsaWdodCc7XG5cdFx0XHRcblx0XHRcdGlmIChobCkge1xuXHRcdFx0XHRzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYuZG9tKCkuaW5uZXJIVE1MID0gaGwgKyAnXFxuJztcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUuaW52YWxpZHMubWFwKGZ1bmN0aW9uKGludikge1xuXHRcdFx0XHRcdFx0Ly8gd2UgY291bGQgZ28gbG9jYWwgaW5zdGVhZFxuXHRcdFx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdFx0XHRpZiAobm9kZSA9IHNlbGYudmlldygpLm5vZGVBdFJlZ2lvbihpbnYucmVnaW9uLHRydWUpKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYubG9nKCdmb3VuZCBub2RlIGF0IGludmFsaWQgcG9zaXRpb24nLG5vZGUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZS5yZXBsYWNlV2l0aChpbnYubm9kZSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGJhZCBuYW1pbmdcblx0XHR0YWcucHJvdG90eXBlLmNvZGVTdGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHJlYWwgPSBzZWxmLmNvZGUoKTtcblx0XHRcdHZhciB2YWxpZCA9IHJlYWw7XG5cdFx0XHR2YXIgaW52YWxpZHMgPSBxJCgnLmludmFsaWQnLHNlbGYpO1xuXHRcdFx0dmFyIG93bnJlZyA9IHNlbGYucmVnaW9uKCk7XG5cdFx0XHR2YXIgc2VscmVnID0gc2VsZi52aWV3KCkuc2VsKCkucmVnaW9uKCk7XG5cdFx0XHRcblx0XHRcdHZhciByZW1lbWJlciA9IGludmFsaWRzLm1hcChmdW5jdGlvbihpbnYpIHtcblx0XHRcdFx0Ly8gbXVsdGlsZXZlbCBuZXN0aW5nP1xuXHRcdFx0XHR2YXIgcmVnaW9uID0gaW52LnJlZ2lvbigpO1xuXHRcdFx0XHR2YXIgcmVscmVnID0gcmVnaW9uLnJlbGF0aXZlVG8ob3ducmVnKTtcblx0XHRcdFx0c2VsZi5sb2coJ2ludmFsaWQgcmVnaW9uJyxvd25yZWcsJ3NlbGYnLHJlZ2lvbixyZWxyZWcpO1xuXHRcdFx0XHR2YWxpZCA9IHZhbGlkLmlucyhpbnYucGxhY2Vob2xkZXIoKSxyZWxyZWcpO1xuXHRcdFx0XHRyZXR1cm4ge3JlZ2lvbjogcmVnaW9uLHBsYWNlaG9sZGVyOiBpbnYucGxhY2Vob2xkZXIoKSxyYXc6IGludi5jb2RlKCksbm9kZTogaW52LHJvb3Q6IHNlbGYscmVsUmVnaW9uOiByZWxyZWd9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlZ2lvbjogb3ducmVnLFxuXHRcdFx0XHRtYXJrZXI6IChzZWxyZWcuaW50ZXJzZWN0cyhvd25yZWcpID8gKHNlbHJlZykgOiAobnVsbCkpLFxuXHRcdFx0XHRyYXc6IHJlYWwsXG5cdFx0XHRcdGNvZGU6IHZhbGlkLFxuXHRcdFx0XHRpbnZhbGlkczogcmVtZW1iZXJcblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaW50ZXJwb2xhdGVkJywgJ2ltYmxvY2snKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbmRlbnQnLCAnaW1ibG9jaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBtYXAgPSB7fTtcblx0XHRcdHZhciB2YXJzID0gW107XG5cdFx0XHRxJCgnLl9sdmFyJyx0aGlzKS5tYXAoZnVuY3Rpb24obHZhcikge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGx2YXIudGV4dCgpO1xuXHRcdFx0XHRpZiAoIW1hcFtuYW1lXSkge1xuXHRcdFx0XHRcdG1hcFtuYW1lXSA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIHZhcnMucHVzaChuYW1lKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHZhcnM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1wYWlyJywgJ2ltYmxvY2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdwYWlyJyk7XG5cdFx0XG5cdFx0dGFnLnBhaXIgPSBmdW5jdGlvbiAob3BlbixjbG9zZSl7XG5cdFx0XHR0aGlzLnByb3RvdHlwZS5fb3BlbiA9IG9wZW47XG5cdFx0XHR0aGlzLnByb3RvdHlwZS5fY2xvc2UgPSBjbG9zZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb3BlbiB8fCAnJztcblx0XHR9O1xuXHRcdHRhZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9jbG9zZSB8fCAnJztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZ2VuKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KXtcblx0XHRcdHRocm93ICdzaG91bGQgbm90IGdldCBoZXJlJztcblx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gdGhpcy5vcGVuKCkgKyBJTS5wYXJzZShjb250ZW50KSArIHRoaXMuY2xvc2UoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKCkucmVwbGFjZSgvW1xcc1xcdCBcXG5dLywnJykgPT0gKHRoaXMub3BlbigpICsgdGhpcy5jbG9zZSgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNQYWlyZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBjb2RlID0gdGhpcy5jb2RlKCk7XG5cdFx0XHRyZXR1cm4gY29kZVswXSA9PSB0aGlzLm9wZW4oKSAmJiBjb2RlW2NvZGUubGVuZ3RoIC0gMV0gPT0gdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc09wZW5lZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpWzBdID09IHRoaXMub3BlbigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpW3RoaXMuY29kZSgpLmxlbmd0aCAtIDFdID09IHRoaXMuY2xvc2UoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlbW92ZSB0aGUgd2hvbGUgdGhpbmcnKTtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlbDtcblx0XHRcdFx0dmFyIHBhciA9IHRoaXMucGFyZW50KCk7XG5cdFx0XHRcdHdoaWxlIChlbCA9IHRoaXMuX2RvbS5maXJzdENoaWxkKXtcblx0XHRcdFx0XHRwYXIuZG9tKCkuaW5zZXJ0QmVmb3JlKGVsLHRoaXMuX2RvbSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHJlbW92ZSBzZWxmIGFzIHdlbGxcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub251bndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1wYWlyIG9udW53cmFwISEhJyxlKTtcblx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGFnJC4kaW1vcGVuKCkuc2V0Q29udGVudCh0aGlzLm9wZW4oKSwwKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kaW1jbG9zZSgpLnNldENvbnRlbnQodGhpcy5jbG9zZSgpLDApLmVuZCgpXG5cdFx0XHRdKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmluc2VydGVkID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5zZXRDYXJldCh0aGlzLnJlZ2lvbigpLmNvbGxhcHNlKGZhbHNlKS5tb3ZlKDEpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmxpbmVicmVhayA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBwcmUgPSBlLmxpbmVzdHIoJ3ByZScpO1xuXHRcdFx0dmFyIGluZGVudCA9IGUuaW5kZW50KCk7XG5cdFx0XHR2YXIgbmV3JCA9IHRoaXMudGV4dCgpLmlucygnJyxlLnJlbFJlZ2lvbigpKTtcblx0XHRcdFxuXHRcdFx0Ly8gdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIG5vP1xuXHRcdFx0aWYgKG5ldyQgPT0gKHRoaXMub3BlbigpICsgdGhpcy5jbG9zZSgpKSkge1xuXHRcdFx0XHR2YXIgcHJlZml4ID0gJ1xcbicgKyBpbmRlbnQgKyAnXFx0Jztcblx0XHRcdFx0dmFyIHBvc3QgPSAnXFxuJyArIGluZGVudDtcblx0XHRcdFx0dGhpcy5vbndoaXRlc3BhY2UoZSxwcmVmaXggKyBwb3N0KTtcblx0XHRcdFx0ZS5jYXJldCgpLmNvbGxhcHNlKGZhbHNlKS5tb3ZlKC1wb3N0Lmxlbmd0aCk7XG5cdFx0XHRcdHJldHVybiBlLmhhbmRsZWQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG5lZWQgdG8gZmlyc3QgY29uc2lkZXIgdGhlIHNwbGl0dGluZywgbm8/XG5cdFx0XHRpZiAodGhpcy5pbmNyZWFzZUluZGVudChwcmUpKSB7IGluZGVudCArPSAnXFx0JyB9O1xuXHRcdFx0aWYgKHRoaXMuZGVjcmVhc2VJbmRlbnQocHJlKSkgeyBpbmRlbnQgPSBpbmRlbnQuc2xpY2UoMSkgfTtcblx0XHRcdHRoaXMub253aGl0ZXNwYWNlKGUsJ1xcbicgKyBpbmRlbnQpO1xuXHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdyZXBhaXIgaW10YWcnKTtcblx0XHRcdGlmICghKHRoaXMuaXNQYWlyZWQoKSkpIHsgdGhpcy5yZXZhbGlkYXRlKHRydWUpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ2ltcGFpciBtdXRhdGVkJyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZhbGlkYXRlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlZmF1bHRWYWxpZGF0aW9uTW9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICd0b2tlbml6ZSc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmV2YWxpZGF0ZSA9IGZ1bmN0aW9uIChtb2RlLHdyaXRlKXtcblx0XHRcdC8vIHRyaWNreSBtb3RoZXJmdWNrZXIgLS0gbW9zdGx5IHVzZWZ1bCBmb3IgdmFsaWRhdGlvbnNcblx0XHRcdC8vIEkgc3VwcG9zZSB3ZSBjYW4gZG8gdGhpcyBhIHNpbXBsZXIgd2F5IC0tIGJ5IHR1cm5pbmdcblx0XHRcdC8vIG9mZiBvYnNlcnZlcnMgLS0gdGVtcG9yYXJpbHkgcmVwbGFjaW5nIGlubmVyIGNvZGUgZXRjXG5cdFx0XHRcblx0XHRcdC8vIHdoZW4gYSBibG9jayBjaGVja3MgdmFsaWRpdHkgaXQgc2hvdWxkIHByb2JhYmx5XG5cdFx0XHQvLyBzdWJzdGl0dXRlIGlubmVyIGludmFsaWQgcGFydHMgLSBzbyB0aGF0IHRoZSBibG9ja1xuXHRcdFx0Ly8gdGhpbmcgaXMgc3RpbGwgdmFsaWRcblx0XHRcdHZhciBzZWxmID0gdGhpcywgaGw7XG5cdFx0XHRpZihtb2RlID09PSB1bmRlZmluZWQpIG1vZGUgPSBzZWxmLmRlZmF1bHRWYWxpZGF0aW9uTW9kZSgpO1xuXHRcdFx0aWYod3JpdGUgPT09IHVuZGVmaW5lZCkgd3JpdGUgPSBmYWxzZTtcblx0XHRcdHZhciB3YXNJbnZhbGlkID0gc2VsZi5oYXNGbGFnKCdpbnZhbGlkJyk7XG5cdFx0XHR2YXIgb2xkU3RhdGUgPSBzZWxmLmhhc0ZsYWcoJ2ludmFsaWQnKTtcblx0XHRcdHZhciBzdGF0ZSA9IHNlbGYuY29kZVN0YXRlKCk7XG5cdFx0XHR2YXIgY29kZSA9IHN0YXRlLmNvZGU7XG5cdFx0XHRcblx0XHRcdGlmICghKHNlbGYuaXNQYWlyZWQoKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYubWFya0ludmFsaWQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnNvbGUubG9nKCd3aWxsIHJldmFsaWRhdGUgd2l0aCBjb2RlJyxjb2RlKTtcblx0XHRcdGNvbnNvbGUudGltZSgncmV2YWxpZGF0ZScpO1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAobW9kZSA9PSAnY29tcGlsZScpIHtcblx0XHRcdFx0XHRzZWxmLl9vdXRwdXQgPSBJbWJhYy5jb21waWxlKGNvZGUse2JhcmU6IHRydWV9KTtcblx0XHRcdFx0XHRzZWxmLl90b2tlbnMgPSBzZWxmLl9vdXRwdXQub3B0aW9ucy5fdG9rZW5zO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuX3Rva2VucyA9IEltYmFjLnRva2VuaXplKGNvZGUse2JhcmU6IHRydWV9KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0c2VsZi5tYXJrVmFsaWQoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5fdG9rZW5zID0gbnVsbDtcblx0XHRcdFx0c2VsZi5tYXJrSW52YWxpZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS50aW1lRW5kKCdyZXZhbGlkYXRlJyk7XG5cdFx0XHRcblx0XHRcdGlmICh3YXNJbnZhbGlkICYmIHNlbGYuX3Rva2Vucykge1xuXHRcdFx0XHQvLyBuZWVkIHRvIGZpeCBpbm5lciBmb3Igcm9vdFxuXHRcdFx0XHRpZiAoaGwgPSBIaWdobGlnaHRlci5oaWdobGlnaHQoY29kZSx7dG9rZW5zOiBzZWxmLl90b2tlbnMsaW5uZXI6IHRydWV9KSkge1xuXHRcdFx0XHRcdC8vIHRoaXMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgb3V0IGludG8gYSBzZXBhcmF0ZSBtZXRob2Rcblx0XHRcdFx0XHQvLyBwb3NzaWJseSBkbyBsb2FkU3RhdGUgLyBkdW1wU3RhdGVcblx0XHRcdFx0XHRzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5kb20oKS5pbm5lckhUTUwgPSBobDtcblx0XHRcdFx0XHRcdHN0YXRlLmludmFsaWRzLm1hcChmdW5jdGlvbihpbnYpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdFx0XHRcdGlmIChub2RlID0gc2VsZi52aWV3KCkubm9kZUF0UmVnaW9uKGludi5yZWdpb24sdHJ1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZS5yZXBsYWNlV2l0aChpbnYubm9kZSk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGlmIChzdGF0ZS5tYXJrZXIpIHsgcmV0dXJuIHNlbGYudmlldygpLnNlbCgpLnNldChzdGF0ZS5tYXJrZXIpIH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9wZW4oKSArICgnICcpLnJlcGVhdCh0aGlzLnNpemUoKSAtIDIpICsgdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0F0b21pYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdtdWF0ZWQgaW1jdXJseScpO1xuXHRcdFx0dGhpcy52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKHRoaXMuZGlydHlFeHRlbnQoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWN1cmx5JywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2N1cmx5Jyk7XG5cdFx0dGFnLnBhaXIoJ3snLCd9Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc3F1YXJlJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NxdWFyZScpO1xuXHRcdHRhZy5wYWlyKCdbJywnXScpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJldHRpZnkgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmxvZygncHJldHRpZnkhJyk7XG5cdFx0XHRlLmhhbmRsZWQoKTtcblx0XHRcdHZhciBpbmQgPSBlLnJlZ2lvbigpLmluZGVudCgpO1xuXHRcdFx0c2VsZi5sb2coJ3dpdGggaW5kZW50YXRpb24nLGluZCxpbmQubGVuZ3RoKTtcblx0XHRcdFxuXHRcdFx0c2VsZi52aWV3KCkub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuY2hpbGRyZW4oKSksIGxlbiA9IGFyeS5sZW5ndGgsIGNoaWxkLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Y2hpbGQgPSBhcnlbaV07XG5cdFx0XHRcdFx0cmVzLnB1c2goY2hpbGQubWF0Y2hlcygnLmNvbW1hLC5faW1vcGVuJykgPyAoXG5cdFx0XHRcdFx0XHRjaGlsZC5zZXROZXh0KCdcXG4nICsgaW5kICsgJ1xcdCcpXG5cdFx0XHRcdFx0KSA6ICgoY2hpbGQubWF0Y2hlcygnLl9pbWNsb3NlJykpICYmIChcblx0XHRcdFx0XHRcdGNoaWxkLnNldFByZXYoJ1xcbicgKyBpbmQpXG5cdFx0XHRcdFx0KSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcGFyZW5zJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3BhcmVucycpO1xuXHRcdHRhZy5wYWlyKCcoJywnKScpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub251bndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1wYWlyIG9udW53cmFwISEhJyxlKTtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0Ly8gbG9vayBhdCBwcmV2IGFuZCBuZXh0IGFzIHdlbGw/XG5cdFx0XHQvLyBzaG91bGQgZG8gdGhpcyB0aHJvdWdoIHRoZSB2aWV3XG5cdFx0XHR0aGlzLnNldENvZGUoJyAnICsgdGhpcy5jb2RlKCkuc2xpY2UoMSwtMSkpO1xuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLnJlcGFpcigpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaXN0cmluZycsICdpbXBhaXInLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdpc3RyaW5nJyk7XG5cdFx0dGFnLnBhaXIoJ1wiJywnXCInKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pZXhwcicsICdpbXBhaXInLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdpZXhwcicpO1xuXHRcdHRhZy5wYWlyKCd7JywnfScpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWJsb2NrcGFyYW1zJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2Jsb2NrcGFyYW1zJyk7XG5cdFx0dGFnLnBhaXIoJ3wnLCd8Jyk7XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbXRhZ25vZGUnLCAnaW1wYWlyJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnbm9kZScpO1xuXHRcdHRhZy5wYWlyKCc8JywnPicpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFpcmFibGUgPSBmdW5jdGlvbiAoc3RyLGUpe1xuXHRcdFx0cmV0dXJuIGlkeCQoc3RyLFsneycsJ1snLCcoJywnXCInLFwiJ1wiXSkgPj0gMDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9wZW4oKSArICgneCcpLnJlcGVhdCh0aGlzLnNpemUoKSAtIDIpICsgdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWZhdWx0VmFsaWRhdGlvbk1vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAnY29tcGlsZSc7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9ibG9jay5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbXJvb3QnLCAnaW1ibG9jaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcuX25vZGVUeXBlID0gJ2NvZGUnO1xuXHRcdC8vIGRlZiBzZWxmLmRvbVxuXHRcdC8vXHRAZG9tIHx8PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJylcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRyeVVuZGVudCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYubG9nKCd0cnlVbmRlbnQnKTtcblx0XHRcdHZhciBub2RlcyA9IGUudmlldygpLm5vZGVzSW5SZWdpb24oZS5yZWdpb24oKS5jbG9uZSgpLnN0YXJ0QXRMaW5lKCkpO1xuXHRcdFx0bm9kZXMubWFwKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdGlmIChtYXRjaC5ub2RlLm1hdGNoZXMoJy5faW1uZXdsaW5lJykgJiYgbWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0bWF0Y2gubm9kZS51bmRlbnQoKTtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkuY2FyZXQoKS5tb3ZlKC0xKTtcblx0XHRcdFx0XHQvLyBlLmNhcmV0Lm1vdmUoLTEpXG5cdFx0XHRcdFx0Ly8gZS5jYXJldC5leHBhbmQoMCwtMSlcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBlLm1vdmVDYXJldCA9IDBcblx0XHRcdGUuaGFuZGxlZCgpO1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5kb20oKS5hZGRFdmVudExpc3RlbmVyKCcnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROZXh0ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0dGhpcy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQcmV2ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0dmFyIGZpcnN0ID0gdGhpcy5kb20oKS5maXJzdENoaWxkO1xuXHRcdFx0Zmlyc3QgPyAodGhpcy5pbnNlcnRCZWZvcmUobm9kZSxmaXJzdCkpIDogKHRoaXMuYXBwZW5kQ2hpbGQobm9kZSkpO1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubGluZWJyZWFrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIHByZSA9IGUubGluZXN0cigncHJlJyk7XG5cdFx0XHR2YXIgaW5kZW50ID0gZS5pbmRlbnQoKTtcblx0XHRcdHZhciBuZXckID0gdGhpcy50ZXh0KCkuaW5zKCcnLGUucmVsUmVnaW9uKCkpO1xuXHRcdFx0Ly8gbmVlZCB0byBmaXJzdCBjb25zaWRlciB0aGUgc3BsaXR0aW5nLCBubz9cblx0XHRcdGlmICh0aGlzLmluY3JlYXNlSW5kZW50KHByZSkpIHsgaW5kZW50ICs9ICdcXHQnIH07XG5cdFx0XHRpZiAodGhpcy5kZWNyZWFzZUluZGVudChwcmUpKSB7IGluZGVudCA9IGluZGVudC5zbGljZSgxKSB9O1xuXHRcdFx0dGhpcy5vbndoaXRlc3BhY2UoZSwnXFxuJyArIGluZGVudCk7XG5cdFx0XHRyZXR1cm4gZS5oYW5kbGVkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdpbXJvb3QgbXV0YXRlZCcpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpcnR5RXh0ZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmxvZygnaW1yb290IGRpcnR5RXh0ZW50Jyk7XG5cdFx0XHQvLyBzdXBlclxuXHRcdFx0dmFyIG5vZGVzID0gc2VsZi5jaGlsZHJlbigpLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBuLmRvbSgpOyB9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y29kZTogc2VsZi5jb2RlKCksXG5cdFx0XHRcdG5vZGVzOiBub2Rlcyxcblx0XHRcdFx0cGFyZW50OiBzZWxmLmRvbSgpLFxuXHRcdFx0XHRjb250YWluczogZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHNlbGYuZG9tKCkuY29udGFpbnMoZWwuX2RvbSB8fCBlbCk7IH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9yb290LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGV4dGVybnM7XG5cdFxuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXHRcblx0dmFyIFNJTkdMRV9TVFIgPSAvXidbXiddKickLztcblx0dmFyIERPVUJMRV9TVFIgPSAvXlwiW15cIlxce10qXCIkLztcblx0dmFyIENPTU1FTlQgPSAvXlxcI1sgXFx0XVteXFxuXSokLztcblx0XG5cdERPVUJMRV9TVFIgPSAvXlwiKFteXFxcXFwiXFx7XXxcXFxcXFxcXHxcXFxcXCIpKlwiJC87XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1saXQnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltcmVnZXgnLCAnaW1saXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCdyZWdleCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhaXJpbmcgPSBmdW5jdGlvbiAoY2hyKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXZhbGlkYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcmVnID0gdGhpcy5jb2RlKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgb2JqID0gZXZhbChyZWcpO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyB9O1xuXHRcdFx0dGhpcy5sb2coJ3JlZ2V4IGlzJyxyZWcsb2JqKTtcblx0XHRcdHRoaXMuZmxhZygnaW52YWxpZCcsIW9iaik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ3JlZ2V4IG11dGF0ZWQnKTtcblx0XHRcdHJldHVybiB0aGlzLnJldmFsaWRhdGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAnLycgKyAnUicucmVwZWF0KHRoaXMuc2l6ZSgpIC0gMikgKyAnLyc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzQXRvbWljID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9saXRlcmFscy5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0Ly8gc2hvdWxkIHJhdGhlciByZWNvbmNpbGUgaW50byB0b2tlbiAtIG9yIHNvbWV0aGluZyBsaWtlIGl0XG5cdHZhciBuYW1lcyA9IHtcblx0XHQnLic6ICdkb3QnLFxuXHRcdCc9JzogJ2VxJyxcblx0XHQnPyc6ICdxJyxcblx0XHQnISc6ICd1bmFyeScsXG5cdFx0JzonOiAnY29sb24nLFxuXHRcdCcsJzogJ2NvbW1hJyxcblx0XHQnIyc6ICdoYXNoJyxcblx0XHQnKic6ICdtdWx0Jyxcblx0XHQnPj4nOiAnYml0c2hpZnQnXG5cdH07XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1vcCcsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnR5cGUoJ29wJyk7XG5cdFx0dGFnLmFsaWFzKCdyZWxhdGlvbicpO1xuXHRcdHRhZy5hbGlhcygnY29tcGFyZScpO1xuXHRcdHRhZy5hbGlhcygnY29tcG91bmRfYXNzaWduJyk7XG5cdFx0dGFnLmFsaWFzKCdhc3NpZ24nKTtcblx0XHR0YWcuYWxpYXMoJ2Jsb2NrX2FyZycpO1xuXHRcdHRhZy5hbGlhcygnc3BsYXQnKTtcblx0XHR0YWcuYWxpYXMoJ2xvZ2ljJyk7XG5cdFx0dGFnLmFsaWFzKCdtYXRoJyk7XG5cdFx0dGFnLmFsaWFzKCdzaGlmdCcpO1xuXHRcdHRhZy5hbGlhcygndW5hcnknKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuIElNLmlzT3AoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJhc2VDbGFzc2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5iYXNlQ2xhc3Nlcy5hcHBseSh0aGlzLGFyZ3VtZW50cykgKyAnICcgKyAobmFtZXNbdGhpcy5jb2RlKCldIHx8ICcnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAodG9rZW4pe1xuXHRcdFx0dmFyIHZhbCA9IHRva2VuICYmIHRva2VuLl92YWx1ZSB8fCB0aGlzLmNvZGUoKTtcblx0XHRcdHRoaXMuZG9tKCkuY2xhc3NOYW1lID0gKFwiX2ltIF9pbW9wIG9wIFwiICsgKG5hbWVzW3ZhbF0gfHwgJycpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIG1lcmdlIHdpdGggYSBtb3JlIGdlbmVyaWMgdmVyc2lvbiBmb3IgdG9rZW4gaW4gZ2VuZXJhbFxuXHRcdC8vIHNhbWUgZ29lcyBmb3IgdGV4dCBldGNcblx0XHR0YWcucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGFnLl9fc3VwZXJfXy5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5jb2RlKCkgPT0gJy8vJykge1xuXHRcdFx0XHR0aGlzLmxvZygnaXMgYSByZWdleCEhJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlY2xhc3NpZnkoJ3JlZ2V4Jyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0Ly8gbGluayByZWd1bGFyIG9wcyB0byBvcC1ub2RlXG5cdHJldHVybiAnKyAtICogLyA9ICsrIC0tID09ID09PSAhPSAhPT0gPiA8ID49IDw9ICYgJiYgfCB8fCBvciAuIDogPyAmPSB8fD0gJiY9ID8uID86ICwgISAuLiAuLi4gLjogPj4gPDwgIycuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24ob3ApIHtcblx0XHRyZXR1cm4gSU0uVHlwZXNbb3BdID0gSU0uVHlwZXMub3A7XG5cdH0pO1xuXHRcblx0XG5cdC8vIElNLlR5cGVzOmxvZ2ljID0gSU0uVHlwZXM6b3Bcblx0Ly8gSU0uVHlwZXM6Y29tcGFyZSA9IElNLlR5cGVzOm9wXG5cdC8vIElNLlR5cGVzOm1hdGggPSBJTS5UeXBlczpvcFxuXHQvLyBJTS5UeXBlczpzaGlmdCA9IElNLlR5cGVzOm9wXG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvb3BlcmF0b3JzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHQvLyB0aGlzIHNob3VsZCBiZSBtb3JlIGFkdmFuY2VkIHRoYW4gdGhpcywgbm8/XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0F0b21pYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFyc2VkID0gZnVuY3Rpb24gKGNvZGUsb2xkKXtcblx0XHRcdHRoaXMubG9nKFwiaW1zZWwgcmVwYXJzZWRcIixjb2RlLG9sZCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbHRhZycsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yX3RhZycpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGNsYXNzJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfY2xhc3MnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zZWxjb21iJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfY29tYmluYXRvcicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGF0dHJvcCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yX2F0dHJfb3AnKTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltc2VsYXR0cm9wJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfYXR0cl9vcCcpO1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL3NlbGVjdG9yLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWluc2VydCcsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlZyxpbnMpe1xuXHRcdFx0Y29uc29sZS5sb2coJ2luc2VydCBjb2RlIGludG8gaW1pbnNlcnQhIScsaW5zLHJlZyk7XG5cdFx0XHRcblx0XHRcdGlmIChpbnMgaW5zdGFuY2VvZiBJTS5UeXBlcy5mcmFnbWVudCkge1xuXHRcdFx0XHRpbnMgPSBpbnMuY29kZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChpbnMgaW5zdGFuY2VvZiBJTS5UeXBlcy5yYXcpIHtcblx0XHRcdFx0aW5zID0gaW5zLl9yYXc7XG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgaW5zPT0nc3RyaW5nJ3x8aW5zIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0XHRpbnMgPSAodGhpcy5jb2RlKCkgfHwgXCJcIikuaW5zKGlucyxyZWcpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zZXRDb2RlKGlucyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKCkubWF0Y2goL15bXFxuXFx0XFwgXSskLyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdpbWluc2VydCBtdXRhdGVkJyk7XG5cdFx0XHRcblx0XHRcdHZhciBkaXJ0eSA9IHRoaXMuZGlydHlFeHRlbnQoKTtcblx0XHRcdHRoaXMudmlldygpLmhpZ2hsaWdodGVyKCkucmVwYXJzZShkaXJ0eSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXdoaXRlc3BhY2UnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2FuUHJlcGVuZCA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWRhdGUoc3RyICsgdGhpcy5jb2RlKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHRcdHJldHVybiB0aGlzLnZhbGlkYXRlKHRoaXMuY29kZSgpICsgc3RyKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbW5ld2xpbmUnLCAnaW13aGl0ZXNwYWNlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnbmV3bGluZScpO1xuXHRcdHRhZy5hbGlhcygnXFxuJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0XHRpZiAoc3RyLm1hdGNoKC9eW1xcblxcdFxcIF0rJC8pKSB7XG5cdFx0XHRcdC8vIHNob3VsZCBub3QgcmVhbGx5IGJlIGFibGUgdG8gcHJlcGVuZCBoZXJlXG5cdFx0XHRcdC8vIGl0IHNob2xkIHJhdGhlciBpbnNlcnQgYSBuZXcgbmV3bGluZSBpblxuXHRcdFx0XHQvLyBhbiBpbWluc2VydCwgYW5kIHRoYXQgc2hvdWxkIGJlIGFibGUgdG9cblx0XHRcdFx0Ly8gZGVjaWRlIHRoYXQgbm8gcmVwYXJzZSBpcyBuZWVkZWRcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYodmFsID09PSB1bmRlZmluZWQpIHZhbCA9IHRoaXMuY29kZSgpO1xuXHRcdFx0cmV0dXJuIHZhbCA9PSAnXFxuJztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5pbnNlcnQodGhpcy5yZWdpb24oKS5lbmQoKSwnXFx0Jyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygndW5kZW50IG5ld2xpbmUnKTtcblx0XHRcdHZhciByZWcgPSB0aGlzLnJlZ2lvbigpLmNsb25lKCkuY29sbGFwc2UodHJ1ZSkuY2xvbmUoMCwxKTtcblx0XHRcdGlmIChyZWcudGV4dCgpID09ICdcXHQnKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdjYW4gdW5kZW50ISEnKTtcblx0XHRcdFx0dGhpcy52aWV3KCkuZXJhc2UocmVnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHZpZXcub2JzZXJ2ZXIucGF1c2UgZG9cblx0XHRcdC8vXHRuZXh0Lm9ycGhhbml6ZSBpZiBuZXh0Py5tYXRjaGVzKCcuX2ltdGFiJylcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBsb2cgJ2ltbmV3bGluZSBtdXRhdGVkISEnXG5cdFx0XHQvLyByZW1vdmUgbm9kZSBpZiBpdCBpcyBvcnBoYW5pemVkXG5cdFx0XHRpZiAodGhpcy5jb2RlKCkgPT0gJycpIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlbW92ZSB3aG9sZSBub2RlJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlcGFyc2UgbmV3bGluZScpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKHtub2RlczogW3RoaXMuZG9tKCldLGNvZGU6IHRoaXMuY29kZSgpfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zcGFjZScsICdpbXdoaXRlc3BhY2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCd3aGl0ZXNwYWNlJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYodmFsID09PSB1bmRlZmluZWQpIHZhbCA9IHRoaXMuY29kZSgpO1xuXHRcdFx0cmV0dXJuICgvXlsgXSskLykudGVzdCh2YWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdGhpcyBzaG91bGQgYmUgdGhlIGRlZmF1bHQgZm9yIGFsbCBub2Rlcywgbm8/XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoIW8uZGVlcCAmJiB0aGlzLnZhbGlkYXRlKHRoaXMuY29kZSgpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ubXV0YXRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zZW1pY29sb24nLCAnaW13aGl0ZXNwYWNlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VtaWNvbG9uJyk7XG5cdFx0dGFnLmFsaWFzKCc7Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltdGFiJywgJ2ltd2hpdGVzcGFjZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnR5cGUoJ3RhYicpO1xuXHRcdHRhZy5hbGlhcygnXFx0Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVkaXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoZS5pc1N1cnJvdW5kZWQoKSkge1xuXHRcdFx0XHR0aGlzLmxvZygnZGVsZXRlIHRhYj8hPycpO1xuXHRcdFx0XHRpZiAoZS50ZXh0KCkpIHsgLy8gb3RoZXJ3aXNlIHdlIHJlYWxseSBhcmUgZG9uZVxuXHRcdFx0XHRcdGUucmVkaXJlY3QodGhpcy5wcmV2KCkgfHwgdGhpcy5uZXh0KCkgfHwgdGhpcy5wYXJlbnQoKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZS5oYW5kbGVkKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRlLnJlZ2lvbigpLmNvbGxhcHNlKGZhbHNlKTtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmKHZhbCA9PT0gdW5kZWZpbmVkKSB2YWwgPSB0aGlzLmNvZGUoKTtcblx0XHRcdHJldHVybiB2YWwgPT0gJ1xcdCc7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1jb21tZW50JywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnY29tbWVudCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gQ09NTUVOVC50ZXN0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygnaW1jb21tZW50IG11dGF0ZWQnKTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLm11dGF0ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXM7XG5cdFx0XHR0aGlzLmxvZygncmVwYWlyIGNvbW1lbnQnKTtcblx0XHRcdHZhciByZWdpb24gPSB0aGlzLnJlZ2lvbigpLmVuZEF0TGluZSgpO1xuXHRcdFx0dmFyIGZ1bGwgPSByZWdpb24udGV4dCgpOyAvLyBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxhc3QgbGluZT9cblx0XHRcdHZhciBub2RlcyA9IHJlZ2lvbi5ub2RlcyhmYWxzZSk7XG5cdFx0XHR0aGlzLmxvZygnd2hvbGUgcmVnaW9uIHNob3VsZCBiZScscmVnaW9uLGZ1bGwsbm9kZXMpO1xuXHRcdFx0dGhpcy5sb2coJ2FsbCBub2Rlcycsbm9kZXMpO1xuXHRcdFx0XG5cdFx0XHQvLyBWRVJZIHRlbXBvcmFyeVxuXHRcdFx0aWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dGhpcy5zZXRDb2RlKGZ1bGwpO1xuXHRcdFx0XHR3aGlsZSAobm9kZXMubGVuZ3RoID4gMSl7XG5cdFx0XHRcdFx0dmFyIGVsID0gbm9kZXMucG9wKCk7XG5cdFx0XHRcdFx0ZWwubm9kZS5vcnBoYW5pemUoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnNlcnRlZCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzLnJlcGFpcigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRpZiAoIXRleHQubWF0Y2goL1tcXG5dLykpIHsgcmV0dXJuIHRydWUgfTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHQvLyBhbGxvdyBpbnNlcnRpbmcgYWRkaXRpb25hbCB0YWJzIGRpcmVjdGx5IGhlcmU/XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2VvZicpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvd2hpdGVzcGFjZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXdhcm4nLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ21lc3NhZ2UnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbWVzc2FnZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdidWlsdCBlcnJvciB3aXRoIGVycm9yJyx0aGlzLm9iamVjdCgpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWVycicsICdpbXdhcm4nKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Fubm90YXRpb25zLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciBSb3V0ZXIgPSByZXF1aXJlKCcuL3JvdXRlcicpLlJvdXRlcjtcblx0XG5cdGZ1bmN0aW9uIEFwcCgpe1xuXHRcdHRoaXMuc2V0Q2FjaGUoe30pO1xuXHRcdHRoaXMuc2V0RGVwcyh7fSk7XG5cdFx0dGhpcy5yZXNldCgpO1xuXHRcdHRoaXMudGljaygpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkFwcCA9IEFwcDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdEFwcC5wcm90b3R5cGUucmVxID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZXE7IH1cblx0QXBwLnByb3RvdHlwZS5zZXRSZXEgPSBmdW5jdGlvbih2KXsgdGhpcy5fcmVxID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0QXBwLnByb3RvdHlwZS5yZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3JlczsgfVxuXHRBcHAucHJvdG90eXBlLnNldFJlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLmRlcHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RlcHM7IH1cblx0QXBwLnByb3RvdHlwZS5zZXREZXBzID0gZnVuY3Rpb24odil7IHRoaXMuX2RlcHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLnNpdGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3NpdGU7IH1cblx0QXBwLnByb3RvdHlwZS5zZXRTaXRlID0gZnVuY3Rpb24odil7IHRoaXMuX3NpdGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jYWNoZTsgfVxuXHRBcHAucHJvdG90eXBlLnNldENhY2hlID0gZnVuY3Rpb24odil7IHRoaXMuX2NhY2hlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5zZXRDYWNoZSh7fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnJvdXRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9yb3V0ZXIgfHwgKHRoaXMuX3JvdXRlciA9IG5ldyBSb3V0ZXIodGhpcykpO1xuXHR9O1xuXHRcblx0QXBwLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIEltYmEuU0VSVkVSID8gKHRoaXMucmVxKCkucGF0aCkgOiAodGhpcy5fcGF0aCk7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gJyc7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gSW1iYS5TRVJWRVIgPyAoJycpIDogKGRvY3VtZW50LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKTtcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghSW1iYS5TRVJWRVIpIHtcblx0XHRcdHRoaXMuX3BhdGggPSBkb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QXBwLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdEltYmEuc2NoZWR1bGUodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnVuc2NoZWR1bGUgPSBmdW5jdGlvbiAoKXtcblx0XHRJbWJhLnVuc2NoZWR1bGUodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLmZldGNoRG9jdW1lbnQgPSBmdW5jdGlvbiAoc3JjLGNiKXtcblx0XHRcblx0XHR2YXIgZGVwc18sICQxLCAkMywgJDI7XG5cdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnZmV0Y2ggZG9jdW1lbnQnLHNyYyk7XG5cdFx0XHRcblx0XHRcdHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cdFx0XHR2YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblx0XHRcdFxuXHRcdFx0dmFyIGZpbGVwYXRoID0gKFwiXCIgKyBfX2Rpcm5hbWUgKyBcIi8uLi9kb2NzL1wiICsgc3JjKS5yZXBsYWNlKC9cXC9cXC8vZywnLycpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVzID0gdGhpcy5kZXBzKClbc3JjXTtcblx0XHRcdFxuXHRcdFx0aWYgKCFyZXMpIHtcblx0XHRcdFx0dmFyIGJvZHkgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgsJ3V0Zi04Jyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3JjLm1hdGNoKC9cXC5tZCQvKSkge1xuXHRcdFx0XHRcdHJlcyA9IHRoaXMuTWFya2Rvd24ucmVuZGVyKGJvZHkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNyYy5tYXRjaCgvXFwuanNvbiQvKSkge1xuXHRcdFx0XHRcdHJlcyA9IEpTT04ucGFyc2UoYm9keSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3JjLm1hdGNoKC9cXC5pbWJhJC8pKSB7XG5cdFx0XHRcdFx0dmFyIGh0bWwgPSB0aGlzLkhpZ2hsaWdodGVyLmhpZ2hsaWdodChib2R5LHttb2RlOiAnZnVsbCd9KTtcblx0XHRcdFx0XHRyZXMgPSB7Ym9keTogYm9keSxodG1sOiBodG1sfTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdChkZXBzXyA9IHRoaXMuZGVwcygpKVsoJDEgPSBzcmMpXSB8fCAoZGVwc19bJDFdID0gcmVzKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuc2l0ZSgpKSB7XG5cdFx0XHRcdCgkMyA9IHRoaXMuc2l0ZSgpLmRlcHMoKSlbKCQyID0gc3JjKV0gfHwgKCQzWyQyXSA9IHJlcyk7XG5cdFx0XHR9O1xuXHRcdFx0Y2IgJiYgY2IocmVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKERFUFNbc3JjXSkge1xuXHRcdFx0XHRjYiAmJiBjYihERVBTW3NyY10pO1xuXHRcdFx0XHRyZXR1cm4ge3RoZW46IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYocmVzKTsgfX07IC8vIGZha2UgcHJvbWlzZSBoYWNrXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHR4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdERFUFNbc3JjXSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdHJldHVybiBjYiAmJiBjYihERVBTW3NyY10pO1xuXHRcdFx0XHQvLyBYSFIgPSB4aHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3Jlc3BvbnNlIGhlcmUnLHhocjpyZXNwb25zZVRleHRcblx0XHRcdH0pO1xuXHRcdFx0eGhyLm9wZW4oXCJHRVRcIixzcmMpO1xuXHRcdFx0eGhyLnNlbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRyZXR1cm4gQXBwO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hcHAuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0Ly8gZXh0ZXJucztcblx0XG5cdGZ1bmN0aW9uIFJvdXRlcihhcHApe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLl9hcHAgPSBhcHA7XG5cdFx0XG5cdFx0aWYgKEltYmEuaXNDbGllbnQoKSkge1xuXHRcdFx0d2luZG93Lm9ucG9wc3RhdGUgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHNlbGYucmVmcmVzaCgpO1xuXHRcdFx0XHRjb25zb2xlLmxvZygncG9wc3RhdGUnKTtcblx0XHRcdFx0cmV0dXJuIEltYmEuc2V0VGltZW91dCgwLGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0c2VsZjtcblx0fTtcblx0XG5cdGV4cG9ydHMuUm91dGVyID0gUm91dGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0Um91dGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXRoOyB9XG5cdFJvdXRlci5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRSb3V0ZXIuc2x1ZyA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCcnKS50b0xvd2VyQ2FzZSgpOyAvLyB0cmltXG5cdFx0Ly8gcmVtb3ZlIGFjY2VudHMsIHN3YXAgw7EgZm9yIG4sIGV0Y1xuXHRcdHZhciBmcm9tID0gXCLDoMOhw6TDosOlw6jDqcOrw6rDrMOtw6/DrsOyw7PDtsO0w7nDusO8w7vDscOnwrcvXyw6O1wiO1xuXHRcdHZhciB0byA9IFwiYWFhYWFlZWVlaWlpaW9vb291dXV1bmMtLS0tLS1cIjtcblx0XHRcblx0XHQvLyBmb3IgKHZhciBpPTAsIGw9ZnJvbS5sZW5ndGggOyBpPGwgOyBpKyspXG5cdFx0Ly8gXHRzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGZyb20uY2hhckF0KGkpLCAnZycpLCB0by5jaGFyQXQoaSkpXG5cdFx0XG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoL1teYS16MC05IC1dL2csJycpOyAvLyByZW1vdmUgaW52YWxpZCBjaGFyc1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9cXHMrL2csJy0nKTsgLy8gY29sbGFwc2Ugd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBieSAtXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoLy0rL2csJy0nKTsgLy8gY29sbGFwc2UgZGFzaGVzXG5cdFx0XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblx0XG5cdFJvdXRlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um91dGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcC5wYXRoKCk7XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYXBwLmhhc2goKTtcblx0fTtcblx0XG5cdFJvdXRlci5wcm90b3R5cGUuZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGgoKTtcblx0XHR2YXIgbSA9IHBhdGgubWF0Y2goL1xcLihbXlxcL10rKSQvKTtcblx0XHRyZXR1cm4gbSAmJiBtWzFdIHx8ICcnO1xuXHR9O1xuXHRcblx0Um91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChocmVmLHN0YXRlLHJlcGxhY2Upe1xuXHRcdGlmKHN0YXRlID09PSB1bmRlZmluZWQpIHN0YXRlID0ge307XG5cdFx0aWYocmVwbGFjZSA9PT0gdW5kZWZpbmVkKSByZXBsYWNlID0gZmFsc2U7XG5cdFx0aWYgKGhyZWYgPT0gJy9pbnN0YWxsJykge1xuXHRcdFx0Ly8gcmVkaXJlY3RzIGhlcmVcblx0XHRcdGhyZWYgPSAnL2d1aWRlcyN0b2MtZ2V0dGluZy1zdGFydGVkLWluc3RhbGxhdGlvbic7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAocmVwbGFjZSkge1xuXHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsbnVsbCxocmVmKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsbnVsbCxocmVmKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghaHJlZi5tYXRjaCgvXFwjLykpIHtcblx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLDApO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLnNjb3BlZCA9IGZ1bmN0aW9uIChyZWcscGFydCl7XG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGgoKSArICcjJyArIHRoaXMuaGFzaCgpO1xuXHRcdGlmICgodHlwZW9mIHJlZz09J3N0cmluZyd8fHJlZyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHZhciBueHQgPSBwYXRoW3JlZy5sZW5ndGhdO1xuXHRcdFx0cmV0dXJuIHBhdGguc3Vic3RyKDAscmVnLmxlbmd0aCkgPT0gcmVnICYmICghbnh0IHx8IG54dCA9PSAnLScgfHwgbnh0ID09ICcvJyB8fCBueHQgPT0gJyMnIHx8IG54dCA9PSAnPycgfHwgbnh0ID09ICdfJyk7XG5cdFx0fSBlbHNlIGlmIChyZWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdHZhciBtID0gcGF0aC5tYXRjaChyZWcpO1xuXHRcdFx0cmV0dXJuIHBhcnQgJiYgbSA/IChtW3BhcnRdKSA6IChtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHJlZyxwYXJ0KXtcblx0XHR2YXIgcGF0aCA9IHRoaXMucGF0aCgpICsgJyMnICsgdGhpcy5oYXNoKCk7XG5cdFx0XG5cdFx0aWYgKCh0eXBlb2YgcmVnPT0nc3RyaW5nJ3x8cmVnIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0cmV0dXJuIHBhdGggPT0gcmVnO1xuXHRcdH0gZWxzZSBpZiAocmVnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHR2YXIgbSA9IHBhdGgubWF0Y2gocmVnKTtcblx0XHRcdHJldHVybiBwYXJ0ICYmIG0gPyAobVtwYXJ0XSkgOiAobSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9O1xuXHRyZXR1cm4gUm91dGVyO1xuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcm91dGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRyZXF1aXJlKCcuL2Jhc2UnKTtcblx0cmVxdWlyZSgnLi9tYXJrZG93bicpO1xuXHRcblx0cmVxdWlyZSgnLi9zaXRlJyk7XG5cdHJlcXVpcmUoJy4vbmF2Jyk7XG5cdHJlcXVpcmUoJy4vcGFnZScpO1xuXHRyZXF1aXJlKCcuL2hvbWUnKTtcblx0cmVxdWlyZSgnLi9ibG9nJyk7XG5cdHJlcXVpcmUoJy4vZ3VpZGVzJyk7XG5cdHJlcXVpcmUoJy4vZG9jcycpO1xuXHRyZXR1cm4gcmVxdWlyZSgnLi9zbmlwcGV0Jyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2luZGV4LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZXh0ZW5kVGFnKCdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm91dGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um91dGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvdXRlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIdG1sID0gZnVuY3Rpb24gKGh0bWwpe1xuXHRcdFx0dGhpcy5fZG9tLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAocm91dGUpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEFQUC5yb3V0ZXIoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVyb3V0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5mbGFnKCdzY29wZWQnLHRoaXMucm91dGVyKCkuc2NvcGVkKHRoaXMucm91dGUoKSx0aGlzKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdzZWxlY3RlZCcsdGhpcy5yb3V0ZXIoKS5tYXRjaCh0aGlzLnJvdXRlKCksdGhpcykpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0dGhpcy5jc3MoJ3RyYW5zZm9ybScsdmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY3NzKCd0cmFuc2Zvcm0nKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZXh0ZW5kVGFnKCdzY3JpcHQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4gPSB2YWx1ZTtcblx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZXh0ZW5kVGFnKCdjYW52YXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZHByID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZHByIHx8ICh0aGlzLl9kcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpe1xuXHRcdFx0aWYgKHdpZHRoICE9IHRoaXMuX3dpZHRoKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkud2lkdGggPSB3aWR0aCAqIHRoaXMuZHByKCk7XG5cdFx0XHRcdHRoaXMuY3NzKHt3aWR0aDogd2lkdGh9KTtcblx0XHRcdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCl7XG5cdFx0XHRpZiAoaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmhlaWdodCA9IGhlaWdodCAqIHRoaXMuZHByKCk7XG5cdFx0XHRcdHRoaXMuY3NzKHtoZWlnaHQ6IGhlaWdodH0pO1xuXHRcdFx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5leHRlbmRUYWcoJ2EnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucm91dGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9yb3V0ZSB8fCB0aGlzLmhyZWYoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250YXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoZS5ldmVudCgpLm1ldGFLZXkgfHwgZS5ldmVudCgpLmFsdEtleSkge1xuXHRcdFx0XHRlLl9yZXNwb25kZXIgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5ocmVmKClbMF0gPT0gJyMnIHx8IHRoaXMuaHJlZigpWzBdID09ICcvJykge1xuXHRcdFx0XHRlLmNhbmNlbCgpLmhhbHQoKTtcblx0XHRcdFx0dGhpcy5yb3V0ZXIoKS5nbyh0aGlzLmhyZWYoKSx7fSk7XG5cdFx0XHRcdEltYmEuRXZlbnRzLnRyaWdnZXIoJ3JvdXRlJyx0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXJvdXRlKCk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2Jhc2UuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gZm9yIG1hcmtkb3duIHJlbmRlcmluZ1xuXHR0YWckLmRlZmluZVRhZygnbWQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19zcmMgPSB7d2F0Y2g6ICdyZWxvYWQnLG5hbWU6ICdzcmMnfTtcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5zcmMoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJyx2KTsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMucmVsb2FkICYmIHRoaXMucmVsb2FkKHYsYSx0aGlzLl9fc3JjKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19odG1sID0ge3dhdGNoOiAnaHRtbERpZFNldCcsbmFtZTogJ2h0bWwnfTtcblx0XHR0YWcucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2h0bWw7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEh0bWwgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5odG1sKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5faHRtbCA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmh0bWxEaWRTZXQgJiYgdGhpcy5odG1sRGlkU2V0KHYsYSx0aGlzLl9faHRtbCkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRvYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZG9jOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREb2MgPSBmdW5jdGlvbih2KXsgdGhpcy5fZG9jID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5naHNyYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIChcImh0dHBzOi8vZ2l0aHViLmNvbS9zb21lYmVlL2ltYmEuaW8vYmxvYi9tYXN0ZXIvZG9jc1wiICsgdGhpcy5zcmMoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmh0bWxEaWRTZXQgPSBmdW5jdGlvbiAoaHRtbCl7XG5cdFx0XHR0aGlzLmJvZHkoKS5kb20oKS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0dGhpcy5zZXR1cCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCkgKyAnLm1kJyxmdW5jdGlvbihkb2MpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5hc3NlbWJsZShkb2MpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsZi5fc25pcHBldHMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuX3NuaXBwZXRzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0YXJ5W2ldLmVuZCgpOyAvLyBzaW11bGF0ZSByZWFsIHJlbmRlcmluZyBoZXJlP1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gbm90IG9uIGZyb250cGFnZT8hXG5cdFx0dGFnLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uIChkb2Mpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnbWQnKS5zZXRIdG1sKGRvYy5ib2R5KS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRhZy5fX3N1cGVyX18uYnVpbGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0aWYgKEltYmEuaXNDbGllbnQoKSAmJiB0aGlzLnNyYygpKSB7IHJldHVybiB0aGlzLnJlbG9hZCgpIH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gbG9nIFwiYXdha2VuZWQgbWQgZnJvbSBjbGllbnQoISlcIlxuXHRcdFx0dGhpcy5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0Jyx0aGlzKS50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uIChodG1sKXtcblx0XHRcdHRoaXMuX2RvbS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0dGhpcy5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0Jyx0aGlzKS50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdyZWxvYWRpbmcgbWFya2Rvd24nXG5cdFx0XHRcdHNlbGYuX3NuaXBwZXRzID0gW107XG5cdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCkgKyAnLm1kJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncmV0dXJuZWQgZnJvbSBtYXJrZG93biBoZXJlPyEnLHJlc1xuXHRcdFx0XHRcdHNlbGYuYXNzZW1ibGUoKHNlbGYuc2V0RG9jKHJlcykscmVzKSk7XG5cdFx0XHRcdFx0c2VsZi5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0JyxzZWxmKS50b0FycmF5KCk7XG5cdFx0XHRcdFx0c2VsZi5wYXJlbnQoKS5kb20oKS5zY3JvbGxUb3AgPSAwO1xuXHRcdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblx0XG5cdC8vIGRlZmluZSByZW5kZXJlclxuXHR2YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG5cdHZhciBtZHIgPSBuZXcgKG1hcmtlZC5SZW5kZXJlcikoKTtcblx0XG5cdG1kci5oZWFkaW5nID0gZnVuY3Rpb24gKHRleHQsbHZsKXtcblx0XHRyZXR1cm4gKFwiPGhcIiArIGx2bCArIFwiPlwiICsgdGV4dCArIFwiPC9oXCIgKyBsdmwgKyBcIj5cIik7XG5cdH07XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ21hcmtlZCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXJlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDb250ZW50KHRleHQsMCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAodmFsLHR5cCl7XG5cdFx0XHRpZiAodmFsICE9IHRoaXMuX2NvbnRlbnQpIHtcblx0XHRcdFx0dGhpcy5fY29udGVudCA9IHZhbDtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSBtYXJrZWQodmFsLHtyZW5kZXJlcjogbWRyfSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL21hcmtkb3duLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTQsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWRcbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eXFxuKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rXFxuKikrLyxcbiAgZmVuY2VzOiBub29wLFxuICBocjogL14oICpbLSpfXSl7Myx9ICooPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICooW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS8sXG4gIG5wdGFibGU6IG5vb3AsXG4gIGxoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICooPzpcXG4rfCQpLyxcbiAgYmxvY2txdW90ZTogL14oICo+W15cXG5dKyhcXG4oPyFkZWYpW15cXG5dKykqXFxuKikrLyxcbiAgbGlzdDogL14oICopKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICBodG1sOiAvXiAqKD86Y29tbWVudCAqKD86XFxufFxccyokKXxjbG9zZWQgKig/OlxcbnsyLH18XFxzKiQpfGNsb3NpbmcgKig/OlxcbnsyLH18XFxzKiQpKS8sXG4gIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICtbXCIoXShbXlxcbl0rKVtcIildKT8gKig/Olxcbit8JCkvLFxuICB0YWJsZTogbm9vcCxcbiAgcGFyYWdyYXBoOiAvXigoPzpbXlxcbl0rXFxuPyg/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXx0YWd8ZGVmKSkrKVxcbiovLFxuICB0ZXh0OiAvXlteXFxuXSsvXG59O1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkK1xcLikvO1xuYmxvY2suaXRlbSA9IC9eKCAqKShidWxsKSBbXlxcbl0qKD86XFxuKD8hXFwxYnVsbCApW15cXG5dKikqLztcbmJsb2NrLml0ZW0gPSByZXBsYWNlKGJsb2NrLml0ZW0sICdnbScpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgpO1xuXG5ibG9jay5saXN0ID0gcmVwbGFjZShibG9jay5saXN0KVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/OlstKl9dICopezMsfSg/OlxcXFxuK3wkKSknKVxuICAoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgKCk7XG5cbmJsb2NrLmJsb2NrcXVvdGUgPSByZXBsYWNlKGJsb2NrLmJsb2NrcXVvdGUpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuYmxvY2suX3RhZyA9ICcoPyEoPzonXG4gICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlJ1xuICArICd8dmFyfHNhbXB8a2JkfHN1YnxzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG8nXG4gICsgJ3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZylcXFxcYilcXFxcdysoPyE6L3xbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJztcblxuYmxvY2suaHRtbCA9IHJlcGxhY2UoYmxvY2suaHRtbClcbiAgKCdjb21tZW50JywgLzwhLS1bXFxzXFxTXSo/LS0+LylcbiAgKCdjbG9zZWQnLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LylcbiAgKCdjbG9zaW5nJywgLzx0YWcoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vKVxuICAoL3RhZy9nLCBibG9jay5fdGFnKVxuICAoKTtcblxuYmxvY2sucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnaHInLCBibG9jay5ocilcbiAgKCdoZWFkaW5nJywgYmxvY2suaGVhZGluZylcbiAgKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAoJ2Jsb2NrcXVvdGUnLCBibG9jay5ibG9ja3F1b3RlKVxuICAoJ3RhZycsICc8JyArIGJsb2NrLl90YWcpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IG1lcmdlKHt9LCBibG9jayk7XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGZlbmNlczogL14gKihgezMsfXx+ezMsfSlbIFxcLl0qKFxcUyspPyAqXFxuKFtcXHNcXFNdKj8pXFxzKlxcMSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogL14vLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKyhbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpL1xufSk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCcoPyEnLCAnKD8hJ1xuICAgICsgYmxvY2suZ2ZtLmZlbmNlcy5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDInKSArICd8J1xuICAgICsgYmxvY2subGlzdC5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDMnKSArICd8JylcbiAgKCk7XG5cbi8qKlxuICogR0ZNICsgVGFibGVzIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay50YWJsZXMgPSBtZXJnZSh7fSwgYmxvY2suZ2ZtLCB7XG4gIG5wdGFibGU6IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLFxuICB0YWJsZTogL14gKlxcfCguKylcXG4gKlxcfCggKlstOl0rWy18IDpdKilcXG4oKD86ICpcXHwuKig/OlxcbnwkKSkqKVxcbiovXG59KTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbnMubGlua3MgPSB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMucnVsZXMgPSBibG9jay5ub3JtYWw7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLnRhYmxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLmdmbTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgQmxvY2sgUnVsZXNcbiAqL1xuXG5MZXhlci5ydWxlcyA9IGJsb2NrO1xuXG4vKipcbiAqIFN0YXRpYyBMZXggTWV0aG9kXG4gKi9cblxuTGV4ZXIubGV4ID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xufTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzaW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKHNyYykge1xuICBzcmMgPSBzcmNcbiAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpXG4gICAgLnJlcGxhY2UoL1xcdTI0MjQvZywgJ1xcbicpO1xuXG4gIHJldHVybiB0aGlzLnRva2VuKHNyYywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIExleGluZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uKHNyYywgdG9wLCBicSkge1xuICB2YXIgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKVxuICAgICwgbmV4dFxuICAgICwgbG9vc2VcbiAgICAsIGNhcFxuICAgICwgYnVsbFxuICAgICwgYlxuICAgICwgaXRlbVxuICAgICwgc3BhY2VcbiAgICAsIGlcbiAgICAsIGw7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIG5ld2xpbmVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5uZXdsaW5lLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc3BhY2UnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eIHs0fS9nbSwgJycpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgID8gY2FwLnJlcGxhY2UoL1xcbiskLywgJycpXG4gICAgICAgICAgOiBjYXBcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZmVuY2VzIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZmVuY2VzLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIGxhbmc6IGNhcFsyXSxcbiAgICAgICAgdGV4dDogY2FwWzNdIHx8ICcnXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgbm8gbGVhZGluZyBwaXBlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5ucHRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsyXSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaHInXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJsb2NrcXVvdGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ibG9ja3F1b3RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcblxuICAgICAgLy8gUGFzcyBgdG9wYCB0byBrZWVwIHRoZSBjdXJyZW50XG4gICAgICAvLyBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgLy8gaG93IG1hcmtkb3duLnBsIHdvcmtzLlxuICAgICAgdGhpcy50b2tlbihjYXAsIHRvcCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlzdFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpc3QuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgYnVsbCA9IGNhcFsyXTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X3N0YXJ0JyxcbiAgICAgICAgb3JkZXJlZDogYnVsbC5sZW5ndGggPiAxXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG4gICAgICBjYXAgPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5pdGVtKTtcblxuICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgbCA9IGNhcC5sZW5ndGg7XG4gICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGNhcFtpXTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3QgaXRlbSdzIGJ1bGxldFxuICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuICAgICAgICBzcGFjZSA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1xcLikgKy8sICcnKTtcblxuICAgICAgICAvLyBPdXRkZW50IHdoYXRldmVyIHRoZVxuICAgICAgICAvLyBsaXN0IGl0ZW0gY29udGFpbnMuIEhhY2t5LlxuICAgICAgICBpZiAofml0ZW0uaW5kZXhPZignXFxuICcpKSB7XG4gICAgICAgICAgc3BhY2UgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgaXRlbSA9ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgID8gaXRlbS5yZXBsYWNlKG5ldyBSZWdFeHAoJ14gezEsJyArIHNwYWNlICsgJ30nLCAnZ20nKSwgJycpXG4gICAgICAgICAgICA6IGl0ZW0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5leHQgbGlzdCBpdGVtIGJlbG9uZ3MgaGVyZS5cbiAgICAgICAgLy8gQmFja3BlZGFsIGlmIGl0IGRvZXMgbm90IGJlbG9uZyBpbiB0aGlzIGxpc3QuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnRMaXN0cyAmJiBpICE9PSBsIC0gMSkge1xuICAgICAgICAgIGIgPSBibG9jay5idWxsZXQuZXhlYyhjYXBbaSArIDFdKVswXTtcbiAgICAgICAgICBpZiAoYnVsbCAhPT0gYiAmJiAhKGJ1bGwubGVuZ3RoID4gMSAmJiBiLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgICBzcmMgPSBjYXAuc2xpY2UoaSArIDEpLmpvaW4oJ1xcbicpICsgc3JjO1xuICAgICAgICAgICAgaSA9IGwgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAvLyBVc2U6IC8oXnxcXG4pKD8hIClbXlxcbl0rXFxuXFxuKD8hXFxzKiQpL1xuICAgICAgICAvLyBmb3IgZGlzY291bnQgYmVoYXZpb3IuXG4gICAgICAgIGxvb3NlID0gbmV4dCB8fCAvXFxuXFxuKD8hXFxzKiQpLy50ZXN0KGl0ZW0pO1xuICAgICAgICBpZiAoaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBuZXh0ID0gaXRlbS5jaGFyQXQoaXRlbS5sZW5ndGggLSAxKSA9PT0gJ1xcbic7XG4gICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogbG9vc2VcbiAgICAgICAgICAgID8gJ2xvb3NlX2l0ZW1fc3RhcnQnXG4gICAgICAgICAgICA6ICdsaXN0X2l0ZW1fc3RhcnQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgIHRoaXMudG9rZW4oaXRlbSwgZmFsc2UsIGJxKTtcblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtX2VuZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHRtbFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3BhcmFncmFwaCdcbiAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlZlxuICAgIGlmICgoIWJxICYmIHRvcCkgJiYgKGNhcCA9IHRoaXMucnVsZXMuZGVmLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5saW5rc1tjYXBbMV0udG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy50YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC8oPzogKlxcfCAqKT9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXVxuICAgICAgICAgIC5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJylcbiAgICAgICAgICAuc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMucGFyYWdyYXBoLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHRleHQ6IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgIDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgLy8gVG9wLWxldmVsIHNob3VsZCBuZXZlciByZWFjaCBoZXJlLlxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGlubGluZSA9IHtcbiAgZXNjYXBlOiAvXlxcXFwoW1xcXFxgKnt9XFxbXFxdKCkjK1xcLS4hXz5dKS8sXG4gIGF1dG9saW5rOiAvXjwoW14gPl0rKEB8OlxcLylbXiA+XSspPi8sXG4gIHVybDogbm9vcCxcbiAgdGFnOiAvXjwhLS1bXFxzXFxTXSo/LS0+fF48XFwvP1xcdysoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vLFxuICBsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXChocmVmXFwpLyxcbiAgcmVmbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gIG5vbGluazogL14hP1xcWygoPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXSkqKVxcXS8sXG4gIHN0cm9uZzogL15fXyhbXFxzXFxTXSs/KV9fKD8hXyl8XlxcKlxcKihbXFxzXFxTXSs/KVxcKlxcKig/IVxcKikvLFxuICBlbTogL15cXGJfKCg/OlteX118X18pKz8pX1xcYnxeXFwqKCg/OlxcKlxcKnxbXFxzXFxTXSkrPylcXCooPyFcXCopLyxcbiAgY29kZTogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLFxuICBicjogL14gezIsfVxcbig/IVxccyokKS8sXG4gIGRlbDogbm9vcCxcbiAgdGV4dDogL15bXFxzXFxTXSs/KD89W1xcXFw8IVxcW18qYF18IHsyLH1cXG58JCkvXG59O1xuXG5pbmxpbmUuX2luc2lkZSA9IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLztcbmlubGluZS5faHJlZiA9IC9cXHMqPD8oW1xcc1xcU10qPyk+Pyg/OlxccytbJ1wiXShbXFxzXFxTXSo/KVsnXCJdKT9cXHMqLztcblxuaW5saW5lLmxpbmsgPSByZXBsYWNlKGlubGluZS5saW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gICgpO1xuXG5pbmxpbmUucmVmbGluayA9IHJlcGxhY2UoaW5saW5lLnJlZmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS9cbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IHJlcGxhY2UoaW5saW5lLmVzY2FwZSkoJ10pJywgJ358XSknKSgpLFxuICB1cmw6IC9eKGh0dHBzPzpcXC9cXC9bXlxcczxdK1tePC4sOjtcIicpXFxdXFxzXSkvLFxuICBkZWw6IC9efn4oPz1cXFMpKFtcXHNcXFNdKj9cXFMpfn4vLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS50ZXh0KVxuICAgICgnXXwnLCAnfl18JylcbiAgICAoJ3wnLCAnfGh0dHBzPzovL3wnKVxuICAgICgpXG59KTtcblxuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogcmVwbGFjZShpbmxpbmUuYnIpKCd7Mix9JywgJyonKSgpLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS5nZm0udGV4dCkoJ3syLH0nLCAnKicpKClcbn0pO1xuXG4vKipcbiAqIElubGluZSBMZXhlciAmIENvbXBpbGVyXG4gKi9cblxuZnVuY3Rpb24gSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMubGlua3MgPSBsaW5rcztcbiAgdGhpcy5ydWxlcyA9IGlubGluZS5ub3JtYWw7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKCF0aGlzLmxpbmtzKSB7XG4gICAgdGhyb3cgbmV3XG4gICAgICBFcnJvcignVG9rZW5zIGFycmF5IHJlcXVpcmVzIGEgYGxpbmtzYCBwcm9wZXJ0eS4nKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuYnJlYWtzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmdmbTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgdGhpcy5ydWxlcyA9IGlubGluZS5wZWRhbnRpYztcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBJbmxpbmUgUnVsZXNcbiAqL1xuXG5JbmxpbmVMZXhlci5ydWxlcyA9IGlubGluZTtcblxuLyoqXG4gKiBTdGF0aWMgTGV4aW5nL0NvbXBpbGluZyBNZXRob2RcbiAqL1xuXG5JbmxpbmVMZXhlci5vdXRwdXQgPSBmdW5jdGlvbihzcmMsIGxpbmtzLCBvcHRpb25zKSB7XG4gIHZhciBpbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpO1xuICByZXR1cm4gaW5saW5lLm91dHB1dChzcmMpO1xufTtcblxuLyoqXG4gKiBMZXhpbmcvQ29tcGlsaW5nXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKHNyYykge1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGxpbmtcbiAgICAsIHRleHRcbiAgICAsIGhyZWZcbiAgICAsIGNhcDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gZXNjYXBlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZXNjYXBlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBjYXBbMV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhdXRvbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmF1dG9saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gY2FwWzFdLmNoYXJBdCg2KSA9PT0gJzonXG4gICAgICAgICAgPyB0aGlzLm1hbmdsZShjYXBbMV0uc3Vic3RyaW5nKDcpKVxuICAgICAgICAgIDogdGhpcy5tYW5nbGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRoaXMubWFuZ2xlKCdtYWlsdG86JykgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB1cmwgKGdmbSlcbiAgICBpZiAoIXRoaXMuaW5MaW5rICYmIChjYXAgPSB0aGlzLnJ1bGVzLnVybC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFnXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGFnLmV4ZWMoc3JjKSkge1xuICAgICAgaWYgKCF0aGlzLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKVxuICAgICAgICAgIDogZXNjYXBlKGNhcFswXSlcbiAgICAgICAgOiBjYXBbMF1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IHRoaXMubGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgIG91dCArPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICBzcmMgPSBjYXBbMF0uc3Vic3RyaW5nKDEpICsgc3JjO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCBsaW5rKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzdHJvbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5zdHJvbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuc3Ryb25nKHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGVtXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZW0uZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZW0odGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZXNwYW4oZXNjYXBlKGNhcFsyXSwgdHJ1ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYnJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ici5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5icigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmRlbCh0aGlzLm91dHB1dChjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRleHQoZXNjYXBlKHRoaXMuc21hcnR5cGFudHMoY2FwWzBdKSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBMaW5rXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbihjYXAsIGxpbmspIHtcbiAgdmFyIGhyZWYgPSBlc2NhcGUobGluay5ocmVmKVxuICAgICwgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcblxuICByZXR1cm4gY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnXG4gICAgPyB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgdGl0bGUsIHRoaXMub3V0cHV0KGNhcFsxXSkpXG4gICAgOiB0aGlzLnJlbmRlcmVyLmltYWdlKGhyZWYsIHRpdGxlLCBlc2NhcGUoY2FwWzFdKSk7XG59O1xuXG4vKipcbiAqIFNtYXJ0eXBhbnRzIFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5zbWFydHlwYW50cyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMpIHJldHVybiB0ZXh0O1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufTtcblxuLyoqXG4gKiBNYW5nbGUgTGlua3NcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUubWFuZ2xlID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5tYW5nbGUpIHJldHVybiB0ZXh0O1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGwgPSB0ZXh0Lmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIGNoO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuXG5mdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24oY29kZSwgbGFuZywgZXNjYXBlZCkge1xuICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IGNvZGUpIHtcbiAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgY29kZSA9IG91dDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWxhbmcpIHtcbiAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICArICdcXG48L2NvZGU+PC9wcmU+JztcbiAgfVxuXG4gIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIidcbiAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgKyBlc2NhcGUobGFuZywgdHJ1ZSlcbiAgICArICdcIj4nXG4gICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgKyAnXFxuPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYmxvY2txdW90ZSA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJyArIHF1b3RlICsgJzwvYmxvY2txdW90ZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbihodG1sKSB7XG4gIHJldHVybiBodG1sO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhlYWRpbmcgPSBmdW5jdGlvbih0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gIHJldHVybiAnPGgnXG4gICAgKyBsZXZlbFxuICAgICsgJyBpZD1cIidcbiAgICArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXhcbiAgICArIHJhdy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teXFx3XSsvZywgJy0nKVxuICAgICsgJ1wiPidcbiAgICArIHRleHRcbiAgICArICc8L2gnXG4gICAgKyBsZXZlbFxuICAgICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGhyLz5cXG4nIDogJzxocj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihib2R5LCBvcmRlcmVkKSB7XG4gIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICByZXR1cm4gJzwnICsgdHlwZSArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0aXRlbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnBhcmFncmFwaCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKGhlYWRlciwgYm9keSkge1xuICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgKyAnPHRoZWFkPlxcbidcbiAgICArIGhlYWRlclxuICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICsgJzx0Ym9keT5cXG4nXG4gICAgKyBib2R5XG4gICAgKyAnPC90Ym9keT5cXG4nXG4gICAgKyAnPC90YWJsZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlcm93ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVjZWxsID0gZnVuY3Rpb24oY29udGVudCwgZmxhZ3MpIHtcbiAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgdmFyIHRhZyA9IGZsYWdzLmFsaWduXG4gICAgPyAnPCcgKyB0eXBlICsgJyBzdHlsZT1cInRleHQtYWxpZ246JyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICA6ICc8JyArIHR5cGUgKyAnPic7XG4gIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG4vLyBzcGFuIGxldmVsIHJlbmRlcmVyXG5SZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGVzcGFuID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUoaHJlZikpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdzpdL2csICcnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuICB2YXIgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIHZhciBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dDtcbn07XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW4gPSBudWxsO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xufVxuXG4vKipcbiAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAqL1xuXG5QYXJzZXIucGFyc2UgPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMsIHJlbmRlcmVyKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIHJlbmRlcmVyKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShzcmMpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMb29wXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHNyYykge1xuICB0aGlzLmlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihzcmMubGlua3MsIHRoaXMub3B0aW9ucywgdGhpcy5yZW5kZXJlcik7XG4gIHRoaXMudG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgIG91dCArPSB0aGlzLnRvaygpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbiA9IHRoaXMudG9rZW5zLnBvcCgpO1xufTtcblxuLyoqXG4gKiBQcmV2aWV3IE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdIHx8IDA7XG59O1xuXG4vKipcbiAqIFBhcnNlIFRleHQgVG9rZW5zXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvZHkgPSB0aGlzLnRva2VuLnRleHQ7XG5cbiAgd2hpbGUgKHRoaXMucGVlaygpLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5saW5lLm91dHB1dChib2R5KTtcbn07XG5cbi8qKlxuICogUGFyc2UgQ3VycmVudCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhlYWRpbmcoXG4gICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpLFxuICAgICAgICB0aGlzLnRva2VuLmRlcHRoLFxuICAgICAgICB0aGlzLnRva2VuLnRleHQpO1xuICAgIH1cbiAgICBjYXNlICdjb2RlJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY29kZSh0aGlzLnRva2VuLnRleHQsXG4gICAgICAgIHRoaXMudG9rZW4ubGFuZyxcbiAgICAgICAgdGhpcy50b2tlbi5lc2NhcGVkKTtcbiAgICB9XG4gICAgY2FzZSAndGFibGUnOiB7XG4gICAgICB2YXIgaGVhZGVyID0gJydcbiAgICAgICAgLCBib2R5ID0gJydcbiAgICAgICAgLCBpXG4gICAgICAgICwgcm93XG4gICAgICAgICwgY2VsbFxuICAgICAgICAsIGZsYWdzXG4gICAgICAgICwgajtcblxuICAgICAgLy8gaGVhZGVyXG4gICAgICBjZWxsID0gJyc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5oZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmxhZ3MgPSB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfTtcbiAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi5oZWFkZXJbaV0pLFxuICAgICAgICAgIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93ID0gdGhpcy50b2tlbi5jZWxsc1tpXTtcblxuICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHJvd1tqXSksXG4gICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnYmxvY2txdW90ZV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnYmxvY2txdW90ZV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJydcbiAgICAgICAgLCBvcmRlcmVkID0gdGhpcy50b2tlbi5vcmRlcmVkO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRva2VuLnR5cGUgPT09ICd0ZXh0J1xuICAgICAgICAgID8gdGhpcy5wYXJzZVRleHQoKVxuICAgICAgICAgIDogdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xvb3NlX2l0ZW1fc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICB2YXIgaHRtbCA9ICF0aGlzLnRva2VuLnByZSAmJiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgID8gdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dClcbiAgICAgICAgOiB0aGlzLnRva2VuLnRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5odG1sKGh0bWwpO1xuICAgIH1cbiAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VUZXh0KCkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICByZXR1cm4gaHRtbFxuICAgIC5yZXBsYWNlKCFlbmNvZGUgPyAvJig/ISM/XFx3KzspL2cgOiAvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLyYoWyNcXHddKyk7L2csIGZ1bmN0aW9uKF8sIG4pIHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICB2YXIgaSA9IDFcbiAgICAsIHRhcmdldFxuICAgICwga2V5O1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogTWFya2VkXG4gKi9cblxuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgfHwgdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IG9wdC5oaWdobGlnaHRcbiAgICAgICwgdG9rZW5zXG4gICAgICAsIHBlbmRpbmdcbiAgICAgICwgaSA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICB9XG5cbiAgICBwZW5kaW5nID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBvdXQgPSBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfVxuXG4gICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG4gICAgICByZXR1cm4gZXJyXG4gICAgICAgID8gY2FsbGJhY2soZXJyKVxuICAgICAgICA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgfTtcblxuICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuXG4gICAgaWYgKCFwZW5kaW5nKSByZXR1cm4gZG9uZSgpO1xuXG4gICAgZm9yICg7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbihlcnIsIGNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgIGlmIChjb2RlID09IG51bGwgfHwgY29kZSA9PT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkodG9rZW5zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0KSBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoTGV4ZXIubGV4KHNyYywgb3B0KSwgb3B0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZC4nO1xuICAgIGlmICgob3B0IHx8IG1hcmtlZC5kZWZhdWx0cykuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+J1xuICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgKyAnPC9wcmU+JztcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBtZXJnZShtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZGVmYXVsdHMgPSB7XG4gIGdmbTogdHJ1ZSxcbiAgdGFibGVzOiB0cnVlLFxuICBicmVha3M6IGZhbHNlLFxuICBwZWRhbnRpYzogZmFsc2UsXG4gIHNhbml0aXplOiBmYWxzZSxcbiAgc2FuaXRpemVyOiBudWxsLFxuICBtYW5nbGU6IHRydWUsXG4gIHNtYXJ0TGlzdHM6IGZhbHNlLFxuICBzaWxlbnQ6IGZhbHNlLFxuICBoaWdobGlnaHQ6IG51bGwsXG4gIGxhbmdQcmVmaXg6ICdsYW5nLScsXG4gIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgaGVhZGVyUHJlZml4OiAnJyxcbiAgcmVuZGVyZXI6IG5ldyBSZW5kZXJlcixcbiAgeGh0bWw6IGZhbHNlXG59O1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcblxubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5cbm1hcmtlZC5JbmxpbmVMZXhlciA9IElubGluZUxleGVyO1xubWFya2VkLmlubGluZUxleGVyID0gSW5saW5lTGV4ZXIub3V0cHV0O1xuXG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXJrZWQ7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5tYXJrZWQgPSBtYXJrZWQ7XG59XG5cbn0pLmNhbGwoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG59KCkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbWFya2VkL2xpYi9tYXJrZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZGVmaW5lVGFnKCdzaXRlJywgJ2h0bWwnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVwcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGVwczsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RGVwcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kZXBzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnJC4kaGVhZCgpLnNldENvbnRlbnQoW1xuXHRcdFx0XHR0YWckLiR0aXRsZSgpLnNldFRleHQoXCJpbWJhXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0Q2hhcnNldChcInV0Zi04XCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0TmFtZShcInZpZXdwb3J0XCIpLnNldENvbnRlbnQoXCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLG1pbmltdW0tc2NhbGU9MVwiKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kbWV0YSgpLnNldE5hbWUoXCJEZXNjcmlwdGlvblwiKS5zZXRDb250ZW50KFwiSW1iYSBpcyBhIHJpY2ggcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgZm9yIHRoZSB3ZWIuXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0TmFtZShcImtleXdvcmRzXCIpLnNldENvbnRlbnQoXCJpbWJhIGphdmFzY3JpcHQgbGFuZ3VhZ2UganNcIikuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGxpbmsoKS5zZXRIcmVmKCdodHRwOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Tb3VyY2UrQ29kZStQcm86NDAwLDUwMCw2MDAnKS5zZXRSZWwoJ3N0eWxlc2hlZXQnKS5zZXRUeXBlKCd0ZXh0L2NzcycpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRsaW5rKCkuc2V0UmVsKFwic3R5bGVzaGVldFwiKS5zZXRIcmVmKFwiL2Nzcy9zaXRlLmNzc1wiKS5zZXRNZWRpYShcInNjcmVlblwiKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kc2NyaXB0KCkuc2V0VGV4dCgnREVQUyA9IHt9OycpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRzY3JpcHQoKS5zZXRTcmMoXCIvdmVuZG9yL2dhLmpzXCIpLmVuZCgpXG5cdFx0XHRdLDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnJC4kYm9keSgpLnNldElkKCdzaXRlJykuc2V0Q29udGVudChbXG5cdFx0XHRcdHRhZyQuJHNpdGVfbmF2KCkuc2V0SWQoJ2hlYWRlcicpLmZsYWcoJ2F3YWtlbicpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRob21lKCkuc2V0Um91dGUoJy9ob21lJykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGd1aWRlcygpLnNldFJvdXRlKCcvZ3VpZGVzJykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGRvY3MoKS5zZXRSb3V0ZSgnL2RvY3MnKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kYmxvZygpLnNldFJvdXRlKCcvYmxvZycpLmVuZCgpXG5cdFx0XHRdLDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zY3JpcHRzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHQwO1xuXHRcdFx0cmV0dXJuIHRhZyQuJGRpdigpLmZsYWcoJ3NjcmlwdHMnKS5zZXRDb250ZW50KFtcblx0XHRcdFx0KGZ1bmN0aW9uKHQwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgbyA9IHNlbGYuZGVwcygpLCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG8pLCBsID0ga2V5cy5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHRcdHJlcy5wdXNoKHRhZyQuJHNjcmlwdCgpLnNldFR5cGUoXCJ0ZXh0L2phdmFzY3JpcHRcIikuc2V0U3JjKChrZXlzW2ldICsgJy5kZXAnKSkuZW5kKCkpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fSkodDApLFxuXHRcdFx0XHR0YWckLiRzY3JpcHQoKS5zZXRTcmMoXCIvdmVuZG9yL2hsLmpzXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRzY3JpcHQoKS5zZXRTcmMoXCIvY2xpZW50LmpzXCIpLmVuZCgpXG5cdFx0XHRdLDApLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGRpcnR5IHdvcmthcm91bmRzXG5cdFx0XHRBUFAuc2V0U2l0ZSh0aGlzKTtcblx0XHRcdHRoaXMuc2V0RGVwcyh7fSk7XG5cdFx0XHRBUFAuZmV0Y2hEb2N1bWVudCgnL2d1aWRlcy5tZCcpO1xuXHRcdFx0dmFyIGJvZHkgPSB0aGlzLmJvZHkoKTtcblx0XHRcdGJvZHkuYXBwZW5kKHRoaXMuc2NyaXB0cygpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5mbGFnKCdsaWdodCcpLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGhpcy5oZWFkKCksXG5cdFx0XHRcdGJvZHlcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0XHRBUFAuc2V0U2l0ZShudWxsKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnc2l0ZS1uYXYnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9nZ2xlTWVudSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHEkJCgnYm9keScpLnRvZ2dsZUZsYWcoJ21lbnUnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3O1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oXG5cdFx0XHRcdCh0MCA9IHRoaXMuJGE9dGhpcy4kYSB8fCB0YWckLiRuYXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kYSgpLmZsYWcoJ21lbnUnKS5zZXRIYW5kbGVyKCd0YXAnLCd0b2dnbGVNZW51Jyx0aGlzKSkuc2V0Q29udGVudCgodDEuJCRhID0gdDEuJCRhIHx8IHRhZyQuJGIoKSkuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0KHQyID0gdDAuJCRiPXQwLiQkYiB8fCB0YWckLiRhKCkuZmxhZygndGFiJykuZmxhZygnbG9nbycpLnNldEhyZWYoJy9ob21lJykpLnNldENvbnRlbnQoKHQyLiQkYSA9IHQyLiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2ltYmEnKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDAuJCRjID0gdDAuJCRjIHx8IHRhZyQuJHNwYW4oKS5mbGFnKCdncmVlZHknKSkuZW5kKCksXG5cdFx0XHRcdFx0KHQzID0gdDAuJCRkPXQwLiQkZCB8fCB0YWckLiRhKCkuZmxhZygndGFiJykuZmxhZygnaG9tZScpLnNldEhyZWYoJy9ob21lJykpLnNldENvbnRlbnQoKHQzLiQkYSA9IHQzLiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2hvbWUnKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDQgPSB0MC4kJGU9dDAuJCRlIHx8IHRhZyQuJGEoKS5mbGFnKCd0YWInKS5mbGFnKCdndWlkZXMnKS5zZXRIcmVmKCcvZ3VpZGVzJykpLnNldENvbnRlbnQoKHQ0LiQkYSA9IHQ0LiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2d1aWRlcycpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0NSA9IHQwLiQkZj10MC4kJGYgfHwgdGFnJC4kYSgpLmZsYWcoJ3RhYicpLmZsYWcoJ2RvY3MnKS5zZXRIcmVmKCcvZG9jcycpKS5zZXRDb250ZW50KCh0NS4kJGEgPSB0NS4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdkb2NzJykuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0KHQ2ID0gdDAuJCRnPXQwLiQkZyB8fCB0YWckLiRhKCkuZmxhZygndGFiJykuZmxhZygnYmxvZycpLnNldEhyZWYoJy9ibG9nJykpLnNldENvbnRlbnQoKHQ2LiQkYSA9IHQ2LiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2Jsb2cnKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDcgPSB0MC4kJGg9dDAuJCRoIHx8IHRhZyQuJGEoKS5mbGFnKCdnaXRodWInKS5zZXRIcmVmKCdodHRwczovL2dpdGh1Yi5jb20vc29tZWJlZS9pbWJhJykpLnNldENvbnRlbnQoKHQ3LiQkYSA9IHQ3LiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2dpdGh1YicpLmVuZCgpLDIpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdCwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zY2hlZHVsZSh7ZnBzOiAwfSk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL3NpdGUuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbmF2bWVudScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnJvdXRlID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Y29uc29sZS5sb2coJ25hdm1lbnUgb25yb3V0ZScsZSk7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ21lbnUnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ25hdi1saXN0Jyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbmF2LWxpbmsnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaHJlZiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHJlZiA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnaHJlZicsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDA7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbigodDAgPSB0aGlzLiRhPXRoaXMuJGEgfHwgdGFnJC4kYSgpKS5zZXRIcmVmKHRoaXMuaHJlZigpKS5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQsMykuZW5kKCksMikuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3RvYycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnRvZ2dsZUZsYWcoJ2NvbGxhcHNlZCcpO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9uYXYuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygncGFnZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2JvZHkgPSB0aGlzLl9ib2R5IHx8IHRhZyQuJGRpdigpLnNldFJlZignYm9keScsdGhpcykpLnNldFRleHQoXCJDb250ZW50IGhlcmVcIikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hdiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICh0aGlzLl9uYXYgPSB0aGlzLl9uYXYgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCduYXYnLHRoaXMpKS5zZXRUZXh0KFwiTmF2aWdhdGlvbiBoZXJlXCIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHR0aGlzLm5hdigpLFxuXHRcdFx0XHR0aGlzLmJvZHkoKVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGxvZyAncmVuZGVyIHBhZ2UnLHJvdXRlXG5cdFx0XHR2YXIgc2NvcGVkID0gdGhpcy5yb3V0ZXIoKS5zY29wZWQodGhpcy5yb3V0ZSgpLHRoaXMpO1xuXHRcdFx0dGhpcy5mbGFnKCdzY29wZWQnLHNjb3BlZCk7XG5cdFx0XHR0aGlzLmZsYWcoJ3NlbGVjdGVkJyx0aGlzLnJvdXRlcigpLm1hdGNoKHRoaXMucm91dGUoKSx0aGlzKSk7XG5cdFx0XHRcblx0XHRcdGlmICghKHNjb3BlZCAmJiB0aGlzLnJlYWR5KCkpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGhpcy5hc3NlbWJsZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNjaGVkdWxlKHtmcHM6IDF9KTtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvcGFnZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRmdW5jdGlvbiBzaHVmZmxlKGFycmF5KXtcblx0XHR2YXIgY291bnRlciA9IGFycmF5Lmxlbmd0aCx0ZW1wLGluZGV4O1xuXHRcdFxuXHRcdC8vIFdoaWxlIHRoZXJlIGFyZSBlbGVtZW50cyBpbiB0aGUgYXJyYXlcblx0XHR3aGlsZSAoY291bnRlciA+IDApe1xuXHRcdFx0Ly8gUGljayBhIHJhbmRvbSBpbmRleFxuXHRcdFx0aW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb3VudGVyKTtcblx0XHRcdGNvdW50ZXItLTsgLy8gRGVjcmVhc2UgY291bnRlciBieSAxXG5cdFx0XHRcblx0XHRcdC8vIEFuZCBzd2FwIHRoZSBsYXN0IGVsZW1lbnQgd2l0aCBpdFxuXHRcdFx0dGVtcCA9IGFycmF5W2NvdW50ZXJdO1xuXHRcdFx0YXJyYXlbY291bnRlcl0gPSBhcnJheVtpbmRleF07XG5cdFx0XHRhcnJheVtpbmRleF0gPSB0ZW1wO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3BhdHRlcm4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmIChJbWJhLlNFUlZFUikgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XG5cdFx0XHR2YXIgcGFydHMgPSB7dGFnczogW10sa2V5d29yZHM6IFtdLG1ldGhvZHM6IFtdfTtcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0dmFyIGxpbmVzID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIG8gPSBJbWJhLlRhZy5wcm90b3R5cGUsIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMobyksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdGsgPSBrZXlzW2ldO2l0ZW1zLnB1c2goKFwiPGVtPlwiICsgayArIFwiPC9lbT5cIikpO1xuXHRcdFx0XHRwYXJ0cy5tZXRob2RzLnB1c2goKFwiPGVtPlwiICsgayArIFwiPC9lbT5cIikpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIGFyeSA9IGl0ZXIkKEhUTUxfVEFHUyksIGxlbl8gPSBhcnkubGVuZ3RoLCBrMTsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHQvLyBmb3Igb3duIGssdiBvZiBJbWJhLlRBR1Ncblx0XHRcdFx0Ly8gaWYgdiBhbmQgdjpwcm90b3R5cGUgaXNhIEltYmEuVGFnXG5cdFx0XHRcdGsxID0gYXJ5W2pdO1xuXHRcdFx0XHRpdGVtcy5wdXNoKChcIjx1PiZsdDtcIiArIGsxICsgXCImZ3Q7PC91PlwiKSk7XG5cdFx0XHRcdHBhcnRzLnRhZ3MucHVzaCgoXCI8dT4mbHQ7XCIgKyBrMSArIFwiJmd0OzwvdT5cIikpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHdvcmRzID0gXCJkZWYgaWYgZWxzZSBlbGlmIHdoaWxlIHVudGlsIGZvciBpbiBvZiB2YXIgbGV0IGNsYXNzIGV4dGVuZCBleHBvcnQgaW1wb3J0IHRhZyBnbG9iYWxcIjtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIGFyeSA9IGl0ZXIkKHdvcmRzLnNwbGl0KFwiIFwiKSksIGxlbl8gPSBhcnkubGVuZ3RoLCBrMjsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHRrMiA9IGFyeVtqXTtcblx0XHRcdFx0aXRlbXMucHVzaCgoXCI8aT5cIiArIGsyICsgXCI8L2k+XCIpKTtcblx0XHRcdFx0cGFydHMua2V5d29yZHMucHVzaCgoXCI8aT5cIiArIGsyICsgXCI8L2k+XCIpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBzaHVmZmxlZCA9IHNodWZmbGUoaXRlbXMpO1xuXHRcdFx0dmFyIGFsbCA9IFtdLmNvbmNhdChzaHVmZmxlZCk7XG5cdFx0XHR2YXIgY291bnQgPSBpdGVtcy5sZW5ndGggLSAxO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBsZW4gPSAxMiwgbG4gPSAwOyBsbiA8PSBsZW47IGxuKyspIHtcblx0XHRcdFx0dmFyIGNoYXJzID0gMDtcblx0XHRcdFx0bGluZXNbbG5dID0gW107XG5cdFx0XHRcdHdoaWxlIChjaGFycyA8IDMwMCl7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSAoc2h1ZmZsZWQucG9wKCkgfHwgYWxsW01hdGguZmxvb3IoY291bnQgKiBNYXRoLnJhbmRvbSgpKV0pO1xuXHRcdFx0XHRcdGlmIChpdGVtKSB7XG5cdFx0XHRcdFx0XHRjaGFycyArPSBpdGVtLmxlbmd0aDtcblx0XHRcdFx0XHRcdGxpbmVzW2xuXS5wdXNoKGl0ZW0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjaGFycyA9IDQwMDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSAnPGRpdj4nICsgbGluZXMubWFwKGZ1bmN0aW9uKGxuKSB7XG5cdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cImxpbmVcIj4nICsgbG4uam9pbihcIiBcIikgKyAnPC9kaXY+Jztcblx0XHRcdH0pLmpvaW4oJycpICsgJzwvZGl2Pic7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygnYXdha2VuaW5nIHBhdHRlcm4hIScpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChxJCgnLmxpbmUnLHRoaXMpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHZhciB6ID0gMjAgKyBpICogMTA7XG5cdFx0XHRcdC8vIHogPSBwYXJzZUludCgteiArIE1hdGgucmFuZG9tICogeiAqIDIpXG5cdFx0XHRcdGFyeVtpXS5jc3MoJ3RyYW5zZm9ybScsKFwidHJhbnNsYXRlWihcIiArIHogKyBcInB4KVwiKSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2hvbWUnLCAncGFnZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dmFyIHRvZG9zID0ge2RlbW86IHRydWUsYXV0b3J1bjogdHJ1ZX07XG5cdFx0dmFyIGNsb2NrID0ge2RlbW86IHRydWUsYXV0b3J1bjogdHJ1ZX07XG5cdFx0dmFyIHJlbWluZGVycyA9IHtkZW1vOiB0cnVlLGF1dG9ydW46IHRydWV9O1xuXHRcdHZhciBoZXJvID0ge2F1dG9ydW46IHRydWV9O1xuXHRcdHZhciBjYW52YXMgPSB7ZGVtbzogdHJ1ZSxhdXRvcnVuOiB0cnVlfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNuaXBwZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnY29kZVtkYXRhLXNyY10nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzbmlwcGV0cyksIGxlbiA9IGFyeS5sZW5ndGgsIHNuaXBwZXQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRzbmlwcGV0ID0gYXJ5W2ldO1xuXHRcdFx0XHR2YXIgc3JjID0gc25pcHBldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmZXRjaGluZyBzbmlwcGV0IGZvciAnLHNyY1xuXHRcdFx0XHRERVBTW3NyY10gPSB7aHRtbDogc25pcHBldC5pbm5lckhUTUx9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18uYXdha2VuLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmF2ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCB0MSwgdDIsIHQzLCB0NDtcblx0XHRcdHJldHVybiAodDAgPSB0aGlzLl9ib2R5PXRoaXMuX2JvZHkgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdib2R5Jyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kZGl2KCkuc2V0SWQoJ2hlcm8nKS5mbGFnKCdkYXJrJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0aGlzLl9wYXR0ZXJuID0gdGhpcy5fcGF0dGVybiB8fCB0YWckLiRwYXR0ZXJuKCkuc2V0UmVmKCdwYXR0ZXJuJyx0aGlzKS5mbGFnKCdhd2FrZW4nKSkuZW5kKCksXG5cdFx0XHRcdFx0KHQxLiQkYiA9IHQxLiQkYiB8fCB0YWckLiRleGFtcGxlKCkuZmxhZygnaGVybycpLmZsYWcoJ2RhcmsnKS5zZXRTcmMoJy9ob21lL2V4YW1wbGVzL2hlcm8uaW1iYScpKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpLFxuXHRcdFx0XHRcblx0XHRcdFx0KHQyID0gdGhpcy5fY29udGVudD10aGlzLl9jb250ZW50IHx8IHRhZyQuJGRpdigpLnNldFJlZignY29udGVudCcsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0Mi4kJGEgPSB0Mi4kJGEgfHwgdGFnJC4kbWFya2VkKCkuZmxhZygnc2VjdGlvbicpLmZsYWcoJ21kJykuZmxhZygnd2VsY29tZScpLmZsYWcoJ2h1Z2UnKS5mbGFnKCdsaWdodCcpKS5zZXRUZXh0KFwiIyBSdWJ5LCBQeXRob24gYW5kIFJlYWN0IGdvdCB0b2dldGhlci4gTmluZSBtb250aHMgbGF0ZXIsIEltYmEgd2FzIGJvcm4uXFxuXFxuSW1iYSBpcyBhIG5ldyBwcm9ncmFtbWluZyBsYW5ndWFnZSBmb3IgdGhlIHdlYiB0aGF0IGNvbXBpbGVzIHRvIGhpZ2hseSBcXG5wZXJmb3JtYW50IGFuZCByZWFkYWJsZSBKYXZhU2NyaXB0LiBJdCBoYXMgbGFuZ3VhZ2UgbGV2ZWwgc3VwcG9ydCBmb3IgZGVmaW5pbmcsIFxcbmV4dGVuZGluZywgc3ViY2xhc3NpbmcsIGluc3RhbnRpYXRpbmcgYW5kIHJlbmRlcmluZyBkb20gbm9kZXMuIEZvciBhIHNlbWktY29tcGxleCBcXG5hcHBsaWNhdGlvbiBsaWtlIFRvZG9NVkMsIGl0IGlzIG1vcmUgdGhhbiBcXG5bMTAgdGltZXMgZmFzdGVyIHRoYW4gUmVhY3RdKGh0dHA6Ly9zb21lYmVlLmdpdGh1Yi5pby90b2RvbXZjLXJlbmRlci1iZW5jaG1hcmsvaW5kZXguaHRtbCkgXFxud2l0aCBsZXNzIGNvZGUsIGFuZCBhIG11Y2ggc21hbGxlciBsaWJyYXJ5Llxcblxcbi0tLVxcblxcbi0gIyMgSW1iYS5pbnNwaXJhdGlvblxcbiAgSW1iYSBicmluZ3MgdGhlIGJlc3QgZnJvbSBSdWJ5LCBQeXRob24sIGFuZCBSZWFjdCAoKyBKU1gpIHRvZ2V0aGVyIGluIGEgY2xlYW4gbGFuZ3VhZ2UgYW5kIHJ1bnRpbWUuXFxuXFxuLSAjIyBJbWJhLmludGVyb3BlcmFiaWxpdHlcXG4gIEltYmEgY29tcGlsZXMgZG93biB0byBjbGVhbiBhbmQgcmVhZGFibGUgSmF2YVNjcmlwdC4gVXNlIGFueSBKUyBsaWJyYXJ5IGluIEltYmEgYW5kIHZpY2EtdmVyc2EuXFxuXFxuLSAjIyBJbWJhLnBlcmZvcm1hbmNlXFxuICBCdWlsZCB5b3VyIGFwcGxpY2F0aW9uIHZpZXdzIHVzaW5nIEltYmEncyBuYXRpdmUgdGFncyBmb3IgdW5wcmVjZWRlbnRlZCBwZXJmb3JtYW5jZS5cXG5cIikuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkYiA9IHQyLiQkYiB8fCB0YWckLiRleGFtcGxlKCkuZmxhZygnZGFyaycpLnNldEhlYWRpbmcoXCJTaW1wbGUgcmVtaW5kZXJzXCIpLnNldFNyYygnL2hvbWUvZXhhbXBsZXMvcmVtaW5kZXJzLmltYmEnKSkuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkYyA9IHQyLiQkYyB8fCB0YWckLiRtYXJrZWQoKS5mbGFnKCdzZWN0aW9uJykuZmxhZygnbWQnKSkuc2V0VGV4dChcIiMjIFJldXNhYmxlIGNvbXBvbmVudHNcXG5cXG5BIGN1c3RvbSB0YWcgLyBjb21wb25lbnQgY2FuIG1haW50YWluIGludGVybmFsIHN0YXRlIGFuZCBjb250cm9sIGhvdyB0byByZW5kZXIgaXRzZWxmLlxcbldpdGggdGhlIHBlcmZvcm1hbmNlIG9mIERPTSByZWNvbmNpbGlhdGlvbiBpbiBJbWJhLCB5b3UgY2FuIHVzZSBvbmUtd2F5IGRlY2xhcmF0aXZlIGJpbmRpbmcsXFxuZXZlbiBmb3IgYW5pbWF0aW9ucy4gV3JpdGUgYWxsIHlvdXIgdmlld3MgaW4gYSBzdHJhaWdodC1mb3J3YXJkIGxpbmVhciBmYXNoaW9uIGFzIGlmIHlvdSBjb3VsZFxcbnJlcmVuZGVyIHlvdXIgd2hvbGUgYXBwbGljYXRpb24gb24gKipldmVyeSBzaW5nbGUqKiBkYXRhL3N0YXRlIGNoYW5nZS5cIikuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkZCA9IHQyLiQkZCB8fCB0YWckLiRleGFtcGxlKCkuZmxhZygnZGFyaycpLnNldEhlYWRpbmcoXCJXb3JsZCBjbG9ja1wiKS5zZXRTcmMoJy9ob21lL2V4YW1wbGVzL2Nsb2NrLmltYmEnKSkuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkZSA9IHQyLiQkZSB8fCB0YWckLiRtYXJrZWQoKS5mbGFnKCdzZWN0aW9uJykuZmxhZygnbWQnKSkuc2V0VGV4dChcIiMjIEV4dGVuZCBuYXRpdmUgdGFnc1xcblxcbkluIGFkZGl0aW9uIHRvIGRlZmluaW5nIGN1c3RvbSB0YWdzLCB5b3UgY2FuIGFsc28gZXh0ZW5kIG5hdGl2ZSB0YWdzLCBvciBpbmhlcml0IGZyb20gdGhlbS5cXG5CaW5kaW5nIHRvIGRvbSBldmVudHMgaXMgYXMgc2ltcGxlIGFzIGRlZmluaW5nIG1ldGhvZHMgb24geW91ciB0YWdzOyBhbGwgZXZlbnRzIHdpbGwgYmVcXG5lZmZpY2llbnRseSBkZWxlZ2F0ZWQgYW5kIGhhbmRsZWQgYnkgSW1iYS4gTGV0J3MgZGVmaW5lIGEgc2ltcGxlIHNrZXRjaHBhZC4uLlwiKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDIuJCRmID0gdDIuJCRmIHx8IHRhZyQuJGV4YW1wbGUoKS5mbGFnKCdkYXJrJykuc2V0SGVhZGluZyhcIkN1c3RvbSBjYW52YXNcIikuc2V0U3JjKCcvaG9tZS9leGFtcGxlcy9jYW52YXMuaW1iYScpKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDMgPSB0Mi4kJGc9dDIuJCRnIHx8IHRhZyQuJGZvb3RlcigpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdFx0KHQ0ID0gdDMuJCRhPXQzLiQkYSB8fCB0YWckLiRuYXYoKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdCh0NC4kJGEgPSB0NC4kJGEgfHwgdGFnJC4kYSgpLmZsYWcoJ2J1dHRvbicpLmZsYWcoJ2h1Z2UnKS5mbGFnKCdtYWluJykuc2V0SHJlZignL2luc3RhbGwnKSkuc2V0VGV4dChcIkluc3RhbGxcIikuZW5kKCksXG5cdFx0XHRcdFx0XHRcdCh0NC4kJGIgPSB0NC4kJGIgfHwgdGFnJC4kYSgpLmZsYWcoJ2J1dHRvbicpLmZsYWcoJ2h1Z2UnKS5zZXRIcmVmKCcvZ3VpZGVzJykpLnNldFRleHQoXCJMZWFybiBtb3JlXCIpLmVuZCgpXG5cdFx0XHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRcdFx0LDIpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdF0sMikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBkZWYgYXdha2VuXG5cdFx0Ly8gXHQjIGF3YWtlbiB0aGUgc25pcHBldHNcblx0XHQvLyBcdHNjaGVkdWxlXG5cdFx0Ly8gXHRmb3IgZWwgaW4gJShzbmlwcGV0KVxuXHRcdC8vIFx0XHRlbFxuXHRcdC8vIFx0c2VsZlxuXHRcdFxuXHRcdC8vIGRlZiB0aWNrXG5cdFx0Ly8gXHRsb2cgJ2hvbWUudGljaydcblx0XHQvLyBcdHNlbGZcblx0XHRcblx0XHQvLyBkZWYgYXNzZW1ibGVcblx0XHQvLyBcdHJldHVybiBzZWxmIGlmIEltYmEuaXNDbGllbnRcblx0XHQvLyBcdHN1cGVyXG5cdFx0Ly8gXHQjIGZsYWcoJ3Njb3BlZCcscm91dGVyLnNjb3BlZChyb3V0ZSxzZWxmKSlcblx0XHQvLyBcdCMgZmxhZygnc2VsZWN0ZWQnLHJvdXRlci5tYXRjaChyb3V0ZSxzZWxmKSlcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2hvbWUuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdibG9nJywgJ3BhZ2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmF2ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX25hdj10aGlzLl9uYXYgfHwgdGFnJC4kbmF2bWVudSgpLnNldFJlZignbmF2Jyx0aGlzKSkuc2V0Q29udGVudChcblx0XHRcdFx0KHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0KHQxLiQkYSA9IHQxLiQkYSB8fCB0YWckLiRoMSgpKS5zZXRUZXh0KFwiTm8gaXRlbXM/XCIpLmVuZCgpXG5cdFx0XHRcdCwyKS5lbmQoKVxuXHRcdFx0LDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2JvZHkgPSB0aGlzLl9ib2R5IHx8IHRhZyQuJGRpdigpLnNldFJlZignYm9keScsdGhpcykpLnNldFRleHQoXG5cdFx0XHRcdFwiTm8gcG9zdHNcIlxuXHRcdFx0KS5lbmQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnYmxvZ3Bvc3QnLCAnYXJ0aWNsZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDEsIHQyO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodDAgPSB0aGlzLiRhPXRoaXMuJGEgfHwgdGFnJC4kaGVhZGVyKCkpLnNldENvbnRlbnQoKHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRoMSgpKS5zZXRDb250ZW50KHRoaXMub2JqZWN0KCkudGl0bGUsMykuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdCh0MiA9IHRoaXMuJGI9dGhpcy4kYiB8fCB0YWckLiRzZWN0aW9uKCkuZmxhZygnbWQnKSkuc2V0Q29udGVudCh0aGlzLm9iamVjdCgpLmJvZHksMykuZW5kKClcblx0XHRcdF0sMikuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2Jsb2cuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0cmVxdWlyZSgnLi9wYWdlJyk7XG5cdFxuXHRmdW5jdGlvbiBHdWlkZShwYXRoKXtcblx0XHR0aGlzLl9wYXRoID0gcGF0aDtcblx0XHR0aGlzLl9yZWFkeSA9IGZhbHNlO1xuXHRcdHRoaXMuZmV0Y2goKTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0dmFyIGNhY2hlID0ge307XG5cdFxuXHRHdWlkZS5nZXQgPSBmdW5jdGlvbiAocGF0aCl7XG5cdFx0dmFyICQxO1xuXHRcdHZhciBjYWNoZSA9IEFQUC5jYWNoZSgpO1xuXHRcdHJldHVybiBjYWNoZVsoJDEgPSAnZ3VpZGUtJyArIHBhdGgpXSB8fCAoY2FjaGVbJDFdID0gbmV3IHRoaXMocGF0aCkpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRHdWlkZS5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcGF0aDsgfVxuXHRHdWlkZS5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRHdWlkZS5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fcmVhZHk7XG5cdH07XG5cdFxuXHRHdWlkZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnZmV0Y2ggR3VpZGUgb24gc2VydmVyJyxwYXRoXG5cdFx0XHRyZXR1cm4gQVBQLmZldGNoRG9jdW1lbnQoc2VsZi5fcGF0aCArICcubWQnLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnZmV0Y2ggR3VpZGUgb24gc2VydmVyIGRvbmUnLHBhdGhcblx0XHRcdFx0cmV0dXJuIHNlbGYubG9hZChyZXMpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5fcHJvbWlzZSB8fCAoc2VsZi5fcHJvbWlzZSA9IEFQUC5mZXRjaERvY3VtZW50KHNlbGYuX3BhdGggKyAnLm1kJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdHJldHVybiBzZWxmLmxvYWQocmVzKTtcblx0XHR9KSk7XG5cdH07XG5cdFxuXHRHdWlkZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChkb2Mpe1xuXHRcdHRoaXMuX29iamVjdCA9IGRvYztcblx0XHR0aGlzLl9tZXRhID0gZG9jLm1ldGEgfHwge307XG5cdFx0dGhpcy5fcmVhZHkgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLnRpdGxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX29iamVjdC50aXRsZSB8fCAncGF0aCc7XG5cdH07XG5cdFxuXHRHdWlkZS5wcm90b3R5cGUudG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX29iamVjdCAmJiB0aGlzLl9vYmplY3QudG9jWzBdO1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb2JqZWN0ICYmIHRoaXMuX29iamVjdC5ib2R5O1xuXHR9O1xuXHRcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdndWlkZS10b2MnLCAndG9jJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdG9jOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUb2MgPSBmdW5jdGlvbih2KXsgdGhpcy5fdG9jID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sZXZlbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xldmVsJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldExldmVsID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdsZXZlbCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucm91dGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyb3V0ZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSb3V0ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgncm91dGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RvYyB8fCB0aGlzLm9iamVjdCgpLnRvYygpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb3V0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIChcIlwiICsgKHRoaXMub2JqZWN0KCkucGF0aCgpKSArIFwiI1wiICsgKHRoaXMudG9jKCkuc2x1ZykpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnRvZ2dsZUZsYWcoJ2NvbGxhcHNlZCcpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDEsIHNlbGYgPSB0aGlzLCB0MiwgdDM7XG5cdFx0XHRpZiAoIXRoaXMub2JqZWN0KCkucmVhZHkoKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLnJlcm91dGUoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnZW50cnknKS5zZXRMZXZlbCgodGhpcy50b2MoKS5sZXZlbCkpLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGhpcy50b2MoKS5jaGlsZHJlbi5sZW5ndGggJiYgdGhpcy50b2MoKS5sZXZlbCA8IDIgPyAoSW1iYS5zdGF0aWMoW1xuXHRcdFx0XHRcdCh0MCA9IHRoaXMuJGE9dGhpcy4kYSB8fCB0YWckLiRkaXYoKS5mbGFnKCdoZWFkZXInKS5zZXRIYW5kbGVyKCd0YXAnLCd0b2dnbGUnLHRoaXMpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdFx0KHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRhKCkpLnNldEhyZWYodGhpcy5yb3V0ZSgpKS5zZXRDb250ZW50KHRoaXMudG9jKCkudGl0bGUsMykuZW5kKClcblx0XHRcdFx0XHQsMikuZW5kKCksXG5cdFx0XHRcdFx0KHQyID0gc2VsZi4kYj1zZWxmLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdChmdW5jdGlvbih0Mikge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi50b2MoKS5jaGlsZHJlbiksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDJbJyQkYScgKyBpXSA9IHQyWyckJGEnICsgaV0gfHwgdGFnJC4kZ3VpZGVfdG9jKCkpLnNldFRvYyhhcnlbaV0pLnNldE9iamVjdChzZWxmLm9iamVjdCgpKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0XHR9KSh0Milcblx0XHRcdFx0XHQsMykuZW5kKClcblx0XHRcdFx0XSwyKSkgOiAoXG5cdFx0XHRcdFx0KHQzID0gc2VsZi4kYz1zZWxmLiRjIHx8IHRhZyQuJGEoKSkuc2V0SHJlZihzZWxmLnJvdXRlKCkpLnNldENvbnRlbnQoc2VsZi50b2MoKS50aXRsZSwzKS5lbmQoKVxuXHRcdFx0XHQpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdndWlkZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBvYmplY3RfO1xuXHRcdFx0aWYgKCEob2JqZWN0XyA9IHRoaXMub2JqZWN0KCkpICYmIG9iamVjdF8ucmVhZHkgICYmICBvYmplY3RfLnJlYWR5KCkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ21kJykuc2V0Qm9keSgodGhpcy5vYmplY3QoKS5ib2R5KCkpKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Qm9keSA9IGZ1bmN0aW9uIChib2R5KXtcblx0XHRcdGlmIChib2R5ICE9IHRoaXMuX2JvZHkpIHtcblx0XHRcdFx0dGhpcy5fYm9keSA9IGJvZHk7XG5cdFx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gYm9keTtcblx0XHRcdFx0aWYgKEltYmEuaXNDbGllbnQoKSkgdGhpcy5yZWF3YWtlbigpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHEkKCcuX3NuaXBwZXQnLHRoaXMpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFyeVtpXTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2d1aWRlcycsICdwYWdlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hdiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCB0MTtcblx0XHRcdHJldHVybiAodDAgPSB0aGlzLl9uYXY9dGhpcy5fbmF2IHx8IHRhZyQuJG5hdm1lbnUoKS5zZXRSZWYoJ25hdicsdGhpcykpLnNldENvbnRlbnQoXG5cdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodDEuJCRhID0gdDEuJCRhIHx8IHRhZyQuJGd1aWRlX3RvYygpKS5zZXRPYmplY3QoR3VpZGUuZ2V0KCcvZ3VpZGVzJykpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MS4kJGIgPSB0MS4kJGIgfHwgdGFnJC4kZ3VpZGVfdG9jKCkpLnNldE9iamVjdChHdWlkZS5nZXQoJy9ndWlkZXMvbGFuZ3VhZ2UnKSkuZW5kKClcblx0XHRcdFx0Ly8gPGd1aWRlLXRvY1tHdWlkZS5nZXQoJy9ndWlkZXMvdGlwcycpXT5cblx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0LDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDA7XG5cdFx0XHRyZXR1cm4gKHQwID0gdGhpcy5fYm9keT10aGlzLl9ib2R5IHx8IHRhZyQuJGRpdigpLnNldFJlZignYm9keScsdGhpcykuZmxhZygnbGlnaHQnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdCh0aGlzLmd1aWRlKCkpID8gKCh0MC4kJGEgPSB0MC4kJGEgfHwgdGFnJC4kZ3VpZGUoKSkuc2V0T2JqZWN0KHRoaXMuZ3VpZGUoKSkuZW5kKCkpIDogdm9pZCgwKVxuXHRcdFx0Ly8gPGd1aWRlQGRvYy5tZC5sIHNyYz1cIntyb3V0ZXIucGF0aH1cIj5cblx0XHRcdF0sMSkuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ucm91dGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmxvZygnb25yb3V0ZSBndWlkZXMnLHNlbGYucm91dGVyKCkuaGFzaCgpKTtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2VsZi5yb3V0ZXIoKS5oYXNoKCkpIHtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZWw7XG5cdFx0XHRcdFx0aWYgKGVsID0gc2VsZi5maXJzdCgnIycgKyBzZWxmLnJvdXRlcigpLmhhc2goKSkpIHtcblx0XHRcdFx0XHRcdHNlbGYubG9nKCdmb3VuZCBlbGVtZW50PyE/JyxlbCk7XG5cdFx0XHRcdFx0XHRlbC5kb20oKS5zY3JvbGxJbnRvVmlldyh0cnVlKTtcblx0XHRcdFx0XHRcdHJldHVybiBzZWxmLl9zY3JvbGxGcmVlemUgPSB3aW5kb3cuc2Nyb2xsWTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LDApO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ndWlkZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKHRoaXMucm91dGVyKCkuc2NvcGVkKCcvZ3VpZGVzJykpIHtcblx0XHRcdFx0cmV0dXJuIEd1aWRlLmdldCh0aGlzLnJvdXRlcigpLnBhdGgoKSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmIChJbWJhLmlzQ2xpZW50KCkpIHtcblx0XHRcdFx0Ly8gQGRvYyA9ICUlKGd1aWRlKVxuXHRcdFx0XHRzZWxmLnNjaGVkdWxlKHtmcHM6IDF9KTtcblx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2NoZWNrIHNjcm9sbGluZydcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5zY3JvbGxlZCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2Nyb2xsZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICghdGhpcy5oYXNGbGFnKCdzY29wZWQnKSkgeyByZXR1cm4gfTtcblx0XHRcdFxuXHRcdFx0dmFyIGl0ZW1zID0gcSQoJ1tpZF0nLHRoaXMpO1xuXHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XG5cdFx0XHQvLyBzaG91bGQgcHJvYmFibHkgY2FjaGUgdGhlc2UgcGVyaW9kaWNhbGx5XG5cdFx0XHR2YXIgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFk7XG5cdFx0XHR2YXIgd2ggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdFx0XHR2YXIgZGggPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX3Njcm9sbEZyZWV6ZSA+PSAwKSB7XG5cdFx0XHRcdHZhciBkaWZmID0gTWF0aC5hYnMoc2Nyb2xsVG9wIC0gdGhpcy5fc2Nyb2xsRnJlZXplKTtcblx0XHRcdFx0aWYgKGRpZmYgPCA1MCkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XHR0aGlzLl9zY3JvbGxGcmVlemUgPSAtMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBzY3JvbGxCb3R0b20gPSBkaCAtIChzY3JvbGxUb3AgKyB3aCk7XG5cdFx0XHRcblx0XHRcdC8vIGNvbnNvbGUubG9nIHNjcm9sbFRvcCx3aCxkaCxzY3JvbGxCb3R0b21cblx0XHRcdFxuXHRcdFx0aWYgKHNjcm9sbEJvdHRvbSA9PSAwKSB7XG5cdFx0XHRcdG1hdGNoID0gaXRlbXMubGFzdCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGl0ZW1zKSwgbGVuID0gYXJ5Lmxlbmd0aCwgaXRlbTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0aXRlbSA9IGFyeVtpXTtcblx0XHRcdFx0XHR2YXIgdCA9IChpdGVtLmRvbSgpLm9mZnNldFRvcCArIDMwICsgNjApOyAvLyBoYWNrXG5cdFx0XHRcdFx0dmFyIGRpc3QgPSBzY3JvbGxUb3AgLSB0O1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwie2l0ZW0uaWR9IHt0fSB7ZGlzdH1cIlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChkaXN0IDwgMCkge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBpdGVtO2JyZWFrO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJtYXRjaCBpcyB7bWF0Y2guaWR9XCJcblx0XHRcdFx0aWYgKHRoaXMuX2hhc2ggIT0gbWF0Y2guaWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuX2hhc2ggPSBtYXRjaC5pZCgpO1xuXHRcdFx0XHRcdHRoaXMucm91dGVyKCkuZ28oJyMnICsgdGhpcy5faGFzaCx7fSx0cnVlKTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2d1aWRlcy5pbWJhXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRmdW5jdGlvbiBwYXRoVG9BbmNob3IocGF0aCl7XG5cdFx0cmV0dXJuICdhcGktJyArIHBhdGgucmVwbGFjZSgvXFwuL2csJ18nKS5yZXBsYWNlKC9cXCMvZywnX18nKTtcblx0fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktZGVzYycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIdG1sID0gZnVuY3Rpb24gKGh0bWwpe1xuXHRcdFx0aWYgKGh0bWwgIT0gdGhpcy5faHRtbCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IHRoaXMuX2h0bWwgPSBodG1sO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1yZWYnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktaXRlbScpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1wYXRoJywgJ3NwYW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBvYmplY3RfO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHRpZiAoKHR5cGVvZiAob2JqZWN0XyA9IHRoaXMub2JqZWN0KCkpPT0nc3RyaW5nJ3x8b2JqZWN0XyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0dGhpcy5zZXRIdG1sKHRoaXMub2JqZWN0KCkucmVwbGFjZSgvXFxiKFtcXHddK3xcXC58XFwjKVxcYi9nLGZ1bmN0aW9uKG0saSkge1xuXHRcdFx0XHRcdGlmIChpID09ICcuJyB8fCBpID09ICcjJykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIChcIjxpPlwiICsgaSArIFwiPC9pPlwiKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlbMF0gPT0gaVswXS50b1VwcGVyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFwiPGIgY2xhc3M9J2NvbnN0Jz5cIiArIGkgKyBcIjwvYj5cIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiAoXCI8YiBjbGFzcz0naWQnPlwiICsgaSArIFwiPC9iPlwiKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1saW5rJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodGhpcy4kYSA9IHRoaXMuJGEgfHwgdGFnJC4kYXBpX3BhdGgoKS5mbGFnKCd2YWx1ZScpKS5zZXRPYmplY3QodGhpcy5vYmplY3QoKS52YWx1ZSkuZW5kKCksXG5cdFx0XHRcdCh0MCA9IHRoaXMuJGI9dGhpcy4kYiB8fCB0YWckLiRzcGFuKCkuZmxhZygnZGVzYycpKS5zZXRDb250ZW50KHRoaXMub2JqZWN0KCkuZGVzYywzKS5lbmQoKVxuXHRcdFx0XSwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktcmV0dXJuJywgJ2FwaS1saW5rJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLWNsYXNzJywgJ2FwaS1pdGVtJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fb2JqZWN0ID0ge3dhdGNoOiAncGFyc2UnLG5hbWU6ICdvYmplY3QnfTtcblx0XHR0YWcucHJvdG90eXBlLm9iamVjdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb2JqZWN0OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRPYmplY3QgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5vYmplY3QoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9vYmplY3QgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5wYXJzZSAmJiB0aGlzLnBhcnNlKHYsYSx0aGlzLl9fb2JqZWN0KSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLm9iamVjdCgpWycuJ10pLCBsZW4gPSBhcnkubGVuZ3RoLCBtLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdG0gPSBhcnlbaV07XG5cdFx0XHRcdGlmICghbS5kZXNjKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRyZXMucHVzaChtKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLl9zdGF0aWNzID0gcmVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMub2JqZWN0KClbJyMnXSksIGxlbiA9IGFyeS5sZW5ndGgsIG0xLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdG0xID0gYXJ5W2ldO1xuXHRcdFx0XHRpZiAoIW0xLmRlc2MpIHsgY29udGludWU7IH07XG5cdFx0XHRcdHJlcy5wdXNoKG0xKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLl9tZXRob2RzID0gcmVzO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IFtdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgc2VsZiA9IHRoaXMsIHQ1LCB0NiwgdDc7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdCh0aGlzLiRhID0gdGhpcy4kYSB8fCB0YWckLiRzcGFuKCkuZmxhZygndG9jLWFuY2hvcicpKS5zZXRJZChwYXRoVG9BbmNob3IodGhpcy5vYmplY3QoKS5uYW1lcGF0aCkpLmVuZCgpLFxuXHRcdFx0XHQodDAgPSB0aGlzLiRiPXRoaXMuJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykpLnNldENvbnRlbnQoKHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCd0aXRsZScpKS5zZXRDb250ZW50KCh0MS4kJGEgPSB0MS4kJGEgfHwgdGFnJC4kYXBpX3BhdGgoKSkuc2V0T2JqZWN0KHRoaXMub2JqZWN0KCkubmFtZXBhdGgpLmVuZCgpLDIpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy4kYyA9IHRoaXMuJGMgfHwgdGFnJC4kYXBpX2Rlc2MoKSkuc2V0SHRtbCh0aGlzLm9iamVjdCgpLmh0bWwpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy5vYmplY3QoKS5jdG9yKSA/IChcblx0XHRcdFx0XHQodDIgPSB0aGlzLiRkPXRoaXMuJGQgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpLmZsYWcoJ2N0b3InKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdCh0Mi4kJGEgPSB0Mi4kJGEgfHwgdGFnJC4kYXBpX21ldGhvZCgpKS5zZXRQYXRoKCh0aGlzLm9iamVjdCgpLm5hbWVwYXRoICsgJy5uZXcnKSkuc2V0T2JqZWN0KHRoaXMub2JqZWN0KCkuY3RvcikuZW5kKClcblx0XHRcdFx0XHQsMikuZW5kKClcblx0XHRcdFx0KSA6IHZvaWQoMCksXG5cdFx0XHRcdFxuXHRcdFx0XHQodDMgPSBzZWxmLiRlPXNlbGYuJGUgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodGhpcy5fc3RhdGljcy5sZW5ndGggPiAwKSA/IChcblx0XHRcdFx0XHRcdCh0NCA9IHQzLiQkYT10My4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnc2VjdGlvbicpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0KHQ0LiQkYSA9IHQ0LiQkYSB8fCB0YWckLiRoMigpLmZsYWcoJ2hlYWRlcicpKS5zZXRUZXh0KCdTdGF0aWMgTWV0aG9kcycpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDUgPSB0NC4kJGI9dDQuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKS5mbGFnKCdsaXN0JykpLnNldENvbnRlbnQoKGZ1bmN0aW9uKHQ1KSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuX3N0YXRpY3MpLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDVbJyQkYScgKyBpXSA9IHQ1WyckJGEnICsgaV0gfHwgdGFnJC4kYXBpX21ldGhvZCgpLmZsYWcoJ2RvYycpKS5zZXRJbmFtZShzZWxmLm9iamVjdCgpLm5hbWVwYXRoKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdFx0XHR9KSh0NSksMykuZW5kKClcblx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHQpIDogdm9pZCgwKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQoc2VsZi5fbWV0aG9kcy5sZW5ndGggPiAwKSA/IChcblx0XHRcdFx0XHRcdCh0NiA9IHQzLiQkYj10My4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnc2VjdGlvbicpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0KHQ2LiQkYSA9IHQ2LiQkYSB8fCB0YWckLiRoMigpLmZsYWcoJ2hlYWRlcicpKS5zZXRUZXh0KCdJbnN0YW5jZSBNZXRob2RzJykuZW5kKCksXG5cdFx0XHRcdFx0XHRcdCh0NyA9IHQ2LiQkYj10Ni4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpLmZsYWcoJ2xpc3QnKSkuc2V0Q29udGVudCgoZnVuY3Rpb24odDcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5fbWV0aG9kcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlcy5wdXNoKCh0N1snJCRhJyArIGldID0gdDdbJyQkYScgKyBpXSB8fCB0YWckLiRhcGlfbWV0aG9kKCkuZmxhZygnZG9jJykpLnNldEluYW1lKHNlbGYub2JqZWN0KCkuaW5hbWUpLnNldE9iamVjdChhcnlbaV0pLmVuZCgpKTtcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0XHRcdH0pKHQ3KSwzKS5lbmQoKVxuXHRcdFx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XHRcdCkgOiB2b2lkKDApXG5cdFx0XHRcdF0sMSkuZW5kKClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLXZhbHVlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIG9iamVjdF8sICQxO1xuXHRcdFx0aWYgKHRoaXMub2JqZWN0KCkudHlwZSkge1xuXHRcdFx0XHR0aGlzLmZsYWcodGhpcy5vYmplY3QoKS50eXBlKS5zZXRDaGlsZHJlbihcblx0XHRcdFx0XHR0aGlzLm9iamVjdCgpLnZhbHVlXG5cdFx0XHRcdCwzKS5zeW5jZWQoKTtcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiAob2JqZWN0XyA9IHRoaXMub2JqZWN0KCkpPT0nc3RyaW5nJ3x8b2JqZWN0XyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0dGhpcy5mbGFnKCdzdHInKS5zZXRUZXh0KHRoaXMub2JqZWN0KCkpLnN5bmNlZCgpO1xuXHRcdFx0fSBlbHNlIGlmICgodHlwZW9mICgkMSA9IHRoaXMub2JqZWN0KCkpPT0nbnVtYmVyJ3x8JDEgaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG5cdFx0XHRcdHRoaXMuZmxhZygnbnVtJykuc2V0VGV4dCh0aGlzLm9iamVjdCgpKS5zeW5jZWQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLXBhcmFtJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9iamVjdCgpLnR5cGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCB0MCwgdDE7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKHNlbGYudHlwZSgpKS5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHNlbGYudHlwZSgpID09ICdOYW1lZFBhcmFtcycgPyAoXG5cdFx0XHRcdFx0KGZ1bmN0aW9uKHNlbGYpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLm9iamVjdCgpLm5vZGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgoc2VsZlsnJGEnICsgaV0gPSBzZWxmWyckYScgKyBpXSB8fCB0YWckLiRhcGlfcGFyYW0oKSkuc2V0T2JqZWN0KGFyeVtpXSkuZW5kKCkpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fSkoc2VsZilcblx0XHRcdFx0KSA6IChJbWJhLnN0YXRpYyhbXG5cdFx0XHRcdFx0KHQwID0gc2VsZi4kYj1zZWxmLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ25hbWUnKSkuc2V0Q29udGVudChzZWxmLm9iamVjdCgpLm5hbWUsMykuZW5kKCksXG5cdFx0XHRcdFx0KHNlbGYub2JqZWN0KCkuZGVmYXVsdHMpID8gKEltYmEuc3RhdGljKFtcblx0XHRcdFx0XHRcdCh0MSA9IHNlbGYuJGM9c2VsZi4kYyB8fCB0YWckLiRpKCkpLnNldENvbnRlbnQoW3NlbGYudHlwZSgpID09ICdOYW1lZFBhcmFtJyA/ICgnOiAnKSA6ICgnID0gJyldLDEpLmVuZCgpLFxuXHRcdFx0XHRcdFx0KHNlbGYuJGQgPSBzZWxmLiRkIHx8IHRhZyQuJGFwaV92YWx1ZSgpKS5zZXRPYmplY3Qoc2VsZi5vYmplY3QoKS5kZWZhdWx0cykuZW5kKClcblx0XHRcdFx0XHRdLDIpKSA6IHZvaWQoMClcblx0XHRcdFx0XSwzKSlcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLW1ldGhvZCcsICdhcGktaXRlbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faW5hbWU7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEluYW1lID0gZnVuY3Rpb24odil7IHRoaXMuX2luYW1lID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXRoOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24odil7IHRoaXMuX3BhdGggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRhZ3MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiAodDAgPSB0aGlzLl90YWdzPXRoaXMuX3RhZ3MgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCd0YWdzJyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdCh0aGlzLm9iamVjdCgpLmRlcHJlY2F0ZWQpID8gKFxuXHRcdFx0XHRcdCh0MC4kJGEgPSB0MC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnZGVwcmVjYXRlZCcpLmZsYWcoJ3JlZCcpKS5zZXRUZXh0KCdNZXRob2QgaXMgZGVwcmVjYXRlZCcpLmVuZCgpXG5cdFx0XHRcdCkgOiB2b2lkKDApLFxuXHRcdFx0XHQodGhpcy5vYmplY3QoKS5yZXR1cm4pID8gKCh0MC4kJGIgPSB0MC4kJGIgfHwgdGFnJC4kYXBpX3JldHVybigpLnNldE5hbWUoJ3JldHVybnMnKSkuc2V0T2JqZWN0KHRoaXMub2JqZWN0KCkucmV0dXJuKS5lbmQoKSkgOiB2b2lkKDApXG5cdFx0XHRdLDEpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCAodGhpcy5pbmFtZSgpICsgJy4nICsgdGhpcy5vYmplY3QoKS5uYW1lKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2x1ZyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHBhdGhUb0FuY2hvcih0aGlzLm9iamVjdCgpLm5hbWVwYXRoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHNlbGYgPSB0aGlzLCB0MTtcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ2RlcHJlY2F0ZWQnLHRoaXMub2JqZWN0KCkuZGVwcmVjYXRlZCkuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodGhpcy4kYSA9IHRoaXMuJGEgfHwgdGFnJC4kc3BhbigpLmZsYWcoJ3RvYy1hbmNob3InKSkuc2V0SWQodGhpcy5zbHVnKCkpLmVuZCgpLFxuXHRcdFx0XHQodDAgPSBzZWxmLiRiPXNlbGYuJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0MC4kJGEgPSB0MC4kJGEgfHwgdGFnJC4kYXBpX3BhdGgoKSkuc2V0T2JqZWN0KHRoaXMucGF0aCgpKS5lbmQoKSxcblx0XHRcdFx0XHQodDEgPSB0MC4kJGI9dDAuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3BhcmFtcycpKS5zZXRDb250ZW50KChmdW5jdGlvbih0MSkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYub2JqZWN0KCkucGFyYW1zKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDFbJyQkYScgKyBpXSA9IHQxWyckJGEnICsgaV0gfHwgdGFnJC4kYXBpX3BhcmFtKCkpLnNldE9iamVjdChhcnlbaV0pLmVuZCgpKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdH0pKHQxKSwzKS5lbmQoKSxcblx0XHRcdFx0XHQodDAuJCRjID0gdDAuJCRjIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2dyb3cnKSkuZW5kKClcblx0XHRcdFx0XSwyKS5lbmQoKSxcblx0XHRcdFx0KHNlbGYuJGMgPSBzZWxmLiRjIHx8IHRhZyQuJGFwaV9kZXNjKCkuZmxhZygnbWQnKSkuc2V0SHRtbChzZWxmLm9iamVjdCgpLmh0bWwpLmVuZCgpLFxuXHRcdFx0XHRzZWxmLnRhZ3MoKVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdkb2MtbGluaycsICdhJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5zZXRIcmVmKChcIi9kb2NzI1wiICsgcGF0aFRvQW5jaG9yKHRoaXMub2JqZWN0KCkubmFtZXBhdGgpKSkuc2V0Q2hpbGRyZW4oKHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJGFwaV9wYXRoKCkpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLm5hbWVwYXRoKS5lbmQoKSwyKS5zeW5jZWQoKTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLnJlbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udGFwID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0YWcuX19zdXBlcl9fLm9udGFwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiB0aGlzLnVwKHEkKCcuX2RvY3MnLHRoaXMpKS5yZWZvY3VzKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZG9jLWdyb3VwJywgJ3RvYycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRhcCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudG9nZ2xlRmxhZygnY29sbGFwc2VkJyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdkb2NzJywgJ3BhZ2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX192ZXJzaW9uID0geydkZWZhdWx0JzogJzAuMTQuMScsbmFtZTogJ3ZlcnNpb24nfTtcblx0XHR0YWcucHJvdG90eXBlLnZlcnNpb24gPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZlcnNpb247IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZlcnNpb24gPSBmdW5jdGlvbih2KXsgdGhpcy5fdmVyc2lvbiA9IHY7IHJldHVybiB0aGlzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5fdmVyc2lvbiA9ICcwLjE0LjEnO1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucm9vdHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3Jvb3RzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSb290cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yb290cyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKFwiL2FwaS9cIiArIHRoaXMudmVyc2lvbigpICsgXCIuanNvblwiKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZG9jcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvY3M7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2FkKCk7XG5cdFx0XHR0aGlzLnNjaGVkdWxlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9hZCgpO1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18uYnVpbGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoSW1iYS5TRVJWRVIpIHtcblx0XHRcdFx0Ly8gcmV0dXJuIHNlbGZcblx0XHRcdFx0QVBQLmZldGNoRG9jdW1lbnQoc2VsZi5zcmMoKSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHRzZWxmLl9kb2NzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXMpKTtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5nZW5lcmF0ZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZi5fcmVxdWVzdCB8fCAoc2VsZi5fcmVxdWVzdCA9IEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCksZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdERPQ1MgPSBzZWxmLl9kb2NzID0gcmVzO1xuXHRcdFx0XHRET0NNQVAgPSBzZWxmLl9kb2NzLmVudGl0aWVzO1xuXHRcdFx0XHRzZWxmLmdlbmVyYXRlKCk7XG5cdFx0XHRcdHJldHVybiBzZWxmLmxvYWRlZCgpO1xuXHRcdFx0fSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBlbDtcblx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHQvLyByZWFsbHk/XG5cdFx0XHRpZiAoZG9jdW1lbnQubG9jYXRpb24uaGFzaCkge1xuXHRcdFx0XHRpZiAoZWwgPSB0aGlzLmZpcnN0KGRvY3VtZW50LmxvY2F0aW9uLmhhc2gpKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3Nob3VsZCBzY3JvbGwgaGVyZT8hPyE/IScsZWxcblx0XHRcdFx0XHRlbC5kb20oKS5zY3JvbGxJbnRvVmlldygpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWZvY3VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHRpZiAoZWwgPSB0aGlzLmZpcnN0KGRvY3VtZW50LmxvY2F0aW9uLmhhc2gpKSB7XG5cdFx0XHRcdGVsLmRvbSgpLnNjcm9sbEludG9WaWV3KCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChwYXRoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvY3MoKS5lbnRpdGllc1twYXRoXTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuX3Jvb3RzID0gW107XG5cdFx0XHR2YXIgZW50cyA9IHRoaXMuX2RvY3MuZW50aXRpZXM7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIG8gPSB0aGlzLmRvY3MoKS5lbnRpdGllcywgaXRlbSwgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0aXRlbSA9IG9ba2V5c1tpXV07aWYgKGl0ZW0udHlwZSA9PSAnY2xhc3MnIHx8IGtleXNbaV0gPT0gJ0ltYmEnKSB7XG5cdFx0XHRcdFx0aXRlbVsnLiddID0gKGl0ZW1bJy4nXSB8fCBbXSkuc29ydCgpLm1hcChmdW5jdGlvbihwYXRoKSB7IHJldHVybiBlbnRzW3BhdGhdOyB9KS5maWx0ZXIoZnVuY3Rpb24odikgeyByZXR1cm4gdi50eXBlID09ICdtZXRob2QnICYmIHYuZGVzYzsgfSk7XG5cdFx0XHRcdFx0aXRlbVsnIyddID0gKGl0ZW1bJyMnXSB8fCBbXSkuc29ydCgpLm1hcChmdW5jdGlvbihwYXRoKSB7IHJldHVybiBlbnRzW3BhdGhdOyB9KS5maWx0ZXIoZnVuY3Rpb24odikgeyByZXR1cm4gdi50eXBlID09ICdtZXRob2QnICYmIHYuZGVzYzsgfSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGl0ZW0uZGVzYykgeyB0aGlzLl9yb290cy5wdXNoKGl0ZW0pIH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKCEodGhpcy5kb2NzKCkpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5yZW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHQwO1xuXHRcdFx0cmV0dXJuICh0MCA9IHNlbGYuX2JvZHk9c2VsZi5fYm9keSB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2JvZHknLHRoaXMpLmZsYWcoJ2xpZ2h0JykpLnNldENvbnRlbnQoXG5cdFx0XHRcdChmdW5jdGlvbih0MCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLnJvb3RzKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXMucHVzaCgodDBbJyQkYScgKyBpXSA9IHQwWyckJGEnICsgaV0gfHwgdGFnJC4kYXBpX2NsYXNzKCkuZmxhZygnZG9jJykuZmxhZygnbCcpKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9KSh0MClcblx0XHRcdCwzKS5lbmQoKTtcblx0XHR9O1xuXHRcdHRhZy5wcm90b3R5cGUubmF2ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHNlbGYgPSB0aGlzLCB0MTtcblx0XHRcdHJldHVybiAodDAgPSBzZWxmLl9uYXY9c2VsZi5fbmF2IHx8IHRhZyQuJG5hdm1lbnUoKS5zZXRSZWYoJ25hdicsdGhpcykpLnNldENvbnRlbnQoXG5cdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdChmdW5jdGlvbih0MSkge1xuXHRcdFx0XHRcdFx0dmFyIHQyLCB0MywgdDQsIHQ1LCB0Njtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLnJvb3RzKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCByb290LCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHJvb3QgPSBhcnlbaV07XG5cdFx0XHRcdFx0XHRcdHJlcy5wdXNoKCh0MiA9IHQxWyckJGEnICsgaV09dDFbJyQkYScgKyBpXSB8fCB0YWckLiRkb2NfZ3JvdXAoKS5mbGFnKCdjbGFzcycpLmZsYWcoJ3NlY3Rpb24nKS5mbGFnKCdjb21wYWN0JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHRcdCh0MyA9IHQyLiQkYT10Mi4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykpLnNldENvbnRlbnQoKHQzLiQkYSA9IHQzLiQkYSB8fCB0YWckLiRkb2NfbGluaygpLmZsYWcoJ2NsYXNzJykpLnNldE9iamVjdChyb290KS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0XHQodDQgPSB0Mi4kJGI9dDIuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdFx0XHQodDUgPSB0NC4kJGE9dDQuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3N0YXRpYycpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoZnVuY3Rpb24odDUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdDY7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGl0ZW1zID0gaXRlciQocm9vdFsnLiddKSwgbGVuXyA9IGl0ZW1zLmxlbmd0aCwgbWV0aCwgcmVzMSA9IFtdOyBqIDwgbGVuXzsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtZXRoID0gaXRlbXNbal07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW1ldGguZGVzYykgeyBjb250aW51ZTsgfTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlczEucHVzaCgodDYgPSB0NVsnJCRhJyArIGpdPXQ1WyckJGEnICsgal0gfHwgdGFnJC4kZGl2KCkuZmxhZygnZW50cnknKSkuc2V0Q29udGVudCgodDYuJCRhID0gdDYuJCRhIHx8IHRhZyQuJGRvY19saW5rKCkpLnNldE9iamVjdChtZXRoKS5lbmQoKSwyKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSkodDUpXG5cdFx0XHRcdFx0XHRcdFx0XHQsMykuZW5kKCksXG5cdFx0XHRcdFx0XHRcdFx0XHQodDYgPSB0NC4kJGI9dDQuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2luc3RhbmNlJykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdChmdW5jdGlvbih0Nikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB0Nztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMCwgaXRlbXMgPSBpdGVyJChyb290WycjJ10pLCBsZW5fID0gaXRlbXMubGVuZ3RoLCBtZXRoLCByZXMxID0gW107IGogPCBsZW5fOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1ldGggPSBpdGVtc1tqXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghbWV0aC5kZXNjKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzMS5wdXNoKCh0NyA9IHQ2WyckJGEnICsgal09dDZbJyQkYScgKyBqXSB8fCB0YWckLiRkaXYoKS5mbGFnKCdlbnRyeScpKS5zZXRDb250ZW50KCh0Ny4kJGEgPSB0Ny4kJGEgfHwgdGFnJC4kZG9jX2xpbmsoKSkuc2V0T2JqZWN0KG1ldGgpLmVuZCgpLDIpLmVuZCgpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXMxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KSh0Nilcblx0XHRcdFx0XHRcdFx0XHRcdCwzKS5lbmQoKVxuXHRcdFx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHRcdFx0XSwyKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHR9KSh0MSlcblx0XHRcdFx0LDMpLmVuZCgpXG5cdFx0XHQsMikuZW5kKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvZG9jcy5pbWJhXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBleHRlcm5zO1xuXHRcblx0Ly8gdmFyIGhsanMgPSByZXF1aXJlICdoaWdobGlnaHQuanMnXG5cdFxuXHR0YWckLmRlZmluZVRhZygndG9vbCcsICdidXR0b24nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWN0aW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9hY3Rpb247IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEFjdGlvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hY3Rpb24gPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnc3ltJykuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnYnV0dG9uIGNsaWNrJyxlKTtcblx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy5sb2coJ3RvdWNoc3RhcnQnKTtcblx0XHRcdHRydWU7XG5cdFx0XHRyZXR1cm4gZS5ldmVudCgpLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc25pcHBldC1oaW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRUZXh0KFwiSSBhbSBhIGhpbnQhIVwiKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdvdmVybGF5cycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHJvb3Q7XG5cdFx0XHRpZiAocm9vdCA9IHRoaXMudmlldygpLl9yb290KSB7XG5cdFx0XHRcdHZhciBsZWZ0ID0gMCx0b3AgPSAwLGVsID0gcm9vdC5kb20oKTtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChlbCAmJiAhZWwuY29udGFpbnModGhpcy5fZG9tKSl7XG5cdFx0XHRcdFx0bGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xuXHRcdFx0XHRcdHRvcCArPSBlbC5vZmZzZXRUb3AgLSBlbC5zY3JvbGxUb3A7XG5cdFx0XHRcdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5fZG9tLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4Jztcblx0XHRcdFx0dGhpcy5fZG9tLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdoaW50LWxhYmVsJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldExhYmVsID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0aWYgKHRleHQgIT0gdGhpcy5fbGFiZWwpIHtcblx0XHRcdFx0dGhpcy5fbGFiZWwgPSB0ZXh0O1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IHRleHQ7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnb3ZlcmxheS1oaW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19yb3cgPSB7d2F0Y2g6ICdyb3dEaWRTZXQnLG5hbWU6ICdyb3cnfTtcblx0XHR0YWcucHJvdG90eXBlLnJvdyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm93OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSb3cgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5yb3coKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9yb3cgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5yb3dEaWRTZXQgJiYgdGhpcy5yb3dEaWRTZXQodixhLHRoaXMuX19yb3cpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2NvbCA9IHt3YXRjaDogJ2NvbERpZFNldCcsbmFtZTogJ2NvbCd9O1xuXHRcdHRhZy5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb2w7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldENvbCA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmNvbCgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2NvbCA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmNvbERpZFNldCAmJiB0aGlzLmNvbERpZFNldCh2LGEsdGhpcy5fX2NvbCkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fbGVuID0ge3dhdGNoOiAnbGVuRGlkU2V0JyxuYW1lOiAnbGVuJ307XG5cdFx0dGFnLnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2xlbjsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TGVuID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMubGVuKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fbGVuID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMubGVuRGlkU2V0ICYmIHRoaXMubGVuRGlkU2V0KHYsYSx0aGlzLl9fbGVuKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucm93RGlkU2V0ID0gZnVuY3Rpb24gKG5ldyQsb2xkKXtcblx0XHRcdHZhciB2YWwgPSAoXCJcIiArICh0aGlzLm9iamVjdCgpLnJvdygpICogdGhpcy52aWV3KCkubGluZUhlaWdodCgpKSArIFwicHhcIik7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnN0eWxlLnRvcCA9IHZhbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29sRGlkU2V0ID0gZnVuY3Rpb24gKG5ldyQsb2xkKXtcblx0XHRcdHZhciB2YWwgPSAoXCJcIiArICh0aGlzLm9iamVjdCgpLmNvbCgpICogdGhpcy52aWV3KCkuY2hhcldpZHRoKCkpICsgXCJweFwiKTtcblx0XHRcdHJldHVybiB0aGlzLl9kb20uc3R5bGUubGVmdCA9IHZhbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubGVuRGlkU2V0ID0gZnVuY3Rpb24gKG5ldyQsb2xkKXtcblx0XHRcdHZhciB3aWR0aCA9IChcIlwiICsgKG5ldyQgKiB0aGlzLnZpZXcoKS5jaGFyV2lkdGgoKSkgKyBcInB4XCIpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdoaW50IGF0JyxvYmplY3Qucm93XG5cdFx0XHR2YXIgcmVnID0gdGhpcy5vYmplY3QoKS5yZWdpb24oKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlZykge1xuXHRcdFx0XHR0aGlzLnNldFJvdyh0aGlzLm9iamVjdCgpLnJvdygpKTtcblx0XHRcdFx0dGhpcy5zZXRDb2wodGhpcy5vYmplY3QoKS5jb2woKSk7XG5cdFx0XHRcdHRoaXMuc2V0TGVuKHJlZy5zaXplKCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnd2FybicpLmZsYWcoJ2dsb2JhbCcsKCFyZWcpKS5zZXRUeXBlKCh0aGlzLm9iamVjdCgpLnR5cGUoKSkpLnNldENoaWxkcmVuKFxuXHRcdFx0XHQodGhpcy4kYSA9IHRoaXMuJGEgfHwgdGFnJC4kaGludF9sYWJlbCgpLmZsYWcoJ2xhYmVsJykpLnNldExhYmVsKHRoaXMub2JqZWN0KCkubGFiZWwoKSkuZW5kKClcblx0XHRcdCwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdqc3ZpZXcnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbigodGhpcy5fY29kZSA9IHRoaXMuX2NvZGUgfHwgdGFnJC4kY29kZSgpLnNldFJlZignY29kZScsdGhpcykpLmVuZCgpLDIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvZGUsY2Ipe1xuXHRcdFx0Ly8gc2hvdWxkIGNvbXBpbGUgYmFyZVxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0Y29kZSA9IGNvZGUucmVwbGFjZSgvXFwvXFwvXFwjIHNvdXJjZU1hcHBpbmcoLiopJC8sJycpO1xuXHRcdFx0Y29kZSA9IGNvZGUucmVwbGFjZSgvXlxcKGZ1bmN0aW9uXFwoXFwpXFx7XFxuLywnJyk7XG5cdFx0XHRjb2RlID0gY29kZS5yZXBsYWNlKC9cXG4/XFx9XFwpXFwoXFwpXFxuPyQvLCcnKTtcblx0XHRcdC8vIGNvZGUgPSBjb2RlLnJlcGxhY2UoL15cXHQvbWcsJycpXG5cdFx0XHR0aGlzLl9jb2RlLnRleHRDb250ZW50ID0gY29kZTtcblx0XHRcdFxuXHRcdFx0dGhpcy5mbGFnKCdodWdlJyxjb2RlLmxlbmd0aCA+IDEwMDApO1xuXHRcdFx0XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRobGpzLmNvbmZpZ3VyZSh7Y2xhc3NQcmVmaXg6ICcnfSk7XG5cdFx0XHRcdHZhciBobCA9IGhsanMuaGlnaGxpZ2h0KCdqYXZhc2NyaXB0Jyxjb2RlKTtcblx0XHRcdFx0c2VsZi5fY29kZS5zZXRIdG1sKGhsLnZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIGNiICYmIGNiKHNlbGYpO1xuXHRcdFx0fSwwKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnY29uc29sZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lZGl0b3IgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2VkaXRvcjsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RWRpdG9yID0gZnVuY3Rpb24odil7IHRoaXMuX2VkaXRvciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZW1wdHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuZWRpdG9yKCkpIHtcblx0XHRcdFx0dGhpcy5lZGl0b3IoKS5mbGFnKCdjb25zb2xlJyk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2xvZ2dpbmcgdmFsJyx2YWxcblx0XHRcdFxuXHRcdFx0aWYgKHZhbCA9PSB0aGlzKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh2YWwgJiYgdmFsLmRvbSkge1xuXHRcdFx0XHR2YWwgPSB2YWwuZG9tKCkub3V0ZXJIVE1MO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdFx0dmFsID0gSlNPTi5zdHJpbmdpZnkodmFsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh2YWwgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuYXBwZW5kKHRhZyQuJGRpdigpLmZsYWcoJ2pzb24nKS5zZXRDb250ZW50KHZhbCwwKS5lbmQoKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm47XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0Ly8gdGhpcyBpcyBiYXNpY2FsbHkgbGlrZSBhbiBlZGl0b3Jcblx0dGFnJC5kZWZpbmVUYWcoJ3NuaXBwZXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmltYmEgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2ltYmE7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEltYmEgPSBmdW5jdGlvbih2KXsgdGhpcy5faW1iYSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb25maWc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldENvbmZpZyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jb25maWcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fc3JjID0ge3dhdGNoOiAncmVsb2FkJyxuYW1lOiAnc3JjJ307XG5cdFx0dGFnLnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3NyYzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMuc3JjKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fc3JjID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMucmVsb2FkICYmIHRoaXMucmVsb2FkKHYsYSx0aGlzLl9fc3JjKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGVhZGluZyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hlYWRpbmcnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnaGVhZGluZycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbGF5b3V0Jyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldExheW91dCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbGF5b3V0Jyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50YWIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0YWInKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGFiID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0YWInLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fYWN0aXZlID0ge3dhdGNoOiAnYWN0aXZlRGlkU2V0JyxuYW1lOiAnYWN0aXZlJ307XG5cdFx0dGFnLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMuYWN0aXZlKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fYWN0aXZlID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuYWN0aXZlRGlkU2V0ICYmIHRoaXMuYWN0aXZlRGlkU2V0KHYsYSx0aGlzLl9fYWN0aXZlKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBkb21fO1xuXHRcdFx0cmV0dXJuIChkb21fID0gdGhpcy5kb20oKSkuaWQgfHwgKGRvbV8uaWQgPSAoXCJzbmlwcGV0XCIgKyAoY291bnRlcisrKSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hY3RpdmVEaWRTZXQgPSBmdW5jdGlvbiAoYm9vbCl7XG5cdFx0XHRyZXR1cm4gYm9vbCA/ICh0aGlzLnNjaGVkdWxlKHtmcHM6IDYwfSkpIDogKHRoaXMudW5zY2hlZHVsZSgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5wdXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAodGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dCB8fCB0YWckLiRpbWNhcHRvcigpLnNldFJlZignaW5wdXQnLHRoaXMpKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZpZXcgfHwgKHRoaXMuX3ZpZXcgPSAodGhpcy5fdmlldyA9IHRoaXMuX3ZpZXcgfHwgdGFnJC4kaW12aWV3KCkuc2V0UmVmKCd2aWV3Jyx0aGlzKSkuc2V0SW5wdXQodGhpcy5pbnB1dCgpKS5lbmQoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRcblx0XHRcdHZhciBzZWxmID0gdGhpcywgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NTtcblx0XHRcdGlmIChJbWJhLlNFUlZFUikge1xuXHRcdFx0XHRpZiAoc2VsZi5zcmMoKSAmJiBzZWxmLnNyYygpLm1hdGNoKC9cXC5pbWJhJC8pKSB7XG5cdFx0XHRcdFx0QVBQLmZldGNoRG9jdW1lbnQoc2VsZi5zcmMoKSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHRcdHZhciB2Xztcblx0XHRcdFx0XHRcdHJldHVybiAoc2VsZi5zZXRJbWJhKHZfID0gcmVzLmh0bWwpLHZfKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gcHJlcmVuZGVyIHNoZWxsXG5cdFx0XHRcdHNlbGYuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHRcdCh0MCA9IHNlbGYuX21haW49c2VsZi5fbWFpbiB8fCB0YWckLiRzZWN0aW9uKCkuc2V0UmVmKCdtYWluJyxzZWxmKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHQodDEgPSBzZWxmLl9oZWFkZXI9c2VsZi5faGVhZGVyIHx8IHRhZyQuJGhlYWRlcigpLnNldFJlZignaGVhZGVyJyxzZWxmKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdCh0MiA9IHQxLiQkYT10MS4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygndGl0bGUnKS5mbGFnKCdwYXRoJykpLnNldENvbnRlbnQoc2VsZi5oZWFkaW5nKCksMykuZW5kKCksXG5cdFx0XHRcdFx0XHRcdCh0MyA9IHQxLiQkYj10MS4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygndG9vbHMnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdFx0KHQzLiQkYSA9IHQzLiQkYSB8fCB0YWckLiR0b29sKCkuZmxhZygncmVzZXQnKS5zZXRUaXRsZSgncmVzZXQnKS5zZXRIYW5kbGVyKCd0YXAnLCdyZXNldCcsc2VsZikpLnNldFRleHQoJ3Jlc2V0JykuZW5kKCksXG5cdFx0XHRcdFx0XHRcdFx0KHQzLiQkYiA9IHQzLiQkYiB8fCB0YWckLiR0b29sKCkuZmxhZygnanMnKS5zZXRUaXRsZSgnc2hvdyBqcycpLnNldEhhbmRsZXIoJ3RhcCcsJ3RvZ2dsZUpTJyxzZWxmKSkuc2V0VGV4dCgnc2hvdyBqcycpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHRcdCh0My4kJGMgPSB0My4kJGMgfHwgdGFnJC4kdG9vbCgpLmZsYWcoJ3J1bicpLnNldFRpdGxlKCdydW4nKS5zZXRIYW5kbGVyKCd0YXAnLCdydW4nLHNlbGYpKS5zZXRUZXh0KCdydW4nKS5lbmQoKVxuXHRcdFx0XHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRcdFx0XHRdLDIpLmVuZCgpLFxuXHRcdFx0XHRcdFx0KHQ0ID0gc2VsZi5fdmlldz1zZWxmLl92aWV3IHx8IHRhZyQuJGRpdigpLnNldFJlZigndmlldycsc2VsZikpLnNldENvbnRlbnQoKHQ1ID0gdDQuJCRhPXQ0LiQkYSB8fCB0YWckLiRjb2RlKCkuZmxhZygnaW1iYWNvZGUnKSkuZGF0YXNldCgnc3JjJywoc2VsZi5zcmMoKSkpLnNldENvbnRlbnQoc2VsZi5pbWJhKCksMykuZW5kKCksMikuZW5kKClcblx0XHRcdFx0XHRdLDIpLmVuZCgpLFxuXHRcdFx0XHRcdChzZWxmLl9pbnNwZWN0b3IgPSBzZWxmLl9pbnNwZWN0b3IgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdpbnNwZWN0b3InLHNlbGYpKS5lbmQoKVxuXHRcdFx0XHRdLDIpLnN5bmNlZCgpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRhZy5fX3N1cGVyX18uYnVpbGQuYXBwbHkoc2VsZixhcmd1bWVudHMpO1xuXHRcdFx0aWYgKHNlbGYuc3JjKCkpIHsgcmV0dXJuIHNlbGYucmVsb2FkKCkgfTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNmZyl7XG5cdFx0XHR2YXIgdl87XG5cdFx0XHRpZiAoY2ZnICE9IHRoaXMuX29wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fb3B0aW9ucyA9IGNmZztcblx0XHRcdFx0aWYgKGNmZy50aXRsZSkgeyAodGhpcy5zZXRIZWFkaW5nKHZfID0gY2ZnLnRpdGxlKSx2XykgfTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29wdHMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9jb3B0cyB8fCAodGhpcy5fY29wdHMgPSB7XG5cdFx0XHRcdGJhcmU6IGZhbHNlLFxuXHRcdFx0XHRzdGFuZGFsb25lOiBmYWxzZSxcblx0XHRcdFx0c291cmNlTWFwSW5saW5lOiB0cnVlLFxuXHRcdFx0XHRmaWxlbmFtZTogKFwiXCIgKyB0aGlzLmlkKCkgKyBcIi5pbWJhXCIpLFxuXHRcdFx0XHR0YXJnZXRQYXRoOiAoXCJcIiArIHRoaXMuaWQoKSArIFwiLmpzXCIpLFxuXHRcdFx0XHRzb3VyY2VQYXRoOiAoXCJcIiArIHRoaXMuaWQoKSArIFwiLmltYmFcIilcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAoa2V5KXtcblx0XHRcdHJldHVybiB0aGlzLl9vcHRpb25zID8gKHRoaXMuX29wdGlvbnNba2V5XSkgOiAobnVsbCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdHRoaXMuX29wdGlvbnMgPSBvO1xuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGNvbmZpZyA9IHt9O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIGNvZGUgPSBxJCQoJy5pbWJhY29kZScsdGhpcykuZG9tKCkuaW5uZXJIVE1MO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyB9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY29kZSkge1xuXHRcdFx0XHRjb25maWcuaHRtbCA9IGNvZGU7XG5cdFx0XHRcdHRoaXMudmlldygpLmxvYWQobnVsbCx7aHRtbDogY29kZX0pO1xuXHRcdFx0XHR0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29kZSxvKXtcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0aWYgKGNvZGUgfHwgby5odG1sKSB7IHRoaXMudmlldygpLmxvYWQoY29kZSxvKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5jb2RlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoY29kZSxvLGJsayl7XG5cdFx0XHQvLyBjYWNoZSBsYXRlc3QgY29tcGlsYXRpb24gLSByZXR1cm4/XG5cdFx0XHRpZihibGs9PXVuZGVmaW5lZCAmJiB0eXBlb2YgbyA9PSAnZnVuY3Rpb24nKSBibGsgPSBvLG8gPSB0aGlzLmNvcHRzKCk7XG5cdFx0XHRpZihvPT11bmRlZmluZWQpIG8gPSB0aGlzLmNvcHRzKCk7XG5cdFx0XHRyZXR1cm4gU2NyaW1ibGEud29ya2VyKCkuY29tcGlsZShjb2RlLG8sYmxrKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub3ZlcmxheXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLnZpZXcoKS5oaW50cygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgaGludCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRoaW50ID0gYXJ5W2ldO1xuXHRcdFx0XHRpZiAoIWhpbnQuYWN0aXZlKCkpIHsgY29udGludWU7IH07XG5cdFx0XHRcdHJlcy5wdXNoKCh0aGlzWydfJyArICdoaW50JyArIGldID0gdGhpc1snXycgKyAnaGludCcgKyBpXSB8fCB0YWckLiRvdmVybGF5X2hpbnQoKSkuc2V0Vmlldyh0aGlzLnZpZXcoKSkuc2V0T2JqZWN0KGhpbnQpLmVuZCgpKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2dnbGVKUyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKHRoaXMudGFiKCkgIT0gJ2pzJykge1xuXHRcdFx0XHR0aGlzLnNob3dqcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRUYWIoJ2ltYmEnKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dGZvY3VzID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0VklFVyA9IHRoaXM7IC8vIGhhY2tcblx0XHRcdHRoaXMuZmxhZygnZm9jdXMnKTtcblx0XHRcdHJldHVybiAodGhpcy5zZXRBY3RpdmUodHJ1ZSksdHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5wdXRibHVyID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy51bmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHR2YXIgcmVsID0gZS5ldmVudCgpLnJlbGF0ZWRUYXJnZXQ7XG5cdFx0XHRpZiAoIShyZWwgJiYgdGhpcy5kb20oKS5jb250YWlucyhyZWwpKSkge1xuXHRcdFx0XHR0aGlzLnVuZmxhZygnZm9jdXMnKTtcblx0XHRcdFx0dGhpcy5zZXRBY3RpdmUoZmFsc2UpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1O1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGhpcy5faW5wdXQsXG5cdFx0XHRcdCh0MCA9IHRoaXMuX21haW49dGhpcy5fbWFpbiB8fCB0YWckLiRzZWN0aW9uKCkuc2V0UmVmKCdtYWluJyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0KHQxID0gdGhpcy5faGVhZGVyPXRoaXMuX2hlYWRlciB8fCB0YWckLiRoZWFkZXIoKS5zZXRSZWYoJ2hlYWRlcicsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0KHQyID0gdDEuJCRhPXQxLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCd0aXRsZScpLmZsYWcoJ3BhdGgnKSkuc2V0Q29udGVudCh0aGlzLmhlYWRpbmcoKSwzKS5lbmQoKSxcblx0XHRcdFx0XHRcdCh0MyA9IHQxLiQkYj10MS4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygndG9vbHMnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdCh0My4kJGEgPSB0My4kJGEgfHwgdGFnJC4kdG9vbCgpLmZsYWcoJ3Jlc2V0Jykuc2V0VGl0bGUoJ3Jlc2V0Jykuc2V0SGFuZGxlcigndGFwJywncmVzZXQnLHRoaXMpKS5zZXRUZXh0KCdyZXNldCcpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDMuJCRiID0gdDMuJCRiIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdqcycpLnNldFRpdGxlKCdzaG93IGpzJykuc2V0SGFuZGxlcigndGFwJywndG9nZ2xlSlMnLHRoaXMpKS5zZXRUZXh0KCdzaG93IGpzJykuZW5kKCksXG5cdFx0XHRcdFx0XHRcdCh0My4kJGMgPSB0My4kJGMgfHwgdGFnJC4kdG9vbCgpLmZsYWcoJ3J1bicpLnNldFRpdGxlKCdydW4nKS5zZXRIYW5kbGVyKCd0YXAnLCdydW4nLHRoaXMpKS5zZXRUZXh0KCdydW4nKS5lbmQoKVxuXHRcdFx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XHRcdF0sMikuZW5kKCksXG5cdFx0XHRcdFx0KHQ0ID0gdGhpcy5fb3ZlcmxheXM9dGhpcy5fb3ZlcmxheXMgfHwgdGFnJC4kb3ZlcmxheXMoKS5zZXRSZWYoJ292ZXJsYXlzJyx0aGlzKSkuc2V0Vmlldyh0aGlzLnZpZXcoKSkuc2V0Q29udGVudCh0aGlzLm92ZXJsYXlzKCksMykuZW5kKCksXG5cdFx0XHRcdFx0KHRoaXMuX2pzdmlldyA9IHRoaXMuX2pzdmlldyB8fCB0YWckLiRqc3ZpZXcoKS5zZXRSZWYoJ2pzdmlldycsdGhpcykpLmVuZCgpLFxuXHRcdFx0XHRcdHRoaXMuX3ZpZXcuZW5kKCksXG5cdFx0XHRcdFx0KHRoaXMuX2NvbnNvbGUgPSB0aGlzLl9jb25zb2xlIHx8IHRhZyQuJGNvbnNvbGUoKS5zZXRSZWYoJ2NvbnNvbGUnLHRoaXMpLmZsYWcoJ2RhcmsnKSkuc2V0RWRpdG9yKHRoaXMpLmVuZCgpXG5cdFx0XHRcdF0sMSkuZW5kKCksXG5cdFx0XHRcdCh0NSA9IHRoaXMuX2luc3BlY3Rvcj10aGlzLl9pbnNwZWN0b3IgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdpbnNwZWN0b3InLHRoaXMpKS5zZXRDb250ZW50KHRoaXMucGxheWdyb3VuZCgpLDMpLmVuZCgpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zYW5kYm94ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX3NhbmRib3ggPSB0aGlzLl9zYW5kYm94IHx8IHRhZyQuJHNhbmRib3goKS5zZXRSZWYoJ3NhbmRib3gnLHRoaXMpLmZsYWcoJ3BsYXlncm91bmQnKSkuc2V0RWRpdG9yKHRoaXMpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wbGF5Z3JvdW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zYW5kYm94KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKCFzZWxmLl9idWlsdCkgeyByZXR1cm4gfTtcblx0XHRcdFxuXHRcdFx0aWYgKERFUFNbc2VsZi5zcmMoKV0pIHtcblx0XHRcdFx0dmFyIHJlcyA9IERFUFNbc2VsZi5zcmMoKV07XG5cdFx0XHRcdHNlbGYudmlldygpLmxvYWQobnVsbCx7aHRtbDogcmVzLmh0bWwsZmlsZW5hbWU6IHNlbGYuc3JjKCl9KTtcblx0XHRcdFx0aWYgKHNlbGYuYXV0b3J1bigpKSB7XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYucnVuKCk7IH0sNTApO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gc2VsZjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGdldCBpbWJhIGRvY3VtZW50PyE/XG5cdFx0XHRBUFAuZmV0Y2hEb2N1bWVudChzZWxmLnNyYygpLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRzZWxmLnZpZXcoKS5sb2FkKHJlcy5ib2R5LHtmaWxlbmFtZTogc2VsZi5zcmMoKX0pO1xuXHRcdFx0XHRpZiAoc2VsZi5hdXRvcnVuKCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYucnVuKCk7IH0sNTApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25ydW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnJ1bigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hdXRvcnVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZWRpdGVkYXN5bmMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZmxhZygnZGlydHknKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnNhdmUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMudmlldygpLmhpbnRzKCkuY2xlYXIoKTtcblx0XHRcdHJldHVybiB0aGlzLnJ1bigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMuX2NvbnNvbGUucmVzZXQoKTtcblx0XHRcdGlmICh0aGlzLl9vcHRpb25zLmh0bWwpIHtcblx0XHRcdFx0dGhpcy52aWV3KCkubG9hZChudWxsLHtodG1sOiB0aGlzLl9vcHRpb25zLmh0bWx9KTtcblx0XHRcdH07XG5cdFx0XHRpZiAoZSkge1xuXHRcdFx0XHRlLmNhbmNlbCgpO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMudW5mbGFnKCdkaXJ0eScpO1xuXHRcdFx0dGhpcy52aWV3KCkuY2FyZXQoKS5ub3JtYWxpemUoKS5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0c2VsZi5mbGFnKCdydW5uaW5nJyk7XG5cdFx0XHRzZWxmLmNvbXBpbGUoc2VsZi5jb2RlKCksc2VsZi5jb3B0cygpLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRzZWxmLnZpZXcoKS5oaW50cygpLnJlbShmdW5jdGlvbihoaW50KSB7IHJldHVybiBoaW50Lmdyb3VwKCkgPT0gJ3J1bnRpbWUnOyB9KTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChyZXMuZGF0YSAmJiByZXMuZGF0YS5jb2RlKSB7XG5cdFx0XHRcdFx0Ly8gQGpzdmlldy5sb2FkKHJlczpkYXRhOmNvZGUpIGlmIHJlczpkYXRhXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHJldHVybiBzZWxmLl9zYW5kYm94LnJ1bihyZXMuZGF0YSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnNvbGUubG9nKCdlcnJvcicpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zaG93anMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBvID0ge2JhcmU6IHRydWUsc3RhbmRhbG9uZTogZmFsc2UsZmlsZW5hbWU6ICdhLmltYmEnfTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbGYuY29tcGlsZShzZWxmLmNvZGUoKSxvLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEuY29kZSkge1xuXHRcdFx0XHRcdHJldHVybiBzZWxmLl9qc3ZpZXcubG9hZChyZXMuZGF0YS5jb2RlLGZ1bmN0aW9uKCkgeyB2YXIgdl87XG5cdFx0XHRcdFx0cmV0dXJuIChzZWxmLnNldFRhYih2XyA9ICdqcycpLHZfKTsgfSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEuZXJyb3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29uc29sZS5sb2coJ2hhcyBlcnJvcicpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJ1bkVycm9yID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0by50eXBlID0gJ2Vycm9yJztcblx0XHRcdG8uZ3JvdXAgPSAncnVudGltZSc7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncnVuRXJyb3InLG9cblx0XHRcdC8vIG9ubHkgc2hvdyBlcnJvciBpZiB3ZSBoYXZlIGEgbGluZSBhbmQgY29sdW1uXG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuaGludHMoKS5hZGQobykuYWN0aXZhdGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucnVuTG9nID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0by50eXBlID0gJ2xvZyc7XG5cdFx0XHRvLmdyb3VwID0gJ3J1bnRpbWUnO1xuXHRcdFx0by5tZXNzYWdlIHx8IChvLm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShvLnBhcmFtc1swXSkpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3J1bkxvZycsb1xuXHRcdFx0XG5cdFx0XHRpZiAoby5uciAhPSBudWxsICYmICFvLmxvYykge1xuXHRcdFx0XHR2YXIgbG9ncyA9IHRoaXMudmlldygpLmZpbmQoJy5pZGVudGlmaWVyLmxvZywuaWRlbnRpZmllcltuYW1lPVwibG9nXCJdJykudG9BcnJheSgpO1xuXHRcdFx0XHR2YXIgbm9kZSA9IGxvZ3Nbby5ucl07XG5cdFx0XHRcdFxuXHRcdFx0XHRvLm5vZGUgPSBub2RlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0XHR2YXIgcmVnID0gbm9kZS5yZWdpb24oKTsgLy8gbm9kZS5uZXh0ID8gbm9kZS5uZXh0LnJlZ2lvbiA6IFxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdmb3VuZCBsb2MhIScsbm9kZSxyZWcpO1xuXHRcdFx0XHRcdC8vIGxldCBjb2wgPSB2aWV3LmJ1ZmZlci5saW5lKHJlZy5yb3cpWzpsZW5ndGhdXG5cdFx0XHRcdFx0by5sb2MgPSByZWcuZW5kQXRMaW5lKCkuY29sbGFwc2UoKTsgLy8ge2xpbmU6IHJlZy5yb3csIGNvbHVtbjogY29sfSAjICByZWcudG9KU09OICMge2xpbmU6IHJlZy5yb3csIGNvbHVtbjogMTAwfVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIG86bG9jID0gbG9nc1tvOm5yXS5yZWdpb24udG9KU09OXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLmhpbnRzKCkuYWRkKG8pLmFjdGl2YXRlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJ1blJlc3VsdCA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdydW5SZXN1bHQnLG9cblx0XHRcdHRoaXMuZmxhZygncmVwbCcsISFvKTtcblx0XHRcdHRoaXMuX2NvbnNvbGUubG9nKG8pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZXhhbXBsZScsICdzbmlwcGV0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF1dG9ydW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0aWYgKCFJbWJhLlNFUlZFUikge1xuXHRcdEltYmEuRXZlbnQuUFJPQ0VTU0lORztcblx0XHRcblx0XHRcblx0XHRcdFxuXHRcdFx0dmFyIHByZXYgPSBJbWJhLkV2ZW50LnByb3RvdHlwZS5wcm9jZXNzO1xuXHRcdFx0XG5cdFx0XHRJbWJhLkV2ZW50LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRcdEltYmEuRXZlbnQuUFJPQ0VTU0lORyA9IHRoaXM7XG5cdFx0XHRcdHJldHVybiBwcmV2LmNhbGwodGhpcyk7XG5cdFx0XHR9O1xuXHRcdFxuXHR9O1xuXHRcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnc2FuZGJveCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lZGl0b3IgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2VkaXRvcjsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RWRpdG9yID0gZnVuY3Rpb24odil7IHRoaXMuX2VkaXRvciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29uc29sZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZWRpdG9yKCkuX2NvbnNvbGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbiAobXNnLHVybCxsaW5lLGNvbCxlcnIpe1xuXHRcdFx0XG5cdFx0XHR2YXIgc3RhY2tfO1xuXHRcdFx0aWYgKHVybC5tYXRjaCgvc25pcHBldChcXGQrKVxcLihpbWJhfGpzKS8pKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgaWQgPSB1cmwuc3BsaXQoJy4nKS5zaGlmdCgpO1xuXHRcdFx0XHR2YXIgc25pcHBldCA9IHRhZyR3cmFwKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc25pcHBldCkge1xuXHRcdFx0XHRcdHNuaXBwZXQucGxheWdyb3VuZCgpLm9uZXJyb3IobXNnLCcnLGxpbmUsY29sLGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICh1cmwgPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0Ly8gc2FmYXJpP1xuXHRcdFx0XHR2YXIgZXYgPSBJbWJhLkV2ZW50LlBST0NFU1NJTkc7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdsYXN0IGV2ZW50IHRhcmdldCcsZXYgJiYgZXYudGFyZ2V0KCkpO1xuXHRcdFx0XHRpZiAoZXYgJiYgZXYudGFyZ2V0KCkpIHtcblx0XHRcdFx0XHRzbmlwcGV0ID0gZXYudGFyZ2V0KCkuY2xvc2VzdChxJCgnLl9zbmlwcGV0Jyx0aGlzKSk7XG5cdFx0XHRcdFx0aWYgKHNuaXBwZXQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzbmlwcGV0LnBsYXlncm91bmQoKS5vbmVycm9yKG1zZywnJyxsaW5lLGNvbCxlcnIpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zb2xlLmxvZygnY2F1Z2h0IHRoZSBlcnJvciBoZXJlISEhJyxhcmd1bWVudHMsdGhpcyk7XG5cdFx0XHR2YXIgbG9jcyA9IFtdO1xuXHRcdFx0XG5cdFx0XHRlcnIgJiYgKHN0YWNrXyA9IGVyci5zdGFjaykgJiYgc3RhY2tfLnJlcGxhY2UgICYmICBzdGFja18ucmVwbGFjZSgvKFxcPGFub255bW91c1xcPnxzbmlwcGV0XFxkK1xcLmltYmEpXFw6KFxcZCspOihcXGQrKS9nLGZ1bmN0aW9uKG0sc291cmNlLGxpbmUsY29sKSB7XG5cdFx0XHRcdGxvY3MucHVzaCh7bGluZTogcGFyc2VJbnQobGluZSksY29sdW1uOiBwYXJzZUludChjb2wpfSk7XG5cdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGxvY3MucHVzaCh7bGluZTogbGluZSxjb2x1bW46IGNvbH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAobG9jc1swXSkge1xuXHRcdFx0XHR2YXIgbWFwID0gdGhpcy5vYmplY3QoKS5zb3VyY2VtYXA7XG5cdFx0XHRcdHZhciBjb25zdW1lciA9IFNjcmltYmxhLlNvdXJjZU1hcC5Tb3VyY2VNYXBDb25zdW1lcihtYXApO1xuXHRcdFx0XHR2YXIgbG9jID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcihsb2NzWzBdKTtcblx0XHRcdFx0Y29uc29sZS5sb2coJ29yaWdpbmFsIGxvY2F0aW9uIGlzJyxsb2MpO1xuXHRcdFx0XHR0aGlzLmVkaXRvcigpLnJ1bkVycm9yKHttZXNzYWdlOiBtc2csbG9jOiBsb2N9KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmxvZyA9IGZ1bmN0aW9uIChucixwYXJzKXtcblx0XHRcdHRoaXMuZWRpdG9yKCkucnVuTG9nKHtucjogbnIscGFyYW1zOiBwYXJzfSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChxJCgnLnNjaGVkdWxlZF8nLHRoaXMpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFyeVtpXS51bnNjaGVkdWxlKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18uZW1wdHkuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wcmVzZW50ID0gZnVuY3Rpb24gKHJlcyl7XG5cdFx0XHR2YXIgbm9kZTtcblx0XHRcdGlmIChyZXMgJiYgKHJlcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBJbWJhLlRhZykpIHtcblx0XHRcdFx0bm9kZSA9IG5ldyByZXMocmVzLmNyZWF0ZU5vZGUoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKHJlcyBpbnN0YW5jZW9mIEltYmEuVGFnKSB7XG5cdFx0XHRcdG5vZGUgPSByZXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKG5vZGUpO1xuXHRcdFx0XHRub2RlLmVuZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuY29uc29sZSgpLmxvZyhub2RlIHx8IHJlcyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChzcmMpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIGNvZGUgPSBzcmMuY29kZTtcblx0XHRcdGlmICghY29kZSkgeyByZXR1cm4gc2VsZiB9O1xuXHRcdFx0XG5cdFx0XHRzZWxmLl9vYmplY3QgPSBzcmM7XG5cdFx0XHRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24obXNnLHVybCxsaW5lLGNvbCxlcnIpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnY2F1Z2h0IGVycm9yJyxtc2csdXJsLGxpbmUsY29sLGVycix0aGlzKTtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5vbmVycm9yKG1zZyx1cmwsbGluZSxjb2wsZXJyKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvZGUgPSBjb2RlICsgJ1xcbi8vIyBzb3VyY2VVUkw9JyArIHNlbGYuZWRpdG9yKCkuaWQoKSArICcuaW1iYSc7XG5cdFx0XHRcdHZhciB0YWckID0gSW1iYS5UQUdTLl9fY2xvbmUoKTtcblx0XHRcdFx0dmFyIGNvbnNvbGUgPSBzZWxmLmNvbnNvbGUoKTtcblx0XHRcdFx0dmFyIHJlcyA9IGV2YWwoY29kZSk7XG5cdFx0XHRcdHNlbGYucHJlc2VudChyZXMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRzZWxmLmxvZygnaW1tZWRpYXRlIGVycm9yIGluIGV2YWwtaW5saW5lJyxlKTtcblx0XHRcdFx0c2VsZi5vbmVycm9yKGUubWVzc2FnZSwnJyxlLmxpbmVOciB8fCBlLmxpbmUgfHwgMCxlLmNvbHVtbixlKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9zbmlwcGV0LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==