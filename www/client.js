/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		__webpack_require__(1);
		
		// need to use webpack for this include to work as intended
		Scrimbla = __webpack_require__(14);
		
		var App = __webpack_require__(57).App;
		APP = new App();
		APP.schedule();
		
		__webpack_require__(59);
		
		// awaken pages etc
		q$('._page').map(function(el) { return el; });
		return q$('.awaken').map(function(el) { return el; });
	
	})()

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		if (typeof Imba === 'undefined') {
			__webpack_require__(2);
			
			Imba.CLIENT = true;
			
			__webpack_require__(3);
			__webpack_require__(4);
			__webpack_require__(5);
			__webpack_require__(6);
			__webpack_require__(7);
			__webpack_require__(8);
			__webpack_require__(9);
			__webpack_require__(10);
			__webpack_require__(11);
			__webpack_require__(12);
			return __webpack_require__(13);
		} else {
			return console.warn("Imba is already loaded");
		};
	
	})()

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		// externs;
		
		if (true) {
			global = window;
		};
		
		/*
		Imba is the namespace for all runtime related utilities
		@namespace
		*/
		
		Imba = {
			VERSION: '0.14.1',
			DEBUG: false
		};
		
		var reg = /-./g;
		
		/*
		True if running in client environment.
		@return {bool}
		*/
		
		Imba.isClient = function (){
			return Imba.CLIENT === true;
		};
		
		/*
		True if running in server environment.
		@return {bool}
		*/
		
		Imba.isServer = function (){
			return (false) === true;
		};
		
		Imba.subclass = function (obj,sup){
			;
			for (var k in sup){
				if (sup.hasOwnProperty(k)) { obj[k] = sup[k] };
			};
			
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
			return obj;
		};
		
		/*
		Lightweight method for making an object iterable in imbas for/in loops.
		If the compiler cannot say for certain that a target in a for loop is an
		array, it will cache the iterable version before looping.
		
		```imba
		# this is the whole method
		def Imba.iterable o
			return o ? (o:toArray ? o.toArray : o) : []
		
		class CustomIterable
			def toArray
				[1,2,3]
		
		# will return [2,4,6]
		for x in CustomIterable.new
			x * 2
		
		```
		*/
		
		Imba.iterable = function (o){
			return o ? ((o.toArray ? (o.toArray()) : (o))) : ([]);
		};
		
		/*
		Coerces a value into a promise. If value is array it will
		call `Promise.all(value)`, or if it is not a promise it will
		wrap the value in `Promise.resolve(value)`. Used for experimental
		await syntax.
		@return {Promise}
		*/
		
		Imba.await = function (value){
			if (value instanceof Array) {
				return Promise.all(value);
			} else if (value && value.then) {
				return value;
			} else {
				return Promise.resolve(value);
			};
		};
		
		Imba.toCamelCase = function (str){
			return str.replace(reg,function(m) { return m.charAt(1).toUpperCase(); });
		};
		
		Imba.toCamelCase = function (str){
			return str.replace(reg,function(m) { return m.charAt(1).toUpperCase(); });
		};
		
		Imba.indexOf = function (a,b){
			return (b && b.indexOf) ? (b.indexOf(a)) : ([].indexOf.call(a,b));
		};
		
		Imba.prop = function (scope,name,opts){
			if (scope.defineProperty) {
				return scope.defineProperty(name,opts);
			};
			return;
		};
		
		return Imba.attr = function (scope,name,opts){
			if (scope.defineAttribute) {
				return scope.defineAttribute(name,opts);
			};
			
			var getName = Imba.toCamelCase(name);
			var setName = Imba.toCamelCase('set-' + name);
			
			scope.prototype[getName] = function() {
				return this.getAttribute(name);
			};
			
			scope.prototype[setName] = function(value) {
				this.setAttribute(name,value);
				return this;
			};
			
			return;
		};
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	(function(){
		
		
		function emit__(event,args,node){
			// var node = cbs[event]
			var prev,cb,ret;
			
			while ((prev = node) && (node = node.next)){
				if (cb = node.listener) {
					if (node.path && cb[node.path]) {
						ret = args ? (cb[node.path].apply(cb,args)) : (cb[node.path]());
					} else {
						// check if it is a method?
						ret = args ? (cb.apply(node,args)) : (cb.call(node));
					};
				};
				
				if (node.times && --node.times <= 0) {
					prev.next = node.next;
					node.listener = null;
				};
			};
			return;
		};
		
		// method for registering a listener on object
		Imba.listen = function (obj,event,listener,path){
			var $1;
			var cbs,list,tail;
			cbs = obj.__listeners__ || (obj.__listeners__ = {});
			list = cbs[($1 = event)] || (cbs[$1] = {});
			tail = list.tail || (list.tail = (list.next = {}));
			tail.listener = listener;
			tail.path = path;
			list.tail = tail.next = {};
			return tail;
		};
		
		Imba.once = function (obj,event,listener){
			var tail = Imba.listen(obj,event,listener);
			tail.times = 1;
			return tail;
		};
		
		Imba.unlisten = function (obj,event,cb,meth){
			var node,prev;
			var meta = obj.__listeners__;
			if (!meta) { return };
			
			if (node = meta[event]) {
				while ((prev = node) && (node = node.next)){
					if (node == cb || node.listener == cb) {
						prev.next = node.next;
						// check for correct path as well?
						node.listener = null;
						break;
					};
				};
			};
			return;
		};
		
		Imba.emit = function (obj,event,params){
			var cb;
			if (cb = obj.__listeners__) {
				if (cb[event]) { emit__(event,params,cb[event]) };
				if (cb.all) { emit__(event,[event,params],cb.all) }; // and event != 'all'
			};
			return;
		};
		
		return Imba.observeProperty = function (observer,key,trigger,target,prev){
			if (prev && typeof prev == 'object') {
				Imba.unlisten(prev,'all',observer,trigger);
			};
			if (target && typeof target == 'object') {
				Imba.listen(target,'all',observer,trigger);
			};
			return this;
		};
	
	})()

/***/ },
/* 4 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		
		var raf; // very simple raf polyfill
		raf || (raf = global.requestAnimationFrame);
		raf || (raf = global.webkitRequestAnimationFrame);
		raf || (raf = global.mozRequestAnimationFrame);
		raf || (raf = function(blk) { return setTimeout(blk,1000 / 60); });
		
		Imba.tick = function (d){
			if (this._scheduled) { raf(Imba.ticker()) };
			Imba.Scheduler.willRun();
			this.emit(this,'tick',[d]);
			Imba.Scheduler.didRun();
			return;
		};
		
		Imba.ticker = function (){
			var self = this;
			return self._ticker || (self._ticker = function(e) { return self.tick(e); });
		};
		
		/*
		
		Global alternative to requestAnimationFrame. Schedule a target
		to tick every frame. You can specify which method to call on the
		target (defaults to tick).
		
		*/
		
		Imba.schedule = function (target,method){
			if(method === undefined) method = 'tick';
			this.listen(this,'tick',target,method);
			// start scheduling now if this was the first one
			if (!this._scheduled) {
				this._scheduled = true;
				raf(Imba.ticker());
			};
			return this;
		};
		
		/*
		
		Unschedule a previously scheduled target
		
		*/
		
		Imba.unschedule = function (target,method){
			this.unlisten(this,'tick',target,method);
			var cbs = this.__listeners__ || (this.__listeners__ = {});
			if (!cbs.tick || !cbs.tick.next || !cbs.tick.next.listener) {
				this._scheduled = false;
			};
			return this;
		};
		
		/*
		
		Light wrapper around native setTimeout that expects the block / function
		as last argument (instead of first). It also triggers an event to Imba
		after the timeout to let schedulers update (to rerender etc) afterwards.
		
		*/
		
		Imba.setTimeout = function (delay,block){
			return setTimeout(function() {
				block();
				return Imba.Scheduler.markDirty();
				// Imba.emit(Imba,'timeout',[block])
			},delay);
		};
		
		/*
		
		Light wrapper around native setInterval that expects the block / function
		as last argument (instead of first). It also triggers an event to Imba
		after every interval to let schedulers update (to rerender etc) afterwards.
		
		*/
		
		Imba.setInterval = function (interval,block){
			return setInterval(function() {
				block();
				return Imba.Scheduler.markDirty();
				// Imba.emit(Imba,'interval',[block])
			},interval);
		};
		
		/*
		Clear interval with specified id
		*/
		
		Imba.clearInterval = function (interval){
			return clearInterval(interval);
		};
		
		/*
		Clear timeout with specified id
		*/
		
		Imba.clearTimeout = function (timeout){
			return clearTimeout(timeout);
		};
		
		// should add an Imba.run / setImmediate that
		// pushes listener onto the tick-queue with times - once
		
		
		/*
		
		Instances of Imba.Scheduler manages when to call `tick()` on their target,
		at a specified framerate or when certain events occur. Root-nodes in your
		applications will usually have a scheduler to make sure they rerender when
		something changes. It is also possible to make inner components use their
		own schedulers to control when they render.
		
		@iname scheduler
		
		*/
		
		Imba.Scheduler = function Scheduler(target){
			var self = this;
			self._target = target;
			self._marked = false;
			self._active = false;
			self._marker = function() { return self.mark(); };
			self._ticker = function(e) { return self.tick(e); };
			
			self._events = true;
			self._fps = 1;
			
			self._dt = 0;
			self._timestamp = 0;
			self._ticks = 0;
			self._flushes = 0;
		};
		
		Imba.Scheduler.markDirty = function (){
			this._dirty = true;
			return this;
		};
		
		Imba.Scheduler.isDirty = function (){
			return !!this._dirty;
		};
		
		Imba.Scheduler.willRun = function (){
			return this._active = true;
		};
		
		Imba.Scheduler.didRun = function (){
			this._active = false;
			return this._dirty = false;
		};
		
		Imba.Scheduler.isActive = function (){
			return !!this._active;
		};
		
		/*
			Create a new Imba.Scheduler for specified target
			@return {Imba.Scheduler}
			*/
		
		/*
			Check whether the current scheduler is active or not
			@return {bool}
			*/
		
		Imba.Scheduler.prototype.active = function (){
			return this._active;
		};
		
		/*
			Delta time between the two last ticks
			@return {Number}
			*/
		
		Imba.Scheduler.prototype.dt = function (){
			return this._dt;
		};
		
		/*
			Configure the scheduler
			@return {self}
			*/
		
		Imba.Scheduler.prototype.configure = function (pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var fps = pars.fps !== undefined ? pars.fps : 1;
			var events = pars.events !== undefined ? pars.events : true;
			if (events != null) { this._events = events };
			if (fps != null) { this._fps = fps };
			return this;
		};
		
		/*
			Mark the scheduler as dirty. This will make sure that
			the scheduler calls `target.tick` on the next frame
			@return {self}
			*/
		
		Imba.Scheduler.prototype.mark = function (){
			this._marked = true;
			return this;
		};
		
		/*
			Instantly trigger target.tick and mark scheduler as clean (not dirty/marked).
			This is called implicitly from tick, but can also be called manually if you
			really want to force a tick without waiting for the next frame.
			@return {self}
			*/
		
		Imba.Scheduler.prototype.flush = function (){
			this._marked = false;
			this._flushes++;
			this._target.tick();
			return this;
		};
		
		/*
			@fixme this expects raf to run at 60 fps 
		
			Called automatically on every frame while the scheduler is active.
			It will only call `target.tick` if the scheduler is marked dirty,
			or when according to @fps setting.
		
			If you have set up a scheduler with an fps of 1, tick will still be
			called every frame, but `target.tick` will only be called once every
			second, and it will *make sure* each `target.tick` happens in separate
			seconds according to Date. So if you have a node that renders a clock
			based on Date.now (or something similar), you can schedule it with 1fps,
			never needing to worry about two ticks happening within the same second.
			The same goes for 4fps, 10fps etc.
		
			@protected
			@return {self}
			*/
		
		Imba.Scheduler.prototype.tick = function (delta){
			this._ticks++;
			this._dt = delta;
			
			var fps = this._fps;
			
			if (fps == 60) {
				this._marked = true;
			} else if (fps == 30) {
				if (this._ticks % 2) { this._marked = true };
			} else if (fps) {
				// if it is less round - we trigger based
				// on date, for consistent rendering.
				// ie, if you want to render every second
				// it is important that no two renders
				// happen during the same second (according to Date)
				var period = ((60 / fps) / 60) * 1000;
				var beat = Math.floor(Date.now() / period);
				
				if (this._beat != beat) {
					this._beat = beat;
					this._marked = true;
				};
			};
			
			if (this._marked || (this._events && Imba.Scheduler.isDirty())) this.flush();
			// reschedule if @active
			return this;
		};
		
		/*
			Start the scheduler if it is not already active.
			**While active**, the scheduler will override `target.commit`
			to do nothing. By default Imba.tag#commit calls render, so
			that rendering is cascaded through to children when rendering
			a node. When a scheduler is active (for a node), Imba disables
			this automatic rendering.
			*/
		
		Imba.Scheduler.prototype.activate = function (){
			if (!this._active) {
				this._active = true;
				// override target#commit while this is active
				this._commit = this._target.commit;
				this._target.commit = function() { return this; };
				Imba.schedule(this);
				if (this._events) { Imba.listen(Imba,'event',this,'onevent') };
				this._target && this._target.flag  &&  this._target.flag('scheduled_');
				this.tick(0); // start ticking
			};
			return this;
		};
		
		/*
			Stop the scheduler if it is active.
			*/
		
		Imba.Scheduler.prototype.deactivate = function (){
			if (this._active) {
				this._active = false;
				this._target.commit = this._commit;
				Imba.unschedule(this);
				Imba.unlisten(Imba,'event',this);
				this._target && this._target.unflag  &&  this._target.unflag('scheduled_');
			};
			return this;
		};
		
		Imba.Scheduler.prototype.track = function (){
			return this._marker;
		};
		
		Imba.Scheduler.prototype.onevent = function (event){
			var $1;
			if (this._marked) { return this };
			
			if (this._events instanceof Function) {
				if (this._events(event)) this.mark();
			} else if (this._events instanceof Array) {
				if (idx$(($1 = event) && $1.type  &&  $1.type(),this._events) >= 0) this.mark();
			} else if (this._events) {
				if (event._responder) this.mark();
			};
			return this;
		};
		return Imba.Scheduler;
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		Imba.static = function (items,nr){
			items.static = nr;
			return items;
		};
		
		/*
		This is the baseclass that all tags in imba inherit from.
		@iname node
		*/
		
		Imba.Tag = function Tag(dom){
			this.setDom(dom);
		};
		
		Imba.Tag.createNode = function (){
			throw "Not implemented";
		};
		
		Imba.Tag.build = function (){
			return new this(this.createNode());
		};
		
		
		
		Imba.Tag.prototype.object = function(v){ return this._object; }
		Imba.Tag.prototype.setObject = function(v){ this._object = v; return this; };
		
		Imba.Tag.prototype.dom = function (){
			return this._dom;
		};
		
		Imba.Tag.prototype.setDom = function (dom){
			dom._tag = this;
			this._dom = dom;
			return this;
		};
		
		/*
			Setting references for tags like
			`<div@header>` will compile to `tag('div').setRef('header',this).end()`
			By default it adds the reference as a className to the tag.
			@return {self}
			*/
		
		Imba.Tag.prototype.setRef = function (ref,ctx){
			this.flag(this._ref = ref);
			return this;
		};
		
		/*
			Method that is called by the compiled tag-chains, for
			binding events on tags to methods etc.
			`<a :tap=fn>` compiles to `tag('a').setHandler('tap',fn,this).end()`
			where this refers to the context in which the tag is created.
			@return {self}
			*/
		
		Imba.Tag.prototype.setHandler = function (event,handler,ctx){
			var key = 'on' + event;
			
			if (handler instanceof Function) {
				this[key] = handler;
			} else if (handler instanceof Array) {
				var fn = handler.shift();
				this[key] = function(e) { return ctx[fn].apply(ctx,handler.concat(e)); };
			} else {
				this[key] = function(e) { return ctx[handler](e); };
			};
			return this;
		};
		
		Imba.Tag.prototype.setId = function (id){
			this.dom().id = id;
			return this;
		};
		
		Imba.Tag.prototype.id = function (){
			return this.dom().id;
		};
		
		/*
			Adds a new attribute or changes the value of an existing attribute
			on the specified tag. If the value is null or false, the attribute
			will be removed.
			@return {self}
			*/
		
		Imba.Tag.prototype.setAttribute = function (name,value){
			// should this not return self?
			var old = this.dom().getAttribute(name);
			
			if (old == value) {
				return value;
			} else if (value != null && value !== false) {
				return this.dom().setAttribute(name,value);
			} else {
				return this.dom().removeAttribute(name);
			};
		};
		
		/*
			removes an attribute from the specified tag
			*/
		
		Imba.Tag.prototype.removeAttribute = function (name){
			return this.dom().removeAttribute(name);
		};
		
		/*
			returns the value of an attribute on the tag.
			If the given attribute does not exist, the value returned
			will either be null or "" (the empty string)
			*/
		
		Imba.Tag.prototype.getAttribute = function (name){
			return this.dom().getAttribute(name);
		};
		
		/*
			Override this to provide special wrapping etc.
			@return {self}
			*/
		
		Imba.Tag.prototype.setContent = function (content,type){
			this.setChildren(content,type);
			return this;
		};
		
		/*
			Set the children of node. type param is optional,
			and should only be used by Imba when compiling tag trees. 
			@return {self}
			*/
		
		Imba.Tag.prototype.setChildren = function (nodes,type){
			throw "Not implemented";
		};
		
		/*
			Get text of node. Uses textContent behind the scenes (not innerText)
			[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()
			@return {string} inner text of node
			*/
		
		Imba.Tag.prototype.text = function (v){
			return this._dom.textContent;
		};
		
		/*
			Set text of node. Uses textContent behind the scenes (not innerText)
			[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()
			*/
		
		Imba.Tag.prototype.setText = function (txt){
			this._empty = false;
			this._dom.textContent = txt == null ? (txt = "") : (txt);
			return this;
		};
		
		
		/*
			Method for getting and setting data-attributes. When called with zero
			arguments it will return the actual dataset for the tag.
		
				var node = <div data-name='hello'>
				# get the whole dataset
				node.dataset # {name: 'hello'}
				# get a single value
				node.dataset('name') # 'hello'
				# set a single value
				node.dataset('name','newname') # self
		
		
			*/
		
		Imba.Tag.prototype.dataset = function (key,val){
			throw "Not implemented";
		};
		
		/*
			Empty placeholder. Override to implement custom render behaviour.
			Works much like the familiar render-method in React.
			@return {self}
			*/
		
		Imba.Tag.prototype.render = function (){
			return this;
		};
		
		/*
			Called implicitly through Imba.Tag#end, upon creating a tag. All
			properties will have been set before build is called, including
			setContent.
			@return {self}
			*/
		
		Imba.Tag.prototype.build = function (){
			this.render();
			return this;
		};
		
		/*
			Called implicitly through Imba.Tag#end, for tags that are part of
			a tag tree (that are rendered several times).
			@return {self}
			*/
		
		Imba.Tag.prototype.commit = function (){
			this.render();
			return this;
		};
		
		/*
		
			Called by the tag-scheduler (if this tag is scheduled)
			By default it will call this.render. Do not override unless
			you really understand it.
		
			*/
		
		Imba.Tag.prototype.tick = function (){
			this.render();
			return this;
		};
		
		/*
			
			A very important method that you will practically never manually.
			The tag syntax of Imba compiles to a chain of setters, which always
			ends with .end. `<a.large>` compiles to `tag('a').flag('large').end()`
			
			You are highly adviced to not override its behaviour. The first time
			end is called it will mark the tag as built and call Imba.Tag#build,
			and call Imba.Tag#commit on subsequent calls.
			@return {self}
			*/
		
		Imba.Tag.prototype.end = function (){
			if (this._built) {
				this.commit();
			} else {
				this._built = true;
				this.build();
			};
			return this;
		};
		
		/*
			This is called instead of Imba.Tag#end for `<self>` tag chains.
			Defaults to noop
			@return {self}
			*/
		
		Imba.Tag.prototype.synced = function (){
			return this;
		};
		
		// called when the node is awakened in the dom - either automatically
		// upon attachment to the dom-tree, or the first time imba needs the
		// tag for a domnode that has been rendered on the server
		Imba.Tag.prototype.awaken = function (){
			return this;
		};
		
		/*
			List of flags for this node. 
			*/
		
		Imba.Tag.prototype.flags = function (){
			return this._dom.classList;
		};
		
		/*
			Add speficied flag to current node.
			If a second argument is supplied, it will be coerced into a Boolean,
			and used to indicate whether we should remove the flag instead.
			@return {self}
			*/
		
		Imba.Tag.prototype.flag = function (name,toggler){
			// it is most natural to treat a second undefined argument as a no-switch
			// so we need to check the arguments-length
			if (arguments.length == 2 && !toggler) {
				this._dom.classList.remove(name);
			} else {
				this._dom.classList.add(name);
			};
			return this;
		};
		
		/*
			Remove specified flag from node
			@return {self}
			*/
		
		Imba.Tag.prototype.unflag = function (name){
			this._dom.classList.remove(name);
			return this;
		};
		
		/*
			Toggle specified flag on node
			@return {self}
			*/
		
		Imba.Tag.prototype.toggleFlag = function (name){
			this._dom.classList.toggle(name);
			return this;
		};
		
		/*
			Check whether current node has specified flag
			@return {bool}
			*/
		
		Imba.Tag.prototype.hasFlag = function (name){
			return this._dom.classList.contains(name);
		};
		
		/*
			Get the scheduler for this node. A new scheduler will be created
			if it does not already exist.
		
			@return {Imba.Scheduler}
			*/
		
		Imba.Tag.prototype.scheduler = function (){
			return this._scheduler == null ? (this._scheduler = new Imba.Scheduler(this)) : (this._scheduler);
		};
		
		/*
		
			Shorthand to start scheduling a node. The method will basically
			proxy the arguments through to scheduler.configure, and then
			activate the scheduler.
			
			@return {self}
			*/
		
		Imba.Tag.prototype.schedule = function (options){
			if(options === undefined) options = {};
			this.scheduler().configure(options).activate();
			return this;
		};
		
		/*
			Shorthand for deactivating scheduler (if tag has one).
			@deprecated
			*/
		
		Imba.Tag.prototype.unschedule = function (){
			if (this._scheduler) { this.scheduler().deactivate() };
			return this;
		};
		
		
		/*
			Get the parent of current node
			@return {Imba.Tag} 
			*/
		
		Imba.Tag.prototype.parent = function (){
			return tag$wrap(this.dom().parentNode);
		};
		
		/*
			Shorthand for console.log on elements
			@return {self}
			*/
		
		Imba.Tag.prototype.log = function (){
			var $0 = arguments, i = $0.length;
			var args = new Array(i>0 ? i : 0);
			while(i>0) args[i-1] = $0[--i];
			args.unshift(console);
			Function.prototype.call.apply(console.log,args);
			return this;
		};
		
		
		Imba.Tag.prototype.initialize = Imba.Tag;
		
		HTML_TAGS = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");
		HTML_TAGS_UNSAFE = "article aside header section".split(" ");
		SVG_TAGS = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
		
		
		function extender(obj,sup){
			for (var i = 0, keys = Object.keys(sup), l = keys.length; i < l; i++){
				obj[($1 = keys[i])] == null ? (obj[$1] = sup[keys[i]]) : (obj[$1]);
			};
			
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
			if (sup.inherit) { sup.inherit(obj) };
			return obj;
		};
		
		function Tag(){
			return function(dom) {
				this.setDom(dom);
				return this;
			};
		};
		
		function TagSpawner(type){
			return function() { return type.build(); };
		};
		
		Imba.Tags = function Tags(){
			this;
		};
		
		Imba.Tags.prototype.__clone = function (ns){
			var clone = Object.create(this);
			clone._parent = this;
			return clone;
		};
		
		Imba.Tags.prototype.defineNamespace = function (name){
			var clone = Object.create(this);
			clone._parent = this;
			clone._ns = name;
			this[name.toUpperCase()] = clone;
			return clone;
		};
		
		Imba.Tags.prototype.baseType = function (name){
			return idx$(name,HTML_TAGS) >= 0 ? ('htmlelement') : ('div');
		};
		
		Imba.Tags.prototype.defineTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			supr || (supr = this.baseType(name));
			var supertype = this[supr];
			var tagtype = Tag();
			var norm = name.replace(/\-/g,'_');
			
			
			tagtype._name = name;
			extender(tagtype,supertype);
			
			if (name[0] == '#') {
				this[name] = tagtype;
				Imba.SINGLETONS[name.slice(1)] = tagtype;
			} else {
				this[name] = tagtype;
				this['$' + norm] = TagSpawner(tagtype);
			};
			
			if (body) {
				if (body.length == 2) {
					// create clone
					if (!tagtype.hasOwnProperty('TAGS')) {
						tagtype.TAGS = (supertype.TAGS || this).__clone();
					};
				};
				
				body.call(tagtype,tagtype,tagtype.TAGS || this);
			};
			
			return tagtype;
		};
		
		Imba.Tags.prototype.defineSingleton = function (name,supr,body){
			return this.defineTag(name,supr,body);
		};
		
		Imba.Tags.prototype.extendTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			var klass = ((typeof name=='string'||name instanceof String) ? (this[name]) : (name));
			// allow for private tags here as well?
			if (body) { body && body.call(klass,klass,klass.prototype) };
			return klass;
		};
		
		
		Imba.TAGS = new Imba.Tags();
		Imba.TAGS.element = Imba.Tag;
		
		var svg = Imba.TAGS.defineNamespace('svg');
		
		svg.baseType = function (name){
			return 'svgelement';
		};
		
		
		Imba.SINGLETONS = {};
		
		
		Imba.defineTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			return Imba.TAGS.defineTag(name,supr,body);
		};
		
		Imba.defineSingletonTag = function (id,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = 'div';
			if(supr==undefined) supr = 'div';
			return Imba.TAGS.defineTag(this.name(),supr,body);
		};
		
		Imba.extendTag = function (name,body){
			return Imba.TAGS.extendTag(name,body);
		};
		
		Imba.tag = function (name){
			var typ = Imba.TAGS[name];
			if (!typ) { throw new Error(("tag " + name + " is not defined")) };
			return new typ(typ.createNode());
		};
		
		Imba.tagWithId = function (name,id){
			var typ = Imba.TAGS[name];
			if (!typ) { throw new Error(("tag " + name + " is not defined")) };
			var dom = typ.createNode();
			dom.id = id;
			return new typ(dom);
		};
		
		// TODO: Can we move these out and into dom.imba in a clean way?
		// These methods depends on Imba.document.getElementById
		
		Imba.getTagSingleton = function (id){
			var klass;
			var dom,node;
			
			if (klass = Imba.SINGLETONS[id]) {
				if (klass && klass.Instance) { return klass.Instance };
				
				// no instance - check for element
				if (dom = Imba.document().getElementById(id)) {
					// we have a live instance - when finding it through a selector we should awake it, no?
					// console.log('creating the singleton from existing node in dom?',id,type)
					node = klass.Instance = new klass(dom);
					node.awaken(dom); // should only awaken
					return node;
				};
				
				dom = klass.createNode();
				dom.id = id;
				node = klass.Instance = new klass(dom);
				node.end().awaken(dom);
				return node;
			} else if (dom = Imba.document().getElementById(id)) {
				return Imba.getTagForDom(dom);
			};
		};
		
		var svgSupport = typeof SVGElement !== 'undefined';
		
		Imba.getTagForDom = function (dom){
			var m;
			if (!dom) { return null };
			if (dom._dom) { return dom }; // could use inheritance instead
			if (dom._tag) { return dom._tag };
			if (!dom.nodeName) { return null };
			
			var ns = null;
			var id = dom.id;
			var type = dom.nodeName.toLowerCase();
			var tags = Imba.TAGS;
			var native$ = type;
			var cls = dom.className;
			
			if (id && Imba.SINGLETONS[id]) {
				// FIXME control that it is the same singleton?
				// might collide -- not good?
				return Imba.getTagSingleton(id);
			};
			// look for id - singleton
			
			// need better test here
			if (svgSupport && (dom instanceof SVGElement)) {
				ns = "svg";
				cls = dom.className.baseVal;
				tags = tags.SVG;
			};
			
			var spawner;
			
			if (cls) {
				// there can be several matches here - should choose the last
				// should fall back to less specific later? - otherwise things may fail
				// TODO rework this
				if (m = cls.match(/\b_([a-z\-]+)\b(?!\s*_[a-z\-]+)/)) {
					type = m[1]; // .replace(/-/g,'_')
				};
				
				if (m = cls.match(/\b([A-Z\-]+)_\b/)) {
					ns = m[1];
				};
			};
			
			
			spawner = tags[type] || tags[native$];
			return spawner ? (new spawner(dom).awaken(dom)) : (null);
		};
		
		tag$ = Imba.TAGS;
		t$ = Imba.tag;
		tc$ = Imba.tagWithFlags;
		ti$ = Imba.tagWithId;
		tic$ = Imba.tagWithIdAndFlags;
		id$ = Imba.getTagSingleton;
		return tag$wrap = Imba.getTagForDom;
		
	
	})()

/***/ },
/* 6 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		Imba.document = function (){
			return window.document;
		};
		
		/*
		Returns the body element wrapped in an Imba.Tag
		*/
		
		Imba.root = function (){
			return tag$wrap(Imba.document().body);
		};
		
		tag$.defineTag('htmlelement', 'element', function(tag){
			
			/*
				Called when a tag type is being subclassed.
				*/
			
			tag.inherit = function (child){
				child.prototype._empty = true;
				child._protoDom = null;
				
				if (this._nodeType) {
					child._nodeType = this._nodeType;
					
					var className = "_" + child._name.replace(/_/g,'-');
					if (child._name[0] != '#') { return child._classes = this._classes.concat(className) };
				} else {
					child._nodeType = child._name;
					return child._classes = [];
				};
			};
			
			tag.buildNode = function (){
				var dom = Imba.document().createElement(this._nodeType);
				var cls = this._classes.join(" ");
				if (cls) { dom.className = cls };
				return dom;
			};
			
			tag.createNode = function (){
				var proto = (this._protoDom || (this._protoDom = this.buildNode()));
				return proto.cloneNode(false);
			};
			
			tag.dom = function (){
				return this._protoDom || (this._protoDom = this.buildNode());
			};
			
			
			
			tag.prototype.id = function(v){ return this.getAttribute('id'); }
			tag.prototype.setId = function(v){ this.setAttribute('id',v); return this; };
			
			
			tag.prototype.tabindex = function(v){ return this.getAttribute('tabindex'); }
			tag.prototype.setTabindex = function(v){ this.setAttribute('tabindex',v); return this; };
			
			
			tag.prototype.title = function(v){ return this.getAttribute('title'); }
			tag.prototype.setTitle = function(v){ this.setAttribute('title',v); return this; };
			
			
			tag.prototype.role = function(v){ return this.getAttribute('role'); }
			tag.prototype.setRole = function(v){ this.setAttribute('role',v); return this; };
			
			tag.prototype.width = function (){
				return this._dom.offsetWidth;
			};
			
			tag.prototype.height = function (){
				return this._dom.offsetHeight;
			};
			
			tag.prototype.setChildren = function (nodes,type){
				this._empty ? (this.append(nodes)) : (this.empty().append(nodes));
				this._children = null;
				return this;
			};
			
			/*
				Set inner html of node
				*/
			
			tag.prototype.setHtml = function (html){
				this._dom.innerHTML = html;
				return this;
			};
			
			/*
				Get inner html of node
				*/
			
			tag.prototype.html = function (){
				return this._dom.innerHTML;
			};
			
			/*
				Remove all content inside node
				*/
			
			tag.prototype.empty = function (){
				while (this._dom.firstChild){
					this._dom.removeChild(this._dom.firstChild);
				};
				this._children = null;
				this._empty = true;
				return this;
			};
			
			/*
				Remove specified child from current node.
				*/
			
			tag.prototype.remove = function (child){
				var par = this.dom();
				var el = child && child.dom();
				if (el && el.parentNode == par) { par.removeChild(el) };
				return this;
			};
			
			tag.prototype.emit = function (name,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var data = pars.data !== undefined ? pars.data : null;
				var bubble = pars.bubble !== undefined ? pars.bubble : true;
				Imba.Events.trigger(name,this,{data: data,bubble: bubble});
				return this;
			};
			
			tag.prototype.css = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.css(keys[i],key[keys[i]]);
					};
				} else if (val == null) {
					this.dom().style.removeProperty(key);
				} else if (val == undefined) {
					return this.dom().style[key];
				} else {
					if ((typeof val=='number'||val instanceof Number) && key.match(/width|height|left|right|top|bottom/)) {
						val = val + "px";
					};
					this.dom().style[key] = val;
				};
				return this;
			};
			
			tag.prototype.dataset = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.dataset(keys[i],key[keys[i]]);
					};
					return this;
				};
				
				if (arguments.length == 2) {
					this.setAttribute(("data-" + key),val);
					return this;
				};
				
				if (key) {
					return this.getAttribute(("data-" + key));
				};
				
				var dataset = this.dom().dataset;
				
				if (!dataset) {
					dataset = {};
					for (var i = 0, ary = iter$(this.dom().attributes), len = ary.length, atr; i < len; i++) {
						atr = ary[i];
						if (atr.name.substr(0,5) == 'data-') {
							dataset[Imba.toCamelCase(atr.name.slice(5))] = atr.value;
						};
					};
				};
				
				return dataset;
			};
			
			/*
				Get descendants of current node, optionally matching selector
				@return {Imba.Selector}
				*/
			
			tag.prototype.find = function (sel){
				return new Imba.Selector(sel,this);
			};
			
			/*
				Get the first matching child of node
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.first = function (sel){
				return sel ? (this.find(sel).first()) : (tag$wrap(this.dom().firstElementChild));
			};
			
			/*
				Get the last matching child of node
			
					node.last # returns the last child of node
					node.last %span # returns the last span inside node
					node.last do |el| el.text == 'Hi' # return last node with text Hi
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.last = function (sel){
				return sel ? (this.find(sel).last()) : (tag$wrap(this.dom().lastElementChild));
			};
			
			/*
				Get the child at index
				*/
			
			tag.prototype.child = function (i){
				return tag$wrap(this.dom().children[i || 0]);
			};
			
			tag.prototype.children = function (sel){
				var nodes = new Imba.Selector(null,this,this._dom.children);
				return sel ? (nodes.filter(sel)) : (nodes);
			};
			
			tag.prototype.orphanize = function (){
				var par;
				if (par = this.dom().parentNode) { par.removeChild(this._dom) };
				return this;
			};
			
			tag.prototype.matches = function (sel){
				var fn;
				if (sel instanceof Function) {
					return sel(this);
				};
				
				if (sel.query) { sel = sel.query() };
				if (fn = (this._dom.webkitMatchesSelector || this._dom.matches)) { return fn.call(this._dom,sel) };
				// TODO support other browsers etc?
			};
			
			/*
				Get the first element matching supplied selector / filter
				traversing upwards, but including the node itself.
				@return {Imba.Tag}
				*/
			
			tag.prototype.closest = function (sel){
				if (!sel) { return this.parent() }; // should return self?!
				var node = this;
				if (sel.query) { sel = sel.query() };
				
				while (node){
					if (node.matches(sel)) { return node };
					node = node.parent();
				};
				return null;
			};
			
			/*
				Get the closest ancestor of node that matches
				specified selector / matcher.
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.up = function (sel){
				if (!sel) { return this.parent() };
				return this.parent() && this.parent().closest(sel);
			};
			
			tag.prototype.path = function (sel){
				var node = this;
				var nodes = [];
				if (sel && sel.query) { sel = sel.query() };
				
				while (node){
					if (!sel || node.matches(sel)) { nodes.push(node) };
					node = node.parent();
				};
				return nodes;
			};
			
			tag.prototype.parents = function (sel){
				var par = this.parent();
				return par ? (par.path(sel)) : ([]);
			};
			
			
			
			tag.prototype.siblings = function (sel){
				var par, self = this;
				if (!(par = this.parent())) { return [] }; // FIXME
				var ary = this.dom().parentNode.children;
				var nodes = new Imba.Selector(null,this,ary);
				return nodes.filter(function(n) { return n != self && (!sel || n.matches(sel)); });
			};
			
			/*
				Get the immediately following sibling of node.
				*/
			
			tag.prototype.next = function (sel){
				if (sel) {
					var el = this;
					while (el = el.next()){
						if (el.matches(sel)) { return el };
					};
					return null;
				};
				return tag$wrap(this.dom().nextElementSibling);
			};
			
			/*
				Get the immediately preceeding sibling of node.
				*/
			
			tag.prototype.prev = function (sel){
				if (sel) {
					var el = this;
					while (el = el.prev()){
						if (el.matches(sel)) { return el };
					};
					return null;
				};
				return tag$wrap(this.dom().previousElementSibling);
			};
			
			tag.prototype.contains = function (node){
				return this.dom().contains(node && node._dom || node);
			};
			
			tag.prototype.index = function (){
				var i = 0;
				var el = this.dom();
				while (el.previousSibling){
					el = el.previousSibling;
					i++;
				};
				return i;
			};
			
			
			/*
				
				@deprecated
				*/
			
			tag.prototype.insert = function (node,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var before = pars.before !== undefined ? pars.before : null;
				var after = pars.after !== undefined ? pars.after : null;
				if (after) { before = after.next() };
				if (node instanceof Array) {
					node = (tag$.$fragment().setContent(node,0).end());
				};
				if (before) {
					this.dom().insertBefore(node.dom(),before.dom());
				} else {
					this.append(node);
				};
				return this;
			};
			
			/*
				Focus on current node
				@return {self}
				*/
			
			tag.prototype.focus = function (){
				this.dom().focus();
				return this;
			};
			
			/*
				Remove focus from current node
				@return {self}
				*/
			
			tag.prototype.blur = function (){
				this.dom().blur();
				return this;
			};
			
			tag.prototype.template = function (){
				return null;
			};
			
			/*
				@todo Should support multiple arguments like append
			
				The .prepend method inserts the specified content as the first
				child of the target node. If the content is already a child of 
				node it will be moved to the start.
				
			    	node.prepend <div.top> # prepend node
			    	node.prepend "some text" # prepend text
			    	node.prepend [<ul>,<ul>] # prepend array
			
				*/
			
			tag.prototype.prepend = function (item){
				var first = this._dom.childNodes[0];
				first ? (this.insertBefore(item,first)) : (this.appendChild(item));
				return this;
			};
			
			/*
				The .append method inserts the specified content as the last child
				of the target node. If the content is already a child of node it
				will be moved to the end.
				
				# example
				    var root = <div.root>
				    var item = <div.item> "This is an item"
				    root.append item # appends item to the end of root
			
				    root.prepend "some text" # append text
				    root.prepend [<ul>,<ul>] # append array
				*/
			
			tag.prototype.append = function (item){
				// possible to append blank
				// possible to simplify on server?
				if (!item) { return this };
				
				if (item instanceof Array) {
					for (var i = 0, ary = iter$(item), len = ary.length, member; i < len; i++) {
						member = ary[i];
						member && this.append(member);
					};
				} else if ((typeof item=='string'||item instanceof String) || (typeof item=='number'||item instanceof Number)) {
					var node = Imba.document().createTextNode(item);
					this._dom.appendChild(node);
					if (this._empty) { this._empty = false };
				} else {
					this._dom.appendChild(item._dom || item);
					if (this._empty) { this._empty = false };
				};
				
				return this;
			};
			
			/*
				Insert a node into the current node (self), before another.
				The relative node must be a child of current node. 
				*/
			
			tag.prototype.insertBefore = function (node,rel){
				if ((typeof node=='string'||node instanceof String)) { node = Imba.document().createTextNode(node) };
				if (node && rel) { this.dom().insertBefore((node._dom || node),(rel._dom || rel)) };
				return this;
			};
			
			/*
				Append a single item (node or string) to the current node.
				If supplied item is a string it will automatically. This is used
				by Imba internally, but will practically never be used explicitly.
				*/
			
			tag.prototype.appendChild = function (node){
				if ((typeof node=='string'||node instanceof String)) { node = Imba.document().createTextNode(node) };
				if (node) { this.dom().appendChild(node._dom || node) };
				return this;
			};
			
			/*
				Remove a single child from the current node.
				Used by Imba internally.
				*/
			
			tag.prototype.removeChild = function (node){
				if (node) { this.dom().removeChild(node._dom || node) };
				return this;
			};
			
			tag.prototype.toString = function (){
				return this._dom.toString(); // really?
			};
			
			/*
				@deprecated
				*/
			
			tag.prototype.classes = function (){
				console.log('Imba.Tag#classes is deprecated');
				return this._dom.classList;
			};
		});
		
		return tag$.defineTag('svgelement', 'htmlelement');
	
	})()

/***/ },
/* 7 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// Extending Imba.Tag#css to work without prefixes by inspecting
		// the properties of a CSSStyleDeclaration and creating a map
		
		// var prefixes = ['-webkit-','-ms-','-moz-','-o-','-blink-']
		// var props = ['transform','transition','animation']
		
		var styles = window.getComputedStyle(document.documentElement,'');
		
		Imba.CSSKeyMap = {};
		
		for (var i = 0, ary = iter$(styles), len = ary.length, prefixed; i < len; i++) {
			prefixed = ary[i];
			var unprefixed = prefixed.replace(/^-(webkit|ms|moz|o|blink)-/,'');
			var camelCase = unprefixed.replace(/-(\w)/g,function(m,a) { return a.toUpperCase(); });
			
			// if there exists an unprefixed version -- always use this
			if (prefixed != unprefixed) {
				if (styles.hasOwnProperty(unprefixed)) { continue; };
			};
			
			// register the prefixes
			Imba.CSSKeyMap[unprefixed] = Imba.CSSKeyMap[camelCase] = prefixed;
		};
		
		return tag$.extendTag('htmlelement', function(tag){
			
			// override the original css method
			tag.prototype.css = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.css(keys[i],key[keys[i]]);
					};
					return this;
				};
				
				key = Imba.CSSKeyMap[key] || key;
				
				if (val == null) {
					this.dom().style.removeProperty(key);
				} else if (val == undefined) {
					return this.dom().style[key];
				} else {
					if ((typeof val=='number'||val instanceof Number) && key.match(/width|height|left|right|top|bottom/)) {
						val = val + "px";
					};
					this.dom().style[key] = val;
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 8 */
/***/ function(module, exports) {

	(function(){
		
		// predefine all supported html tags
		tag$.defineTag('fragment', 'htmlelement', function(tag){
			
			tag.createNode = function (){
				return Imba.document().createDocumentFragment();
			};
		});
		
		tag$.defineTag('a', function(tag){
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
		});
		
		tag$.defineTag('abbr');
		tag$.defineTag('address');
		tag$.defineTag('area');
		tag$.defineTag('article');
		tag$.defineTag('aside');
		tag$.defineTag('audio');
		tag$.defineTag('b');
		tag$.defineTag('base');
		tag$.defineTag('bdi');
		tag$.defineTag('bdo');
		tag$.defineTag('big');
		tag$.defineTag('blockquote');
		tag$.defineTag('body');
		tag$.defineTag('br');
		
		tag$.defineTag('button', function(tag){
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
		});
		
		tag$.defineTag('canvas', function(tag){
			tag.prototype.setWidth = function (val){
				if (this.width() != val) { this.dom().width = val };
				return this;
			};
			
			tag.prototype.setHeight = function (val){
				if (this.height() != val) { this.dom().height = val };
				return this;
			};
			
			tag.prototype.width = function (){
				return this.dom().width;
			};
			
			tag.prototype.height = function (){
				return this.dom().height;
			};
			
			tag.prototype.context = function (type){
				if(type === undefined) type = '2d';
				return this.dom().getContext(type);
			};
		});
		
		tag$.defineTag('caption');
		tag$.defineTag('cite');
		tag$.defineTag('code');
		tag$.defineTag('col');
		tag$.defineTag('colgroup');
		tag$.defineTag('data');
		tag$.defineTag('datalist');
		tag$.defineTag('dd');
		tag$.defineTag('del');
		tag$.defineTag('details');
		tag$.defineTag('dfn');
		tag$.defineTag('div');
		tag$.defineTag('dl');
		tag$.defineTag('dt');
		tag$.defineTag('em');
		tag$.defineTag('embed');
		tag$.defineTag('fieldset');
		tag$.defineTag('figcaption');
		tag$.defineTag('figure');
		tag$.defineTag('footer');
		
		tag$.defineTag('form', function(tag){
			
			
			tag.prototype.method = function(v){ return this.getAttribute('method'); }
			tag.prototype.setMethod = function(v){ this.setAttribute('method',v); return this; };
			
			
			tag.prototype.action = function(v){ return this.getAttribute('action'); }
			tag.prototype.setAction = function(v){ this.setAttribute('action',v); return this; };
		});
		
		tag$.defineTag('h1');
		tag$.defineTag('h2');
		tag$.defineTag('h3');
		tag$.defineTag('h4');
		tag$.defineTag('h5');
		tag$.defineTag('h6');
		tag$.defineTag('head');
		tag$.defineTag('header');
		tag$.defineTag('hr');
		tag$.defineTag('html');
		tag$.defineTag('i');
		
		tag$.defineTag('iframe', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
		});
		
		tag$.defineTag('img', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
		});
		
		tag$.defineTag('input', function(tag){
			// can use attr instead
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
			
			tag.prototype.setPlaceholder = function (v){
				if (v != this.dom().placeholder) { this.dom().placeholder = v };
				return this;
			};
			
			tag.prototype.placeholder = function (){
				return this.dom().placeholder;
			};
			
			tag.prototype.checked = function (){
				return this.dom().checked;
			};
			
			tag.prototype.setChecked = function (bool){
				if (bool != this.dom().checked) { this.dom().checked = bool };
				return this;
			};
		});
		
		tag$.defineTag('ins');
		tag$.defineTag('kbd');
		tag$.defineTag('keygen');
		tag$.defineTag('label');
		tag$.defineTag('legend');
		tag$.defineTag('li');
		
		tag$.defineTag('link', function(tag){
			
			
			tag.prototype.rel = function(v){ return this.getAttribute('rel'); }
			tag.prototype.setRel = function(v){ this.setAttribute('rel',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
			
			
			tag.prototype.media = function(v){ return this.getAttribute('media'); }
			tag.prototype.setMedia = function(v){ this.setAttribute('media',v); return this; };
		});
		
		tag$.defineTag('main');
		tag$.defineTag('map');
		tag$.defineTag('mark');
		tag$.defineTag('menu');
		tag$.defineTag('menuitem');
		
		tag$.defineTag('meta', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.content = function(v){ return this.getAttribute('content'); }
			tag.prototype.setContent = function(v){ this.setAttribute('content',v); return this; };
			
			
			tag.prototype.charset = function(v){ return this.getAttribute('charset'); }
			tag.prototype.setCharset = function(v){ this.setAttribute('charset',v); return this; };
		});
		
		tag$.defineTag('meter');
		tag$.defineTag('nav');
		tag$.defineTag('noscript');
		tag$.defineTag('object');
		tag$.defineTag('ol');
		tag$.defineTag('optgroup');
		
		tag$.defineTag('option', function(tag){
			
			
			tag.prototype.value = function(v){ return this.getAttribute('value'); }
			tag.prototype.setValue = function(v){ this.setAttribute('value',v); return this; };
		});
		
		tag$.defineTag('output');
		tag$.defineTag('p');
		tag$.defineTag('param');
		tag$.defineTag('pre');
		tag$.defineTag('progress');
		tag$.defineTag('q');
		tag$.defineTag('rp');
		tag$.defineTag('rt');
		tag$.defineTag('ruby');
		tag$.defineTag('s');
		tag$.defineTag('samp');
		
		tag$.defineTag('script', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.async = function(v){ return this.getAttribute('async'); }
			tag.prototype.setAsync = function(v){ this.setAttribute('async',v); return this; };
			
			
			tag.prototype.defer = function(v){ return this.getAttribute('defer'); }
			tag.prototype.setDefer = function(v){ this.setAttribute('defer',v); return this; };
		});
		
		tag$.defineTag('section');
		
		tag$.defineTag('select', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.multiple = function(v){ return this.getAttribute('multiple'); }
			tag.prototype.setMultiple = function(v){ this.setAttribute('multiple',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
		});
		
		
		tag$.defineTag('small');
		tag$.defineTag('source');
		tag$.defineTag('span');
		tag$.defineTag('strong');
		tag$.defineTag('style');
		tag$.defineTag('sub');
		tag$.defineTag('summary');
		tag$.defineTag('sup');
		tag$.defineTag('table');
		tag$.defineTag('tbody');
		tag$.defineTag('td');
		
		tag$.defineTag('textarea', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.rows = function(v){ return this.getAttribute('rows'); }
			tag.prototype.setRows = function(v){ this.setAttribute('rows',v); return this; };
			
			
			tag.prototype.cols = function(v){ return this.getAttribute('cols'); }
			tag.prototype.setCols = function(v){ this.setAttribute('cols',v); return this; };
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
			
			tag.prototype.setPlaceholder = function (v){
				if (v != this.dom().placeholder) { this.dom().placeholder = v };
				return this;
			};
			
			tag.prototype.placeholder = function (){
				return this.dom().placeholder;
			};
		});
		
		tag$.defineTag('tfoot');
		tag$.defineTag('th');
		tag$.defineTag('thead');
		tag$.defineTag('time');
		tag$.defineTag('title');
		tag$.defineTag('tr');
		tag$.defineTag('track');
		tag$.defineTag('u');
		tag$.defineTag('ul');
		tag$.defineTag('video');
		return tag$.defineTag('wbr');
	
	})()

/***/ },
/* 9 */
/***/ function(module, exports) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		
		tag$.SVG.defineTag('svgelement', function(tag){
			
			tag.namespaceURI = function (){
				return "http://www.w3.org/2000/svg";
			};
			
			var types = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
			
			tag.buildNode = function (){
				var dom = Imba.document().createElementNS(this.namespaceURI(),this._nodeType);
				var cls = this._classes.join(" ");
				if (cls) { dom.className.baseVal = cls };
				return dom;
			};
			
			tag.inherit = function (child){
				child._protoDom = null;
				
				if (idx$(child._name,types) >= 0) {
					child._nodeType = child._name;
					return child._classes = [];
				} else {
					child._nodeType = this._nodeType;
					var className = "_" + child._name.replace(/_/g,'-');
					return child._classes = this._classes.concat(className);
				};
			};
			
			
			Imba.attr(tag,'x');
			Imba.attr(tag,'y');
			
			Imba.attr(tag,'width');
			Imba.attr(tag,'height');
			
			Imba.attr(tag,'stroke');
			Imba.attr(tag,'stroke-width');
		});
		
		tag$.SVG.defineTag('svg', function(tag){
			Imba.attr(tag,'viewbox');
		});
		
		tag$.SVG.defineTag('g');
		
		tag$.SVG.defineTag('defs');
		
		tag$.SVG.defineTag('symbol', function(tag){
			Imba.attr(tag,'preserveAspectRatio');
			Imba.attr(tag,'viewBox');
		});
		
		tag$.SVG.defineTag('marker', function(tag){
			Imba.attr(tag,'markerUnits');
			Imba.attr(tag,'refX');
			Imba.attr(tag,'refY');
			Imba.attr(tag,'markerWidth');
			Imba.attr(tag,'markerHeight');
			Imba.attr(tag,'orient');
		});
		
		
		// Basic shapes
		
		tag$.SVG.defineTag('rect', function(tag){
			Imba.attr(tag,'rx');
			Imba.attr(tag,'ry');
		});
		
		tag$.SVG.defineTag('circle', function(tag){
			Imba.attr(tag,'cx');
			Imba.attr(tag,'cy');
			Imba.attr(tag,'r');
		});
		
		tag$.SVG.defineTag('ellipse', function(tag){
			Imba.attr(tag,'cx');
			Imba.attr(tag,'cy');
			Imba.attr(tag,'rx');
			Imba.attr(tag,'ry');
		});
		
		tag$.SVG.defineTag('path', function(tag){
			Imba.attr(tag,'d');
			Imba.attr(tag,'pathLength');
		});
		
		tag$.SVG.defineTag('line', function(tag){
			Imba.attr(tag,'x1');
			Imba.attr(tag,'x2');
			Imba.attr(tag,'y1');
			Imba.attr(tag,'y2');
		});
		
		tag$.SVG.defineTag('polyline', function(tag){
			Imba.attr(tag,'points');
		});
		
		tag$.SVG.defineTag('polygon', function(tag){
			Imba.attr(tag,'points');
		});
		
		tag$.SVG.defineTag('text', function(tag){
			Imba.attr(tag,'dx');
			Imba.attr(tag,'dy');
			Imba.attr(tag,'text-anchor');
			Imba.attr(tag,'rotate');
			Imba.attr(tag,'textLength');
			Imba.attr(tag,'lengthAdjust');
		});
		
		return tag$.SVG.defineTag('tspan', function(tag){
			Imba.attr(tag,'dx');
			Imba.attr(tag,'dy');
			Imba.attr(tag,'rotate');
			Imba.attr(tag,'textLength');
			Imba.attr(tag,'lengthAdjust');
		});
	
	})()

/***/ },
/* 10 */
/***/ function(module, exports) {

	(function(){
		if (!document.documentElement.classList) {
			tag$.extendTag('htmlelement', function(tag){
				
				tag.prototype.hasFlag = function (ref){
					return new RegExp('(^|\\s)' + ref + '(\\s|$)').test(this._dom.className);
				};
				
				tag.prototype.addFlag = function (ref){
					if (this.hasFlag(ref)) { return this };
					this._dom.className += (this._dom.className ? (' ') : ('')) + ref;
					return this;
				};
				
				tag.prototype.unflag = function (ref){
					if (!this.hasFlag(ref)) { return this };
					var regex = new RegExp('(^|\\s)*' + ref + '(\\s|$)*','g');
					this._dom.className = this._dom.className.replace(regex,'');
					return this;
				};
				
				tag.prototype.toggleFlag = function (ref){
					return this.hasFlag(ref) ? (this.unflag(ref)) : (this.flag(ref));
				};
				
				tag.prototype.flag = function (ref,bool){
					if (arguments.length == 2 && !!bool === false) {
						return this.unflag(ref);
					};
					return this.addFlag(ref);
				};
			});
			
			return true;
		};
	
	})()

/***/ },
/* 11 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var doc = document;
		var win = window;
		
		var hasTouchEvents = window && window.ontouchstart !== undefined;
		
		Imba.Pointer = function Pointer(){
			this.setButton(-1);
			this.setEvent({x: 0,y: 0,type: 'uninitialized'});
			return this;
		};
		
		
		
		Imba.Pointer.prototype.phase = function(v){ return this._phase; }
		Imba.Pointer.prototype.setPhase = function(v){ this._phase = v; return this; };
		
		
		Imba.Pointer.prototype.prevEvent = function(v){ return this._prevEvent; }
		Imba.Pointer.prototype.setPrevEvent = function(v){ this._prevEvent = v; return this; };
		
		
		Imba.Pointer.prototype.button = function(v){ return this._button; }
		Imba.Pointer.prototype.setButton = function(v){ this._button = v; return this; };
		
		
		Imba.Pointer.prototype.event = function(v){ return this._event; }
		Imba.Pointer.prototype.setEvent = function(v){ this._event = v; return this; };
		
		
		Imba.Pointer.prototype.dirty = function(v){ return this._dirty; }
		Imba.Pointer.prototype.setDirty = function(v){ this._dirty = v; return this; };
		
		
		Imba.Pointer.prototype.events = function(v){ return this._events; }
		Imba.Pointer.prototype.setEvents = function(v){ this._events = v; return this; };
		
		
		Imba.Pointer.prototype.touch = function(v){ return this._touch; }
		Imba.Pointer.prototype.setTouch = function(v){ this._touch = v; return this; };
		
		Imba.Pointer.prototype.update = function (e){
			this.setEvent(e);
			this.setDirty(true);
			return this;
		};
		
		// this is just for regular mouse now
		Imba.Pointer.prototype.process = function (){
			var e1 = this.event();
			
			if (this.dirty()) {
				this.setPrevEvent(e1);
				this.setDirty(false);
				
				// button should only change on mousedown etc
				if (e1.type == 'mousedown') {
					this.setButton(e1.button);
					
					// do not create touch for right click
					if (this.button() == 2 || (this.touch() && this.button() != 0)) {
						return;
					};
					
					// cancel the previous touch
					if (this.touch()) { this.touch().cancel() };
					this.setTouch(new Imba.Touch(e1,this));
					this.touch().mousedown(e1,e1);
				} else if (e1.type == 'mousemove') {
					if (this.touch()) { this.touch().mousemove(e1,e1) };
				} else if (e1.type == 'mouseup') {
					this.setButton(-1);
					
					if (this.touch() && this.touch().button() == e1.button) {
						this.touch().mouseup(e1,e1);
						this.setTouch(null);
					};
					// trigger pointerup
				};
			} else {
				if (this.touch()) { this.touch().idle() };
			};
			return this;
		};
		
		Imba.Pointer.prototype.cleanup = function (){
			return Imba.POINTERS;
		};
		
		Imba.Pointer.prototype.x = function (){
			return this.event().x;
		};
		Imba.Pointer.prototype.y = function (){
			return this.event().y;
		};
		
		// deprecated -- should remove
		Imba.Pointer.update = function (){
			// console.log('update touch')
			for (var i = 0, ary = iter$(Imba.POINTERS), len = ary.length; i < len; i++) {
				ary[i].process();
			};
			// need to be able to prevent the default behaviour of touch, no?
			win.requestAnimationFrame(Imba.Pointer.update);
			return this;
		};
		
		var lastNativeTouchTimeStamp = 0;
		var lastNativeTouchTimeout = 50;
		
		// Imba.Touch
		// Began	A finger touched the screen.
		// Moved	A finger moved on the screen.
		// Stationary	A finger is touching the screen but hasn't moved.
		// Ended	A finger was lifted from the screen. This is the final phase of a touch.
		// Canceled The system cancelled tracking for the touch.
		
		/*
		Consolidates mouse and touch events. Touch objects persist across a touch,
		from touchstart until end/cancel. When a touch starts, it will traverse
		down from the innermost target, until it finds a node that responds to
		ontouchstart. Unless the touch is explicitly redirected, the touch will
		call ontouchmove and ontouchend / ontouchcancel on the responder when appropriate.
		
			tag draggable
				# called when a touch starts
				def ontouchstart touch
					flag 'dragging'
					self
				
				# called when touch moves - same touch object
				def ontouchmove touch
					# move the node with touch
					css top: touch.dy, left: touch.dx
				
				# called when touch ends
				def ontouchend touch
					unflag 'dragging'
		
		@iname touch
		*/
		
		Imba.Touch = function Touch(event,pointer){
			// @native  = false
			this.setEvent(event);
			this.setData({});
			this.setActive(true);
			this._button = event && event.button || 0;
			this._suppress = false; // deprecated
			this._captured = false;
			this.setBubble(false);
			pointer = pointer;
			this.setUpdates(0);
			return this;
		};
		
		var touches = [];
		var count = 0;
		var identifiers = {};
		
		Imba.Touch.count = function (){
			return count;
		};
		
		Imba.Touch.lookup = function (item){
			return item && (item.__touch__ || identifiers[item.identifier]);
		};
		
		Imba.Touch.release = function (item,touch){
			var v_, $1;
			(((v_ = identifiers[item.identifier]),delete identifiers[item.identifier], v_));
			((($1 = item.__touch__),delete item.__touch__, $1));
			return;
		};
		
		Imba.Touch.ontouchstart = function (e){
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (this.lookup(t)) { continue; };
				var touch = identifiers[t.identifier] = new this(e); // (e)
				t.__touch__ = touch;
				touches.push(touch);
				count++;
				touch.touchstart(e,t);
			};
			return this;
		};
		
		Imba.Touch.ontouchmove = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchmove(e,t);
				};
			};
			
			return this;
		};
		
		Imba.Touch.ontouchend = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchend(e,t);
					this.release(t,touch);
					count--;
				};
			};
			
			// e.preventDefault
			// not always supported!
			// touches = touches.filter(||)
			return this;
		};
		
		Imba.Touch.ontouchcancel = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchcancel(e,t);
					this.release(t,touch);
					count--;
				};
			};
			return this;
		};
		
		Imba.Touch.onmousedown = function (e){
			return this;
		};
		
		Imba.Touch.onmousemove = function (e){
			return this;
		};
		
		Imba.Touch.onmouseup = function (e){
			return this;
		};
		
		
		
		
		Imba.Touch.prototype.phase = function(v){ return this._phase; }
		Imba.Touch.prototype.setPhase = function(v){ this._phase = v; return this; };
		
		
		Imba.Touch.prototype.active = function(v){ return this._active; }
		Imba.Touch.prototype.setActive = function(v){ this._active = v; return this; };
		
		
		Imba.Touch.prototype.event = function(v){ return this._event; }
		Imba.Touch.prototype.setEvent = function(v){ this._event = v; return this; };
		
		
		Imba.Touch.prototype.pointer = function(v){ return this._pointer; }
		Imba.Touch.prototype.setPointer = function(v){ this._pointer = v; return this; };
		
		
		Imba.Touch.prototype.target = function(v){ return this._target; }
		Imba.Touch.prototype.setTarget = function(v){ this._target = v; return this; };
		
		
		Imba.Touch.prototype.handler = function(v){ return this._handler; }
		Imba.Touch.prototype.setHandler = function(v){ this._handler = v; return this; };
		
		
		Imba.Touch.prototype.updates = function(v){ return this._updates; }
		Imba.Touch.prototype.setUpdates = function(v){ this._updates = v; return this; };
		
		
		Imba.Touch.prototype.suppress = function(v){ return this._suppress; }
		Imba.Touch.prototype.setSuppress = function(v){ this._suppress = v; return this; };
		
		
		Imba.Touch.prototype.data = function(v){ return this._data; }
		Imba.Touch.prototype.setData = function(v){ this._data = v; return this; };
		
		Imba.Touch.prototype.__bubble = {chainable: true,name: 'bubble'};
		Imba.Touch.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }
		Imba.Touch.prototype.setBubble = function(v){ this._bubble = v; return this; };
		
		
		
		Imba.Touch.prototype.gestures = function(v){ return this._gestures; }
		Imba.Touch.prototype.setGestures = function(v){ this._gestures = v; return this; };
		
		/*
			
		
			@internal
			@constructor
			*/
		
		Imba.Touch.prototype.capture = function (){
			this._captured = true;
			this._event && this._event.preventDefault();
			return this;
		};
		
		Imba.Touch.prototype.isCaptured = function (){
			return !!this._captured;
		};
		
		/*
			Extend the touch with a plugin / gesture. 
			All events (touchstart,move etc) for the touch
			will be triggered on the plugins in the order they
			are added.
			*/
		
		Imba.Touch.prototype.extend = function (plugin){
			// console.log "added gesture!!!"
			this._gestures || (this._gestures = []);
			this._gestures.push(plugin);
			return this;
		};
		
		/*
			Redirect touch to specified target. ontouchstart will always be
			called on the new target.
			@return {Number}
			*/
		
		Imba.Touch.prototype.redirect = function (target){
			this._redirect = target;
			return this;
		};
		
		/*
			Suppress the default behaviour. Will call preventDefault for
			all native events that are part of the touch.
			*/
		
		Imba.Touch.prototype.suppress = function (){
			// collision with the suppress property
			this._active = false;
			return this;
		};
		
		Imba.Touch.prototype.setSuppress = function (value){
			console.warn('Imba.Touch#suppress= is deprecated');
			this._supress = value;
			return this;
		};
		
		Imba.Touch.prototype.touchstart = function (e,t){
			this._event = e;
			this._touch = t;
			this._button = 0;
			this._x = t.clientX;
			this._y = t.clientY;
			this.began();
			if (e && this.isCaptured()) { e.preventDefault() };
			return this;
		};
		
		Imba.Touch.prototype.touchmove = function (e,t){
			this._event = e;
			this._x = t.clientX;
			this._y = t.clientY;
			this.update();
			if (e && this.isCaptured()) { e.preventDefault() };
			return this;
		};
		
		Imba.Touch.prototype.touchend = function (e,t){
			this._event = e;
			this._x = t.clientX;
			this._y = t.clientY;
			this.ended();
			
			lastNativeTouchTimeStamp = e.timeStamp;
			
			if (this._maxdr < 20) {
				var tap = new Imba.Event(e);
				tap.setType('tap');
				tap.process();
				if (tap._responder) { e.preventDefault() };
			};
			
			if (e && this.isCaptured()) {
				e.preventDefault();
			};
			
			return this;
		};
		
		Imba.Touch.prototype.touchcancel = function (e,t){
			return this.cancel();
		};
		
		Imba.Touch.prototype.mousedown = function (e,t){
			var self = this;
			self._event = e;
			self._button = e.button;
			self._x = t.clientX;
			self._y = t.clientY;
			self.began();
			
			self._mousemove = function(e) { return self.mousemove(e,e); };
			doc.addEventListener('mousemove',self._mousemove,true);
			return self;
		};
		
		Imba.Touch.prototype.mousemove = function (e,t){
			this._x = t.clientX;
			this._y = t.clientY;
			this._event = e;
			if (this.isCaptured()) { e.preventDefault() };
			this.update();
			this.move();
			return this;
		};
		
		Imba.Touch.prototype.mouseup = function (e,t){
			this._x = t.clientX;
			this._y = t.clientY;
			this.ended();
			doc.removeEventListener('mousemove',this._mousemove,true);
			this._mousemove = null;
			return this;
		};
		
		Imba.Touch.prototype.idle = function (){
			return this.update();
		};
		
		Imba.Touch.prototype.began = function (){
			this._maxdr = this._dr = 0;
			this._x0 = this._x;
			this._y0 = this._y;
			
			var dom = this.event().target;
			var node = null;
			
			this._sourceTarget = dom && tag$wrap(dom);
			
			while (dom){
				node = tag$wrap(dom);
				if (node && node.ontouchstart) {
					this._bubble = false;
					this.setTarget(node);
					this.target().ontouchstart(this);
					if (!this._bubble) { break; };
				};
				dom = dom.parentNode;
			};
			
			this._updates++;
			return this;
		};
		
		Imba.Touch.prototype.update = function (){
			var target_;
			if (!this._active) { return this };
			
			var dr = Math.sqrt(this.dx() * this.dx() + this.dy() * this.dy());
			if (dr > this._dr) { this._maxdr = dr };
			this._dr = dr;
			
			// catching a touch-redirect?!?
			if (this._redirect) {
				if (this._target && this._target.ontouchcancel) {
					this._target.ontouchcancel(this);
				};
				this.setTarget(this._redirect);
				this._redirect = null;
				if (this.target().ontouchstart) { this.target().ontouchstart(this) };
			};
			
			
			this._updates++;
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length; i < len; i++) {
					ary[i].ontouchupdate(this);
				};
			};
			
			(target_ = this.target()) && target_.ontouchupdate  &&  target_.ontouchupdate(this);
			return this;
		};
		
		Imba.Touch.prototype.move = function (){
			var target_;
			if (!this._active) { return this };
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length, g; i < len; i++) {
					g = ary[i];
					if (g.ontouchmove) { g.ontouchmove(this,this._event) };
				};
			};
			
			(target_ = this.target()) && target_.ontouchmove  &&  target_.ontouchmove(this,this._event);
			return this;
		};
		
		Imba.Touch.prototype.ended = function (){
			var target_;
			if (!this._active) { return this };
			
			this._updates++;
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length; i < len; i++) {
					ary[i].ontouchend(this);
				};
			};
			
			(target_ = this.target()) && target_.ontouchend  &&  target_.ontouchend(this);
			
			return this;
		};
		
		Imba.Touch.prototype.cancel = function (){
			if (!this._cancelled) {
				this._cancelled = true;
				this.cancelled();
				if (this._mousemove) { doc.removeEventListener('mousemove',this._mousemove,true) };
			};
			return this;
		};
		
		Imba.Touch.prototype.cancelled = function (){
			var target_;
			if (!this._active) { return this };
			
			this._cancelled = true;
			this._updates++;
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length, g; i < len; i++) {
					g = ary[i];
					if (g.ontouchcancel) { g.ontouchcancel(this) };
				};
			};
			
			(target_ = this.target()) && target_.ontouchcancel  &&  target_.ontouchcancel(this);
			return this;
		};
		
		/*
			The absolute distance the touch has moved from starting position 
			@return {Number}
			*/
		
		Imba.Touch.prototype.dr = function (){
			return this._dr;
		};
		
		/*
			The distance the touch has moved horizontally
			@return {Number}
			*/
		
		Imba.Touch.prototype.dx = function (){
			return this._x - this._x0;
		};
		
		/*
			The distance the touch has moved vertically
			@return {Number}
			*/
		
		Imba.Touch.prototype.dy = function (){
			return this._y - this._y0;
		};
		
		/*
			Initial horizontal position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.x0 = function (){
			return this._x0;
		};
		
		/*
			Initial vertical position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.y0 = function (){
			return this._y0;
		};
		
		/*
			Horizontal position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.x = function (){
			return this._x;
		};
		
		/*
			Vertical position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.y = function (){
			return this._y;
		};
		
		/*
			Horizontal position of touch relative to target
			@return {Number}
			*/
		
		Imba.Touch.prototype.tx = function (){
			this._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());
			return this._x - this._targetBox.left;
		};
		
		/*
			Vertical position of touch relative to target
			@return {Number}
			*/
		
		Imba.Touch.prototype.ty = function (){
			this._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());
			return this._y - this._targetBox.top;
		};
		
		/*
			Button pressed in this touch. Native touches defaults to left-click (0)
			@return {Number}
			*/
		
		Imba.Touch.prototype.button = function (){
			return this._button;
		}; // @pointer ? @pointer.button : 0
		
		Imba.Touch.prototype.sourceTarget = function (){
			return this._sourceTarget;
		};
		
		
		Imba.TouchGesture = function TouchGesture(){ };
		
		
		Imba.TouchGesture.prototype.__active = {'default': false,name: 'active'};
		Imba.TouchGesture.prototype.active = function(v){ return this._active; }
		Imba.TouchGesture.prototype.setActive = function(v){ this._active = v; return this; }
		Imba.TouchGesture.prototype._active = false;
		
		Imba.TouchGesture.prototype.ontouchstart = function (e){
			return this;
		};
		
		Imba.TouchGesture.prototype.ontouchupdate = function (e){
			return this;
		};
		
		Imba.TouchGesture.prototype.ontouchend = function (e){
			return this;
		};
		
		
		// A Touch-event is created on mousedown (always)
		// and while it exists, mousemove and mouseup will
		// be delegated to this active event.
		Imba.POINTER = new Imba.Pointer();
		Imba.POINTERS = [Imba.POINTER];
		
		
		// regular event stuff
		Imba.KEYMAP = {
			"8": 'backspace',
			"9": 'tab',
			"13": 'enter',
			"16": 'shift',
			"17": 'ctrl',
			"18": 'alt',
			"19": 'break',
			"20": 'caps',
			"27": 'esc',
			"32": 'space',
			"35": 'end',
			"36": 'home',
			"37": 'larr',
			"38": 'uarr',
			"39": 'rarr',
			"40": 'darr',
			"45": 'insert',
			"46": 'delete',
			"107": 'plus',
			"106": 'mult',
			"91": 'meta'
		};
		
		Imba.CHARMAP = {
			"%": 'modulo',
			"*": 'multiply',
			"+": 'add',
			"-": 'sub',
			"/": 'divide',
			".": 'dot'
		};
		
		/*
		Imba handles all events in the dom through a single manager,
		listening at the root of your document. If Imba finds a tag
		that listens to a certain event, the event will be wrapped 
		in an `Imba.Event`, which normalizes some of the quirks and 
		browser differences.
		
		@iname event
		*/
		
		Imba.Event = function Event(e){
			this.setEvent(e);
			this.setBubble(true);
		};
		
		/* reference to the native event */
		
		
		
		Imba.Event.prototype.event = function(v){ return this._event; }
		Imba.Event.prototype.setEvent = function(v){ this._event = v; return this; };
		
		/* reference to the native event */
		
		
		
		Imba.Event.prototype.prefix = function(v){ return this._prefix; }
		Imba.Event.prototype.setPrefix = function(v){ this._prefix = v; return this; };
		
		
		
		Imba.Event.prototype.data = function(v){ return this._data; }
		Imba.Event.prototype.setData = function(v){ this._data = v; return this; };
		
		/*
			should remove this alltogether?
			@deprecated
			*/
		
		
		
		Imba.Event.prototype.source = function(v){ return this._source; }
		Imba.Event.prototype.setSource = function(v){ this._source = v; return this; };
		
		/* A {Boolean} indicating whether the event bubbles up or not */
		
		
		Imba.Event.prototype.__bubble = {type: Boolean,chainable: true,name: 'bubble'};
		Imba.Event.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }
		Imba.Event.prototype.setBubble = function(v){ this._bubble = v; return this; };
		
		Imba.Event.wrap = function (e){
			return new this(e);
		};
		
		Imba.Event.prototype.setType = function (type){
			this._type = type;
			return this;
		};
		
		/*
			@return {String} The name of the event (case-insensitive)
			*/
		
		Imba.Event.prototype.type = function (){
			return this._type || this.event().type;
		};
		
		Imba.Event.prototype.name = function (){
			return this._name || (this._name = this.type().toLowerCase().replace(/\:/g,''));
		};
		
		// mimc getset
		Imba.Event.prototype.bubble = function (v){
			if (v != undefined) {
				this.setBubble(v);
				return this;
			};
			return this._bubble;
		};
		
		/*
			Prevents further propagation of the current event.
			@return {self}
			*/
		
		Imba.Event.prototype.halt = function (){
			this.setBubble(false);
			return this;
		};
		
		/*
			Cancel the event (if cancelable). In the case of native events it
			will call `preventDefault` on the wrapped event object.
			@return {self}
			*/
		
		Imba.Event.prototype.cancel = function (){
			if (this.event().preventDefault) { this.event().preventDefault() };
			this._cancel = true;
			return this;
		};
		
		/*
			Indicates whether or not event.cancel has been called.
		
			@return {Boolean}
			*/
		
		Imba.Event.prototype.isPrevented = function (){
			return this.event() && this.event().defaultPrevented || this._cancel;
		};
		
		/*
			A reference to the initial target of the event.
			*/
		
		Imba.Event.prototype.target = function (){
			return tag$wrap(this.event()._target || this.event().target);
		};
		
		/*
			A reference to the object responding to the event.
			*/
		
		Imba.Event.prototype.responder = function (){
			return this._responder;
		};
		
		/*
			Redirect the event to new target
			*/
		
		Imba.Event.prototype.redirect = function (node){
			this._redirect = node;
			return this;
		};
		
		/*
			Get the normalized character for KeyboardEvent/TextEvent
			@return {String}
			*/
		
		Imba.Event.prototype.keychar = function (){
			if (this.event() instanceof TextEvent) {
				return this.event().data;
			};
			
			if (this.event() instanceof KeyboardEvent) {
				var ki = this.event().keyIdentifier;
				var sym = Imba.KEYMAP[this.event().keyCode];
				
				// p 'keysym!',ki,sym
				
				if (!sym && ki.substr(0,2) == "U+") {
					sym = String.fromCharCode(parseInt(ki.substr(2),16));
				};
				return sym;
			};
			
			return null;
		};
		
		/*
			@deprecated
			*/
		
		Imba.Event.prototype.keycombo = function (){
			var sym;
			if (!(sym = this.keychar())) { return };
			sym = Imba.CHARMAP[sym] || sym;
			var combo = [],e = this.event();
			if (e.ctrlKey) { combo.push('ctrl') };
			if (e.shiftKey) { combo.push('shift') };
			if (e.altKey) { combo.push('alt') };
			if (e.metaKey) { combo.push('cmd') };
			combo.push(sym);
			return combo.join("_").toLowerCase();
		};
		
		
		Imba.Event.prototype.process = function (){
			var node;
			var meth = ("on" + (this._prefix || '') + this.name());
			var args = null;
			var domtarget = this.event()._target || this.event().target;
			// var node = <{domtarget:_responder or domtarget}>
			// need to clean up and document this behaviour
			
			var domnode = domtarget._responder || domtarget;
			// @todo need to stop infinite redirect-rules here
			
			var $1;while (domnode){
				this._redirect = null;
				if (node = tag$wrap(domnode)) { // not only tag 
					
					if ((typeof node[($1 = meth)]=='string'||node[$1] instanceof String)) {
						// should remember the receiver of the event
						meth = node[meth];
						continue; // should not continue?
					};
					
					if (node[meth] instanceof Array) {
						args = node[meth].concat(node);
						meth = args.shift();
						continue; // should not continue?
					};
					
					if (node[meth] instanceof Function) {
						this._responder || (this._responder = node);
						// should autostop bubble here?
						args ? (node[meth].apply(node,args)) : (node[meth](this,this.data()));
					};
				};
				
				// add node.nextEventResponder as a separate method here?
				if (!(this.bubble() && (domnode = (this._redirect || (node ? (node.parent()) : (domnode.parentNode)))))) {
					break;
				};
			};
			
			this.processed();
			return this;
		};
		
		
		Imba.Event.prototype.processed = function (){
			Imba.emit(Imba,'event',[this]);
			return this;
		};
		
		/*
			Return the x/left coordinate of the mouse / pointer for this event
			@return {Number} x coordinate of mouse / pointer for event
			*/
		
		Imba.Event.prototype.x = function (){
			return this.event().x;
		};
		
		/*
			Return the y/top coordinate of the mouse / pointer for this event
			@return {Number} y coordinate of mouse / pointer for event
			*/
		
		Imba.Event.prototype.y = function (){
			return this.event().y;
		};
		
		/*
			Returns a Number representing a system and implementation
			dependent numeric code identifying the unmodified value of the
			pressed key; this is usually the same as keyCode.
		
			For mouse-events, the returned value indicates which button was
			pressed on the mouse to trigger the event.
		
			@return {Number}
			*/
		
		Imba.Event.prototype.which = function (){
			return this.event().which;
		};
		
		
		/*
		
		Manager for listening to and delegating events in Imba. A single instance
		is always created by Imba (as `Imba.Events`), which handles and delegates all
		events at the very root of the document. Imba does not capture all events
		by default, so if you want to make sure exotic or custom DOMEvents are delegated
		in Imba you will need to register them in `Imba.Events.register(myCustomEventName)`
		
		@iname manager
		
		*/
		
		Imba.EventManager = function EventManager(node,pars){
			var self = this;
			if(!pars||pars.constructor !== Object) pars = {};
			var events = pars.events !== undefined ? pars.events : [];
			self.setRoot(node);
			self.setCount(0);
			self.setListeners([]);
			self.setDelegators({});
			self.setDelegator(function(e) {
				// console.log "delegating event?! {e}"
				self.delegate(e);
				return true;
			});
			
			for (var i = 0, ary = iter$(events), len = ary.length; i < len; i++) {
				self.register(ary[i]);
			};
			
			return self;
		};
		
		
		
		Imba.EventManager.prototype.root = function(v){ return this._root; }
		Imba.EventManager.prototype.setRoot = function(v){ this._root = v; return this; };
		
		
		Imba.EventManager.prototype.count = function(v){ return this._count; }
		Imba.EventManager.prototype.setCount = function(v){ this._count = v; return this; };
		
		Imba.EventManager.prototype.__enabled = {'default': false,watch: 'enabledDidSet',name: 'enabled'};
		Imba.EventManager.prototype.enabled = function(v){ return this._enabled; }
		Imba.EventManager.prototype.setEnabled = function(v){
			var a = this.enabled();
			if(v != a) { this._enabled = v; }
			if(v != a) { this.enabledDidSet && this.enabledDidSet(v,a,this.__enabled) }
			return this;
		}
		Imba.EventManager.prototype._enabled = false;
		
		
		Imba.EventManager.prototype.listeners = function(v){ return this._listeners; }
		Imba.EventManager.prototype.setListeners = function(v){ this._listeners = v; return this; };
		
		
		Imba.EventManager.prototype.delegators = function(v){ return this._delegators; }
		Imba.EventManager.prototype.setDelegators = function(v){ this._delegators = v; return this; };
		
		
		Imba.EventManager.prototype.delegator = function(v){ return this._delegator; }
		Imba.EventManager.prototype.setDelegator = function(v){ this._delegator = v; return this; };
		
		Imba.EventManager.prototype.enabledDidSet = function (bool){
			bool ? (this.onenable()) : (this.ondisable());
			return this;
		};
		
		/*
		
			Tell the current EventManager to intercept and handle event of a certain name.
			By default, Imba.Events will register interceptors for: *keydown*, *keyup*, 
			*keypress*, *textInput*, *input*, *change*, *submit*, *focusin*, *focusout*, 
			*blur*, *contextmenu*, *dblclick*, *mousewheel*, *wheel*
		
			*/
		
		Imba.EventManager.prototype.register = function (name,handler){
			if(handler === undefined) handler = true;
			if (name instanceof Array) {
				for (var i = 0, ary = iter$(name), len = ary.length; i < len; i++) {
					this.register(ary[i],handler);
				};
				return this;
			};
			
			if (this.delegators()[name]) { return this };
			// console.log("register for event {name}")
			var fn = this.delegators()[name] = handler instanceof Function ? (handler) : (this.delegator());
			if (this.enabled()) { return this.root().addEventListener(name,fn,true) };
		};
		
		Imba.EventManager.prototype.listen = function (name,handler,capture){
			if(capture === undefined) capture = true;
			this.listeners().push([name,handler,capture]);
			if (this.enabled()) { this.root().addEventListener(name,handler,capture) };
			return this;
		};
		
		Imba.EventManager.prototype.delegate = function (e){
			this.setCount(this.count() + 1);
			var event = Imba.Event.wrap(e);
			event.process();
			return this;
		};
		
		Imba.EventManager.prototype.create = function (type,target,pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var data = pars.data !== undefined ? pars.data : null;
			var source = pars.source !== undefined ? pars.source : null;
			var event = Imba.Event.wrap({type: type,target: target});
			if (data) { (event.setData(data),data) };
			if (source) { (event.setSource(source),source) };
			return event;
		};
		
		// use create instead?
		Imba.EventManager.prototype.trigger = function (){
			return this.create.apply(this,arguments).process();
		};
		
		Imba.EventManager.prototype.onenable = function (){
			for (var o = this.delegators(), i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				this.root().addEventListener(keys[i],o[keys[i]],true);
			};
			
			for (var i = 0, ary = iter$(this.listeners()), len = ary.length, item; i < len; i++) {
				item = ary[i];
				this.root().addEventListener(item[0],item[1],item[2]);
			};
			return this;
		};
		
		Imba.EventManager.prototype.ondisable = function (){
			for (var o = this.delegators(), i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				this.root().removeEventListener(keys[i],o[keys[i]],true);
			};
			
			for (var i = 0, ary = iter$(this.listeners()), len = ary.length, item; i < len; i++) {
				item = ary[i];
				this.root().removeEventListener(item[0],item[1],item[2]);
			};
			return this;
		};
		
		
		ED = Imba.Events = new Imba.EventManager(document,{events: [
			'keydown','keyup','keypress','textInput','input','change','submit',
			'focusin','focusout','blur','contextmenu','dblclick',
			'mousewheel','wheel'
		]});
		
		// should set these up inside the Imba.Events object itself
		// so that we can have different EventManager for different roots
		
		if (hasTouchEvents) {
			Imba.Events.listen('touchstart',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchstart(e);
			});
			
			Imba.Events.listen('touchmove',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchmove(e);
			});
			
			Imba.Events.listen('touchend',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchend(e);
			});
			
			Imba.Events.listen('touchcancel',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchcancel(e);
			});
		};
		
		Imba.Events.register('click',function(e) {
			// Only for main mousebutton, no?
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				var tap = new Imba.Event(e);
				tap.setType('tap');
				tap.process();
				if (tap._responder) {
					return e.preventDefault();
				};
			};
			// delegate the real click event
			return Imba.Events.delegate(e);
		});
		
		Imba.Events.listen('mousedown',function(e) {
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				if (Imba.POINTER) { return Imba.POINTER.update(e).process() };
			};
		});
		
		// Imba.Events.listen(:mousemove) do |e|
		// 	# console.log 'mousemove',e:timeStamp
		// 	if (e:timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout
		// 		Imba.POINTER.update(e).process if Imba.POINTER # .process if touch # should not happen? We process through 
		
		Imba.Events.listen('mouseup',function(e) {
			// console.log 'mouseup',e:timeStamp
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				if (Imba.POINTER) { return Imba.POINTER.update(e).process() };
			};
		});
		
		
		Imba.Events.register(['mousedown','mouseup']);
		return (Imba.Events.setEnabled(true),true);
	
	})()

/***/ },
/* 12 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var ImbaTag = Imba.TAGS.element;
		
		function removeNested(root,node,caret){
			// if node/nodes isa String
			// 	we need to use the caret to remove elements
			// 	for now we will simply not support this
			if (node instanceof ImbaTag) {
				root.removeChild(node);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					removeNested(root,ary[i],caret);
				};
			} else {
				// what if this is not null?!?!?
				// take a chance and remove a text-elementng
				var next = caret ? (caret.nextSibling) : (root._dom.firstChild);
				if ((next instanceof Text) && next.textContent == node) {
					root.removeChild(next);
				} else {
					throw 'cannot remove string';
				};
			};
			
			return caret;
		};
		
		function appendNested(root,node){
			if (node instanceof ImbaTag) {
				root.appendChild(node);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					appendNested(root,ary[i]);
				};
			} else if (node != null && node !== false) {
				root.appendChild(Imba.document().createTextNode(node));
			};
			
			return;
		};
		
		
		// insert nodes before a certain node
		// does not need to return any tail, as before
		// will still be correct there
		// before must be an actual domnode
		function insertNestedBefore(root,node,before){
			if (node instanceof ImbaTag) {
				root.insertBefore(node,before);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					insertNestedBefore(root,ary[i],before);
				};
			} else if (node != null && node !== false) {
				root.insertBefore(Imba.document().createTextNode(node),before);
			};
			
			return before;
		};
		
		// after must be an actual domnode
		function insertNestedAfter(root,node,after){
			var before = after ? (after.nextSibling) : (root._dom.firstChild);
			
			if (before) {
				insertNestedBefore(root,node,before);
				return before.previousSibling;
			} else {
				appendNested(root,node);
				return root._dom.lastChild;
			};
		};
		
		function reconcileCollectionChanges(root,new$,old,caret){
			
			var newLen = new$.length;
			var lastNew = new$[newLen - 1];
			
			// This re-order algorithm is based on the following principle:
			// 
			// We build a "chain" which shows which items are already sorted.
			// If we're going from [1, 2, 3] -> [2, 1, 3], the tree looks like:
			//
			// 	3 ->  0 (idx)
			// 	2 -> -1 (idx)
			// 	1 -> -1 (idx)
			//
			// This tells us that we have two chains of ordered items:
			// 
			// 	(1, 3) and (2)
			// 
			// The optimal re-ordering then becomes two keep the longest chain intact,
			// and move all the other items.
			
			var newPosition = [];
			
			// The tree/graph itself
			var prevChain = [];
			// The length of the chain
			var lengthChain = [];
			
			// Keep track of the longest chain
			var maxChainLength = 0;
			var maxChainEnd = 0;
			
			for (var idx = 0, ary = iter$(old), len = ary.length, node; idx < len; idx++) {
				node = ary[idx];
				var newPos = new$.indexOf(node);
				newPosition.push(newPos);
				
				if (newPos == -1) {
					root.removeChild(node);
					prevChain.push(-1);
					lengthChain.push(-1);
					continue;
				};
				
				var prevIdx = newPosition.length - 2;
				
				// Build the chain:
				while (prevIdx >= 0){
					if (newPosition[prevIdx] == -1) {
						prevIdx--;
					} else if (newPos > newPosition[prevIdx]) {
						// Yay, we're bigger than the previous!
						break;
					} else {
						// Nope, let's walk back the chain
						prevIdx = prevChain[prevIdx];
					};
				};
				
				prevChain.push(prevIdx);
				
				var currLength = (prevIdx == -1) ? (0) : (lengthChain[prevIdx] + 1);
				
				if (currLength > maxChainLength) {
					maxChainLength = currLength;
					maxChainEnd = idx;
				};
				
				lengthChain.push(currLength);
			};
			
			var stickyNodes = [];
			
			// Now we can walk the longest chain backwards and mark them as "sticky",
			// which implies that they should not be moved
			var cursor = newPosition.length - 1;
			while (cursor >= 0){
				if (cursor == maxChainEnd && newPosition[cursor] != -1) {
					stickyNodes[newPosition[cursor]] = true;
					maxChainEnd = prevChain[maxChainEnd];
				};
				
				cursor -= 1;
			};
			
			// And let's iterate forward, but only move non-sticky nodes
			for (var idx1 = 0, ary = iter$(new$), len = ary.length; idx1 < len; idx1++) {
				if (!stickyNodes[idx1]) {
					var after = new$[idx1 - 1];
					insertNestedAfter(root,ary[idx1],(after && after._dom) || caret);
				};
			};
			
			// should trust that the last item in new list is the caret
			return lastNew && lastNew._dom || caret;
		};
		
		
		// expects a flat non-sparse array of nodes in both new and old, always
		function reconcileCollection(root,new$,old,caret){
			var k = new$.length;
			var i = k;
			var last = new$[k - 1];
			
			
			if (k == old.length && new$[0] === old[0]) {
				// running through to compare
				while (i--){
					if (new$[i] !== old[i]) { break; };
				};
			};
			
			if (i == -1) {
				return last && last._dom || caret;
			} else {
				return reconcileCollectionChanges(root,new$,old,caret);
			};
		};
		
		// the general reconciler that respects conditions etc
		// caret is the current node we want to insert things after
		function reconcileNested(root,new$,old,caret){
			
			// if new == null or new === false or new === true
			// 	if new === old
			// 		return caret
			// 	if old && new != old
			// 		removeNested(root,old,caret) if old
			// 
			// 	return caret
			
			// var skipnew = new == null or new === false or new === true
			var newIsNull = new$ == null || new$ === false;
			var oldIsNull = old == null || old === false;
			
			
			if (new$ === old) {
				// remember that the caret must be an actual dom element
				// we should instead move the actual caret? - trust
				if (newIsNull) {
					return caret;
				} else if (new$ && new$._dom) {
					return new$._dom;
				} else {
					return caret ? (caret.nextSibling) : (root._dom.firstChild);
				};
			} else if (new$ instanceof Array) {
				if (old instanceof Array) {
					if (new$.static || old.static) {
						// if the static is not nested - we could get a hint from compiler
						// and just skip it
						if (new$.static == old.static) {
							for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
								// this is where we could do the triple equal directly
								caret = reconcileNested(root,ary[i],old[i],caret);
							};
							return caret;
						} else {
							removeNested(root,old,caret);
						};
						
						// if they are not the same we continue through to the default
					} else {
						return reconcileCollection(root,new$,old,caret);
					};
				} else if (old instanceof ImbaTag) {
					root.removeChild(old);
				} else if (!oldIsNull) {
					// old was a string-like object?
					root.removeChild(caret ? (caret.nextSibling) : (root._dom.firstChild));
				};
				
				return insertNestedAfter(root,new$,caret);
				// remove old
			} else if (new$ instanceof ImbaTag) {
				if (!oldIsNull) { removeNested(root,old,caret) };
				insertNestedAfter(root,new$,caret);
				return new$;
			} else if (newIsNull) {
				if (!oldIsNull) { removeNested(root,old,caret) };
				return caret;
			} else {
				// if old did not exist we need to add a new directly
				var nextNode;
				// if old was array or imbatag we need to remove it and then add
				if (old instanceof Array) {
					removeNested(root,old,caret);
				} else if (old instanceof ImbaTag) {
					root.removeChild(old);
				} else if (!oldIsNull) {
					// ...
					nextNode = caret ? (caret.nextSibling) : (root._dom.firstChild);
					if ((nextNode instanceof Text) && nextNode.textContent != new$) {
						nextNode.textContent = new$;
						return nextNode;
					};
				};
				
				// now add the textnode
				return insertNestedAfter(root,new$,caret);
			};
		};
		
		
		return tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.setChildren = function (new$,typ){
				var old = this._children;
				// var isArray = nodes isa Array
				if (new$ === old) {
					return this;
				};
				
				if (!old) {
					this.empty();
					appendNested(this,new$);
				} else if (typ == 2) {
					return this;
				} else if (typ == 1) {
					// here we _know _that it is an array with the same shape
					// every time
					var caret = null;
					for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
						// prev = old[i]
						caret = reconcileNested(this,ary[i],old[i],caret);
					};
				} else if (typ == 3) {
					// this is possibly fully dynamic. It often is
					// but the old or new could be static while the other is not
					// this is not handled now
					// what if it was previously a static array? edgecase - but must work
					if (new$ instanceof ImbaTag) {
						this.empty();
						this.appendChild(new$);
					} else if (new$ instanceof Array) {
						if (old instanceof Array) {
							// is this not the same as setting staticChildren now but with the
							reconcileCollection(this,new$,old,null);
						} else {
							this.empty();
							appendNested(this,new$);
						};
					} else {
						this.setText(new$);
						return this;
					};
				} else if ((new$ instanceof Array) && (old instanceof Array)) {
					reconcileCollection(this,new$,old,null);
				} else {
					this.empty();
					appendNested(this,new$);
				};
				
				this._children = new$;
				return this;
			};
			
			
			// only ever called with array as argument
			tag.prototype.setStaticChildren = function (new$){
				var old = this._children;
				
				var caret = null;
				for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
					// prev = old[i]
					caret = reconcileNested(this,ary[i],old[i],caret);
				};
				
				this._children = new$;
				return this;
			};
			
			tag.prototype.content = function (){
				return this._content || this.children().toArray();
			};
			
			tag.prototype.setText = function (text){
				if (text != this._children) {
					this._children = text;
					this.dom().textContent = text == null || text === false ? ('') : (text);
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 13 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		/*
		The special syntax for selectors in Imba creates Imba.Selector
		instances.
		*/
		
		Imba.Selector = function Selector(sel,scope,nodes){
			
			this._query = sel instanceof Imba.Selector ? (sel.query()) : (sel);
			this._context = scope;
			
			if (nodes) {
				for (var i = 0, ary = iter$(nodes), len = ary.length, res = []; i < len; i++) {
					res.push(tag$wrap(ary[i]));
				};
				this._nodes = res;
			};
			
			this._lazy = !nodes;
			return this;
		};
		
		Imba.Selector.one = function (sel,scope){
			var el = (scope || Imba.document()).querySelector(sel);
			return el && tag$wrap(el) || null;
		};
		
		Imba.Selector.all = function (sel,scope){
			return new Imba.Selector(sel,scope);
		};
		
		
		
		Imba.Selector.prototype.query = function(v){ return this._query; }
		Imba.Selector.prototype.setQuery = function(v){ this._query = v; return this; };
		
		Imba.Selector.prototype.reload = function (){
			this._nodes = null;
			return this;
		};
		
		Imba.Selector.prototype.scope = function (){
			var ctx;
			if (this._scope) { return this._scope };
			if (!(ctx = this._context)) { return Imba.document() };
			return this._scope = ctx.toScope ? (ctx.toScope()) : (ctx);
		};
		
		/*
			@returns {Imba.Tag} first node matching this selector
			*/
		
		Imba.Selector.prototype.first = function (){
			if (this._lazy) { return tag$wrap(this._first || (this._first = this.scope().querySelector(this.query()))) } else {
				return this.nodes()[0];
			};
		};
		
		/*
			@returns {Imba.Tag} last node matching this selector
			*/
		
		Imba.Selector.prototype.last = function (){
			return this.nodes()[this._nodes.length - 1];
		};
		
		/*
			@returns [Imba.Tag] all nodes matching this selector
			*/
		
		Imba.Selector.prototype.nodes = function (){
			if (this._nodes) { return this._nodes };
			var items = this.scope().querySelectorAll(this.query());
			for (var i = 0, ary = iter$(items), len = ary.length, res = []; i < len; i++) {
				res.push(tag$wrap(ary[i]));
			};
			this._nodes = res;
			this._lazy = false;
			return this._nodes;
		};
		
		/*
			The number of nodes matching this selector
			*/
		
		Imba.Selector.prototype.count = function (){
			return this.nodes().length;
		};
		
		Imba.Selector.prototype.len = function (){
			return this.nodes().length;
		};
		
		/*
			@todo Add support for block or selector?
			*/
		
		Imba.Selector.prototype.some = function (){
			return this.count() >= 1;
		};
		
		/*
			Get node at index
			*/
		
		Imba.Selector.prototype.at = function (idx){
			return this.nodes()[idx];
		};
		
		/*
			Loop through nodes
			*/
		
		Imba.Selector.prototype.forEach = function (block){
			this.nodes().forEach(block);
			return this;
		};
		
		/*
			Map nodes
			*/
		
		Imba.Selector.prototype.map = function (block){
			return this.nodes().map(block);
		};
		
		/*
			Returns a plain array containing nodes. Implicitly called
			when iterating over a selector in Imba `(node for node in $(selector))`
			*/
		
		Imba.Selector.prototype.toArray = function (){
			return this.nodes();
		};
		
		// Get the first element that matches the selector, 
		// beginning at the current element and progressing up through the DOM tree
		Imba.Selector.prototype.closest = function (sel){
			// seems strange that we alter this selector?
			this._nodes = this.map(function(node) { return node.closest(sel); });
			return this;
		};
		
		// Get the siblings of each element in the set of matched elements, 
		// optionally filtered by a selector.
		// TODO remove duplicates?
		Imba.Selector.prototype.siblings = function (sel){
			this._nodes = this.map(function(node) { return node.siblings(sel); });
			return this;
		};
		
		// Get the descendants of each element in the current set of matched 
		// elements, filtered by a selector.
		Imba.Selector.prototype.find = function (sel){
			this._nodes = this.__query__(sel.query(),this.nodes());
			return this;
		};
		
		Imba.Selector.prototype.reject = function (blk){
			return this.filter(blk,false);
		};
		
		/*
			Filter the nodes in selector by a function or other selector
			*/
		
		Imba.Selector.prototype.filter = function (blk,bool){
			if(bool === undefined) bool = true;
			var fn = (blk instanceof Function) && blk || function(n) { return n.matches(blk); };
			var ary = this.nodes().filter(function(n) { return fn(n) == bool; });
			// if we want to return a new selector for this, we should do that for
			// others as well
			return new Imba.Selector("",this._scope,ary);
		};
		
		Imba.Selector.prototype.__query__ = function (query,contexts){
			var nodes = [];
			var i = 0;
			var l = contexts.length;
			
			while (i < l){
				nodes.push.apply(nodes,contexts[i++].querySelectorAll(query));
			};
			return nodes;
		};
		
		Imba.Selector.prototype.__matches__ = function (){
			return true;
		};
		
		/*
			Add specified flag to all nodes in selector
			*/
		
		Imba.Selector.prototype.flag = function (flag){
			return this.forEach(function(n) { return n.flag(flag); });
		};
		
		/*
			Remove specified flag from all nodes in selector
			*/
		
		Imba.Selector.prototype.unflag = function (flag){
			return this.forEach(function(n) { return n.unflag(flag); });
		};
		
		
		// def Imba.querySelectorAll
		q$ = function(sel,scope) { return new Imba.Selector(sel,scope); };
		
		// def Imba.Selector.one
		q$$ = function(sel,scope) {
			var el = (scope || Imba.document()).querySelector(sel);
			return el && tag$wrap(el) || null;
		};
		
		
		// extending tags with query-methods
		// must be a better way to reopen classes
		return tag$.extendTag('element', function(tag){
			tag.prototype.querySelectorAll = function (q){
				return this._dom.querySelectorAll(q);
			};
			tag.prototype.querySelector = function (q){
				return this._dom.querySelector(q);
			};
			
			// should be moved to Imba.Tag instead?
			// or we should implement all of them here
			tag.prototype.find = function (sel){
				return new Imba.Selector(sel,this);
			};
		});
		
	
	})()

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var util;
		IMDEBUG = true;
		
		// wtf er alt dette?
		IM = {};
		IM.NEWLINE = '\n';
		IM.CHAR = 0;
		IM.WORD_START = 1;
		IM.WORD_END = 2;
		IM.PUNCTUATION_START = 3;
		IM.PUNCTUATION_END = 4;
		IM.SUB_WORD_START = 5;
		IM.SUB_WORD_END = 6;
		IM.LINE_START = 7;
		IM.LINE_END = 8;
		IM.EMPTY_LINE = 9;
		
		IM.FS = __webpack_require__(15);
		
		var SourceMap = __webpack_require__(16);
		
		// if global:require
		var Region = __webpack_require__(27).Region;
		
		__webpack_require__(28);
		
		__webpack_require__(35);
		__webpack_require__(36);
		__webpack_require__(37);
		
		__webpack_require__(38);
		__webpack_require__(39);
		__webpack_require__(45);
		
		var Highlighter = __webpack_require__(29).Highlighter;
		var ImbacWorker = __webpack_require__(46).ImbacWorker;
		
		IM.worker = function (){
			return this._worker || (this._worker = new ImbacWorker());
		};
		
		module.exports.util = util = __webpack_require__(34);
		// nodes
		__webpack_require__(47);
		
		
		function worker(){
			return IM.worker();
		}; exports.worker = worker;
		
		module.exports.SourceMap = SourceMap;
		module.exports.Region = Region;
		return module.exports.Highlighter = Highlighter;
	
	})()

/***/ },
/* 15 */
/***/ function(module, exports) {

	(function(){
		// externs;
		function save(path,content,encoding,cb){
			if(cb==undefined && typeof encoding == 'function') cb = encoding,encoding = 'utf-8';
			if(encoding==undefined) encoding = 'utf-8';
			console.log('save',path,content,encoding);
			
			return xr.post(path,{body: content}).then(function() {
				console.log('responded');
				return cb && cb(arguments);
			});
		}; exports.save = save;
		
		function readFileAsync(path,encoding,cb){
			if(cb==undefined && typeof encoding == 'function') cb = encoding,encoding = 'utf-8';
			if(encoding==undefined) encoding = 'utf-8';
			console.log('save',path,encoding);
			
			return xr.get(path).then(function(res) {
				console.log('responded',res);
				cb && cb(arguments);
				return res;
			});
		}; exports.readFileAsync = readFileAsync;; return readFileAsync;
	
	})()

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(17).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(23).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(26).SourceNode;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var base64VLQ = __webpack_require__(18);
	  var util = __webpack_require__(20);
	  var ArraySet = __webpack_require__(21).ArraySet;
	  var MappingList = __webpack_require__(22).MappingList;
	
	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. You may pass an object with the following
	   * properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: A root for all relative URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    if (!aArgs) {
	      aArgs = {};
	    }
	    this._file = util.getArg(aArgs, 'file', null);
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = new MappingList();
	    this._sourcesContents = null;
	  }
	
	  SourceMapGenerator.prototype._version = 3;
	
	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap =
	    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	      var sourceRoot = aSourceMapConsumer.sourceRoot;
	      var generator = new SourceMapGenerator({
	        file: aSourceMapConsumer.file,
	        sourceRoot: sourceRoot
	      });
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        var newMapping = {
	          generated: {
	            line: mapping.generatedLine,
	            column: mapping.generatedColumn
	          }
	        };
	
	        if (mapping.source != null) {
	          newMapping.source = mapping.source;
	          if (sourceRoot != null) {
	            newMapping.source = util.relative(sourceRoot, newMapping.source);
	          }
	
	          newMapping.original = {
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          };
	
	          if (mapping.name != null) {
	            newMapping.name = mapping.name;
	          }
	        }
	
	        generator.addMapping(newMapping);
	      });
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          generator.setSourceContent(sourceFile, content);
	        }
	      });
	      return generator;
	    };
	
	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping =
	    function SourceMapGenerator_addMapping(aArgs) {
	      var generated = util.getArg(aArgs, 'generated');
	      var original = util.getArg(aArgs, 'original', null);
	      var source = util.getArg(aArgs, 'source', null);
	      var name = util.getArg(aArgs, 'name', null);
	
	      if (!this._skipValidation) {
	        this._validateMapping(generated, original, source, name);
	      }
	
	      if (source != null && !this._sources.has(source)) {
	        this._sources.add(source);
	      }
	
	      if (name != null && !this._names.has(name)) {
	        this._names.add(name);
	      }
	
	      this._mappings.add({
	        generatedLine: generated.line,
	        generatedColumn: generated.column,
	        originalLine: original != null && original.line,
	        originalColumn: original != null && original.column,
	        source: source,
	        name: name
	      });
	    };
	
	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent =
	    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	      var source = aSourceFile;
	      if (this._sourceRoot != null) {
	        source = util.relative(this._sourceRoot, source);
	      }
	
	      if (aSourceContent != null) {
	        // Add the source content to the _sourcesContents map.
	        // Create a new _sourcesContents map if the property is null.
	        if (!this._sourcesContents) {
	          this._sourcesContents = {};
	        }
	        this._sourcesContents[util.toSetString(source)] = aSourceContent;
	      } else if (this._sourcesContents) {
	        // Remove the source file from the _sourcesContents map.
	        // If the _sourcesContents map is empty, set the property to null.
	        delete this._sourcesContents[util.toSetString(source)];
	        if (Object.keys(this._sourcesContents).length === 0) {
	          this._sourcesContents = null;
	        }
	      }
	    };
	
	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   * @param aSourceMapPath Optional. The dirname of the path to the source map
	   *        to be applied. If relative, it is relative to the SourceMapConsumer.
	   *        This parameter is needed when the two source maps aren't in the same
	   *        directory, and the source map to be applied contains relative source
	   *        paths. If so, those relative source paths need to be rewritten
	   *        relative to the SourceMapGenerator.
	   */
	  SourceMapGenerator.prototype.applySourceMap =
	    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	      var sourceFile = aSourceFile;
	      // If aSourceFile is omitted, we will use the file property of the SourceMap
	      if (aSourceFile == null) {
	        if (aSourceMapConsumer.file == null) {
	          throw new Error(
	            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	            'or the source map\'s "file" property. Both were omitted.'
	          );
	        }
	        sourceFile = aSourceMapConsumer.file;
	      }
	      var sourceRoot = this._sourceRoot;
	      // Make "sourceFile" relative if an absolute Url is passed.
	      if (sourceRoot != null) {
	        sourceFile = util.relative(sourceRoot, sourceFile);
	      }
	      // Applying the SourceMap can add and remove items from the sources and
	      // the names array.
	      var newSources = new ArraySet();
	      var newNames = new ArraySet();
	
	      // Find mappings for the "sourceFile"
	      this._mappings.unsortedForEach(function (mapping) {
	        if (mapping.source === sourceFile && mapping.originalLine != null) {
	          // Check if it can be mapped by the source map, then update the mapping.
	          var original = aSourceMapConsumer.originalPositionFor({
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          });
	          if (original.source != null) {
	            // Copy mapping
	            mapping.source = original.source;
	            if (aSourceMapPath != null) {
	              mapping.source = util.join(aSourceMapPath, mapping.source)
	            }
	            if (sourceRoot != null) {
	              mapping.source = util.relative(sourceRoot, mapping.source);
	            }
	            mapping.originalLine = original.line;
	            mapping.originalColumn = original.column;
	            if (original.name != null) {
	              mapping.name = original.name;
	            }
	          }
	        }
	
	        var source = mapping.source;
	        if (source != null && !newSources.has(source)) {
	          newSources.add(source);
	        }
	
	        var name = mapping.name;
	        if (name != null && !newNames.has(name)) {
	          newNames.add(name);
	        }
	
	      }, this);
	      this._sources = newSources;
	      this._names = newNames;
	
	      // Copy sourcesContents of applied map.
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aSourceMapPath != null) {
	            sourceFile = util.join(aSourceMapPath, sourceFile);
	          }
	          if (sourceRoot != null) {
	            sourceFile = util.relative(sourceRoot, sourceFile);
	          }
	          this.setSourceContent(sourceFile, content);
	        }
	      }, this);
	    };
	
	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping =
	    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                                aName) {
	      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	          && aGenerated.line > 0 && aGenerated.column >= 0
	          && !aOriginal && !aSource && !aName) {
	        // Case 1.
	        return;
	      }
	      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	               && aGenerated.line > 0 && aGenerated.column >= 0
	               && aOriginal.line > 0 && aOriginal.column >= 0
	               && aSource) {
	        // Cases 2 and 3.
	        return;
	      }
	      else {
	        throw new Error('Invalid mapping: ' + JSON.stringify({
	          generated: aGenerated,
	          source: aSource,
	          original: aOriginal,
	          name: aName
	        }));
	      }
	    };
	
	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings =
	    function SourceMapGenerator_serializeMappings() {
	      var previousGeneratedColumn = 0;
	      var previousGeneratedLine = 1;
	      var previousOriginalColumn = 0;
	      var previousOriginalLine = 0;
	      var previousName = 0;
	      var previousSource = 0;
	      var result = '';
	      var mapping;
	      var nameIdx;
	      var sourceIdx;
	
	      var mappings = this._mappings.toArray();
	      for (var i = 0, len = mappings.length; i < len; i++) {
	        mapping = mappings[i];
	
	        if (mapping.generatedLine !== previousGeneratedLine) {
	          previousGeneratedColumn = 0;
	          while (mapping.generatedLine !== previousGeneratedLine) {
	            result += ';';
	            previousGeneratedLine++;
	          }
	        }
	        else {
	          if (i > 0) {
	            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	              continue;
	            }
	            result += ',';
	          }
	        }
	
	        result += base64VLQ.encode(mapping.generatedColumn
	                                   - previousGeneratedColumn);
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (mapping.source != null) {
	          sourceIdx = this._sources.indexOf(mapping.source);
	          result += base64VLQ.encode(sourceIdx - previousSource);
	          previousSource = sourceIdx;
	
	          // lines are stored 0-based in SourceMap spec version 3
	          result += base64VLQ.encode(mapping.originalLine - 1
	                                     - previousOriginalLine);
	          previousOriginalLine = mapping.originalLine - 1;
	
	          result += base64VLQ.encode(mapping.originalColumn
	                                     - previousOriginalColumn);
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (mapping.name != null) {
	            nameIdx = this._names.indexOf(mapping.name);
	            result += base64VLQ.encode(nameIdx - previousName);
	            previousName = nameIdx;
	          }
	        }
	      }
	
	      return result;
	    };
	
	  SourceMapGenerator.prototype._generateSourcesContent =
	    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	      return aSources.map(function (source) {
	        if (!this._sourcesContents) {
	          return null;
	        }
	        if (aSourceRoot != null) {
	          source = util.relative(aSourceRoot, source);
	        }
	        var key = util.toSetString(source);
	        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
	                                                    key)
	          ? this._sourcesContents[key]
	          : null;
	      }, this);
	    };
	
	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON =
	    function SourceMapGenerator_toJSON() {
	      var map = {
	        version: this._version,
	        sources: this._sources.toArray(),
	        names: this._names.toArray(),
	        mappings: this._serializeMappings()
	      };
	      if (this._file != null) {
	        map.file = this._file;
	      }
	      if (this._sourceRoot != null) {
	        map.sourceRoot = this._sourceRoot;
	      }
	      if (this._sourcesContents) {
	        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	      }
	
	      return map;
	    };
	
	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString =
	    function SourceMapGenerator_toString() {
	      return JSON.stringify(this.toJSON());
	    };
	
	  exports.SourceMapGenerator = SourceMapGenerator;
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	{
	  var base64 = __webpack_require__(19);
	
	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011
	
	  var VLQ_BASE_SHIFT = 5;
	
	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0
	      ? ((-aValue) << 1) + 1
	      : (aValue << 1) + 0;
	  }
	
	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative
	      ? -shifted
	      : shifted;
	  }
	
	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  exports.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;
	
	    var vlq = toVLQSigned(aValue);
	
	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);
	
	    return encoded;
	  };
	
	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string via the out parameter.
	   */
	  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;
	
	    do {
	      if (aIndex >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	
	      digit = base64.decode(aStr.charCodeAt(aIndex++));
	      if (digit === -1) {
	        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	      }
	
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);
	
	    aOutParam.value = fromVLQSigned(result);
	    aOutParam.rest = aIndex;
	  };
	}


/***/ },
/* 19 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  exports.encode = function (number) {
	    if (0 <= number && number < intToCharMap.length) {
	      return intToCharMap[number];
	    }
	    throw new TypeError("Must be between 0 and 63: " + number);
	  };
	
	  /**
	   * Decode a single base 64 character code digit to an integer. Returns -1 on
	   * failure.
	   */
	  exports.decode = function (charCode) {
	    var bigA = 65;     // 'A'
	    var bigZ = 90;     // 'Z'
	
	    var littleA = 97;  // 'a'
	    var littleZ = 122; // 'z'
	
	    var zero = 48;     // '0'
	    var nine = 57;     // '9'
	
	    var plus = 43;     // '+'
	    var slash = 47;    // '/'
	
	    var littleOffset = 26;
	    var numberOffset = 52;
	
	    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	    if (bigA <= charCode && charCode <= bigZ) {
	      return (charCode - bigA);
	    }
	
	    // 26 - 51: abcdefghijklmnopqrstuvwxyz
	    if (littleA <= charCode && charCode <= littleZ) {
	      return (charCode - littleA + littleOffset);
	    }
	
	    // 52 - 61: 0123456789
	    if (zero <= charCode && charCode <= nine) {
	      return (charCode - zero + numberOffset);
	    }
	
	    // 62: +
	    if (charCode == plus) {
	      return 62;
	    }
	
	    // 63: /
	    if (charCode == slash) {
	      return 63;
	    }
	
	    // Invalid base64 digit.
	    return -1;
	  };
	}


/***/ },
/* 20 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }
	  exports.getArg = getArg;
	
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;
	
	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);
	    if (!match) {
	      return null;
	    }
	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }
	  exports.urlParse = urlParse;
	
	  function urlGenerate(aParsedUrl) {
	    var url = '';
	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }
	    url += '//';
	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }
	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }
	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port
	    }
	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }
	    return url;
	  }
	  exports.urlGenerate = urlGenerate;
	
	  /**
	   * Normalizes a path, or the path portion of a URL:
	   *
	   * - Replaces consequtive slashes with one slash.
	   * - Removes unnecessary '.' parts.
	   * - Removes unnecessary '<dir>/..' parts.
	   *
	   * Based on code in the Node.js 'path' core module.
	   *
	   * @param aPath The path or url to normalize.
	   */
	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);
	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }
	      path = url.path;
	    }
	    var isAbsolute = exports.isAbsolute(path);
	
	    var parts = path.split(/\/+/);
	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];
	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          // The first part is blank if the path is absolute. Trying to go
	          // above the root is a no-op. Therefore we can remove all '..' parts
	          // directly after the root.
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }
	    path = parts.join('/');
	
	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }
	
	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }
	    return path;
	  }
	  exports.normalize = normalize;
	
	  /**
	   * Joins two paths/URLs.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be joined with the root.
	   *
	   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	   *   first.
	   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	   *   is updated with the result and aRoot is returned. Otherwise the result
	   *   is returned.
	   *   - If aPath is absolute, the result is aPath.
	   *   - Otherwise the two paths are joined with a slash.
	   * - Joining for example 'http://' and 'www.example.com' is also supported.
	   */
	  function join(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	    if (aPath === "") {
	      aPath = ".";
	    }
	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);
	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    }
	
	    // `join(foo, '//www.example.org')`
	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }
	      return urlGenerate(aPathUrl);
	    }
	
	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }
	
	    // `join('http://', 'www.example.com')`
	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }
	
	    var joined = aPath.charAt(0) === '/'
	      ? aPath
	      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }
	    return joined;
	  }
	  exports.join = join;
	
	  exports.isAbsolute = function (aPath) {
	    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	  };
	
	  /**
	   * Make a path relative to a URL or another path.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be made relative to aRoot.
	   */
	  function relative(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	
	    aRoot = aRoot.replace(/\/$/, '');
	
	    // It is possible for the path to be above the root. In this case, simply
	    // checking whether the root is a prefix of the path won't work. Instead, we
	    // need to remove components from the root one by one, until either we find
	    // a prefix that fits, or we run out of components to remove.
	    var level = 0;
	    while (aPath.indexOf(aRoot + '/') !== 0) {
	      var index = aRoot.lastIndexOf("/");
	      if (index < 0) {
	        return aPath;
	      }
	
	      // If the only part of the root that is left is the scheme (i.e. http://,
	      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	      // have exhausted all components, so the path is not relative to the root.
	      aRoot = aRoot.slice(0, index);
	      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	        return aPath;
	      }
	
	      ++level;
	    }
	
	    // Make sure we add a "../" for each component we removed from the root.
	    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	  }
	  exports.relative = relative;
	
	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */
	  function toSetString(aStr) {
	    return '$' + aStr;
	  }
	  exports.toSetString = toSetString;
	
	  function fromSetString(aStr) {
	    return aStr.substr(1);
	  }
	  exports.fromSetString = fromSetString;
	
	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */
	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0 || onlyCompareOriginal) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  }
	  exports.compareByOriginalPositions = compareByOriginalPositions;
	
	  /**
	   * Comparator between two mappings with deflated source and name indices where
	   * the generated positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */
	  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0 || onlyCompareGenerated) {
	      return cmp;
	    }
	
	    cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  }
	  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	  function strcmp(aStr1, aStr2) {
	    if (aStr1 === aStr2) {
	      return 0;
	    }
	
	    if (aStr1 > aStr2) {
	      return 1;
	    }
	
	    return -1;
	  }
	
	  /**
	   * Comparator between two mappings with inflated source and name strings where
	   * the generated positions are compared.
	   */
	  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return strcmp(mappingA.name, mappingB.name);
	  }
	  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	
	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = {};
	  }
	
	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };
	
	  /**
	   * Return how many unique items are in this ArraySet. If duplicates have been
	   * added, than those do not count towards the size.
	   *
	   * @returns Number
	   */
	  ArraySet.prototype.size = function ArraySet_size() {
	    return Object.getOwnPropertyNames(this._set).length;
	  };
	
	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var sStr = util.toSetString(aStr);
	    var isDuplicate = this._set.hasOwnProperty(sStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      this._set[sStr] = idx;
	    }
	  };
	
	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    var sStr = util.toSetString(aStr);
	    return this._set.hasOwnProperty(sStr);
	  };
	
	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    var sStr = util.toSetString(aStr);
	    if (this._set.hasOwnProperty(sStr)) {
	      return this._set[sStr];
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };
	
	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };
	
	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };
	
	  exports.ArraySet = ArraySet;
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	
	  /**
	   * Determine whether mappingB is after mappingA with respect to generated
	   * position.
	   */
	  function generatedPositionAfter(mappingA, mappingB) {
	    // Optimized for most common case
	    var lineA = mappingA.generatedLine;
	    var lineB = mappingB.generatedLine;
	    var columnA = mappingA.generatedColumn;
	    var columnB = mappingB.generatedColumn;
	    return lineB > lineA || lineB == lineA && columnB >= columnA ||
	           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	  }
	
	  /**
	   * A data structure to provide a sorted view of accumulated mappings in a
	   * performance conscious manner. It trades a neglibable overhead in general
	   * case for a large speedup in case of mappings being added in order.
	   */
	  function MappingList() {
	    this._array = [];
	    this._sorted = true;
	    // Serves as infimum
	    this._last = {generatedLine: -1, generatedColumn: 0};
	  }
	
	  /**
	   * Iterate through internal items. This method takes the same arguments that
	   * `Array.prototype.forEach` takes.
	   *
	   * NOTE: The order of the mappings is NOT guaranteed.
	   */
	  MappingList.prototype.unsortedForEach =
	    function MappingList_forEach(aCallback, aThisArg) {
	      this._array.forEach(aCallback, aThisArg);
	    };
	
	  /**
	   * Add the given source mapping.
	   *
	   * @param Object aMapping
	   */
	  MappingList.prototype.add = function MappingList_add(aMapping) {
	    if (generatedPositionAfter(this._last, aMapping)) {
	      this._last = aMapping;
	      this._array.push(aMapping);
	    } else {
	      this._sorted = false;
	      this._array.push(aMapping);
	    }
	  };
	
	  /**
	   * Returns the flat, sorted array of mappings. The mappings are sorted by
	   * generated position.
	   *
	   * WARNING: This method returns internal data without copying, for
	   * performance. The return value must NOT be mutated, and should be treated as
	   * an immutable borrow. If you want to take ownership, you must make your own
	   * copy.
	   */
	  MappingList.prototype.toArray = function MappingList_toArray() {
	    if (!this._sorted) {
	      this._array.sort(util.compareByGeneratedPositionsInflated);
	      this._sorted = true;
	    }
	    return this._array;
	  };
	
	  exports.MappingList = MappingList;
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	  var binarySearch = __webpack_require__(24);
	  var ArraySet = __webpack_require__(21).ArraySet;
	  var base64VLQ = __webpack_require__(18);
	  var quickSort = __webpack_require__(25).quickSort;
	
	  function SourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    return sourceMap.sections != null
	      ? new IndexedSourceMapConsumer(sourceMap)
	      : new BasicSourceMapConsumer(sourceMap);
	  }
	
	  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	  }
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;
	
	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.
	
	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    get: function () {
	      if (!this.__generatedMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__generatedMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    get: function () {
	      if (!this.__originalMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__originalMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype._charIsMappingSeparator =
	    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	      var c = aStr.charAt(index);
	      return c === ";" || c === ",";
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      throw new Error("Subclasses must implement _parseMappings");
	    };
	
	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping =
	    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	      var context = aContext || null;
	      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	      var mappings;
	      switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	      }
	
	      var sourceRoot = this.sourceRoot;
	      mappings.map(function (mapping) {
	        var source = mapping.source === null ? null : this._sources.at(mapping.source);
	        if (source != null && sourceRoot != null) {
	          source = util.join(sourceRoot, source);
	        }
	        return {
	          source: source,
	          generatedLine: mapping.generatedLine,
	          generatedColumn: mapping.generatedColumn,
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: mapping.name === null ? null : this._names.at(mapping.name)
	        };
	      }, this).forEach(aCallback, context);
	    };
	
	  /**
	   * Returns all generated line and column information for the original source,
	   * line, and column provided. If no column is provided, returns all mappings
	   * corresponding to a either the line we are searching for or the next
	   * closest line that has any mappings. Otherwise, returns all mappings
	   * corresponding to the given line and either the column we are searching for
	   * or the next closest column that has any offsets.
	   *
	   * The only argument is an object with the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: Optional. the column number in the original source.
	   *
	   * and an array of objects is returned, each with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  SourceMapConsumer.prototype.allGeneratedPositionsFor =
	    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	      var line = util.getArg(aArgs, 'line');
	
	      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	      // returns the index of the closest mapping less than the needle. By
	      // setting needle.originalColumn to 0, we thus find the last mapping for
	      // the given line, provided such a mapping exists.
	      var needle = {
	        source: util.getArg(aArgs, 'source'),
	        originalLine: line,
	        originalColumn: util.getArg(aArgs, 'column', 0)
	      };
	
	      if (this.sourceRoot != null) {
	        needle.source = util.relative(this.sourceRoot, needle.source);
	      }
	      if (!this._sources.has(needle.source)) {
	        return [];
	      }
	      needle.source = this._sources.indexOf(needle.source);
	
	      var mappings = [];
	
	      var index = this._findMapping(needle,
	                                    this._originalMappings,
	                                    "originalLine",
	                                    "originalColumn",
	                                    util.compareByOriginalPositions,
	                                    binarySearch.LEAST_UPPER_BOUND);
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (aArgs.column === undefined) {
	          var originalLine = mapping.originalLine;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we found. Since
	          // mappings are sorted, this is guaranteed to find all mappings for
	          // the line we found.
	          while (mapping && mapping.originalLine === originalLine) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        } else {
	          var originalColumn = mapping.originalColumn;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we were searching for.
	          // Since mappings are sorted, this is guaranteed to find all mappings for
	          // the line we are searching for.
	          while (mapping &&
	                 mapping.originalLine === line &&
	                 mapping.originalColumn == originalColumn) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        }
	      }
	
	      return mappings;
	    };
	
	  exports.SourceMapConsumer = SourceMapConsumer;
	
	  /**
	   * A BasicSourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The only parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: Optional. The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function BasicSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);
	
	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    sources = sources
	      // Some source maps produce relative source paths like "./foo.js" instead of
	      // "foo.js".  Normalize these first so that future comparisons will succeed.
	      // See bugzil.la/1090768.
	      .map(util.normalize)
	      // Always ensure that absolute sources are internally stored relative to
	      // the source root, if the source root is absolute. Not doing this would
	      // be particularly problematic when the source root is a prefix of the
	      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	      .map(function (source) {
	        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	          ? util.relative(sourceRoot, source)
	          : source;
	      });
	
	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names, true);
	    this._sources = ArraySet.fromArray(sources, true);
	
	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this.file = file;
	  }
	
	  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	  /**
	   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @returns BasicSourceMapConsumer
	   */
	  BasicSourceMapConsumer.fromSourceMap =
	    function SourceMapConsumer_fromSourceMap(aSourceMap) {
	      var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	      smc.sourceRoot = aSourceMap._sourceRoot;
	      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                              smc.sourceRoot);
	      smc.file = aSourceMap._file;
	
	      // Because we are modifying the entries (by converting string sources and
	      // names to indices into the sources and names ArraySets), we have to make
	      // a copy of the entry or else bad things happen. Shared mutable state
	      // strikes again! See github issue #191.
	
	      var generatedMappings = aSourceMap._mappings.toArray().slice();
	      var destGeneratedMappings = smc.__generatedMappings = [];
	      var destOriginalMappings = smc.__originalMappings = [];
	
	      for (var i = 0, length = generatedMappings.length; i < length; i++) {
	        var srcMapping = generatedMappings[i];
	        var destMapping = new Mapping;
	        destMapping.generatedLine = srcMapping.generatedLine;
	        destMapping.generatedColumn = srcMapping.generatedColumn;
	
	        if (srcMapping.source) {
	          destMapping.source = sources.indexOf(srcMapping.source);
	          destMapping.originalLine = srcMapping.originalLine;
	          destMapping.originalColumn = srcMapping.originalColumn;
	
	          if (srcMapping.name) {
	            destMapping.name = names.indexOf(srcMapping.name);
	          }
	
	          destOriginalMappings.push(destMapping);
	        }
	
	        destGeneratedMappings.push(destMapping);
	      }
	
	      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	      return smc;
	    };
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  BasicSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._sources.toArray().map(function (s) {
	        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	      }, this);
	    }
	  });
	
	  /**
	   * Provide the JIT with a nice shape / hidden class.
	   */
	  function Mapping() {
	    this.generatedLine = 0;
	    this.generatedColumn = 0;
	    this.source = null;
	    this.originalLine = null;
	    this.originalColumn = null;
	    this.name = null;
	  }
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  BasicSourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      var generatedLine = 1;
	      var previousGeneratedColumn = 0;
	      var previousOriginalLine = 0;
	      var previousOriginalColumn = 0;
	      var previousSource = 0;
	      var previousName = 0;
	      var length = aStr.length;
	      var index = 0;
	      var cachedSegments = {};
	      var temp = {};
	      var originalMappings = [];
	      var generatedMappings = [];
	      var mapping, str, segment, end, value;
	
	      while (index < length) {
	        if (aStr.charAt(index) === ';') {
	          generatedLine++;
	          index++;
	          previousGeneratedColumn = 0;
	        }
	        else if (aStr.charAt(index) === ',') {
	          index++;
	        }
	        else {
	          mapping = new Mapping();
	          mapping.generatedLine = generatedLine;
	
	          // Because each offset is encoded relative to the previous one,
	          // many segments often have the same encoding. We can exploit this
	          // fact by caching the parsed variable length fields of each segment,
	          // allowing us to avoid a second parse if we encounter the same
	          // segment again.
	          for (end = index; end < length; end++) {
	            if (this._charIsMappingSeparator(aStr, end)) {
	              break;
	            }
	          }
	          str = aStr.slice(index, end);
	
	          segment = cachedSegments[str];
	          if (segment) {
	            index += str.length;
	          } else {
	            segment = [];
	            while (index < end) {
	              base64VLQ.decode(aStr, index, temp);
	              value = temp.value;
	              index = temp.rest;
	              segment.push(value);
	            }
	
	            if (segment.length === 2) {
	              throw new Error('Found a source, but no line and column');
	            }
	
	            if (segment.length === 3) {
	              throw new Error('Found a source and line, but no column');
	            }
	
	            cachedSegments[str] = segment;
	          }
	
	          // Generated column.
	          mapping.generatedColumn = previousGeneratedColumn + segment[0];
	          previousGeneratedColumn = mapping.generatedColumn;
	
	          if (segment.length > 1) {
	            // Original source.
	            mapping.source = previousSource + segment[1];
	            previousSource += segment[1];
	
	            // Original line.
	            mapping.originalLine = previousOriginalLine + segment[2];
	            previousOriginalLine = mapping.originalLine;
	            // Lines are stored 0-based
	            mapping.originalLine += 1;
	
	            // Original column.
	            mapping.originalColumn = previousOriginalColumn + segment[3];
	            previousOriginalColumn = mapping.originalColumn;
	
	            if (segment.length > 4) {
	              // Original name.
	              mapping.name = previousName + segment[4];
	              previousName += segment[4];
	            }
	          }
	
	          generatedMappings.push(mapping);
	          if (typeof mapping.originalLine === 'number') {
	            originalMappings.push(mapping);
	          }
	        }
	      }
	
	      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	      this.__generatedMappings = generatedMappings;
	
	      quickSort(originalMappings, util.compareByOriginalPositions);
	      this.__originalMappings = originalMappings;
	    };
	
	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  BasicSourceMapConsumer.prototype._findMapping =
	    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                           aColumnName, aComparator, aBias) {
	      // To return the position we are searching for, we must first find the
	      // mapping for the given position and then return the opposite position it
	      // points to. Because the mappings are sorted, we can use binary search to
	      // find the best mapping.
	
	      if (aNeedle[aLineName] <= 0) {
	        throw new TypeError('Line must be greater than or equal to 1, got '
	                            + aNeedle[aLineName]);
	      }
	      if (aNeedle[aColumnName] < 0) {
	        throw new TypeError('Column must be greater than or equal to 0, got '
	                            + aNeedle[aColumnName]);
	      }
	
	      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	    };
	
	  /**
	   * Compute the last column for each generated mapping. The last column is
	   * inclusive.
	   */
	  BasicSourceMapConsumer.prototype.computeColumnSpans =
	    function SourceMapConsumer_computeColumnSpans() {
	      for (var index = 0; index < this._generatedMappings.length; ++index) {
	        var mapping = this._generatedMappings[index];
	
	        // Mappings do not contain a field for the last generated columnt. We
	        // can come up with an optimistic estimate, however, by assuming that
	        // mappings are contiguous (i.e. given two consecutive mappings, the
	        // first mapping ends where the second one starts).
	        if (index + 1 < this._generatedMappings.length) {
	          var nextMapping = this._generatedMappings[index + 1];
	
	          if (mapping.generatedLine === nextMapping.generatedLine) {
	            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	            continue;
	          }
	        }
	
	        // The last mapping for each line spans the entire line.
	        mapping.lastGeneratedColumn = Infinity;
	      }
	    };
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  BasicSourceMapConsumer.prototype.originalPositionFor =
	    function SourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._generatedMappings,
	        "generatedLine",
	        "generatedColumn",
	        util.compareByGeneratedPositionsDeflated,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._generatedMappings[index];
	
	        if (mapping.generatedLine === needle.generatedLine) {
	          var source = util.getArg(mapping, 'source', null);
	          if (source !== null) {
	            source = this._sources.at(source);
	            if (this.sourceRoot != null) {
	              source = util.join(this.sourceRoot, source);
	            }
	          }
	          var name = util.getArg(mapping, 'name', null);
	          if (name !== null) {
	            name = this._names.at(name);
	          }
	          return {
	            source: source,
	            line: util.getArg(mapping, 'originalLine', null),
	            column: util.getArg(mapping, 'originalColumn', null),
	            name: name
	          };
	        }
	      }
	
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function BasicSourceMapConsumer_hasContentsOfAllSources() {
	      if (!this.sourcesContent) {
	        return false;
	      }
	      return this.sourcesContent.length >= this._sources.size() &&
	        !this.sourcesContent.some(function (sc) { return sc == null; });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  BasicSourceMapConsumer.prototype.sourceContentFor =
	    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      if (!this.sourcesContent) {
	        return null;
	      }
	
	      if (this.sourceRoot != null) {
	        aSource = util.relative(this.sourceRoot, aSource);
	      }
	
	      if (this._sources.has(aSource)) {
	        return this.sourcesContent[this._sources.indexOf(aSource)];
	      }
	
	      var url;
	      if (this.sourceRoot != null
	          && (url = util.urlParse(this.sourceRoot))) {
	        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	        // many users. We can help them out when they expect file:// URIs to
	        // behave like it would if they were running a local HTTP server. See
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	        if (url.scheme == "file"
	            && this._sources.has(fileUriAbsPath)) {
	          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	        }
	
	        if ((!url.path || url.path == "/")
	            && this._sources.has("/" + aSource)) {
	          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	        }
	      }
	
	      // This function is used recursively from
	      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	      // don't want to throw if we can't find the source - we just want to
	      // return null, so we provide a flag to exit gracefully.
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  BasicSourceMapConsumer.prototype.generatedPositionFor =
	    function SourceMapConsumer_generatedPositionFor(aArgs) {
	      var source = util.getArg(aArgs, 'source');
	      if (this.sourceRoot != null) {
	        source = util.relative(this.sourceRoot, source);
	      }
	      if (!this._sources.has(source)) {
	        return {
	          line: null,
	          column: null,
	          lastColumn: null
	        };
	      }
	      source = this._sources.indexOf(source);
	
	      var needle = {
	        source: source,
	        originalLine: util.getArg(aArgs, 'line'),
	        originalColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._originalMappings,
	        "originalLine",
	        "originalColumn",
	        util.compareByOriginalPositions,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (mapping.source === needle.source) {
	          return {
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          };
	        }
	      }
	
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    };
	
	  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	  /**
	   * An IndexedSourceMapConsumer instance represents a parsed source map which
	   * we can query for information. It differs from BasicSourceMapConsumer in
	   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	   * input.
	   *
	   * The only parameter is a raw source map (either as a JSON string, or already
	   * parsed to an object). According to the spec for indexed source maps, they
	   * have the following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - file: Optional. The generated file this source map is associated with.
	   *   - sections: A list of section definitions.
	   *
	   * Each value under the "sections" field has two fields:
	   *   - offset: The offset into the original specified at which this section
	   *       begins to apply, defined as an object with a "line" and "column"
	   *       field.
	   *   - map: A source map definition. This source map could also be indexed,
	   *       but doesn't have to be.
	   *
	   * Instead of the "map" field, it's also possible to have a "url" field
	   * specifying a URL to retrieve a source map from, but that's currently
	   * unsupported.
	   *
	   * Here's an example source map, taken from the source map spec[0], but
	   * modified to omit a section which uses the "url" field.
	   *
	   *  {
	   *    version : 3,
	   *    file: "app.js",
	   *    sections: [{
	   *      offset: {line:100, column:10},
	   *      map: {
	   *        version : 3,
	   *        file: "section.js",
	   *        sources: ["foo.js", "bar.js"],
	   *        names: ["src", "maps", "are", "fun"],
	   *        mappings: "AAAA,E;;ABCDE;"
	   *      }
	   *    }],
	   *  }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	   */
	  function IndexedSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sections = util.getArg(sourceMap, 'sections');
	
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	
	    var lastOffset = {
	      line: -1,
	      column: 0
	    };
	    this._sections = sections.map(function (s) {
	      if (s.url) {
	        // The url field will require support for asynchronicity.
	        // See https://github.com/mozilla/source-map/issues/16
	        throw new Error('Support for url field in sections not implemented.');
	      }
	      var offset = util.getArg(s, 'offset');
	      var offsetLine = util.getArg(offset, 'line');
	      var offsetColumn = util.getArg(offset, 'column');
	
	      if (offsetLine < lastOffset.line ||
	          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	        throw new Error('Section offsets must be ordered and non-overlapping.');
	      }
	      lastOffset = offset;
	
	      return {
	        generatedOffset: {
	          // The offset fields are 0-based, but we use 1-based indices when
	          // encoding/decoding from VLQ.
	          generatedLine: offsetLine + 1,
	          generatedColumn: offsetColumn + 1
	        },
	        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	      }
	    });
	  }
	
	  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  IndexedSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      var sources = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	          sources.push(this._sections[i].consumer.sources[j]);
	        }
	      }
	      return sources;
	    }
	  });
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  IndexedSourceMapConsumer.prototype.originalPositionFor =
	    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      // Find the section containing the generated position we're trying to map
	      // to an original position.
	      var sectionIndex = binarySearch.search(needle, this._sections,
	        function(needle, section) {
	          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	          if (cmp) {
	            return cmp;
	          }
	
	          return (needle.generatedColumn -
	                  section.generatedOffset.generatedColumn);
	        });
	      var section = this._sections[sectionIndex];
	
	      if (!section) {
	        return {
	          source: null,
	          line: null,
	          column: null,
	          name: null
	        };
	      }
	
	      return section.consumer.originalPositionFor({
	        line: needle.generatedLine -
	          (section.generatedOffset.generatedLine - 1),
	        column: needle.generatedColumn -
	          (section.generatedOffset.generatedLine === needle.generatedLine
	           ? section.generatedOffset.generatedColumn - 1
	           : 0),
	        bias: aArgs.bias
	      });
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	      return this._sections.every(function (s) {
	        return s.consumer.hasContentsOfAllSources();
	      });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  IndexedSourceMapConsumer.prototype.sourceContentFor =
	    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        var content = section.consumer.sourceContentFor(aSource, true);
	        if (content) {
	          return content;
	        }
	      }
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  IndexedSourceMapConsumer.prototype.generatedPositionFor =
	    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        // Only consider this section if the requested source is in the list of
	        // sources of the consumer.
	        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	          continue;
	        }
	        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	        if (generatedPosition) {
	          var ret = {
	            line: generatedPosition.line +
	              (section.generatedOffset.generatedLine - 1),
	            column: generatedPosition.column +
	              (section.generatedOffset.generatedLine === generatedPosition.line
	               ? section.generatedOffset.generatedColumn - 1
	               : 0)
	          };
	          return ret;
	        }
	      }
	
	      return {
	        line: null,
	        column: null
	      };
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  IndexedSourceMapConsumer.prototype._parseMappings =
	    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      this.__generatedMappings = [];
	      this.__originalMappings = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	        var sectionMappings = section.consumer._generatedMappings;
	        for (var j = 0; j < sectionMappings.length; j++) {
	          var mapping = sectionMappings[j];
	
	          var source = section.consumer._sources.at(mapping.source);
	          if (section.consumer.sourceRoot !== null) {
	            source = util.join(section.consumer.sourceRoot, source);
	          }
	          this._sources.add(source);
	          source = this._sources.indexOf(source);
	
	          var name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	
	          // The mappings coming from the consumer for the section have
	          // generated positions relative to the start of the section, so we
	          // need to offset them to be relative to the start of the concatenated
	          // generated file.
	          var adjustedMapping = {
	            source: source,
	            generatedLine: mapping.generatedLine +
	              (section.generatedOffset.generatedLine - 1),
	            generatedColumn: mapping.generatedColumn +
	              (section.generatedOffset.generatedLine === mapping.generatedLine
	              ? section.generatedOffset.generatedColumn - 1
	              : 0),
	            originalLine: mapping.originalLine,
	            originalColumn: mapping.originalColumn,
	            name: name
	          };
	
	          this.__generatedMappings.push(adjustedMapping);
	          if (typeof adjustedMapping.originalLine === 'number') {
	            this.__originalMappings.push(adjustedMapping);
	          }
	        }
	      }
	
	      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	      quickSort(this.__originalMappings, util.compareByOriginalPositions);
	    };
	
	  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	}


/***/ },
/* 24 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  exports.GREATEST_LOWER_BOUND = 1;
	  exports.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Recursive implementation of binary search.
	   *
	   * @param aLow Indices here and lower do not contain the needle.
	   * @param aHigh Indices here and higher do not contain the needle.
	   * @param aNeedle The element being searched for.
	   * @param aHaystack The non-empty array being searched.
	   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   */
	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	    // This function terminates when one of the following is true:
	    //
	    //   1. We find the exact element we are looking for.
	    //
	    //   2. We did not find the exact element, but we can return the index of
	    //      the next-closest element.
	    //
	    //   3. We did not find the exact element, and there is no next-closest
	    //      element than the one we are searching for, so we return -1.
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);
	    if (cmp === 0) {
	      // Found the element we are looking for.
	      return mid;
	    }
	    else if (cmp > 0) {
	      // Our needle is greater than aHaystack[mid].
	      if (aHigh - mid > 1) {
	        // The element is in the upper half.
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // The exact needle element was not found in this haystack. Determine if
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return aHigh < aHaystack.length ? aHigh : -1;
	      } else {
	        return mid;
	      }
	    }
	    else {
	      // Our needle is less than aHaystack[mid].
	      if (mid - aLow > 1) {
	        // The element is in the lower half.
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return mid;
	      } else {
	        return aLow < 0 ? -1 : aLow;
	      }
	    }
	  }
	
	  /**
	   * This is an implementation of binary search which will always try and return
	   * the index of the closest element if there is no exact hit. This is because
	   * mappings between original and generated line/col pairs are single points,
	   * and there is an implicit region between each of them, so a miss just means
	   * that you aren't on the very start of a region.
	   *
	   * @param aNeedle The element you are looking for.
	   * @param aHaystack The array that is being searched.
	   * @param aCompare A function which takes the needle and an element in the
	   *     array and returns -1, 0, or 1 depending on whether the needle is less
	   *     than, equal to, or greater than the element, respectively.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	   */
	  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	    if (aHaystack.length === 0) {
	      return -1;
	    }
	
	    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	    if (index < 0) {
	      return -1;
	    }
	
	    // We have found either the exact element, or the next-closest element than
	    // the one we are searching for. However, there may be more than one such
	    // element. Make sure we always return the smallest of these.
	    while (index - 1 >= 0) {
	      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	        break;
	      }
	      --index;
	    }
	
	    return index;
	  };
	}


/***/ },
/* 25 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  // It turns out that some (most?) JavaScript engines don't self-host
	  // `Array.prototype.sort`. This makes sense because C++ will likely remain
	  // faster than JS when doing raw CPU-intensive sorting. However, when using a
	  // custom comparator function, calling back and forth between the VM's C++ and
	  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
	  // worse generated code for the comparator function than would be optimal. In
	  // fact, when sorting with a comparator, these costs outweigh the benefits of
	  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	  // a ~3500ms mean speed-up in `bench/bench.html`.
	
	  /**
	   * Swap the elements indexed by `x` and `y` in the array `ary`.
	   *
	   * @param {Array} ary
	   *        The array.
	   * @param {Number} x
	   *        The index of the first item.
	   * @param {Number} y
	   *        The index of the second item.
	   */
	  function swap(ary, x, y) {
	    var temp = ary[x];
	    ary[x] = ary[y];
	    ary[y] = temp;
	  }
	
	  /**
	   * Returns a random integer within the range `low .. high` inclusive.
	   *
	   * @param {Number} low
	   *        The lower bound on the range.
	   * @param {Number} high
	   *        The upper bound on the range.
	   */
	  function randomIntInRange(low, high) {
	    return Math.round(low + (Math.random() * (high - low)));
	  }
	
	  /**
	   * The Quick Sort algorithm.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   * @param {Number} p
	   *        Start index of the array
	   * @param {Number} r
	   *        End index of the array
	   */
	  function doQuickSort(ary, comparator, p, r) {
	    // If our lower bound is less than our upper bound, we (1) partition the
	    // array into two pieces and (2) recurse on each half. If it is not, this is
	    // the empty array and our base case.
	
	    if (p < r) {
	      // (1) Partitioning.
	      //
	      // The partitioning chooses a pivot between `p` and `r` and moves all
	      // elements that are less than or equal to the pivot to the before it, and
	      // all the elements that are greater than it after it. The effect is that
	      // once partition is done, the pivot is in the exact place it will be when
	      // the array is put in sorted order, and it will not need to be moved
	      // again. This runs in O(n) time.
	
	      // Always choose a random pivot so that an input array which is reverse
	      // sorted does not cause O(n^2) running time.
	      var pivotIndex = randomIntInRange(p, r);
	      var i = p - 1;
	
	      swap(ary, pivotIndex, r);
	      var pivot = ary[r];
	
	      // Immediately after `j` is incremented in this loop, the following hold
	      // true:
	      //
	      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	      //
	      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	      for (var j = p; j < r; j++) {
	        if (comparator(ary[j], pivot) <= 0) {
	          i += 1;
	          swap(ary, i, j);
	        }
	      }
	
	      swap(ary, i + 1, j);
	      var q = i + 1;
	
	      // (2) Recurse on each half.
	
	      doQuickSort(ary, comparator, p, q - 1);
	      doQuickSort(ary, comparator, q + 1, r);
	    }
	  }
	
	  /**
	   * Sort the given array in-place with the given comparator function.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   */
	  exports.quickSort = function (ary, comparator) {
	    doQuickSort(ary, comparator, 0, ary.length - 1);
	  };
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var SourceMapGenerator = __webpack_require__(17).SourceMapGenerator;
	  var util = __webpack_require__(20);
	
	  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	  // operating systems these days (capturing the result).
	  var REGEX_NEWLINE = /(\r?\n)/;
	
	  // Newline character code for charCodeAt() comparisons
	  var NEWLINE_CODE = 10;
	
	  // Private symbol for identifying `SourceNode`s when multiple versions of
	  // the source-map library are loaded. This MUST NOT CHANGE across
	  // versions!
	  var isSourceNode = "$$$isSourceNode$$$";
	
	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine == null ? null : aLine;
	    this.column = aColumn == null ? null : aColumn;
	    this.source = aSource == null ? null : aSource;
	    this.name = aName == null ? null : aName;
	    this[isSourceNode] = true;
	    if (aChunks != null) this.add(aChunks);
	  }
	
	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   * @param aRelativePath Optional. The path that relative sources in the
	   *        SourceMapConsumer should be relative to.
	   */
	  SourceNode.fromStringWithSourceMap =
	    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	      // The SourceNode we want to fill with the generated code
	      // and the SourceMap
	      var node = new SourceNode();
	
	      // All even indices of this array are one line of the generated code,
	      // while all odd indices are the newlines between two adjacent lines
	      // (since `REGEX_NEWLINE` captures its match).
	      // Processed fragments are removed from this array, by calling `shiftNextLine`.
	      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	      var shiftNextLine = function() {
	        var lineContents = remainingLines.shift();
	        // The last line of a file might not have a newline.
	        var newLine = remainingLines.shift() || "";
	        return lineContents + newLine;
	      };
	
	      // We need to remember the position of "remainingLines"
	      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	      // The generate SourceNodes we need a code range.
	      // To extract it current and last mapping is used.
	      // Here we store the last mapping.
	      var lastMapping = null;
	
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        if (lastMapping !== null) {
	          // We add the code from "lastMapping" to "mapping":
	          // First check if there is a new line in between.
	          if (lastGeneratedLine < mapping.generatedLine) {
	            // Associate first line with "lastMapping"
	            addMappingWithCode(lastMapping, shiftNextLine());
	            lastGeneratedLine++;
	            lastGeneratedColumn = 0;
	            // The remaining code is added without mapping
	          } else {
	            // There is no new line in between.
	            // Associate the code between "lastGeneratedColumn" and
	            // "mapping.generatedColumn" with "lastMapping"
	            var nextLine = remainingLines[0];
	            var code = nextLine.substr(0, mapping.generatedColumn -
	                                          lastGeneratedColumn);
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                                lastGeneratedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	            addMappingWithCode(lastMapping, code);
	            // No more remaining code, continue
	            lastMapping = mapping;
	            return;
	          }
	        }
	        // We add the generated code until the first mapping
	        // to the SourceNode without any mapping.
	        // Each line is added as separate string.
	        while (lastGeneratedLine < mapping.generatedLine) {
	          node.add(shiftNextLine());
	          lastGeneratedLine++;
	        }
	        if (lastGeneratedColumn < mapping.generatedColumn) {
	          var nextLine = remainingLines[0];
	          node.add(nextLine.substr(0, mapping.generatedColumn));
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	        }
	        lastMapping = mapping;
	      }, this);
	      // We have processed all mappings.
	      if (remainingLines.length > 0) {
	        if (lastMapping) {
	          // Associate the remaining code in the current line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	        }
	        // and add the remaining lines without any mapping
	        node.add(remainingLines.join(""));
	      }
	
	      // Copy sourcesContent into SourceNode
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aRelativePath != null) {
	            sourceFile = util.join(aRelativePath, sourceFile);
	          }
	          node.setSourceContent(sourceFile, content);
	        }
	      });
	
	      return node;
	
	      function addMappingWithCode(mapping, code) {
	        if (mapping === null || mapping.source === undefined) {
	          node.add(code);
	        } else {
	          var source = aRelativePath
	            ? util.join(aRelativePath, mapping.source)
	            : mapping.source;
	          node.add(new SourceNode(mapping.originalLine,
	                                  mapping.originalColumn,
	                                  source,
	                                  code,
	                                  mapping.name));
	        }
	      }
	    };
	
	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length-1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk[isSourceNode]) {
	        chunk.walk(aFn);
	      }
	      else {
	        if (chunk !== '') {
	          aFn(chunk, { source: this.source,
	                       line: this.line,
	                       column: this.column,
	                       name: this.name });
	        }
	      }
	    }
	  };
	
	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len-1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };
	
	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild[isSourceNode]) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    }
	    else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    }
	    else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };
	
	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent =
	    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	    };
	
	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents =
	    function SourceNode_walkSourceContents(aFn) {
	      for (var i = 0, len = this.children.length; i < len; i++) {
	        if (this.children[i][isSourceNode]) {
	          this.children[i].walkSourceContents(aFn);
	        }
	      }
	
	      var sources = Object.keys(this.sourceContents);
	      for (var i = 0, len = sources.length; i < len; i++) {
	        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	      }
	    };
	
	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };
	
	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null
	          && original.line !== null
	          && original.column !== null) {
	        if(lastOriginalSource !== original.source
	           || lastOriginalLine !== original.line
	           || lastOriginalColumn !== original.column
	           || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      for (var idx = 0, length = chunk.length; idx < length; idx++) {
	        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	          generated.line++;
	          generated.column = 0;
	          // Mappings end at eol
	          if (idx + 1 === length) {
	            lastOriginalSource = null;
	            sourceMappingActive = false;
	          } else if (sourceMappingActive) {
	            map.addMapping({
	              source: original.source,
	              original: {
	                line: original.line,
	                column: original.column
	              },
	              generated: {
	                line: generated.line,
	                column: generated.column
	              },
	              name: original.name
	            });
	          }
	        } else {
	          generated.column++;
	        }
	      }
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });
	
	    return { code: generated.code, map: map };
	  };
	
	  exports.SourceNode = SourceNode;
	}


/***/ },
/* 27 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		
		function Region(a,b,root,view){
			this._a = a;
			this._b = b;
			this._root = root;
			this._view = view;
			return this;
		};
		
		exports.Region = Region; // export class 
		
		
		Region.prototype.a = function(v){ return this._a; }
		Region.prototype.setA = function(v){ this._a = v; return this; };
		
		
		Region.prototype.b = function(v){ return this._b; }
		Region.prototype.setB = function(v){ this._b = v; return this; };
		
		
		Region.prototype.view = function(v){ return this._view; }
		Region.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Region.prototype.root = function(v){ return this._root; }
		Region.prototype.setRoot = function(v){ this._root = v; return this; };
		
		// remove root from region
		
		Region.normalize = function (val,view){
			var line_;
			if (val instanceof Region) { return val };
			if (val instanceof Array) { return new Region(val[0],val[1],null,view) };
			if ((typeof val=='number'||val instanceof Number)) { return new Region(val,val,null,view) };
			
			if ((val instanceof Object) && (typeof (line_ = val.line)=='number'||line_ instanceof Number)) {
				var lines = view._buffer.lines();
				var loc = 0;
				for (var i = 0, ary = iter$(lines), len = ary.length; i < len; i++) {
					if (i < (val.line - 1)) {
						loc += ary[i].length + 1;
					} else {
						break;
					};
				};
				
				loc += (val.column || 0);
				return new Region(loc,loc,null,view);
			};
		};
		
		
		Region.prototype.start = function (){
			return Math.min(this._a,this._b);
		};
		
		Region.prototype.end = function (){
			return Math.max(this._a,this._b);
		};
		
		Region.prototype.clone = function (ad,bd){
			if(ad === undefined) ad = 0;
			if(bd === undefined) bd = 0;
			return new Region(this._a + ad,this._b + bd,this._root,this._view);
		};
		
		Region.prototype.contains = function (rel){
			if (rel instanceof Region) {
				return this.start() <= rel.start() && this.end() >= rel.end();
			} else if ((typeof rel=='number'||rel instanceof Number)) {
				return this.start() <= rel && this.end() >= rel;
			};
		};
		
		Region.prototype.adjust = function (rel,add){
			if(add === undefined) add = true;
			if (rel.end() < this.start()) {
				add ? (this.move(rel.size())) : (this.move(-rel.size()));
			};
			return this;
		};
		
		Region.prototype.intersects = function (rel){
			// is this decent?
			rel = Region.normalize(rel);
			var a = Math.max(this.start(),rel.start());
			var b = Math.min(this.end(),rel.end());
			return b >= a;
		};
		
		Region.prototype.relativeTo = function (rel){
			// could use move instead
			return new Region(this._a - rel.start(),this._b - rel.start(),this._root,this._view);
		};
		
		Region.prototype.intersection = function (region){
			return this;
		};
		
		Region.prototype.equals = function (region){
			return this.start() == region.start() && this.end() == region.end();
		};
		
		Region.prototype.same = function (region){
			return region && region.a() == this.a() && region.b() == this.b();
		};
		
		Region.prototype.size = function (){
			return this.end() - this.start();
		};
		
		Region.prototype.move = function (num){
			if(num === undefined) num = 1;
			this._a += num;
			this._b += num;
			return this;
		};
		
		Region.prototype.collapsed = function (){
			return this.size() == 0;
		};
		
		Region.prototype.reverse = function (){
			var a = this._a,b = this._b;
			this._a = b;
			this._b = a;
			return this;
		};
		
		Region.prototype.reversed = function (){
			return this._a > this._b;
		};
		
		Region.prototype.normalize = function (){
			var a = this.start();
			var b = this.end();
			this._a = a;
			this._b = b;
			return this;
		};
		
		Region.prototype.collapse = function (forward){
			if(forward === undefined) forward = true;
			if (forward) {
				this._a = this._b = this.end();
				// @a = @b
			} else {
				this._b = this._a;
				this._a = this._b = this.start();
			};
			return this;
		};
		
		// expand to closest /n
		Region.prototype.expand = function (atStart,atEnd){
			if (this.b() < this.a()) {
				this._b += atStart;
				this._a += atEnd;
			} else {
				this._a += atStart;
				this._b += atEnd;
			};
			return this;
		};
		
		Region.prototype.text = function (){
			return this.view().substr(this);
		};
		
		Region.prototype.toString = function (){
			return ("[" + (this._a) + "," + (this._b) + "]");
		};
		
		Region.prototype.insert = function (node){
			return this;
		};
		
		Region.prototype.nodes = function (includeEnds){
			if(includeEnds === undefined) includeEnds = true;
			return this.view().nodesInRegion(this,includeEnds);
		};
		
		Region.prototype.prevNode = function (query){
			var nodes = this.nodes(false);
			var node = nodes.lft;
			if ((query instanceof Imba.Selector) || (typeof query=='string'||query instanceof String)) {
				var $1;while (node){
					if (node.matches(query)) { return node };
					node = ($1 = node) && $1.isLast  &&  $1.isLast() ? (node.parent()) : (null);
				};
				return null;
			};
			return node;
		};
		
		Region.prototype.nextNode = function (query){
			var nodes = this.nodes(false);
			var node = nodes.rgt;
			if ((query instanceof Imba.Selector) || (typeof query=='string'||query instanceof String)) {
				var $1;while (node){
					if (node.matches(query)) { return node };
					node = ($1 = node) && $1.isFirst  &&  $1.isFirst() ? (node.parent()) : (null);
				};
				return null;
			};
			return node;
		};
		
		Region.prototype.scope = function (query){
			var nodes = this.nodes(false);
			var node;
			if (nodes.lft) {
				node = nodes.lft.up(query);
			} else if (nodes.rgt) {
				node || (node = nodes.rgt.up(query));
			} else if (nodes[0]) {
				node || (node = nodes[0].node.closest(query));
			};
			return node;
		};
		
		Region.prototype.buffer = function (){
			return this._root.code();
		};
		
		Region.prototype.startAtLine = function (){
			this.normalize();
			var buffer = this.buffer();
			var a = this.start();
			
			if (buffer[a] == '\n' && this.size() == 0) {
				a--; // if we are at the end of a line
			};
			
			while (a >= 0 && buffer[a] != '\n'){
				a--;
			};
			this._a = a;
			return this;
		};
		
		Region.prototype.endAtLine = function (){
			this.normalize();
			var buffer = this.buffer();
			var b = (this.end() - 1);
			while (b >= 0 && buffer[b] && buffer[b] != '\n'){
				b++;
			};
			this._b = b;
			return this;
		};
		
		Region.prototype.cell = function (){
			return this.view()._buffer.locToCell(this.a());
		};
		
		Region.prototype.row = function (){
			return this.cell()[0];
		};
		
		Region.prototype.col = function (){
			return this.cell()[1];
		};
		
		Region.prototype.peekbehind = function (len){
			if(len === undefined) len = 1;
			return len == 1 ? (this.buffer()[this.start() - 1]) : (this.buffer().substring(this.start() - len,this.start()));
		};
		
		Region.prototype.peekahead = function (len){
			if(len === undefined) len = 1;
			return len == 1 ? (this.buffer()[this.end()]) : (this.buffer().substr(this.end(),len));
		};
		
		Region.prototype.indent = function (){
			return this.clone().startAtLine().text().match(/^\n?(\t*)/)[1];
		};
		
		Region.prototype.peek = function (before,after){
			if(before === undefined) before = 0;
			if(after === undefined) after = 0;
			return this.clone(before,after).text();
		};
		
		Region.prototype.lloc = function (){
			return {startLine: 0,startCol: 2};
		};
		
		Region.prototype.toJSON = function (){
			return [this.a(),this.b()];
		};
		return Region;
	
	})()

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		
		var KEYWORDS = 'var if elif else for while def in isa while until switch when then return class tag let do and or prop attr in prop'.split(' ');
		var OPS = '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ?'.split(' ');
		
		var WHITESPACE = /^[ \t\n]+$/;
		
		IM.HL = {
			newline: "<b class='_imnewline'>\n</b>",
			space: function(m) { return ("<b class='_imspace'>" + m + "</b>"); },
			tab: function(m) { return new Array(m.length + 1).join("<b class='_imtab'>\t</b>"); }
		};
		
		
		var Region = __webpack_require__(27).Region;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		var MATCHERS = {
			keyword: function(v) { return KEYWORDS.indexOf(v) >= 0; },
			self: /^(this|self)$/,
			const: function(v) { return (/^[A-Z][\w\_]*$/).test(v); },
			ivar: function(v) { return (/^@[\w\_]+$/).test(v); },
			bool: function(v) { return (/^(true|yes|false|no|null|undefined)$/).test(v); },
			identifier: /^[\$a-z_][\w\_\$]*(\-[\$\w\_]+)*$/,
			float: /^\d+\.\d+$/,
			int: /^\d+$/,
			comment: /^\#([ \t][^\n]*)?$/
		};
		
		var MODES = {
			all: Object.keys(MATCHERS)
		};
		
		
			
			String.prototype.repeat = function (num){
				return new Array(num + 1).join(this);
			};
			
			String.prototype.ins = function (str,region){
				var text = this.toString();
				if (region == 'append') {
					return text + str;
				} else if (region == 'prepend') {
					return "" + str + text;
				} else if (region instanceof Region) {
					return text.substr(0,region.start()) + str + text.slice(region.end());
				};
			};
		
		
		function isWhitespace(str){
			return WHITESPACE.test(str);
		}; exports.isWhitespace = isWhitespace;
		
		IM.num = function (val){
			return tag$.$imnum().flag('number').setText(val).end();
		};
		
		IM.tab = function (){
			return tag$.$imtab().setText('\t').end();
		};
		
		IM.newline = function (){
			return tag$.$imnewline().setText('\n').end();
		};
		
		IM.op = function (val){
			return tag$.$imop().flag('op').setText(val).end();
		};
		
		
		IM.tok = function (val){
			if (val && val._dom) { return val };
			if (val.match(WHITESPACE)) { return IM.parseWhitespace(val) };
			if (OPS.indexOf(val) >= 0) { return IM.op(val) }; // should use token directly
			// return IM.num(val) if val.match(/^\d+(\.\d+)?$/) # should use token directly
			return tag$.$imtok().setText(val).end();
		};
		
		IM.raw = function (val,ctx){
			return tag$.$imraw().setRaw(val).end();
		};
		
		IM.isWhitespace = function (val){
			return WHITESPACE.test(val);
		};
		
		IM.isOp = function (val){
			return OPS.indexOf(val) >= 0;
		};
		
		IM.parseWhitespace = function (text,rich){
			if(rich === undefined) rich = true;
			var hl = IM.HL;
			
			text = text.replace(/(\n|[ ]+|[\t]+)/g,function(m,l) {
				if (l == '\n') {
					return hl.newline || '\n';
				} else if (l[0] == ' ') {
					return hl.space instanceof Function ? (hl.space(l)) : (l);
				} else if (l[0] == '\t') {
					return hl.tab instanceof Function ? (hl.tab(l)) : (l);
				};
			});
			
			if (rich && text.indexOf('<') >= 0) {
				return tag$.$imfragment().setContent(text,0).end();
			};
			
			return text;
		};
		
		IM.identify = function (val,mode){
			if(mode === undefined) mode = 'all';
			var rules = MODES[mode];
			var res;
			for (var i = 0, ary = iter$(rules), len = ary.length, name; i < len; i++) {
				name = ary[i];
				var rule = MATCHERS[name];
				
				if (rule instanceof Function) {
					res = rule(val,mode);
				} else if (rule instanceof RegExp) {
					res = rule.test(val);
				};
				
				if (res) {
					return res === true ? (name) : (res);
				};
			};
			
			return null;
		};
		
		IM.parse = function (code,context){
			// decide if full?
			// console.log "parse code {code:length} {code.substr(0,20)}"
			if (typeof code != 'string') { return code };
			
			if (WHITESPACE.test(code)) {
				return IM.parseWhitespace(code,false);
			};
			
			var ws = code.match(/^([ \t]*)([^]*?)([ \t]*)$/) || ['','',code,''];
			var hl;
			
			if (ws[1] || ws[3]) {
				code = ws[2];
			};
			
			var id = IM.identify(code);
			
			if (id) {
				var typ = 'span';
				var cls = Highlighter.Mapping[id] || id; // this is the issue, no?
				
				if (cls instanceof Array) {
					typ = cls[0];
					cls = cls[1];
				};
				
				if (!cls.match(/\b_[\w]/)) { cls = '_imtok ' + cls };
				// console.log 'parsed as type',id,cls
				hl = '<' + typ + ' class="' + cls + '">' + code + '</' + typ + '>';
			};
			
			if (!hl) {
				hl = Highlighter.highlight(code);
			};
			
			if (ws) {
				hl = IM.parseWhitespace(ws[1],false) + hl + IM.parseWhitespace(ws[3],false);
			};
			if (hl) {
				return hl;
			} else {
				return code;
			};
		};
		
		
		return IM.textNodes = function (root,mark){
			// console.time('textNodes2')
			if(mark === undefined) mark = false;
			root = root._dom || root;
			var el;
			var nodes = [];
			var pos = 0;
			var walk = document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);
			
			while (el = walk.nextNode()){
				if (mark) {
					var len = el.length;
					el._loc = pos;
					pos += len;
				};
				nodes.push(el);
			};
			return nodes;
		};
	
	})()

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		// var imbac = global.Imbac
		var Lexer = __webpack_require__(30).Lexer;
		
		var util = __webpack_require__(34);
		
		var NODETYPE = 'b';
		var KEYWORDS = [
			'null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','isa','case','nil'
		];
		
		var classes = {
			'+': '_imop op add math',
			'++': '_imop op incr math',
			'--': '_imop op decr math',
			'-': '_imop op sub math',
			'=': '_imop op eq',
			'/': '_imop op div math',
			'*': '_imop op mult math',
			'?': '_imop op ternary',
			',': '_imop op comma',
			':': '_imop op colon',
			'.': '_imop op dot',
			'.:': '_imop op cdot',
			'!': '_imop op unary',
			'?.': '_imop op qdot',
			'[': '_imopen sb sbl',
			']': '_imclose sb sbr',
			'(': '_imopen rb rbl',
			')': '_imclose rb rbr',
			'{': '_imopen cb cbl',
			'}': '_imclose cb cbr',
			'#': '_imop op hash',
			'call_start': '_imopen call rb rbl',
			'call_end': '_imclose call rb rbr',
			'tag_start': '_imopen tag_open',
			'tag_end': '_imclose tag_close',
			
			'true': '_imbool true',
			'yes': '_imbool true',
			'false': '_imbool false',
			'no': '_imbool false',
			
			'{{': '_imopen',
			'}}': '_imclose',
			
			'"': 'doublequote',
			"'": 'singlequote',
			
			'regex': '_imregex regex',
			'identifier': '_imtok _imidentifier identifier',
			
			'compound_assign': 'op assign compound',
			'str': '_imstr string',
			'num': '_imnum number',
			'string': '_imstr string',
			'number': '_imnum number',
			'math': '_imop op math',
			'unary': '_imop op unary',
			'forin': 'keyword in',
			'forof': 'keyword of',
			'own': 'keyword own',
			'compare': '_imop op compare',
			'herecomment': '_herecomment',
			'relation': 'keyword relation',
			'export': 'keyword export',
			'global': 'keyword global',
			'extern': 'keyword global',
			'extend': 'keyword extend',
			'require': 'keyword require',
			'from': 'keyword from',
			'logic': 'keyword logic',
			'post_if': 'keyword if post_if',
			'post_for': 'keyword for post_for',
			'prop': 'keyword prop',
			'attr': 'keyword attr',
			
			'selector_start': '_imopen _imselopen selector_start',
			'selector_end': '_imclose _imselclose selector_end',
			'index_start': '_imopen index_start',
			'index_end': '_imclose index_end',
			'block_param_start': '_imopen',
			'block_param_end': '_imclose',
			
			'string_start': '_imstrstart string_start',
			'string_end': '_imstrend string_end',
			'neostring': '_imtok _imneostring'
		};
		
		var INTERPOLATING = '_imistring';
		
		var OPEN = {
			'tag_start': '_imtagnode tagnode',
			'call_start': '_imparens call',
			'selector_start': '_imsel selector',
			'string_start': '_imistring',
			'index_start': 'index',
			'block_param_start': '_impair _imblockparams',
			// 'indent': '_indent'
			'(': '_imparens paren',
			'{{': '_imiexpr',
			'{': '_imcurly curly',
			'[': '_imsquare square',
			'("': '_imistring'
		};
		
		
		
		var CLOSE = {
			'tag_end': 'tag',
			'call_end': '_imparens call',
			'string_end': '_imistring',
			'selector_end': 'sel',
			'index_end': 'index',
			'block_param_end': '_impair _imblockparams',
			'}}': '_imiexpr',
			')': 'paren',
			']': 'square',
			'}': 'curly',
			'")': 'string'
		};
		
		var OPS = '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ?'.split(' ');
		
		var hlo = {
			newline: "<b class='_imnewline'>\n</b>",
			space: function(m) { return ("<b class='_imspace'>" + m + "</b>"); },
			tab: function(m) { return new Array(m.length + 1).join("<b class='_imtab'>\t</b>"); }
		};
		
		function Stack(){
			this._stack = [];
			return this;
		};
		
		Stack.prototype.push = function (val){
			this._stack.push(val);
			this._current = val;
			return this;
		};
		
		Stack.prototype.pop = function (){
			var len = this._stack.pop();
			this._current = this._stack[len - 1];
			return this;
		};
		
		Stack.prototype.toString = function (){
			return this._current;
		};
		
		function Token(type,value,line,loc,len){
			this._type = type;
			this._value = value;
			this._meta = null;
			this._line = line || 0;
			this._col = -1;
			this._loc = loc || 0;
			this._len = len || 0;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.loc = function (){
			return this._loc;
		};
		
		Token.prototype.len = function (){
			return this._len;
		};
		
		
		
		function Highlighter(code,tokens,ast,o){
			var hl_;
			if(o === undefined) o = {};
			this._code = code;
			this._tokens = tokens;
			this._ast = ast;
			
			o.render || (o.render = {});
			o.hl || (o.hl = {});
			(hl_ = o.hl).newline || (hl_.newline = '<b class="_n">\n</b>');
			this._options = o;
			
			this._options.nextVarCounter || (this._options.nextVarCounter = 0);
			this._varRefs = {};
			
			if (o.mode == 'full' && !ast) {
				this._ast = Imbac.parse(this._tokens,{});
			};
			
			return this;
		};
		
		exports.Highlighter = Highlighter; // export class 
		Highlighter.Mapping = classes;
		
		Highlighter.logger = function (){
			return VIEW.logger();
		};
		
		Highlighter.tokenize = function (code,o){
			// console.log 'tokenize using local lexer'
			if(o === undefined) o = {};
			if (global.Imbac) {
				return Imbac.tokenize(code,o);
			};
			
			this._lexer || (this._lexer = new Lexer());
			this._lexer.reset();
			return this._lexer.tokenize(code,o);
		};
		
		Highlighter.reclassify = function (domnode,type,token,newCode,oldCode){
			
			type = type.toLowerCase();
			// console.log 'reclassify node as type',domnode,type,token
			var cls = IM.Types[type] || Imba.TAGS[("im" + type)] || IM.Types.token;
			
			var node = tag$wrap(domnode);
			
			if (node instanceof cls) {
				return node.reuse(token,newCode,oldCode);
			};
			
			if (cls) {
				node = new cls(domnode).setup(token,newCode,oldCode);
			};
			
			return node;
		};
		
		
		Highlighter.nestTokens = function (tokens,offset){
			var pairing = {
				'TAG_START': 'TAG_END',
				'SELECTOR_START': 'SELECTOR_END',
				'CALL_START': 'CALL_END',
				'INDEX_START': 'INDEX_END',
				'STRING_START': 'STRING_END',
				'BLOCK_PARAM_START': 'BLOCK_PARAM_END',
				'{{': '}}',
				'{': '}',
				'[': ']',
				'(': ')'
			};
			
			var naming = {
				'TAG_START': 'tagnode',
				'SELECTOR_START': 'selector',
				'STRING_START': 'istring',
				'CALL_START': 'parens',
				'INDEX_START': 'square',
				'BLOCK_PARAM_START': 'blockparams',
				'{{': 'iexpr',
				'{': 'curly',
				'[': 'square',
				'(': 'parens'
			};
			
			var idx = 0;
			
			var root = {
				_loc: 0,
				_offset: 0,
				_children: []
			};
			
			var stack = [root];
			var ends = [];
			var offset = 0;
			
			var loc,val,typ,ctx,tok;
			
			while (tok = tokens[idx++]){
				loc = tok._loc;
				val = tok._value;
				typ = tok._type;
				
				// normalizing because we dont rewrite tokens (should start with that)
				if (typ == 'IDENTIFIER' && (val == 'prop' || val == 'attr')) { typ = tok._type = 'KEYWORD' }; // not always
				if (typ == 'INDEX_START') { typ = tok._type = '[' };
				if (typ == 'INDEX_END') { typ = tok._type = ']' };
				if (typ == 'CALL_START') { typ = tok._type = '(' };
				if (typ == 'CALL_END') { typ = tok._type = ')' };
				
				ctx = stack[stack.length - 1];
				
				loc -= ctx._offset;
				// offset relative to context
				var closer = pairing[typ];
				
				if (closer) {
					var group = new Token(naming[typ],'',-1,loc);
					group._offset = ctx._offset + loc;
					offset += loc;
					group._children = [];
					ends.push(closer);
					stack.push(group);
					ctx._children.push(group);
					ctx = group;
				};
				
				tok._loc -= ctx._offset;
				
				// update length at all times
				if (tok._len >= 1) {
					ctx._children.push(tok);
					ctx._len = tok._loc + tok._len;
				};
				
				if (ends[ends.length - 1] == typ) {
					ends.pop();
					ctx._len = tok._loc + tok._len;
					stack.pop();
					// offset -= ctx.@offset
				};
			};
			
			// console.log 'children here',root.@children
			return root._children;
		};
		
		Highlighter.normalizeTokens = function (code,tokens,offset){
			if(offset === undefined) offset = 0;
			var idx = 0;
			var caret = 0;
			var new$ = [];
			var tok,next,typ,val;
			var loc = 0;
			
			var stack = new Stack();
			
			var ws = function() {
				var newtok = null;
				
				while (loc > caret){
					var chr = code[caret];
					if (chr == '\t') {
						newtok = new Token('tab',chr,-1,caret,1);
					} else if (chr == '\n') {
						newtok = new Token('newline',chr,-1,caret,1);
					} else if (chr == ';') {
						newtok = new Token('semicolon',chr,-1,caret,1);
					} else if (chr == ' ') {
						if (newtok && newtok._type == 'whitespace') {
							newtok._value += ' ';
							newtok._len += 1;
							caret++;
							continue;
						};
						newtok = new Token('whitespace',chr,-1,caret,1);
					} else if (chr == '#') {
						var startloc = caret;
						var comment = '';
						while (caret < loc && code[caret] != '\n'){
							comment += code[caret];
							caret++;
						};
						new$.push(new Token('comment',comment,-1,startloc,comment.length));
						continue;
					} else {
						newtok = null;
					};
					
					caret++;
					if (newtok) { new$.push(newtok) };
				};
				return;
			};
			
			var skip = ['TERMINATOR','INDENT','OUTDENT',' ',' \t'];
			
			while (tok = tokens[idx++]){
				next = tokens[idx];
				loc = tok._loc;
				val = tok._value;
				typ = tok._type;
				
				if (typ == '#' && next && next._type == 'IDENTIFIER') {
					next._type = 'IDREF';
				};
				
				if (typ == '(' && val == '("') {
					stack.push(val);
				};
				
				if (skip.indexOf(typ) >= 0) { continue; };
				
				if (loc > caret) { ws() };
				caret = tok._loc + tok._len;
				new$.push(tok);
			};
			
			// move to the end to possibly parse more whitespace
			loc = code.length;
			ws();
			// now nest the tokens
			new$ = this.nestTokens(new$);
			return new$;
		};
		
		Highlighter.whitespaceToTokens = function (str){
			var tok;
			var tokens = [];
			var caret = 0;
			var len = str.length;
			
			while (len > caret){
				var loc = caret;
				var chr = str[caret++];
				if (chr == '\t') {
					tokens.push(tok = new Token('tab',chr,-1,loc,1));
				} else if (chr == '\n') {
					tokens.push(tok = new Token('newline',chr,-1,loc,1));
				} else if (chr == ' ') {
					if (tok && tok._type == 'whitespace') {
						tok._value += ' ';
						tok._len += 1;
						continue;
					};
					tokens.push(tok = new Token('whitespace',chr,-1,loc,1));
				};
			};
			
			return tokens;
		};
		
		Highlighter.reparse = function (o){
			
			var $1;
			if (o instanceof Element) {
				var el = tag$wrap(o);
				if (el) { ($1 = el) && $1.mutated  &&  $1.mutated() };
				return;
			};
			
			var nodes = o.nodes;
			var code = o.code;
			var tokens = o.tokens;
			// should use a global logger-instance
			this.logger().groupCollapsed('reparse %s',JSON.stringify(code));
			
			if (util.isWhitespace(code) && !tokens) {
				console.log('using whitespaceToTokens');
				tokens = this.whitespaceToTokens(code);
			};
			// logger.log nodes.slice
			// big hack - adding a space at the end to close up selectors
			// should rather drop inline and let the parser pair up loose ends?
			if (!tokens) {
				tokens = this.tokenize(code + ' ',{inline: true,silent: true,rewrite: false});
				tokens = this.normalizeTokens(code,tokens);
				this.logger().log(tokens.slice());
			};
			
			this.logger().log(nodes.slice());
			this.applyTokens(code,tokens,nodes,o.nested,o.parent);
			this.logger().groupEnd();
			return;
		};
		
		Highlighter.applyTokens = function (code,tokens,nodes,nested,parent){
			// what about len and loc for inner nodes? Should this be set already?
			
			var self = this;
			var node;
			var prevNode;
			
			var addNode = function(nodes,index,after) {
				self.logger().log('addNode',index);
				var el = document.createElement(NODETYPE);
				
				if (after) {
					if (after.nextSibling) {
						after.parentNode.insertBefore(el,after.nextSibling);
					} else if (after.parentNode) {
						after.parentNode.appendChild(el);
					};
				} else if (parent) {
					parent.appendChild(el);
				};
				
				nodes.splice(index,0,el);
				return el;
			};
			
			var removeNode = function(nodes,index) {
				self.logger().log('removeNode',index);
				var el = nodes[index];
				if (el && el.parentNode) {
					el.parentNode.removeChild(el);
				};
				return nodes.splice(index,1);
			};
			
			// loop through to set the locations of the nodes
			var nloc = 0;
			for (var i = 0, ary = iter$(nodes), len = ary.length, node1; i < len; i++) {
				node1 = ary[i];
				node1._loc = nloc;
				nloc += (node1._len = node1.textContent.length);
			};
			
			for (var i = 0, ary = iter$(tokens), len = ary.length, tok; i < len; i++) {
				tok = ary[i];
				node = nodes[i];
				var tloc = tok._loc;
				nloc = node && node._loc;
				
				while (node && node._len == 0){
					self.logger().log('remove node because it is empty',node);
					removeNode(nodes,i);
					node = nodes[i];
				};
				
				if (!node) {
					// need to insert new node here - 
					node = addNode(nodes,i,prevNode);
				} else if (nloc > tloc) {
					node = addNode(nodes,i,prevNode);
				} else if (tloc > nloc) {
					removeNode(nodes,i);
					node = nodes[i];
				};
				
				// need to insert new node here - 
				if (!node) { node = addNode(nodes,i,prevNode) };
				
				if (tok._type == 'STRING' && tok._value.match(/\{3}/)) {
					if (nested) {
						nested.pop(); // this is the node
						prevNode = node;
						continue;
					};
					
					// want to make sure it is a placeholder for the right thing
				};
				
				var cval = code.substr(tloc,tok._len);
				var cprev = node.textContent;
				var element = self.reclassify(node,tok._type,tok,cval,cprev);
				
				if (tok._children) {
					var cnodes = node.children;
					if (cnodes.length && cnodes.length == node.childNodes.length) {
						self.logger().log('reuse the cnodes(!)',cnodes);
						// otherwise we should remove the textNodes?
						// convert to array
						cnodes = Array.prototype.slice.call(cnodes);
					} else {
						self.logger().log('wrong length');
						for (var j = 0, items = iter$(node.childNodes), len_ = items.length; j < len_; j++) {
							self.logger().log(items[j]);
						};
						// see if previous value is the same?!
						node.innerHTML = '';
						cnodes = [];
					};
					
					// let o =
					// 	code: cval
					// 	nodes: cnodes
					// 	tokens: tok.@children # already parsed
					// 	nested: nested
					// 	parent: node
					
					self.applyTokens(cval,tok._children,cnodes,nested,node);
				} else if (cprev != cval) {
					node.textContent = cval; // tok.@value
					element.reparsed(cval,cprev);
				};
				
				prevNode = node;
				// tok.@len
			};
			
			// loop through tokens? not sure it works due to the issues with whitespace?
			
			// remove excess original nodes
			while (nodes.length > tokens.length){
				node = nodes.pop();
				if (node.parentNode) { node.parentNode.removeChild(node) };
				// node.orphanize
			};
			return self;
		};
		
		// should later be able to rehighlight the text / nodes directly instead
		// probably more efficient
		Highlighter.highlight = function (code,o){
			// first try to parse etc?
			// could highlight single words as well
			if(o === undefined) o = {};
			o.hl || (o.hl = hlo);
			var tokens = o.tokens || null;
			
			if (!tokens) {
				try {
					// sure we dont want to rewrite anything now?
					if (true) { console.time('tokenize') };
					if (o.mode == 'full') {
						tokens = this.tokenize(code,{});
					} else {
						tokens = this.tokenize(code,{inline: true,silent: true,rewrite: false});
					};
					if (true) { console.timeEnd('tokenize') };
				} catch (e) {
					if (e._options) { tokens = e._options.tokens };
				};
			};
			
			var hl = new this(code,tokens,null,o);
			return hl.process();
		};
		
		
		
		Highlighter.prototype.options = function(v){ return this._options; }
		Highlighter.prototype.setOptions = function(v){ this._options = v; return this; };
		
		Highlighter.prototype.varRef = function (variable){
			var $1;
			var i = this._options.nested;
			var pfx = i ? ('i') : ('');
			return this._varRefs[($1 = variable._ref)] || (this._varRefs[$1] = (pfx + this._options.nextVarCounter++));
		};
		
		Highlighter.prototype.parseWhitespace = function (text){
			// parsing comments
			var self = this;
			var hl = this._options.hl;
			var comments = [];
			
			text = text.replace(/(\#)([^\n]*)/g,function(m,s,q) {
				if (self._options.render.comment) {
					m = self._options.render.comment('comment',m);
				};
				var nr = comments.push(("<" + NODETYPE + " class='_im _imcomment'>" + m + "</" + NODETYPE + ">"));
				return ("$" + (nr - 1) + "$");
			});
			
			text = text.replace(/(\n|[ ]+|[\t]+)/g,function(m,l) {
				if (l == '\n') {
					return hl.newline || '\n';
				} else if (l[0] == ' ') {
					return hl.space instanceof Function ? (hl.space(l)) : (l);
				} else if (l[0] == '\t') {
					return hl.tab instanceof Function ? (hl.tab(l)) : (l);
				};
			});
			
			if (comments.length) {
				text = text.replace(/\$(\d+)\$/g,function(m,nr) {
					return comments[parseInt(nr)];
				});
			};
			return text;
		};
		
		Highlighter.prototype.process = function (){
			var tok;
			var o = this.options();
			
			var str = this._code;
			var pos = this._tokens.length;
			
			var stack = [];
			var depth = 0;
			var context = null;
			
			var push = function(ctx) {
				stack.push(ctx);
				depth = stack.length;
				return context = stack[depth - 1];
			};
			
			var pop = function(ctx) {
				stack.pop();
				depth = stack.length;
				return context = stack[depth - 1];
			};
			
			if (this._ast && this._ast.analyze) {
				try {
					this._ast.analyze({});
				} catch (e) {
					null;
				};
			};
			
			var res = "";
			pos = 0;
			var caret = 0;
			
			var open,close;
			
			while (tok = this._tokens[pos++]){
				var next = this._tokens[pos];
				
				if (close) {
					if (!(o.inner && depth == 1)) { res += ("</" + NODETYPE + ">") };
					close = null;
					pop();
				};
				
				var typ = tok._type.toLowerCase();
				var loc = tok._loc;
				var val = tok._value;
				var len = tok._len; // or tok.@value:length
				var meta = tok._meta;
				var attrs = '';
				
				if (loc > caret) {
					var add = str.substring(caret,loc);
					if (context != INTERPOLATING) { add = this.parseWhitespace(add) };
					res += add;
					caret = loc;
				};
				
				close = CLOSE[typ];
				
				if (open = OPEN[typ]) {
					// open = OPEN[val] || open
					push(open);
					if (!(o.inner && depth == 1)) { res += ("<" + NODETYPE + " class='" + open + "'>") };
				};
				
				if (len == 0 || typ == 'terminator' || typ == 'indent' || typ == 'outdent') {
					continue;
				};
				
				if (tok._col == -1 && tok._loc <= 0) {
					continue;
				};
				
				var node = NODETYPE;
				var content = str.substr(loc,len);
				// temporary workaround until we redefine require as an identifier
				if (typ == 'const' && content == 'require') {
					typ = 'require';
				};
				
				
				var cls = classes[typ] || typ;
				
				if (cls instanceof Array) {
					node = cls[0];
					cls = cls[1];
				};
				
				cls = cls.split(" ");
				
				if (KEYWORDS.indexOf(typ) >= 0) {
					cls.unshift('keyword');
				};
				
				caret = loc + len;
				
				if (typ == 'identifier') {
					if (content[0] == '#') {
						cls.push('idref');
					};
					
					if (meta) {
						if (meta.type == 'ACCESS') { cls.push('access') };
					};
					
					if (content == 'log') {
						cls.push('log');
					};
				};
				
				if (tok._variable) {
					
					cls.push('lvar');
					var ref = this.varRef(tok._variable);
					attrs += (" eref='v" + ref + "'");
					// cls.push("ref-"+ref)
				};
				
				if (typ == 'herecomment') {
					var end = ("<" + NODETYPE + ">###</" + NODETYPE + ">");
					content = end + content.slice(3,-3) + end;
				};
				
				if (typ == 'string') {
					if (content.match(/^['"]?\.?\.\//)) { cls.push('pathname') };
				};
				
				var clstr = cls.join(" ");
				if (!clstr.match(/\b\_/)) { clstr = '_imtok ' + clstr };
				res += ("<" + node + " class='" + clstr + "'") + attrs + ">" + content + ("</" + node + ">");
			};
			
			// close after?
			if (close) {
				res += ("</" + NODETYPE + ">");
				close = null;
			};
			
			if (caret < str.length - 1) {
				add = str.slice(caret);
				if (context != INTERPOLATING) { add = this.parseWhitespace(add) };
				res += add;
			};
			
			if (this._tokens.length == 0) {
				res = this._code;
			};
			
			return res;
		};
		return Highlighter;
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		var ALL_KEYWORDS;
		
		var T = __webpack_require__(31);
		var Token = T.Token;
		
		var rw = __webpack_require__(32);
		var Rewriter = rw.Rewriter;
		var INVERSES = rw.INVERSES;
		
		var K = 0;
		
		var ERR = __webpack_require__(33);
		
		// Constants
		// ---------
		
		// Keywords that Imba shares in common with JavaScript.
		var JS_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return'
		];
		
		// new can be used as a keyword in imba, since object initing is done through
		// MyObject.new. new is a very useful varname.
		
		// We want to treat return like any regular call for now
		// Must be careful to throw the exceptions in AST, since the parser
		// wont
		
		// Imba-only keywords. var should move to JS_Keywords
		// some words (like tokid) should be context-specific
		var IMBA_KEYWORDS = [
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import'
		];
		
		var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];
		
		var IMBA_ALIAS_MAP = {
			'and': '&&',
			'or': '||',
			'is': '==',
			'isnt': '!=',
			'not': '!',
			'yes': 'true',
			'no': 'false',
			'isa': 'instanceof',
			'case': 'switch',
			'nil': 'null'
		};
		
		var IMBA_ALIASES = Object.keys(IMBA_ALIAS_MAP);
		IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);
		
		// FixedArray for performance
		// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
		module.exports.ALL_KEYWORDS = ALL_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil'
		];
		
		// The list of keywords that are reserved by JavaScript, but not used, or are
		// used by Imba internally. We throw an error when these are encountered,
		// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
		var RESERVED = ['case','default','function','void','with','const','enum','native'];
		var STRICT_RESERVED = ['case','function','void','const'];
		
		// The superset of both JavaScript keywords and reserved words, none of which may
		// be used as identifiers or properties.
		var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);
		
		var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
		// removed ~=|~| |&(?![&=])
		
		// Token matching regexes.
		// added hyphens to identifiers now - to test
		var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;
		
		var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;
		
		var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;
		
		var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
		var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;
		
		var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;
		
		var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
		var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
		var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;
		
		var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
		var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		
		var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\/\\\:][\w\x7f-\uffff]+)*)|==|\<=\>|\[\]|\[\]\=|\*|[\\/,\\])/;
		
		
		var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
		
		var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;
		
		var OPERATOR = /^(?:[-=]=>|===|->|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;
		
		// FIXME splat should only be allowed when the previous thing is spaced or inside call?
		
		var WHITESPACE = /^[^\n\S]+/;
		
		var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
		// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
		var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;
		
		var CODE = /^[-=]=>/;
		
		var MULTI_DENT = /^(?:\n[^\n\S]*)+/;
		
		var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;
		
		var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;
		
		// Regex-matching-regexes.
		var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;
		
		var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;
		
		var HEREGEX_OMIT = /\s+(?:#.*)?/g;
		
		// Token cleaning regexes.
		var MULTILINER = /\n/g;
		
		var HEREDOC_INDENT = /\n+([^\n\S]*)/g;
		
		var HEREDOC_ILLEGAL = /\*\//;
		
		// expensive?
		var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
		
		var TRAILING_SPACES = /\s+$/;
		
		var CONST_IDENTIFIER = /^[A-Z]/;
		
		var ARGVAR = /^\$\d$/;
		
		// Compound assignment tokens.
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];
		
		// Unary tokens.
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		
		// Logical tokens.
		var LOGIC = ['&&','||','&','|','^'];
		
		// Bit-shifting tokens.
		var SHIFT = ['<<','>>','>>>'];
		
		// Comparison tokens.
		var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];
		
		// Overideable methods
		var OP_METHODS = ['<=>','<<','..'];
		
		// Mathematical tokens.
		var MATH = ['*','/','%','','',''];
		
		// Relational tokens that are negatable with `not` prefix.
		var RELATION = ['IN','OF','INSTANCEOF','ISA'];
		
		// Boolean tokens.
		var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];
		
		// Our list is shorter, due to sans-parentheses method calls.
		var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];
		
		// If the previous token is not spaced, there are more preceding tokens that
		// force a division parse:
		var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];
		
		// Tokens which could legitimately be invoked or indexed. An opening
		// parentheses or bracket following these tokens will be recorded as the start
		// of a function invocation or indexing operation.
		// really?!
		
		var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];
		
		// } should not be callable anymore!!! '}', '::',
		var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];
		// var INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS','}' # are booleans indexable? really?
		// optimize for FixedArray
		var INDEXABLE = [
			'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
			'NUMBER','BOOL','TAG_SELECTOR','IDREF','ARGUMENTS','}','TAG_TYPE'
		];
		
		var GLOBAL_IDENTIFIERS = ['global','exports','require'];
		
		// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
		// occurs at the start of a line. We disambiguate these from trailing whens to
		// avoid an ambiguity in the grammar.
		var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];
		
		
		function LexerError(message,file,line){
			this.message = message;
			this.file = file;
			this.line = line;
			return this;
		};
		subclass$(LexerError,SyntaxError);
		exports.LexerError = LexerError; // export class 
		
		
		
		function last(array,back){
			if(back === undefined) back = 0;
			return array[array.length - back - 1];
		};
		
		function count(str,substr){
			return str.split(substr).length - 1;
		};
		
		function repeatString(str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		var tT = T.typ;
		var tV = T.val;
		var tTs = T.setTyp;
		var tVs = T.setVal;
		
		// The Lexer class reads a stream of Imba and divvies it up into tokidged
		// tokens. Some potential ambiguity in the grammar has been avoided by
		// pushing some extra smarts into the Lexer.
		
		// Based on the original lexer.coffee from CoffeeScript
		function Lexer(){
			this.reset();
			this;
		};
		
		exports.Lexer = Lexer; // export class 
		Lexer.prototype.reset = function (){
			this._code = null;
			this._chunk = null; // The remainder of the source code.
			this._opts = null;
			
			this._indent = 0; // The current indentation level.
			this._indebt = 0; // The over-indentation at the current level.
			this._outdebt = 0; // The under-outdentation at the current level.
			
			this._indents = []; // The stack of all current indentation levels.
			this._ends = []; // The stack for pairing up tokens.
			this._contexts = []; // suplements @ends
			this._scopes = [];
			this._nextScope = null; // the scope to add on the next indent
			// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
			// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
			
			this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
			this._seenFor = false;
			this._loc = 0;
			this._locOffset = 0;
			
			this._end = null;
			this._char = null;
			this._bridge = null;
			this._last = null;
			this._lastTyp = '';
			this._lastVal = null;
			return this;
		};
		
		Lexer.prototype.jisonBridge = function (jison){
			return this._bridge = {
				lex: T.lex,
				setInput: function(tokens) {
					this.tokens = tokens;
					return this.pos = 0;
				},
				
				upcomingInput: function() { return ""; }
			};
		};
		
		
		Lexer.prototype.tokenize = function (code,o){
			
			if(o === undefined) o = {};
			if (code.length == 0) {
				return [];
			};
			
			if (!o.inline) {
				if (WHITESPACE.test(code)) {
					code = ("\n" + code);
					if (code.match(/^\s*$/g)) { return [] };
				};
				
				code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
			};
			
			this._last = null;
			this._lastTyp = null;
			this._lastVal = null;
			
			this._code = code;
			this._opts = o;
			this._locOffset = o.loc || 0;
			// add a reference to the options object
			o._tokens = this._tokens;
			// what about col here?
			
			// @indent  = 0 # The current indentation level.
			// @indebt  = 0 # The over-indentation at the current level.
			// @outdebt = 0 # The under-outdentation at the current level.
			// @indents = [] # The stack of all current indentation levels.
			// @ends    = [] # The stack for pairing up tokens.
			// @tokens  = [] # Stream of parsed tokens in the form `['TYPE', value, line]`.
			// @char = nil
			
			if (o.profile) { console.time("tokenize:lexer") };
			this.parse(code);
			if (!o.inline) this.closeIndentation();
			if (!o.silent && this._ends.length) {
				this.error(("missing " + (this._ends.pop())));
			};
			
			if (o.profile) { console.timeEnd("tokenize:lexer") };
			if (o.rewrite == false || o.norewrite) { return this._tokens };
			return new Rewriter().rewrite(this._tokens,o);
		};
		
		Lexer.prototype.parse = function (code){
			var i = 0;
			var pi = 0;
			
			while (this._chunk = code.slice(i)){
				this._loc = this._locOffset + i;
				pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
				i += pi;
			};
			
			return;
		};
		
		Lexer.prototype.basicContext = function (){
			return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
		};
		
		Lexer.prototype.moveCaret = function (i){
			return this._loc += i;
		};
		
		Lexer.prototype.context = function (){
			return this._ends[this._ends.length - 1];
		};
		
		Lexer.prototype.inContext = function (key){
			var o = this._contexts[this._contexts.length - 1];
			return o && o[key];
		};
		
		Lexer.prototype.pushEnd = function (val){
			// console.log "pushing end",val
			this._ends.push(val);
			this._contexts.push(null);
			this._end = val;
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.popEnd = function (val){
			this._ends.pop();
			this._contexts.pop();
			this._end = this._ends[this._ends.length - 1];
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.refreshScope = function (){
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
		};
		
		
		
		Lexer.prototype.queueScope = function (val){
			// console.log("pushing scope {val} - {@indents} {@indents:length}")
			// @scopes.push(val) # no no
			this._scopes[this._indents.length] = val;
			return this;
		};
		
		Lexer.prototype.popScope = function (val){
			this._scopes.pop();
			return this;
		};
		
		Lexer.prototype.getScope = function (){
			return this._scopes[this._indents.length - 1];
		};
		
		Lexer.prototype.scope = function (sym,opts){
			var len = this._ends.push(this._end = sym);
			this._contexts.push(opts || null);
			return sym;
		};
		
		
		Lexer.prototype.closeSelector = function (){
			if (this._end == '%') {
				this.token('SELECTOR_END','%',0);
				return this.pair('%');
			};
		};
		
		
		Lexer.prototype.openDef = function (){
			return this.pushEnd('DEF');
		};
		
		
		Lexer.prototype.closeDef = function (){
			if (this.context() == 'DEF') {
				var prev = last(this._tokens);
				// console.log "close def {prev}"
				// console.log('closeDef with last>',prev)
				if (tT(prev) == 'DEF_FRAGMENT') {
					true;
				} else if (tT(prev) == 'TERMINATOR') {
					// console.log "here?!??"
					var n = this._tokens.pop();
					// console.log n
					this.token('DEF_BODY','DEF_BODY',0);
					// token('TERMINATOR', '',0) unless n.@value.indexOf('//') >= 0
					this._tokens.push(n);
				} else {
					this.token('DEF_BODY','DEF_BODY',0);
				};
				
				this.pair('DEF');
			};
			return;
		};
		
		Lexer.prototype.tagContextToken = function (){
			var match;
			if (this._chunk[0] == '#') {
				// console.log('found id # in tagContextToken')
				this.token('#','#',1);
				return 1;
			};
			
			if (match = TAG_ATTR.exec(this._chunk)) {
				// console.log 'TAG_SDDSATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			return 0;
		};
		
		Lexer.prototype.tagDefContextToken = function (){
			// console.log "tagContextToken"
			var match;
			if (match = TAG_TYPE.exec(this._chunk)) {
				this.token('TAG_TYPE',match[0],match[0].length);
				return match[0].length;
			};
			
			if (match = TAG_ID.exec(this._chunk)) {
				var input = match[0];
				this.token('TAG_ID',input,input.length);
				return input.length;
			};
			
			return 0;
		};
		
		
		Lexer.prototype.tagToken = function (){
			var match, ary;
			if (!(match = TAG.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
			
			if (type == '<') {
				this.token('TAG_START','<',1);
				this.pushEnd(INVERSES.TAG_START);
				
				if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
					// special case should probably be handled in AST
					if (match[0] != 'self') {
						this.token('TAG_TYPE',match[0],match[0].length,1);
						return input.length + match[0].length;
					};
				};
				
				if (identifier) {
					if (identifier.substr(0,1) == '{') {
						return type.length;
					} else {
						this.token('TAG_NAME',input.substr(1),0);
					};
				};
			};
			
			return input.length;
		};
		
		
		Lexer.prototype.selectorToken = function (){
			var ary, string;
			var match;
			
			// special handling if we are in this context
			if (this._end == '%') {
				var chr = this._chunk.charAt(0);
				var open = this.inContext('open');
				
				// should add for +, ~ etc
				// should maybe rather look for the correct type of character?
				
				if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
					// console.log "close this selector directly"
					this.token('SELECTOR_END','%',0);
					this.pair('%');
					return 0;
				};
				
				if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
					// spaces between? -- include the whole
					this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
					return match[0].length;
				} else if (match = SELECTOR_PART.exec(this._chunk)) {
					var type = match[1];
					var id = match[2];
					
					switch (type) {
						case '.':
							tokid = 'SELECTOR_CLASS';break;
						
						case '#':
							tokid = 'SELECTOR_ID';break;
						
						case ':':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						case '::':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						default:
						
							var tokid = 'SELECTOR_TAG';
					
					};
					
					this.token(tokid,match[2],match[0].length);
					return match[0].length;
				} else if (chr == '[') {
					this.token('[','[',1);
					this.pushEnd(']');
					if (match = SELECTOR_ATTR.exec(this._chunk)) {
						// fuck this length shit
						var idoffset = match[0].indexOf(match[1]);
						var opoffset = match[0].indexOf(match[2]);
						this.token('IDENTIFIER',match[1],match[1].length,idoffset);
						this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
						return match[0].length;
					};
					return 1;
				} else if (chr == '|') {
					var tok = this._tokens[this._tokens.length - 1];
					tTs(tok,'SELECTOR_NS');
					// tok[0] = 'SELECTOR_NS' # FIX
					return 1;
				} else if (chr == ',') {
					this.token('SELECTOR_GROUP',',',1);
					return 1;
				} else if (chr == '*') {
					this.token('UNIVERSAL_SELECTOR','*',1);
					return 1;
				} else if (chr == ')') {
					this.pair('%');
					this.token('SELECTOR_END',')',1);
					return 1;
				} else if (idx$(chr,[')','}',']','']) >= 0) {
					this.pair('%');
					return 0;
				};
			};
			
			if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
			
			// this is a closed selector
			if (kind == '(') {
				// token '(','('
				this.token('SELECTOR_START',id,id.length + 1);
				// self.pushEnd(')') # are we so sure about this?
				this.pushEnd('%');
				
				// @ends.push ')'
				// @ends.push '%'
				return id.length + 1;
			} else if (id == '%') {
				// we are already scoped in on a selector
				if (this.context() == '%') { return 1 };
				this.token('SELECTOR_START',id,id.length);
				// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
				
				this.scope('%',{open: true});
				// @ends.push '%'
				// make sure a terminator breaks out
				return id.length;
			} else {
				return 0;
			};
			
			if ((id == '%' || id == '$') && ['%','$','@','(','['].indexOf(chr) >= 0) {
				var idx = 2;
				
				
				// VERY temporary way of solving this
				if ((chr == '%' || chr == '$' || chr == '@')) {
					id += chr;
					idx = 3;
					chr = this._chunk.charAt(2);
				};
				
				
				if (chr == '(') {
					if (!(string = this.balancedSelector(this._chunk,')'))) { return 0 };
					if (0 < string.indexOf('{',1)) {
						this.token('SELECTOR',id);
						// is this even used anymore? If so - we need to fix it
						this.interpolateString(string.slice(idx,-1));
						return string.length;
					} else {
						this.token('SELECTOR',id);
						this.token('(','(');
						this.token('STRING','"' + string.slice(idx,-1) + '"');
						this.token(')',')');
						return string.length;
					};
				} else if (chr == '[') {
					this.token('SELECTOR',id);
					return 1;
					// token '[','['
					// @ends.push ''
				};
			} else {
				return 0;
			};
		};
		
		// is this really needed? Should be possible to
		// parse the identifiers and = etc i jison?
		// what is special about methodNameToken? really?
		Lexer.prototype.methodNameToken = function (){
			// we can optimize this by after a def simply
			// fetching all the way after the def until a space or (
			// and then add this to the def-token itself (as with fragment)
			if (this._chunk.charAt(0) == ' ') { return 0 };
			
			var match;
			
			if (this._end == ')') {
				var outerctx = this._ends[this._ends.length - 2];
				// weird assumption, no?
				// console.log 'context is inside!!!'
				if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
					this.token('TAG_ATTR_SET',match[1]);
					return match[0].length;
				};
			};
			
			if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			// var prev = last @tokens
			var length = match[0].length;
			
			var id = match[0];
			var ltyp = this._lastTyp;
			var typ = 'IDENTIFIER';
			var pre = id.charAt(0);
			var space = false;
			
			var m4 = match[4]; // might be out of bounds? should rather check charAt
			// drop match 4??
			
			// should this not quit here in practically all cases?
			if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!' || m4 == '?') || match[5])) {
				return 0;
			};
			
			// again, why?
			if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
				return 0;
			};
			
			if (id == 'new') {
				typ = 'NEW';
			};
			
			if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
				return 0;
			};
			
			if (id == '|') {
				// hacky way to implement this
				// with new lexer we'll use { ... } instead, and assume object-context,
				// then go back and correct when we see the context is invalid
				if (ltyp == '(' || ltyp == 'CALL_START') {
					this.token('DO','DO',0);
					this.pushEnd('|');
					// @ends.push '|'
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (ltyp == 'DO' || ltyp == '{') {
					// @ends.push '|'
					this.pushEnd('|');
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (this._ends[this._ends.length - 1] == '|') {
					this.token('BLOCK_PARAM_END','|',1);
					this.pair('|');
					return length;
				} else {
					return 0;
				};
			};
			
			// whaat?
			// console.log("method identifier",id)
			if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
				return 0;
			};
			
			if (OP_METHODS.indexOf(id) >= 0) {
				space = true;
			};
			
			// not even anything we should use?!?
			if (pre == '@') {
				typ = 'IVAR';
			} else if (pre == '$') {
				true;
				// typ = 'GVAR'
			} else if (pre == '#') {
				typ = 'TAGID';
			} else if (CONST_IDENTIFIER.test(pre) || id == 'require' || id == 'global' || id == 'exports') {
				// really? seems very strange
				// console.log('global!!',typ,id)
				typ = 'CONST';
			};
			
			// what is this really for?
			if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING','IDREF'].indexOf(ltyp) >= 0) {
				this.token('.','.',0);
			};
			
			this.token(typ,id,length);
			
			if (space) {
				this._last.spaced = true;
			};
			
			return length;
		};
		
		
		Lexer.prototype.inTag = function (){
			var len = this._ends.length;
			if (len > 0) {
				var ctx0 = this._ends[len - 1];
				var ctx1 = len > 1 ? (this._ends[len - 2]) : (ctx0);
				return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			};
			return false;
		};
		
		Lexer.prototype.isKeyword = function (id){
			if ((id == 'attr' || id == 'prop')) {
				var scop = this.getScope();
				var incls = scop == 'CLASS' || scop == 'TAG';
				// var scopes = @indents.map(|ind,i| @scopes[i] or 'NONE')
				// console.log "id is prop: {scopes.join(" -> ")} | {@indents.join(" -> ")}"
				if (incls) { return true };
			};
			
			return ALL_KEYWORDS.indexOf(id) >= 0;
		};
		
		// Matches identifying literals: variables, keywords, method names, etc.
		// Check to ensure that JavaScript reserved words aren't being used as
		// identifiers. Because Imba reserves a handful of keywords that are
		// allowed in JavaScript, we're careful not to tokid them as keywords when
		// referenced as property names here, so you can still do `jQuery.is()` even
		// though `is` means `===` otherwise.
		Lexer.prototype.identifierToken = function (){
			var ary;
			var match;
			
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			var innerctx = ctx0;
			var typ;
			var reserved = false;
			
			var addLoc = false;
			var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			
			// console.log ctx1,ctx0
			
			if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
				// console.log 'TAG_ATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			
			// see if this is a plain object-key
			// way too much logic going on here?
			// the ast should normalize whether keys
			// are accessable as keys or strings etc
			if (match = OBJECT_KEY.exec(this._chunk)) {
				var id = match[1];
				typ = 'IDENTIFIER';
				
				// FIXME loc of key includes colon
				// moveCaret(id:length)
				// console.log "ok"
				if (true) {
					// console.log "got here? {match}"
					this.token(typ,id,id.length);
					this.moveCaret(id.length);
					this.token(':',':',match[3].length);
					this.moveCaret(-id.length);
					// moveCaret(match[3]:length)
					return match[0].length;
				};
				
				// moveCaret(match[2]:length)
				// return 0
				console.log(match[3].length);
				this.token(typ,id,match[0].length);
				this.token(':',':',1);
				return match[0].length;
			};
			
			if (!(match = IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			
			var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
			var idlen = id.length;
			
			// What is the logic here?
			if (id == 'own' && this.lastTokenType() == 'FOR') {
				this.token('OWN',id,id.length);
				return id.length;
			};
			
			var prev = last(this._tokens);
			var lastTyp = this._lastTyp;
			
			// should we force this to be an identifier even if it is a reserved word?
			// this should only happen for when part of object etc
			// will prev ever be @???
			var forcedIdentifier;
			
			// again
			forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
			
			
			// temp hack! need to solve for other keywords etc as well
			// problem appears with ternary conditions.
			
			// well -- it should still be an indentifier if in object?
			// forcedIdentifier = no if id in ['undefined','break']
			
			if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
			
			// if we are not at the top level? -- hacky
			if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
				forcedIdentifier = true;
			};
			
			var isKeyword = false;
			
			// console.log "match",match
			// console.log "typ is {typ}"
			// little reason to check for this right here? but I guess it is only a simple check
			if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
				// console.log "TYP $"
				if (id == '$0') {
					typ = 'ARGUMENTS';
				} else {
					typ = 'ARGVAR';
					id = id.substr(1);
				};
			} else if (typ == '@') {
				typ = 'IVAR';
				
				// id:reserved = yes if colon
			} else if (typ == '#') {
				// we are trying to move to generic tokens,
				// so we are starting to splitting up the symbols and the items
				// we'll see if that works
				typ = 'IDENTIFIER';
				this.token('#','#');
				id = id.substr(1);
			} else if (typ == '@@') {
				typ = 'CVAR';
			} else if (typ == '$' && !colon) {
				typ = 'IDENTIFIER';
				// typ = 'GVAR'
			} else if (CONST_IDENTIFIER.test(id) || id == 'require' || id == 'global' || id == 'exports') {
				// thous should really be handled by the ast instead
				typ = 'CONST';
			} else if (id == 'elif') {
				this.token('ELSE','elif',id.length);
				this.token('IF','if');
				return id.length;
			} else {
				typ = 'IDENTIFIER';
			};
			
			
			
			// this catches all 
			if (!forcedIdentifier && (isKeyword = this.isKeyword(id))) {
				// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
				typ = id.toUpperCase();
				addLoc = true;
				
				// clumsy - but testing performance
				if (typ == 'YES') {
					typ = 'TRUE';
				} else if (typ == 'NO') {
					typ = 'FALSE';
				} else if (typ == 'NIL') {
					typ = 'NULL';
				} else if (typ == 'VAR') {
					if (this._lastVal == 'export') {
						tTs(prev,'EXPORT');
					};
				} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
					true;
				} else if (typ == 'TAG') {
					this.pushEnd('TAG');
					// @ends.push('TAG')
				} else if (typ == 'DEF') {
					// should probably shift context and optimize this
					this.openDef();
				} else if (typ == 'DO') {
					if (this.context() == 'DEF') this.closeDef();
				} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
					typ = 'LEADING_WHEN';
				} else if (typ == 'FOR') {
					this._seenFor = true;
				} else if (typ == 'UNLESS') {
					typ = 'IF'; // WARN
				} else if (UNARY.indexOf(typ) >= 0) {
					typ = 'UNARY';
				} else if (RELATION.indexOf(typ) >= 0) {
					if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
						typ = 'FOR' + typ; // ?
						this._seenFor = false;
					} else {
						typ = 'RELATION';
						if (String(this.value()) == '!') {
							this._tokens.pop(); // is fucked up??!
							// WARN we need to keep the loc, no?
							id = '!' + id;
						};
					};
				};
			};
			
			if (id == 'super') {
				typ = 'SUPER';
			};
			
			// do we really want to check this here
			if (!forcedIdentifier) {
				// should already have dealt with this
				
				if (isKeyword && IMBA_ALIASES.indexOf(id) >= 0) { id = IMBA_ALIAS_MAP[id] };
				// these really should not go here?!?
				switch (id) {
					case '!':
						typ = 'UNARY';break;
					
					case '==':
					case '!=':
					case '===':
					case '!==':
						typ = 'COMPARE';break;
					
					case '&&':
					case '||':
						typ = 'LOGIC';break;
					
					case 'break':
					case 'continue':
					case 'debugger':
					case 'arguments':
						typ = id.toUpperCase();break;
				
				};
			};
			
			// prev = last @tokens
			var len = input.length;
			
			// should be strict about the order, check this manually instead
			if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
				this.queueScope(typ);
				
				var i = this._tokens.length;
				
				while (i){
					prev = this._tokens[--i];
					var ctrl = "" + tV(prev);
					// console.log("ctrl is {ctrl}")
					// need to coerce to string because of stupid CS ===
					// console.log("prev is",prev[0],prev[1])
					if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
						tTs(prev,ctrl.toUpperCase());
						// prev[0] = ctrl.toUpperCase # FIX
					} else {
						break;
					};
				};
			} else if (typ == 'IF') {
				this.queueScope(typ);
			} else if (typ == 'IMPORT') {
				// could manually parse the whole ting here?
				this.pushEnd('IMPORT');
				// @ends.push 'IMPORT'
			} else if (id == 'from' && ctx0 == 'IMPORT') {
				typ = 'FROM';
				this.pair('IMPORT');
			} else if (id == 'as' && ctx0 == 'IMPORT') {
				typ = 'AS';
				this.pair('IMPORT');
			};
			
			if (typ == 'IDENTIFIER') {
				// see if previous was catch -- belongs in rewriter?
				if (lastTyp == 'CATCH') {
					typ = 'CATCH_VAR';
				};
			};
			
			if (colon) {
				this.token(typ,id,idlen);
				this.moveCaret(idlen);
				// console.log "add colon?"
				this.token(':',':',colon.length);
				this.moveCaret(-idlen);
			} else {
				this.token(typ,id,idlen);
			};
			
			return len;
		};
		
		// Matches numbers, including decimals, hex, and exponential notation.
		// Be careful not to interfere with ranges-in-progress.
		Lexer.prototype.numberToken = function (){
			var binaryLiteral;
			var match,number,lexedLength;
			
			if (!(match = NUMBER.exec(this._chunk))) { return 0 };
			
			number = match[0];
			lexedLength = number.length;
			
			if (binaryLiteral = /0b([01]+)/.exec(number)) {
				
				number = "" + parseInt(binaryLiteral[1],2);
			};
			
			var prev = last(this._tokens);
			
			if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
				// console.log "got here"
				this.token(".",".");
				number = number.substr(1);
			};
			
			
			this.token('NUMBER',number,lexedLength);
			return lexedLength;
		};
		
		Lexer.prototype.symbolToken = function (){
			var match,symbol,prev;
			
			if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
			symbol = match[0].substr(1);
			prev = last(this._tokens);
			
			// is this a property-access?
			// should invert this -- only allow when prev IS .. 
			
			// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
			
			// FIX
			if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR']) == -1) {
				this.token('.:',':',1);
				var sym = symbol.split(/[\:\\\/]/)[0]; // really?
				// token 'SYMBOL', "'#{symbol}'"
				this.token('IDENTIFIER',sym,sym.length,1);
				return (sym.length + 1);
			} else {
				// token 'SYMBOL', "'#{symbol}'"
				this.token('SYMBOL',symbol,match[0].length);
				return match[0].length;
			};
		};
		
		Lexer.prototype.escapeStr = function (str,heredoc,q){
			str = str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
			if (q) {
				var r = RegExp(("\\\\[" + q + "]"),"g");
				str = str.replace(r,q);
				str = str.replace(RegExp(("" + q),"g"),'\\$&');
			};
			return str;
			
			// str = str.replace(MULTILINER, '\\n')
			// str = str.replace(/\t/g, '\\t')
		};
		// Matches strings, including multi-line strings. Ensures that quotation marks
		// are balanced within the string's contents, and within nested interpolations.
		Lexer.prototype.stringToken = function (){
			var match,string;
			
			switch (this._chunk.charAt(0)) {
				case "'":
					if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
					string = match[0];
					this.token('STRING',this.escapeStr(string),string.length);
					// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
					break;
				
				case '"':
					if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
					// what about tripe quoted strings?
					
					if (string.indexOf('{') >= 0) {
						var len = string.length;
						// if this has no interpolation?
						// we are now messing with locations - beware
						this.token('STRING_START',string.charAt(0),1);
						this.interpolateString(string.slice(1,-1));
						this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
					} else {
						len = string.length;
						// string = string.replace(MULTILINER, '\\\n')
						this.token('STRING',this.escapeStr(string),len);
					};
					break;
				
				default:
				
					return 0;
			
			};
			
			this.moveHead(string);
			return string.length;
		};
		
		// Matches heredocs, adjusting indentation to the correct level, as heredocs
		// preserve whitespace, but ignore indentation to the left.
		Lexer.prototype.heredocToken = function (){
			var match,heredoc,quote,doc;
			
			if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
			
			heredoc = match[0];
			quote = heredoc.charAt(0);
			doc = this.sanitizeHeredoc(match[2],{quote: quote,indent: null});
			// console.log "found heredoc {match[0]:length} {doc:length}"
			
			if (quote == '"' && doc.indexOf('{') >= 0) {
				var open = match[1];
				// console.log doc.substr(0,3),match[1]
				this.token('STRING_START',open,open.length);
				this.interpolateString(doc,{heredoc: true,offset: open.length,quote: quote});
				this.token('STRING_END',open,open.length,heredoc.length - open.length);
			} else {
				this.token('STRING',this.makeString(doc,quote,true),0);
			};
			
			this.moveHead(heredoc);
			return heredoc.length;
		};
		
		// Matches and consumes comments.
		Lexer.prototype.commentToken = function (){
			var match,length,comment,indent,prev;
			
			var typ = 'HERECOMMENT';
			
			if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
				// console.log "match inline comment"
				length = match[0].length;
				indent = match[1];
				comment = match[2];
				
				prev = last(this._tokens);
				var pt = prev && tT(prev);
				var note = '//' + comment.substr(1);
				
				if (this._last && this._last.spaced) {
					note = ' ' + note;
					// console.log "the previous node was SPACED"
				};
				// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
				
				if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !pt) {
					// console.log "skip comment"
					// token 'INLINECOMMENT', comment.substr(2)
					// console.log "adding as terminator"
					this.token('TERMINATOR',note,length); // + '\n'
				} else {
					// console.log "add comment ({note})"
					if (pt == 'TERMINATOR') {
						tVs(prev,tV(prev) + note);
						// prev[1] += note
					} else if (pt == 'INDENT') {
						// console.log "adding comment to INDENT: {note}" # why not add directly here?
						this.addLinebreaks(1,note);
					} else {
						// console.log "comment here"
						// should we ever get here?
						this.token(typ,comment.substr(2),length); // are we sure?
					};
				};
				
				return length; // disable now while compiling
			};
			
			// should use exec?
			if (!(match = COMMENT.exec(this._chunk))) { return 0 };
			
			comment = match[0];
			var here = match[1];
			
			if (here) {
				this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
				this.token('TERMINATOR','\n');
			} else {
				this.token('HERECOMMENT',comment,comment.length);
				this.token('TERMINATOR','\n'); // auto? really?
			};
			
			this.moveHead(comment);
			return comment.length;
		};
		
		// Matches JavaScript interpolated directly into the source via backticks.
		Lexer.prototype.jsToken = function (){
			var match,script;
			
			if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
			this.token('JS',(script = match[0]).slice(1,-1));
			return script.length;
		};
		
		// Matches regular expression literals. Lexing regular expressions is difficult
		// to distinguish from division, so we borrow some basic heuristics from
		// JavaScript and Ruby.
		Lexer.prototype.regexToken = function (){
			var ary;
			var match,length,prev;
			
			if (this._chunk.charAt(0) != '/') { return 0 };
			if (match = HEREGEX.exec(this._chunk)) {
				length = this.heregexToken(match);
				this.moveHead(match[0]);
				return length;
			};
			
			prev = last(this._tokens);
			// FIX
			if (prev && (idx$(tT(prev),(prev.spaced ? (
				NOT_REGEX
			) : (
				NOT_SPACED_REGEX
			))) >= 0)) { return 0 };
			if (!(match = REGEX.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
			
			// FIXME
			// if regex[..1] is '/*'
			//	error 'regular expressions cannot begin with `*`'
			
			if (regex == '//') {
				regex = '/(?:)/';
			};
			
			this.token('REGEX',("" + regex + flags),m.length);
			return m.length;
		};
		
		// Matches multiline extended regular expressions.
		// The escaping should rather happen in AST - possibly as an additional flag?
		Lexer.prototype.heregexToken = function (match){
			var ary;
			var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
			
			if (0 > body.indexOf('#{')) {
				
				var re = body.replace(HEREGEX_OMIT,'').replace(/\//g,'\\/');
				
				if (re.match(/^\*/)) {
					this.error('regular expressions cannot begin with `*`');
				};
				
				this.token('REGEX',("/" + (re || '(?:)') + "/" + flags),heregex.length);
				return heregex.length;
			};
			
			// use more basic regex type
			
			this.token('CONST','RegExp');
			this._tokens.push(T.token('CALL_START','(',0));
			var tokens = [];
			
			for (var i = 0, items = iter$(this.interpolateString(body,{regex: true})), len = items.length, pair; i < len; i++) {
				
				pair = items[i];
				var tok = tT(pair); // FIX
				var value = tV(pair); // FIX
				
				if (tok == 'TOKENS') {
					// FIXME what is this?
					tokens.push.apply(tokens,value);
				} else {
					if (!value) {
						console.log("what??");
					};
					
					if (!(value = value.replace(HEREGEX_OMIT,''))) { continue; };
					
					value = value.replace(/\\/g,'\\\\');
					tokens.push(T.token('STRING',this.makeString(value,'"',true),0)); // FIX
				};
				
				tokens.push(T.token('+','+',0)); // FIX
			};
			
			tokens.pop();
			
			// FIX
			if (!(tokens[0] && tT(tokens[0]) == 'STRING')) {
				// FIX
				this._tokens.push(T.token('STRING','""'),T.token('+','+'));
			};
			
			this._tokens.push.apply(this._tokens,tokens); // what is this?
			// FIX
			
			if (flags) {
				this._tokens.push(T.token(',',',',0));
				this._tokens.push(T.token('STRING','"' + flags + '"',0));
			};
			
			this.token(')',')',0);
			
			return heregex.length;
		};
		
		// Matches newlines, indents, and outdents, and determines which is which.
		// If we can detect that the current line is continued onto the the next line,
		// then the newline is suppressed:
		//
		//     elements
		//       .each( ... )
		//       .map( ... )
		//
		// Keeps track of the level of indentation, because a single outdent token
		// can close multiple indents, so we need to know how far in we happen to be.
		Lexer.prototype.lineToken = function (){
			var match;
			
			if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
			// should it not pair by itself token('SELECTOR_END','%',0)
			// if @end == '%'
			// 	console.log "pairing selector in lineToken {@chunk.substr(0,10)}"
			// 	# should not need to add anything here?
			// 	pair('%')
			
			var indent = match[0];
			// var brCount = count indent, '\n'
			var brCount = this.moveHead(indent);
			this._seenFor = false;
			// reset column as well?
			
			var prev = last(this._tokens,1);
			var size = indent.length - 1 - indent.lastIndexOf('\n');
			var noNewlines = this.unfinished();
			
			// console.log "noNewlines",noNewlines
			// console.log "lineToken -- ",@chunk.substr(0,10),"--"
			if ((/^\n#\s/).test(this._chunk)) {
				this.addLinebreaks(1);
				return 0;
			};
			
			if (size - this._indebt == this._indent) {
				if (noNewlines) {
					this.suppressNewlines();
				} else {
					this.newlineToken(brCount);
				};
				return indent.length;
			};
			
			if (size > this._indent) {
				if (noNewlines) {
					this._indebt = size - this._indent;
					this.suppressNewlines();
					return indent.length;
				};
				
				if (this.inTag()) {
					// console.log "indent inside tokid?!?"
					// @indebt = size - @indent
					// suppressNewlines()
					return indent.length;
				};
				
				
				var diff = size - this._indent + this._outdebt;
				this.closeDef();
				
				var immediate = last(this._tokens);
				
				if (immediate && tT(immediate) == 'TERMINATOR') {
					tTs(immediate,'INDENT');
					immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
					
					// should rather add to meta somehow?!?
					// tVs(immediate,tV(immediate) + '%|%') # crazy
				} else {
					this.token('INDENT',"" + diff,0);
				};
				
				// console.log "indenting", prev, last(@tokens,1)
				// if prev and prev[0] == 'TERMINATOR'
				//   console.log "terminator before indent??"
				
				// check for comments as well ?
				
				this._indents.push(diff);
				this.pushEnd('OUTDENT');
				// @ends.push 'OUTDENT'
				this._outdebt = this._indebt = 0;
				this.addLinebreaks(brCount);
			} else {
				this._indebt = 0;
				this.outdentToken(this._indent - size,noNewlines,brCount);
				this.addLinebreaks(brCount - 1);
				// console.log "outdent",noNewlines,tokid()
			};
			
			this._indent = size;
			return indent.length;
		};
		
		// Record an outdent token or multiple tokens, if we happen to be moving back
		// inwards past several recorded indents.
		Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
			// here we should also take care to pop / reset the scope-body
			// or context-type for indentation 
			var dent = 0;
			while (moveOut > 0){
				var len = this._indents.length - 1;
				if (this._indents[len] == undefined) {
					moveOut = 0;
				} else if (this._indents[len] == this._outdebt) {
					moveOut -= this._outdebt;
					this._outdebt = 0;
				} else if (this._indents[len] < this._outdebt) {
					this._outdebt -= this._indents[len];
					moveOut -= this._indents[len];
				} else {
					dent = this._indents.pop() - this._outdebt;
					moveOut -= dent;
					this._outdebt = 0;
					
					if (!noNewlines) { this.addLinebreaks(1) };
					
					this.pair('OUTDENT');
					this.token('OUTDENT',"" + dent,0);
				};
			};
			
			if (dent) { this._outdebt -= moveOut };
			
			while (this.lastTokenValue() == ';'){
				this._tokens.pop();
			};
			
			if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
			
			// capping scopes so they dont hang around 
			this._scopes.length = this._indents.length;
			
			var ctx = this.context();
			if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
			this.closeDef();
			return this;
		};
		
		// Matches and consumes non-meaningful whitespace. tokid the previous token
		// as being "spaced", because there are some cases where it makes a difference.
		Lexer.prototype.whitespaceToken = function (){
			var match,nline,prev;
			if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
			prev = last(this._tokens);
			
			// FIX - why oh why?
			if (prev) {
				if (match) {
					prev.spaced = true;
					return match[0].length;
				} else {
					prev.newLine = true;
					return 0;
				};
			};
		};
		
		Lexer.prototype.addNewline = function (){
			return this.token('TERMINATOR','\n');
		};
		
		Lexer.prototype.moveHead = function (str){
			var br = count(str,'\n');
			return br;
		};
		
		
		Lexer.prototype.addLinebreaks = function (count,raw){
			var br;
			
			if (!raw && count == 0) { return this }; // no terminators?
			
			var prev = this._last;
			
			if (!raw) {
				if (count == 1) {
					br = '\n';
				} else if (count == 2) {
					br = '\n\n';
				} else if (count == 3) {
					br = '\n\n\n';
				} else {
					br = repeatString('\n',count);
				};
			};
			// FIX
			if (prev) {
				var t = prev._type; // @lastTyp
				var v = tV(prev);
				
				// we really want to add this
				if (t == 'INDENT') {
					// TODO we want to add to the indent
					// console.log "add the comment to the indent -- pre? {raw} {br}"
					
					var meta = prev._meta || (prev._meta = {pre: '',post: ''});
					meta.post += (raw || br);
					// tVs(v + (raw or br))
					return this;
				} else if (t == 'TERMINATOR') {
					// console.log "already exists terminator {br} {raw}"
					tVs(prev,v + (raw || br));
					return this;
				};
			};
			
			this.token('TERMINATOR',br,0);
			return;
		};
		
		// Generate a newline token. Consecutive newlines get merged together.
		Lexer.prototype.newlineToken = function (lines){
			// console.log "newlineToken"
			while (this.lastTokenValue() == ';'){
				console.log("pop token",this._tokens[this._tokens.length - 1]);
				this._tokens.pop();
			};
			
			this.addLinebreaks(lines);
			
			var ctx = this.context();
			// WARN now import cannot go over multiple lines
			if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
			this.closeDef(); // close def -- really?
			return this;
		};
		
		// Use a `\` at a line-ending to suppress the newline.
		// The slash is removed here once its job is done.
		Lexer.prototype.suppressNewlines = function (){
			if (this.value() == '\\') { this._tokens.pop() };
			return this;
		};
		
		// We treat all other single characters as a token. E.g.: `( ) , . !`
		// Multi-character operators are also literal tokens, so that Jison can assign
		// the proper order of operations. There are some symbols that we tokid specially
		// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
		// parentheses that indicate a method call from regular parentheses, and so on.
		Lexer.prototype.literalToken = function (){
			var match,value;
			if (match = OPERATOR.exec(this._chunk)) {
				value = match[0];
				if (CODE.test(value)) this.tagParameters();
			} else {
				value = this._chunk.charAt(0);
			};
			
			var end1 = this._ends[this._ends.length - 1];
			var end2 = this._ends[this._ends.length - 2];
			
			var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
			
			var tokid = value;
			var prev = last(this._tokens);
			var pt = prev && tT(prev);
			var pv = prev && tV(prev);
			var length = value.length;
			
			// is this needed?
			if (value == '=' && prev) {
				
				if (pv == '||' || pv == '&&') { // in ['||', '&&']
					tTs(prev,'COMPOUND_ASSIGN');
					tVs(prev,pv + '=');
					// prev[0] = 'COMPOUND_ASSIGN'
					// prev[1] += '='
					return value.length;
				};
			};
			
			if (value == ';') {
				this._seenFor = false;
				tokid = 'TERMINATOR';
			} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
				// console.log 'spaced before ( in tokid'
				// FIXME - should rather add a special token like TAG_PARAMS_START
				this.token(',',',');
			} else if (value == '->' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '/>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && this.context() == 'DEF') {
				// console.log('picked up >!!')
				tokid = 'DEF_FRAGMENT';
				
				// elif value is 'TERMINATOR' and end1 is '%' 
				// 	closeSelector()
			} else if (value == 'TERMINATOR' && end1 == 'DEF') {
				this.closeDef();
			} else if (value == '&' && this.context() == 'DEF') {
				// console.log("okay!")
				tokid = 'BLOCK_ARG';
				// change the next identifier instead?
			} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
				tokid = "SPLAT";
			} else if (value == '') {
				tokid = 'SQRT';
			} else if (value == '') {
				tokid = 'FUNC';
			} else if (idx$(value,MATH) >= 0) {
				tokid = 'MATH';
			} else if (idx$(value,COMPARE) >= 0) {
				tokid = 'COMPARE';
			} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
				tokid = 'COMPOUND_ASSIGN';
			} else if (idx$(value,UNARY) >= 0) {
				tokid = 'UNARY';
			} else if (idx$(value,SHIFT) >= 0) {
				tokid = 'SHIFT';
			} else if (idx$(value,LOGIC) >= 0) {
				tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
			} else if (prev && !prev.spaced) {
				// need a better way to do these
				if (value == '(' && end1 == '%') {
					tokid = 'TAG_ATTRS_START';
				} else if (value == '(' && idx$(pt,CALLABLE) >= 0) {
					// not using this ???
					// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
					tokid = 'CALL_START';
				} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
					tokid = 'INDEX_START';
					if (pt == '?') { tTs(prev,'INDEX_SOAK') };
					// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
				};
			};
			
			switch (value) {
				case '(':
				case '{':
				case '[':
					this.pushEnd(INVERSES[value]);break;
				
				case ')':
				case '}':
				case ']':
					this.pair(value);break;
			
			};
			
			// hacky rule to try to allow for tuple-assignments in blocks
			// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
			//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
			//   console.log("found comma")
			
			this.token(tokid,value,value.length);
			return value.length;
		};
		
		// Token Manipulators
		// ------------------
		
		// Sanitize a heredoc or herecomment by
		// erasing all external indentation on the left-hand side.
		Lexer.prototype.sanitizeHeredoc = function (doc,options){
			var match;
			var indent = options.indent;
			var herecomment = options.herecomment;
			
			if (herecomment) {
				if (HEREDOC_ILLEGAL.test(doc)) {
					this.error("block comment cannot contain '*/' starting");
				};
				if (doc.indexOf('\n') <= 0) { return doc };
			} else {
				var length_;while (match = HEREDOC_INDENT.exec(doc)){
					var attempt = match[1];
					if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
						indent = attempt;
					};
				};
			};
			
			if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
			if (!herecomment) { doc = doc.replace(/^\n/,'') };
			return doc;
		};
		
		// A source of ambiguity in our grammar used to be parameter lists in function
		// definitions versus argument lists in function calls. Walk backwards, tokidging
		// parameters specially in order to make things easier for the parser.
		Lexer.prototype.tagParameters = function (){
			var tok;
			if (this.lastTokenType() != ')') { return this };
			var stack = [];
			var tokens = this._tokens;
			var i = tokens.length;
			
			tTs(tokens[--i],'PARAM_END');
			
			while (tok = tokens[--i]){
				var t = tT(tok);
				switch (t) {
					case ')':
						stack.push(tok);
						break;
					
					case '(':
					case 'CALL_START':
						if (stack.length) {
							stack.pop();
						} else if (t == '(') {
							tTs(tok,'PARAM_START');
							return this;
						} else {
							return this;
						};
						break;
				
				};
			};
			
			return this;
		};
		
		// Close up all remaining open blocks at the end of the file.
		Lexer.prototype.closeIndentation = function (){
			// ctx = context
			// pair(ctx) if ctx in ['%','DEF']
			this.closeDef();
			this.closeSelector();
			return this.outdentToken(this._indent,false,0);
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedString = function (str,end){
			var match,letter,prev;
			
			// console.log 'balancing string!', str, end
			var stack = [end];
			var i = 0;
			
			// could it not happen here?
			while (i < (str.length - 1)){
				i++;
				letter = str.charAt(i);
				switch (letter) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							var v = str.slice(0,i + 1);
							return v;
						};
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				
				if (end == '}' && (letter == '"' || letter == "'")) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
					i += match[0].length - 1;
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == '"' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter;
			};
			
			if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
		};
		
		// Expand variables and expressions inside double-quoted strings using
		// Ruby-like notation for substitution of arbitrary expressions.
		//
		//     "Hello #{name.capitalize()}."
		//
		// If it encounters an interpolation, this method will recursively create a
		// new Lexer, tokenize the interpolated contents, and merge them into the
		// token stream.
		Lexer.prototype.interpolateString = function (str,options){
			// console.log "interpolate string"
			if(options === undefined) options = {};
			var heredoc = options.heredoc;
			var quote = options.quote;
			var regex = options.regex;
			var prefix = options.prefix;
			
			var startLoc = this._loc;
			var tokens = [];
			var pi = 0;
			var i = -1;
			var locOffset = options.offset || 1;
			var strlen = str.length;
			var letter;
			var expr;
			
			var isInterpolated = false;
			// out of bounds
			while (letter = str.charAt(i += 1)){
				if (letter == '\\') {
					i += 1;
					continue;
				};
				
				if (!(str.charAt(i) == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
					continue;
				};
				
				isInterpolated = true;
				
				// these have no real sense of location or anything?
				if (pi < i) {
					// this is the prefix-string - before any item
					var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
					// tok.@loc = @loc + pi
					// tok.@len = i - pi + 2
					tokens.push(tok);
				};
				
				tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
				
				var inner = expr.slice(1,-1);
				// console.log 'inner is',inner
				// remove leading spaces 
				// need to keep track of how much whitespace we dropped from the start
				inner = inner.replace(/^[^\n\S]+/,'');
				
				if (inner.length) {
					// we need to remember the loc we start at
					// console.log('interpolate from loc',@loc,i)
					// really? why not just add to the stack??
					// what about the added 
					// should share with the selector no?
					// console.log "tokenize inner parts of string",inner
					var spaces = 0;
					var offset = this._loc + i + (expr.length - inner.length) - 1;
					// why create a whole new lexer? Should rather reuse one
					// much better to simply move into interpolation mode where
					// we continue parsing until we meet unpaired }
					var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
					// console.log nested.pop
					
					if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
						nested.shift();
					};
					
					if (nested.length) {
						tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
					};
				};
				
				// should rather add the amount by which our lexer has moved?
				i += expr.length - 1;
				tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
				pi = i + 1;
			};
			
			// adding the last part of the string here
			if (i >= pi && pi < str.length) {
				// set the length as well - or?
				// the string after?
				// console.log 'push neostring'
				tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
			};
			
			// console.log tokens:length
			if (regex) { return tokens };
			
			if (!tokens.length) { return this.token('NEOSTRING','""') };
			
			for (var j = 0, len = tokens.length; j < len; j++) {
				this._tokens.push(tokens[j]);
			};
			
			return tokens;
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedSelector = function (str,end){
			var prev;
			var letter;
			var stack = [end];
			// FIXME
			for (var len = str.length, i = 1; i < len; i++) {
				switch (letter = str.charAt(i)) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							return str.slice(0,i + 1);
						};
						
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				if (end == '}' && letter == [')']) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == ')' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter; // what, why?
			};
			
			return this.error(("missing " + (stack.pop()) + ", starting"));
		};
		
		// Pairs up a closing token, ensuring that all listed pairs of tokens are
		// correctly balanced throughout the course of the token stream.
		Lexer.prototype.pair = function (tok){
			var wanted = last(this._ends);
			if (tok != wanted) {
				if ('OUTDENT' != wanted) { this.error(("unmatched " + tok)) };
				var size = last(this._indents);
				this._indent -= size;
				this.outdentToken(size,true,0);
				return this.pair(tok);
			};
			return this.popEnd();
		};
		
		
		// Helpers
		// -------
		
		// Add a token to the results, taking note of the line number.
		Lexer.prototype.token = function (id,value,len,offset){
			this._lastTyp = id;
			this._lastVal = value;
			var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
			this._tokens.push(tok);
			return;
		};
		
		Lexer.prototype.lastTokenType = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (tT(token)) : ('NONE');
		};
		
		Lexer.prototype.lastTokenValue = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (token._value) : ('');
		};
		
		// Peek at a tokid in the current token stream.
		Lexer.prototype.tokid = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tTs(tok,val) };
				return tT(tok);
				// tok.@type = tokid if tokid # why?
				// tok.@type
			} else {
				return null;
			};
		};
		
		// Peek at a value in the current token stream.
		Lexer.prototype.value = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tVs(tok,val) };
				return tV(tok);
				// tok.@value = val if val # why?
				// tok.@value
			} else {
				return null;
			};
		};
		
		
		// Are we in the midst of an unfinished expression?
		Lexer.prototype.unfinished = function (){
			if (LINE_CONTINUER.test(this._chunk)) { return true };
			return UNFINISHED.indexOf(this._lastTyp) >= 0;
		};
		
		// var tokens = ['\\','.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'THROW', 'EXTENDS']
		
		// Converts newlines for string literals.
		Lexer.prototype.escapeLines = function (str,heredoc){
			return str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
		};
		
		// Constructs a string token by escaping quotes and newlines.
		Lexer.prototype.makeString = function (body,quote,heredoc){
			if (!body) { return quote + quote };
			body = body.replace(/\\([\s\S])/g,function(match,contents) {
				return (contents == '\n' || contents == quote) ? (contents) : (match);
			});
			// Does not work now
			body = body.replace(RegExp(("" + quote),"g"),'\\$&');
			return quote + this.escapeLines(body,heredoc) + quote;
		};
		
		// Throws a syntax error on the current `@line`.
		Lexer.prototype.error = function (message,len){
			if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
			
			if (len) {
				message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
			};
			
			var err = new SyntaxError(message);
			err.line = this._line;
			// err:columnNumber
			err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
			err.region = [this._loc,this._loc + (len || 0)];
			throw err;
		};
		return Lexer;
	
	})()

/***/ },
/* 31 */
/***/ function(module, exports) {

	(function(){
		var TOK, LBRACKET, RBRACKET, LPAREN, RPAREN, INDENT, OUTDENT;
		
		
		module.exports.TOK = TOK = {};
		var TTERMINATOR = TOK.TERMINATOR = 1;
		var TIDENTIFIER = TOK.IDENTIFIER = 2;
		TIDENTIFIER = TOK.IVAR = 2;
		var CONST = TOK.CONST = 3;
		var VAR = TOK.VAR = 4;
		var IF = TOK.IF = 5;
		var ELSE = TOK.ELSE = 6;
		var DEF = TOK.DEF = 7;
		
		
		
		function Token(type,value,loc,len){
			this._type = type;
			this._value = value;
			this._loc = loc != null ? (loc) : (-1);
			this._len = len || 0;
			this._meta = null;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.traverse = function (){
			return;
		};
		
		Token.prototype.c = function (){
			return "" + this._value;
		};
		
		Token.prototype.toString = function (){
			return this._value;
		};
		
		Token.prototype.charAt = function (i){
			return this._value.charAt(i);
		};
		
		Token.prototype.slice = function (i){
			return this._value.slice(i);
		};
		
		Token.prototype.region = function (){
			return [this._loc,this._loc + (this._len || this._value.length)];
		};
		
		Token.prototype.sourceMapMarker = function (){
			return this._loc == -1 ? (':') : (("%$" + (this._loc) + "$%"));
			// @col == -1 ? '' : "%%{@line}${@col}%%"
		};
		
		
		function lex(){
			var token = this.tokens[this.pos++];
			var ttag;
			
			if (token) {
				ttag = token._type;
				this.yytext = token;
			} else {
				ttag = '';
			};
			
			return ttag;
		}; exports.lex = lex;
		
		
		// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
		function token(typ,val){
			return new Token(typ,val,-1,0);
		}; exports.token = token;
		
		function typ(tok){
			return tok._type;
		}; exports.typ = typ;
		function val(tok){
			return tok._value;
		}; exports.val = val; // tok[offset + 1]
		function line(tok){
			return tok._line;
		}; exports.line = line; // tok[offset + 2]
		function loc(tok){
			return tok._loc;
		}; exports.loc = loc; // tok[offset + 2]
		
		function setTyp(tok,v){
			return tok._type = v;
		}; exports.setTyp = setTyp;
		function setVal(tok,v){
			return tok._value = v;
		}; exports.setVal = setVal;
		function setLine(tok,v){
			return tok._line = v;
		}; exports.setLine = setLine;
		function setLoc(tok,v){
			return tok._loc = v;
		}; exports.setLoc = setLoc;
		
		
		module.exports.LBRACKET = LBRACKET = new Token('{','{',0,0,0);
		module.exports.RBRACKET = RBRACKET = new Token('}','}',0,0,0);
		
		module.exports.LPAREN = LPAREN = new Token('(','(',0,0,0);
		module.exports.RPAREN = RPAREN = new Token(')',')',0,0,0);
		
		LBRACKET.generated = true;
		RBRACKET.generated = true;
		LPAREN.generated = true;
		RPAREN.generated = true;
		
		module.exports.INDENT = INDENT = new Token('INDENT','2',0,0,0);
		return module.exports.OUTDENT = OUTDENT = new Token('OUTDENT','2',0,0,0);
	
	})()

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var INVERSES, LINEBREAKS;
		
		// The Imba language has a good deal of optional syntax, implicit syntax,
		// and shorthand syntax. This can greatly complicate a grammar and bloat
		// the resulting parse table. Instead of making the parser handle it all, we take
		// a series of passes over the token stream, using this **Rewriter** to convert
		// shorthand into the unambiguous long form, add implicit indentation and
		// parentheses, and generally clean things up.
		
		var T = __webpack_require__(31);
		var Token = T.Token;
		
		// Based on the original rewriter.coffee from CoffeeScript
		function Rewriter(){ };
		
		exports.Rewriter = Rewriter; // export class 
		Rewriter.prototype.tokens = function (){
			return this._tokens;
		};
		
		// Helpful snippet for debugging:
		//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
		// Rewrite the token stream in multiple passes, one logical filter at
		// a time. This could certainly be changed into a single pass through the
		// stream, with a big ol' efficient switch, but it's much nicer to work with
		// like this. The order of these passes matters -- indentation must be
		// corrected before implicit parentheses can be wrapped around blocks of code.
		Rewriter.prototype.rewrite = function (tokens,opts){
			var token;
			if(opts === undefined) opts = {};
			this._tokens = tokens;
			this._options = opts;
			
			// console.log "tokens in: " + tokens:length
			if (opts.profile) { console.time("tokenize:rewrite") };
			
			var i = 0;
			// flag empty methods
			while (token = tokens[i]){
				var next = tokens[i + 1];
				if (token._type == 'DEF_BODY' && next && next._type == 'TERMINATOR') {
					token._type = 'DEF_EMPTY';
				};
				i++;
			};
			
			this.step("ensureFirstLine");
			this.step("removeLeadingNewlines");
			this.step("removeMidExpressionNewlines");
			this.step("tagDefArguments");
			this.step("closeOpenCalls");
			this.step("closeOpenIndexes");
			this.step("closeOpenTags");
			this.step("closeOpenTagAttrLists");
			this.step("addImplicitIndentation");
			this.step("tagPostfixConditionals");
			this.step("addImplicitBraces");
			this.step("addImplicitParentheses");
			
			if (opts.profile) { console.timeEnd("tokenize:rewrite") };
			// console.log "tokens out: " + @tokens:length
			return this._tokens;
		};
		
		Rewriter.prototype.step = function (fn){
			if (this._options.profile) {
				console.log(("---- starting " + fn + " ---- "));
				console.time(fn);
			};
			
			this[fn]();
			
			if (this._options.profile) {
				console.timeEnd(fn);
				console.log("\n\n");
			};
			return;
		};
		
		// Rewrite the token stream, looking one token ahead and behind.
		// Allow the return value of the block to tell us how many tokens to move
		// forwards (or backwards) in the stream, to make sure we don't miss anything
		// as tokens are inserted and removed, and the stream changes length under
		// our feet.
		Rewriter.prototype.scanTokens = function (block){
			var token;
			var tokens = this._tokens;
			
			var i = 0;
			while (token = tokens[i]){
				i += block.call(this,token,i,tokens);
			};
			
			return true;
		};
		
		Rewriter.prototype.detectEnd = function (i,condition,action){
			var tokens = this._tokens;
			var levels = 0;
			var starts = [];
			var token;
			var t,v;
			
			while (token = tokens[i]){
				if (levels == 0 && condition.call(this,token,i,starts)) {
					return action.call(this,token,i);
				};
				if (!token || levels < 0) {
					return action.call(this,token,i - 1);
				};
				
				t = T.typ(token);
				
				if (EXPRESSION_START.indexOf(t) >= 0) {
					if (levels == 0) { starts.push(i) };
					levels += 1;
				} else if (EXPRESSION_END.indexOf(t) >= 0) {
					levels -= 1;
				};
				i += 1;
			};
			return i - 1;
		};
		
		Rewriter.prototype.ensureFirstLine = function (){
			var tok = this._tokens[0];
			
			if (T.typ(tok) == 'TERMINATOR') {
				// console.log "adding bodystart"
				this._tokens = [T.token('BODYSTART','BODYSTART')].concat(this._tokens);
				// T.setTyp(tok,'HEADER')
			};
			return;
		};
		
		// Leading newlines would introduce an ambiguity in the grammar, so we
		// dispatch them here.
		Rewriter.prototype.removeLeadingNewlines = function (){
			var at = 0;
			
			for (var i = 0, ary = iter$(this._tokens), len = ary.length; i < len; i++) {
				if (T.typ(ary[i]) != 'TERMINATOR') {
					at = i;break;
				};
			};
			
			if (at) { this._tokens.splice(0,at) };
			
			return;
		};
		
		// Some blocks occur in the middle of expressions -- when we're expecting
		// this, remove their trailing newlines.
		Rewriter.prototype.removeMidExpressionNewlines = function (){
			var self = this;
			return self.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
				var next = self.tokenType(i + 1);
				
				if (!(T.typ(token) == 'TERMINATOR' && EXPRESSION_CLOSE.indexOf(next) >= 0)) { return 1 };
				if (next == 'OUTDENT') { return 1 };
				tokens.splice(i,1);
				return 0;
			});
		};
		
		
		Rewriter.prototype.tagDefArguments = function (){
			return true;
		};
		
		// The lexer has tagged the opening parenthesis of a method call. Match it with
		// its paired close. We have the mis-nested outdent case included here for
		// calls that close on the same line, just before their outdent.
		Rewriter.prototype.closeOpenCalls = function (){
			var self = this;
			var condition = function(token,i) {
				var t = T.typ(token);
				return (t == ')' || t == 'CALL_END') || t == 'OUTDENT' && self.tokenType(i - 1) == ')';
			};
			
			var action = function(token,i) {
				var t = T.typ(token);
				var tok = self._tokens[t == 'OUTDENT' ? (i - 1) : (i)];
				return T.setTyp(tok,'CALL_END');
			};
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'CALL_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close.
		Rewriter.prototype.closeOpenIndexes = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[']','INDEX_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'INDEX_END'); };
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		
		Rewriter.prototype.closeOpenTagAttrLists = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[')','TAG_ATTRS_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_ATTRS_END'); }; // 'TAG_ATTRS_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_ATTRS_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close. Should be done in lexer directly
		Rewriter.prototype.closeOpenTags = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['>','TAG_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_END'); }; // token[0] = 'TAG_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		Rewriter.prototype.addImplicitCommas = function (){
			return;
		};
		
		Rewriter.prototype.addImplicitBlockCalls = function (){
			var token;
			var i = 1;
			var tokens = this._tokens;
			
			while (token = tokens[i]){
				var t = token._type;
				var v = token._value;
				// hmm
				if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
					tokens.splice(i + 1,0,T.token('CALL_END',')'));
					tokens.splice(i + 1,0,T.token('CALL_START','('));
					i++;
				};
				i++;
			};
			
			return;
		};
		
		// Object literals may be written with implicit braces, for simple cases.
		// Insert the missing braces here, so that the parser doesn't have to.
		Rewriter.prototype.addImplicitBraces = function (){
			var self = this;
			var stack = [];
			var start = null;
			var startIndent = 0;
			var startIdx = null;
			
			var noBraceTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			var noBraceContext = ['IF','TERNARY','FOR'];
			
			var noBrace = false;
			
			var scope = function() {
				return stack[stack.length - 1] || [];
			};
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var open = function(token,i) {
				return self._tokens.splice(i,0,T.LBRACKET);
			};
			
			var close = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var stackToken = function(a,b) {
				return [a,b];
			};
			
			return self.scanTokens(function(token,i,tokens) {
				var type = T.typ(token);
				var v = T.val(token);
				var ctx = stack[stack.length - 1] || [];
				var idx;
				
				if (noBraceContext.indexOf(type) >= 0) {
					// console.log "found noBraceTag {type}"
					stack.push(stackToken(type,i));
					return 1;
				};
				
				if (v == '?') {
					// console.log('TERNARY OPERATOR!')
					stack.push(stackToken('TERNARY',i));
					return 1;
				};
				
				// no need to test for this here as well as in
				if (EXPRESSION_START.indexOf(type) >= 0) {
					if (type == 'INDENT' && noBraceContext.indexOf(ctx[0]) >= 0) {
						stack.pop();
					};
					
					// console.log('expression start',type,ctx[0])
					if (type == 'INDENT' && self.tokenType(i - 1) == '{') {
						// stack ?!? no token
						stack.push(stackToken('{',i)); // should not autogenerate another?
					} else {
						stack.push(stackToken(type,i));
					};
					return 1;
				};
				
				if (EXPRESSION_END.indexOf(type) >= 0) {
					// console.log "EXPRESSION_END at {type} - stack is {ctx[0]}"
					if (ctx[0] == 'TERNARY') { // FIX?
						stack.pop();
					};
					
					start = stack.pop();
					if (!start) {
						console.log("NO STACK!!");
					};
					start[2] = i;
					
					// seems like the stack should use tokens, no?)
					if (start[0] == '{' && start.generated) { //  # type != '}' # and start:generated
						close(token,i);
						return 1;
					};
					
					return 1;
				};
				
				// is this correct? same for if/class etc?
				if (ctx[0] == 'TERNARY' && (type == 'TERMINATOR' || type == 'OUTDENT')) {
					stack.pop();
					return 1;
				};
				
				if (noBraceContext.indexOf(ctx[0]) >= 0 && type == 'INDENT') {
					console.log("popping noBraceContext");
					stack.pop();
					return 1;
				};
				
				
				if (type == ',') {
					// automatically add an ending here if inside:generated scope?
					// it is important that this is:generated(!)
					if (ctx[0] == '{' && ctx.generated) {
						tokens.splice(i,0,T.RBRACKET);
						stack.pop();
						return 2;
					} else {
						return 1;
					};
					true;
				};
				
				// found a type
				if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
					// could just check if the end was right before this?
					
					if (start && start[2] == i - 1) {
						// console.log('this expression was just ending before colon!')
						idx = start[1] - 1; // these are the stackTokens
					} else {
						// console.log "rewrite here? #{i}"
						idx = i - 2; // if start then start[1] - 1 else i - 2
						// idx = idx - 1 if tokenType(idx) is 'TERMINATOR'
					};
					
					while (self.tokenType(idx - 1) == 'HERECOMMENT'){
						idx -= 2;
					};
					
					var t0 = tokens[idx - 1];
					
					if (t0 && T.typ(t0) == '}' && t0.generated) {
						tokens.splice(idx - 1,1);
						var s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
						tokens.splice(idx - 2,1);
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else {
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						open(token,idx + 1);
						return 2;
					};
				};
				
				// we probably need to run through autocall first?!
				
				if (type == 'DO') { // and ctx:generated
					var prev = T.typ(tokens[i - 1]); // [0]
					if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
						
						var tok = T.token(',',',');
						tok.generated = true;
						tokens.splice(i,0,tok);
						
						if (ctx.generated) {
							close(token,i);
							stack.pop();
							return 2;
						};
					};
				};
				
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'DEF_BODY') && ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
				
				return 1;
			});
		};
		
		// Methods may be optionally called without parentheses, for simple cases.
		// Insert the implicit parentheses here, so that the parser doesn't have to
		// deal with them.
		// Practically everything will now be callable this way (every identifier)
		Rewriter.prototype.addImplicitParentheses = function (){
			
			var self = this, token;
			var noCallTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.token('CALL_END',')'));
			};
			
			// console.log "adding implicit parenthesis" # ,self:scanTokens
			var tokens = self._tokens;
			
			var noCall = false;
			var seenFor = false;
			var endCallAtTerminator = false;
			
			var i = 0;
			while (token = tokens[i]){
				
				// to handle cases like:
				// if a(do yes).test
				// 	yes
				// we need to keep a stack for balanced pairs
				// until then you must explicitly end the call like
				// if a(do yes).test()
				// 	yes
				
				var type = token._type;
				
				var prev = tokens[i - 1];
				var current = tokens[i];
				var next = tokens[i + 1];
				
				var pt = prev && prev._type;
				var nt = next && next._type;
				
				// if pt == 'WHEN'
				// Never make these tags implicitly call
				// should we not just remove these from IMPLICIT_FUNC?
				if ((pt == ')' || pt == ']') && type == 'INDENT') {
					noCall = true;
				};
				
				if (noCallTag.indexOf(pt) >= 0) {
					// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
					endCallAtTerminator = true;
					noCall = true;
					if (pt == 'FOR') { seenFor = true };
				};
				
				
				var callObject = false;
				var callIndent = false;
				
				// [prev, current, next] = tokens[i - 1 .. i + 1]
				
				// check for comments
				// console.log "detect end??"
				if (!noCall && type == 'INDENT' && next) {
					var prevImpFunc = pt && IMPLICIT_FUNC.indexOf(pt) >= 0;
					var nextImpCall = nt && IMPLICIT_CALL.indexOf(nt) >= 0;
					callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
					callIndent = nextImpCall && prevImpFunc;
				};
				
				var seenSingle = false;
				var seenControl = false;
				// Hmm ?
				
				// this is not correct if this is inside a block,no?
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'INDENT')) {
					endCallAtTerminator = false;
					noCall = false;
				};
				
				if (type == '?' && prev && !prev.spaced) { token.call = true };
				
				// where does fromThem come from?
				if (token.fromThen) {
					i += 1;continue;
				};
				// here we deal with :spaced and :newLine
				if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC.indexOf(pt) >= 0) && (IMPLICIT_CALL.indexOf(type) >= 0 || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
					i += 1;continue;
				};
				
				
				tokens.splice(i,0,T.token('CALL_START','('));
				// console.log "added ( {prev}"
				var cond = function(token,i) {
					var type = T.typ(token);
					if (!seenSingle && token.fromThen) { return true };
					var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
					if (ifelse || type == 'CATCH') { seenSingle = true };
					if (ifelse || type == 'SWITCH' || type == 'TRY') { seenControl = true };
					var prev = self.tokenType(i - 1);
					
					if ((type == '.' || type == '?.' || type == '::') && prev == 'OUTDENT') { return true };
					if (endCallAtTerminator && (type == 'INDENT' || type == 'TERMINATOR')) { return true };
					if ((type == 'WHEN' || type == 'BY') && !seenFor) {
						// console.log "dont close implicit call outside for"
						return false;
					};
					
					var post = tokens[i + 1];
					var postTyp = post && T.typ(post);
					// WTF
					return !token.generated && prev != ',' && (IMPLICIT_END.indexOf(type) >= 0 || (type == 'INDENT' && !seenControl) || (type == 'DOS' && prev != '=')) && (type != 'INDENT' || (self.tokenType(i - 2) != 'CLASS' && IMPLICIT_BLOCK.indexOf(prev) == -1 && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL.indexOf(postTyp) >= 0))));
				};
				
				// The action for detecting when the call should end
				// console.log "detect end??"
				self.detectEnd(i + 1,cond,action);
				if (T.typ(prev) == '?') { T.setTyp(prev,'FUNC_EXIST') };
				i += 2;
				// need to reset after a match
				endCallAtTerminator = false;
				noCall = false;
				seenFor = false;
			};
			
			
			return;
		};
		
		// Because our grammar is LALR(1), it can't handle some single-line
		// expressions that lack ending delimiters. The **Rewriter** adds the implicit
		// blocks, so it doesn't need to. ')' can close a single-line block,
		// but we need to make sure it's balanced.
		Rewriter.prototype.addImplicitIndentation = function (){
			
			
			var self = this, token;
			var i = 0;
			var tokens = self._tokens;
			while (token = tokens[i]){
				var type = T.typ(token);
				var next = self.tokenType(i + 1);
				
				// why are we removing terminators after then? should be able to handle
				if (type == 'TERMINATOR' && next == 'THEN') {
					tokens.splice(i,1);
					continue;
				};
				
				if (type == 'CATCH' && idx$(self.tokenType(i + 2),['OUTDENT','TERMINATOR','FINALLY']) >= 0) {
					tokens.splice.apply(tokens,[].concat([i + 2,0], [].slice.call(self.indentation(token))));
					i += 4;continue;
				};
				
				if (SINGLE_LINERS.indexOf(type) >= 0 && (next != 'INDENT' && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
					
					var starter = type;
					
					var indent = T.token('INDENT','2');
					var outdent = T.OUTDENT;
					// var indent, outdent = indentation(token)
					if (starter == 'THEN') { indent.fromThen = true }; // setting special values for these -- cannot really reuse?
					indent.generated = true;
					// outdent:generated = true
					tokens.splice(i + 1,0,indent);
					
					var condition = function(token,i) {
						var t = T.typ(token);
						return T.val(token) != ';' && SINGLE_CLOSERS.indexOf(t) >= 0 && !(t == 'ELSE' && starter != 'IF' && starter != 'THEN');
					};
					
					var action = function(token,i) {
						var idx = self.tokenType(i - 1) == ',' ? (i - 1) : (i);
						return tokens.splice(idx,0,outdent);
					};
					
					self.detectEnd(i + 2,condition,action);
					if (type == 'THEN') { tokens.splice(i,1) };
				};
				
				i++;
			};
			
			return;
		};
		
		// Tag postfix conditionals as such, so that we can parse them with a
		// different precedence.
		Rewriter.prototype.tagPostfixConditionals = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['TERMINATOR','INDENT']) >= 0; };
			
			return self.scanTokens(function(token,i) {
				var typ = T.typ(token);
				if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
				var original = token;
				self.detectEnd(i + 1,condition,function(token,i) {
					if (T.typ(token) != 'INDENT') { return T.setTyp(original,'POST_' + T.typ(original)) };
				});
				return 1;
			});
		};
		
		// Generate the indentation tokens, based on another token on the same line.
		Rewriter.prototype.indentation = function (token){
			return [T.token('INDENT','2'),T.token('OUTDENT','2')];
		};
		
		// Look up a type by token index.
		Rewriter.prototype.type = function (i){
			// if i < 0 then return null
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// if tok then tok[0] else null
		};
		
		Rewriter.prototype.tokenType = function (i){
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// return tok and tok[0]
		};
		
		// Constants
		// ---------
		
		// List of the token pairs that must be balanced.
		var BALANCED_PAIRS = [
			['(',')'],
			['[',']'],
			['{','}'],
			['{{','}}'],
			['INDENT','OUTDENT'],
			['CALL_START','CALL_END'],
			['PARAM_START','PARAM_END'],
			['INDEX_START','INDEX_END'],
			['TAG_START','TAG_END'],
			['TAG_PARAM_START','TAG_PARAM_END'],
			['TAG_ATTRS_START','TAG_ATTRS_END'],
			['BLOCK_PARAM_START','BLOCK_PARAM_END']
		];
		
		// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
		// look things up from either end.
		module.exports.INVERSES = INVERSES = {};
		
		// The tokens that signal the start/end of a balanced pair.
		// var EXPRESSION_START = []
		// var EXPRESSION_END   = []
		
		for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
			pair = ary[i];
			var left = pair[0];
			var rite = pair[1];
			INVERSES[rite] = left;
			INVERSES[left] = rite;
		};
		
		var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','TAG_PARAM_START','BLOCK_PARAM_START','STRING_START','{{','TAG_START'];
		var EXPRESSION_END = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','TAG_PARAM_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END'];
		
		var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];
		
		// Tokens that indicate the close of a clause of an expression.
		var EXPRESSION_CLOSE = ['CATCH','WHEN','ELSE','FINALLY'].concat(EXPRESSION_END);
		
		// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
		var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
		'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];
		
		// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
		var IMPLICIT_CALL = [
			'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
			'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
			'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
			'FOR','STRING_START','CONTINUE','BREAK'
		]; // '->', '=>', why does it not work with symbol?
		
		var IMPLICIT_INDENT_CALL = [
			'FOR'
		];
		// is not do an implicit call??
		
		var IMPLICIT_UNSPACED_CALL = ['+','-'];
		
		// Tokens indicating that the implicit call must enclose a block of expressions.
		var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 
		
		var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		var LOGIC = ['&&','||','&','|','^'];
		
		// optimize for fixed arrays
		var NO_IMPLICIT_BLOCK_CALL = [
			'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
			'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
		]; // .concat(COMPOUND_ASSIGN)
		
		
		// console.log NO_IMPLICIT_BLOCK_CALL:length
		// NO_IMPLICIT_BLOCK_CALL
		// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']
		
		var IMPLICIT_COMMA = ['DO'];
		
		// Tokens that always mark the end of an implicit call for single-liners.
		var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];
		
		// Single-line flavors of block expressions that have unclosed endings.
		// The grammar can't disambiguate them, so we insert the implicit indentation.
		var SINGLE_LINERS = ['ELSE','TRY','FINALLY','THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR']; // '->', '=>', really?
		var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
		
		// Tokens that end a line.
		return LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT'];
	
	})()

/***/ },
/* 33 */
/***/ function(module, exports) {

	(function(){
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		// create separate error-types with all the logic
		
		function ImbaParseError(e,o){
			this.error = e;
			this.message = e.message;
			this.filename = e.filename;
			this.line = e.line;
			this._options = o || {};
			this;
		};
		
		subclass$(ImbaParseError,Error);
		exports.ImbaParseError = ImbaParseError; // export class 
		ImbaParseError.wrap = function (err){
			// what about the stacktrace?
			return new ImbaParseError(err);
		};
		
		ImbaParseError.prototype.set = function (opts){
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(opts), l = keys.length; i < l; i++){
				this._options[keys[i]] = opts[keys[i]];
			};
			return this;
		};
		
		ImbaParseError.prototype.start = function (){
			var o = this._options;
			var idx = o.pos - 1;
			var tok = o.tokens && o.tokens[idx];
			while (tok && tok._loc == -1){
				tok = o.tokens[--idx];
			};
			return tok;
		};
		
		ImbaParseError.prototype.desc = function (){
			var o = this._options;
			var msg = this.message;
			if (o.token && o.token._loc == -1) {
				return 'Syntax Error';
			} else {
				return msg;
			};
		};
		
		ImbaParseError.prototype.loc = function (){
			var start_;
			return (start_ = this.start()) && start_.region  &&  start_.region();
		};
		
		ImbaParseError.prototype.toJSON = function (){
			var o = this._options;
			var tok = this.start();
			// var tok = o:tokens and o:tokens[o:pos - 1]
			// var loc = tok and [tok.@loc,tok.@loc + (tok.@len or tok.@value:length)] or [0,0]
			// , col: tok.@col, line: tok.@line
			// get the token itself?
			return {warn: true,message: this.desc(),loc: this.loc()};
		};
		return ImbaParseError;
	
	})()

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var Region = __webpack_require__(27).Region;
		
		
		function isWhitespace(str){
			return (/^[\n\t\ ]+$/).test(str);
		}; exports.isWhitespace = isWhitespace;
		
		function commonAncestor(a,b){
			if (a instanceof Array) {
				var arr = a.slice();
				return arr.reduce(function(prev,curr,i) {
					return commonAncestor(prev,curr);
				},arr.shift());
			};
			
			if (!a || !b) { return (a || b) };
			
			a = a._dom || a;
			b = b._dom || b;
			
			while (!a.contains(b)){
				a = a.parentNode;
			};
			while (!b.contains(a)){
				b = b.parentNode;
			};
			
			return tag$wrap(a);
		}; exports.commonAncestor = commonAncestor;
		
		
		var pairs = {
			'"': '"',
			"'": "'",
			'(': ')',
			'<': '>',
			'[': ']',
			'{': '}'
		};
		
		function wrapText(text,open,close){
			close || (close = pairs[open]);
			if (open == "'") { text = text.replace(/\'/g,"\\'") };
			return (open || '') + text + (close || '');
		}; exports.wrapText = wrapText;
		
		
		function stringIsBalanced(str){
			var opens = '[{("\'';
			var closes = ']})"\'';
			var stack = [];
			var i = 0;
			var s,end;
			
			while (s = str[i++]){
				var oid = opens.indexOf(s);
				
				if (s == end) {
					stack.pop();
					end = stack[stack.length - 1];
				} else if (oid >= 0) {
					stack.push(end = closes[oid]);
				};
			};
			
			return stack.length == 0 ? (true) : (false);
		}; exports.stringIsBalanced = stringIsBalanced;
		
		function colToLoc(line,col,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var ci = 0;
			var rci = 0; // real column
			var char$;
			
			if (col == 0) { return 0 };
			
			while (char$ = line[ci++]){
				if (char$ == '\t') {
					var rest = tabsize - rci % tabsize;
					rci += rest;
				} else {
					rci += 1;
				};
				
				if (rci >= col) {
					return ci;
				};
			};
			
			return line.length;
		}; exports.colToLoc = colToLoc;
		
		function colToViewCol(line,col,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var ci = 0;
			var rci = 0; // real column
			var char$;
			
			if (col == 0) { return 0 };
			
			while (char$ = line[ci++]){
				if (char$ == '\t') {
					var rest = tabsize - rci % tabsize;
					if (rest > 3 && col <= rci + 2) { break; };
					rci += rest;
				} else {
					rci += 1;
				};
				
				if (col <= rci) { break; };
			};
			return rci;
		}; exports.colToViewCol = colToViewCol;
		
		function colsForLine(line,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var col = 0;
			var idx = 0;
			var char$;
			while (char$ = line[idx++]){
				if (char$ == '\t') {
					var rest = tabsize - col % tabsize;
					col += rest;
				} else {
					col += 1;
				};
			};
			return col;
		}; exports.colsForLine = colsForLine;
		
		function rowcol(buf,loc,tabsize){
			if(tabsize === undefined) tabsize = 4;
			buf = buf.toString();
			var pos = loc;
			var col = 0;
			var line = 0;
			var char$;
			
			// go back to start of line
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					break;
				};
				pos--;
			};
			
			// get column for slice
			while ((pos < loc) && (char$ = buf[pos])){
				if (char$ == '\t') {
					var rest = tabsize - (col % tabsize);
					col += rest;
				} else {
					col += 1;
				};
				pos++;
			};
			
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					line++;
				};
				pos--;
			};
			
			return [line,col];
		}; exports.rowcol = rowcol;
		
		function increaseIndent(str){
			var reg = /^(\s*(.*\=\s*)?(export |global |extend )?(class|def|tag|unless|if|else|elif|switch|try|catch|finally|for|while|until|do))/;
			var other = /\b(do)\b/;
			return reg.test(str) || other.test(str);
		}; exports.increaseIndent = increaseIndent;
		
		
		function repeatString(str,count){
			return new Array(count + 1).join(str);
		}; exports.repeatString = repeatString;
		
		
		function patchString(orig,str,mode){
			var region;
			var text = orig.toString();
			
			if (mode == 'append') {
				return text + str;
			} else if (mode == 'prepend') {
				return "" + str + text;
			} else {
				if (region = Region.normalize(mode)) {
					// let region = Region.normalize()
					return text.substr(0,region.start()) + str + text.slice(region.end());
				};
			};
		}; exports.patchString = patchString;; return patchString;
		
		
	
	})()

/***/ },
/* 35 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		function HistoryState(data){
			if(data === undefined) data = {};
			this._timestamp = new Date();
			this._data = data;
			this;
		};
		
		
		
		HistoryState.prototype.data = function(v){ return this._data; }
		HistoryState.prototype.setData = function(v){ this._data = v; return this; };
		
		
		HistoryState.prototype.timestamp = function(v){ return this._timestamp; }
		HistoryState.prototype.setTimestamp = function(v){ this._timestamp = v; return this; };
		
		HistoryState.prototype.apply = function (view){
			return this;
		};
		
		HistoryState.prototype.update = function (data){
			this._data = data;
			this._timestamp = new Date();
			return this;
		};
		
		
		function FullHistoryState(){ return HistoryState.apply(this,arguments) };
		
		subclass$(FullHistoryState,HistoryState);
		FullHistoryState.prototype.apply = function (view){
			view.loadState(this._data);
			return this;
		};
		
		function DiffHistoryState(){ return HistoryState.apply(this,arguments) };
		
		subclass$(DiffHistoryState,HistoryState);
		
		
		var types = {};
		
		function Command(params){
			this._params = params;
		};
		
		
		
		Command.prototype.prev = function(v){ return this._prev; }
		Command.prototype.setPrev = function(v){ this._prev = v; return this; };
		
		
		Command.prototype.next = function(v){ return this._next; }
		Command.prototype.setNext = function(v){ this._next = v; return this; };
		
		
		Command.prototype.frame = function(v){ return this._frame; }
		Command.prototype.setFrame = function(v){ this._frame = v; return this; };
		
		Command.sym = function (sym){
			var $0 = arguments, i = $0.length;
			var pars = new Array(i>1 ? i-1 : 0);
			while(i>1) pars[--i - 1] = $0[i];
			this.prototype._symbol = sym;
			this.prototype._signature = pars;
			types[sym] = this;
			return this;
		};
		
		Command.load = function (o){
			var typ = types[o[0]];
			var frame = o[1];
			var cmd = typ.build(o[2]);
			cmd.setFrame(frame);
			return cmd;
		};
		
		Command.build = function (params){
			return new this(params);
		};
		
		Command.prototype.data = function (){
			return this._data;
		};
		
		Command.prototype.params = function (){
			return this._params;
		};
		
		Command.prototype.undo = function (view){
			return this.prev();
		};
		
		Command.prototype.redo = function (view){
			return this;
		};
		
		Command.prototype.enter = function (view){
			return this;
		};
		
		Command.prototype.remove = function (){
			var v_;
			if (this.prev()) { (this.prev().setNext(v_ = this.next()),v_) };
			if (this.next()) { (this.next().setPrev(v_ = this.prev()),v_) };
			return this;
		};
		
		Command.prototype.toJSON = function (){
			return [this._symbol,this._frame || 0,this.params() || []];
		};
		
		function Mark(){ return Command.apply(this,arguments) };
		
		subclass$(Mark,Command);
		Mark.sym('M','value');
		
		
		function Snapshot(params){
			this._code = params[0];
		};
		
		subclass$(Snapshot,Mark);
		Snapshot.sym('S','code');
		
		Snapshot.prototype.params = function (){
			return [this._code];
		};
		
		Snapshot.prototype.redo = function (view){
			console.log('load',this._code);
			view.load(this._code);
			// must repair? what about annotations?
			return this;
		};
		
		function Selection(params){
			this._old = params[0];
			this._new = params[1];
		};
		
		subclass$(Selection,Command);
		Selection.sym('|','old','new');
		
		Selection.load = function (val){
			return new this(val);
		};
		
		Selection.prototype.params = function (){
			return [this._old,this._new];
		};
		
		Selection.prototype.redo = function (view){
			view.caret().set(JSON.parse(this._new));
			return this;
		};
		
		Selection.prototype.enter = function (view){
			this.redo(view);
			return this;
		};
		
		Selection.prototype.undo = function (view){
			// we need to know about the previous selection for this?
			// can either store both - or traverse backwards to the previous
			// command like this
			var old = JSON.parse(this._old);
			console.log('move selection back to old',old,this.data());
			view.caret().set(old);
			return this.prev();
		};
		
		
		function Insert(pars){
			this._point = pars[0];
			this._str = pars[1];
		};
		
		subclass$(Insert,Command);
		Insert.sym('+','point','str');
		
		Insert.prototype.params = function (){
			return [this._point,this._str];
		};
		
		Insert.prototype.redo = function (view){
			console.log('redo Insert');
			return view.insert(this._point,this._str);
		};
		
		Insert.prototype.undo = function (view){
			console.log('undo Insert');
			view.erase([this._point,this._point + this._str.length]);
			return this.prev();
		};
		
		function Erase(params){
			this._region = params[0];
			this._str = params[1];
		};
		
		subclass$(Erase,Command);
		Erase.sym('-','region','str');
		
		Erase.prototype.params = function (){
			return [this._region,this._str];
		};
		
		Erase.prototype.redo = function (view){
			console.log('redo Erase');
			return view.erase(this._region);
		};
		
		Erase.prototype.undo = function (view){
			// if we dont know the text to 
			console.log('undo Erase');
			view.insert(this._region.start(),this._str);
			return this.prev();
		};
		
		
		function History(view){
			this._mode = 'normal';
			this._view = view;
			this._enabled = true;
			this._active = false;
			this.setCurrent(this._seed = new Mark());
			this;
		};
		
		exports.History = History; // export class 
		
		
		History.prototype.mode = function(v){ return this._mode; }
		History.prototype.setMode = function(v){ this._mode = v; return this; };
		
		
		History.prototype.view = function(v){ return this._view; }
		History.prototype.setView = function(v){ this._view = v; return this; };
		
		
		History.prototype.enabled = function(v){ return this._enabled; }
		History.prototype.setEnabled = function(v){ this._enabled = v; return this; };
		
		
		History.prototype.current = function(v){ return this._current; }
		History.prototype.setCurrent = function(v){ this._current = v; return this; };
		
		
		History.prototype.seed = function(v){ return this._seed; }
		History.prototype.setSeed = function(v){ this._seed = v; return this; };
		
		
		History.prototype.tail = function(v){ return this._tail; }
		History.prototype.setTail = function(v){ this._tail = v; return this; }; // is this behind or in the very front?
		
		History.prototype.add = function (item,move,frame){
			if(move === undefined) move = true;
			if(frame === undefined) frame = this.view().frames();
			item.setFrame(frame);
			
			if (this.current()) {
				// if current has a next event
				// this should be detached here?
				item.setPrev(this.current());
				this.current().setNext(item);
			};
			
			if (move) { (this.setCurrent(item),item) };
			return this;
		};
		
		History.prototype.next = function (){
			var current_;
			return (current_ = this.current()) && current_.next  &&  current_.next();
		};
		
		History.prototype.prev = function (){
			var current_;
			return (current_ = this.current()) && current_.prev  &&  current_.prev();
		};
		
		History.prototype.update = function (o){
			return this;
		};
		
		History.prototype.move = function (dir){
			if(dir === undefined) dir = 1;
			return this;
		};
		
		History.prototype.redo = function (){
			var self = this;
			self.apply(function() {
				var res = [];while (self.next()){
					self.next().redo(self.view(),self);
					self.setCurrent(self.next());
					if (self.current() instanceof Mark) { break; };
				};return res;
			});
			return self;
		};
		
		History.prototype.undo = function (){
			var self = this;
			self.apply(function() {
				// should be possible to undo 
				var res = [], v_, current_;while (self.current()){
					if (self.prev()) { (self.setCurrent(v_ = self.current().undo(self.view(),self)),v_) };
					(current_ = self.current()) && current_.enter  &&  current_.enter(self.view(),self);
					if (self.current() instanceof Mark) { break; };
				};return res;
			});
			
			return self;
		};
		
		History.prototype.apply = function (cb){
			this._active = true;
			cb && cb();
			this._active = false;
			return this;
		};
		
		History.prototype.batch = function (cb){
			return this;
		};
		
		History.prototype.enter = function (state){
			state.apply(this.view());
			return this;
		};
		
		History.prototype.onerase = function (reg,str,edit){
			if (this._active) { return this };
			return this.add(new Erase([reg,str]));
		};
		
		History.prototype.oninsert = function (loc,str,edit){
			if (this._active) { return this };
			return this.add(new Insert([loc,str]));
		};
		
		History.prototype.oncaret = function (old,new$){
			if (this._active) { return this };
			return this.add(new Selection([old,new$]));
		};
		
		History.prototype.onload = function (code){
			if (this._active) { return this };
			var mark = new Snapshot([code]);
			return this.add(mark);
		};
		
		History.prototype.mark = function (value){
			if (this._active) { return this };
			var mark = new Mark([value]);
			return this.add(mark);
		};
		
		History.prototype.tick = function (){
			
			var self = this;
			if (self._mode == 'play') {
				// console.log 'plyaing'
				var frame = self.view().frames() - self._offset;
				// console.log 'history.tick will play',frame,next,current
				self.apply(function() {
					var res = [], v_;while (self.next() && self.next().frame() <= frame){
						// console.log 'history.tick play',frame,next,current
						// console.log 'replay frame!'
						self.next().redo(self.view(),self);
						res.push(((self.setCurrent(v_ = self.next()),v_)));
					};return res;
				});
				
				if (!(self.next())) {
					self.setMode('live');
				};
			};
			return self;
		};
		
		History.prototype.play = function (){
			// should probably happen in a different manager
			var self = this;
			var snap = self.seed();
			while (!(!snap || (snap instanceof Snapshot))){
				snap = snap.next();
			};
			
			self._offset = self.view().frames() - snap.frame();
			console.log("playing from seed",snap,self._offset);
			// console.log 'found snapshot?!? -- offset frame',@offset
			self.apply(function() { var v_;
			return (self.setCurrent(v_ = snap.redo(self.view(),self)),v_); });
			self.setMode('play');
			return self;
		};
		
		History.prototype.toJSON = function (){
			var data = [];
			var step = this._seed;
			
			while (step){
				data.push(step.toJSON());
				step = step.next();
			};
			
			return {commands: data};
		};
		
		History.prototype.load = function (data){
			var step = this.seed();
			for (var i = 0, ary = iter$(data.commands), len = ary.length; i < len; i++) {
				var item = Command.load(ary[i]);
				item.setPrev(step);
				step.setNext(item);
				step = item;
				// console.log 'load item',item
			};
			// console.log 'loaded'
			return this;
		};
		return History;
		
		
	
	})()

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		function Logger(view){
			this._enabled = true;
			this._view = view;
			this;
		};
		
		exports.Logger = Logger; // export class 
		
		
		Logger.prototype.enabled = function(v){ return this._enabled; }
		Logger.prototype.setEnabled = function(v){ this._enabled = v; return this; };
		
		
		Logger.prototype.view = function(v){ return this._view; }
		Logger.prototype.setView = function(v){ this._view = v; return this; };
		
		Logger.prototype.log = function (){
			if (this._enabled || (1)) { console.log.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.warn = function (){
			if (this._enabled || (1)) { console.log.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.group = function (name){
			if (this._enabled || (1)) { console.group.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.groupCollapsed = function (){
			if (this._enabled || (1)) { console.groupCollapsed.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.groupEnd = function (){
			if (this._enabled || (1)) { console.groupEnd() };
			return this;
		};
		return Logger;
		
		
	
	})()

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		var self = this;
		var util = __webpack_require__(34);
		
		var specialKeys = {
			8: "backspace",
			9: "tab",
			10: "return",
			13: "return",
			16: "shift",
			17: "ctrl",
			18: "alt",
			19: "pause",
			20: "capslock",
			27: "esc",
			32: "space",
			33: "pageup",
			34: "pagedown",
			35: "end",
			36: "home",
			37: "left",
			38: "up",
			39: "right",
			40: "down",
			45: "insert",
			46: "del",
			59: ";",
			61: "=",
			96: "0",
			97: "1",
			98: "2",
			99: "3",
			100: "4",
			101: "5",
			102: "6",
			103: "7",
			104: "8",
			105: "9",
			106: "*",
			107: "+",
			109: "-",
			110: ".",
			111: "/",
			112: "f1",
			113: "f2",
			114: "f3",
			115: "f4",
			116: "f5",
			117: "f6",
			118: "f7",
			119: "f8",
			120: "f9",
			121: "f10",
			122: "f11",
			123: "f12",
			144: "numlock",
			145: "scroll",
			173: "-",
			186: ";",
			187: "=",
			188: ",",
			189: "-",
			190: ".",
			191: "/",
			192: "`",
			219: "[",
			220: "\\",
			221: "]",
			222: "'"
		};
		
		var shiftNums = {
			"`": "~",
			"1": "!",
			"2": "@",
			"3": "#",
			"4": "$",
			"5": "%",
			"6": "^",
			"7": "&",
			"8": "*",
			"9": "(",
			"0": ")",
			"-": "_",
			"=": "+",
			";": ": ",
			"'": '"',
			",": "<",
			".": ">",
			"/": "?",
			"\\": "|"
		};
		
		function trigger(key,o){
			if (o instanceof Function) {
				o = {command: o};
			};
			o.trigger = key;
			return o;
		};
		
		function combo(keys,o){
			if (o instanceof Function) { o = {command: o} };
			o.keys = keys;
			return o;
		};
		
		IM.KeyBindings = [
			
			combo(['super+z'],function(sel) { return sel.view().history().undo(); }),
			combo(["super+shift+z"],function(sel) { return sel.view().history().redo(); }),
			combo(["alt+super+p"],function(sel) { return sel.view().history().play(); }),
			// combo ["alt+shift+r"] do |sel| sel.view.history.play
			
			combo(["super+s"],{command: "save"}),
			combo(["super+b"],{command: "run"}),
			combo(["alt+super+s"],{command: "saveSession"}),
			combo(["alt+shift+l"],{command: "reparse"}),
			combo(["alt+shift+k"],{command: "reparseExtent"}),
			
			combo(["super+a"],function(sel) { return sel.selectAll(); }),
			
			
			combo(['tab'],{context: function(sel) { return sel.text().indexOf('\n') >= 0; },
			command: function(sel) {
				sel.expandToLines();
				var region = sel.region();
				var nodes = sel.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline')) {
						console.log('found tab in selection',match);
						if (match.mode != 'start') {
							return match.node.indent();
						};
					};
				});
				return sel.dirty();
			}}),
			
			
			
			combo(["shift+tab"],{context: function(sel) { return sel.text().indexOf('\n') >= 0; },
			command: function(sel) {
				sel.expandToLines();
				var region = sel.region();
				var nodes = sel.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						return match.node.undent();
					};
				});
				return sel.dirty();
			}}),
			
			combo(["shift+tab"],{context: function(e) {
				return true; // String(e.view.selection).indexOf('\n') >= 0
			},
			command: function(sel) {
				console.log('try undent');
				return true;
			}}),
			
			combo(["alt+shift+return"],function(sel) { return console.log('prettify'); }),
			
			combo(["backspace"],{context: function(e) {
				console.log('deleteLeftRight backspace?!?',e.region(),e.region().peek(-1,1));
				return idx$(e.region().peek(-1,1),['[]','{}','<>','()','""',"''"]) >= 0;
			},
			
			command: function(sel) {
				console.log('moving!!');
				sel.expand(-1,1);
				return sel.erase();
			}}),
			
			combo(["backspace"],{context: function(sel,o) {
				var reg = sel.region();
				if (reg.size() == 0) {
					if (o.node = reg.prevNode('._impair,._imstr')) {
						return true;
					};
				};
			},
			
			command: function(sel,o) { var v_;
			return (sel.setRegion(v_ = o.node.region().clone().reverse()),v_); }}),
			
			combo(["backspace"],{context: function(sel,o) {
				if (sel.text() && !util.stringIsBalanced(sel.text())) {
					return true;
				};
			},
			command: function(sel,o) { return true; }}),
			
			combo(["backspace"],function(sel) { return sel.erase(); }),
			combo(["shift+backspace"],function(sel) { return sel.erase(); }),
			combo(["alt+backspace"],function(sel) { return sel.erase(IM.WORD_START); }),
			combo(["super+backspace"],function(sel) { return sel.erase(IM.LINE_START); }),
			
			combo(["return",'shift+return','super+return'],function(sel) {
				var ind = sel.indent();
				if (util.increaseIndent(sel.head().peekbehind())) { ind += '\t' };
				
				// should not happen in string
				if (idx$(sel.region().peek(-1,1),['[]','{}','()']) >= 0) {
					sel.insert('\n\t' + ind);
					sel.view().insert(sel.head().loc(),'\n' + ind);
				} else {
					sel.insert('\n' + ind);
				};
				
				return true;
			}),
			
			
			combo(['space','shift+space'],function(sel) {
				if (sel.region().peek(-1,1) == '<>') {
					sel.move(1).erase();
				};
				
				return sel.insert(' ');
			}),
			
			combo(['tab'],function(sel) { return sel.insert('\t'); }),
			
			
			combo(['super+up'],function(sel) {
				sel.collapse().head().set(0,0).normalize();
				return sel.dirty();
			}),
			
			combo(['super+down'],function(sel) {
				sel.collapse().head().set(100000,0).normalize();
				return sel.dirty();
			}),
			
			combo(['super+u'],function(sel,o) {
				console.log(sel.target(),"found ut!!!");
				return console.log(sel.target().bubble('unwrap',{}));
			}),
			
			combo(['alt+super+r'],function() { return window.location.reload(); })
		];
		
		IM.Triggers = [
			
			trigger('|',{context: function(sel) { return sel.region().peek(-1,1) == '||'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger('[',function(sel) { return sel.insert('[$0]'); }),
			trigger('|',function(sel) { return sel.insert('|$0|'); }),
			trigger('(',function(sel) { return sel.insert('($0)'); }),
			trigger('{',function(sel) { return sel.insert('{$0}'); }),
			
			trigger('<',{context: function(sel) { return !sel.peekbehind(/(\b(tag|if|class) |\d\s*$)/); },
			command: function(sel) { return sel.insert('<$0>'); }}),
			
			trigger('"',{context: function(sel,o) {
				if (sel.region().peek(-1,0) == '\\' && (o.node = sel.region().scope(q$('._imstr',self)))) {
					return true;
				};
			},
			command: function(sel) { return sel.insert('"'); }}),
			
			trigger("'",{context: function(sel,o) { return sel.region().peek(-1,1) == "''"; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger("'",{context: function(sel,o) { return o.node = sel.region().scope(q$('._imstr',self)); },
			command: function(sel) { return sel.insert("\\'"); }}),
			
			trigger('"',function(sel) { return sel.insert('"$0"'); }),
			trigger("'",function(sel) { return sel.insert("'$0'"); }),
			
			trigger(']',{context: function(sel) { return sel.region().peek(0,1) == ']'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger('}',{context: function(sel) { return sel.region().peek(0,1) == '}'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger(')',{context: function(sel) { return sel.region().peek(0,1) == ')'; },
			command: function(sel) { return sel.move(1); }})
		];
		
		function ShortcutManager(view,bindings){
			this._view = view;
			this._bindings = bindings || IM.KeyBindings;
			this;
		};
		
		global.ShortcutManager = ShortcutManager; // global class 
		ShortcutManager.prototype.view = function (){
			return this._view;
		};
		
		ShortcutManager.prototype.keysForEvent = function (e){
			var combo = [];
			var special = specialKeys[e.which];
			var chr = special || String.fromCharCode(e.which);
			
			chr = chr.toLowerCase(); // unless e:shiftKey
			
			if (e.ctrlKey && special != 'ctrl') { combo.push('ctrl') };
			if (e.altKey && special != 'alt') { combo.push('alt') };
			if (e.metaKey && !e.ctrlKey && special !== 'meta') { combo.push('super') };
			if (e.shiftKey && special != 'shift') { combo.push('shift') };
			if (combo.indexOf(chr) < 0) { combo.push(chr) };
			
			return combo.join('+');
		};
		
		ShortcutManager.prototype.commandsForKeys = function (combo){
			return this._bindings.filter(function(binding) { return binding.keys == combo; });
		};
		
		ShortcutManager.prototype.getShortcut = function (e){
			var combo = this.keysForEvent(e.event());
			console.log(combo);
			
			for (var i = 0, ary = iter$(this._bindings), len = ary.length, cmd; i < len; i++) {
				cmd = ary[i];
				if (cmd.keys.indexOf(combo) >= 0) {
					var o = {};
					// console.log 'found shortcut',combo,cmd:keys
					if (!cmd.context || cmd.context.call(this.view(),this.view().caret(),o,e,this.view())) {
						cmd.data = o;
						return cmd;
					};
				};
			};
			
			return null;
		};
		
		ShortcutManager.prototype.getTrigger = function (view,text){
			for (var i = 0, ary = iter$(IM.Triggers), len = ary.length, cmd; i < len; i++) {
				cmd = ary[i];
				if (cmd.trigger == text) {
					var res = cmd.context ? (cmd.context.call(view,view.caret(),view,text)) : (true);
					if (res) { return cmd };
				};
			};
			return null;
		};
		return ShortcutManager;
		
		
		
		
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 38 */
/***/ function(module, exports) {

	(function(){
		return tag$.defineTag('imcaptor', 'input', function(tag){
			
			tag.prototype.select = function (){
				if (!this.dom().value) {
					this.dom().value = 'x';
				};
				this.dom().select();
				return this;
			};
			
			tag.prototype.build = function (){
				var self = this;
				tag.__super__.build.apply(self,arguments);
				self.dom().onfocus = function(e) {
					console.log('dom onfocus!!!!');
					var event = Imba.Event.wrap({type: 'inputfocus',target: self.dom()});
					return event.process();
				};
				
				self.dom().onblur = function(e) {
					console.log('dom onblur!!!!',e);
					var event = Imba.Event.wrap({type: 'inputblur',target: self.dom(),relatedTarget: e.relatedTarget});
					return event.process();
					// Imba.Events.trigger('inputblur',dom)
				};
				
				return self;
			};
		});
	
	})()

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// disabling logs for now
		// console:log = do true
		// externs;
		
		var OPEN = ['"',"'",'(','[','{','<'];
		var CLOSE = ['"',"'",')',']','}','>'];
		
		if (Imba.Events) {
			Imba.Events.register(['copy','paste','cut','beforecut','beforepaste','beforecopy','keypress']);
		};
		
		var Logger = __webpack_require__(36).Logger;
		var History = __webpack_require__(35).History;
		var Buffer = __webpack_require__(40).Buffer;
		var Observer = __webpack_require__(41).Observer;
		
		var Region = __webpack_require__(27).Region;
		var hints$ = __webpack_require__(42), Hints = hints$.Hints, Hint = hints$.Hint;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		var util = __webpack_require__(34);
		
		__webpack_require__(43);
		
		__webpack_require__(44);
		
		tag$.defineTag('imdims', function(tag){
			
			tag.prototype.ch = function (){
				// uncache
				if (this._ow != this.dom().offsetWidth) {
					this._ow = this.dom().offsetWidth;
					this._ch = null;
				};
				
				return this._ch || (this._ch = this.dom().getBoundingClientRect().width);
			};
		});
		
		tag$.defineTag('imviewbody');
		
		tag$.defineTag('imview', function(tag){
			
			
			
			tag.prototype.filename = function(v){ return this._filename; }
			tag.prototype.setFilename = function(v){ this._filename = v; return this; };
			
			
			
			tag.prototype.observer = function(v){ return this._observer; }
			tag.prototype.setObserver = function(v){ this._observer = v; return this; };
			
			
			tag.prototype.history = function(v){ return this._history; }
			tag.prototype.setHistory = function(v){ this._history = v; return this; };
			
			
			tag.prototype.hints = function(v){ return this._hints; }
			tag.prototype.setHints = function(v){ this._hints = v; return this; };
			
			
			tag.prototype.logger = function(v){ return this._logger; }
			tag.prototype.setLogger = function(v){ this._logger = v; return this; };
			
			
			tag.prototype.shortcuts = function(v){ return this._shortcuts; }
			tag.prototype.setShortcuts = function(v){ this._shortcuts = v; return this; };
			
			tag.prototype.__focusNode = {watch: 'focusNodeDidSet',name: 'focusNode'};
			tag.prototype.focusNode = function(v){ return this._focusNode; }
			tag.prototype.setFocusNode = function(v){
				var a = this.focusNode();
				if(v != a) { this._focusNode = v; }
				if(v != a) { this.focusNodeDidSet && this.focusNodeDidSet(v,a,this.__focusNode) }
				return this;
			};
			
			
			tag.prototype.caret = function(v){ return this._caret; }
			tag.prototype.setCaret = function(v){ this._caret = v; return this; };
			
			
			tag.prototype.frames = function(v){ return this._frames; }
			tag.prototype.setFrames = function(v){ this._frames = v; return this; };
			
			
			tag.prototype.readonly = function(v){ return this._readonly; }
			tag.prototype.setReadonly = function(v){ this._readonly = v; return this; };
			
			tag.prototype.highlighter = function (){
				return Highlighter;
			};
			
			tag.prototype.lineHeight = function (){
				return this._dims.dom().offsetHeight;
			};
			
			tag.prototype.charWidth = function (){
				return this._dims.ch();
			};
			
			tag.prototype.isReadOnly = function (){
				return this.history().mode() == 'play';
			};
			
			tag.prototype.tabSize = function (){
				return 4;
			};
			
			tag.prototype.build = function (){
				// console.log 'build imview'
				VIEW = this;
				this.setTabindex(0);
				
				this._readonly = false;
				this._logger = new Logger(this);
				this._frames = 0;
				this._changes = 0;
				
				this._hints = new Hints(this);
				this._buffer = new Buffer(this);
				this._history = new History(this);
				this._shortcuts = new ShortcutManager(this);
				this.render();
				this._observer = new Observer(this);
				this.caret().setRegion(new Region(0,0,this.root(),this));
				
				// bind to mousemove of dom?
				
				this.dom().addEventListener('mouseover',function(e) { return Imba.Events.delegate(e); });
				this.dom().addEventListener('mouseout',function(e) { return Imba.Events.delegate(e); });
				return this;
			};
			
			tag.prototype.onmouseover = function (e){
				return e.halt();
			};
			
			tag.prototype.onmouseout = function (e){
				return e.halt();
			};
			
			tag.prototype.setInput = function (input){
				
				if (input != this._input) {
					this._input = input;
					// console.log 'set input!!!',@input
					this._input.dom()._responder = this.dom();
				};
				return this;
			};
			
			tag.prototype.input = function (){
				return this._input || this._caret.input();
			};
			
			// called every frame - looking for changed nodes to deal with
			// to deal with mutations.
			tag.prototype.tick = function (){
				this._frames++;
				this.history().tick();
				this.render();
				if (this._dirty) this.repair();
				return this;
			};
			
			tag.prototype.commit = function (){
				return this.tick();
			};
			
			tag.prototype.log = function (){
				var logger_;
				(logger_ = this.logger()).log.apply(logger_,arguments);
				return this;
			};
			
			tag.prototype.edited = function (){
				var self = this;
				self._changes++;
				self._dirty = true;
				self._buffer.refresh();
				
				self.view().hints().rem(function(hint) {
					return hint.group() == 'runtime';
				});
				
				self.hints().cleanup();
				
				self.delay('didchange',50,function() {
					return Imba.Events.trigger('edited:async',self,{data: self});
				});
				
				// we can improve how/when we choose to annotate.
				// currently we do it after every edit - but it should
				// really only be needed when we have changed identifiers.
				// should also only reannotate the closest known scope,
				// but this comes later with refactoring from whole files
				// to scopes.
				self.delay('annotate',500,function() { return self.annotate(); });
				self.delay('recompile',-1); // cancel recompilation
				return self;
			};
			
			tag.prototype.dirty = function (){
				return this;
			};
			
			tag.prototype.activate = function (){
				this.flag('active');
				return this;
			};
			
			tag.prototype.deactivate = function (){
				this.unflag('active');
				return this;
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$imviewbody().setRef('body',this)).setContent([
					(this._dims = this._dims || tag$.$imdims().setRef('dims',this)).setText("x").end(),
					(this._caret = this._caret || tag$.$imcaret().setRef('caret',this)).setView(this).end(),
					(this._root = this._root || tag$.$imroot().setRef('root',this).flag('imba')).setView(this).end()
				],2).end();
			};
			
			tag.prototype.header = function (){
				return null;
			};
			
			tag.prototype.footer = function (){
				return null;
			};
			
			tag.prototype.overlays = function (){
				return (this._overlays = this._overlays || tag$.$scrimbla_overlays().setRef('overlays',this)).setView(this).end();
			};
			
			tag.prototype.render = function (){
				return this.flag('readonly',this.isReadOnly()).setChildren([
					this.header(),
					this.body(),
					this.footer()
				],1).synced();
			};
			
			tag.prototype.view = function (){
				return this;
			};
			
			tag.prototype.sel = function (){
				return this.caret();
			};
			
			tag.prototype.root = function (){
				return this._root;
			};
			
			tag.prototype.buffer = function (){
				return this._buffer;
				// root.code
			};
			
			tag.prototype.size = function (){
				return this.root().size();
			};
			
			tag.prototype.load = function (code,o){
				var parsed;
				if(o === undefined) o = {};
				this.setFilename(o.filename);
				// console.log 'loading file with filename',o:filename
				// observer.pause do
				if (o.html) {
					this.root().dom().innerHTML = o.html;
					this._buffer.refresh();
					this.history().onload(this.code());
				} else {
					// should use our new parser
					if (parsed = this.parse(code)) {
						if (parsed.highlighted) {
							this.root().dom().innerHTML = parsed.highlighted;
						} else {
							this.root().dom().textContent = code;
						};
					};
					this._buffer.refresh();
					this.history().onload(code);
					this.annotate();
				};
				return this;
			};
			
			tag.prototype.parse = function (code){
				// here we can parse the full code
				return {highlighted: IM.parse(code)};
			};
			
			tag.prototype.refocus = function (){
				if (document.activeElement != this.input().dom()) { this.input().focus() };
				return this;
			};
			
			tag.prototype.oninputfocus = function (e){
				console.log('oninputfocus!!');
				VIEW = this; // hack
				return this.flag('focus');
			};
			
			tag.prototype.oninputblur = function (e){
				return this.unflag('focus');
			};
			
			tag.prototype.onfocusin = function (e){
				VIEW = this; // hack
				this.flag('focus');
				console.log('focus',e);
				return this;
			};
			
			tag.prototype.onfocusout = function (e){
				this.unflag('focus');
				console.log('unfocus',e);
				return this;
			};
			
			tag.prototype.oninput = function (e){
				return this;
			};
			
			tag.prototype.ontextinput = function (e){
				return this;
			};
			
			tag.prototype.execAction = function (action,keydown){
				var command_;
				if (action.command instanceof Function) {
					return action.command.call(this,this.caret(),action.data || {event: keydown},this);
				} else if ((typeof (command_ = action.command)=='string'||command_ instanceof String)) {
					this.log('command is string',action.command);
					var ev = Imba.Events.trigger(action.command,this,{data: action});
					this.log(ev);
					return this;
				};
			};
			
			tag.prototype.tryCommand = function (cmd,target,params){
				if(params === undefined) params = [];
				if (cmd.context) {
					var guard = cmd.context.apply(target || this,params);
					if (!guard) { return false };
				};
				
				if (cmd.command instanceof Function) {
					return cmd.command.apply(target || this,params);
				};
			};
			
			
			
			tag.prototype.onkeydown = function (e){
				var arr;
				VIEW = this; // hack
				e.halt();
				// var combo = e.keycombo
				var combo = this.shortcuts().keysForEvent(e.event());
				var action = this.shortcuts().getShortcut(e);
				var ins = null;
				
				var shift = (/\bshift\b/).test(combo);
				var alt = (/\balt\b/).test(combo);
				var sup = (/\bsuper\b/).test(combo);
				
				// log 'imview keydown',combo
				
				if (action) {
					// console.log 'action here?!',action
					if (this.execAction(action,e)) { e.cancel() };
					return;
				};
				
				// move these into commands as well
				// thisshould move this into commands instead
				if (arr = combo.match(/\b(left|right|up|down)/)) {
					this.hints().activate();
					
					var isCollapsed = this.caret().isCollapsed();
					var ends = this.caret().ends();
					
					shift ? (this.caret().decollapse()) : (this.caret().collapse());
					
					if (arr[0] == 'down') {
						this.caret().moveDown();
						return e.cancel();
					} else if (arr[0] == 'up') {
						this.caret().moveUp();
						return e.cancel();
					};
					
					var mode = IM.CHARACTERS;
					var dir = 0;
					
					if (arr[0] == 'left') {
						dir = -1;
					};
					
					if (arr[0] == 'right') {
						dir = 1;
					};
					
					if (alt) {
						mode = dir > 0 ? (IM.WORD_END) : (IM.WORD_START);
					} else if (sup) {
						mode = dir > 0 ? (IM.LINE_END) : (IM.LINE_START);
					} else if (!shift && !isCollapsed) {
						this.caret().head().set(dir > 0 ? (ends[1]) : (ends[0]));
						this.caret().dirty(); // should not need to call this all the time
						return e.cancel();
					};
					
					this.caret().move(dir,mode);
					
					return e.cancel();
				};
				
				if (e.event().which == 229) {
					return e.halt();
				};
				
				if (combo.match(/^super\+(c|v|x)$/)) {
					// console.log 'matching combo for copy paste'
					e.halt();
					this._awaitCombo = true;
					this.refocus();
					return;
				};
				
				if (ins != null) {
					e.halt().cancel();
					this.caret().insert(ins);
					return this;
				};
				
				return this;
			};
			
			tag.prototype.onkeypress = function (e){
				if (this._awaitCombo) {
					this._awaitCombo = false;
					return e.halt();
				};
				
				e.halt();
				var text = String.fromCharCode(e.event().charCode);
				e._text = text;
				e.cancel();
				this.ontype(e);
				return this;
			};
			
			tag.prototype.ontextinput = function (e){
				e.halt().cancel();
				e._text = e.event().data;
				this.ontype(e);
				return this;
			};
			
			tag.prototype.onkeyup = function (e){
				e.halt();
				return this;
			};
			
			tag.prototype.oninput = function (e){
				e.halt();
				return this;
			};
			
			tag.prototype.ontype = function (e){
				try {
					var ins = e._text;
					// log 'ontype',e,ins
					
					var spans = this.view().nodesInRegion(this.caret().region(),false,true);
					var target = spans[0];
					var cmd;
					
					if (spans.length == 1) {
						// log 'single node for nodesInRegion',target:node
						if (cmd = target.node[("trigger-" + ins)]) {
							// log "found combo for this!??!",cmd
							if (this.tryCommand(cmd,this.caret(),[target.node,target])) {
								return this;
							};
						};
					};
					
					cmd = this.shortcuts().getTrigger(this,ins);
					
					if (cmd && (cmd.command instanceof Function)) {
						// log 'found command!!',cmd
						// should rather run tryCommand?!?
						return cmd.command(this.caret(),this,ins,e);
					} else {
						if (ins) { return this.caret().insert(ins) };
					};
				} catch (e) {
					return this.log('error from ontype');
				};
			};
			
			tag.prototype.onbackspace = function (e){
				e.cancel().halt();
				this.caret().erase();
				return;
			};
			
			tag.prototype.onbeforecopy = function (e){
				if (true) { console.log('onbeforecopy',e) };
				this.input().select();
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				return e.halt();
			};
			
			tag.prototype.oncopy = function (e){
				if (true) { console.log('oncopy',e,this.caret().text()) };
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				e.halt().cancel();
				this.refocus();
				return;
			};
			
			tag.prototype.oncut = function (e){
				if (true) {
					console.log('oncut',e);
				};
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				e.halt().cancel();
				return this.caret().erase();
			};
			
			tag.prototype.onbeforepaste = function (e){
				return console.log('onbeforepaste',e);
			};
			
			tag.prototype.onpaste = function (e){
				console.log('onpaste',e);
				var data = e.event().clipboardData;
				var text = data.getData('text/plain');
				e.halt().cancel();
				this.caret().insert(text);
				this.refocus();
				return this.repair();
				// edit text: data
			};
			
			tag.prototype.refresh = function (){
				// focusNode = sel.node # only if it is inside the scope?
				// caret.region = sel.region
				this.caret().render();
				return this;
			};
			
			tag.prototype.exec = function (o){
				var fn = o.command;
				var args = o.args || [];
				var ev = new Imba.Event({type: 'command',target: this.dom(),data: o});
				ev.setData(o);
				ev.process();
				
				return;
			};
			
			tag.prototype.ontouchstart = function (touch){
				var ary;
				this._rect = this._body.dom().getBoundingClientRect();
				
				if (touch.button() != 0) { return };
				
				if (touch._touch) {
					// is it not redirected?
					return touch.redirect({});
				};
				
				var e = touch.event();
				e.preventDefault();
				// see if shift is down? should change behaviour
				var shift = e.shiftKey;
				// log 'ontouchstart',touch,touch.x,touch.y,e,touch.button
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				
				if (shift) {
					this.caret().selectable();
				} else {
					this.caret().collapse();
				};
				
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				// console.log 'touch start refocus?'
				this.refocus();
				return this;
			};
			
			tag.prototype.xyToRowCol = function (x,y){
				var col = Math.max(Math.round(x / this.charWidth()),0);
				var row = Math.max(Math.ceil(y / this.lineHeight()),1);
				return [row - 1,col];
			};
			
			tag.prototype.rcForTouch = function (touch){
				var x = Math.max(touch.x() - this._rect.left,0);
				var y = Math.max(touch.y() - this._rect.top,0);
				return this.xyToRowCol(x,y);
			};
			
			tag.prototype.ontouchupdate = function (touch){
				var ary;
				if (touch.button() != 0) { return };
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				this.caret().selectable();
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				return this;
			};
			
			tag.prototype.ontouchend = function (touch){
				var ary;
				if (touch.button() != 0) { return };
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				return this;
			};
			
			tag.prototype.erase = function (reg,edit){
				reg = Region.normalize(reg,this);
				
				var text = reg.text();
				this.history().onerase(reg,text,edit);
				
				var spans = this.nodesInRegion(reg,false,true);
				// gropu the nodes
				this.observer().pause(function() {
					if (spans.length > 1) {
						spans[1].node.setPrev(tag$.$iminsert().flag('dirty').end());
					} else if (spans[0] && spans[0].mode == 'all') {
						console.log('removing single node?!');
						var before = spans[0].node.prev();
						
						spans[0].node.setPrev(tag$.$iminsert().flag('dirty').end());
					};
					
					for (var i = 0, ary = iter$(spans), len = ary.length, sel, res = []; i < len; i++) {
						// buffer need to updated during this?
						sel = ary[i];
						res.push(sel.node.erase(sel.region,sel.mode,edit));
					};
					return res;
				});
				
				// delay('annotate',500) do annotate
				return this.erased(reg);
			};
			
			tag.prototype.inserted = function (loc,str){
				console.log('inserted',loc,str);
				var reg = new Region(loc,loc + str.length,null,this);
				for (var i = 0, ary = iter$(this.hints()), len = ary.length; i < len; i++) {
					ary[i].adjust(reg,true);
				};
				// hints.cleanup
				this.edited();
				if (util.isWhitespace(str)) this.repair();
				return this;
			};
			
			tag.prototype.erased = function (reg){
				for (var i = 0, ary = iter$(this.hints()), len = ary.length; i < len; i++) {
					ary[i].adjust(reg,false);
				};
				this.edited();
				return this.repair(); // repair synchronously
			};
			
			tag.prototype.insert = function (point,str,edit){
				if (point instanceof Region) {
					if (point.size() > 0) {
						this.logger().warn('uncollapsed region in insert is not allowed');
					};
					point = point.start();
				};
				
				this.log('insert',point,str);
				// should maybe create this as a command - and then make it happen?
				
				this.history().oninsert(point,str,edit);
				
				// log 'insert in view'
				var spans = this.nodesInRegion(Region.normalize(point,this),false);
				var mid = spans[0];
				var target = mid || spans.prev || spans.next;
				var lft = spans.lft,rgt = spans.rgt;
				var node;
				var reg;
				
				// log spans,mid,lft,rgt
				this.log('before and after',lft,rgt,str);
				
				if (mid) {
					this.log('insert mid',mid.node);
					mid.node.insert(mid.region,str,edit,mid);
				} else {
					
					while (rgt){
						if (rgt.canPrepend(str)) {
							this.log('prepend',rgt,str);
							rgt.insert('prepend',str,edit);
							return this.inserted(point,str);
						} else if (rgt.isFirst()) {
							rgt = rgt.parent();
							continue;
						};
						
						break;
					};
					
					// find the closest parent
					while (lft){
						if (lft.canAppend(str)) {
							this.log('append',lft,str);
							lft.insert('append',str,edit);
							return this.inserted(point,str);
						} else if (lft.isLast()) {
							lft = lft.parent();
							continue;
						};
						
						break;
					};
					
					node = tag$.$iminsert().end();
					
					if (lft) {
						lft.setNext(node);
					} else if (rgt) {
						rgt.setPrev(node);
					} else {
						// must be empty
						this.root().dom().appendChild(node.dom());
					};
					
					node.insert('append',str,edit);
				};
				
				return this.inserted(point,str);
			};
			
			tag.prototype.onmutations = function (){
				return this;
			};
			
			tag.prototype.repair = function (){
				this._dirty = false;
				var els = this.dom().getElementsByClassName('dirty');
				
				if (els.length) {
					// logger.log "{els:length} dirty nodes to repair"
					
					for (var muts = [], i = 0, ary = iter$(els), len = ary.length; i < len; i++) {
						muts.push(tag$wrap(ary[i]));
					};
					
					for (var i = 0, ary = iter$(muts), len = ary.length, mut; i < len; i++) {
						mut = ary[i];
						mut.unflag('dirty');
						mut.mutated(muts);
					};
				};
				return this;
			};
			
			tag.prototype.code = function (){
				return this._root.dom().textContent;
			};
			
			tag.prototype.focusNodeDidSet = function (new$,old){
				if (!this.root().contains(new$)) { return };
				
				var path = [];
				
				while (new$ && new$ != this.root()){
					path.push(new$);
					new$ = new$.parent();
				};
				
				q$('.focus_',this).map(function(n) {
					if (path.indexOf(n) < 0) { return n.unflag('focus_') };
				});
				
				for (var i = 0, len = path.length; i < len; i++) {
					path[i].flag('focus_');
				};
				return this;
			};
			
			
			tag.prototype.recompile = function (){
				// should happen in a separate thread - and be delayed
				console.log('recompile');
				var res;
				
				try {
					res = Imbac.compile(this.code(),{bare: true});
				} catch (e) { };
				
				if (res) {
					this.compiled(res);
				};
				return this;
			};
			
			tag.prototype.reparse = function (){
				this.log('reparse');
				this.root().rehighlight({inner: true});
				return this;
			};
			
			tag.prototype.compiled = function (res){
				return this;
			};
			
			tag.prototype.onrunerror = function (e){
				console.log('onrunerror',e);
				return this;
			};
			
			tag.prototype.addError = function (msg,loc){
				var node;
				var reg = Region.normalize(loc,this);
				console.log('found warnings',reg,msg,loc);
				if (node = this.nodeAtRegion(reg)) {
					this.log('node at region is?!',node);
					msg = msg.split(/error at (\[[\d\:]*\])\:\s*/).pop();
					node.flag('err');
					node.setAttribute('error',msg);
				};
				this.delay('annotate',-1);
				return this;
			};
			
			
			
			tag.prototype.annotate = function (){
				// console.log 'annotate'
				
				var self = this;
				var state = self.root().codeState();
				var code = state.code;
				
				var apply = function(meta) {
					var vars = [];
					for (var i = 0, ary = iter$(meta.scopes), len = ary.length; i < len; i++) {
						for (var j = 0, items = iter$(ary[i].vars), len_ = items.length; j < len_; j++) {
							vars.push(items[j]);
						};
					};
					
					var warnings = meta.warnings || [];
					var oldWarnings = self.hints().filter(function(hint) { return hint.group() == 'analysis'; });
					
					if (oldWarnings) {
						// could intelligently keep them instead
						self.hints().rem(oldWarnings);
					};
					
					for (var i = 0, ary = iter$(warnings), len = ary.length, warn; i < len; i++) {
						warn = ary[i];
						warn.type || (warn.type = 'error');
						warn.group = 'analysis';
						self.hints().add(warn).activate();
					};
					
					if (warnings.length) { return self };
					
					var nodes = IM.textNodes(self.root().dom(),true);
					// what about removing old warnings?
					
					var map = {};
					for (var i = 0, ary = iter$(nodes), len = ary.length, node; i < len; i++) {
						node = ary[i];
						map[node._loc] = node;
					};
					
					// get textNodes with mapping(!)
					for (var i1 = 0, len = vars.length; i1 < len; i1++) {
						for (var k = 0, ary = iter$(vars[i1].refs), len_ = ary.length, ref; k < len_; k++) {
							ref = ary[k];
							var a = ref.loc[0];
							var b = ref.loc[1];
							var eref = ("v" + i1);
							
							if (map[a]) {
								var dom = map[a].parentNode;
								var oldRef = dom.getAttribute('eref');
								// console.log 'setting the ref for node?',dom,dom.@tag
								tag$wrap(dom).setEref(eref);
								// if dom.@tag
								// 	dom.@tag.eref = eref
								// else
								// 	dom.setAttribute('eref',eref) unless oldRef == eref
								// 	dom:classList.add('lvar')
							};
						};
					};
					
					return;
				};
				
				try {
					
					console.time('analyze');
					IM.worker().analyze(code,{bare: true},function(res) {
						console.log('result from worker analyze');
						console.timeEnd('analyze');
						
						if (res.data) {
							console.time('annotate');
							apply(res.data);
							return console.timeEnd('annotate');
						};
					});
				} catch (e) {
					self.log('error from annotate',e);
				};
				
				return self;
			};
			
			tag.prototype.oncommand = function (e,c){
				if (this[c.command] instanceof Function) {
					this[c.command].call(this,c.args || []);
					e.halt();
				};
				return this;
			};
			
			tag.prototype.dumpState = function (o){
				if(o === undefined) o = {};
				return {
					html: this.root().dom().innerHTML,
					code: this.root().code(),
					selection: this.caret().region(),
					timestamp: new Date()
				};
			};
			
			tag.prototype.loadState = function (o){
				var self = this;
				if(o === undefined) o = {};
				self.observer().pause(function() {
					var v_;
					if (o.html) {
						self.root().dom().innerHTML = o.html;
					} else if (o.code) {
						self.load(o.code);
					};
					if (o.selection) {
						return (self.caret().setRegion(v_ = o.selection),v_);
					};
				});
				return self;
			};
			
			tag.prototype.loadSession = function (session){
				this.history().load(session);
				this.history().play();
				return this;
			};
			
			tag.prototype.textNodes = function (rel){
				if(rel === undefined) rel = this.root();
				return IM.textNodes(rel);
			};
			
			// Should be separate from the viewcode?
			tag.prototype.regionForNode = function (node,rel){
				if(rel === undefined) rel = this.root();
				var el = node._dom || node;
				var len = el.textContent.length;
				var rng = document.createRange();
				rng.setStart(rel._dom || rel,0);
				rng.setEnd(node._dom || node,0);
				var pre = rng.toString();
				return new Region(pre.length,pre.length + len,rel,this);
			};
			
			// Should merge with nodesInRegion
			tag.prototype.nodeAtRegion = function (region,exact){
				if(exact === undefined) exact = false;
				console.time('nodeAtRegion');
				var rel = this.root();
				var a = region.a();
				var b = region.b();
				
				var nodes = this.textNodes(rel);
				// move into region instead?
				var pos = 0;
				var match = null;
				var adist,bdist,str,len;
				
				for (var i = 0, ary = iter$(nodes), len_ = ary.length, node; i < len_; i++) {
					// console.log 'looking through nodes'
					node = ary[i];
					adist = a - pos;
					bdist = b - pos;
					str = node.textContent;
					len = str.length;
					
					if (adist >= 0 && adist < len) {
						// console.log 'found starting point?',node,str,adist
						match = node;
						break;
						// return tag(node:parentNode)
					};
					
					if (bdist >= 0 && bdist < len) {
						// console.log 'found ending point',node,str,bdist
						// range.setEnd(node,bdist)
						break;
					};
					
					
					pos += len;
				};
				
				var el = tag$wrap(match.parentNode);
				// we want to match the one that is full length
				if (exact && len < region.size()) {
					while (el){
						// be careful
						var elreg = el.region();
						if (region.equals(elreg)) { return el };
						el = el.parent();
					};
				};
				
				console.timeEnd('nodeAtRegion');
				return match ? (tag$wrap(match.parentNode)) : (null);
			};
			
			tag.prototype.nodesForEntity = function (ref){
				return q$('[eref="'+("" + ref)+'"]',this);
			};
			
			// does not need to belong to view directly
			tag.prototype.nodesInRegion = function (region,includeEnds,generalize){
				if(includeEnds === undefined) includeEnds = true;
				if(generalize === undefined) generalize = false;
				console.time('nodesInRegion');
				region = Region.normalize(region,this).normalize();
				var a = region.start();
				var b = region.end();
				
				// can be optimized by supplying the regions
				var nodes = IM.textNodes(region.root() || this.root());
				var matches = [];
				var match;
				var el;
				// move into region instead?
				matches.includeEnds = includeEnds;
				matches.region = region;
				
				var pos = 0;
				var ends = [];
				
				for (var i1 = 0, ary = iter$(nodes), len_ = ary.length, node; i1 < len_; i1++) {
					// console.log 'looking through nodes'
					node = ary[i1];
					var adist = a - pos;
					var bdist = b - pos;
					var str = node.textContent;
					var len = str.length;
					
					if ((pos + len) >= a && pos <= b) {
						el = tag$wrap(node.parentNode);
						var start = Math.max(0,a - pos);
						var end = Math.min(len,Math.max(b - pos,0));
						var par;
						
						match = {
							node: el,
							startOffset: start,
							endOffset: end,
							region: new Region(start,end,el,this),
							size: len
						};
						// log "node at {pos} + {len} - looking in range {a} - {b}"
						var mode = 'all';
						
						if (start == len) {
							mode = 'end';
						} else if (end == 0) {
							mode = 'start';
						} else if (start == 0 && end == len) {
							par = el.dom().parentNode;
							var isOpener = par != this._root.dom() && el.dom() == par.firstChild;
							var isCloser = par != this._root.dom() && el.dom() == par.lastChild;
							
							if (isOpener) {
								match.opens = el.parent();
								ends.push(match);
							};
							
							if (isCloser) {
								end = ends[ends.length - 1];
								if (end && end.opens == el.parent()) {
									end.closer = match;
									match.opener = end;
									ends.pop();
								};
								
								match.closes = el.parent();
							};
							
							mode = 'all';
						} else {
							mode = 'partial';
						};
						
						match.mode = mode;
						matches.push(match);
					};
					
					pos += len;
					if (pos > b) { break; };
				};
				
				var first = matches[0];
				var last = matches[matches.length - 1];
				
				if (first && first.mode == 'end') {
					matches.prev = first;
					matches.lft = first.node;
					
					// if first:node isa IM.Types:close
					// 	matches:lft = first:node.parent
					
					if (!includeEnds) { matches.shift() };
				};
				
				if (last && last.mode == 'start') {
					matches.next = last;
					matches.rgt = last.node;
					
					// if last:node isa IM.Types:open
					// 	matches:rgt = last:node.parent
					
					if (!includeEnds) { matches.pop() };
				};
				
				
				// normalize the nodes in groups
				if (generalize) {
					// console.log 'generalize!',matches
					var i = 0;
					var m;
					while (m = matches[i]){
						if (m.closer) {
							var idx = matches.indexOf(m.closer);
							len = m.opens.size();
							var new$ = {
								mode: 'all',
								region: new Region(0,len,m.opens,this),
								startOffset: 0,
								endOffset: len,
								node: m.opens
							};
							var rem = matches.splice(i,idx - i + 1,new$);
							new$.children = rem;
							// console.log 'slice away the items'
						};
						i++;
					};
				};
				
				console.timeEnd('nodesInRegion');
				return matches;
			};
			
			// should move to Buffer class
			tag.prototype.linecount = function (){
				return this.buffer().linecount();
				// buffer.split('\n')[:length]
			};
			
			// Returns the contents of the region as a string.
			// Returns the character to the right of the point.
			tag.prototype.substr = function (region,len){
				return this.buffer().substr(region,len);
			};
			
			// move into Buffer
			tag.prototype.linestr = function (nr){
				return this.buffer().line(nr);
				// if nr isa Number
				// 	buffer.split('\n')[nr] or ''
			};
			
			tag.prototype.expandRegionTo = function (region,match,forward){
				if(forward === undefined) forward = true;
				var buf = this.buffer().toString();
				var pos = region.start();
				var end = region.end();
				
				if (forward) {
					while (buf[end + 1] != match){
						end++;
					};
				} else {
					while (buf[pos - 1] != match){
						pos--;
					};
				};
				
				return new Region(pos,end,this);
			};
		});
		
		
		return VIEW = null;
	
	})()

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var Region = __webpack_require__(27).Region;
		
		function Buffer(view){
			this._view = view;
			this._buffer = '';
			this._cache = {};
			this;
		};
		
		exports.Buffer = Buffer; // export class 
		
		
		Buffer.prototype.view = function(v){ return this._view; }
		Buffer.prototype.setView = function(v){ this._view = v; return this; };
		
		Buffer.prototype.set = function (buffer){
			if (buffer == this._buffer) {
				return this;
			};
			
			this._buffer = buffer;
			this._cache = {};
			this._lines = null;
			return this;
		};
		
		Buffer.prototype.refresh = function (){
			return this.set(this.view().root().code());
		};
		
		Buffer.prototype.lines = function (){
			return this._lines || (this._lines = (true) && (
				this._buffer.split('\n')
			));
		};
		
		Buffer.prototype.split = function (){
			return this._buffer.split.apply(this._buffer,arguments);
		};
		
		Buffer.prototype.linecount = function (){
			return this.lines().length;
		};
		
		Buffer.prototype.line = function (nr){
			if ((typeof nr=='number'||nr instanceof Number)) {
				return this.lines()[nr] || '';
			} else {
				return '';
			};
		};
		
		Buffer.prototype.len = function (){
			return this._buffer.length;
		};
		
		// location to 
		Buffer.prototype.locToRc = function (){
			return this;
		};
		
		Buffer.prototype.location = function (){
			return this;
		};
		
		Buffer.prototype.locToRow = function (loc){
			var ln = 0;
			var len = 0;
			for (var i = 0, ary = iter$(this.lines()), len_ = ary.length; i < len_; i++) {
				len += ary[i].length + 1;
				if (loc < len) { return i };
			};
			return this.lines().length;
		};
		
		Buffer.prototype.locToCell = function (loc){
			if (this._cache[loc]) {
				return this._cache[loc];
			};
			
			var pos = loc;
			var col = 0;
			var row = 0;
			var char$;
			
			var buf = this._buffer;
			var tabsize = this._view.tabSize();
			
			// go back to start of line
			// goes through the whole
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					break;
				};
				pos--;
			};
			
			// get column for slice
			while ((pos < loc) && (char$ = buf[pos])){
				if (char$ == '\t') {
					var rest = tabsize - (col % tabsize);
					col += rest;
				} else {
					col += 1;
				};
				pos++;
			};
			
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					row++;
				};
				pos--;
			};
			
			return this._cache[loc] = [row,col];
		};
		
		Buffer.prototype.substr = function (region,len){
			if (region instanceof Region) {
				return this._buffer.substr(region.start(),region.size());
			} else if ((typeof region=='number'||region instanceof Number)) {
				return this._buffer.substr(region,len || 1);
			} else {
				throw 'must be region or number';
			};
		};
		
		Buffer.prototype.toString = function (){
			return this._buffer || '';
		};
		return Buffer;
	
	})()

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var util = __webpack_require__(34);
		
		function Observer(view,cfg){
			var self = this;
			self._active = false;
			self._view = view;
			self._config = cfg || {attributes: false,childList: true,characterData: true,subtree: true};
			self._observer = new MutationObserver(function(muts) { return self.onmutations(muts); });
			self;
		};
		
		exports.Observer = Observer; // export class 
		
		
		Observer.prototype.view = function(v){ return this._view; }
		Observer.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Observer.prototype.config = function(v){ return this._config; }
		Observer.prototype.setConfig = function(v){ this._config = v; return this; };
		
		
		Observer.prototype.active = function(v){ return this._active; }
		Observer.prototype.setActive = function(v){ this._active = v; return this; };
		
		Observer.prototype.resume = function (){
			if (!this._active) {
				this._observer.observe(this.view().root().dom(),this.config());
				this._active = true;
			};
			return this;
		};
		
		Observer.prototype.pause = function (blk){
			var wasActive = this._active;
			this._active = false;
			if (wasActive) { this._observer.disconnect() };
			
			if (blk instanceof Function) {
				blk();
				if (wasActive) this.resume();
			};
			
			return this;
		};
		
		Observer.prototype.paused = function (){
			return !this._active;
		};
		
		Observer.prototype.onmutations = function (mutations){
			var el;
			this.view().logger().group('mutations');
			
			var deep = false;
			var nodes = [];
			for (var i = 0, ary = iter$(mutations), len = ary.length, mut; i < len; i++) {
				mut = ary[i];
				this.view().log('mutation',mut);
				var type = mut.type;
				var target = mut.previousSibling || mut.target;
				
				if (type == 'characterData') {
					this.view().log(("updated code to " + (target.textContent)));
					target = target.parentNode;
				} else if (type == 'childList') {
					deep = true;
					var add = mut.addedNodes;
					if (add.length == 1 && (add[0] instanceof Element)) {
						target = add[0];
					};
				};
				
				this.view().log(target,tag$wrap(target));
				// var added = mut:addedNodes
				// for node in mut:addedNodes
				// if target and target:parentNode # and target.@tag
				if (el = tag$wrap(target)) {
					this.view().log('add target?!');
					if (nodes.indexOf(el) < 0) { nodes.push(el) };
				};
				
				// if we have added a node instead
			};
			
			// mutations are not registered on node-level but on extent
			// not really how this should happen
			
			var common = util.commonAncestor(nodes);
			
			this.view().log('common container for mutations is',common,nodes);
			
			var extent;
			
			if (nodes.length == 1) {
				this.view().log('a single node was mutated',nodes[0]);
				nodes[0].mutated({deep: deep,mutations: mutations});
			} else {
				// collect extents for all nodes?
				// rather make a region expand 
				for (var i = 0, len = nodes.length, node; i < len; i++) {
					node = nodes[i];
					if (extent && extent.contains(node.dom())) { // :nodes.indexOf(node.dom) >= 0
						this.view().log('this node is already part of the extent',node.dom());
					} else {
						extent = node.dirtyExtent();
					};
					// node?.mutated
				};
				
				if (extent) {
					// console.log 'found extent(!)',extent
					this.pause(function() { return true; });
				};
			};
			
			this.view().logger().groupEnd();
			this.view().onmutations({nodes: nodes,mutations: mutations,extent: extent});
			return this;
		};
		return Observer;
		
	
	})()

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Region = __webpack_require__(27).Region;
		
		var labels = {
			"Unexpected 'TAG_END'": 'Tag closed unexpectedly',
			"Unexpected 'TERMINATOR'": 'Unexpected ',
			"Unexpected 'POST_IF'": 'Missing body in <b>IF</b>'
		};
		
		var rules = [
			[/Uncaught Error: tag (\w+) is not defined/,"tag <b>$1</b> does not exist"]
		];
		
		function Hint(opts,view){
			this._view = view;
			this._data = opts;
			this._active = false;
			this._region = opts.loc ? (Region.normalize(opts.loc,view)) : (null);
			// try to find the node immediately
			this._node = opts.node || this.node();
			this;
		};
		
		exports.Hint = Hint; // export class 
		Hint.build = function (o,view){
			return new this(o,view);
		};
		
		
		
		Hint.prototype.view = function(v){ return this._view; }
		Hint.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Hint.prototype.region = function(v){ return this._region; }
		Hint.prototype.setRegion = function(v){ this._region = v; return this; };
		
		
		Hint.prototype.active = function(v){ return this._active; }
		Hint.prototype.setActive = function(v){ this._active = v; return this; };
		
		Hint.prototype.getAttribute = function (key){
			return this._data[key];
		};
		
		Hint.prototype.setAttribute = function (key,val){
			this._data[key] = val;
			return this;
		};
		
		Hint.prototype.type = function (){
			return this._data.type || 'error';
		};
		
		Hint.prototype.group = function (){
			return this._data.group;
		};
		
		Hint.prototype.ref = function (){
			return this._data.ref;
		};
		
		Hint.prototype.node = function (){
			return this._node || (this._node = this._region && this.view().nodeAtRegion(this._region));
		};
		
		Hint.prototype.row = function (){
			return this.region().row();
		};
		
		Hint.prototype.col = function (){
			return this.region().col();
		};
		
		Hint.prototype.label = function (){
			var lbl;
			return this._label || (this._label = (true) && (
				lbl = this._data.label || this._data.message || 'Hint',
				lbl = lbl.split(/error at (\[[\d\:]*\])\:\s*/).pop(),
				lbl = labels[lbl] || lbl
			));
		};
		
		
		Hint.prototype.activate = function (){
			var node_;
			if (!this._active) {
				// node?.setAttribute('hint',ref)
				this._active = true;
				(node_ = this.node()) && node_.setHint  &&  node_.setHint(this);
			};
			return this;
		};
		
		Hint.prototype.deactivate = function (){
			console.log('deactivate hint!!');
			this.setActive(false);
			return this;
			// cleanup
			// remove
		};
		
		Hint.prototype.prune = function (){
			return this.view().hints().prune(this);
		};
		
		// should make this hint ready to be removed
		Hint.prototype.cleanup = function (){
			if (this._node) {
				if (this._node.hint() == this) { this._node.setHint(null) };
			};
			return this;
		};
		
		Hint.prototype.remove = function (){
			this.view().hints().rem(this);
			return this;
		};
		
		Hint.prototype.changed = function (){
			// console.log 'deactivate on changed!'
			// @deactivate = yes
			this.prune();
			return this;
		};
		
		Hint.prototype.adjust = function (reg,ins){
			if(ins === undefined) ins = true;
			if (this.region().intersects(reg)) {
				// deactivate
				this.prune();
				// @deactivate = yes
			};
			
			this.region().adjust(reg,ins);
			return this;
		};
		
		function Hints(view){
			this._prune = [];
			this._array = [];
			this._map = {};
			this._view = view;
		};
		
		exports.Hints = Hints; // export class 
		var nr = 0;
		
		Hints.prototype.toArray = function (){
			return this._array;
		};
		
		Hints.prototype.get = function (ref){
			return this._map[ref];
		};
		
		Hints.prototype.activate = function (){
			for (var i = 0, ary = iter$(this._array), len = ary.length; i < len; i++) {
				ary[i].activate();
			};
			return this;
		};
		
		// this should take care of deallocating the hint no?
		Hints.prototype.rem = function (hint){
			if (hint instanceof Function) {
				hint = this._array.filter(hint);
			};
			
			if (hint instanceof Array) {
				for (var i = 0, ary = iter$(hint), len = ary.length; i < len; i++) {
					this.rem(ary[i]);
				};
				return hint;
			};
			
			if ((typeof hint=='string'||hint instanceof String)) {
				return this.rem(this.get(hint));
			};
			
			if (this._array.indexOf(hint) >= 0) {
				hint.cleanup();
				this._array.splice(this._array.indexOf(hint),1);
			};
			
			return hint;
		};
		
		Hints.prototype.prune = function (hint){
			if (this._prune.indexOf(hint) < 0) { this._prune.push(hint) };
			return this;
		};
		
		Hints.prototype.clear = function (){
			var arr = this._array;
			this._array = [];
			
			for (var i = 0, ary = iter$(arr), len = ary.length; i < len; i++) {
				ary[i].deactivate();
			};
			return this;
		};
		
		Hints.prototype.cleanup = function (){
			
			var self = this;
			self._array.map(function(item) {
				if (self._prune.indexOf(item) >= 0) {
					item.deactivate();
					return self.rem(item);
				};
			});
			self._prune = [];
			return self;
		};
		
		
		Hints.prototype.filter = function (cb){
			return this._array.filter(cb);
		};
		
		Hints.prototype.add = function (o){
			var ref = o.ref = ("hint" + (nr++));
			if (!((o instanceof Hint))) { o = Hint.build(o,this._view) };
			this._map[ref] = o;
			this._array.push(o);
			return o;
		};
		return Hints;
	
	})()

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var util = __webpack_require__(34);
		var Region = __webpack_require__(27).Region;
		
		function RowCol(row,col,caret){
			if(row === undefined) row = 0;
			if(col === undefined) col = 0;
			if(caret === undefined) caret = null;
			this._row = row;
			this._col = col;
			this._caret = caret;
			this;
		};
		
		
		
		RowCol.prototype.row = function(v){ return this._row; }
		RowCol.prototype.setRow = function(v){ this._row = v; return this; };
		
		
		RowCol.prototype.col = function(v){ return this._col; }
		RowCol.prototype.setCol = function(v){ this._col = v; return this; };
		
		
		RowCol.prototype.caret = function(v){ return this._caret; }
		RowCol.prototype.setCaret = function(v){ this._caret = v; return this; };
		
		RowCol.prototype.view = function (){
			return this.caret().view();
		};
		
		RowCol.prototype.normalize = function (){
			this._col = this.realCol();
			return this;
		};
		
		RowCol.prototype.set = function (row,col){
			var ary;
			if (row instanceof RowCol) {
				col = row.col();
				row = row.row();
				
				// return set(row.row,row.col)
			};
			
			if (row instanceof Region) {
				var ary = iter$(util.rowcol(this.view()._buffer,row.start()));row = ary[0];col = ary[1];
			};
			
			var lc = this.view()._buffer.linecount();
			
			if (row >= lc) {
				row = lc - 1;
				col = 1000;
			};
			
			this._row = row;
			this._col = col;
			return this;
		};
		
		
		RowCol.prototype.move = function (offset){
			this.normalize();
			
			var col = this.realCol() + offset;
			var llen = this.linelen();
			
			var lloc = this.lineloc();
			// find the real offset in characters (not columns)
			
			
			// if offset < 0
			// 	# normalize?
			// 	@col = Math.min(@col,llen)
			
			if (col < 0) {
				if (this._row > 0) {
					this.moveUp();
					this._col = this.linelen();
				} else {
					this._row = 0;
					this._col = 0;
				};
				return this;
			} else if (col > llen) {
				if (this._row >= (this.view()._buffer.linecount() - 1)) {
					return this;
				};
				
				this.moveDown();
				var rest = Math.max(0,col - llen - 1);
				var moves = util.colsForLine(this.linestr().substr(0,rest));
				this._col = moves;
				return this;
			};
			
			// this should work
			this._col = util.colsForLine(this.linestr().substr(0,lloc + offset));
			// @col += offset
			return this;
		};
		
		RowCol.prototype.moveUp = function (len){
			this._row = Math.max(0,this._row - 1);
			return this;
		};
		
		RowCol.prototype.moveDown = function (len){
			console.log('moveDown');
			var lc = this.view()._buffer.linecount(); // split('\n')[:length]
			this._row = this._row + 1;
			if (this._row >= lc) {
				console.log('out of bounds');
				this.setLoc(this.view()._buffer.len());
			};
			return this;
		};
		
		RowCol.prototype.clone = function (){
			return new RowCol(this.row(),this.col(),this.caret());
		};
		
		RowCol.prototype.linelen = function (){
			return util.colsForLine(this.linestr());
		};
		
		RowCol.prototype.lineloc = function (){
			return util.colToLoc(this.linestr(),this.realCol());
		};
		
		RowCol.prototype.realCol = function (){
			var rc = util.colToViewCol(this.linestr(),this._col);
			return rc;
		};
		
		RowCol.prototype.linestr = function (){
			return this.view().linestr(this.row());
		};
		
		RowCol.prototype.peekbehind = function (){
			var str = this.linestr();
			return str.substr(0,util.colToLoc(str,this.realCol()));
		};
		
		RowCol.prototype.peekahead = function (){
			var str = this.linestr();
			return str.slice(util.colToLoc(str,this.realCol()));
		};
		
		RowCol.prototype.setLoc = function (loc){
			var ary;
			var ary = iter$(util.rowcol(this.view()._buffer,loc));var row = ary[0],col = ary[1];
			this.set(row,col);
			return this;
		};
		
		RowCol.prototype.loc = function (){
			// should cache(!)
			var lines = this.view()._buffer.lines();
			// var lines = view.buffer.split('\n')
			var loc = 0;
			for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
				line = ary[i];
				var ln = line.length;
				if (i < this._row) {
					loc += ln + 1; // include newline
				} else if (i == this._row) {
					var viewcol = util.colToViewCol(line,this._col);
					var offset = util.colToLoc(line,viewcol);
					loc += Math.min(ln,offset);
				};
			};
			return loc;
		};
		
		RowCol.prototype.tab = function (){
			// wrong - need to round instead?
			
			var lft = this.col() % 4;
			this.setCol(this.col() + (4 - lft)); // Math.floor(col / 4) * 4 + 4
			console.log('marker tab',lft,this.col(),this.realCol());
			return this;
		};
		
		RowCol.prototype.untab = function (){
			console.log('untab',this.col());
			var rest = 4 - this.col() % 4;
			this.setCol(Math.ceil(this.col() / 4) * 4 - 4);
			return this;
		};
		
		RowCol.prototype.alter = function (mode,dir){
			var $1, $2, $3, $4, $5, $6;
			var nodes = this.caret().view().nodesInRegion(this.loc(),false);
			var node = nodes[0];
			var mid = node && node.node;
			var lft = nodes.prev && nodes.prev.node;
			var rgt = nodes.next && nodes.next.node;
			var part;
			
			// log 'move',offset,mode,nodes
			if (mode == IM.WORD_START) {
				var el = mid || lft;
				if (($1 = lft) && $1.matches  &&  $1.matches(q$('._imclose',this))) {
					this.setLoc(lft.parent().region().start());
				} else if (($2 = lft) && $2.matches  &&  $2.matches(q$('._imstr',this))) {
					this.setLoc(lft.region().start());
				} else {
					var loc = this.loc();
					// let buf = view.buffer
					// console.log 'peekbehind',peekbehind,loc,str
					var str = this.peekbehind().split('').reverse().join('');
					loc -= str.match(/^([\s\t\.]*.+?|)(\b|$)/)[1].length;
					this.setLoc(loc);
				};
			} else if (mode == IM.WORD_END) {
				el = mid || rgt;
				if (($3 = rgt) && $3.matches  &&  $3.matches(q$('._imopen',this))) {
					this.setLoc(rgt.parent().region().end());
				} else if (($4 = rgt) && $4.matches  &&  $4.matches(q$('._imstr',this))) {
					this.setLoc(rgt.region().end());
				} else {
					var loc1 = this.loc();
					// let buf = view.buffer
					
					
					// console.log 'peekahead',peekahead,loc
					loc1 += this.peekahead().match(/^([\s\.]*.+?|)(\b|$)/)[1].length;
					// loc++ until buf[loc].match(/[\n\]/)
					this.setLoc(loc1);
				};
			} else if (mode == IM.LINE_END) {
				this.set(this.row(),1000);
			} else if (mode == IM.LINE_START) {
				// FIXME tabs-for-spaces
				var tabs = this.linestr().match(/^\t*/)[0].length;
				var newcol = tabs * this.view().tabSize();
				this.setCol(this.col() > newcol ? (newcol) : (0));
			} else {
				if (dir < 0 && ($5 = lft) && $5.matches  &&  $5.matches('._imtab')) {
					// head.col = head.col - 4
					// caret.view.log 'right is tab',lft.region
					this.setLoc(lft.region().start());
					// head.untab
				} else if (dir > 0 && ($6 = rgt) && $6.matches  &&  $6.matches('._imtab')) {
					
					// use tab instead
					this.tab();
					// head.col = head.col + 4
				} else {
					// ...
					this.move(dir);
				};
			};
			
			return this;
		};
		
		tag$.defineTag('imcarethead');
		
		// should move into Marker (like Atom)
		return tag$.defineTag('imcaret', function(tag){
			
			
			
			tag.prototype.region = function(v){ return this._region; }
			tag.prototype.setRegion = function(v){ this._region = v; return this; };
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			
			tag.prototype.lines = function(v){ return this._lines; }
			tag.prototype.setLines = function(v){ this._lines = v; return this; };
			
			
			tag.prototype.ranges = function(v){ return this._ranges; }
			tag.prototype.setRanges = function(v){ this._ranges = v; return this; };
			
			tag.prototype.__mode = {watch: 'modeDidSet',name: 'mode'};
			tag.prototype.mode = function(v){ return this._mode; }
			tag.prototype.setMode = function(v){
				var a = this.mode();
				if(v != a) { this._mode = v; }
				if(v != a) { this.modeDidSet && this.modeDidSet(v,a,this.__mode) }
				return this;
			};
			
			tag.prototype.__col = {'default': 0,watch: 'dirty',name: 'col'};
			tag.prototype.col = function(v){ return this._col; }
			tag.prototype.setCol = function(v){
				var a = this.col();
				if(v != a) { this._col = v; }
				if(v != a) { this.dirty && this.dirty(v,a,this.__col) }
				return this;
			}
			tag.prototype._col = 0; // the real column of the caret
			
			tag.prototype.__row = {'default': 0,watch: 'dirty',name: 'row'};
			tag.prototype.row = function(v){ return this._row; }
			tag.prototype.setRow = function(v){
				var a = this.row();
				if(v != a) { this._row = v; }
				if(v != a) { this.dirty && this.dirty(v,a,this.__row) }
				return this;
			}
			tag.prototype._row = 0;
			
			
			tag.prototype.input = function(v){ return this._input; }
			tag.prototype.setInput = function(v){ this._input = v; return this; };
			
			
			
			tag.prototype.tail = function(v){ return this._tail; }
			tag.prototype.setTail = function(v){ this._tail = v; return this; }; // rowcol
			
			
			tag.prototype.head = function(v){ return this._head; }
			tag.prototype.setHead = function(v){ this._head = v; return this; };
			
			
			tag.prototype.hash = function(v){ return this._hash; }
			tag.prototype.setHash = function(v){ this._hash = v; return this; };
			
			tag.prototype.expand = function (lft,rgt){
				var ary;
				if(lft === undefined) lft = 0;
				if(rgt === undefined) rgt = 0;
				this.log('imcaret expand',lft,rgt);
				this.decollapse();
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				a.move(lft);
				b.move(rgt);
				return this;
			};
			
			tag.prototype.toArray = function (){
				if (this.isCollapsed()) {
					return [this.head().row(),this.head().col()];
				} else {
					return [this.head().row(),this.head().col(),this.tail().row(),this.tail().col()];
				};
			};
			
			tag.prototype.toHash = function (){
				return '[' + this.toArray().join(',') + ']';
			};
			
			tag.prototype.set = function (val){
				if (val instanceof IM.Types.Tok) {
					return this.set(val.region());
				};
				
				if (val instanceof Region) {
					return (this.setRegion(val),val);
				};
				
				if (val instanceof Array) {
					this.head().setRow(val[0]);
					this.head().setCol(val[1]);
					
					if (val.length == 4) {
						this.decollapse();
						this.tail().setRow(val[2]);
						this.tail().setCol(val[3]);
					} else {
						this.setTail(this.head());
					};
				};
				this.dirty();
				return this;
			};
			
			tag.prototype.expandToLines = function (){
				var ary;
				this.selectable();
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				a.setCol(0);
				b.setCol(1000);
				return this.dirty();
			};
			
			tag.prototype.selectAll = function (){
				this.decollapse();
				this.tail().setLoc(0);
				this.head().setLoc(this.view()._buffer.len()); // :length
				this.dirty();
				return this;
			};
			
			tag.prototype.selectable = function (){
				this.decollapse();
				return this;
			};
			
			tag.prototype.decollapse = function (){
				var v_;
				if (this.tail() == this.head()) { (this.setTail(v_ = this.head().clone()),v_) };
				return this;
			};
			
			tag.prototype.collapse = function (){
				this.setTail(this.head());
				this.dirty();
				return this;
			};
			
			tag.prototype.collapseToStart = function (){
				if (this.isReversed()) {
					this.setTail(this.head());
				} else {
					this.setHead(this.tail());
				};
				this.dirty();
				return this;
			};
			
			tag.prototype.orientation = function (){
				return this.isReversed() ? ('reversed') : ('normal');
			};
			
			tag.prototype.isCollapsed = function (){
				return this.tail() == this.head();
			};
			
			tag.prototype.isReversed = function (){
				return this.head().row() < this.tail().row() || (this.tail().row() == this.head().row() && this.head().col() < this.tail().col());
			};
			
			tag.prototype.indent = function (){
				var str = this.head().linestr();
				var ind = str.match(/^(\t*)/)[0];
				return ind;
			};
			
			tag.prototype.peekbehind = function (val){
				var str = this.ends()[0].peekbehind();
				if (val instanceof RegExp) { return str.match(val) };
				return str;
			};
			
			tag.prototype.move = function (offset,mode){
				if(offset === undefined) offset = 1;
				if(mode === undefined) mode = 0;
				this.head().alter(mode,offset);
				return this.dirty();
			};
			
			// what if we 
			tag.prototype.moveDown = function (len){
				if(len === undefined) len = 1;
				this.head().moveDown();
				return this.dirty();
			};
			
			tag.prototype.moveUp = function (len){
				if(len === undefined) len = 1;
				this.head().moveUp();
				return this.dirty();
			};
			
			tag.prototype.ends = function (){
				return this.isReversed() ? ([this.head(),this.tail()]) : ([this.tail(),this.head()]);
			};
			
			tag.prototype.text = function (){
				return this.region().text();
			};
			
			tag.prototype.region = function (){
				// get the actual region based on head and tail
				// getting the code might be expensive if done
				// too many times -- but easy to cache
				// send this to util instead
				var ary;
				var code = this.view().code();
				var lines = code.split('\n');
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				
				var start = 0;
				var end = 0;
				var ln = 0;
				
				var ar = a.row(),ac = a.col(),br = b.row(),bc = b.col();
				var char$;
				
				for (var i = 0, items = iter$(lines), len = items.length, line; i < len; i++) {
					line = items[i];
					ln = line.length;
					if (i < ar) {
						start += ln + 1; // include newline
					} else if (i == ar) {
						var offset = util.colToLoc(line,ac);
						start += Math.min(ln,offset);
					};
					
					if (i < br) {
						end += ln + 1; // include newline
					} else if (i == br) {
						offset = util.colToLoc(line,bc);
						end += Math.min(ln,offset);
					} else {
						break;
					};
				};
				
				return new Region(start,end,this.view().root(),this.view());
			};
			
			tag.prototype.setRegion = function (reg){
				var buf = this.view().code();
				var a = util.rowcol(buf,reg.a());
				var b = util.rowcol(buf,reg.b());
				
				this.setHead(new RowCol(b[0],b[1],this));
				
				if (reg.size() == 0) {
					this.setTail(this.head());
				} else {
					this.setTail(new RowCol(a[0],a[1],this));
				};
				return this.dirty();
			};
			
			tag.prototype.nodes = function (reg){
				if(reg === undefined) reg = this.region();
				return this.view().nodesInRegion(reg,this.isCollapsed());
			};
			
			// should rather move this to region itself
			tag.prototype.target = function (reg){
				if(reg === undefined) reg = this.region();
				var nodes = this.nodes(reg);
				if (nodes.length > 2) {
					return util.commonAncestor(nodes.map(function(n) { return n.node; }));
				};
				return nodes[0].node;
			};
			
			tag.prototype.insert = function (text,edit){
				
				var sub = '';
				this.view().history().mark('action');
				
				if (!(this.isCollapsed())) {
					var reg = this.region();
					sub = reg.text();
					this.view().erase(reg);
					this.collapseToStart();
				};
				
				var move = 0;
				var sel;
				
				// need a different syntax for $0 -- can be in regular pasted code
				// should have a separate command for insertSnippet probably.
				if (text.indexOf('$0') >= 0) {
					sel = this.region().clone(0,sub.length).move(text.indexOf('$0'));
					text = text.replace('$0',sub);
				};
				
				edit || (edit = {size: text.length});
				
				this.head().normalize();
				var res = this.view().insert(this.region().start(),text,edit);
				this.view().log('inserted -- now move',edit.size);
				
				if (sel) {
					this.setRegion(sel);
				} else {
					// move locations
					this.head().setLoc(this.head().loc() + edit.size);
					// head.move(edit:size)
				};
				
				this.dirty();
				
				return this;
			};
			
			
			tag.prototype.erase = function (mode){
				this.view().history().mark('action');
				
				if (this.isCollapsed()) {
					this.log('isCollapsed',mode);
					this.decollapse();
					this.head().alter(mode,-1); // 
					
					// dirty
					// return erase # call again now
				};
				console.log('erasing region',this.region());
				this.view().erase(this.region());
				// log 'now collapse region to start',region
				this.collapseToStart();
				// log region
				return this;
				
				var target = this.target(this.reg());
				this.setRegion(this.reg());
				
				return this.view().edit(
					{text: '',
					target: target,
					region: this.reg(),
					caret: this.reg().clone().collapse(false)}
				);
			};
			
			tag.prototype.dirty = function (){
				var $1, $2;
				this._timestamp = new Date();
				// var hash = toArray.join("")
				
				if (this._hash != this.toHash()) {
					// the realCol values could have changed though?
					this.view().history().oncaret(this._hash,this.toHash(),this);
					this._hash = this.toHash();
					// console.log 'caret has actually changed',@hash
				};
				
				var rev = this.isReversed();
				var a = this.tail();
				var b = this.head();
				
				if (rev) { $1 = b,$2 = a,a = $1,b = $2 };
				
				var lc = b.row() - a.row();
				var row = a.row();
				
				var ac = a.realCol(); // Math.min( a.col, util.colsForLine(view.linestr(a.row) ) )
				var bc = b.realCol(); // Math.min( b.col, util.colsForLine(view.linestr(b.row) ) )
				var hc,tc;
				
				if (this.isReversed()) {
					hc = ac;
					tc = bc;
				} else {
					hc = bc;
					tc = ac;
				};
				
				// log 'dirty',region,a.row,a.col,b.row,b.col,hc,tc,head,tail,rev
				
				this.css({transform: ("translate(0px," + (a.row() * 100) + "%)")});
				// convert the row and column to a region (should go both ways)
				this._caret.css({transform: ("translate(" + hc + "ch," + ((this.head().row() - row) * 100) + "%)")});
				this._start.css({marginLeft: ("" + ac + "ch"),width: "auto"});
				this._end.css({width: ("" + bc + "ch")});
				
				if (this.isCollapsed()) {
					this.setMode('collapsed');
				} else if (lc == 0) {
					this.setMode('single');
					this._start.css({width: (bc - ac) + "ch"});
				} else {
					this._mid.setText(lc > 1 ? (('\n').repeat(lc - 1)) : (''));
					this.setMode('multi');
				};
				return this;
			};
			
			tag.prototype.render = function (){
				var elapsed = (new Date() - this._timestamp);
				var flip = Math.round(elapsed / 500) % 2;
				
				if (flip != this._flip) {
					this._caret.flag('blink',flip);
					this._flip = flip;
				};
				
				return this;
			};
			
			tag.prototype.build = function (){
				var v_, t0;
				this.setTail((this.setHead(v_ = new RowCol(0,0,this)),v_));
				
				return this.setChildren([
					// <imcaptor@input value='x'>
					(this.$a = this.$a || tag$.$span().flag('dim')).setText('x').end(),
					(this._caret = this._caret || tag$.$imcarethead().setRef('caret',this)).end(),
					(t0 = this._lines=this._lines || tag$.$div().setRef('lines',this)).setContent([
						(this._start = this._start || tag$.$div().setRef('start',this)).setText(" ").end(),
						(this._mid = this._mid || tag$.$div().setRef('mid',this)).end(),
						(this._end = this._end || tag$.$div().setRef('end',this)).setText(" ").end()
					],2).end()
				],2).synced();
			};
			
			tag.prototype.normalize = function (){
				this.head().normalize();
				return this;
			};
			
			tag.prototype.modeDidSet = function (new$,old){
				this.unflag(old);
				return this.flag(new$);
			};
		});
	
	})()

/***/ },
/* 44 */
/***/ function(module, exports) {

	(function(){
		
		tag$.defineTag('scrimbla-overlay', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				return this.setChildren(JSON.stringify(this.object()),3).synced();
			};
		});
		
		return tag$.defineTag('scrimbla-overlays', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.add = function (type,data){
				if(data === undefined) data = {};
				console.log('add overlay!');
				this.append(tag$.$scrimbla_overlay().setView(this.view()).setObject(data).end());
				return this;
			};
			
			tag.prototype.reposition = function (){
				return this;
			};
		});
	
	})()

/***/ },
/* 45 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('imeditor', function(tag){
			
			tag.prototype.build = function (){
				this.render();
				return this;
			};
			
			tag.prototype.render = function (){
				return this.setChildren(
					(this._view = this._view || tag$.$imview().setRef('view',this)).end()
				,2).synced();
			};
			
			tag.prototype.view = function (){
				return this._view;
			};
			
			tag.prototype.activate = function (){
				this.view().activate();
				return this;
			};
			
			tag.prototype.deactivate = function (){
				this.view().deactivate();
				return this;
			};
			
			tag.prototype.load = function (code,opts){
				this.view().load(code,opts);
				return this;
			};
			
			tag.prototype.fs = function (){
				return IM.FS;
			};
			
			tag.prototype.oncommand = function (e,c){
				if (this[c.command] instanceof Function) {
					this[c.command].call(this,c.args || []);
					e.halt();
				};
				return this;
			};
			
			tag.prototype.onsavesession = function (){
				console.log("imeditor.saveSession",this);
				var path = this.view().filename().replace(/\.imba$/,'.imbasession');
				var body = JSON.stringify(this.view().history());
				
				return IM.FS.save(path,body,function() {
					return console.log('returned from saving!',path);
				});
			};
		});
	
	})()

/***/ },
/* 46 */
/***/ function(module, exports) {

	(function(){
		
		/*
		Bridge for communicating with the Imba compiler in a worker
		*/
		
		function ImbacWorker(path){
			if(path === undefined) path = "/vendor/imba/imbac.worker.min.js";
			this._path = path;
			this._callbacks = [];
			this;
		};
		
		exports.ImbacWorker = ImbacWorker; // export class 
		ImbacWorker.prototype.worker = function (){
			var self = this, process1;
			return self._worker || (self._worker = (true) && (
				process1 = new Worker(self._path),
				process1.onmessage = function(e) { return self.onmessage(e); },
				process1
			));
		};
		
		ImbacWorker.prototype.onmessage = function (e){
			var fn;
			if (fn = this._callbacks.shift()) {
				return fn(e.data,e);
			};
		};
		
		ImbacWorker.prototype.compile = function (code,o,cb){
			this._callbacks.push(cb);
			this.worker().postMessage(['compile',code,o]);
			return this;
		};
		
		ImbacWorker.prototype.analyze = function (code,o,cb){
			this._callbacks.push(cb);
			this.worker().postMessage(['analyze',code,o]);
			return this;
		};
		return ImbacWorker;
	
	})()

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		__webpack_require__(48);
		__webpack_require__(49);
		__webpack_require__(50);
		__webpack_require__(51);
		__webpack_require__(52);
		__webpack_require__(53);
		__webpack_require__(54);
		__webpack_require__(55);
		return __webpack_require__(56);
	
	})()

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Highlighter = __webpack_require__(29).Highlighter;
		var util = __webpack_require__(34);
		
		// dangerous to extend all htmlelement tags globally
		tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.bubble = function (name,data){
				// log "bubble event",name,data
				var ev = Imba.Events.trigger(name,this,{data: data,bubble: true});
				return ev;
			};
			
			tag.prototype.delay = function (name,time,blk){
				this._timeouts || (this._timeouts = {});
				clearTimeout(this._timeouts[name]);
				if (time != -1) { this._timeouts[name] = setTimeout(blk,time) };
				return this;
			};
			
			tag.prototype.setNext = function (el){
				if (el instanceof IMFragment) {
					el = Array.prototype.slice.call(el.dom().childNodes);
				};
				
				if (el instanceof Array) {
					for (var i = 0, ary = iter$(el.reverse()), len = ary.length; i < len; i++) {
						this.setNext(ary[i]);
					};
					return this;
				};
				
				var curr = this.dom().nextSibling;
				if ((typeof el=='string'||el instanceof String)) {
					el = document.createTextNode(el);
				};
				
				if (curr) {
					this.parent().insertBefore(el,curr);
				} else {
					this.parent().appendChild(el);
				};
				
				return el;
			};
			
			tag.prototype.setPrev = function (el){
				if (el instanceof IMFragment) {
					el = Array.prototype.slice.call(el.dom().childNodes);
					// el = [].concat(el.dom:childNodes)
				};
				
				if (el instanceof Array) {
					for (var i = 0, ary = iter$(el), len = ary.length; i < len; i++) {
						this.setPrev(ary[i]);
					};
					return this;
				};
				
				var curr = this.dom().prevSibling;
				if ((typeof el=='string'||el instanceof String)) {
					el = document.createTextNode(el);
				};
				this.parent().insertBefore(el,this);
				// parent.insert(el, before: self)
				return el;
			};
			
			tag.prototype.nextNode = function (){
				return this.dom().nextSibling;
			};
			
			tag.prototype.prevNode = function (){
				return this.dom().prevSibling;
			};
		});
		
		IM.Types = {};
		
		tag$.defineTag('im', 'b', function(tag){
			
			tag.key = function (key,handler){
				this.prototype[("handle" + key)] = handler;
				return this;
			};
			
			tag.native = function (typ){
				this._nativeType = typ;
				return this;
			};
			
			tag.type = function (typ){
				IM.Types[typ] = this;
				this._type = typ;
				this.prototype._type = typ;
				// @domFlags.push(typ) if @domFlags
				return this;
			};
			
			tag.type('Tok');
			
			tag.alias = function (typ){
				IM.Types[typ] = this;
				return this;
			};
			
			tag.trigger = function (match,cmd){
				if (cmd instanceof Function) {
					cmd = {command: cmd};
				};
				
				cmd.trigger = match;
				return this.prototype[("trigger-" + match)] = cmd;
			};
			
			tag.prototype.setHint = function (hint){
				if (hint && hint != this._hint) {
					this.setAttribute('hint',hint.ref());
					this.setAttribute("hint-type",hint.type());
				} else {
					this.removeAttribute('hint');
					this.removeAttribute('hint-type');
				};
				return this._hint = hint;
			};
			
			tag.prototype.hint = function (){
				// strange no?		
				return this._hint || this.view().hints().get(this.getAttribute('hint'));
			};
			
			// go over to using this 
			tag.prototype.walkTextNodes = function (mark){
				if(mark === undefined) mark = false;
				this.setRoot(this.dom());
				var el;
				var nodes = [];
				var pos = 0;
				var walk = document.createTreeWalker(this.root(),NodeFilter.SHOW_TEXT,null,false);
				
				while (el = walk.nextNode()){
					if (mark) {
						var len = el.length;
						el._loc = pos;
						pos += len;
					};
					nodes.push(el);
				};
				
				return nodes;
			};
			
			
			tag.prototype.util = function (){
				return util;
			};
			
			tag.prototype.select = function (){
				return this.view().caret().set(this.region());
			};
			
			tag.prototype.canPrepend = function (text){
				return false;
			};
			
			tag.prototype.canAppend = function (text){
				return false;
			};
			
			tag.prototype.log = function (){
				var logger_;
				(logger_ = this.view().logger()).log.apply(logger_,arguments);
				return this;
			};
			
			tag.prototype.toString = function (){
				return this.dom().outerHTML;
			};
			
			tag.prototype.spaced = function (){
				if (this.dom().nextSibling instanceof Text) {
					return (/[\t ]/).test(this.dom().nextSibling.textContent[0]);
				};
				return false;
			};
			
			tag.prototype.unspaced = function (){
				return !(this.spaced());
			};
			
			tag.prototype.nextImmediate = function (){
				// could be text as well?
				return this.dom().nextSibling instanceof Text ? (null) : (this.next());
			};
			
			tag.prototype.prevImmediate = function (){
				// could be text as well?
				return this.dom().previousSibling instanceof Text ? (null) : (this.prev());
			};
			
			tag.prototype.repair = function (){
				return this;
			};
			
			tag.prototype.text = function (){
				return this.dom().textContent;
			};
			
			tag.prototype.setText = function (text){
				this.dom().textContent = text;
				return this;
			};
			
			tag.prototype.code = function (){
				return this.dom().textContent;
			};
			
			tag.prototype.setCode = function (code,silent){
				var hint_;
				if(silent === undefined) silent = false;
				var prev = this.code();
				
				if (this._dom.firstChild == this._dom.lastChild && (this._dom.firstChild instanceof Text)) {
					// still set if it has not changed?
					this._dom.firstChild.textContent = code;
				} else {
					this._dom.textContent = code;
				};
				
				if (code != prev) {
					(hint_ = this.hint()) && hint_.changed  &&  hint_.changed();
					if (!silent) { this.onchanged(code,prev) };
				};
				return this;
			};
			
			tag.prototype.onchanged = function (code,prev){
				return this.flag('dirty');
			};
			
			tag.prototype.size = function (){
				return this.code().length;
			};
			
			tag.prototype.view = function (){
				var parent_;
				return this._view || ((parent_ = this.parent()) && parent_.view  &&  parent_.view()) || VIEW;
			};
			
			tag.prototype.sel = function (){
				return this.view().caret();
			};
			
			tag.prototype.region = function (){
				return this.view().regionForNode(this);
			};
			
			tag.prototype.loc = function (){
				return this.region().loc();
			};
			
			tag.prototype.load = function (){
				return this;
			};
			
			tag.prototype.decreaseIndent = function (pre,state){
				return false;
			};
			
			tag.prototype.increaseIndent = function (pre,state){
				var reg = /^(\s*(.*\=\s*)?(class|def|tag|unless|if|else|elif|switch|try|catch|finally|for|while|until|do))/;
				return reg.test(pre);
			};
			
			tag.prototype.erase = function (region,mode){
				if (mode == 'all') {
					this.orphanize();
				} else {
					this.setCode(util.patchString(this.code(),'',region)); // code.ins('',region)
				};
				return this;
			};
			
			tag.prototype.insert = function (region,str,edit,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var mode = pars.mode !== undefined ? pars.mode : null;
				this.setCode(util.patchString(this.code(),str,region));
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				return this;
			};
			
			tag.prototype.oncommand = function (e,cmd){
				var name = cmd.command;
				var fn = this[name];
				this.log('run oncommand',name,cmd);
				
				if (fn instanceof Function) {
					fn.call(this,e,cmd);
				};
				return this;
			};
			
			tag.prototype.indentBlock = function (e){
				this.log('im.indentBlock',arguments,this);
				return this;
			};
			
			tag.prototype.clone = function (val){
				return IM.tok(val).classify();
			};
			
			tag.prototype.validate = function (code){
				return false;
			};
			
			tag.prototype.isFirst = function (){
				var par = this.parent();
				return (par instanceof IM.Types.Tok) && par.dom().firstChild == this.dom();
			};
			
			tag.prototype.isLast = function (){
				var par = this.parent();
				return (par instanceof IM.Types.Tok) && par.dom().lastChild == this.dom();
			};
			
			tag.prototype.isValid = function (code){
				if(code === undefined) code = this.text();
				return this.validate(code);
			};
			
			tag.prototype.markInvalid = function (){
				this.flag('invalid');
				return this;
			};
			
			tag.prototype.markValid = function (){
				this.unflag('invalid');
				return this;
			};
			
			tag.prototype.isInvalid = function (){
				return this.hasFlag('invalid');
			};
			
			tag.prototype.classify = function (){
				return this;
			};
			
			// unwrap / remove this node from parent
			tag.prototype.unwrap = function (){
				var el = this.dom();
				var par = el.parentNode;
				
				while (el.firstChild){
					par.insertBefore(el.firstChild,el);
				};
				return this;
			};
			
			tag.prototype.replaceWith = function (other){
				this.setPrev(other);
				return this.orphanize();
			};
			
			tag.prototype.scope = function (){
				return this.closest(q$('._indent',this));
			};
			
			tag.prototype.mutated = function (muts){
				// remove node if it is orphanized
				var self = this;
				if (self.code() == '') {
					self.log('remove whole node');
					// should possibly
					return self.orphanize();
				} else {
					self.log('mutated -- reparse');
					return self.view().observer().pause(function() {
						return self.view().highlighter().reparse(self.dirtyExtent());
					});
				};
			};
			
			
			tag.prototype.reclassify = function (type){
				// reclassify should happen through the highlighter
				// log 'reclassify node as type',type
				var cls = IM.Types[type] || Imba.TAGS[("im" + type)];
				
				if (cls) {
					// log 'found class to reclassify as',cls,self:constructor
					if (cls == this.constructor) {
						return this;
					};
					
					// log 'found class to reclassify as',cls
					var node = new cls(this.dom()).setup();
					return node;
				};
				return this;
			};
			
			tag.prototype.reparsed = function (){
				return this;
			};
			
			tag.prototype.baseClasses = function (){
				var cls = this.constructor.dom().className;
				if (this._type) { cls += ' ' + this._type };
				return cls;
			};
			
			tag.prototype.setup = function (){
				this._dom.className = this.baseClasses();
				return this;
			};
			
			tag.prototype.reuse = function (){
				return this.setup.apply(this,arguments);
			};
			
			tag.prototype.isAtomic = function (){
				return false;
			};
			
			// find the nodes / region that should be reparsed if this element has changed
			// this is currently quote 
			
			tag.prototype.dirtyExtent = function (){
				// 3log "get dirty extent for",dom
				var self = this, sel, sel1, sel2, $1;
				if (sel = self.up(q$('.selector',self))) {
					return sel.dirtyExtent();
				} else if (sel1 = self.up(q$('._imtagnode',self))) {
					return sel1.dirtyExtent();
				} else if (sel2 = self.up(q$('._imistring',self))) {
					return sel2.dirtyExtent();
				};
				
				if (self.isAtomic()) { // hmm
					return {
						nodes: [self.dom()],
						code: self.code(),
						contains: function(el) { return self.dom().contains(el._dom || el); }
					};
				};
				
				var start = self.dom();
				var end = self.dom();
				
				var prev,next;
				var nodes = [self.dom()];
				var opener,closer;
				
				while (prev = start.previousSibling){
					if (prev instanceof Text) {
						break;
					} else if (prev.matches('._imnewline,._imtab')) { // ,._imopen,._imclose
						break;
					};
					
					if (prev.matches('._imopen')) {
						opener = prev;
					};
					
					start = prev;
					nodes.unshift(start);
				};
				
				while (next = end.nextSibling){
					if (next instanceof Text) {
						break;
					} else if (next.matches('._imnewline')) { // ._imopen,._imclose
						break;
					};
					
					if (next.matches('._imclose')) {
						closer = next;
					};
					
					end = next;
					nodes.push(end);
				};
				
				// see if we include an open or close-tag
				
				var result = {
					nodes: nodes,
					code: "",
					target: self.dom(),
					nested: [],
					contains: function(node) { return this.nodes.indexOf(node) >= 0; }
				};
				
				if (opener || closer) {
					// log "includes opener and / or closer",opener,closer
					var par = tag$wrap((opener || closer).parentNode);
					if (($1 = par) && $1.isAtomic  &&  $1.isAtomic()) {
						// log 'return the parent dirty extent',par
						return par.dirtyExtent();
					};
					
					for (var i = 0, ary = iter$((opener || closer).parentNode.children), len_ = ary.length, res = []; i < len_; i++) {
						res.push(ary[i]);
					};
					nodes = res;
				};
				
				var loc = 0;
				
				// should use the tags directly
				for (var i = 0, ary = iter$(nodes), len_ = ary.length, node; i < len_; i++) {
					node = ary[i];
					var rich = tag$wrap(node);
					var text = node.textContent;
					var len = text.length;
					
					if (false) {
						text = "''";
						len = 5;
						self.log("added node as nested reference",rich.dom());
						// this is fucked up
						// this really does mess up the rich nodes here(?!)
						result.nested.push(rich);
					};
					
					result.code += text;
					loc += len;
				};
				
				result.nodes = nodes;
				return result;
			};
			
			tag.prototype.reparseExtent = function (e){
				var self = this;
				return self.view().observer().pause(function() {
					var dirty = self.dirtyExtent();
					if (e) { e.handled() };
					return Highlighter.reparse(dirty);
				});
			};
		});
		
		
		// piece of unparsed code
		tag$.defineTag('imraw', 'im', function(tag){
			tag.type('raw');
			tag.alias('@');
			
			tag.prototype.setRaw = function (raw){
				this._raw = raw;
				this._dom.textContent = raw;
				return this;
			};
			
			tag.prototype.onedit = function (e){
				this.setCode(e.patch(this));
				return e.handled();
			};
		});
		
		tag$.defineTag('imfragment', 'imraw', function(tag){
			tag.type('fragment');
			
			tag.prototype.setContent = function (content){
				if (typeof content == 'string') {
					this.dom().innerHTML = content;
				} else {
					tag.__super__.setContent.apply(this,arguments);
				};
				return this;
			};
			
			tag.prototype.repair = function (){
				this.unwrap();
				this.orphanize();
				return this;
			};
		});
		
		IMFragment = Imba.TAGS.imfragment;
		
		tag$.defineTag('imopen', 'im', function(tag){
			
			// @nodeType = 's'
			tag.type('open');
			
			tag.alias('[');
			tag.alias('(');
			tag.alias('{');
			tag.alias('{{');
			tag.alias('index_start');
			tag.alias('block_param_start');
		});
		
		tag$.defineTag('imclose', 'im', function(tag){
			
			tag.type('close');
			// @nodeType = 's'
			
			tag.alias(']');
			tag.alias(')');
			tag.alias('}');
			tag.alias('}}');
			tag.alias('index_end');
			tag.alias('block_param_end');
		});
		
		tag$.defineTag('imrparen', 'imclose', function(tag){
			tag.type('rparen');
			tag.alias(')');
		});
		
		tag$.defineTag('imtagopen', 'imopen', function(tag){
			tag.type('tag_start');
		});
		
		tag$.defineTag('imtagclose', 'imclose', function(tag){
			tag.type('tag_end');
		});
		
		tag$.defineTag('imselopen', 'imopen', function(tag){
			tag.type('selector_start');
		});
		
		tag$.defineTag('imselclose', 'imclose', function(tag){
			tag.type('selector_end');
		});
		
		tag$.defineTag('imquote', 'im');
		
		tag$.defineTag('imsinglequote', 'imquote', function(tag){
			tag.type("'");
		});
		
		tag$.defineTag('imdoublequote', 'imquote', function(tag){
			tag.type('"');
		});
		
		tag$.defineTag('imstrstart', 'imopen', function(tag){
			tag.type('string_start');
		});
		
		return tag$.defineTag('imstrend', 'imclose', function(tag){
			tag.type('string_end');
		});
	
	})()

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		var Region = __webpack_require__(27).Region;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		
		var keywords = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil','extend','export','own'
		];
		
		// this is really the general token
		tag$.defineTag('imtok', 'im', function(tag){
			tag.alias('token');
			
			
			tag.prototype.__eref = {watch: 'erefDidSet',name: 'eref'};
			tag.prototype.eref = function(v){ return this.getAttribute('eref'); }
			tag.prototype.setEref = function(v){
				var a = this.eref();
				if(v != a) { this.setAttribute('eref',v); }
				if(v != a) { this.erefDidSet && this.erefDidSet(v,a,this.__eref) }
				return this;
			};
			
			tag.prototype.erefDidSet = function (new$,old){
				// experimental
				// console.log 'erefDidSet',new,old
				if (!(new$ && old)) { this.flag('lvar',!(!(new$))) };
				return this;
			};
			
			tag.prototype.isVarRef = function (){
				return this.hasFlag('lvar');
			};
			
			tag.prototype.clearVarRef = function (){
				this.setEref(null);
				return this;
			};
			
			tag.prototype.clone = function (val){
				return IM.tok(val);
			};
			
			tag.prototype.setText = function (text){
				tag.__super__.setText.call(this,text);
				this.classify();
				
				var typ = IM.identify(text);
				
				if (typ) {
					this.log('reclassifying imtok immediately');
					this.setCode(text);
					return this.reclassify(typ);
				};
				
				// return raw token if not classified?
				return this._typ ? (this) : (tag$.$imraw().setRaw(text).end());
			};
			
			tag.prototype.canPrepend = function (text){
				return true;
			};
			
			tag.prototype.canAppend = function (text){
				return true;
			};
			
			tag.prototype.classify = function (map){
				map || (map = IM.identify(this.code()));
				if (map) {
					if (!map.match(/\b_[\w]/)) { map = '_imtok ' + map };
					this.dom().className = map;
					this._typ = map;
				} else {
					this._typ = null;
				};
				return this;
			};
			
			tag.prototype.validate = function (code){
				return false;
			};
			
			tag.prototype.repair = function (){
				this.log('repair');
				this.classify();
				return this;
			};
			
			tag.prototype.split = function (region){
				region = Region.normalize(region);
				var lft = this.code().substring(0,region.start());
				var rgt = this.code().slice(region.end());
				
				this.setCode(lft);
				this.setNext(IM.tok(rgt));
				return this;
			};
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				var dirty = this.dirtyExtent();
				this.view().observer().pause(function() { return Highlighter.reparse(dirty); });
				return this;
			};
			
			tag.prototype.reuse = function (tok,new$,old){
				if (new$ == old) { return this };
				return tag.__super__.reuse.apply(this,arguments);
			};
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && this.validate(this.code())) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
			
			tag.prototype.ondblclick = function (e){
				e.halt();
				return this.select();
			};
			
			tag.prototype.onmouseover = function (e){
				e.halt();
				
				if (this.eref()) {
					return this.view().nodesForEntity(this.eref()).map(function(el) { return el.flag('hl'); });
				};
			};
			
			tag.prototype.onmouseout = function (e){
				e.halt();
				if (this.eref()) {
					return this.view().nodesForEntity(this.eref()).map(function(el) { return el.unflag('hl'); });
				};
			};
		});
		
		
		tag$.defineTag('imidentifier', 'imtok', function(tag){
			tag.type('identifier');
			
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			tag.prototype.validate = function (code){
				// regex for identifier
				return (/^[a-z](-?[\wA-Za-z_\-\x7f-\uffff\$]+)*$/).test(code) && keywords.indexOf(code) == -1;
			};
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'identifier setup',baseClasses
				var v_;
				if (tok && tok._value) { (this.setName(v_ = tok._value),v_) };
				this._dom.className = this.baseClasses();
				return this;
			};
			
			tag.prototype.mutated = function (){
				// console.log 'imidentifier mutated'
				this.setName(this.code());
				if (this.isVarRef()) {
					this.clearVarRef();
				};
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imtagtype', 'imtok', function(tag){
			tag.type('tag_type');
		});
		
		tag$.defineTag('imtagid', 'imtok', function(tag){
			tag.type('tag_id');
			tag.alias('idref');
		});
		
		tag$.defineTag('imconst', 'imtok', function(tag){
			tag.type('const');
			
			tag.prototype.validate = function (code){
				return (/^[A-Z](-?[\wA-Za-z_\-\x7f-\uffff\$]+)*$/).test(code);
			};
			
			// def onchanged code, prev
			// 	# console.log 'imconst onchanged',code,prev
			// 	flag('dirty') unless validate(code)
		});
		
		
		tag$.defineTag('imivar', 'imtok', function(tag){
			tag.type('ivar');
		});
		
		tag$.defineTag('imcvar', 'imtok', function(tag){
			tag.type('cvar');
		});
		
		tag$.defineTag('imkeyword', 'imtok', function(tag){
			tag.type('keyword');
			tag.alias('new');
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'setup imkeyword',tok, new, old
				var cls = this.baseClasses();
				if (tok && tok._value) { cls += ' ' + tok._value };
				this._dom.className = cls;
				return this;
			};
		});
		
		keywords.map(function(keyword) { return IM.Types[keyword] = IM.Types.keyword; });
		
		IM.Types.forin = IM.Types.keyword;
		IM.Types.forof = IM.Types.keyword;
		IM.Types.post_if = IM.Types.keyword;
		IM.Types.post_unless = IM.Types.keyword;
		IM.Types.post_for = IM.Types.keyword;
		IM.Types.post_while = IM.Types.keyword;
		
		tag$.defineTag('imnum', 'imtok', function(tag){
			tag.type('number');
			
			tag.prototype.validate = function (code){
				return (/^\d+(\.\d+)?$/).test(code);
			};
			
			tag.prototype.reuse = function (){
				return this;
			};
		});
		
		tag$.defineTag('imint', 'imnum', function(tag){
			tag.type('int');
		});
		
		tag$.defineTag('imfloat', 'imnum', function(tag){
			tag.type('float');
		});
		
		tag$.defineTag('imbool', 'imtok', function(tag){
			tag.type('bool');
			tag.alias('true');
			tag.alias('false');
		});
		
		// this should be more advanced - no
		tag$.defineTag('imstr', 'imtok', function(tag){
			tag.type('string');
			
			tag.prototype.quote = function (){
				return this.code()[0];
			};
			
			tag.prototype.setQuote = function (quote){
				this.setCode(quote + this.code().slice(1,-1) + quote);
				return this;
			};
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'setup string',tok, new, old
				this._dom.className = this.baseClasses();
				this.setCode(new$);
				return this;
			};
			
			tag.prototype.onunwrap = function (e){
				var v_;
				this.log('imstring onunwrap!!!',e);
				e.halt();
				// look at prev and next as well?
				// should do this through the view
				return (this.setCode(v_ = this.code().slice(1,-1)),v_);
			};
			
			tag.prototype.ondblclick = function (e){
				e.halt();
				return this.select();
			};
			
			tag.prototype.validate = function (code){
				if (code[0] == '"') {
					return (/^\"([^"\{]*)\"$/).test(code);
				} else if (code[0] == "'") {
					return (/^\'([^'\{]*)\'$/).test(code);
				};
			};
			
			tag.trigger('"',function(token,o) {
				if (o.mode == 'all') {
					token.setQuote('"');
					return true;
				} else if (token.quote() == '"') {
					this.insert('\\"');
					return true;
				} else {
					return this.insert('"');
				};
			});
			
			
			tag.trigger("'",function(token,o) {
				var v_;
				if (o.mode == 'all') {
					return (token.setQuote(v_ = "'"),v_);
				} else if (token.quote() == "'") {
					this.insert("\\'");
					return true;
				} else {
					return this.insert("'");
				};
			});
		});
		
		
		
		tag$.defineTag('imneostring', 'imtok', function(tag){
			tag.type('neostring');
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && !this.code().match(/[\{\"\']/)) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imsym', 'imtok', function(tag){
			tag.type('symbol');
		});
		
		return tag$.defineTag('imtagattr', 'imtok', function(tag){
			tag.type('tag_attr');
		});
	
	})()

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var Highlighter = __webpack_require__(29).Highlighter;
		var util = __webpack_require__(34);
		
		tag$.defineTag('imblock', 'im', function(tag){
			
			tag.prototype.deleteLeftRight = function (e){
				this.log('imblock deleteLeftRight',e.region().peek(-1,1));
				
				if (e.region().peek(-1,1) == this.code()) {
					this.orphanize();
					return e.handled();
				};
				
				return this;
			};
			
			tag.prototype.indentBlock = function (e){
				var self = this;
				e.handled();
				
				self.view().caret().expandToLines();
				var region = self.view().caret().region();
				var nodes = self.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline')) {
						self.log('found tab in selection',match);
						if (match.mode != 'start') {
							return match.node.indent();
						};
					};
				});
				
				self.view().caret().dirty();
				return self;
			};
			
			tag.prototype.undent = function (e){
				this.log('imblock.undent',arguments);
				var nodes = e.view().nodesInRegion(e.region().clone().startAtLine());
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						return match.node.undent();
						// e.caret.expand(0,-1)
					};
				});
				this.view().caret().expandToLines();
				return e.handled();
			};
			
			tag.prototype.pairable = function (str,e){
				return true;
			};
			
			tag.prototype.wrap = function (node){
				this.setChildren([node]);
				return this;
			};
			
			tag.prototype.repair = function (){
				// log "repair block"
				q$('._imraw',this).map(function(raw) { return raw.repair(); });
				return this;
			};
			
			tag.prototype.rehighlight = function (){
				// var reg = view.sel.region
				var self = this;
				var state = self.codeState();
				var hl = IM.parse(state.code);
				// could send this through load instead
				// what about annotations here?
				throw 'dont rehighlight';
				
				if (hl) {
					self.view().observer().pause(function() {
						self.dom().innerHTML = hl + '\n';
						return state.invalids.map(function(inv) {
							// we could go local instead
							var node;
							if (node = self.view().nodeAtRegion(inv.region,true)) {
								self.log('found node at invalid position',node);
								return node.replaceWith(inv.node);
							};
						});
					});
				};
				return self;
			};
			
			// bad naming
			tag.prototype.codeState = function (){
				var self = this;
				var real = self.code();
				var valid = real;
				var invalids = q$('.invalid',self);
				var ownreg = self.region();
				var selreg = self.view().sel().region();
				
				var remember = invalids.map(function(inv) {
					// multilevel nesting?
					var region = inv.region();
					var relreg = region.relativeTo(ownreg);
					self.log('invalid region',ownreg,'self',region,relreg);
					valid = valid.ins(inv.placeholder(),relreg);
					return {region: region,placeholder: inv.placeholder(),raw: inv.code(),node: inv,root: self,relRegion: relreg};
				});
				
				return {
					region: ownreg,
					marker: (selreg.intersects(ownreg) ? (selreg) : (null)),
					raw: real,
					code: valid,
					invalids: remember
				};
			};
		});
		
		
		tag$.defineTag('iminterpolated', 'imblock');
		
		tag$.defineTag('indent', 'imblock', function(tag){
			
			tag.prototype.variables = function (){
				var map = {};
				var vars = [];
				q$('._lvar',this).map(function(lvar) {
					var name = lvar.text();
					if (!map[name]) {
						map[name] = true;
						return vars.push(name);
					};
				});
				return vars;
			};
		});
		
		tag$.defineTag('impair', 'imblock', function(tag){
			tag.type('pair');
			
			tag.pair = function (open,close){
				this.prototype._open = open;
				this.prototype._close = close;
				return this;
			};
			
			tag.prototype.open = function (){
				return this._open || '';
			};
			tag.prototype.close = function (){
				return this._close || '';
			};
			
			tag.prototype.build = function (){
				this.gen();
				return this;
			};
			
			tag.prototype.setContent = function (content){
				throw 'should not get here';
				this.dom().innerHTML = this.open() + IM.parse(content) + this.close();
				return this;
			};
			
			tag.prototype.isEmpty = function (){
				return this.code().replace(/[\s\t \n]/,'') == (this.open() + this.close());
			};
			
			tag.prototype.isPaired = function (){
				var code = this.code();
				return code[0] == this.open() && code[code.length - 1] == this.close();
			};
			
			tag.prototype.isOpened = function (){
				return this.code()[0] == this.open();
			};
			
			tag.prototype.isClosed = function (){
				return this.code()[this.code().length - 1] == this.close();
			};
			
			tag.prototype.unwrap = function (){
				if (this.isEmpty()) {
					this.log('remove the whole thing');
					this.orphanize();
				} else {
					var el;
					var par = this.parent();
					while (el = this._dom.firstChild){
						par.dom().insertBefore(el,this._dom);
					};
					// remove self as well
				};
				return this;
			};
			
			tag.prototype.onunwrap = function (e){
				this.log('impair onunwrap!!!',e);
				return e.halt();
			};
			
			tag.prototype.gen = function (){
				this.setChildren([
					tag$.$imopen().setContent(this.open(),0).end(),
					tag$.$imclose().setContent(this.close(),0).end()
				]);
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				e.setCaret(this.region().collapse(false).move(1));
				return this;
			};
			
			tag.prototype.select = function (){
				return this;
			};
			
			tag.prototype.onlinebreak = function (e){
				var pre = e.linestr('pre');
				var indent = e.indent();
				var new$ = this.text().ins('',e.relRegion());
				
				// this is a special case - no?
				if (new$ == (this.open() + this.close())) {
					var prefix = '\n' + indent + '\t';
					var post = '\n' + indent;
					this.onwhitespace(e,prefix + post);
					e.caret().collapse(false).move(-post.length);
					return e.handled();
				};
				
				// need to first consider the splitting, no?
				if (this.increaseIndent(pre)) { indent += '\t' };
				if (this.decreaseIndent(pre)) { indent = indent.slice(1) };
				this.onwhitespace(e,'\n' + indent);
				return e.handled();
			};
			
			tag.prototype.repair = function (){
				this.log('repair imtag');
				if (!(this.isPaired())) { this.revalidate(true) };
				return this;
			};
			
			tag.prototype.mutated = function (){
				this.log('impair mutated');
				return this.revalidate();
			};
			
			tag.prototype.defaultValidationMode = function (){
				return 'tokenize';
			};
			
			tag.prototype.rehighlight = function (){
				return this;
			};
			
			tag.prototype.revalidate = function (mode,write){
				// tricky motherfucker -- mostly useful for validations
				// I suppose we can do this a simpler way -- by turning
				// off observers -- temporarily replacing inner code etc
				
				// when a block checks validity it should probably
				// substitute inner invalid parts - so that the block
				// thing is still valid
				var self = this, hl;
				if(mode === undefined) mode = self.defaultValidationMode();
				if(write === undefined) write = false;
				var wasInvalid = self.hasFlag('invalid');
				var oldState = self.hasFlag('invalid');
				var state = self.codeState();
				var code = state.code;
				
				if (!(self.isPaired())) {
					return self.markInvalid();
				};
				
				console.log('will revalidate with code',code);
				console.time('revalidate');
				
				try {
					if (mode == 'compile') {
						self._output = Imbac.compile(code,{bare: true});
						self._tokens = self._output.options._tokens;
					} else {
						self._tokens = Imbac.tokenize(code,{bare: true});
					};
					self.markValid();
				} catch (e) {
					self._tokens = null;
					self.markInvalid();
				};
				
				console.timeEnd('revalidate');
				
				if (wasInvalid && self._tokens) {
					// need to fix inner for root
					if (hl = Highlighter.highlight(code,{tokens: self._tokens,inner: true})) {
						// this should be refactored out into a separate method
						// possibly do loadState / dumpState
						self.view().observer().pause(function() {
							self.dom().innerHTML = hl;
							state.invalids.map(function(inv) {
								var node;
								if (node = self.view().nodeAtRegion(inv.region,true)) {
									return node.replaceWith(inv.node);
								};
							});
							if (state.marker) { return self.view().sel().set(state.marker) };
						});
					};
				};
				
				return self;
			};
			
			tag.prototype.placeholder = function (){
				return this.open() + (' ').repeat(this.size() - 2) + this.close();
			};
			
			tag.prototype.isAtomic = function (){
				return true;
			};
			
			tag.prototype.mutated = function (){
				this.log('muated imcurly');
				this.view().highlighter().reparse(this.dirtyExtent());
				return this;
			};
		});
		
		tag$.defineTag('imcurly', 'impair', function(tag){
			tag.type('curly');
			tag.pair('{','}');
		});
		
		tag$.defineTag('imsquare', 'impair', function(tag){
			tag.type('square');
			tag.pair('[',']');
			
			tag.prototype.prettify = function (e){
				var self = this;
				self.log('prettify!');
				e.handled();
				var ind = e.region().indent();
				self.log('with indentation',ind,ind.length);
				
				self.view().observer().pause(function() {
					for (var i = 0, ary = iter$(self.children()), len = ary.length, child, res = []; i < len; i++) {
						child = ary[i];
						res.push(child.matches('.comma,._imopen') ? (
							child.setNext('\n' + ind + '\t')
						) : ((child.matches('._imclose')) && (
							child.setPrev('\n' + ind)
						)));
					};
					return res;
				});
				
				return true;
			};
		});
		
		tag$.defineTag('imparens', 'impair', function(tag){
			tag.type('parens');
			tag.pair('(',')');
			
			tag.prototype.onunwrap = function (e){
				this.log('impair onunwrap!!!',e);
				e.halt();
				// look at prev and next as well?
				// should do this through the view
				this.setCode(' ' + this.code().slice(1,-1));
				return this.view().repair();
			};
		});
		
		tag$.defineTag('imistring', 'impair', function(tag){
			tag.type('istring');
			tag.pair('"','"');
		});
		
		tag$.defineTag('imiexpr', 'impair', function(tag){
			tag.type('iexpr');
			tag.pair('{','}');
		});
		
		tag$.defineTag('imblockparams', 'impair', function(tag){
			tag.type('blockparams');
			tag.pair('|','|');
		});
		
		return tag$.defineTag('imtagnode', 'impair', function(tag){
			tag.type('tagnode');
			tag.pair('<','>');
			
			tag.prototype.pairable = function (str,e){
				return idx$(str,['{','[','(','"',"'"]) >= 0;
			};
			
			tag.prototype.placeholder = function (){
				return this.open() + ('x').repeat(this.size() - 2) + this.close();
			};
			
			tag.prototype.defaultValidationMode = function (){
				return 'compile';
			};
		});
	
	})()

/***/ },
/* 51 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('imroot', 'imblock', function(tag){
			
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag._nodeType = 'code';
			// def self.dom
			//	@dom ||= document.createElement('code')
			
			tag.prototype.tryUndent = function (e){
				var self = this;
				self.log('tryUndent');
				var nodes = e.view().nodesInRegion(e.region().clone().startAtLine());
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						match.node.undent();
						return self.view().caret().move(-1);
						// e.caret.move(-1)
						// e.caret.expand(0,-1)
					};
				});
				
				// e.moveCaret = 0
				e.handled();
				return self;
			};
			
			tag.prototype.build = function (){
				tag.__super__.build.apply(this,arguments);
				
				this.dom().addEventListener('');
				return this;
			};
			
			tag.prototype.commit = function (){
				return this;
			};
			
			tag.prototype.setNext = function (node){
				this.appendChild(node);
				return node;
			};
			
			tag.prototype.setPrev = function (node){
				var first = this.dom().firstChild;
				first ? (this.insertBefore(node,first)) : (this.appendChild(node));
				return node;
			};
			
			tag.prototype.onlinebreak = function (e){
				var pre = e.linestr('pre');
				var indent = e.indent();
				var new$ = this.text().ins('',e.relRegion());
				// need to first consider the splitting, no?
				if (this.increaseIndent(pre)) { indent += '\t' };
				if (this.decreaseIndent(pre)) { indent = indent.slice(1) };
				this.onwhitespace(e,'\n' + indent);
				return e.handled();
			};
			
			tag.prototype.mutated = function (){
				this.log('imroot mutated');
				return this;
			};
			
			tag.prototype.dirtyExtent = function (){
				var self = this;
				self.log('imroot dirtyExtent');
				// super
				var nodes = self.children().map(function(n) { return n.dom(); });
				
				return {
					code: self.code(),
					nodes: nodes,
					parent: self.dom(),
					contains: function(el) { return self.dom().contains(el._dom || el); }
				};
			};
		});
	
	})()

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		// externs;
		
		var util = __webpack_require__(34);
		
		var SINGLE_STR = /^'[^']*'$/;
		var DOUBLE_STR = /^"[^"\{]*"$/;
		var COMMENT = /^\#[ \t][^\n]*$/;
		
		DOUBLE_STR = /^"([^\\"\{]|\\\\|\\")*"$/;
		
		tag$.defineTag('imlit', 'im', function(tag){
			
			tag.prototype.validate = function (code){
				return false;
			};
		});
		
		return tag$.defineTag('imregex', 'imlit', function(tag){
			
			tag.type('regex');
			
			tag.prototype.validate = function (value){
				return true;
			};
			
			tag.prototype.pairing = function (chr){
				return this;
			};
			
			tag.prototype.revalidate = function (){
				var reg = this.code();
				try {
					var obj = eval(reg);
				} catch (e) { };
				this.log('regex is',reg,obj);
				this.flag('invalid',!obj);
				return this;
			};
			
			tag.prototype.mutated = function (){
				this.log('regex mutated');
				return this.revalidate();
			};
			
			tag.prototype.placeholder = function (){
				return '/' + 'R'.repeat(this.size() - 2) + '/';
			};
			
			tag.prototype.isAtomic = function (){
				return true;
			};
		});
		
	
	})()

/***/ },
/* 53 */
/***/ function(module, exports) {

	(function(){
		
		// should rather reconcile into token - or something like it
		var names = {
			'.': 'dot',
			'=': 'eq',
			'?': 'q',
			'!': 'unary',
			':': 'colon',
			',': 'comma',
			'#': 'hash',
			'*': 'mult',
			'>>': 'bitshift'
		};
		
		tag$.defineTag('imop', 'im', function(tag){
			
			tag.type('op');
			tag.alias('relation');
			tag.alias('compare');
			tag.alias('compound_assign');
			tag.alias('assign');
			tag.alias('block_arg');
			tag.alias('splat');
			tag.alias('logic');
			tag.alias('math');
			tag.alias('shift');
			tag.alias('unary');
			
			tag.prototype.validate = function (code){
				return IM.isOp(code);
			};
			
			tag.prototype.baseClasses = function (){
				return tag.__super__.baseClasses.apply(this,arguments) + ' ' + (names[this.code()] || '');
			};
			
			tag.prototype.setup = function (token){
				var val = token && token._value || this.code();
				this.dom().className = ("_im _imop op " + (names[val] || ''));
				return this;
			};
			
			// should merge with a more generic version for token in general
			// same goes for text etc
			tag.prototype.insert = function (){
				tag.__super__.insert.apply(this,arguments);
				
				if (this.code() == '//') {
					this.log('is a regex!!');
					return this.reclassify('regex');
				};
			};
		});
		
		// link regular ops to op-node
		return '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ? &= ||= &&= ?. ?: , ! .. ... .: >> << #'.split(' ').map(function(op) {
			return IM.Types[op] = IM.Types.op;
		});
		
		
		// IM.Types:logic = IM.Types:op
		// IM.Types:compare = IM.Types:op
		// IM.Types:math = IM.Types:op
		// IM.Types:shift = IM.Types:op
		
	
	})()

/***/ },
/* 54 */
/***/ function(module, exports) {

	(function(){
		
		// this should be more advanced than this, no?
		tag$.defineTag('imsel', 'imtok', function(tag){
			tag.type('selector');
			
			tag.prototype.isAtomic = function (){
				return true;
			};
			
			tag.prototype.reparsed = function (code,old){
				this.log("imsel reparsed",code,old);
				return this;
			};
		});
		
		tag$.defineTag('imseltag', 'imtok', function(tag){
			tag.type('selector_tag');
		});
		
		tag$.defineTag('imselclass', 'imtok', function(tag){
			tag.type('selector_class');
		});
		
		tag$.defineTag('imselcomb', 'imtok', function(tag){
			tag.type('selector_combinator');
		});
		
		tag$.defineTag('imselattrop', 'imtok', function(tag){
			tag.type('selector_attr_op');
		});
		
		return tag$.defineTag('imselattrop', 'imtok', function(tag){
			tag.type('selector_attr_op');
		});
	
	})()

/***/ },
/* 55 */
/***/ function(module, exports) {

	(function(){
		tag$.defineTag('iminsert', 'im', function(tag){
			
			tag.prototype.canAppend = function (){
				return true;
			};
			
			tag.prototype.canPrepend = function (){
				return true;
			};
			
			tag.prototype.insert = function (reg,ins){
				console.log('insert code into iminsert!!',ins,reg);
				
				if (ins instanceof IM.Types.fragment) {
					ins = ins.code();
				} else if (ins instanceof IM.Types.raw) {
					ins = ins._raw;
				} else if ((typeof ins=='string'||ins instanceof String)) {
					ins = (this.code() || "").ins(ins,reg);
				};
				
				this.setCode(ins);
				return this;
			};
			
			tag.prototype.isWhitespace = function (){
				return this.code().match(/^[\n\t\ ]+$/);
			};
			
			tag.prototype.mutated = function (){
				this.log('iminsert mutated');
				
				var dirty = this.dirtyExtent();
				this.view().highlighter().reparse(dirty);
				return this;
			};
		});
		
		tag$.defineTag('imwhitespace', 'im', function(tag){
			
			tag.prototype.canPrepend = function (str){
				return this.validate(str + this.code());
			};
			
			tag.prototype.canAppend = function (str){
				return this.validate(this.code() + str);
			};
			
			tag.prototype.validate = function (){
				return false;
			};
		});
		
		tag$.defineTag('imnewline', 'imwhitespace', function(tag){
			
			tag.type('newline');
			tag.alias('\n');
			
			tag.prototype.canPrepend = function (str){
				if (str.match(/^[\n\t\ ]+$/)) {
					// should not really be able to prepend here
					// it shold rather insert a new newline in
					// an iminsert, and that should be able to
					// decide that no reparse is needed
					return true;
				};
				return false;
			};
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return val == '\n';
			};
			
			tag.prototype.indent = function (){
				this.view().insert(this.region().end(),'\t');
				return this;
			};
			
			tag.prototype.undent = function (){
				this.log('undent newline');
				var reg = this.region().clone().collapse(true).clone(0,1);
				if (reg.text() == '\t') {
					this.log('can undent!!');
					this.view().erase(reg);
				};
				
				// view.observer.pause do
				//	next.orphanize if next?.matches('._imtab')
				return this;
			};
			
			tag.prototype.mutated = function (){
				// log 'imnewline mutated!!'
				// remove node if it is orphanized
				if (this.code() == '') {
					this.log('remove whole node');
					return this.orphanize();
				} else {
					this.log('reparse newline');
					return this.view().highlighter().reparse({nodes: [this.dom()],code: this.code()});
				};
			};
		});
		
		
		
		tag$.defineTag('imspace', 'imwhitespace', function(tag){
			
			tag.type('whitespace');
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return (/^[ ]+$/).test(val);
			};
			
			// this should be the default for all nodes, no?
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && this.validate(this.code())) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imsemicolon', 'imwhitespace', function(tag){
			tag.type('semicolon');
			tag.alias(';');
		});
		
		tag$.defineTag('imtab', 'imwhitespace', function(tag){
			
			tag.type('tab');
			tag.alias('\t');
			
			tag.prototype.onedit = function (e){
				if (e.isSurrounded()) {
					this.log('delete tab?!?');
					if (e.text()) { // otherwise we really are done
						e.redirect(this.prev() || this.next() || this.parent());
					} else {
						e.handled();
					};
					
					e.region().collapse(false);
					this.orphanize();
					return;
				};
			};
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return val == '\t';
			};
		});
		
		tag$.defineTag('imcomment', 'im', function(tag){
			
			tag.type('comment');
			
			tag.prototype.validate = function (code){
				return COMMENT.test(code);
			};
			
			tag.prototype.mutated = function (){
				this.log('imcomment mutated');
				return tag.__super__.mutated.apply(this,arguments);
			};
			
			tag.prototype.repair = function (){
				this;
				this.log('repair comment');
				var region = this.region().endAtLine();
				var full = region.text(); // should not include the last line?
				var nodes = region.nodes(false);
				this.log('whole region should be',region,full,nodes);
				this.log('all nodes',nodes);
				
				// VERY temporary
				if (nodes.length > 1) {
					this.setCode(full);
					while (nodes.length > 1){
						var el = nodes.pop();
						el.node.orphanize();
					};
				};
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				return this.repair();
			};
			
			tag.prototype.canPrepend = function (text){
				return false;
			};
			
			tag.prototype.canAppend = function (text){
				if (!text.match(/[\n]/)) { return true };
			};
		});
		
		
		// allow inserting additional tabs directly here?
		
		return tag$.defineTag('eof');
	
	})()

/***/ },
/* 56 */
/***/ function(module, exports) {

	(function(){
		
		
		tag$.defineTag('imwarn', 'im', function(tag){
			
			
			
			tag.prototype.message = function(v){ return this.getAttribute('message'); }
			tag.prototype.setMessage = function(v){ this.setAttribute('message',v); return this; };
			
			tag.prototype.build = function (){
				this.log('built error with error',this.object());
				return this;
			};
		});
		
		return tag$.defineTag('imerr', 'imwarn');
	
	})()

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var Router = __webpack_require__(58).Router;
		
		function App(){
			this.setCache({});
			this.setDeps({});
			this.reset();
			this.tick();
			this;
		};
		
		exports.App = App; // export class 
		
		
		App.prototype.req = function(v){ return this._req; }
		App.prototype.setReq = function(v){ this._req = v; return this; };
		
		
		App.prototype.res = function(v){ return this._res; }
		App.prototype.setRes = function(v){ this._res = v; return this; };
		
		
		App.prototype.deps = function(v){ return this._deps; }
		App.prototype.setDeps = function(v){ this._deps = v; return this; };
		
		
		App.prototype.site = function(v){ return this._site; }
		App.prototype.setSite = function(v){ this._site = v; return this; };
		
		
		App.prototype.cache = function(v){ return this._cache; }
		App.prototype.setCache = function(v){ this._cache = v; return this; };
		
		
		App.prototype.issues = function(v){ return this._issues; }
		App.prototype.setIssues = function(v){ this._issues = v; return this; };
		
		App.prototype.reset = function (){
			this.setCache({});
			return this;
		};
		
		App.prototype.router = function (){
			return this._router || (this._router = new Router(this));
		};
		
		App.prototype.path = function (){
			return  false ? (this.req().path) : (this._path);
		};
		
		App.prototype.hash = function (){
			return '';
		};
		
		App.prototype.hash = function (){
			return  false ? ('') : (document.location.hash.substr(1));
		};
		
		App.prototype.tick = function (){
			if (true) {
				this._path = document.location.pathname;
			};
			
			return this;
		};
		
		App.prototype.schedule = function (){
			Imba.schedule(this);
			return this;
		};
		
		App.prototype.unschedule = function (){
			Imba.unschedule(this);
			return this;
		};
		
		App.prototype.fetchDocument = function (src,cb){
			
			var deps_, $1, $3, $2;
			if (false) {
				var fs = require('fs');
				var path = require('path');
				
				var filepath = ("" + __dirname + "/../docs/" + src).replace(/\/\//g,'/');
				
				var res = this.deps()[src];
				
				if (!res) {
					var body = fs.readFileSync(filepath,'utf-8');
					
					if (src.match(/\.md$/)) {
						res = this.Markdown.render(body);
					} else if (src.match(/\.json$/)) {
						res = JSON.parse(body);
					} else if (src.match(/\.imba$/)) {
						var html = this.Highlighter.highlight(body,{mode: 'full'});
						res = {body: body,html: html};
					};
				};
				
				(deps_ = this.deps())[($1 = src)] || (deps_[$1] = res);
				
				if (this.site()) {
					($3 = this.site().deps())[($2 = src)] || ($3[$2] = res);
				};
				cb && cb(res);
			} else {
				if (DEPS[src]) {
					cb && cb(DEPS[src]);
					return {then: function(v) { return v(res); }}; // fake promise hack
				};
				
				var xhr = new XMLHttpRequest();
				xhr.addEventListener('load',function(res) {
					DEPS[src] = JSON.parse(xhr.responseText);
					return cb && cb(DEPS[src]);
					// XHR = xhr
					// console.log 'response here',xhr:responseText
				});
				xhr.open("GET",src);
				xhr.send();
			};
			
			return this;
		};
		
		App.prototype.issues = function (){
			return this._issues || (this._issues = Doc.get('/issues/all.json'));
		};
		
		function Doc(path){
			this._path = path;
			this._ready = false;
			this.fetch();
			this;
		};
		
		exports.Doc = Doc; // export class 
		var cache = {};
		
		Doc.get = function (path){
			var $1;
			var cache = APP.cache();
			return cache[($1 = 'doc-' + path)] || (cache[$1] = new this(path));
		};
		
		
		
		Doc.prototype.path = function(v){ return this._path; }
		Doc.prototype.setPath = function(v){ this._path = v; return this; };
		
		
		Doc.prototype.object = function(v){ return this._object; }
		Doc.prototype.setObject = function(v){ this._object = v; return this; };
		
		Doc.prototype.ready = function (){
			return this._ready;
		};
		
		Doc.prototype.fetch = function (){
			var self = this;
			if (false) {
				// console.log 'fetch Guide on server',path
				return APP.fetchDocument(self._path,function(res) {
					// console.log 'fetch Guide on server done',path
					return self.load(res);
				});
			};
			
			return self._promise || (self._promise = APP.fetchDocument(self._path,function(res) {
				return self.load(res);
			}));
		};
		
		Doc.prototype.load = function (doc){
			this._object = doc;
			this._meta = doc.meta || {};
			this._ready = true;
			Imba.emit(this,'ready');
			Imba.Scheduler.markDirty();
			return this;
		};
		
		Doc.prototype.title = function (){
			return this._object.title || 'path';
		};
		
		Doc.prototype.toc = function (){
			return this._object && this._object.toc[0];
		};
		
		Doc.prototype.body = function (){
			return this._object && this._object.body;
		};
		return Doc;
	
	})()

/***/ },
/* 58 */
/***/ function(module, exports) {

	(function(){
		// externs;
		
		function Router(app){
			var self = this;
			self._app = app;
			
			if (Imba.isClient()) {
				window.onpopstate = function(e) {
					self.refresh();
					return Imba.setTimeout(0,function() { return true; });
				};
			};
			self;
		};
		
		exports.Router = Router; // export class 
		
		
		Router.prototype.path = function(v){ return this._path; }
		Router.prototype.setPath = function(v){ this._path = v; return this; };
		
		Router.slug = function (str){
			str = str.replace(/^\s+|\s+$/g,'').toLowerCase(); // trim
			// remove accents, swap  for n, etc
			var from = "/_,:;";
			var to = "aaaaaeeeeiiiioooouuuunc------";
			
			// for (var i=0, l=from.length ; i<l ; i++)
			// 	str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
			
			str = str.replace(/[^a-z0-9 -]/g,''); // remove invalid chars
			str = str.replace(/\s+/g,'-'); // collapse whitespace and replace by -
			str = str.replace(/-+/g,'-'); // collapse dashes
			
			return str;
		};
		
		Router.prototype.refresh = function (){
			return this;
		};
		
		Router.prototype.path = function (){
			return this._app.path();
		};
		
		Router.prototype.hash = function (){
			return this._app.hash();
		};
		
		Router.prototype.ext = function (){
			var path = this.path();
			var m = path.match(/\.([^\/]+)$/);
			return m && m[1] || '';
		};
		
		Router.prototype.go = function (href,state,replace){
			if(state === undefined) state = {};
			if(replace === undefined) replace = false;
			if (href == '/install') {
				// redirects here
				href = '/guides#toc-getting-started-installation';
			};
			
			if (replace) {
				history.replaceState(state,null,href);
			} else {
				history.pushState(state,null,href);
			};
			
			if (!href.match(/\#/)) {
				window.scrollTo(0,0);
			};
			
			return this;
		};
		
		Router.prototype.scoped = function (reg,part){
			var path = this.path() + '#' + this.hash();
			if ((typeof reg=='string'||reg instanceof String)) {
				var nxt = path[reg.length];
				return path.substr(0,reg.length) == reg && (!nxt || nxt == '-' || nxt == '/' || nxt == '#' || nxt == '?' || nxt == '_');
			} else if (reg instanceof RegExp) {
				var m = path.match(reg);
				return part && m ? (m[part]) : (m);
			} else {
				return false;
			};
		};
		
		Router.prototype.match = function (reg,part){
			var path = this.path() + '#' + this.hash();
			
			if ((typeof reg=='string'||reg instanceof String)) {
				return path == reg;
			} else if (reg instanceof RegExp) {
				var m = path.match(reg);
				return part && m ? (m[part]) : (m);
			} else {
				return false;
			};
		};
		return Router;
		
	
	})()

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		__webpack_require__(60);
		__webpack_require__(61);
		
		__webpack_require__(63);
		__webpack_require__(64);
		__webpack_require__(65);
		__webpack_require__(66);
		__webpack_require__(67);
		__webpack_require__(68);
		__webpack_require__(69);
		__webpack_require__(70);
		return __webpack_require__(71);
	
	})()

/***/ },
/* 60 */
/***/ function(module, exports) {

	(function(){
		tag$.extendTag('element', function(tag){
			
			
			tag.prototype.route = function(v){ return this.getAttribute('route'); }
			tag.prototype.setRoute = function(v){ this.setAttribute('route',v); return this; };
			
			// def html= html
			// 	@dom:innerHTML = html
			// 	self
			
			tag.prototype.setHtml = function (html){
				if (html != this._html) {
					this.dom().innerHTML = this._html = html;
				};
				return this;
			};
			
			tag.prototype.go = function (route){
				return this;
			};
			
			tag.prototype.router = function (){
				return APP.router();
			};
			
			tag.prototype.reroute = function (){
				this.flag('scoped',this.router().scoped(this.route(),this));
				return this.flag('selected',this.router().match(this.route(),this));
			};
			
			tag.prototype.setTransform = function (value){
				this.css('transform',value);
				return this;
			};
			
			tag.prototype.transform = function (){
				return this.css('transform');
			};
		});
		
		tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.setHtml = function (html){
				if (html != this._html) {
					this.dom().innerHTML = this._html = html;
				};
				return this;
			};
		});
		
		tag$.extendTag('script', function(tag){
			
			tag.prototype.setChildren = function (value){
				this._children = value;
				this.dom().innerHTML = value;
				return this;
			};
		});
		
		tag$.extendTag('canvas', function(tag){
			
			tag.prototype.dpr = function (){
				return this._dpr || (this._dpr = window.devicePixelRatio || 1);
			};
			
			tag.prototype.setWidth = function (width){
				if (width != this._width) {
					this.dom().width = width * this.dpr();
					this.css({width: width});
					this._width = width;
				};
				return this;
			};
			
			tag.prototype.setHeight = function (height){
				if (height != this._height) {
					this.dom().height = height * this.dpr();
					this.css({height: height});
					this._height = height;
				};
				return this;
			};
		});
		
		tag$.extendTag('a', function(tag){
			
			tag.prototype.route = function (){
				return this._route || this.href();
			};
			
			tag.prototype.ontap = function (e){
				var href = this.href().replace(/^http\:\/\/imba\.io/,'');
				
				if (e.event().metaKey || e.event().altKey) {
					e._responder = null;
					return e.halt();
				};
				
				if (href[0] == '#' || href[0] == '/') {
					e.cancel().halt();
					this.router().go(href,{});
					Imba.Events.trigger('route',this);
				} else {
					e._responder = null;
					return e.halt();
				};
				return this;
			};
			
			tag.prototype.render = function (){
				return this.reroute();
			};
		});
		
		return tag$.defineTag('star', 'a', function(tag){
			
			
			tag.prototype.repo = function(v){ return this.getAttribute('repo'); }
			tag.prototype.setRepo = function(v){ this.setAttribute('repo',v); return this; };
			
			tag.prototype.render = function (){
				return this.setHref(("http://github.com/" + this.repo())).setText(" Star").synced();
				// <a href="http://github.com/{repo}"> " Star"
			};
		});
	
	})()

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// for markdown rendering
		tag$.defineTag('md', function(tag){
			
			
			tag.prototype.__src = {watch: 'reload',name: 'src'};
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){
				var a = this.src();
				if(v != a) { this.setAttribute('src',v); }
				if(v != a) { this.reload && this.reload(v,a,this.__src) }
				return this;
			};
			
			tag.prototype.__html = {watch: 'htmlDidSet',name: 'html'};
			tag.prototype.html = function(v){ return this._html; }
			tag.prototype.setHtml = function(v){
				var a = this.html();
				if(v != a) { this._html = v; }
				if(v != a) { this.htmlDidSet && this.htmlDidSet(v,a,this.__html) }
				return this;
			};
			
			
			tag.prototype.doc = function(v){ return this._doc; }
			tag.prototype.setDoc = function(v){ this._doc = v; return this; };
			
			tag.prototype.body = function (){
				return this;
			};
			
			tag.prototype.setup = function (){
				return this;
			};
			
			tag.prototype.ghsrc = function (){
				return ("https://github.com/somebee/imba.io/blob/master/docs" + this.src());
			};
			
			tag.prototype.htmlDidSet = function (html){
				this.body().dom().innerHTML = html;
				this.setup();
				return this;
			};
			
			tag.prototype.render = function (){
				var self = this;
				if (false) {
					APP.fetchDocument(self.src() + '.md',function(doc) {
						return self.assemble(doc);
					});
				} else if (self._snippets) {
					for (var i = 0, ary = iter$(self._snippets), len = ary.length; i < len; i++) {
						ary[i].end(); // simulate real rendering here?
					};
				};
				return self;
			};
			
			// not on frontpage?!
			tag.prototype.assemble = function (doc){
				return this.flag('md').setHtml(doc.body).synced();
			};
			
			tag.prototype.build = function (){
				tag.__super__.build.apply(this,arguments);
				if (Imba.isClient() && this.src()) { return this.reload() };
			};
			
			tag.prototype.awaken = function (){
				// log "awakened md from client(!)"
				this._snippets = q$('._snippet',this).toArray();
				return this;
			};
			
			tag.prototype.preload = function (html){
				this._dom.innerHTML = html;
				this._snippets = q$('._snippet',this).toArray();
				return this;
			};
			
			tag.prototype.reload = function (){
				var self = this;
				if (Imba.isClient()) {
					// console.log 'reloading markdown'
					self._snippets = [];
					APP.fetchDocument(self.src() + '.md',function(res) {
						// console.log 'returned from markdown here?!',res
						self.assemble((self.setDoc(res),res));
						self._snippets = q$('._snippet',self).toArray();
						self.parent().dom().scrollTop = 0;
						return self;
					});
				};
				return self;
			};
		});
		
		// define renderer
		var marked = __webpack_require__(62);
		var mdr = new (marked.Renderer)();
		
		mdr.heading = function (text,lvl){
			return ("<h" + lvl + ">" + text + "</h" + lvl + ">");
		};
		
		return tag$.defineTag('marked', function(tag){
			
			tag.prototype.renderer = function (){
				return this;
			};
			
			tag.prototype.setText = function (text){
				return this.setContent(text,0);
			};
			
			tag.prototype.setContent = function (val,typ){
				if (val != this._content) {
					this._content = val;
					this.dom().innerHTML = marked(val,{renderer: mdr});
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * marked - a markdown parser
	 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/chjj/marked
	 */
	
	;(function() {
	
	/**
	 * Block-Level Grammar
	 */
	
	var block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: noop,
	  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
	  nptable: noop,
	  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
	  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
	  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
	  table: noop,
	  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
	  text: /^[^\n]+/
	};
	
	block.bullet = /(?:[*+-]|\d+\.)/;
	block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
	block.item = replace(block.item, 'gm')
	  (/bull/g, block.bullet)
	  ();
	
	block.list = replace(block.list)
	  (/bull/g, block.bullet)
	  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
	  ('def', '\\n+(?=' + block.def.source + ')')
	  ();
	
	block.blockquote = replace(block.blockquote)
	  ('def', block.def)
	  ();
	
	block._tag = '(?!(?:'
	  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
	  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
	  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
	
	block.html = replace(block.html)
	  ('comment', /<!--[\s\S]*?-->/)
	  ('closed', /<(tag)[\s\S]+?<\/\1>/)
	  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
	  (/tag/g, block._tag)
	  ();
	
	block.paragraph = replace(block.paragraph)
	  ('hr', block.hr)
	  ('heading', block.heading)
	  ('lheading', block.lheading)
	  ('blockquote', block.blockquote)
	  ('tag', '<' + block._tag)
	  ('def', block.def)
	  ();
	
	/**
	 * Normal Block Grammar
	 */
	
	block.normal = merge({}, block);
	
	/**
	 * GFM Block Grammar
	 */
	
	block.gfm = merge({}, block.normal, {
	  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
	  paragraph: /^/,
	  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
	});
	
	block.gfm.paragraph = replace(block.paragraph)
	  ('(?!', '(?!'
	    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
	    + block.list.source.replace('\\1', '\\3') + '|')
	  ();
	
	/**
	 * GFM + Tables Block Grammar
	 */
	
	block.tables = merge({}, block.gfm, {
	  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
	  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
	});
	
	/**
	 * Block Lexer
	 */
	
	function Lexer(options) {
	  this.tokens = [];
	  this.tokens.links = {};
	  this.options = options || marked.defaults;
	  this.rules = block.normal;
	
	  if (this.options.gfm) {
	    if (this.options.tables) {
	      this.rules = block.tables;
	    } else {
	      this.rules = block.gfm;
	    }
	  }
	}
	
	/**
	 * Expose Block Rules
	 */
	
	Lexer.rules = block;
	
	/**
	 * Static Lex Method
	 */
	
	Lexer.lex = function(src, options) {
	  var lexer = new Lexer(options);
	  return lexer.lex(src);
	};
	
	/**
	 * Preprocessing
	 */
	
	Lexer.prototype.lex = function(src) {
	  src = src
	    .replace(/\r\n|\r/g, '\n')
	    .replace(/\t/g, '    ')
	    .replace(/\u00a0/g, ' ')
	    .replace(/\u2424/g, '\n');
	
	  return this.token(src, true);
	};
	
	/**
	 * Lexing
	 */
	
	Lexer.prototype.token = function(src, top, bq) {
	  var src = src.replace(/^ +$/gm, '')
	    , next
	    , loose
	    , cap
	    , bull
	    , b
	    , item
	    , space
	    , i
	    , l;
	
	  while (src) {
	    // newline
	    if (cap = this.rules.newline.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[0].length > 1) {
	        this.tokens.push({
	          type: 'space'
	        });
	      }
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      cap = cap[0].replace(/^ {4}/gm, '');
	      this.tokens.push({
	        type: 'code',
	        text: !this.options.pedantic
	          ? cap.replace(/\n+$/, '')
	          : cap
	      });
	      continue;
	    }
	
	    // fences (gfm)
	    if (cap = this.rules.fences.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'code',
	        lang: cap[2],
	        text: cap[3] || ''
	      });
	      continue;
	    }
	
	    // heading
	    if (cap = this.rules.heading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[1].length,
	        text: cap[2]
	      });
	      continue;
	    }
	
	    // table no leading pipe (gfm)
	    if (top && (cap = this.rules.nptable.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i].split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // lheading
	    if (cap = this.rules.lheading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[2] === '=' ? 1 : 2,
	        text: cap[1]
	      });
	      continue;
	    }
	
	    // hr
	    if (cap = this.rules.hr.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'hr'
	      });
	      continue;
	    }
	
	    // blockquote
	    if (cap = this.rules.blockquote.exec(src)) {
	      src = src.substring(cap[0].length);
	
	      this.tokens.push({
	        type: 'blockquote_start'
	      });
	
	      cap = cap[0].replace(/^ *> ?/gm, '');
	
	      // Pass `top` to keep the current
	      // "toplevel" state. This is exactly
	      // how markdown.pl works.
	      this.token(cap, top, true);
	
	      this.tokens.push({
	        type: 'blockquote_end'
	      });
	
	      continue;
	    }
	
	    // list
	    if (cap = this.rules.list.exec(src)) {
	      src = src.substring(cap[0].length);
	      bull = cap[2];
	
	      this.tokens.push({
	        type: 'list_start',
	        ordered: bull.length > 1
	      });
	
	      // Get each top-level item.
	      cap = cap[0].match(this.rules.item);
	
	      next = false;
	      l = cap.length;
	      i = 0;
	
	      for (; i < l; i++) {
	        item = cap[i];
	
	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+\.) +/, '');
	
	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }
	
	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (this.options.smartLists && i !== l - 1) {
	          b = block.bullet.exec(cap[i + 1])[0];
	          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
	            src = cap.slice(i + 1).join('\n') + src;
	            i = l - 1;
	          }
	        }
	
	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) loose = next;
	        }
	
	        this.tokens.push({
	          type: loose
	            ? 'loose_item_start'
	            : 'list_item_start'
	        });
	
	        // Recurse.
	        this.token(item, false, bq);
	
	        this.tokens.push({
	          type: 'list_item_end'
	        });
	      }
	
	      this.tokens.push({
	        type: 'list_end'
	      });
	
	      continue;
	    }
	
	    // html
	    if (cap = this.rules.html.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: this.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        pre: !this.options.sanitizer
	          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	        text: cap[0]
	      });
	      continue;
	    }
	
	    // def
	    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.links[cap[1].toLowerCase()] = {
	        href: cap[2],
	        title: cap[3]
	      };
	      continue;
	    }
	
	    // table (gfm)
	    if (top && (cap = this.rules.table.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i]
	          .replace(/^ *\| *| *\| *$/g, '')
	          .split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // top-level paragraph
	    if (top && (cap = this.rules.paragraph.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'paragraph',
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      });
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      // Top-level should never reach here.
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'text',
	        text: cap[0]
	      });
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return this.tokens;
	};
	
	/**
	 * Inline-Level Grammar
	 */
	
	var inline = {
	  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
	  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
	  url: noop,
	  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
	  link: /^!?\[(inside)\]\(href\)/,
	  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
	  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
	  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
	  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
	  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
	  br: /^ {2,}\n(?!\s*$)/,
	  del: noop,
	  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
	};
	
	inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
	inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
	
	inline.link = replace(inline.link)
	  ('inside', inline._inside)
	  ('href', inline._href)
	  ();
	
	inline.reflink = replace(inline.reflink)
	  ('inside', inline._inside)
	  ();
	
	/**
	 * Normal Inline Grammar
	 */
	
	inline.normal = merge({}, inline);
	
	/**
	 * Pedantic Inline Grammar
	 */
	
	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
	});
	
	/**
	 * GFM Inline Grammar
	 */
	
	inline.gfm = merge({}, inline.normal, {
	  escape: replace(inline.escape)('])', '~|])')(),
	  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
	  del: /^~~(?=\S)([\s\S]*?\S)~~/,
	  text: replace(inline.text)
	    (']|', '~]|')
	    ('|', '|https?://|')
	    ()
	});
	
	/**
	 * GFM + Line Breaks Inline Grammar
	 */
	
	inline.breaks = merge({}, inline.gfm, {
	  br: replace(inline.br)('{2,}', '*')(),
	  text: replace(inline.gfm.text)('{2,}', '*')()
	});
	
	/**
	 * Inline Lexer & Compiler
	 */
	
	function InlineLexer(links, options) {
	  this.options = options || marked.defaults;
	  this.links = links;
	  this.rules = inline.normal;
	  this.renderer = this.options.renderer || new Renderer;
	  this.renderer.options = this.options;
	
	  if (!this.links) {
	    throw new
	      Error('Tokens array requires a `links` property.');
	  }
	
	  if (this.options.gfm) {
	    if (this.options.breaks) {
	      this.rules = inline.breaks;
	    } else {
	      this.rules = inline.gfm;
	    }
	  } else if (this.options.pedantic) {
	    this.rules = inline.pedantic;
	  }
	}
	
	/**
	 * Expose Inline Rules
	 */
	
	InlineLexer.rules = inline;
	
	/**
	 * Static Lexing/Compiling Method
	 */
	
	InlineLexer.output = function(src, links, options) {
	  var inline = new InlineLexer(links, options);
	  return inline.output(src);
	};
	
	/**
	 * Lexing/Compiling
	 */
	
	InlineLexer.prototype.output = function(src) {
	  var out = ''
	    , link
	    , text
	    , href
	    , cap;
	
	  while (src) {
	    // escape
	    if (cap = this.rules.escape.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += cap[1];
	      continue;
	    }
	
	    // autolink
	    if (cap = this.rules.autolink.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = cap[1].charAt(6) === ':'
	          ? this.mangle(cap[1].substring(7))
	          : this.mangle(cap[1]);
	        href = this.mangle('mailto:') + text;
	      } else {
	        text = escape(cap[1]);
	        href = text;
	      }
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // url (gfm)
	    if (!this.inLink && (cap = this.rules.url.exec(src))) {
	      src = src.substring(cap[0].length);
	      text = escape(cap[1]);
	      href = text;
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // tag
	    if (cap = this.rules.tag.exec(src)) {
	      if (!this.inLink && /^<a /i.test(cap[0])) {
	        this.inLink = true;
	      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	        this.inLink = false;
	      }
	      src = src.substring(cap[0].length);
	      out += this.options.sanitize
	        ? this.options.sanitizer
	          ? this.options.sanitizer(cap[0])
	          : escape(cap[0])
	        : cap[0]
	      continue;
	    }
	
	    // link
	    if (cap = this.rules.link.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.inLink = true;
	      out += this.outputLink(cap, {
	        href: cap[2],
	        title: cap[3]
	      });
	      this.inLink = false;
	      continue;
	    }
	
	    // reflink, nolink
	    if ((cap = this.rules.reflink.exec(src))
	        || (cap = this.rules.nolink.exec(src))) {
	      src = src.substring(cap[0].length);
	      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = this.links[link.toLowerCase()];
	      if (!link || !link.href) {
	        out += cap[0].charAt(0);
	        src = cap[0].substring(1) + src;
	        continue;
	      }
	      this.inLink = true;
	      out += this.outputLink(cap, link);
	      this.inLink = false;
	      continue;
	    }
	
	    // strong
	    if (cap = this.rules.strong.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.strong(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // em
	    if (cap = this.rules.em.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.em(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.codespan(escape(cap[2], true));
	      continue;
	    }
	
	    // br
	    if (cap = this.rules.br.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.br();
	      continue;
	    }
	
	    // del (gfm)
	    if (cap = this.rules.del.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.del(this.output(cap[1]));
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.text(escape(this.smartypants(cap[0])));
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return out;
	};
	
	/**
	 * Compile Link
	 */
	
	InlineLexer.prototype.outputLink = function(cap, link) {
	  var href = escape(link.href)
	    , title = link.title ? escape(link.title) : null;
	
	  return cap[0].charAt(0) !== '!'
	    ? this.renderer.link(href, title, this.output(cap[1]))
	    : this.renderer.image(href, title, escape(cap[1]));
	};
	
	/**
	 * Smartypants Transformations
	 */
	
	InlineLexer.prototype.smartypants = function(text) {
	  if (!this.options.smartypants) return text;
	  return text
	    // em-dashes
	    .replace(/---/g, '\u2014')
	    // en-dashes
	    .replace(/--/g, '\u2013')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	};
	
	/**
	 * Mangle Links
	 */
	
	InlineLexer.prototype.mangle = function(text) {
	  if (!this.options.mangle) return text;
	  var out = ''
	    , l = text.length
	    , i = 0
	    , ch;
	
	  for (; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }
	
	  return out;
	};
	
	/**
	 * Renderer
	 */
	
	function Renderer(options) {
	  this.options = options || {};
	}
	
	Renderer.prototype.code = function(code, lang, escaped) {
	  if (this.options.highlight) {
	    var out = this.options.highlight(code, lang);
	    if (out != null && out !== code) {
	      escaped = true;
	      code = out;
	    }
	  }
	
	  if (!lang) {
	    return '<pre><code>'
	      + (escaped ? code : escape(code, true))
	      + '\n</code></pre>';
	  }
	
	  return '<pre><code class="'
	    + this.options.langPrefix
	    + escape(lang, true)
	    + '">'
	    + (escaped ? code : escape(code, true))
	    + '\n</code></pre>\n';
	};
	
	Renderer.prototype.blockquote = function(quote) {
	  return '<blockquote>\n' + quote + '</blockquote>\n';
	};
	
	Renderer.prototype.html = function(html) {
	  return html;
	};
	
	Renderer.prototype.heading = function(text, level, raw) {
	  return '<h'
	    + level
	    + ' id="'
	    + this.options.headerPrefix
	    + raw.toLowerCase().replace(/[^\w]+/g, '-')
	    + '">'
	    + text
	    + '</h'
	    + level
	    + '>\n';
	};
	
	Renderer.prototype.hr = function() {
	  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	};
	
	Renderer.prototype.list = function(body, ordered) {
	  var type = ordered ? 'ol' : 'ul';
	  return '<' + type + '>\n' + body + '</' + type + '>\n';
	};
	
	Renderer.prototype.listitem = function(text) {
	  return '<li>' + text + '</li>\n';
	};
	
	Renderer.prototype.paragraph = function(text) {
	  return '<p>' + text + '</p>\n';
	};
	
	Renderer.prototype.table = function(header, body) {
	  return '<table>\n'
	    + '<thead>\n'
	    + header
	    + '</thead>\n'
	    + '<tbody>\n'
	    + body
	    + '</tbody>\n'
	    + '</table>\n';
	};
	
	Renderer.prototype.tablerow = function(content) {
	  return '<tr>\n' + content + '</tr>\n';
	};
	
	Renderer.prototype.tablecell = function(content, flags) {
	  var type = flags.header ? 'th' : 'td';
	  var tag = flags.align
	    ? '<' + type + ' style="text-align:' + flags.align + '">'
	    : '<' + type + '>';
	  return tag + content + '</' + type + '>\n';
	};
	
	// span level renderer
	Renderer.prototype.strong = function(text) {
	  return '<strong>' + text + '</strong>';
	};
	
	Renderer.prototype.em = function(text) {
	  return '<em>' + text + '</em>';
	};
	
	Renderer.prototype.codespan = function(text) {
	  return '<code>' + text + '</code>';
	};
	
	Renderer.prototype.br = function() {
	  return this.options.xhtml ? '<br/>' : '<br>';
	};
	
	Renderer.prototype.del = function(text) {
	  return '<del>' + text + '</del>';
	};
	
	Renderer.prototype.link = function(href, title, text) {
	  if (this.options.sanitize) {
	    try {
	      var prot = decodeURIComponent(unescape(href))
	        .replace(/[^\w:]/g, '')
	        .toLowerCase();
	    } catch (e) {
	      return '';
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
	      return '';
	    }
	  }
	  var out = '<a href="' + href + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += '>' + text + '</a>';
	  return out;
	};
	
	Renderer.prototype.image = function(href, title, text) {
	  var out = '<img src="' + href + '" alt="' + text + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += this.options.xhtml ? '/>' : '>';
	  return out;
	};
	
	Renderer.prototype.text = function(text) {
	  return text;
	};
	
	/**
	 * Parsing & Compiling
	 */
	
	function Parser(options) {
	  this.tokens = [];
	  this.token = null;
	  this.options = options || marked.defaults;
	  this.options.renderer = this.options.renderer || new Renderer;
	  this.renderer = this.options.renderer;
	  this.renderer.options = this.options;
	}
	
	/**
	 * Static Parse Method
	 */
	
	Parser.parse = function(src, options, renderer) {
	  var parser = new Parser(options, renderer);
	  return parser.parse(src);
	};
	
	/**
	 * Parse Loop
	 */
	
	Parser.prototype.parse = function(src) {
	  this.inline = new InlineLexer(src.links, this.options, this.renderer);
	  this.tokens = src.reverse();
	
	  var out = '';
	  while (this.next()) {
	    out += this.tok();
	  }
	
	  return out;
	};
	
	/**
	 * Next Token
	 */
	
	Parser.prototype.next = function() {
	  return this.token = this.tokens.pop();
	};
	
	/**
	 * Preview Next Token
	 */
	
	Parser.prototype.peek = function() {
	  return this.tokens[this.tokens.length - 1] || 0;
	};
	
	/**
	 * Parse Text Tokens
	 */
	
	Parser.prototype.parseText = function() {
	  var body = this.token.text;
	
	  while (this.peek().type === 'text') {
	    body += '\n' + this.next().text;
	  }
	
	  return this.inline.output(body);
	};
	
	/**
	 * Parse Current Token
	 */
	
	Parser.prototype.tok = function() {
	  switch (this.token.type) {
	    case 'space': {
	      return '';
	    }
	    case 'hr': {
	      return this.renderer.hr();
	    }
	    case 'heading': {
	      return this.renderer.heading(
	        this.inline.output(this.token.text),
	        this.token.depth,
	        this.token.text);
	    }
	    case 'code': {
	      return this.renderer.code(this.token.text,
	        this.token.lang,
	        this.token.escaped);
	    }
	    case 'table': {
	      var header = ''
	        , body = ''
	        , i
	        , row
	        , cell
	        , flags
	        , j;
	
	      // header
	      cell = '';
	      for (i = 0; i < this.token.header.length; i++) {
	        flags = { header: true, align: this.token.align[i] };
	        cell += this.renderer.tablecell(
	          this.inline.output(this.token.header[i]),
	          { header: true, align: this.token.align[i] }
	        );
	      }
	      header += this.renderer.tablerow(cell);
	
	      for (i = 0; i < this.token.cells.length; i++) {
	        row = this.token.cells[i];
	
	        cell = '';
	        for (j = 0; j < row.length; j++) {
	          cell += this.renderer.tablecell(
	            this.inline.output(row[j]),
	            { header: false, align: this.token.align[j] }
	          );
	        }
	
	        body += this.renderer.tablerow(cell);
	      }
	      return this.renderer.table(header, body);
	    }
	    case 'blockquote_start': {
	      var body = '';
	
	      while (this.next().type !== 'blockquote_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.blockquote(body);
	    }
	    case 'list_start': {
	      var body = ''
	        , ordered = this.token.ordered;
	
	      while (this.next().type !== 'list_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.list(body, ordered);
	    }
	    case 'list_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.token.type === 'text'
	          ? this.parseText()
	          : this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'loose_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'html': {
	      var html = !this.token.pre && !this.options.pedantic
	        ? this.inline.output(this.token.text)
	        : this.token.text;
	      return this.renderer.html(html);
	    }
	    case 'paragraph': {
	      return this.renderer.paragraph(this.inline.output(this.token.text));
	    }
	    case 'text': {
	      return this.renderer.paragraph(this.parseText());
	    }
	  }
	};
	
	/**
	 * Helpers
	 */
	
	function escape(html, encode) {
	  return html
	    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#39;');
	}
	
	function unescape(html) {
	  return html.replace(/&([#\w]+);/g, function(_, n) {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}
	
	function replace(regex, opt) {
	  regex = regex.source;
	  opt = opt || '';
	  return function self(name, val) {
	    if (!name) return new RegExp(regex, opt);
	    val = val.source || val;
	    val = val.replace(/(^|[^\[])\^/g, '$1');
	    regex = regex.replace(name, val);
	    return self;
	  };
	}
	
	function noop() {}
	noop.exec = noop;
	
	function merge(obj) {
	  var i = 1
	    , target
	    , key;
	
	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }
	
	  return obj;
	}
	
	
	/**
	 * Marked
	 */
	
	function marked(src, opt, callback) {
	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }
	
	    opt = merge({}, marked.defaults, opt || {});
	
	    var highlight = opt.highlight
	      , tokens
	      , pending
	      , i = 0;
	
	    try {
	      tokens = Lexer.lex(src, opt)
	    } catch (e) {
	      return callback(e);
	    }
	
	    pending = tokens.length;
	
	    var done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }
	
	      var out;
	
	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }
	
	      opt.highlight = highlight;
	
	      return err
	        ? callback(err)
	        : callback(null, out);
	    };
	
	    if (!highlight || highlight.length < 3) {
	      return done();
	    }
	
	    delete opt.highlight;
	
	    if (!pending) return done();
	
	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) return done(err);
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }
	
	    return;
	  }
	  try {
	    if (opt) opt = merge({}, marked.defaults, opt);
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/chjj/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occured:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}
	
	/**
	 * Options
	 */
	
	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  return marked;
	};
	
	marked.defaults = {
	  gfm: true,
	  tables: true,
	  breaks: false,
	  pedantic: false,
	  sanitize: false,
	  sanitizer: null,
	  mangle: true,
	  smartLists: false,
	  silent: false,
	  highlight: null,
	  langPrefix: 'lang-',
	  smartypants: false,
	  headerPrefix: '',
	  renderer: new Renderer,
	  xhtml: false
	};
	
	/**
	 * Expose
	 */
	
	marked.Parser = Parser;
	marked.parser = Parser.parse;
	
	marked.Renderer = Renderer;
	
	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;
	
	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;
	
	marked.parse = marked;
	
	if (true) {
	  module.exports = marked;
	} else if (typeof define === 'function' && define.amd) {
	  define(function() { return marked; });
	} else {
	  this.marked = marked;
	}
	
	}).call(function() {
	  return this || ( true ? window : global);
	}());


/***/ },
/* 63 */
/***/ function(module, exports) {

	(function(){
		tag$.defineTag('site', 'html', function(tag){
			
			
			
			tag.prototype.deps = function(v){ return this._deps; }
			tag.prototype.setDeps = function(v){ this._deps = v; return this; };
			
			tag.prototype.head = function (){
				return tag$.$head().setContent([
					tag$.$title().setText("imba").end(),
					tag$.$meta().setCharset("utf-8").end(),
					tag$.$meta().setName("viewport").setContent("width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1").end(),
					tag$.$meta().setName("Description").setContent("Imba is a rich programming language for the web.").end(),
					tag$.$meta().setName("keywords").setContent("imba javascript language js").end(),
					tag$.$link().setHref('http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600').setRel('stylesheet').setType('text/css').end(),
					tag$.$link().setRel("stylesheet").setHref("/css/site.css").setMedia("screen").end(),
					tag$.$script().setText('DEPS = {};').end(),
					tag$.$script().setSrc("/vendor/ga.js").end()
				],2).end();
			};
			
			tag.prototype.body = function (){
				return tag$.$body().setId('site').setContent([
					tag$.$site_nav().setId('header').flag('awaken').end(),
					tag$.$home().setRoute('/home').end(),
					tag$.$guides().setRoute('/guides').end(),
					tag$.$docs().setRoute('/docs').end(),
					tag$.$blog().setRoute('/blog').end(),
					tag$.$footer().setContent([
						tag$.$hr().end(),
						tag$.$div().flag('lft').setText("Imba  2015-2016").end(),
						tag$.$div().flag('rgt').setContent([
							tag$.$a().setHref('http://twitter.com/imbajs').setText('Twitter').end(),
							tag$.$a().setHref('http://github.com/sombee/imba').setText('GitHub').end(),
							tag$.$a().setHref('http://github.com/sombee/imba/issues').setText('Issues').end(),
							tag$.$a().setHref('http://gitter.im/sombee/imba').setText('Chat').end()
						],2).end()
					],2).end()
				],2).end();
			};
			
			
			tag.prototype.scripts = function (){
				var self = this, t0;
				return tag$.$div().flag('scripts').setContent([
					(function(t0) {
						for (var o = self.deps(), i = 0, keys = Object.keys(o), l = keys.length, res = []; i < l; i++){
							res.push(tag$.$script().setType("text/javascript").setSrc((keys[i] + '.dep')).end());
						};
						return res;
					})(t0),
					tag$.$script().setSrc("/vendor/hl.js").end(),
					tag$.$script().setSrc("/client.js").end()
				],0).end();
			};
			
			tag.prototype.render = function (){
				// dirty workarounds
				APP.setSite(this);
				this.setDeps({
					"/issues/all.json": true
				});
				
				APP.fetchDocument('/guides.md');
				var body = this.body();
				body.append(this.scripts());
				
				this.flag('light').setChildren([
					this.head(),
					body
				],1).synced();
				APP.setSite(null);
				return this;
			};
		});
		
		
		return tag$.defineTag('site-nav', function(tag){
			
			tag.prototype.toggleMenu = function (){
				return q$$('body').toggleFlag('menu');
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, t5, t6, t7, t8, t9;
				return this.setChildren(
					(t0 = this.$a=this.$a || tag$.$nav().flag('content')).setContent([
						(t1 = t0.$$a=t0.$$a || tag$.$a().flag('menu').setHandler('tap','toggleMenu',this)).setContent((t1.$$a = t1.$$a || tag$.$b()).end(),2).end(),
						(t2 = t0.$$b=t0.$$b || tag$.$a().flag('tab').flag('logo').setHref('/home')).setContent((t2.$$a = t2.$$a || tag$.$i()).setText('imba').end(),2).end(),
						(t3 = t0.$$c=t0.$$c || tag$.$a().flag('tab').flag('home').setHref('/home')).setContent((t3.$$a = t3.$$a || tag$.$i()).setText('home').end(),2).end(),
						(t4 = t0.$$d=t0.$$d || tag$.$a().flag('tab').flag('guides').setHref('/guides')).setContent((t4.$$a = t4.$$a || tag$.$i()).setText('guides').end(),2).end(),
						(t5 = t0.$$e=t0.$$e || tag$.$a().flag('tab').flag('docs').setHref('/docs')).setContent((t5.$$a = t5.$$a || tag$.$i()).setText('api').end(),2).end(),
						(t6 = t0.$$f=t0.$$f || tag$.$a().flag('tab').flag('blog').setHref('/blog')).setContent((t6.$$a = t6.$$a || tag$.$i()).setText('blog').end(),2).end(),
						(t0.$$g = t0.$$g || tag$.$span().flag('greedy')).end(),
						(t7 = t0.$$h=t0.$$h || tag$.$a().flag('twitter').setHref('http://twitter.com/imbajs')).setContent((t7.$$a = t7.$$a || tag$.$i()).setText('twitter').end(),2).end(),
						(t8 = t0.$$i=t0.$$i || tag$.$a().flag('github').setHref('https://github.com/somebee/imba')).setContent((t8.$$a = t8.$$a || tag$.$i()).setText('github').end(),2).end(),
						(t9 = t0.$$j=t0.$$j || tag$.$a().flag('issues').setHref('https://github.com/somebee/imba/issues')).setContent((t9.$$a = t9.$$a || tag$.$i()).setText('issues').end(),2).end()
					],2).end()
				,2).synced();
			};
			
			tag.prototype.awaken = function (){
				return this.schedule({fps: 0});
			};
		});
	
	})()

/***/ },
/* 64 */
/***/ function(module, exports) {

	(function(){
		
		
		tag$.defineTag('navmenu', function(tag){
			
			tag.prototype.onroute = function (e){
				document.body.classList.remove('menu');
				return this;
			};
		});
		
		tag$.defineTag('nav-list');
		
		tag$.defineTag('nav-link', function(tag){
			
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren((t0 = this.$a=this.$a || tag$.$a()).setHref(this.href()).setContent(this._content,3).end(),2).synced();
			};
		});
		
		return tag$.defineTag('toc', function(tag){
			
			
			
			tag.prototype.level = function(v){ return this.getAttribute('level'); }
			tag.prototype.setLevel = function(v){ this.setAttribute('level',v); return this; };
			
			tag.prototype.toggle = function (){
				return this.toggleFlag('collapsed');
			};
		});
	
	})()

/***/ },
/* 65 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('page', function(tag){
			tag.prototype.body = function (){
				return (this._body = this._body || tag$.$div().setRef('body',this)).setText("Content here").end();
			};
			
			tag.prototype.nav = function (){
				return (this._nav = this._nav || tag$.$div().setRef('nav',this)).setText("Navigation here").end();
			};
			
			tag.prototype.assemble = function (){
				return this.setChildren([
					this.nav(),
					this.body()
				],1).synced();
			};
			
			tag.prototype.ready = function (){
				return true;
			};
			
			tag.prototype.scoped = function (){
				return this;
			};
			
			tag.prototype.unscoped = function (){
				return this;
			};
			
			tag.prototype.render = function (){
				// log 'render page',route
				var scoped = this.router().scoped(this.route(),this);
				
				if (scoped != this._scoped) {
					this._scoped = scoped;
					this._scoped ? (this.scoped()) : (this.unscoped());
					this.flag('scoped',scoped);
					this.flag('selected',this.router().match(this.route(),this));
				};
				
				if (!(scoped && this.ready())) { return this };
				return this.assemble();
			};
			
			tag.prototype.awaken = function (){
				return this.schedule({fps: 1,events: true});
			};
		});
	
	})()

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Router = __webpack_require__(58).Router;
		
		tag$.defineTag('issue-entry', function(tag){
			
			tag.prototype.render = function (){
				var t0, t1, t2, self = this, t3;
				return this.setChildren([
					(t0 = this.$a=this.$a || tag$.$div().flag('header')).setContent(
						(t1 = t0.$$a=t0.$$a || tag$.$a().flag('title')).setHref(("/blog/" + (this.object().number) + "-" + Router.slug(this.object().title))).setContent(this.object().title,3).end()
					,2).end(),
					(t2 = this.$b=this.$b || tag$.$div().flag('legend')).setContent([
						"by ",
						(t2.$$a = t2.$$a || tag$.$gh_user()).setObject(this.object().user).end()
					],2).end(),
					
					(t3 = self.$c=self.$c || tag$.$div().flag('labels')).setContent(
						(function(t3) {
							for (var i = 0, ary = iter$(self.object().labels), len = ary.length, res = []; i < len; i++) {
								res.push((t3['$$a' + i] = t3['$$a' + i] || tag$.$gh_label()).setObject(ary[i]).end());
							};
							return res;
						})(t3)
					,3).end()
				],2).synced();
			};
		});
		
		tag$.defineTag('gh-label', function(tag){
			
			tag.prototype.render = function (){
				this.setTitle((this.object().name)).setChildren(this.object().name,3).synced();
				if (Imba.CLIENT) {
					this.css({backgroundColor: '#' + this.object().color});
				};
				return this;
			};
		});
		
		tag$.defineTag('gh-user', 'span', function(tag){
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren(
					(t0 = this.$a=this.$a || tag$.$a()).setHref(("http://github.com/" + (this.object().login))).setContent(this.object().login,3).end()
				,2).synced();
			};
		});
		
		return tag$.defineTag('issue', function(tag){
			
			tag.prototype.doc = function (){
				return this.object().object();
			};
			
			tag.prototype.build = function (){
				return this.commit();
			};
			
			tag.prototype.commit = function (){
				if (this.object() && this.object().ready()) {
					console.log('commit issue');
					this.unflag('loading');
					return this.render();
				} else {
					return this.flag('loading');
				};
			};
			
			
			tag.prototype.render = function (){
				var t0, t1, t2;
				return this.setChildren([
					(t0 = this.$a=this.$a || tag$.$div().flag('header')).setContent([
						(t1 = t0.$$a=t0.$$a || tag$.$h1().flag('title')).setContent(this.doc().title,3).end(),
						(t2 = t0.$$b=t0.$$b || tag$.$div().flag('legend')).setContent([
							"Written by ",
							(t2.$$a = t2.$$a || tag$.$gh_user()).setObject(this.doc().user).end(),
							(" at " + (this.doc().created_at))
						],1).end()
					],2).end(),
					(this.$b = this.$b || tag$.$div().flag('content').flag('md')).setHtml((this.doc().md)).end()
				],2).synced();
			};
		});
	
	})()

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function shuffle(array){
			var counter = array.length,temp,index;
			
			// While there are elements in the array
			while (counter > 0){
				// Pick a random index
				index = Math.floor(Math.random() * counter);
				counter--; // Decrease counter by 1
				
				// And swap the last element with it
				temp = array[counter];
				array[counter] = array[index];
				array[index] = temp;
			};
			
			return array;
		};
		
		tag$.defineTag('pattern', function(tag){
			
			tag.prototype.build = function (){
				if (false) { return this };
				
				var parts = {tags: [],keywords: [],methods: []};
				var items = [];
				var lines = [];
				
				for (var o = Imba.Tag.prototype, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
					k = keys[i];items.push(("<em>" + k + "</em>"));
					parts.methods.push(("<em>" + k + "</em>"));
				};
				
				for (var i = 0, ary = iter$(HTML_TAGS), len_ = ary.length, k1; i < len_; i++) {
					// for own k,v of Imba.TAGS
					// if v and v:prototype isa Imba.Tag
					k1 = ary[i];
					items.push(("<u>&lt;" + k1 + "&gt;</u>"));
					parts.tags.push(("<u>&lt;" + k1 + "&gt;</u>"));
				};
				
				var words = "def if else elif while until for in of var let class extend export import tag global";
				
				for (var i = 0, ary = iter$(words.split(" ")), len_ = ary.length, k2; i < len_; i++) {
					k2 = ary[i];
					items.push(("<i>" + k2 + "</i>"));
					parts.keywords.push(("<i>" + k2 + "</i>"));
				};
				
				var shuffled = shuffle(items);
				var all = [].concat(shuffled);
				var count = items.length - 1;
				
				for (var len = 12, ln = 0; ln <= len; ln++) {
					var chars = 0;
					lines[ln] = [];
					while (chars < 300){
						var item = (shuffled.pop() || all[Math.floor(count * Math.random())]);
						if (item) {
							chars += item.length;
							lines[ln].push(item);
						} else {
							chars = 400;
						};
					};
				};
				
				this.dom().innerHTML = '<div>' + lines.map(function(ln) {
					return '<div class="line">' + ln.join(" ") + '</div>';
				}).join('') + '</div>';
				return this;
			};
			
			tag.prototype.awaken = function (){
				this.log('awakening pattern!!');
				return this;
				
				for (var i = 0, ary = iter$(q$('.line',this)), len = ary.length; i < len; i++) {
					var z = 20 + i * 10;
					// z = parseInt(-z + Math.random * z * 2)
					ary[i].css('transform',("translateZ(" + z + "px)"));
				};
				return this;
			};
		});
		
		return tag$.defineTag('home', 'page', function(tag){
			
			var todos = {demo: true,autorun: true};
			var clock = {demo: true,autorun: true};
			var reminders = {demo: true,autorun: true};
			var hero = {autorun: true};
			var canvas = {demo: true,autorun: true};
			
			tag.prototype.awaken = function (){
				var snippets = document.querySelectorAll('code[data-src]');
				for (var i = 0, ary = iter$(snippets), len = ary.length, snippet; i < len; i++) {
					snippet = ary[i];
					var src = snippet.getAttribute('data-src');
					// console.log 'fetching snippet for ',src
					DEPS[src] = {html: snippet.innerHTML};
				};
				
				return tag.__super__.awaken.apply(this,arguments);
			};
			
			tag.prototype.nav = function (){
				return null;
			};
			
			tag.prototype.body = function (){
				var t0, t1, t2;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this)).setContent([
					(t1 = t0.$$a=t0.$$a || tag$.$div().setId('hero').flag('dark')).setContent([
						(this._pattern = this._pattern || tag$.$pattern().setRef('pattern',this).flag('awaken')).end(),
						(t1.$$b = t1.$$b || tag$.$example().flag('hero').flag('dark').setSrc('/home/examples/hero.imba')).end()
					],2).end(),
					
					(t2 = this._content=this._content || tag$.$div().setRef('content',this)).setContent([
						(t2.$$a = t2.$$a || tag$.$marked().flag('section').flag('md').flag('welcome').flag('huge').flag('light')).setText("# Ruby, Python and React got together. Nine months later, Imba was born.\n\nImba is a new programming language for the web that compiles to highly \nperformant and readable JavaScript. It has language level support for defining, \nextending, subclassing, instantiating and rendering dom nodes. For a semi-complex \napplication like TodoMVC, it is more than \n[10 times faster than React](http://somebee.github.io/todomvc-render-benchmark/index.html) \nwith less code, and a much smaller library.\n\n---\n\n- ## Imba.inspiration\n  Imba brings the best from Ruby, Python, and React (+ JSX) together in a clean language and runtime.\n\n- ## Imba.interoperability\n  Imba compiles down to clean and readable JavaScript. Use any JS library in Imba and vica-versa.\n\n- ## Imba.performance\n  Build your application views using Imba's native tags for unprecedented performance.\n").end(),
						
						(t2.$$b = t2.$$b || tag$.$example().flag('dark').setHeading("Simple reminders").setSrc('/home/examples/reminders.imba')).end(),
						
						(t2.$$c = t2.$$c || tag$.$marked().flag('section').flag('md')).setText("## Reusable components\n\nA custom tag / component can maintain internal state and control how to render itself.\nWith the performance of DOM reconciliation in Imba, you can use one-way declarative binding,\neven for animations. Write all your views in a straight-forward linear fashion as if you could\nrerender your whole application on **every single** data/state change.").end(),
						
						(t2.$$d = t2.$$d || tag$.$example().flag('dark').setHeading("World clock").setSrc('/home/examples/clock.imba')).end(),
						
						(t2.$$e = t2.$$e || tag$.$marked().flag('section').flag('md')).setText("## Extend native tags\n\nIn addition to defining custom tags, you can also extend native tags, or inherit from them.\nBinding to dom events is as simple as defining methods on your tags; all events will be\nefficiently delegated and handled by Imba. Let's define a simple sketchpad...").end(),
						
						(t2.$$f = t2.$$f || tag$.$example().flag('dark').setHeading("Custom canvas").setSrc('/home/examples/canvas.imba')).end()
					
					// <footer>
					// 	<nav>
					// 		<a.button.huge.main href='/install'> "Install"
					// 		<a.button.huge href='/guides'> "Learn more"
					],2).end()
				],2).end();
			};
			
			// def awaken
			// 	# awaken the snippets
			// 	schedule
			// 	for el in %(snippet)
			// 		el
			// 	self
			
			// def tick
			// 	log 'home.tick'
			// 	self
			
			// def assemble
			// 	return self if Imba.isClient
			// 	super
			// 	# flag('scoped',router.scoped(route,self))
			// 	# flag('selected',router.match(route,self))
		});
	
	})()

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		__webpack_require__(65);
		
		var Doc = __webpack_require__(57).Doc;
		
		return tag$.defineTag('blog', 'page', function(tag){
			
			tag.prototype.doc = function (){
				var nr;
				if (nr = this.router().scoped(/blog\/(\d+)/,1)) {
					return Doc.get('/issues/' + nr + '.json');
				} else {
					return Doc.get('/issues/' + this.posts()[0].number + '.json');
				};
			};
			
			
			tag.prototype.posts = function (){
				return APP.issues().object();
			};
			
			tag.prototype.nav = function (){
				var t0, self = this, t1;
				return (t0 = self._nav=self._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent(
						(function(t1) {
							for (var i = 0, ary = iter$(self.posts()), len = ary.length, res = []; i < len; i++) {
								res.push((t1['$$a' + i] = t1['$$a' + i] || tag$.$issue_entry().flag('entry')).flag('entry').setObject(ary[i]).end());
							};
							return res;
						})(t1)
					,3).end()
				,2).end();
			};
			
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this).flag('light')).setContent([
					(this.doc()) ? (
						(t0.$$a = t0.$$a || tag$.$issue()).setObject(this.doc()).end()
					) : void(0)
				],1).end();
			};
		});
	
	})()

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		__webpack_require__(65);
		
		function Guide(path){
			this._path = path;
			this._ready = false;
			this.fetch();
			this;
		};
		
		var cache = {};
		
		Guide.get = function (path){
			var $1;
			var cache = APP.cache();
			return cache[($1 = 'guide-' + path)] || (cache[$1] = new this(path));
		};
		
		
		
		Guide.prototype.path = function(v){ return this._path; }
		Guide.prototype.setPath = function(v){ this._path = v; return this; };
		
		Guide.prototype.ready = function (){
			return this._ready;
		};
		
		Guide.prototype.fetch = function (){
			var self = this;
			if (false) {
				// console.log 'fetch Guide on server',path
				return APP.fetchDocument(self._path + '.md',function(res) {
					// console.log 'fetch Guide on server done',path
					return self.load(res);
				});
			};
			
			return self._promise || (self._promise = APP.fetchDocument(self._path + '.md',function(res) {
				return self.load(res);
			}));
		};
		
		Guide.prototype.load = function (doc){
			this._object = doc;
			this._meta = doc.meta || {};
			this._ready = true;
			Imba.emit(this,'ready');
			return this;
		};
		
		Guide.prototype.title = function (){
			return this._object.title || 'path';
		};
		
		Guide.prototype.toc = function (){
			return this._object && this._object.toc[0];
		};
		
		Guide.prototype.body = function (){
			return this._object && this._object.body;
		};
		
		
		tag$.defineTag('guide-toc', 'toc', function(tag){
			
			
			
			tag.prototype.toc = function(v){ return this._toc; }
			tag.prototype.setToc = function(v){ this._toc = v; return this; };
			
			tag.prototype.toc = function (){
				return this._toc || this.object().toc();
			};
			
			tag.prototype.route = function (){
				return ("" + (this.object().path()) + "#" + (this.toc().slug));
			};
			
			tag.prototype.toggle = function (){
				return this.toggleFlag('collapsed');
			};
			
			tag.prototype.render = function (){
				var t0, t1, self = this, t2, t3;
				if (!this.object().ready()) { return this };
				
				this.reroute();
				
				return this.flag('entry').setLevel((this.toc().level)).setChildren([
					this.toc().children.length && this.toc().level < 2 ? (Imba.static([
						(t0 = this.$a=this.$a || tag$.$div().flag('header').setHandler('tap','toggle',this)).setContent(
							(t1 = t0.$$a=t0.$$a || tag$.$a()).setHref(this.route()).setContent(this.toc().title,3).end()
						,2).end(),
						(t2 = self.$b=self.$b || tag$.$div().flag('content')).setContent(
							(function(t2) {
								for (var i = 0, ary = iter$(self.toc().children), len = ary.length, res = []; i < len; i++) {
									res.push((t2['$$a' + i] = t2['$$a' + i] || tag$.$guide_toc()).setToc(ary[i]).setObject(self.object()).end());
								};
								return res;
							})(t2)
						,3).end()
					],2)) : (
						(t3 = self.$c=self.$c || tag$.$a()).setHref(self.route()).setContent(self.toc().title,3).end()
					)
				],1).synced();
			};
		});
		
		
		tag$.defineTag('guide', function(tag){
			
			tag.prototype.render = function (){
				var object_;
				if (!(object_ = this.object()) && object_.ready  &&  object_.ready()) { return this };
				return this.flag('md').setBody((this.object().body())).synced();
			};
			
			tag.prototype.setBody = function (body){
				if (body != this._body) {
					this._body = body;
					this.dom().innerHTML = body;
					if (Imba.isClient()) this.reawaken();
				};
				return this;
			};
			
			tag.prototype.reawaken = function (){
				for (var i = 0, ary = iter$(q$('._snippet',this)), len = ary.length; i < len; i++) {
					ary[i];
				};
				return this;
			};
		});
		
		
		return tag$.defineTag('guides', 'page', function(tag){
			
			tag.prototype.nav = function (){
				var t0, t1;
				return (t0 = this._nav=this._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent([
						(t1.$$a = t1.$$a || tag$.$guide_toc()).setObject(Guide.get('/guides')).end(),
						(t1.$$b = t1.$$b || tag$.$guide_toc()).setObject(Guide.get('/guides/language')).end()
					// <guide-toc[Guide.get('/guides/rendering')]>
					],2).end()
				,2).end();
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this).flag('light')).setContent([
					(this.guide()) ? ((t0.$$a = t0.$$a || tag$.$guide()).setObject(this.guide()).end()) : void(0)
				],1).end();
			};
			
			tag.prototype.onroute = function (e){
				var self = this;
				e.halt();
				
				var scroll = function() {
					var el;
					if (el = self.first('#' + self.router().hash())) {
						el.dom().scrollIntoView(true);
						self._scrollFreeze = window.scrollY;
						return el;
					};
					return false;
				};
				
				if (self.router().hash()) {
					self.render();
					scroll() || setTimeout(scroll,20,function() {  });
				};
				
				return self;
			};
			
			tag.prototype.guide = function (){
				if (this.router().scoped('/guides')) {
					return Guide.get(this.router().path());
				};
			};
			
			
			tag.prototype.awaken = function (){
				var self = this;
				if (Imba.isClient()) {
					// @doc = %%(guide)
					self.schedule({fps: 1});
					window.addEventListener('scroll',function() {
						// console.log 'check scrolling'
						return self.scrolled();
					});
				};
				return self;
			};
			
			tag.prototype.scrolled = function (){
				if (!this.hasFlag('scoped')) { return };
				
				var items = q$('[id]',this);
				var match;
				
				// should probably cache these periodically
				var scrollTop = window.scrollY;
				var wh = window.innerHeight;
				var dh = document.body.scrollHeight;
				
				if (this._scrollFreeze >= 0) {
					var diff = Math.abs(scrollTop - this._scrollFreeze);
					if (diff < 50) { return this };
					this._scrollFreeze = -1;
				};
				
				var scrollBottom = dh - (scrollTop + wh);
				
				// console.log scrollTop,wh,dh,scrollBottom
				
				if (scrollBottom == 0) {
					match = items.last();
				} else {
					for (var i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
						item = ary[i];
						var t = (item.dom().offsetTop + 30 + 60); // hack
						var dist = scrollTop - t;
						// console.log "{item.id} {t} {dist}"
						
						if (dist < 0) {
							match = item;break;
						};
					};
				};
				
				if (match) {
					// console.log "match is {match.id}"
					if (this._hash != match.id()) {
						this._hash = match.id();
						this.router().go('#' + this._hash,{},true);
						this.render();
					};
				};
				return this;
			};
			
			tag.prototype.tick = function (){
				this.render();
				return this;
			};
		});
	
	})()

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function pathToAnchor(path){
			return 'api-' + path.replace(/\./g,'_').replace(/\#/g,'__');
		};
		
		tag$.defineTag('api-desc', function(tag){
			
			tag.prototype.setHtml = function (html){
				if (html != this._html) {
					this.dom().innerHTML = this._html = html;
				};
				return this;
			};
		});
		
		tag$.defineTag('api-ref', function(tag){
			
			tag.prototype.render = function (){
				return this.synced();
			};
		});
		
		tag$.defineTag('api-item');
		
		tag$.defineTag('api-path', 'span', function(tag){
			
			tag.prototype.build = function (){
				var object_;
				var items = [];
				if ((typeof (object_ = this.object())=='string'||object_ instanceof String)) {
					this.setHtml(this.object().replace(/\b([\w]+|\.|\#)\b/g,function(m,i) {
						if (i == '.' || i == '#') {
							return ("<i>" + i + "</i>");
						} else if (i[0] == i[0].toUpperCase()) {
							return ("<b class='const'>" + i + "</b>");
						} else {
							return ("<b class='id'>" + i + "</b>");
						};
					}));
				};
				return this;
			};
		});
		
		
		tag$.defineTag('api-link', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren([
					(this.$a = this.$a || tag$.$api_path().flag('value')).setObject(this.object().value).end(),
					(t0 = this.$b=this.$b || tag$.$span().flag('desc')).setContent(this.object().desc,3).end()
				],2).synced();
			};
		});
		
		tag$.defineTag('api-return', 'api-link');
		
		tag$.defineTag('api-class', 'api-item', function(tag){
			
			
			tag.prototype.__object = {watch: 'parse',name: 'object'};
			tag.prototype.object = function(v){ return this._object; }
			tag.prototype.setObject = function(v){
				var a = this.object();
				if(v != a) { this._object = v; }
				if(v != a) { this.parse && this.parse(v,a,this.__object) }
				return this;
			};
			
			tag.prototype.parse = function (){
				for (var i = 0, ary = iter$(this.object()['.']), len = ary.length, m, res = []; i < len; i++) {
					m = ary[i];
					if (!m.desc) { continue; };
					res.push(m);
				};
				this._statics = res;
				for (var i = 0, ary = iter$(this.object()['#']), len = ary.length, m1, res = []; i < len; i++) {
					m1 = ary[i];
					if (!m1.desc) { continue; };
					res.push(m1);
				};
				this._methods = res;
				this._properties = [];
				return this;
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, self = this, t5, t6, t7;
				return this.setChildren([
					(this.$a = this.$a || tag$.$span().flag('toc-anchor')).setId(pathToAnchor(this.object().namepath)).end(),
					(t0 = this.$b=this.$b || tag$.$div().flag('header')).setContent((t1 = t0.$$a=t0.$$a || tag$.$div().flag('title')).setContent((t1.$$a = t1.$$a || tag$.$api_path()).setObject(this.object().namepath).end(),2).end(),2).end(),
					(this.$c = this.$c || tag$.$api_desc()).setHtml(this.object().html).end(),
					(this.object().ctor) ? (
						(t2 = this.$d=this.$d || tag$.$div().flag('content').flag('ctor')).setContent(
							(t2.$$a = t2.$$a || tag$.$api_method()).setPath((this.object().namepath + '.new')).setObject(this.object().ctor).end()
						,2).end()
					) : void(0),
					
					(t3 = self.$e=self.$e || tag$.$div().flag('content')).setContent([
						(this._statics.length > 0) ? (
							(t4 = t3.$$a=t3.$$a || tag$.$div().flag('section')).setContent([
								(t4.$$a = t4.$$a || tag$.$h2().flag('header')).setText('Static Methods').end(),
								(t5 = t4.$$b=t4.$$b || tag$.$div().flag('content').flag('list')).setContent((function(t5) {
									for (var i = 0, ary = iter$(self._statics), len = ary.length, res = []; i < len; i++) {
										res.push((t5['$$a' + i] = t5['$$a' + i] || tag$.$api_method().flag('doc')).setIname(self.object().namepath).setObject(ary[i]).end());
									};
									return res;
								})(t5),3).end()
							],2).end()
						) : void(0),
						
						(self._methods.length > 0) ? (
							(t6 = t3.$$b=t3.$$b || tag$.$div().flag('section')).setContent([
								(t6.$$a = t6.$$a || tag$.$h2().flag('header')).setText('Instance Methods').end(),
								(t7 = t6.$$b=t6.$$b || tag$.$div().flag('content').flag('list')).setContent((function(t7) {
									for (var i = 0, ary = iter$(self._methods), len = ary.length, res = []; i < len; i++) {
										res.push((t7['$$a' + i] = t7['$$a' + i] || tag$.$api_method().flag('doc')).setIname(self.object().iname).setObject(ary[i]).end());
									};
									return res;
								})(t7),3).end()
							],2).end()
						) : void(0)
					],1).end()
				],1).synced();
			};
		});
		
		tag$.defineTag('api-value', function(tag){
			
			tag.prototype.render = function (){
				var object_, $1;
				if (this.object().type) {
					this.flag(this.object().type).setChildren(
						this.object().value
					,3).synced();
				} else if ((typeof (object_ = this.object())=='string'||object_ instanceof String)) {
					this.flag('str').setText(this.object()).synced();
				} else if ((typeof ($1 = this.object())=='number'||$1 instanceof Number)) {
					this.flag('num').setText(this.object()).synced();
				};
				return this;
			};
		});
		
		
		tag$.defineTag('api-param', function(tag){
			
			tag.prototype.type = function (){
				return this.object().type;
			};
			
			tag.prototype.render = function (){
				var self = this, t0, t1;
				return this.flag(self.type()).setChildren([
					self.type() == 'NamedParams' ? (
						(function(self) {
							for (var i = 0, ary = iter$(self.object().nodes), len = ary.length, res = []; i < len; i++) {
								res.push((self['$a' + i] = self['$a' + i] || tag$.$api_param()).setObject(ary[i]).end());
							};
							return res;
						})(self)
					) : (Imba.static([
						(t0 = self.$b=self.$b || tag$.$div().flag('name')).setContent(self.object().name,3).end(),
						(self.object().defaults) ? (Imba.static([
							(t1 = self.$c=self.$c || tag$.$i()).setContent([self.type() == 'NamedParam' ? (': ') : (' = ')],1).end(),
							(self.$d = self.$d || tag$.$api_value()).setObject(self.object().defaults).end()
						],2)) : void(0)
					],3))
				],1).synced();
			};
		});
		
		tag$.defineTag('api-method', 'api-item', function(tag){
			
			
			
			tag.prototype.iname = function(v){ return this._iname; }
			tag.prototype.setIname = function(v){ this._iname = v; return this; };
			
			
			tag.prototype.path = function(v){ return this._path; }
			tag.prototype.setPath = function(v){ this._path = v; return this; };
			
			tag.prototype.tags = function (){
				var t0;
				return (t0 = this._tags=this._tags || tag$.$div().setRef('tags',this)).setContent([
					(this.object().deprecated) ? (
						(t0.$$a = t0.$$a || tag$.$div().flag('deprecated').flag('red')).setText('Method is deprecated').end()
					) : void(0),
					(this.object().return) ? ((t0.$$b = t0.$$b || tag$.$api_return().setName('returns')).setObject(this.object().return).end()) : void(0)
				],1).end();
			};
			
			tag.prototype.path = function (){
				return this._path || (this.iname() + '.' + this.object().name);
			};
			
			tag.prototype.slug = function (){
				return pathToAnchor(this.object().namepath);
			};
			
			tag.prototype.render = function (){
				var t0, self = this, t1;
				return this.flag('deprecated',this.object().deprecated).setChildren([
					(this.$a = this.$a || tag$.$span().flag('toc-anchor')).setId(this.slug()).end(),
					(t0 = self.$b=self.$b || tag$.$div().flag('header')).setContent([
						(t0.$$a = t0.$$a || tag$.$api_path()).setObject(this.path()).end(),
						(t1 = t0.$$b=t0.$$b || tag$.$div().flag('params')).setContent((function(t1) {
							for (var i = 0, ary = iter$(self.object().params), len = ary.length, res = []; i < len; i++) {
								res.push((t1['$$a' + i] = t1['$$a' + i] || tag$.$api_param()).setObject(ary[i]).end());
							};
							return res;
						})(t1),3).end(),
						(t0.$$c = t0.$$c || tag$.$div().flag('grow')).end()
					],2).end(),
					(self.$c = self.$c || tag$.$api_desc().flag('md')).setHtml(self.object().html).end(),
					self.tags()
				],1).synced();
			};
		});
		
		tag$.defineTag('doc-link', 'a', function(tag){
			
			tag.prototype.render = function (){
				this.setHref(("/docs#" + pathToAnchor(this.object().namepath))).setChildren((this.$a = this.$a || tag$.$api_path()).setObject(this.object().namepath).end(),2).synced();
				return tag.__super__.render.apply(this,arguments);
			};
			
			tag.prototype.ontap = function (){
				tag.__super__.ontap.apply(this,arguments);
				return this.up(q$('._docs',this)).refocus();
			};
		});
		
		tag$.defineTag('doc-group', 'toc', function(tag){
			
			tag.prototype.ontap = function (){
				return this.toggleFlag('collapsed');
			};
		});
		
		
		return tag$.defineTag('docs', 'page', function(tag){
			
			
			tag.prototype.__version = {'default': 'current',name: 'version'};
			tag.prototype.version = function(v){ return this._version; }
			tag.prototype.setVersion = function(v){ this._version = v; return this; }
			tag.prototype._version = 'current';
			
			
			tag.prototype.roots = function(v){ return this._roots; }
			tag.prototype.setRoots = function(v){ this._roots = v; return this; };
			
			tag.prototype.src = function (){
				return ("/api/" + this.version() + ".json");
			};
			
			tag.prototype.docs = function (){
				return this._docs;
			};
			
			tag.prototype.awaken = function (){
				this.load();
				this.schedule();
				return this;
			};
			
			tag.prototype.build = function (){
				this.load();
				return tag.__super__.build.apply(this,arguments);
			};
			
			tag.prototype.load = function (){
				var self = this;
				if (false) {
					// return self
					APP.fetchDocument(self.src(),function(res) {
						self._docs = JSON.parse(JSON.stringify(res));
						return self.generate();
					});
					return self;
				};
				
				return self._request || (self._request = APP.fetchDocument(self.src(),function(res) {
					DOCS = self._docs = res;
					DOCMAP = self._docs.entities;
					self.generate();
					return self.loaded();
				}));
			};
			
			tag.prototype.loaded = function (){
				var el;
				this.render();
				// really?
				if (document.location.hash) {
					if (el = this.first(document.location.hash)) {
						// console.log 'should scroll here?!?!?!',el
						el.dom().scrollIntoView();
					};
				};
				return this;
			};
			
			tag.prototype.refocus = function (){
				var el;
				if (el = this.first(document.location.hash)) {
					el.dom().scrollIntoView();
				};
				return this;
			};
			
			tag.prototype.lookup = function (path){
				return this.docs().entities[path];
			};
			
			tag.prototype.generate = function (){
				this._roots = [];
				var ents = this._docs.entities;
				
				for (var o = this.docs().entities, item, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
					item = o[keys[i]];if (item.type == 'class' || keys[i] == 'Imba') {
						item['.'] = (item['.'] || []).sort().map(function(path) { return ents[path]; }).filter(function(v) { return v.type == 'method' && v.desc; });
						item['#'] = (item['#'] || []).sort().map(function(path) { return ents[path]; }).filter(function(v) { return v.type == 'method' && v.desc; });
						
						if (item.desc) { this._roots.push(item) };
					};
				};
				return this;
			};
			
			tag.prototype.render = function (){
				if (!(this.docs())) { return this };
				return tag.__super__.render.apply(this,arguments);
			};
			
			tag.prototype.body = function (){
				var self = this, t0;
				return (t0 = self._body=self._body || tag$.$div().setRef('body',this).flag('light')).setContent(
					(function(t0) {
						for (var i = 0, ary = iter$(self.roots()), len = ary.length, res = []; i < len; i++) {
							res.push((t0['$$a' + i] = t0['$$a' + i] || tag$.$api_class().flag('doc').flag('l')).setObject(ary[i]).end());
						};
						return res;
					})(t0)
				,3).end();
			};
			tag.prototype.nav = function (){
				var t0, self = this, t1;
				return (t0 = self._nav=self._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent(
						(function(t1) {
							var t2, t3, t4, t5, t6;
							for (var i = 0, ary = iter$(self.roots()), len = ary.length, root, res = []; i < len; i++) {
								root = ary[i];
								res.push((t2 = t1['$$a' + i]=t1['$$a' + i] || tag$.$doc_group().flag('class').flag('section').flag('compact')).setContent([
									(t3 = t2.$$a=t2.$$a || tag$.$div().flag('header')).setContent((t3.$$a = t3.$$a || tag$.$doc_link().flag('class')).setObject(root).end(),2).end(),
									(t4 = t2.$$b=t2.$$b || tag$.$div().flag('content')).setContent([
										(t5 = t4.$$a=t4.$$a || tag$.$div().flag('static')).setContent(
											(function(t5) {
												var t6;
												for (var j = 0, items = iter$(root['.']), len_ = items.length, meth, res1 = []; j < len_; j++) {
													meth = items[j];
													if (!meth.desc) { continue; };
													res1.push((t6 = t5['$$a' + j]=t5['$$a' + j] || tag$.$div().flag('entry')).setContent((t6.$$a = t6.$$a || tag$.$doc_link()).setObject(meth).end(),2).end());
												};
												return res1;
											})(t5)
										,3).end(),
										(t6 = t4.$$b=t4.$$b || tag$.$div().flag('instance')).setContent(
											(function(t6) {
												var t7;
												for (var j = 0, items = iter$(root['#']), len_ = items.length, meth, res1 = []; j < len_; j++) {
													meth = items[j];
													if (!meth.desc) { continue; };
													res1.push((t7 = t6['$$a' + j]=t6['$$a' + j] || tag$.$div().flag('entry')).setContent((t7.$$a = t7.$$a || tag$.$doc_link()).setObject(meth).end(),2).end());
												};
												return res1;
											})(t6)
										,3).end()
									],2).end()
								],2).end());
							};
							return res;
						})(t1)
					,3).end()
				,2).end();
			};
		});
		
		
	
	})()

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// externs;
		
		// var hljs = require 'highlight.js'
		
		tag$.defineTag('tool', 'button', function(tag){
			
			
			tag.prototype.action = function(v){ return this._action; }
			tag.prototype.setAction = function(v){ this._action = v; return this; };
			
			tag.prototype.render = function (){
				return this.flag('sym').synced();
			};
			
			tag.prototype.onclick = function (e){
				this.log('button click',e);
				return e.halt();
			};
			
			tag.prototype.ontouchstart = function (e){
				this.log('touchstart');
				true;
				return e.event().preventDefault();
			};
		});
		
		tag$.defineTag('snippet-hint', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				return this.setText("I am a hint!!").synced();
			};
		});
		
		tag$.defineTag('overlays', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				var root;
				if (root = this.view()._root) {
					var left = 0,top = 0,el = root.dom();
					
					while (el && !el.contains(this._dom)){
						left += el.offsetLeft;
						top += el.offsetTop - el.scrollTop;
						el = el.parentNode;
					};
					
					this._dom.style.left = left + 'px';
					this._dom.style.top = top + 'px';
				};
				
				return this;
			};
		});
		
		tag$.defineTag('hint-label', function(tag){
			
			tag.prototype.setLabel = function (text){
				if (text != this._label) {
					this._label = text;
					this.dom().innerHTML = text;
				};
				return this;
			};
		});
		
		tag$.defineTag('overlay-hint', function(tag){
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.__row = {watch: 'rowDidSet',name: 'row'};
			tag.prototype.row = function(v){ return this._row; }
			tag.prototype.setRow = function(v){
				var a = this.row();
				if(v != a) { this._row = v; }
				if(v != a) { this.rowDidSet && this.rowDidSet(v,a,this.__row) }
				return this;
			};
			
			tag.prototype.__col = {watch: 'colDidSet',name: 'col'};
			tag.prototype.col = function(v){ return this._col; }
			tag.prototype.setCol = function(v){
				var a = this.col();
				if(v != a) { this._col = v; }
				if(v != a) { this.colDidSet && this.colDidSet(v,a,this.__col) }
				return this;
			};
			
			tag.prototype.__len = {watch: 'lenDidSet',name: 'len'};
			tag.prototype.len = function(v){ return this._len; }
			tag.prototype.setLen = function(v){
				var a = this.len();
				if(v != a) { this._len = v; }
				if(v != a) { this.lenDidSet && this.lenDidSet(v,a,this.__len) }
				return this;
			};
			
			tag.prototype.rowDidSet = function (new$,old){
				var val = ("" + (this.object().row() * this.view().lineHeight()) + "px");
				return this._dom.style.top = val;
			};
			
			tag.prototype.colDidSet = function (new$,old){
				var val = ("" + (this.object().col() * this.view().charWidth()) + "px");
				return this._dom.style.left = val;
			};
			
			tag.prototype.lenDidSet = function (new$,old){
				var width = ("" + (new$ * this.view().charWidth()) + "px");
				return this._dom.style.width = width;
			};
			
			tag.prototype.render = function (){
				// console.log 'hint at',object.row
				var reg = this.object().region();
				
				if (reg) {
					this.setRow(this.object().row());
					this.setCol(this.object().col());
					this.setLen(reg.size());
				};
				
				return this.flag('warn').flag('global',(!reg)).setType((this.object().type())).setChildren(
					(this.$a = this.$a || tag$.$hint_label().flag('label')).setLabel(this.object().label()).end()
				,2).synced();
			};
		});
		
		tag$.defineTag('jsview', function(tag){
			
			tag.prototype.render = function (){
				return this.setChildren((this._code = this._code || tag$.$code().setRef('code',this)).end(),2).synced();
			};
			
			tag.prototype.load = function (code,cb){
				// should compile bare
				var self = this;
				code = code.replace(/\/\/\# sourceMapping(.*)$/,'');
				code = code.replace(/^\(function\(\)\{\n/,'');
				code = code.replace(/\n?\}\)\(\)\n?$/,'');
				// code = code.replace(/^\t/mg,'')
				this._code.textContent = code;
				
				this.flag('huge',code.length > 1000);
				
				setTimeout(function() {
					hljs.configure({classPrefix: ''});
					var hl = hljs.highlight('javascript',code);
					self._code.setHtml(hl.value);
					return cb && cb(self);
				},0);
				
				return self;
			};
		});
		
		tag$.defineTag('console', function(tag){
			
			
			tag.prototype.editor = function(v){ return this._editor; }
			tag.prototype.setEditor = function(v){ this._editor = v; return this; };
			
			tag.prototype.reset = function (){
				this.empty();
				return this;
			};
			
			tag.prototype.log = function (val){
				console.log.apply(console,arguments);
				
				if (this.editor()) {
					this.editor().flag('console');
				};
				// console.log 'logging val',val
				
				if (val == this) {
					return;
				};
				
				if (val && val.dom) {
					val = val.dom().outerHTML;
				} else if (val instanceof Object) {
					val = JSON.stringify(val);
				};
				
				if (val != undefined) {
					this.append(tag$.$div().flag('json').setContent(val,0).end());
				};
				
				return;
			};
		});
		
		
		// this is basically like an editor
		tag$.defineTag('snippet', function(tag){
			
			var counter = 0;
			
			
			
			tag.prototype.imba = function(v){ return this._imba; }
			tag.prototype.setImba = function(v){ this._imba = v; return this; };
			
			
			tag.prototype.config = function(v){ return this._config; }
			tag.prototype.setConfig = function(v){ this._config = v; return this; };
			
			tag.prototype.__src = {watch: 'reload',name: 'src'};
			tag.prototype.src = function(v){ return this._src; }
			tag.prototype.setSrc = function(v){
				var a = this.src();
				if(v != a) { this._src = v; }
				if(v != a) { this.reload && this.reload(v,a,this.__src) }
				return this;
			};
			
			
			
			tag.prototype.heading = function(v){ return this.getAttribute('heading'); }
			tag.prototype.setHeading = function(v){ this.setAttribute('heading',v); return this; };
			
			
			tag.prototype.layout = function(v){ return this.getAttribute('layout'); }
			tag.prototype.setLayout = function(v){ this.setAttribute('layout',v); return this; };
			
			
			tag.prototype.tab = function(v){ return this.getAttribute('tab'); }
			tag.prototype.setTab = function(v){ this.setAttribute('tab',v); return this; };
			
			
			tag.prototype.__active = {watch: 'activeDidSet',name: 'active'};
			tag.prototype.active = function(v){ return this._active; }
			tag.prototype.setActive = function(v){
				var a = this.active();
				if(v != a) { this._active = v; }
				if(v != a) { this.activeDidSet && this.activeDidSet(v,a,this.__active) }
				return this;
			};
			
			tag.prototype.id = function (){
				var dom_;
				return (dom_ = this.dom()).id || (dom_.id = ("snippet" + (counter++)));
			};
			
			tag.prototype.activeDidSet = function (bool){
				return bool ? (this.schedule({fps: 60})) : (this.unschedule());
			};
			
			tag.prototype.input = function (){
				return (this._input = this._input || tag$.$imcaptor().setRef('input',this)).end();
			};
			
			tag.prototype.view = function (){
				return this._view || (this._view = (this._view = this._view || tag$.$imview().setRef('view',this)).setInput(this.input()).end());
			};
			
			tag.prototype.build = function (){
				
				var self = this, t0, t1, t2, t3, t4, t5;
				if (false) {
					if (self.src() && self.src().match(/\.imba$/)) {
						APP.fetchDocument(self.src(),function(res) {
							var v_;
							return (self.setImba(v_ = res.html),v_);
						});
					};
					// prerender shell
					self.setChildren([
						(t0 = self._main=self._main || tag$.$section().setRef('main',self)).setContent([
							(t1 = self._header=self._header || tag$.$header().setRef('header',self)).setContent([
								(t2 = t1.$$a=t1.$$a || tag$.$div().flag('title').flag('path')).setContent(self.heading(),3).end(),
								(t3 = t1.$$b=t1.$$b || tag$.$div().flag('tools')).setContent([
									(t3.$$a = t3.$$a || tag$.$tool().flag('reset').setTitle('reset').setHandler('tap','reset',self)).setText('reset').end(),
									(t3.$$b = t3.$$b || tag$.$tool().flag('js').setTitle('show js').setHandler('tap','toggleJS',self)).setText('show js').end(),
									(t3.$$c = t3.$$c || tag$.$tool().flag('run').setTitle('run').setHandler('tap','run',self)).setText('run').end()
								],2).end()
							],2).end(),
							(t4 = self._view=self._view || tag$.$div().setRef('view',self)).setContent((t5 = t4.$$a=t4.$$a || tag$.$code().flag('imbacode')).dataset('src',(self.src())).setContent(self.imba(),3).end(),2).end()
						],2).end(),
						(self._inspector = self._inspector || tag$.$div().setRef('inspector',self)).end()
					],2).synced();
					return self;
				};
				
				tag.__super__.build.apply(self,arguments);
				if (self.src()) { return self.reload() };
			};
			
			tag.prototype.setConfig = function (cfg){
				var v_;
				if (cfg != this._options) {
					this._options = cfg;
					if (cfg.title) { (this.setHeading(v_ = cfg.title),v_) };
				};
				return this;
			};
			
			tag.prototype.copts = function (){
				return this._copts || (this._copts = {
					bare: false,
					standalone: false,
					sourceMapInline: true,
					filename: ("" + this.id() + ".imba"),
					targetPath: ("" + this.id() + ".js"),
					sourcePath: ("" + this.id() + ".imba")
				});
			};
			
			tag.prototype.option = function (key){
				return this._options ? (this._options[key]) : (null);
			};
			
			tag.prototype.configure = function (o){
				this._options = o;
				return this.render();
			};
			
			tag.prototype.awaken = function (){
				var config = {};
				try {
					var code = q$$('.imbacode',this).dom().innerHTML;
				} catch (e) { };
				
				if (code) {
					config.html = code;
					this.view().load(null,{html: code});
					this.configure(config);
				};
				
				return this;
			};
			
			tag.prototype.load = function (code,o){
				if(o === undefined) o = {};
				if (code || o.html) { this.view().load(code,o) };
				return this;
			};
			
			tag.prototype.code = function (){
				return this.view().code();
			};
			
			tag.prototype.compile = function (code,o,blk){
				// cache latest compilation - return?
				if(blk==undefined && typeof o == 'function') blk = o,o = this.copts();
				if(o==undefined) o = this.copts();
				return Scrimbla.worker().compile(code,o,blk);
			};
			
			tag.prototype.overlays = function (){
				for (var i = 0, ary = iter$(this.view().hints()), len = ary.length, hint, res = []; i < len; i++) {
					hint = ary[i];
					if (!hint.active()) { continue; };
					res.push((this['_' + 'hint' + i] = this['_' + 'hint' + i] || tag$.$overlay_hint()).setView(this.view()).setObject(hint).end());
				};
				return res;
			};
			
			tag.prototype.toggleJS = function (){
				if (this.tab() != 'js') {
					this.showjs();
				} else {
					this.setTab('imba');
				};
				return this;
			};
			
			tag.prototype.oninputfocus = function (e){
				VIEW = this; // hack
				this.flag('focus');
				return (this.setActive(true),true);
			};
			
			tag.prototype.oninputblur = function (e){
				this.unflag('focus');
				var rel = e.event().relatedTarget;
				if (!(rel && this.dom().contains(rel))) {
					this.unflag('focus');
					this.setActive(false);
				};
				return this;
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, t5;
				if (false) { return this };
				
				return this.setChildren([
					this._input,
					(t0 = this._main=this._main || tag$.$section().setRef('main',this)).setContent([
						(t1 = this._header=this._header || tag$.$header().setRef('header',this)).setContent([
							(t2 = t1.$$a=t1.$$a || tag$.$div().flag('title').flag('path')).setContent(this.heading(),3).end(),
							(t3 = t1.$$b=t1.$$b || tag$.$div().flag('tools')).setContent([
								(t3.$$a = t3.$$a || tag$.$tool().flag('reset').setTitle('reset').setHandler('tap','reset',this)).setText('reset').end(),
								(t3.$$b = t3.$$b || tag$.$tool().flag('js').setTitle('show js').setHandler('tap','toggleJS',this)).setText('show js').end(),
								(t3.$$c = t3.$$c || tag$.$tool().flag('run').setTitle('run').setHandler('tap','run',this)).setText('run').end()
							],2).end()
						],2).end(),
						(t4 = this._overlays=this._overlays || tag$.$overlays().setRef('overlays',this)).setView(this.view()).setContent(this.overlays(),3).end(),
						(this._jsview = this._jsview || tag$.$jsview().setRef('jsview',this)).end(),
						this._view.end(),
						(this._console = this._console || tag$.$console().setRef('console',this).flag('dark')).setEditor(this).end()
					],1).end(),
					(t5 = this._inspector=this._inspector || tag$.$div().setRef('inspector',this)).setContent(this.playground(),3).end()
				],1).synced();
			};
			
			tag.prototype.sandbox = function (){
				return (this._sandbox = this._sandbox || tag$.$sandbox().setRef('sandbox',this).flag('playground')).setEditor(this).end();
			};
			
			tag.prototype.playground = function (){
				return this.sandbox();
			};
			
			tag.prototype.reload = function (){
				var self = this;
				if (!self._built) { return };
				
				if (DEPS[self.src()]) {
					var res = DEPS[self.src()];
					self.view().load(null,{html: res.html,filename: self.src()});
					if (self.autorun()) {
						setTimeout(function() { return self.run(); },50);
					};
					return self;
				};
				
				// get imba document?!?
				APP.fetchDocument(self.src(),function(res) {
					self.view().load(res.body,{filename: self.src()});
					if (self.autorun()) {
						return setTimeout(function() { return self.run(); },50);
					};
				});
				return self;
			};
			
			tag.prototype.onrun = function (){
				return this.run();
			};
			
			tag.prototype.autorun = function (){
				return false;
			};
			
			tag.prototype.oneditedasync = function (){
				this.flag('dirty');
				return this;
			};
			
			tag.prototype.onsave = function (){
				this.view().hints().clear();
				return this.run();
			};
			
			tag.prototype.reset = function (e){
				this._console.reset();
				if (this._options.html) {
					this.view().load(null,{html: this._options.html});
				};
				if (e) {
					e.cancel();
				};
				this.unflag('dirty');
				this.view().caret().normalize().dirty();
				return this;
			};
			
			tag.prototype.run = function (){
				var self = this;
				self.flag('running');
				self.compile(self.code(),self.copts(),function(res) {
					self.view().hints().rem(function(hint) { return hint.group() == 'runtime'; });
					
					if (res.data && res.data.code) {
						// @jsview.load(res:data:code) if res:data
						try {
							return self._sandbox.run(res.data);
						} catch (e) {
							return console.log('error');
						};
					};
				});
				return self;
			};
			
			tag.prototype.showjs = function (){
				var self = this;
				var o = {bare: true,standalone: false,filename: 'a.imba'};
				
				return self.compile(self.code(),o,function(res) {
					if (res.data && res.data.code) {
						return self._jsview.load(res.data.code,function() { var v_;
						return (self.setTab(v_ = 'js'),v_); });
					} else if (res.data && res.data.error) {
						return console.log('has error');
					};
				});
			};
			
			tag.prototype.runError = function (o){
				o.type = 'error';
				o.group = 'runtime';
				// console.log 'runError',o
				// only show error if we have a line and column
				this.view().hints().add(o).activate();
				return this.render();
			};
			
			tag.prototype.runLog = function (o){
				o.type = 'log';
				o.group = 'runtime';
				o.message || (o.message = JSON.stringify(o.params[0]));
				// console.log 'runLog',o
				
				if (o.nr != null && !o.loc) {
					var logs = this.view().find('.identifier.log,.identifier[name="log"]').toArray();
					var node = logs[o.nr];
					
					o.node = node;
					
					if (node) {
						var reg = node.region(); // node.next ? node.next.region : 
						console.log('found loc!!',node,reg);
						// let col = view.buffer.line(reg.row)[:length]
						o.loc = reg.endAtLine().collapse(); // {line: reg.row, column: col} #  reg.toJSON # {line: reg.row, column: 100}
						
						// o:loc = logs[o:nr].region.toJSON
					};
				};
				this.view().hints().add(o).activate();
				return this.render();
			};
			
			tag.prototype.runResult = function (o){
				// console.log 'runResult',o
				this.flag('repl',!!o);
				this._console.log(o);
				return this;
			};
		});
		
		tag$.defineTag('example', 'snippet', function(tag){
			
			tag.prototype.autorun = function (){
				return true;
			};
		});
		
		if (true) {
			Imba.Event.PROCESSING;
			
			
				
				var prev = Imba.Event.prototype.process;
				
				Imba.Event.prototype.process = function (){
					Imba.Event.PROCESSING = this;
					return prev.call(this);
				};
			
		};
		
		
		return tag$.defineTag('sandbox', function(tag){
			
			
			
			tag.prototype.editor = function(v){ return this._editor; }
			tag.prototype.setEditor = function(v){ this._editor = v; return this; };
			
			tag.prototype.render = function (){
				return this;
			};
			
			tag.prototype.console = function (){
				return this.editor()._console;
			};
			
			tag.prototype.onerror = function (msg,url,line,col,err){
				
				var stack_;
				if (url.match(/snippet(\d+)\.(imba|js)/)) {
					
					var id = url.split('.').shift();
					var snippet = tag$wrap(document.getElementById(id));
					
					if (snippet) {
						snippet.playground().onerror(msg,'',line,col,err);
						return;
					};
				} else if (url == 'undefined') {
					// safari?
					var ev = Imba.Event.PROCESSING;
					console.log('last event target',ev && ev.target());
					if (ev && ev.target()) {
						snippet = ev.target().closest(q$('._snippet',this));
						if (snippet) {
							return snippet.playground().onerror(msg,'',line,col,err);
						};
					};
				};
				
				console.log('caught the error here!!!',arguments,this);
				var locs = [];
				
				err && (stack_ = err.stack) && stack_.replace  &&  stack_.replace(/(\<anonymous\>|snippet\d+\.imba)\:(\d+):(\d+)/g,function(m,source,line,col) {
					locs.push({line: parseInt(line),column: parseInt(col)});
					return "";
				});
				
				locs.push({line: line,column: col});
				
				if (locs[0]) {
					var map = this.object().sourcemap;
					var consumer = Scrimbla.SourceMap.SourceMapConsumer(map);
					var loc = consumer.originalPositionFor(locs[0]);
					console.log('original location is',loc);
					this.editor().runError({message: msg,loc: loc});
				};
				
				return true;
			};
			
			tag.prototype.onlog = function (nr,pars){
				this.editor().runLog({nr: nr,params: pars});
				return this;
			};
			
			tag.prototype.empty = function (){
				for (var i = 0, ary = iter$(q$('.scheduled_',this)), len = ary.length; i < len; i++) {
					ary[i].unschedule();
				};
				return tag.__super__.empty.apply(this,arguments);
			};
			
			tag.prototype.present = function (res){
				var node;
				if (res && (res.prototype instanceof Imba.Tag)) {
					node = new res(res.createNode());
				} else if (res instanceof Imba.Tag) {
					node = res;
				};
				
				if (node) {
					this.empty().append(node);
					node.end();
				};
				
				return this.console().log(node || res);
			};
			
			tag.prototype.run = function (src){
				var self = this;
				var code = src.code;
				if (!code) { return self };
				
				self._object = src;
				
				try {
					window.onerror = function(msg,url,line,col,err) {
						console.log('caught error',msg,url,line,col,err,this);
						return self.onerror(msg,url,line,col,err);
					};
					
					code = code + '\n//# sourceURL=' + self.editor().id() + '.imba';
					var tag$ = Imba.TAGS.__clone();
					var console = self.console();
					var res = eval(code);
					self.present(res);
				} catch (e) {
					self.log('immediate error in eval-inline',e);
					self.onerror(e.message,'',e.lineNr || e.line || 0,e.column,e);
				};
				
				return self;
			};
		});
	
	})()

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgY2MwMDExZDhiOGM2YWZhZDY5NjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvaW1iYS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9jb3JlLmV2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9zY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvdGFnLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9kb20uY2xpZW50LmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5odG1sLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5zdmcuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvZG9tLmxlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9kb20uZXZlbnRzLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5zdGF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9pbmRleC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9mcy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9yZWdpb24uaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2hlbHBlcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlnaGxpZ2h0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvbGV4ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvcmV3cml0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvZXJyb3JzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL3V0aWwuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlzdG9yeS5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9sb2dnZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvc2hvcnRjdXRzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy92aWV3cy9jYXB0b3IuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL3ZpZXcuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvYnVmZmVyLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL29ic2VydmVyLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL2hpbnRzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL2NhcmV0LmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy92aWV3cy9vdmVybGF5cy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvZWRpdG9yLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL3dvcmtlci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvaW5kZXguaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Jhc2UuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL3Rva2VuLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9ibG9jay5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvcm9vdC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvbGl0ZXJhbHMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL29wZXJhdG9ycy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvc2VsZWN0b3IuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL3doaXRlc3BhY2UuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Fubm90YXRpb25zLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC5pbWJhIiwid2VicGFjazovLy8uL3NyYy9yb3V0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaW5kZXguaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYmFzZS5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9tYXJrZG93bi5pbWJhIiwid2VicGFjazovLy8uL34vbWFya2VkL2xpYi9tYXJrZWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3NpdGUuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbmF2LmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3BhZ2UuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaXNzdWVzLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2hvbWUuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYmxvZy5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9ndWlkZXMuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvZG9jcy5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9zbmlwcGV0LmltYmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN0Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFnQyxXQUFXLEVBQUU7QUFDN0MseUNBQXdDLFdBQVcsRUFBRTs7QUFFckQsRUFBQyxHOzs7Ozs7QUNoQkQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUEsRUFBQyxHOzs7Ozs7QUN0QkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0Msa0NBQWtDLEVBQUU7QUFDMUU7O0FBRUE7QUFDQSx1Q0FBc0Msa0NBQWtDLEVBQUU7QUFDMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7OztBQ25JRDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9EO0FBQ3BELDRDQUEyQztBQUMzQyxtREFBa0Q7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsSUFBRyx3Q0FBd0M7O0FBRTNDLEVBQUMsRzs7Ozs7O0FDekJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTRDLFNBQVM7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMzWUEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNELHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVJQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCLG1CQUFrQjs7QUFFbEIsc0JBQXFCO0FBQ3JCLHVCQUFzQjs7QUFFdEIsbUJBQWtCO0FBQ2xCLG1CQUFrQjs7QUFFbEIsbUJBQWtCO0FBQ2xCLG9CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25FQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaFhBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdkdBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDL0VBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qix3Q0FBd0M7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxtQkFBbUIsRUFBRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsTUFBTTtBQUNyQztBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RDtBQUN4RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE1BQU07QUFDbkI7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xIQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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OztBQUlBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxnQkFBZTtBQUNmO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QiwyQ0FBMkM7QUFDdkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE2QjtBQUM3Qiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUVBQXdFLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUErRCxTQUFTO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQW9CLFdBQVc7O0FBRS9CLG1FQUFrRSxTQUFTO0FBQzNFO0FBQ0E7O0FBRUEsOERBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUE4QjtBQUM5QixLQUFJOztBQUVKLHNDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQyxXQUFXO0FBQ2hELEtBQUksWUFBWTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTRCLFlBQVk7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQStELFNBQVM7QUFDeEUsc0VBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTBELG1DQUFtQyxFQUFFOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBa0UsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBLGdFQUErRCxTQUFTO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF1QyxVQUFVO0FBQ2pELHlFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBOEIsV0FBVztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUErRCxVQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWdFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0IsSUFBSSxJQUFJLElBQUkscUJBQXFCLEVBQUUsSUFBSSxFQUFFO0FBQy9EOztBQUVBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBdUI7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7O0FBR0Y7O0FBRUEsRUFBQyxHOzs7Ozs7QUNydENEO0FBQ0Esb0JBQW1CLCtDQUErQzs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUF5Qjs7O0FBR3pCLHNDQUFxQyxtQkFBbUI7QUFDeEQseUNBQXdDLGdCQUFnQixhQUFhOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUErRCxVQUFVO0FBQ3pFO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDeElEO0FBQ0Esb0JBQW1CLCtDQUErQztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6Qix5REFBd0QsK0JBQStCLEVBQUU7QUFDekY7QUFDQTs7QUFFQSw4QkFBNkI7OztBQUc3Qix3Q0FBdUMsbUJBQW1CO0FBQzFELDJDQUEwQyxnQkFBZ0IsYUFBYTs7O0FBR3ZFLDBDQUF5QyxxQkFBcUI7QUFDOUQsNkNBQTRDLGtCQUFrQixhQUFhOzs7QUFHM0UsMENBQXlDLHFCQUFxQjtBQUM5RCw2Q0FBNEMsa0JBQWtCLGFBQWE7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixnQ0FBZ0M7QUFDckQsSUFBRztBQUNIO0FBQ0E7QUFDQSw2Q0FBNEMsU0FBUztBQUNyRDtBQUNBLGlEQUFnRDtBQUNoRDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCLGFBQWEsRUFBRTtBQUMxQztBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLGlEQUFpRDtBQUM1RTtBQUNBO0FBQ0E7OztBQUdBLEVBQUMsRzs7Ozs7O0FDN0hEO0FBQ0Esb0JBQW1CLCtDQUErQztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7OztBQUlBLG9DQUFtQyxtQkFBbUI7QUFDdEQsdUNBQXNDLGdCQUFnQixhQUFhOzs7QUFHbkUsc0NBQXFDLHFCQUFxQjtBQUMxRCx5Q0FBd0Msa0JBQWtCLGFBQWE7OztBQUd2RSxzQ0FBcUMscUJBQXFCO0FBQzFELHlDQUF3QyxrQkFBa0IsYUFBYTs7QUFFdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDdk9EO0FBQ0Esb0JBQW1CLCtDQUErQztBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLHFDQUFvQyxrQkFBa0I7QUFDdEQsd0NBQXVDLGVBQWUsYUFBYTs7O0FBR25FLHFDQUFvQyxrQkFBa0I7QUFDdEQsd0NBQXVDLGVBQWUsYUFBYTs7O0FBR25FLHVDQUFzQyxvQkFBb0I7QUFDMUQsMENBQXlDLGlCQUFpQixhQUFhOztBQUV2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWlFLGFBQWE7QUFDOUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEIsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBLHNDQUFxQyxxQkFBcUI7QUFDMUQseUNBQXdDLGtCQUFrQixhQUFhOzs7QUFHdkUsb0NBQW1DLG1CQUFtQjtBQUN0RCx1Q0FBc0MsZ0JBQWdCLGFBQWE7OztBQUduRSxxQ0FBb0Msb0JBQW9CO0FBQ3hELHdDQUF1QyxpQkFBaUIsYUFBYTs7O0FBR3JFLHNDQUFxQyxxQkFBcUI7QUFDMUQseUNBQXdDLGtCQUFrQixhQUFhOztBQUV2RSwyQkFBMEI7QUFDMUIsb0NBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0EsZ0JBQWUsZ0JBQWdCO0FBQy9CLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQSwwQkFBeUI7QUFDekIsbUNBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0EsZ0JBQWUsZUFBZTtBQUM5QixnQkFBZTtBQUNmO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCLDBCQUF5QjtBQUN6QixtQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxnQkFBZSxlQUFlO0FBQzlCLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOzs7QUFHQSxxQ0FBb0Msb0JBQW9CO0FBQ3hELHdDQUF1QyxpQkFBaUIsYUFBYTs7OztBQUlyRSxvQ0FBbUMsbUJBQW1CO0FBQ3RELHVDQUFzQyxnQkFBZ0IsYUFBYSxHQUFHOzs7QUFHdEUsb0NBQW1DLG1CQUFtQjtBQUN0RCx1Q0FBc0MsZ0JBQWdCLGFBQWE7OztBQUduRSxvQ0FBbUMsbUJBQW1CO0FBQ3RELHVDQUFzQyxnQkFBZ0IsYUFBYTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CO0FBQ25CLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRCxlQUFlLEVBQUU7QUFDdkU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixrQkFBa0I7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTs7QUFFYjtBQUNBOztBQUVBLHlCQUF3QjtBQUN4Qix5QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFhLHVEQUF1RDtBQUNwRTtBQUNBLHFCQUFvQixrRkFBa0Y7QUFDdEcscUJBQW9CLDJDQUEyQztBQUMvRCxtQkFBa0Isd0JBQXdCOztBQUUxQztBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0Esc0JBQXFCLHdCQUF3QjtBQUM3QyxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsRUFBQyxHOzs7Ozs7QUNsc0JEOztBQUVBOzs7QUFHQSxvQ0FBbUMsbUJBQW1CO0FBQ3RELHVDQUFzQyxnQkFBZ0IsYUFBYTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7O0FBR0Esb0NBQW1DLG1CQUFtQjtBQUN0RCx1Q0FBc0MsZ0JBQWdCLGFBQWE7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGLEVBQUMsRzs7Ozs7O0FDL0JEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRixFQUFDLEc7Ozs7OztBQ3pERDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQywwQkFBMEIsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDM0NEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDWEQ7QUFDQSxvQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTJDLHdCQUF3QjtBQUNuRTtBQUNBOztBQUVBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUI7QUFDckI7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLHlCQUF3QjtBQUN4Qiw0QkFBMkIsR0FBRztBQUM5QixvQ0FBbUMsR0FBRztBQUN0QyxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLEVBQUU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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cyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgY2MwMDExZDhiOGM2YWZhZDY5NjJcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0cmVxdWlyZSgnaW1iYS9saWIvaW1iYS9icm93c2VyJyk7XG5cdFxuXHQvLyBuZWVkIHRvIHVzZSB3ZWJwYWNrIGZvciB0aGlzIGluY2x1ZGUgdG8gd29yayBhcyBpbnRlbmRlZFxuXHRTY3JpbWJsYSA9IHJlcXVpcmUoJ3NjcmltYmxhL3NyYy9pbmRleCcpO1xuXHRcblx0dmFyIEFwcCA9IHJlcXVpcmUoJy4vYXBwJykuQXBwO1xuXHRBUFAgPSBuZXcgQXBwKCk7XG5cdEFQUC5zY2hlZHVsZSgpO1xuXHRcblx0cmVxdWlyZSgnLi92aWV3cycpO1xuXHRcblx0Ly8gYXdha2VuIHBhZ2VzIGV0Y1xuXHRxJCgnLl9wYWdlJykubWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbDsgfSk7XG5cdHJldHVybiBxJCgnLmF3YWtlbicpLm1hcChmdW5jdGlvbihlbCkgeyByZXR1cm4gZWw7IH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jbGllbnQuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0aWYgKHR5cGVvZiBJbWJhID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJlcXVpcmUoJy4vaW1iYScpO1xuXHRcdFxuXHRcdEltYmEuQ0xJRU5UID0gdHJ1ZTtcblx0XHRcblx0XHRyZXF1aXJlKCcuL2NvcmUuZXZlbnRzJyk7XG5cdFx0cmVxdWlyZSgnLi9zY2hlZHVsZXInKTtcblx0XHRyZXF1aXJlKCcuL3RhZycpO1xuXHRcdHJlcXVpcmUoJy4vZG9tJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uY2xpZW50Jyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uaHRtbCcpO1xuXHRcdHJlcXVpcmUoJy4vZG9tLnN2ZycpO1xuXHRcdHJlcXVpcmUoJy4vZG9tLmxlZ2FjeScpO1xuXHRcdHJlcXVpcmUoJy4vZG9tLmV2ZW50cycpO1xuXHRcdHJlcXVpcmUoJy4vZG9tLnN0YXRpYycpO1xuXHRcdHJldHVybiByZXF1aXJlKCcuL3NlbGVjdG9yJyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGNvbnNvbGUud2FybihcIkltYmEgaXMgYWxyZWFkeSBsb2FkZWRcIik7XG5cdH07XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHQvLyBleHRlcm5zO1xuXHRcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0Z2xvYmFsID0gd2luZG93O1xuXHR9O1xuXHRcblx0Lypcblx0SW1iYSBpcyB0aGUgbmFtZXNwYWNlIGZvciBhbGwgcnVudGltZSByZWxhdGVkIHV0aWxpdGllc1xuXHRAbmFtZXNwYWNlXG5cdCovXG5cdFxuXHRJbWJhID0ge1xuXHRcdFZFUlNJT046ICcwLjE0LjEnLFxuXHRcdERFQlVHOiBmYWxzZVxuXHR9O1xuXHRcblx0dmFyIHJlZyA9IC8tLi9nO1xuXHRcblx0Lypcblx0VHJ1ZSBpZiBydW5uaW5nIGluIGNsaWVudCBlbnZpcm9ubWVudC5cblx0QHJldHVybiB7Ym9vbH1cblx0Ki9cblx0XG5cdEltYmEuaXNDbGllbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gSW1iYS5DTElFTlQgPT09IHRydWU7XG5cdH07XG5cdFxuXHQvKlxuXHRUcnVlIGlmIHJ1bm5pbmcgaW4gc2VydmVyIGVudmlyb25tZW50LlxuXHRAcmV0dXJuIHtib29sfVxuXHQqL1xuXHRcblx0SW1iYS5pc1NlcnZlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBJbWJhLlNFUlZFUiA9PT0gdHJ1ZTtcblx0fTtcblx0XG5cdEltYmEuc3ViY2xhc3MgPSBmdW5jdGlvbiAob2JqLHN1cCl7XG5cdFx0O1xuXHRcdGZvciAodmFyIGsgaW4gc3VwKXtcblx0XHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIHsgb2JqW2tdID0gc3VwW2tdIH07XG5cdFx0fTtcblx0XHRcblx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xuXHRcdG9iai5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmo7XG5cdFx0cmV0dXJuIG9iajtcblx0fTtcblx0XG5cdC8qXG5cdExpZ2h0d2VpZ2h0IG1ldGhvZCBmb3IgbWFraW5nIGFuIG9iamVjdCBpdGVyYWJsZSBpbiBpbWJhcyBmb3IvaW4gbG9vcHMuXG5cdElmIHRoZSBjb21waWxlciBjYW5ub3Qgc2F5IGZvciBjZXJ0YWluIHRoYXQgYSB0YXJnZXQgaW4gYSBmb3IgbG9vcCBpcyBhblxuXHRhcnJheSwgaXQgd2lsbCBjYWNoZSB0aGUgaXRlcmFibGUgdmVyc2lvbiBiZWZvcmUgbG9vcGluZy5cblx0XG5cdGBgYGltYmFcblx0IyB0aGlzIGlzIHRoZSB3aG9sZSBtZXRob2Rcblx0ZGVmIEltYmEuaXRlcmFibGUgb1xuXHRcdHJldHVybiBvID8gKG86dG9BcnJheSA/IG8udG9BcnJheSA6IG8pIDogW11cblx0XG5cdGNsYXNzIEN1c3RvbUl0ZXJhYmxlXG5cdFx0ZGVmIHRvQXJyYXlcblx0XHRcdFsxLDIsM11cblx0XG5cdCMgd2lsbCByZXR1cm4gWzIsNCw2XVxuXHRmb3IgeCBpbiBDdXN0b21JdGVyYWJsZS5uZXdcblx0XHR4ICogMlxuXHRcblx0YGBgXG5cdCovXG5cdFxuXHRJbWJhLml0ZXJhYmxlID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiBvID8gKChvLnRvQXJyYXkgPyAoby50b0FycmF5KCkpIDogKG8pKSkgOiAoW10pO1xuXHR9O1xuXHRcblx0Lypcblx0Q29lcmNlcyBhIHZhbHVlIGludG8gYSBwcm9taXNlLiBJZiB2YWx1ZSBpcyBhcnJheSBpdCB3aWxsXG5cdGNhbGwgYFByb21pc2UuYWxsKHZhbHVlKWAsIG9yIGlmIGl0IGlzIG5vdCBhIHByb21pc2UgaXQgd2lsbFxuXHR3cmFwIHRoZSB2YWx1ZSBpbiBgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKWAuIFVzZWQgZm9yIGV4cGVyaW1lbnRhbFxuXHRhd2FpdCBzeW50YXguXG5cdEByZXR1cm4ge1Byb21pc2V9XG5cdCovXG5cdFxuXHRJbWJhLmF3YWl0ID0gZnVuY3Rpb24gKHZhbHVlKXtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLnRoZW4pIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdEltYmEudG9DYW1lbENhc2UgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UocmVnLGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0uY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7IH0pO1xuXHR9O1xuXHRcblx0SW1iYS50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHJldHVybiBzdHIucmVwbGFjZShyZWcsZnVuY3Rpb24obSkgeyByZXR1cm4gbS5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTsgfSk7XG5cdH07XG5cdFxuXHRJbWJhLmluZGV4T2YgPSBmdW5jdGlvbiAoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IChiLmluZGV4T2YoYSkpIDogKFtdLmluZGV4T2YuY2FsbChhLGIpKTtcblx0fTtcblx0XG5cdEltYmEucHJvcCA9IGZ1bmN0aW9uIChzY29wZSxuYW1lLG9wdHMpe1xuXHRcdGlmIChzY29wZS5kZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0cmV0dXJuIHNjb3BlLmRlZmluZVByb3BlcnR5KG5hbWUsb3B0cyk7XG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRyZXR1cm4gSW1iYS5hdHRyID0gZnVuY3Rpb24gKHNjb3BlLG5hbWUsb3B0cyl7XG5cdFx0aWYgKHNjb3BlLmRlZmluZUF0dHJpYnV0ZSkge1xuXHRcdFx0cmV0dXJuIHNjb3BlLmRlZmluZUF0dHJpYnV0ZShuYW1lLG9wdHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGdldE5hbWUgPSBJbWJhLnRvQ2FtZWxDYXNlKG5hbWUpO1xuXHRcdHZhciBzZXROYW1lID0gSW1iYS50b0NhbWVsQ2FzZSgnc2V0LScgKyBuYW1lKTtcblx0XHRcblx0XHRzY29wZS5wcm90b3R5cGVbZ2V0TmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcblx0XHR9O1xuXHRcdFxuXHRcdHNjb3BlLnByb3RvdHlwZVtzZXROYW1lXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShuYW1lLHZhbHVlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2ltYmEuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdFxuXHRmdW5jdGlvbiBlbWl0X18oZXZlbnQsYXJncyxub2RlKXtcblx0XHQvLyB2YXIgbm9kZSA9IGNic1tldmVudF1cblx0XHR2YXIgcHJldixjYixyZXQ7XG5cdFx0XG5cdFx0d2hpbGUgKChwcmV2ID0gbm9kZSkgJiYgKG5vZGUgPSBub2RlLm5leHQpKXtcblx0XHRcdGlmIChjYiA9IG5vZGUubGlzdGVuZXIpIHtcblx0XHRcdFx0aWYgKG5vZGUucGF0aCAmJiBjYltub2RlLnBhdGhdKSB7XG5cdFx0XHRcdFx0cmV0ID0gYXJncyA/IChjYltub2RlLnBhdGhdLmFwcGx5KGNiLGFyZ3MpKSA6IChjYltub2RlLnBhdGhdKCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIGl0IGlzIGEgbWV0aG9kP1xuXHRcdFx0XHRcdHJldCA9IGFyZ3MgPyAoY2IuYXBwbHkobm9kZSxhcmdzKSkgOiAoY2IuY2FsbChub2RlKSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobm9kZS50aW1lcyAmJiAtLW5vZGUudGltZXMgPD0gMCkge1xuXHRcdFx0XHRwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG5cdFx0XHRcdG5vZGUubGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIG1ldGhvZCBmb3IgcmVnaXN0ZXJpbmcgYSBsaXN0ZW5lciBvbiBvYmplY3Rcblx0SW1iYS5saXN0ZW4gPSBmdW5jdGlvbiAob2JqLGV2ZW50LGxpc3RlbmVyLHBhdGgpe1xuXHRcdHZhciAkMTtcblx0XHR2YXIgY2JzLGxpc3QsdGFpbDtcblx0XHRjYnMgPSBvYmouX19saXN0ZW5lcnNfXyB8fCAob2JqLl9fbGlzdGVuZXJzX18gPSB7fSk7XG5cdFx0bGlzdCA9IGNic1soJDEgPSBldmVudCldIHx8IChjYnNbJDFdID0ge30pO1xuXHRcdHRhaWwgPSBsaXN0LnRhaWwgfHwgKGxpc3QudGFpbCA9IChsaXN0Lm5leHQgPSB7fSkpO1xuXHRcdHRhaWwubGlzdGVuZXIgPSBsaXN0ZW5lcjtcblx0XHR0YWlsLnBhdGggPSBwYXRoO1xuXHRcdGxpc3QudGFpbCA9IHRhaWwubmV4dCA9IHt9O1xuXHRcdHJldHVybiB0YWlsO1xuXHR9O1xuXHRcblx0SW1iYS5vbmNlID0gZnVuY3Rpb24gKG9iaixldmVudCxsaXN0ZW5lcil7XG5cdFx0dmFyIHRhaWwgPSBJbWJhLmxpc3RlbihvYmosZXZlbnQsbGlzdGVuZXIpO1xuXHRcdHRhaWwudGltZXMgPSAxO1xuXHRcdHJldHVybiB0YWlsO1xuXHR9O1xuXHRcblx0SW1iYS51bmxpc3RlbiA9IGZ1bmN0aW9uIChvYmosZXZlbnQsY2IsbWV0aCl7XG5cdFx0dmFyIG5vZGUscHJldjtcblx0XHR2YXIgbWV0YSA9IG9iai5fX2xpc3RlbmVyc19fO1xuXHRcdGlmICghbWV0YSkgeyByZXR1cm4gfTtcblx0XHRcblx0XHRpZiAobm9kZSA9IG1ldGFbZXZlbnRdKSB7XG5cdFx0XHR3aGlsZSAoKHByZXYgPSBub2RlKSAmJiAobm9kZSA9IG5vZGUubmV4dCkpe1xuXHRcdFx0XHRpZiAobm9kZSA9PSBjYiB8fCBub2RlLmxpc3RlbmVyID09IGNiKSB7XG5cdFx0XHRcdFx0cHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBjb3JyZWN0IHBhdGggYXMgd2VsbD9cblx0XHRcdFx0XHRub2RlLmxpc3RlbmVyID0gbnVsbDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRJbWJhLmVtaXQgPSBmdW5jdGlvbiAob2JqLGV2ZW50LHBhcmFtcyl7XG5cdFx0dmFyIGNiO1xuXHRcdGlmIChjYiA9IG9iai5fX2xpc3RlbmVyc19fKSB7XG5cdFx0XHRpZiAoY2JbZXZlbnRdKSB7IGVtaXRfXyhldmVudCxwYXJhbXMsY2JbZXZlbnRdKSB9O1xuXHRcdFx0aWYgKGNiLmFsbCkgeyBlbWl0X18oZXZlbnQsW2V2ZW50LHBhcmFtc10sY2IuYWxsKSB9OyAvLyBhbmQgZXZlbnQgIT0gJ2FsbCdcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdHJldHVybiBJbWJhLm9ic2VydmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYnNlcnZlcixrZXksdHJpZ2dlcix0YXJnZXQscHJldil7XG5cdFx0aWYgKHByZXYgJiYgdHlwZW9mIHByZXYgPT0gJ29iamVjdCcpIHtcblx0XHRcdEltYmEudW5saXN0ZW4ocHJldiwnYWxsJyxvYnNlcnZlcix0cmlnZ2VyKTtcblx0XHR9O1xuXHRcdGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PSAnb2JqZWN0Jykge1xuXHRcdFx0SW1iYS5saXN0ZW4odGFyZ2V0LCdhbGwnLG9ic2VydmVyLHRyaWdnZXIpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvY29yZS5ldmVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRcblx0dmFyIHJhZjsgLy8gdmVyeSBzaW1wbGUgcmFmIHBvbHlmaWxsXG5cdHJhZiB8fCAocmFmID0gZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSk7XG5cdHJhZiB8fCAocmFmID0gZ2xvYmFsLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSk7XG5cdHJhZiB8fCAocmFmID0gZ2xvYmFsLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSk7XG5cdHJhZiB8fCAocmFmID0gZnVuY3Rpb24oYmxrKSB7IHJldHVybiBzZXRUaW1lb3V0KGJsaywxMDAwIC8gNjApOyB9KTtcblx0XG5cdEltYmEudGljayA9IGZ1bmN0aW9uIChkKXtcblx0XHRpZiAodGhpcy5fc2NoZWR1bGVkKSB7IHJhZihJbWJhLnRpY2tlcigpKSB9O1xuXHRcdEltYmEuU2NoZWR1bGVyLndpbGxSdW4oKTtcblx0XHR0aGlzLmVtaXQodGhpcywndGljaycsW2RdKTtcblx0XHRJbWJhLlNjaGVkdWxlci5kaWRSdW4oKTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRJbWJhLnRpY2tlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRyZXR1cm4gc2VsZi5fdGlja2VyIHx8IChzZWxmLl90aWNrZXIgPSBmdW5jdGlvbihlKSB7IHJldHVybiBzZWxmLnRpY2soZSk7IH0pO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdEdsb2JhbCBhbHRlcm5hdGl2ZSB0byByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFNjaGVkdWxlIGEgdGFyZ2V0XG5cdHRvIHRpY2sgZXZlcnkgZnJhbWUuIFlvdSBjYW4gc3BlY2lmeSB3aGljaCBtZXRob2QgdG8gY2FsbCBvbiB0aGVcblx0dGFyZ2V0IChkZWZhdWx0cyB0byB0aWNrKS5cblx0XG5cdCovXG5cdFxuXHRJbWJhLnNjaGVkdWxlID0gZnVuY3Rpb24gKHRhcmdldCxtZXRob2Qpe1xuXHRcdGlmKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSBtZXRob2QgPSAndGljayc7XG5cdFx0dGhpcy5saXN0ZW4odGhpcywndGljaycsdGFyZ2V0LG1ldGhvZCk7XG5cdFx0Ly8gc3RhcnQgc2NoZWR1bGluZyBub3cgaWYgdGhpcyB3YXMgdGhlIGZpcnN0IG9uZVxuXHRcdGlmICghdGhpcy5fc2NoZWR1bGVkKSB7XG5cdFx0XHR0aGlzLl9zY2hlZHVsZWQgPSB0cnVlO1xuXHRcdFx0cmFmKEltYmEudGlja2VyKCkpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0VW5zY2hlZHVsZSBhIHByZXZpb3VzbHkgc2NoZWR1bGVkIHRhcmdldFxuXHRcblx0Ki9cblx0XG5cdEltYmEudW5zY2hlZHVsZSA9IGZ1bmN0aW9uICh0YXJnZXQsbWV0aG9kKXtcblx0XHR0aGlzLnVubGlzdGVuKHRoaXMsJ3RpY2snLHRhcmdldCxtZXRob2QpO1xuXHRcdHZhciBjYnMgPSB0aGlzLl9fbGlzdGVuZXJzX18gfHwgKHRoaXMuX19saXN0ZW5lcnNfXyA9IHt9KTtcblx0XHRpZiAoIWNicy50aWNrIHx8ICFjYnMudGljay5uZXh0IHx8ICFjYnMudGljay5uZXh0Lmxpc3RlbmVyKSB7XG5cdFx0XHR0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdExpZ2h0IHdyYXBwZXIgYXJvdW5kIG5hdGl2ZSBzZXRUaW1lb3V0IHRoYXQgZXhwZWN0cyB0aGUgYmxvY2sgLyBmdW5jdGlvblxuXHRhcyBsYXN0IGFyZ3VtZW50IChpbnN0ZWFkIG9mIGZpcnN0KS4gSXQgYWxzbyB0cmlnZ2VycyBhbiBldmVudCB0byBJbWJhXG5cdGFmdGVyIHRoZSB0aW1lb3V0IHRvIGxldCBzY2hlZHVsZXJzIHVwZGF0ZSAodG8gcmVyZW5kZXIgZXRjKSBhZnRlcndhcmRzLlxuXHRcblx0Ki9cblx0XG5cdEltYmEuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChkZWxheSxibG9jayl7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRibG9jaygpO1xuXHRcdFx0cmV0dXJuIEltYmEuU2NoZWR1bGVyLm1hcmtEaXJ0eSgpO1xuXHRcdFx0Ly8gSW1iYS5lbWl0KEltYmEsJ3RpbWVvdXQnLFtibG9ja10pXG5cdFx0fSxkZWxheSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0TGlnaHQgd3JhcHBlciBhcm91bmQgbmF0aXZlIHNldEludGVydmFsIHRoYXQgZXhwZWN0cyB0aGUgYmxvY2sgLyBmdW5jdGlvblxuXHRhcyBsYXN0IGFyZ3VtZW50IChpbnN0ZWFkIG9mIGZpcnN0KS4gSXQgYWxzbyB0cmlnZ2VycyBhbiBldmVudCB0byBJbWJhXG5cdGFmdGVyIGV2ZXJ5IGludGVydmFsIHRvIGxldCBzY2hlZHVsZXJzIHVwZGF0ZSAodG8gcmVyZW5kZXIgZXRjKSBhZnRlcndhcmRzLlxuXHRcblx0Ki9cblx0XG5cdEltYmEuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwsYmxvY2spe1xuXHRcdHJldHVybiBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblx0XHRcdGJsb2NrKCk7XG5cdFx0XHRyZXR1cm4gSW1iYS5TY2hlZHVsZXIubWFya0RpcnR5KCk7XG5cdFx0XHQvLyBJbWJhLmVtaXQoSW1iYSwnaW50ZXJ2YWwnLFtibG9ja10pXG5cdFx0fSxpbnRlcnZhbCk7XG5cdH07XG5cdFxuXHQvKlxuXHRDbGVhciBpbnRlcnZhbCB3aXRoIHNwZWNpZmllZCBpZFxuXHQqL1xuXHRcblx0SW1iYS5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKGludGVydmFsKXtcblx0XHRyZXR1cm4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdH07XG5cdFxuXHQvKlxuXHRDbGVhciB0aW1lb3V0IHdpdGggc3BlY2lmaWVkIGlkXG5cdCovXG5cdFxuXHRJbWJhLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICh0aW1lb3V0KXtcblx0XHRyZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHR9O1xuXHRcblx0Ly8gc2hvdWxkIGFkZCBhbiBJbWJhLnJ1biAvIHNldEltbWVkaWF0ZSB0aGF0XG5cdC8vIHB1c2hlcyBsaXN0ZW5lciBvbnRvIHRoZSB0aWNrLXF1ZXVlIHdpdGggdGltZXMgLSBvbmNlXG5cdFxuXHRcblx0Lypcblx0XG5cdEluc3RhbmNlcyBvZiBJbWJhLlNjaGVkdWxlciBtYW5hZ2VzIHdoZW4gdG8gY2FsbCBgdGljaygpYCBvbiB0aGVpciB0YXJnZXQsXG5cdGF0IGEgc3BlY2lmaWVkIGZyYW1lcmF0ZSBvciB3aGVuIGNlcnRhaW4gZXZlbnRzIG9jY3VyLiBSb290LW5vZGVzIGluIHlvdXJcblx0YXBwbGljYXRpb25zIHdpbGwgdXN1YWxseSBoYXZlIGEgc2NoZWR1bGVyIHRvIG1ha2Ugc3VyZSB0aGV5IHJlcmVuZGVyIHdoZW5cblx0c29tZXRoaW5nIGNoYW5nZXMuIEl0IGlzIGFsc28gcG9zc2libGUgdG8gbWFrZSBpbm5lciBjb21wb25lbnRzIHVzZSB0aGVpclxuXHRvd24gc2NoZWR1bGVycyB0byBjb250cm9sIHdoZW4gdGhleSByZW5kZXIuXG5cdFxuXHRAaW5hbWUgc2NoZWR1bGVyXG5cdFxuXHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIgPSBmdW5jdGlvbiBTY2hlZHVsZXIodGFyZ2V0KXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHNlbGYuX21hcmtlZCA9IGZhbHNlO1xuXHRcdHNlbGYuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdHNlbGYuX21hcmtlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5tYXJrKCk7IH07XG5cdFx0c2VsZi5fdGlja2VyID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi50aWNrKGUpOyB9O1xuXHRcdFxuXHRcdHNlbGYuX2V2ZW50cyA9IHRydWU7XG5cdFx0c2VsZi5fZnBzID0gMTtcblx0XHRcblx0XHRzZWxmLl9kdCA9IDA7XG5cdFx0c2VsZi5fdGltZXN0YW1wID0gMDtcblx0XHRzZWxmLl90aWNrcyA9IDA7XG5cdFx0c2VsZi5fZmx1c2hlcyA9IDA7XG5cdH07XG5cdFxuXHRJbWJhLlNjaGVkdWxlci5tYXJrRGlydHkgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNjaGVkdWxlci5pc0RpcnR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuICEhdGhpcy5fZGlydHk7XG5cdH07XG5cdFxuXHRJbWJhLlNjaGVkdWxlci53aWxsUnVuID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG5cdH07XG5cdFxuXHRJbWJhLlNjaGVkdWxlci5kaWRSdW4gPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcy5fZGlydHkgPSBmYWxzZTtcblx0fTtcblx0XG5cdEltYmEuU2NoZWR1bGVyLmlzQWN0aXZlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuICEhdGhpcy5fYWN0aXZlO1xuXHR9O1xuXHRcblx0Lypcblx0XHRDcmVhdGUgYSBuZXcgSW1iYS5TY2hlZHVsZXIgZm9yIHNwZWNpZmllZCB0YXJnZXRcblx0XHRAcmV0dXJuIHtJbWJhLlNjaGVkdWxlcn1cblx0XHQqL1xuXHRcblx0Lypcblx0XHRDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IHNjaGVkdWxlciBpcyBhY3RpdmUgb3Igbm90XG5cdFx0QHJldHVybiB7Ym9vbH1cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9hY3RpdmU7XG5cdH07XG5cdFxuXHQvKlxuXHRcdERlbHRhIHRpbWUgYmV0d2VlbiB0aGUgdHdvIGxhc3QgdGlja3Ncblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5kdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kdDtcblx0fTtcblx0XG5cdC8qXG5cdFx0Q29uZmlndXJlIHRoZSBzY2hlZHVsZXJcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHBhcnMpe1xuXHRcdGlmKCFwYXJzfHxwYXJzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHBhcnMgPSB7fTtcblx0XHR2YXIgZnBzID0gcGFycy5mcHMgIT09IHVuZGVmaW5lZCA/IHBhcnMuZnBzIDogMTtcblx0XHR2YXIgZXZlbnRzID0gcGFycy5ldmVudHMgIT09IHVuZGVmaW5lZCA/IHBhcnMuZXZlbnRzIDogdHJ1ZTtcblx0XHRpZiAoZXZlbnRzICE9IG51bGwpIHsgdGhpcy5fZXZlbnRzID0gZXZlbnRzIH07XG5cdFx0aWYgKGZwcyAhPSBudWxsKSB7IHRoaXMuX2ZwcyA9IGZwcyB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRNYXJrIHRoZSBzY2hlZHVsZXIgYXMgZGlydHkuIFRoaXMgd2lsbCBtYWtlIHN1cmUgdGhhdFxuXHRcdHRoZSBzY2hlZHVsZXIgY2FsbHMgYHRhcmdldC50aWNrYCBvbiB0aGUgbmV4dCBmcmFtZVxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fbWFya2VkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0SW5zdGFudGx5IHRyaWdnZXIgdGFyZ2V0LnRpY2sgYW5kIG1hcmsgc2NoZWR1bGVyIGFzIGNsZWFuIChub3QgZGlydHkvbWFya2VkKS5cblx0XHRUaGlzIGlzIGNhbGxlZCBpbXBsaWNpdGx5IGZyb20gdGljaywgYnV0IGNhbiBhbHNvIGJlIGNhbGxlZCBtYW51YWxseSBpZiB5b3Vcblx0XHRyZWFsbHkgd2FudCB0byBmb3JjZSBhIHRpY2sgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgbmV4dCBmcmFtZS5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9tYXJrZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9mbHVzaGVzKys7XG5cdFx0dGhpcy5fdGFyZ2V0LnRpY2soKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0QGZpeG1lIHRoaXMgZXhwZWN0cyByYWYgdG8gcnVuIGF0IDYwIGZwcyBcblx0XG5cdFx0Q2FsbGVkIGF1dG9tYXRpY2FsbHkgb24gZXZlcnkgZnJhbWUgd2hpbGUgdGhlIHNjaGVkdWxlciBpcyBhY3RpdmUuXG5cdFx0SXQgd2lsbCBvbmx5IGNhbGwgYHRhcmdldC50aWNrYCBpZiB0aGUgc2NoZWR1bGVyIGlzIG1hcmtlZCBkaXJ0eSxcblx0XHRvciB3aGVuIGFjY29yZGluZyB0byBAZnBzIHNldHRpbmcuXG5cdFxuXHRcdElmIHlvdSBoYXZlIHNldCB1cCBhIHNjaGVkdWxlciB3aXRoIGFuIGZwcyBvZiAxLCB0aWNrIHdpbGwgc3RpbGwgYmVcblx0XHRjYWxsZWQgZXZlcnkgZnJhbWUsIGJ1dCBgdGFyZ2V0LnRpY2tgIHdpbGwgb25seSBiZSBjYWxsZWQgb25jZSBldmVyeVxuXHRcdHNlY29uZCwgYW5kIGl0IHdpbGwgKm1ha2Ugc3VyZSogZWFjaCBgdGFyZ2V0LnRpY2tgIGhhcHBlbnMgaW4gc2VwYXJhdGVcblx0XHRzZWNvbmRzIGFjY29yZGluZyB0byBEYXRlLiBTbyBpZiB5b3UgaGF2ZSBhIG5vZGUgdGhhdCByZW5kZXJzIGEgY2xvY2tcblx0XHRiYXNlZCBvbiBEYXRlLm5vdyAob3Igc29tZXRoaW5nIHNpbWlsYXIpLCB5b3UgY2FuIHNjaGVkdWxlIGl0IHdpdGggMWZwcyxcblx0XHRuZXZlciBuZWVkaW5nIHRvIHdvcnJ5IGFib3V0IHR3byB0aWNrcyBoYXBwZW5pbmcgd2l0aGluIHRoZSBzYW1lIHNlY29uZC5cblx0XHRUaGUgc2FtZSBnb2VzIGZvciA0ZnBzLCAxMGZwcyBldGMuXG5cdFxuXHRcdEBwcm90ZWN0ZWRcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uIChkZWx0YSl7XG5cdFx0dGhpcy5fdGlja3MrKztcblx0XHR0aGlzLl9kdCA9IGRlbHRhO1xuXHRcdFxuXHRcdHZhciBmcHMgPSB0aGlzLl9mcHM7XG5cdFx0XG5cdFx0aWYgKGZwcyA9PSA2MCkge1xuXHRcdFx0dGhpcy5fbWFya2VkID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGZwcyA9PSAzMCkge1xuXHRcdFx0aWYgKHRoaXMuX3RpY2tzICUgMikgeyB0aGlzLl9tYXJrZWQgPSB0cnVlIH07XG5cdFx0fSBlbHNlIGlmIChmcHMpIHtcblx0XHRcdC8vIGlmIGl0IGlzIGxlc3Mgcm91bmQgLSB3ZSB0cmlnZ2VyIGJhc2VkXG5cdFx0XHQvLyBvbiBkYXRlLCBmb3IgY29uc2lzdGVudCByZW5kZXJpbmcuXG5cdFx0XHQvLyBpZSwgaWYgeW91IHdhbnQgdG8gcmVuZGVyIGV2ZXJ5IHNlY29uZFxuXHRcdFx0Ly8gaXQgaXMgaW1wb3J0YW50IHRoYXQgbm8gdHdvIHJlbmRlcnNcblx0XHRcdC8vIGhhcHBlbiBkdXJpbmcgdGhlIHNhbWUgc2Vjb25kIChhY2NvcmRpbmcgdG8gRGF0ZSlcblx0XHRcdHZhciBwZXJpb2QgPSAoKDYwIC8gZnBzKSAvIDYwKSAqIDEwMDA7XG5cdFx0XHR2YXIgYmVhdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIHBlcmlvZCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9iZWF0ICE9IGJlYXQpIHtcblx0XHRcdFx0dGhpcy5fYmVhdCA9IGJlYXQ7XG5cdFx0XHRcdHRoaXMuX21hcmtlZCA9IHRydWU7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX21hcmtlZCB8fCAodGhpcy5fZXZlbnRzICYmIEltYmEuU2NoZWR1bGVyLmlzRGlydHkoKSkpIHRoaXMuZmx1c2goKTtcblx0XHQvLyByZXNjaGVkdWxlIGlmIEBhY3RpdmVcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U3RhcnQgdGhlIHNjaGVkdWxlciBpZiBpdCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG5cdFx0KipXaGlsZSBhY3RpdmUqKiwgdGhlIHNjaGVkdWxlciB3aWxsIG92ZXJyaWRlIGB0YXJnZXQuY29tbWl0YFxuXHRcdHRvIGRvIG5vdGhpbmcuIEJ5IGRlZmF1bHQgSW1iYS50YWcjY29tbWl0IGNhbGxzIHJlbmRlciwgc29cblx0XHR0aGF0IHJlbmRlcmluZyBpcyBjYXNjYWRlZCB0aHJvdWdoIHRvIGNoaWxkcmVuIHdoZW4gcmVuZGVyaW5nXG5cdFx0YSBub2RlLiBXaGVuIGEgc2NoZWR1bGVyIGlzIGFjdGl2ZSAoZm9yIGEgbm9kZSksIEltYmEgZGlzYWJsZXNcblx0XHR0aGlzIGF1dG9tYXRpYyByZW5kZXJpbmcuXG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXHRcdFx0Ly8gb3ZlcnJpZGUgdGFyZ2V0I2NvbW1pdCB3aGlsZSB0aGlzIGlzIGFjdGl2ZVxuXHRcdFx0dGhpcy5fY29tbWl0ID0gdGhpcy5fdGFyZ2V0LmNvbW1pdDtcblx0XHRcdHRoaXMuX3RhcmdldC5jb21taXQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XHRJbWJhLnNjaGVkdWxlKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMuX2V2ZW50cykgeyBJbWJhLmxpc3RlbihJbWJhLCdldmVudCcsdGhpcywnb25ldmVudCcpIH07XG5cdFx0XHR0aGlzLl90YXJnZXQgJiYgdGhpcy5fdGFyZ2V0LmZsYWcgICYmICB0aGlzLl90YXJnZXQuZmxhZygnc2NoZWR1bGVkXycpO1xuXHRcdFx0dGhpcy50aWNrKDApOyAvLyBzdGFydCB0aWNraW5nXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U3RvcCB0aGUgc2NoZWR1bGVyIGlmIGl0IGlzIGFjdGl2ZS5cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fYWN0aXZlKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3RhcmdldC5jb21taXQgPSB0aGlzLl9jb21taXQ7XG5cdFx0XHRJbWJhLnVuc2NoZWR1bGUodGhpcyk7XG5cdFx0XHRJbWJhLnVubGlzdGVuKEltYmEsJ2V2ZW50Jyx0aGlzKTtcblx0XHRcdHRoaXMuX3RhcmdldCAmJiB0aGlzLl90YXJnZXQudW5mbGFnICAmJiAgdGhpcy5fdGFyZ2V0LnVuZmxhZygnc2NoZWR1bGVkXycpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbWFya2VyO1xuXHR9O1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpe1xuXHRcdHZhciAkMTtcblx0XHRpZiAodGhpcy5fbWFya2VkKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2V2ZW50cyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRpZiAodGhpcy5fZXZlbnRzKGV2ZW50KSkgdGhpcy5tYXJrKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9ldmVudHMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0aWYgKGlkeCQoKCQxID0gZXZlbnQpICYmICQxLnR5cGUgICYmICAkMS50eXBlKCksdGhpcy5fZXZlbnRzKSA+PSAwKSB0aGlzLm1hcmsoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2V2ZW50cykge1xuXHRcdFx0aWYgKGV2ZW50Ll9yZXNwb25kZXIpIHRoaXMubWFyaygpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBJbWJhLlNjaGVkdWxlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9zY2hlZHVsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRJbWJhLnN0YXRpYyA9IGZ1bmN0aW9uIChpdGVtcyxucil7XG5cdFx0aXRlbXMuc3RhdGljID0gbnI7XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9O1xuXHRcblx0Lypcblx0VGhpcyBpcyB0aGUgYmFzZWNsYXNzIHRoYXQgYWxsIHRhZ3MgaW4gaW1iYSBpbmhlcml0IGZyb20uXG5cdEBpbmFtZSBub2RlXG5cdCovXG5cdFxuXHRJbWJhLlRhZyA9IGZ1bmN0aW9uIFRhZyhkb20pe1xuXHRcdHRoaXMuc2V0RG9tKGRvbSk7XG5cdH07XG5cdFxuXHRJbWJhLlRhZy5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhyb3cgXCJOb3QgaW1wbGVtZW50ZWRcIjtcblx0fTtcblx0XG5cdEltYmEuVGFnLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIG5ldyB0aGlzKHRoaXMuY3JlYXRlTm9kZSgpKTtcblx0fTtcblx0XG5cdFxuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLm9iamVjdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb2JqZWN0OyB9XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXRPYmplY3QgPSBmdW5jdGlvbih2KXsgdGhpcy5fb2JqZWN0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZG9tID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RvbTtcblx0fTtcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXREb20gPSBmdW5jdGlvbiAoZG9tKXtcblx0XHRkb20uX3RhZyA9IHRoaXM7XG5cdFx0dGhpcy5fZG9tID0gZG9tO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRTZXR0aW5nIHJlZmVyZW5jZXMgZm9yIHRhZ3MgbGlrZVxuXHRcdGA8ZGl2QGhlYWRlcj5gIHdpbGwgY29tcGlsZSB0byBgdGFnKCdkaXYnKS5zZXRSZWYoJ2hlYWRlcicsdGhpcykuZW5kKClgXG5cdFx0QnkgZGVmYXVsdCBpdCBhZGRzIHRoZSByZWZlcmVuY2UgYXMgYSBjbGFzc05hbWUgdG8gdGhlIHRhZy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0UmVmID0gZnVuY3Rpb24gKHJlZixjdHgpe1xuXHRcdHRoaXMuZmxhZyh0aGlzLl9yZWYgPSByZWYpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRNZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGNvbXBpbGVkIHRhZy1jaGFpbnMsIGZvclxuXHRcdGJpbmRpbmcgZXZlbnRzIG9uIHRhZ3MgdG8gbWV0aG9kcyBldGMuXG5cdFx0YDxhIDp0YXA9Zm4+YCBjb21waWxlcyB0byBgdGFnKCdhJykuc2V0SGFuZGxlcigndGFwJyxmbix0aGlzKS5lbmQoKWBcblx0XHR3aGVyZSB0aGlzIHJlZmVycyB0byB0aGUgY29udGV4dCBpbiB3aGljaCB0aGUgdGFnIGlzIGNyZWF0ZWQuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNldEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQsaGFuZGxlcixjdHgpe1xuXHRcdHZhciBrZXkgPSAnb24nICsgZXZlbnQ7XG5cdFx0XG5cdFx0aWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0dGhpc1trZXldID0gaGFuZGxlcjtcblx0XHR9IGVsc2UgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dmFyIGZuID0gaGFuZGxlci5zaGlmdCgpO1xuXHRcdFx0dGhpc1trZXldID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gY3R4W2ZuXS5hcHBseShjdHgsaGFuZGxlci5jb25jYXQoZSkpOyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW2tleV0gPSBmdW5jdGlvbihlKSB7IHJldHVybiBjdHhbaGFuZGxlcl0oZSk7IH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIChpZCl7XG5cdFx0dGhpcy5kb20oKS5pZCA9IGlkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZG9tKCkuaWQ7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEFkZHMgYSBuZXcgYXR0cmlidXRlIG9yIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGFuIGV4aXN0aW5nIGF0dHJpYnV0ZVxuXHRcdG9uIHRoZSBzcGVjaWZpZWQgdGFnLiBJZiB0aGUgdmFsdWUgaXMgbnVsbCBvciBmYWxzZSwgdGhlIGF0dHJpYnV0ZVxuXHRcdHdpbGwgYmUgcmVtb3ZlZC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsdmFsdWUpe1xuXHRcdC8vIHNob3VsZCB0aGlzIG5vdCByZXR1cm4gc2VsZj9cblx0XHR2YXIgb2xkID0gdGhpcy5kb20oKS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XG5cdFx0aWYgKG9sZCA9PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnNldEF0dHJpYnV0ZShuYW1lLHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvKlxuXHRcdHJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIHNwZWNpZmllZCB0YWdcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5kb20oKS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdHJldHVybnMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgdGFnLlxuXHRcdElmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZG9lcyBub3QgZXhpc3QsIHRoZSB2YWx1ZSByZXR1cm5lZFxuXHRcdHdpbGwgZWl0aGVyIGJlIG51bGwgb3IgXCJcIiAodGhlIGVtcHR5IHN0cmluZylcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5kb20oKS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdE92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZSBzcGVjaWFsIHdyYXBwaW5nIGV0Yy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50LHR5cGUpe1xuXHRcdHRoaXMuc2V0Q2hpbGRyZW4oY29udGVudCx0eXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U2V0IHRoZSBjaGlsZHJlbiBvZiBub2RlLiB0eXBlIHBhcmFtIGlzIG9wdGlvbmFsLFxuXHRcdGFuZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IEltYmEgd2hlbiBjb21waWxpbmcgdGFnIHRyZWVzLiBcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZXMsdHlwZSl7XG5cdFx0dGhyb3cgXCJOb3QgaW1wbGVtZW50ZWRcIjtcblx0fTtcblx0XG5cdC8qXG5cdFx0R2V0IHRleHQgb2Ygbm9kZS4gVXNlcyB0ZXh0Q29udGVudCBiZWhpbmQgdGhlIHNjZW5lcyAobm90IGlubmVyVGV4dClcblx0XHRbaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvdGV4dENvbnRlbnRdKClcblx0XHRAcmV0dXJuIHtzdHJpbmd9IGlubmVyIHRleHQgb2Ygbm9kZVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICh2KXtcblx0XHRyZXR1cm4gdGhpcy5fZG9tLnRleHRDb250ZW50O1xuXHR9O1xuXHRcblx0Lypcblx0XHRTZXQgdGV4dCBvZiBub2RlLiBVc2VzIHRleHRDb250ZW50IGJlaGluZCB0aGUgc2NlbmVzIChub3QgaW5uZXJUZXh0KVxuXHRcdFtodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS90ZXh0Q29udGVudF0oKVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0eHQpe1xuXHRcdHRoaXMuX2VtcHR5ID0gZmFsc2U7XG5cdFx0dGhpcy5fZG9tLnRleHRDb250ZW50ID0gdHh0ID09IG51bGwgPyAodHh0ID0gXCJcIikgOiAodHh0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHQvKlxuXHRcdE1ldGhvZCBmb3IgZ2V0dGluZyBhbmQgc2V0dGluZyBkYXRhLWF0dHJpYnV0ZXMuIFdoZW4gY2FsbGVkIHdpdGggemVyb1xuXHRcdGFyZ3VtZW50cyBpdCB3aWxsIHJldHVybiB0aGUgYWN0dWFsIGRhdGFzZXQgZm9yIHRoZSB0YWcuXG5cdFxuXHRcdFx0dmFyIG5vZGUgPSA8ZGl2IGRhdGEtbmFtZT0naGVsbG8nPlxuXHRcdFx0IyBnZXQgdGhlIHdob2xlIGRhdGFzZXRcblx0XHRcdG5vZGUuZGF0YXNldCAjIHtuYW1lOiAnaGVsbG8nfVxuXHRcdFx0IyBnZXQgYSBzaW5nbGUgdmFsdWVcblx0XHRcdG5vZGUuZGF0YXNldCgnbmFtZScpICMgJ2hlbGxvJ1xuXHRcdFx0IyBzZXQgYSBzaW5nbGUgdmFsdWVcblx0XHRcdG5vZGUuZGF0YXNldCgnbmFtZScsJ25ld25hbWUnKSAjIHNlbGZcblx0XG5cdFxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZGF0YXNldCA9IGZ1bmN0aW9uIChrZXksdmFsKXtcblx0XHR0aHJvdyBcIk5vdCBpbXBsZW1lbnRlZFwiO1xuXHR9O1xuXHRcblx0Lypcblx0XHRFbXB0eSBwbGFjZWhvbGRlci4gT3ZlcnJpZGUgdG8gaW1wbGVtZW50IGN1c3RvbSByZW5kZXIgYmVoYXZpb3VyLlxuXHRcdFdvcmtzIG11Y2ggbGlrZSB0aGUgZmFtaWxpYXIgcmVuZGVyLW1ldGhvZCBpbiBSZWFjdC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENhbGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggSW1iYS5UYWcjZW5kLCB1cG9uIGNyZWF0aW5nIGEgdGFnLiBBbGxcblx0XHRwcm9wZXJ0aWVzIHdpbGwgaGF2ZSBiZWVuIHNldCBiZWZvcmUgYnVpbGQgaXMgY2FsbGVkLCBpbmNsdWRpbmdcblx0XHRzZXRDb250ZW50LlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENhbGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggSW1iYS5UYWcjZW5kLCBmb3IgdGFncyB0aGF0IGFyZSBwYXJ0IG9mXG5cdFx0YSB0YWcgdHJlZSAodGhhdCBhcmUgcmVuZGVyZWQgc2V2ZXJhbCB0aW1lcykuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0XHRDYWxsZWQgYnkgdGhlIHRhZy1zY2hlZHVsZXIgKGlmIHRoaXMgdGFnIGlzIHNjaGVkdWxlZClcblx0XHRCeSBkZWZhdWx0IGl0IHdpbGwgY2FsbCB0aGlzLnJlbmRlci4gRG8gbm90IG92ZXJyaWRlIHVubGVzc1xuXHRcdHlvdSByZWFsbHkgdW5kZXJzdGFuZCBpdC5cblx0XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0XG5cdFx0QSB2ZXJ5IGltcG9ydGFudCBtZXRob2QgdGhhdCB5b3Ugd2lsbCBwcmFjdGljYWxseSBuZXZlciBtYW51YWxseS5cblx0XHRUaGUgdGFnIHN5bnRheCBvZiBJbWJhIGNvbXBpbGVzIHRvIGEgY2hhaW4gb2Ygc2V0dGVycywgd2hpY2ggYWx3YXlzXG5cdFx0ZW5kcyB3aXRoIC5lbmQuIGA8YS5sYXJnZT5gIGNvbXBpbGVzIHRvIGB0YWcoJ2EnKS5mbGFnKCdsYXJnZScpLmVuZCgpYFxuXHRcdFxuXHRcdFlvdSBhcmUgaGlnaGx5IGFkdmljZWQgdG8gbm90IG92ZXJyaWRlIGl0cyBiZWhhdmlvdXIuIFRoZSBmaXJzdCB0aW1lXG5cdFx0ZW5kIGlzIGNhbGxlZCBpdCB3aWxsIG1hcmsgdGhlIHRhZyBhcyBidWlsdCBhbmQgY2FsbCBJbWJhLlRhZyNidWlsZCxcblx0XHRhbmQgY2FsbCBJbWJhLlRhZyNjb21taXQgb24gc3Vic2VxdWVudCBjYWxscy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2J1aWx0KSB7XG5cdFx0XHR0aGlzLmNvbW1pdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9idWlsdCA9IHRydWU7XG5cdFx0XHR0aGlzLmJ1aWxkKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhpcyBpcyBjYWxsZWQgaW5zdGVhZCBvZiBJbWJhLlRhZyNlbmQgZm9yIGA8c2VsZj5gIHRhZyBjaGFpbnMuXG5cdFx0RGVmYXVsdHMgdG8gbm9vcFxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zeW5jZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIGNhbGxlZCB3aGVuIHRoZSBub2RlIGlzIGF3YWtlbmVkIGluIHRoZSBkb20gLSBlaXRoZXIgYXV0b21hdGljYWxseVxuXHQvLyB1cG9uIGF0dGFjaG1lbnQgdG8gdGhlIGRvbS10cmVlLCBvciB0aGUgZmlyc3QgdGltZSBpbWJhIG5lZWRzIHRoZVxuXHQvLyB0YWcgZm9yIGEgZG9tbm9kZSB0aGF0IGhhcyBiZWVuIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXJcblx0SW1iYS5UYWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRMaXN0IG9mIGZsYWdzIGZvciB0aGlzIG5vZGUuIFxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZmxhZ3MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZG9tLmNsYXNzTGlzdDtcblx0fTtcblx0XG5cdC8qXG5cdFx0QWRkIHNwZWZpY2llZCBmbGFnIHRvIGN1cnJlbnQgbm9kZS5cblx0XHRJZiBhIHNlY29uZCBhcmd1bWVudCBpcyBzdXBwbGllZCwgaXQgd2lsbCBiZSBjb2VyY2VkIGludG8gYSBCb29sZWFuLFxuXHRcdGFuZCB1c2VkIHRvIGluZGljYXRlIHdoZXRoZXIgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgZmxhZyBpbnN0ZWFkLlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5mbGFnID0gZnVuY3Rpb24gKG5hbWUsdG9nZ2xlcil7XG5cdFx0Ly8gaXQgaXMgbW9zdCBuYXR1cmFsIHRvIHRyZWF0IGEgc2Vjb25kIHVuZGVmaW5lZCBhcmd1bWVudCBhcyBhIG5vLXN3aXRjaFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGFyZ3VtZW50cy1sZW5ndGhcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmICF0b2dnbGVyKSB7XG5cdFx0XHR0aGlzLl9kb20uY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC5hZGQobmFtZSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0UmVtb3ZlIHNwZWNpZmllZCBmbGFnIGZyb20gbm9kZVxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS51bmZsYWcgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFRvZ2dsZSBzcGVjaWZpZWQgZmxhZyBvbiBub2RlXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnRvZ2dsZUZsYWcgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC50b2dnbGUobmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENoZWNrIHdoZXRoZXIgY3VycmVudCBub2RlIGhhcyBzcGVjaWZpZWQgZmxhZ1xuXHRcdEByZXR1cm4ge2Jvb2x9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5oYXNGbGFnID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHJldHVybiB0aGlzLl9kb20uY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRHZXQgdGhlIHNjaGVkdWxlciBmb3IgdGhpcyBub2RlLiBBIG5ldyBzY2hlZHVsZXIgd2lsbCBiZSBjcmVhdGVkXG5cdFx0aWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cblx0XG5cdFx0QHJldHVybiB7SW1iYS5TY2hlZHVsZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zY2hlZHVsZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVyID09IG51bGwgPyAodGhpcy5fc2NoZWR1bGVyID0gbmV3IEltYmEuU2NoZWR1bGVyKHRoaXMpKSA6ICh0aGlzLl9zY2hlZHVsZXIpO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdFx0U2hvcnRoYW5kIHRvIHN0YXJ0IHNjaGVkdWxpbmcgYSBub2RlLiBUaGUgbWV0aG9kIHdpbGwgYmFzaWNhbGx5XG5cdFx0cHJveHkgdGhlIGFyZ3VtZW50cyB0aHJvdWdoIHRvIHNjaGVkdWxlci5jb25maWd1cmUsIGFuZCB0aGVuXG5cdFx0YWN0aXZhdGUgdGhlIHNjaGVkdWxlci5cblx0XHRcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAob3B0aW9ucyl7XG5cdFx0aWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG5cdFx0dGhpcy5zY2hlZHVsZXIoKS5jb25maWd1cmUob3B0aW9ucykuYWN0aXZhdGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U2hvcnRoYW5kIGZvciBkZWFjdGl2YXRpbmcgc2NoZWR1bGVyIChpZiB0YWcgaGFzIG9uZSkuXG5cdFx0QGRlcHJlY2F0ZWRcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnVuc2NoZWR1bGUgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fc2NoZWR1bGVyKSB7IHRoaXMuc2NoZWR1bGVyKCkuZGVhY3RpdmF0ZSgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Lypcblx0XHRHZXQgdGhlIHBhcmVudCBvZiBjdXJyZW50IG5vZGVcblx0XHRAcmV0dXJuIHtJbWJhLlRhZ30gXG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJHdyYXAodGhpcy5kb20oKS5wYXJlbnROb2RlKTtcblx0fTtcblx0XG5cdC8qXG5cdFx0U2hvcnRoYW5kIGZvciBjb25zb2xlLmxvZyBvbiBlbGVtZW50c1xuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgJDAgPSBhcmd1bWVudHMsIGkgPSAkMC5sZW5ndGg7XG5cdFx0dmFyIGFyZ3MgPSBuZXcgQXJyYXkoaT4wID8gaSA6IDApO1xuXHRcdHdoaWxlKGk+MCkgYXJnc1tpLTFdID0gJDBbLS1pXTtcblx0XHRhcmdzLnVuc2hpZnQoY29uc29sZSk7XG5cdFx0RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYXBwbHkoY29uc29sZS5sb2csYXJncyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmluaXRpYWxpemUgPSBJbWJhLlRhZztcblx0XG5cdEhUTUxfVEFHUyA9IFwiYSBhYmJyIGFkZHJlc3MgYXJlYSBhcnRpY2xlIGFzaWRlIGF1ZGlvIGIgYmFzZSBiZGkgYmRvIGJpZyBibG9ja3F1b3RlIGJvZHkgYnIgYnV0dG9uIGNhbnZhcyBjYXB0aW9uIGNpdGUgY29kZSBjb2wgY29sZ3JvdXAgZGF0YSBkYXRhbGlzdCBkZCBkZWwgZGV0YWlscyBkZm4gZGl2IGRsIGR0IGVtIGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWQgaGVhZGVyIGhyIGh0bWwgaSBpZnJhbWUgaW1nIGlucHV0IGlucyBrYmQga2V5Z2VuIGxhYmVsIGxlZ2VuZCBsaSBsaW5rIG1haW4gbWFwIG1hcmsgbWVudSBtZW51aXRlbSBtZXRhIG1ldGVyIG5hdiBub3NjcmlwdCBvYmplY3Qgb2wgb3B0Z3JvdXAgb3B0aW9uIG91dHB1dCBwIHBhcmFtIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzbWFsbCBzb3VyY2Ugc3BhbiBzdHJvbmcgc3R5bGUgc3ViIHN1bW1hcnkgc3VwIHRhYmxlIHRib2R5IHRkIHRleHRhcmVhIHRmb290IHRoIHRoZWFkIHRpbWUgdGl0bGUgdHIgdHJhY2sgdSB1bCB2YXIgdmlkZW8gd2JyXCIuc3BsaXQoXCIgXCIpO1xuXHRIVE1MX1RBR1NfVU5TQUZFID0gXCJhcnRpY2xlIGFzaWRlIGhlYWRlciBzZWN0aW9uXCIuc3BsaXQoXCIgXCIpO1xuXHRTVkdfVEFHUyA9IFwiY2lyY2xlIGRlZnMgZWxsaXBzZSBnIGxpbmUgbGluZWFyR3JhZGllbnQgbWFzayBwYXRoIHBhdHRlcm4gcG9seWdvbiBwb2x5bGluZSByYWRpYWxHcmFkaWVudCByZWN0IHN0b3Agc3ZnIHRleHQgdHNwYW5cIi5zcGxpdChcIiBcIik7XG5cdFxuXHRcblx0ZnVuY3Rpb24gZXh0ZW5kZXIob2JqLHN1cCl7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhzdXApLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0b2JqWygkMSA9IGtleXNbaV0pXSA9PSBudWxsID8gKG9ialskMV0gPSBzdXBba2V5c1tpXV0pIDogKG9ialskMV0pO1xuXHRcdH07XG5cdFx0XG5cdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHRcdGlmIChzdXAuaW5oZXJpdCkgeyBzdXAuaW5oZXJpdChvYmopIH07XG5cdFx0cmV0dXJuIG9iajtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFRhZygpe1xuXHRcdHJldHVybiBmdW5jdGlvbihkb20pIHtcblx0XHRcdHRoaXMuc2V0RG9tKGRvbSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gVGFnU3Bhd25lcih0eXBlKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlLmJ1aWxkKCk7IH07XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MgPSBmdW5jdGlvbiBUYWdzKCl7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdEltYmEuVGFncy5wcm90b3R5cGUuX19jbG9uZSA9IGZ1bmN0aW9uIChucyl7XG5cdFx0dmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcblx0XHRjbG9uZS5fcGFyZW50ID0gdGhpcztcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZU5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHR2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuXHRcdGNsb25lLl9wYXJlbnQgPSB0aGlzO1xuXHRcdGNsb25lLl9ucyA9IG5hbWU7XG5cdFx0dGhpc1tuYW1lLnRvVXBwZXJDYXNlKCldID0gY2xvbmU7XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9O1xuXHRcblx0SW1iYS5UYWdzLnByb3RvdHlwZS5iYXNlVHlwZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gaWR4JChuYW1lLEhUTUxfVEFHUykgPj0gMCA/ICgnaHRtbGVsZW1lbnQnKSA6ICgnZGl2Jyk7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZVRhZyA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0aWYoYm9keT09dW5kZWZpbmVkICYmIHR5cGVvZiBzdXByID09ICdmdW5jdGlvbicpIGJvZHkgPSBzdXByLHN1cHIgPSAnJztcblx0XHRpZihzdXByPT11bmRlZmluZWQpIHN1cHIgPSAnJztcblx0XHRzdXByIHx8IChzdXByID0gdGhpcy5iYXNlVHlwZShuYW1lKSk7XG5cdFx0dmFyIHN1cGVydHlwZSA9IHRoaXNbc3Vwcl07XG5cdFx0dmFyIHRhZ3R5cGUgPSBUYWcoKTtcblx0XHR2YXIgbm9ybSA9IG5hbWUucmVwbGFjZSgvXFwtL2csJ18nKTtcblx0XHRcblx0XHRcblx0XHR0YWd0eXBlLl9uYW1lID0gbmFtZTtcblx0XHRleHRlbmRlcih0YWd0eXBlLHN1cGVydHlwZSk7XG5cdFx0XG5cdFx0aWYgKG5hbWVbMF0gPT0gJyMnKSB7XG5cdFx0XHR0aGlzW25hbWVdID0gdGFndHlwZTtcblx0XHRcdEltYmEuU0lOR0xFVE9OU1tuYW1lLnNsaWNlKDEpXSA9IHRhZ3R5cGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB0YWd0eXBlO1xuXHRcdFx0dGhpc1snJCcgKyBub3JtXSA9IFRhZ1NwYXduZXIodGFndHlwZSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoYm9keSkge1xuXHRcdFx0aWYgKGJvZHkubGVuZ3RoID09IDIpIHtcblx0XHRcdFx0Ly8gY3JlYXRlIGNsb25lXG5cdFx0XHRcdGlmICghdGFndHlwZS5oYXNPd25Qcm9wZXJ0eSgnVEFHUycpKSB7XG5cdFx0XHRcdFx0dGFndHlwZS5UQUdTID0gKHN1cGVydHlwZS5UQUdTIHx8IHRoaXMpLl9fY2xvbmUoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGJvZHkuY2FsbCh0YWd0eXBlLHRhZ3R5cGUsdGFndHlwZS5UQUdTIHx8IHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRhZ3R5cGU7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0cmV0dXJuIHRoaXMuZGVmaW5lVGFnKG5hbWUsc3Vwcixib2R5KTtcblx0fTtcblx0XG5cdEltYmEuVGFncy5wcm90b3R5cGUuZXh0ZW5kVGFnID0gZnVuY3Rpb24gKG5hbWUsc3Vwcixib2R5KXtcblx0XHRpZihib2R5PT11bmRlZmluZWQgJiYgdHlwZW9mIHN1cHIgPT0gJ2Z1bmN0aW9uJykgYm9keSA9IHN1cHIsc3VwciA9ICcnO1xuXHRcdGlmKHN1cHI9PXVuZGVmaW5lZCkgc3VwciA9ICcnO1xuXHRcdHZhciBrbGFzcyA9ICgodHlwZW9mIG5hbWU9PSdzdHJpbmcnfHxuYW1lIGluc3RhbmNlb2YgU3RyaW5nKSA/ICh0aGlzW25hbWVdKSA6IChuYW1lKSk7XG5cdFx0Ly8gYWxsb3cgZm9yIHByaXZhdGUgdGFncyBoZXJlIGFzIHdlbGw/XG5cdFx0aWYgKGJvZHkpIHsgYm9keSAmJiBib2R5LmNhbGwoa2xhc3Msa2xhc3Msa2xhc3MucHJvdG90eXBlKSB9O1xuXHRcdHJldHVybiBrbGFzcztcblx0fTtcblx0XG5cdFxuXHRJbWJhLlRBR1MgPSBuZXcgSW1iYS5UYWdzKCk7XG5cdEltYmEuVEFHUy5lbGVtZW50ID0gSW1iYS5UYWc7XG5cdFxuXHR2YXIgc3ZnID0gSW1iYS5UQUdTLmRlZmluZU5hbWVzcGFjZSgnc3ZnJyk7XG5cdFxuXHRzdmcuYmFzZVR5cGUgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0cmV0dXJuICdzdmdlbGVtZW50Jztcblx0fTtcblx0XG5cdFxuXHRJbWJhLlNJTkdMRVRPTlMgPSB7fTtcblx0XG5cdFxuXHRJbWJhLmRlZmluZVRhZyA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0aWYoYm9keT09dW5kZWZpbmVkICYmIHR5cGVvZiBzdXByID09ICdmdW5jdGlvbicpIGJvZHkgPSBzdXByLHN1cHIgPSAnJztcblx0XHRpZihzdXByPT11bmRlZmluZWQpIHN1cHIgPSAnJztcblx0XHRyZXR1cm4gSW1iYS5UQUdTLmRlZmluZVRhZyhuYW1lLHN1cHIsYm9keSk7XG5cdH07XG5cdFxuXHRJbWJhLmRlZmluZVNpbmdsZXRvblRhZyA9IGZ1bmN0aW9uIChpZCxzdXByLGJvZHkpe1xuXHRcdGlmKGJvZHk9PXVuZGVmaW5lZCAmJiB0eXBlb2Ygc3VwciA9PSAnZnVuY3Rpb24nKSBib2R5ID0gc3VwcixzdXByID0gJ2Rpdic7XG5cdFx0aWYoc3Vwcj09dW5kZWZpbmVkKSBzdXByID0gJ2Rpdic7XG5cdFx0cmV0dXJuIEltYmEuVEFHUy5kZWZpbmVUYWcodGhpcy5uYW1lKCksc3Vwcixib2R5KTtcblx0fTtcblx0XG5cdEltYmEuZXh0ZW5kVGFnID0gZnVuY3Rpb24gKG5hbWUsYm9keSl7XG5cdFx0cmV0dXJuIEltYmEuVEFHUy5leHRlbmRUYWcobmFtZSxib2R5KTtcblx0fTtcblx0XG5cdEltYmEudGFnID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHZhciB0eXAgPSBJbWJhLlRBR1NbbmFtZV07XG5cdFx0aWYgKCF0eXApIHsgdGhyb3cgbmV3IEVycm9yKChcInRhZyBcIiArIG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSkgfTtcblx0XHRyZXR1cm4gbmV3IHR5cCh0eXAuY3JlYXRlTm9kZSgpKTtcblx0fTtcblx0XG5cdEltYmEudGFnV2l0aElkID0gZnVuY3Rpb24gKG5hbWUsaWQpe1xuXHRcdHZhciB0eXAgPSBJbWJhLlRBR1NbbmFtZV07XG5cdFx0aWYgKCF0eXApIHsgdGhyb3cgbmV3IEVycm9yKChcInRhZyBcIiArIG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSkgfTtcblx0XHR2YXIgZG9tID0gdHlwLmNyZWF0ZU5vZGUoKTtcblx0XHRkb20uaWQgPSBpZDtcblx0XHRyZXR1cm4gbmV3IHR5cChkb20pO1xuXHR9O1xuXHRcblx0Ly8gVE9ETzogQ2FuIHdlIG1vdmUgdGhlc2Ugb3V0IGFuZCBpbnRvIGRvbS5pbWJhIGluIGEgY2xlYW4gd2F5P1xuXHQvLyBUaGVzZSBtZXRob2RzIGRlcGVuZHMgb24gSW1iYS5kb2N1bWVudC5nZXRFbGVtZW50QnlJZFxuXHRcblx0SW1iYS5nZXRUYWdTaW5nbGV0b24gPSBmdW5jdGlvbiAoaWQpe1xuXHRcdHZhciBrbGFzcztcblx0XHR2YXIgZG9tLG5vZGU7XG5cdFx0XG5cdFx0aWYgKGtsYXNzID0gSW1iYS5TSU5HTEVUT05TW2lkXSkge1xuXHRcdFx0aWYgKGtsYXNzICYmIGtsYXNzLkluc3RhbmNlKSB7IHJldHVybiBrbGFzcy5JbnN0YW5jZSB9O1xuXHRcdFx0XG5cdFx0XHQvLyBubyBpbnN0YW5jZSAtIGNoZWNrIGZvciBlbGVtZW50XG5cdFx0XHRpZiAoZG9tID0gSW1iYS5kb2N1bWVudCgpLmdldEVsZW1lbnRCeUlkKGlkKSkge1xuXHRcdFx0XHQvLyB3ZSBoYXZlIGEgbGl2ZSBpbnN0YW5jZSAtIHdoZW4gZmluZGluZyBpdCB0aHJvdWdoIGEgc2VsZWN0b3Igd2Ugc2hvdWxkIGF3YWtlIGl0LCBubz9cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2NyZWF0aW5nIHRoZSBzaW5nbGV0b24gZnJvbSBleGlzdGluZyBub2RlIGluIGRvbT8nLGlkLHR5cGUpXG5cdFx0XHRcdG5vZGUgPSBrbGFzcy5JbnN0YW5jZSA9IG5ldyBrbGFzcyhkb20pO1xuXHRcdFx0XHRub2RlLmF3YWtlbihkb20pOyAvLyBzaG91bGQgb25seSBhd2FrZW5cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRkb20gPSBrbGFzcy5jcmVhdGVOb2RlKCk7XG5cdFx0XHRkb20uaWQgPSBpZDtcblx0XHRcdG5vZGUgPSBrbGFzcy5JbnN0YW5jZSA9IG5ldyBrbGFzcyhkb20pO1xuXHRcdFx0bm9kZS5lbmQoKS5hd2FrZW4oZG9tKTtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH0gZWxzZSBpZiAoZG9tID0gSW1iYS5kb2N1bWVudCgpLmdldEVsZW1lbnRCeUlkKGlkKSkge1xuXHRcdFx0cmV0dXJuIEltYmEuZ2V0VGFnRm9yRG9tKGRvbSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdHZhciBzdmdTdXBwb3J0ID0gdHlwZW9mIFNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXHRcblx0SW1iYS5nZXRUYWdGb3JEb20gPSBmdW5jdGlvbiAoZG9tKXtcblx0XHR2YXIgbTtcblx0XHRpZiAoIWRvbSkgeyByZXR1cm4gbnVsbCB9O1xuXHRcdGlmIChkb20uX2RvbSkgeyByZXR1cm4gZG9tIH07IC8vIGNvdWxkIHVzZSBpbmhlcml0YW5jZSBpbnN0ZWFkXG5cdFx0aWYgKGRvbS5fdGFnKSB7IHJldHVybiBkb20uX3RhZyB9O1xuXHRcdGlmICghZG9tLm5vZGVOYW1lKSB7IHJldHVybiBudWxsIH07XG5cdFx0XG5cdFx0dmFyIG5zID0gbnVsbDtcblx0XHR2YXIgaWQgPSBkb20uaWQ7XG5cdFx0dmFyIHR5cGUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHR2YXIgdGFncyA9IEltYmEuVEFHUztcblx0XHR2YXIgbmF0aXZlJCA9IHR5cGU7XG5cdFx0dmFyIGNscyA9IGRvbS5jbGFzc05hbWU7XG5cdFx0XG5cdFx0aWYgKGlkICYmIEltYmEuU0lOR0xFVE9OU1tpZF0pIHtcblx0XHRcdC8vIEZJWE1FIGNvbnRyb2wgdGhhdCBpdCBpcyB0aGUgc2FtZSBzaW5nbGV0b24/XG5cdFx0XHQvLyBtaWdodCBjb2xsaWRlIC0tIG5vdCBnb29kP1xuXHRcdFx0cmV0dXJuIEltYmEuZ2V0VGFnU2luZ2xldG9uKGlkKTtcblx0XHR9O1xuXHRcdC8vIGxvb2sgZm9yIGlkIC0gc2luZ2xldG9uXG5cdFx0XG5cdFx0Ly8gbmVlZCBiZXR0ZXIgdGVzdCBoZXJlXG5cdFx0aWYgKHN2Z1N1cHBvcnQgJiYgKGRvbSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB7XG5cdFx0XHRucyA9IFwic3ZnXCI7XG5cdFx0XHRjbHMgPSBkb20uY2xhc3NOYW1lLmJhc2VWYWw7XG5cdFx0XHR0YWdzID0gdGFncy5TVkc7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc3Bhd25lcjtcblx0XHRcblx0XHRpZiAoY2xzKSB7XG5cdFx0XHQvLyB0aGVyZSBjYW4gYmUgc2V2ZXJhbCBtYXRjaGVzIGhlcmUgLSBzaG91bGQgY2hvb3NlIHRoZSBsYXN0XG5cdFx0XHQvLyBzaG91bGQgZmFsbCBiYWNrIHRvIGxlc3Mgc3BlY2lmaWMgbGF0ZXI/IC0gb3RoZXJ3aXNlIHRoaW5ncyBtYXkgZmFpbFxuXHRcdFx0Ly8gVE9ETyByZXdvcmsgdGhpc1xuXHRcdFx0aWYgKG0gPSBjbHMubWF0Y2goL1xcYl8oW2EtelxcLV0rKVxcYig/IVxccypfW2EtelxcLV0rKS8pKSB7XG5cdFx0XHRcdHR5cGUgPSBtWzFdOyAvLyAucmVwbGFjZSgvLS9nLCdfJylcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChtID0gY2xzLm1hdGNoKC9cXGIoW0EtWlxcLV0rKV9cXGIvKSkge1xuXHRcdFx0XHRucyA9IG1bMV07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0c3Bhd25lciA9IHRhZ3NbdHlwZV0gfHwgdGFnc1tuYXRpdmUkXTtcblx0XHRyZXR1cm4gc3Bhd25lciA/IChuZXcgc3Bhd25lcihkb20pLmF3YWtlbihkb20pKSA6IChudWxsKTtcblx0fTtcblx0XG5cdHRhZyQgPSBJbWJhLlRBR1M7XG5cdHQkID0gSW1iYS50YWc7XG5cdHRjJCA9IEltYmEudGFnV2l0aEZsYWdzO1xuXHR0aSQgPSBJbWJhLnRhZ1dpdGhJZDtcblx0dGljJCA9IEltYmEudGFnV2l0aElkQW5kRmxhZ3M7XG5cdGlkJCA9IEltYmEuZ2V0VGFnU2luZ2xldG9uO1xuXHRyZXR1cm4gdGFnJHdyYXAgPSBJbWJhLmdldFRhZ0ZvckRvbTtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvdGFnLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHRJbWJhLmRvY3VtZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcblx0fTtcblx0XG5cdC8qXG5cdFJldHVybnMgdGhlIGJvZHkgZWxlbWVudCB3cmFwcGVkIGluIGFuIEltYmEuVGFnXG5cdCovXG5cdFxuXHRJbWJhLnJvb3QgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJHdyYXAoSW1iYS5kb2N1bWVudCgpLmJvZHkpO1xuXHR9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2h0bWxlbGVtZW50JywgJ2VsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRDYWxsZWQgd2hlbiBhIHRhZyB0eXBlIGlzIGJlaW5nIHN1YmNsYXNzZWQuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5pbmhlcml0ID0gZnVuY3Rpb24gKGNoaWxkKXtcblx0XHRcdGNoaWxkLnByb3RvdHlwZS5fZW1wdHkgPSB0cnVlO1xuXHRcdFx0Y2hpbGQuX3Byb3RvRG9tID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX25vZGVUeXBlKSB7XG5cdFx0XHRcdGNoaWxkLl9ub2RlVHlwZSA9IHRoaXMuX25vZGVUeXBlO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9IFwiX1wiICsgY2hpbGQuX25hbWUucmVwbGFjZSgvXy9nLCctJyk7XG5cdFx0XHRcdGlmIChjaGlsZC5fbmFtZVswXSAhPSAnIycpIHsgcmV0dXJuIGNoaWxkLl9jbGFzc2VzID0gdGhpcy5fY2xhc3Nlcy5jb25jYXQoY2xhc3NOYW1lKSB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25vZGVUeXBlID0gY2hpbGQuX25hbWU7XG5cdFx0XHRcdHJldHVybiBjaGlsZC5fY2xhc3NlcyA9IFtdO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5idWlsZE5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBkb20gPSBJbWJhLmRvY3VtZW50KCkuY3JlYXRlRWxlbWVudCh0aGlzLl9ub2RlVHlwZSk7XG5cdFx0XHR2YXIgY2xzID0gdGhpcy5fY2xhc3Nlcy5qb2luKFwiIFwiKTtcblx0XHRcdGlmIChjbHMpIHsgZG9tLmNsYXNzTmFtZSA9IGNscyB9O1xuXHRcdFx0cmV0dXJuIGRvbTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcHJvdG8gPSAodGhpcy5fcHJvdG9Eb20gfHwgKHRoaXMuX3Byb3RvRG9tID0gdGhpcy5idWlsZE5vZGUoKSkpO1xuXHRcdFx0cmV0dXJuIHByb3RvLmNsb25lTm9kZShmYWxzZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcuZG9tID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcHJvdG9Eb20gfHwgKHRoaXMuX3Byb3RvRG9tID0gdGhpcy5idWlsZE5vZGUoKSk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2lkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50YWJpbmRleCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFRhYmluZGV4ID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGl0bGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0aXRsZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndGl0bGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvbGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyb2xlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvbGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLm9mZnNldFdpZHRoO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kb20ub2Zmc2V0SGVpZ2h0O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2Rlcyx0eXBlKXtcblx0XHRcdHRoaXMuX2VtcHR5ID8gKHRoaXMuYXBwZW5kKG5vZGVzKSkgOiAodGhpcy5lbXB0eSgpLmFwcGVuZChub2RlcykpO1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4gPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0U2V0IGlubmVyIGh0bWwgb2Ygbm9kZVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldEh0bWwgPSBmdW5jdGlvbiAoaHRtbCl7XG5cdFx0XHR0aGlzLl9kb20uaW5uZXJIVE1MID0gaHRtbDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCBpbm5lciBodG1sIG9mIG5vZGVcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLmlubmVySFRNTDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgYWxsIGNvbnRlbnQgaW5zaWRlIG5vZGVcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0d2hpbGUgKHRoaXMuX2RvbS5maXJzdENoaWxkKXtcblx0XHRcdFx0dGhpcy5fZG9tLnJlbW92ZUNoaWxkKHRoaXMuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG5cdFx0XHR0aGlzLl9lbXB0eSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgc3BlY2lmaWVkIGNoaWxkIGZyb20gY3VycmVudCBub2RlLlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChjaGlsZCl7XG5cdFx0XHR2YXIgcGFyID0gdGhpcy5kb20oKTtcblx0XHRcdHZhciBlbCA9IGNoaWxkICYmIGNoaWxkLmRvbSgpO1xuXHRcdFx0aWYgKGVsICYmIGVsLnBhcmVudE5vZGUgPT0gcGFyKSB7IHBhci5yZW1vdmVDaGlsZChlbCkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKG5hbWUscGFycyl7XG5cdFx0XHRpZighcGFyc3x8cGFycy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSBwYXJzID0ge307XG5cdFx0XHR2YXIgZGF0YSA9IHBhcnMuZGF0YSAhPT0gdW5kZWZpbmVkID8gcGFycy5kYXRhIDogbnVsbDtcblx0XHRcdHZhciBidWJibGUgPSBwYXJzLmJ1YmJsZSAhPT0gdW5kZWZpbmVkID8gcGFycy5idWJibGUgOiB0cnVlO1xuXHRcdFx0SW1iYS5FdmVudHMudHJpZ2dlcihuYW1lLHRoaXMse2RhdGE6IGRhdGEsYnViYmxlOiBidWJibGV9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0XHRpZiAoa2V5IGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoa2V5KSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHR0aGlzLmNzcyhrZXlzW2ldLGtleVtrZXlzW2ldXSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHZhbCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0XHRcdH0gZWxzZSBpZiAodmFsID09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5zdHlsZVtrZXldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCh0eXBlb2YgdmFsPT0nbnVtYmVyJ3x8dmFsIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBrZXkubWF0Y2goL3dpZHRofGhlaWdodHxsZWZ0fHJpZ2h0fHRvcHxib3R0b20vKSkge1xuXHRcdFx0XHRcdHZhbCA9IHZhbCArIFwicHhcIjtcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5kb20oKS5zdHlsZVtrZXldID0gdmFsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kYXRhc2V0ID0gZnVuY3Rpb24gKGtleSx2YWwpe1xuXHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGtleSksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dGhpcy5kYXRhc2V0KGtleXNbaV0sa2V5W2tleXNbaV1dKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKChcImRhdGEtXCIgKyBrZXkpLHZhbCk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGtleSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoKFwiZGF0YS1cIiArIGtleSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmRvbSgpLmRhdGFzZXQ7XG5cdFx0XHRcblx0XHRcdGlmICghZGF0YXNldCkge1xuXHRcdFx0XHRkYXRhc2V0ID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmRvbSgpLmF0dHJpYnV0ZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBhdHI7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGF0ciA9IGFyeVtpXTtcblx0XHRcdFx0XHRpZiAoYXRyLm5hbWUuc3Vic3RyKDAsNSkgPT0gJ2RhdGEtJykge1xuXHRcdFx0XHRcdFx0ZGF0YXNldFtJbWJhLnRvQ2FtZWxDYXNlKGF0ci5uYW1lLnNsaWNlKDUpKV0gPSBhdHIudmFsdWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBkYXRhc2V0O1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCBkZXNjZW5kYW50cyBvZiBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgbWF0Y2hpbmcgc2VsZWN0b3Jcblx0XHRcdEByZXR1cm4ge0ltYmEuU2VsZWN0b3J9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0cmV0dXJuIG5ldyBJbWJhLlNlbGVjdG9yKHNlbCx0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGZpcnN0IG1hdGNoaW5nIGNoaWxkIG9mIG5vZGVcblx0XHRcblx0XHRcdEByZXR1cm4ge0ltYmEuVGFnfVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRyZXR1cm4gc2VsID8gKHRoaXMuZmluZChzZWwpLmZpcnN0KCkpIDogKHRhZyR3cmFwKHRoaXMuZG9tKCkuZmlyc3RFbGVtZW50Q2hpbGQpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGxhc3QgbWF0Y2hpbmcgY2hpbGQgb2Ygbm9kZVxuXHRcdFxuXHRcdFx0XHRub2RlLmxhc3QgIyByZXR1cm5zIHRoZSBsYXN0IGNoaWxkIG9mIG5vZGVcblx0XHRcdFx0bm9kZS5sYXN0ICVzcGFuICMgcmV0dXJucyB0aGUgbGFzdCBzcGFuIGluc2lkZSBub2RlXG5cdFx0XHRcdG5vZGUubGFzdCBkbyB8ZWx8IGVsLnRleHQgPT0gJ0hpJyAjIHJldHVybiBsYXN0IG5vZGUgd2l0aCB0ZXh0IEhpXG5cdFx0XG5cdFx0XHRAcmV0dXJuIHtJbWJhLlRhZ31cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRyZXR1cm4gc2VsID8gKHRoaXMuZmluZChzZWwpLmxhc3QoKSkgOiAodGFnJHdyYXAodGhpcy5kb20oKS5sYXN0RWxlbWVudENoaWxkKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBjaGlsZCBhdCBpbmRleFxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKGkpe1xuXHRcdFx0cmV0dXJuIHRhZyR3cmFwKHRoaXMuZG9tKCkuY2hpbGRyZW5baSB8fCAwXSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHR2YXIgbm9kZXMgPSBuZXcgSW1iYS5TZWxlY3RvcihudWxsLHRoaXMsdGhpcy5fZG9tLmNoaWxkcmVuKTtcblx0XHRcdHJldHVybiBzZWwgPyAobm9kZXMuZmlsdGVyKHNlbCkpIDogKG5vZGVzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub3JwaGFuaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcGFyO1xuXHRcdFx0aWYgKHBhciA9IHRoaXMuZG9tKCkucGFyZW50Tm9kZSkgeyBwYXIucmVtb3ZlQ2hpbGQodGhpcy5fZG9tKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHZhciBmbjtcblx0XHRcdGlmIChzZWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gc2VsKHRoaXMpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlbC5xdWVyeSkgeyBzZWwgPSBzZWwucXVlcnkoKSB9O1xuXHRcdFx0aWYgKGZuID0gKHRoaXMuX2RvbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgdGhpcy5fZG9tLm1hdGNoZXMpKSB7IHJldHVybiBmbi5jYWxsKHRoaXMuX2RvbSxzZWwpIH07XG5cdFx0XHQvLyBUT0RPIHN1cHBvcnQgb3RoZXIgYnJvd3NlcnMgZXRjP1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCB0aGUgZmlyc3QgZWxlbWVudCBtYXRjaGluZyBzdXBwbGllZCBzZWxlY3RvciAvIGZpbHRlclxuXHRcdFx0dHJhdmVyc2luZyB1cHdhcmRzLCBidXQgaW5jbHVkaW5nIHRoZSBub2RlIGl0c2VsZi5cblx0XHRcdEByZXR1cm4ge0ltYmEuVGFnfVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdGlmICghc2VsKSB7IHJldHVybiB0aGlzLnBhcmVudCgpIH07IC8vIHNob3VsZCByZXR1cm4gc2VsZj8hXG5cdFx0XHR2YXIgbm9kZSA9IHRoaXM7XG5cdFx0XHRpZiAoc2VsLnF1ZXJ5KSB7IHNlbCA9IHNlbC5xdWVyeSgpIH07XG5cdFx0XHRcblx0XHRcdHdoaWxlIChub2RlKXtcblx0XHRcdFx0aWYgKG5vZGUubWF0Y2hlcyhzZWwpKSB7IHJldHVybiBub2RlIH07XG5cdFx0XHRcdG5vZGUgPSBub2RlLnBhcmVudCgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCB0aGUgY2xvc2VzdCBhbmNlc3RvciBvZiBub2RlIHRoYXQgbWF0Y2hlc1xuXHRcdFx0c3BlY2lmaWVkIHNlbGVjdG9yIC8gbWF0Y2hlci5cblx0XHRcblx0XHRcdEByZXR1cm4ge0ltYmEuVGFnfVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnVwID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRpZiAoIXNlbCkgeyByZXR1cm4gdGhpcy5wYXJlbnQoKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5jbG9zZXN0KHNlbCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHZhciBub2RlID0gdGhpcztcblx0XHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdFx0aWYgKHNlbCAmJiBzZWwucXVlcnkpIHsgc2VsID0gc2VsLnF1ZXJ5KCkgfTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKG5vZGUpe1xuXHRcdFx0XHRpZiAoIXNlbCB8fCBub2RlLm1hdGNoZXMoc2VsKSkgeyBub2Rlcy5wdXNoKG5vZGUpIH07XG5cdFx0XHRcdG5vZGUgPSBub2RlLnBhcmVudCgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBub2Rlcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFyZW50cyA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0dmFyIHBhciA9IHRoaXMucGFyZW50KCk7XG5cdFx0XHRyZXR1cm4gcGFyID8gKHBhci5wYXRoKHNlbCkpIDogKFtdKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2libGluZ3MgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHZhciBwYXIsIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKCEocGFyID0gdGhpcy5wYXJlbnQoKSkpIHsgcmV0dXJuIFtdIH07IC8vIEZJWE1FXG5cdFx0XHR2YXIgYXJ5ID0gdGhpcy5kb20oKS5wYXJlbnROb2RlLmNoaWxkcmVuO1xuXHRcdFx0dmFyIG5vZGVzID0gbmV3IEltYmEuU2VsZWN0b3IobnVsbCx0aGlzLGFyeSk7XG5cdFx0XHRyZXR1cm4gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gIT0gc2VsZiAmJiAoIXNlbCB8fCBuLm1hdGNoZXMoc2VsKSk7IH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCB0aGUgaW1tZWRpYXRlbHkgZm9sbG93aW5nIHNpYmxpbmcgb2Ygbm9kZS5cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRpZiAoc2VsKSB7XG5cdFx0XHRcdHZhciBlbCA9IHRoaXM7XG5cdFx0XHRcdHdoaWxlIChlbCA9IGVsLm5leHQoKSl7XG5cdFx0XHRcdFx0aWYgKGVsLm1hdGNoZXMoc2VsKSkgeyByZXR1cm4gZWwgfTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRhZyR3cmFwKHRoaXMuZG9tKCkubmV4dEVsZW1lbnRTaWJsaW5nKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGltbWVkaWF0ZWx5IHByZWNlZWRpbmcgc2libGluZyBvZiBub2RlLlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdGlmIChzZWwpIHtcblx0XHRcdFx0dmFyIGVsID0gdGhpcztcblx0XHRcdFx0d2hpbGUgKGVsID0gZWwucHJldigpKXtcblx0XHRcdFx0XHRpZiAoZWwubWF0Y2hlcyhzZWwpKSB7IHJldHVybiBlbCB9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGFnJHdyYXAodGhpcy5kb20oKS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5jb250YWlucyhub2RlICYmIG5vZGUuX2RvbSB8fCBub2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdHZhciBlbCA9IHRoaXMuZG9tKCk7XG5cdFx0XHR3aGlsZSAoZWwucHJldmlvdXNTaWJsaW5nKXtcblx0XHRcdFx0ZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7XG5cdFx0XHRcdGkrKztcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qXG5cdFx0XHRcblx0XHRcdEBkZXByZWNhdGVkXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKG5vZGUscGFycyl7XG5cdFx0XHRpZighcGFyc3x8cGFycy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSBwYXJzID0ge307XG5cdFx0XHR2YXIgYmVmb3JlID0gcGFycy5iZWZvcmUgIT09IHVuZGVmaW5lZCA/IHBhcnMuYmVmb3JlIDogbnVsbDtcblx0XHRcdHZhciBhZnRlciA9IHBhcnMuYWZ0ZXIgIT09IHVuZGVmaW5lZCA/IHBhcnMuYWZ0ZXIgOiBudWxsO1xuXHRcdFx0aWYgKGFmdGVyKSB7IGJlZm9yZSA9IGFmdGVyLm5leHQoKSB9O1xuXHRcdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRub2RlID0gKHRhZyQuJGZyYWdtZW50KCkuc2V0Q29udGVudChub2RlLDApLmVuZCgpKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoYmVmb3JlKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuaW5zZXJ0QmVmb3JlKG5vZGUuZG9tKCksYmVmb3JlLmRvbSgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXBwZW5kKG5vZGUpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEZvY3VzIG9uIGN1cnJlbnQgbm9kZVxuXHRcdFx0QHJldHVybiB7c2VsZn1cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5kb20oKS5mb2N1cygpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0UmVtb3ZlIGZvY3VzIGZyb20gY3VycmVudCBub2RlXG5cdFx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZG9tKCkuYmx1cigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRlbXBsYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRAdG9kbyBTaG91bGQgc3VwcG9ydCBtdWx0aXBsZSBhcmd1bWVudHMgbGlrZSBhcHBlbmRcblx0XHRcblx0XHRcdFRoZSAucHJlcGVuZCBtZXRob2QgaW5zZXJ0cyB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYXMgdGhlIGZpcnN0XG5cdFx0XHRjaGlsZCBvZiB0aGUgdGFyZ2V0IG5vZGUuIElmIHRoZSBjb250ZW50IGlzIGFscmVhZHkgYSBjaGlsZCBvZiBcblx0XHRcdG5vZGUgaXQgd2lsbCBiZSBtb3ZlZCB0byB0aGUgc3RhcnQuXG5cdFx0XHRcblx0XHQgICAgXHRub2RlLnByZXBlbmQgPGRpdi50b3A+ICMgcHJlcGVuZCBub2RlXG5cdFx0ICAgIFx0bm9kZS5wcmVwZW5kIFwic29tZSB0ZXh0XCIgIyBwcmVwZW5kIHRleHRcblx0XHQgICAgXHRub2RlLnByZXBlbmQgWzx1bD4sPHVsPl0gIyBwcmVwZW5kIGFycmF5XG5cdFx0XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHRcdHZhciBmaXJzdCA9IHRoaXMuX2RvbS5jaGlsZE5vZGVzWzBdO1xuXHRcdFx0Zmlyc3QgPyAodGhpcy5pbnNlcnRCZWZvcmUoaXRlbSxmaXJzdCkpIDogKHRoaXMuYXBwZW5kQ2hpbGQoaXRlbSkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0VGhlIC5hcHBlbmQgbWV0aG9kIGluc2VydHMgdGhlIHNwZWNpZmllZCBjb250ZW50IGFzIHRoZSBsYXN0IGNoaWxkXG5cdFx0XHRvZiB0aGUgdGFyZ2V0IG5vZGUuIElmIHRoZSBjb250ZW50IGlzIGFscmVhZHkgYSBjaGlsZCBvZiBub2RlIGl0XG5cdFx0XHR3aWxsIGJlIG1vdmVkIHRvIHRoZSBlbmQuXG5cdFx0XHRcblx0XHRcdCMgZXhhbXBsZVxuXHRcdFx0ICAgIHZhciByb290ID0gPGRpdi5yb290PlxuXHRcdFx0ICAgIHZhciBpdGVtID0gPGRpdi5pdGVtPiBcIlRoaXMgaXMgYW4gaXRlbVwiXG5cdFx0XHQgICAgcm9vdC5hcHBlbmQgaXRlbSAjIGFwcGVuZHMgaXRlbSB0byB0aGUgZW5kIG9mIHJvb3Rcblx0XHRcblx0XHRcdCAgICByb290LnByZXBlbmQgXCJzb21lIHRleHRcIiAjIGFwcGVuZCB0ZXh0XG5cdFx0XHQgICAgcm9vdC5wcmVwZW5kIFs8dWw+LDx1bD5dICMgYXBwZW5kIGFycmF5XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGl0ZW0pe1xuXHRcdFx0Ly8gcG9zc2libGUgdG8gYXBwZW5kIGJsYW5rXG5cdFx0XHQvLyBwb3NzaWJsZSB0byBzaW1wbGlmeSBvbiBzZXJ2ZXI/XG5cdFx0XHRpZiAoIWl0ZW0pIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFxuXHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoaXRlbSksIGxlbiA9IGFyeS5sZW5ndGgsIG1lbWJlcjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bWVtYmVyID0gYXJ5W2ldO1xuXHRcdFx0XHRcdG1lbWJlciAmJiB0aGlzLmFwcGVuZChtZW1iZXIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICgodHlwZW9mIGl0ZW09PSdzdHJpbmcnfHxpdGVtIGluc3RhbmNlb2YgU3RyaW5nKSB8fCAodHlwZW9mIGl0ZW09PSdudW1iZXInfHxpdGVtIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IEltYmEuZG9jdW1lbnQoKS5jcmVhdGVUZXh0Tm9kZShpdGVtKTtcblx0XHRcdFx0dGhpcy5fZG9tLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0XHRpZiAodGhpcy5fZW1wdHkpIHsgdGhpcy5fZW1wdHkgPSBmYWxzZSB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZG9tLmFwcGVuZENoaWxkKGl0ZW0uX2RvbSB8fCBpdGVtKTtcblx0XHRcdFx0aWYgKHRoaXMuX2VtcHR5KSB7IHRoaXMuX2VtcHR5ID0gZmFsc2UgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEluc2VydCBhIG5vZGUgaW50byB0aGUgY3VycmVudCBub2RlIChzZWxmKSwgYmVmb3JlIGFub3RoZXIuXG5cdFx0XHRUaGUgcmVsYXRpdmUgbm9kZSBtdXN0IGJlIGEgY2hpbGQgb2YgY3VycmVudCBub2RlLiBcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAobm9kZSxyZWwpe1xuXHRcdFx0aWYgKCh0eXBlb2Ygbm9kZT09J3N0cmluZyd8fG5vZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7IG5vZGUgPSBJbWJhLmRvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUobm9kZSkgfTtcblx0XHRcdGlmIChub2RlICYmIHJlbCkgeyB0aGlzLmRvbSgpLmluc2VydEJlZm9yZSgobm9kZS5fZG9tIHx8IG5vZGUpLChyZWwuX2RvbSB8fCByZWwpKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0QXBwZW5kIGEgc2luZ2xlIGl0ZW0gKG5vZGUgb3Igc3RyaW5nKSB0byB0aGUgY3VycmVudCBub2RlLlxuXHRcdFx0SWYgc3VwcGxpZWQgaXRlbSBpcyBhIHN0cmluZyBpdCB3aWxsIGF1dG9tYXRpY2FsbHkuIFRoaXMgaXMgdXNlZFxuXHRcdFx0YnkgSW1iYSBpbnRlcm5hbGx5LCBidXQgd2lsbCBwcmFjdGljYWxseSBuZXZlciBiZSB1c2VkIGV4cGxpY2l0bHkuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0XHRpZiAoKHR5cGVvZiBub2RlPT0nc3RyaW5nJ3x8bm9kZSBpbnN0YW5jZW9mIFN0cmluZykpIHsgbm9kZSA9IEltYmEuZG9jdW1lbnQoKS5jcmVhdGVUZXh0Tm9kZShub2RlKSB9O1xuXHRcdFx0aWYgKG5vZGUpIHsgdGhpcy5kb20oKS5hcHBlbmRDaGlsZChub2RlLl9kb20gfHwgbm9kZSkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdFJlbW92ZSBhIHNpbmdsZSBjaGlsZCBmcm9tIHRoZSBjdXJyZW50IG5vZGUuXG5cdFx0XHRVc2VkIGJ5IEltYmEgaW50ZXJuYWxseS5cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRcdGlmIChub2RlKSB7IHRoaXMuZG9tKCkucmVtb3ZlQ2hpbGQobm9kZS5fZG9tIHx8IG5vZGUpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kb20udG9TdHJpbmcoKTsgLy8gcmVhbGx5P1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEBkZXByZWNhdGVkXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xhc3NlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Y29uc29sZS5sb2coJ0ltYmEuVGFnI2NsYXNzZXMgaXMgZGVwcmVjYXRlZCcpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5jbGFzc0xpc3Q7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3N2Z2VsZW1lbnQnLCAnaHRtbGVsZW1lbnQnKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20uanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gRXh0ZW5kaW5nIEltYmEuVGFnI2NzcyB0byB3b3JrIHdpdGhvdXQgcHJlZml4ZXMgYnkgaW5zcGVjdGluZ1xuXHQvLyB0aGUgcHJvcGVydGllcyBvZiBhIENTU1N0eWxlRGVjbGFyYXRpb24gYW5kIGNyZWF0aW5nIGEgbWFwXG5cdFxuXHQvLyB2YXIgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywnLW1zLScsJy1tb3otJywnLW8tJywnLWJsaW5rLSddXG5cdC8vIHZhciBwcm9wcyA9IFsndHJhbnNmb3JtJywndHJhbnNpdGlvbicsJ2FuaW1hdGlvbiddXG5cdFxuXHR2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCcnKTtcblx0XG5cdEltYmEuQ1NTS2V5TWFwID0ge307XG5cdFxuXHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc3R5bGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcHJlZml4ZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdHByZWZpeGVkID0gYXJ5W2ldO1xuXHRcdHZhciB1bnByZWZpeGVkID0gcHJlZml4ZWQucmVwbGFjZSgvXi0od2Via2l0fG1zfG1venxvfGJsaW5rKS0vLCcnKTtcblx0XHR2YXIgY2FtZWxDYXNlID0gdW5wcmVmaXhlZC5yZXBsYWNlKC8tKFxcdykvZyxmdW5jdGlvbihtLGEpIHsgcmV0dXJuIGEudG9VcHBlckNhc2UoKTsgfSk7XG5cdFx0XG5cdFx0Ly8gaWYgdGhlcmUgZXhpc3RzIGFuIHVucHJlZml4ZWQgdmVyc2lvbiAtLSBhbHdheXMgdXNlIHRoaXNcblx0XHRpZiAocHJlZml4ZWQgIT0gdW5wcmVmaXhlZCkge1xuXHRcdFx0aWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eSh1bnByZWZpeGVkKSkgeyBjb250aW51ZTsgfTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHJlZ2lzdGVyIHRoZSBwcmVmaXhlc1xuXHRcdEltYmEuQ1NTS2V5TWFwW3VucHJlZml4ZWRdID0gSW1iYS5DU1NLZXlNYXBbY2FtZWxDYXNlXSA9IHByZWZpeGVkO1xuXHR9O1xuXHRcblx0cmV0dXJuIHRhZyQuZXh0ZW5kVGFnKCdodG1sZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0Ly8gb3ZlcnJpZGUgdGhlIG9yaWdpbmFsIGNzcyBtZXRob2Rcblx0XHR0YWcucHJvdG90eXBlLmNzcyA9IGZ1bmN0aW9uIChrZXksdmFsKXtcblx0XHRcdGlmIChrZXkgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhrZXkpLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHRcdHRoaXMuY3NzKGtleXNbaV0sa2V5W2tleXNbaV1dKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRrZXkgPSBJbWJhLkNTU0tleU1hcFtrZXldIHx8IGtleTtcblx0XHRcdFxuXHRcdFx0aWYgKHZhbCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0XHRcdH0gZWxzZSBpZiAodmFsID09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5zdHlsZVtrZXldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCh0eXBlb2YgdmFsPT0nbnVtYmVyJ3x8dmFsIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBrZXkubWF0Y2goL3dpZHRofGhlaWdodHxsZWZ0fHJpZ2h0fHRvcHxib3R0b20vKSkge1xuXHRcdFx0XHRcdHZhbCA9IHZhbCArIFwicHhcIjtcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5kb20oKS5zdHlsZVtrZXldID0gdmFsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5jbGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdC8vIHByZWRlZmluZSBhbGwgc3VwcG9ydGVkIGh0bWwgdGFnc1xuXHR0YWckLmRlZmluZVRhZygnZnJhZ21lbnQnLCAnaHRtbGVsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gSW1iYS5kb2N1bWVudCgpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhyZWYgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdocmVmJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhyZWYgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYWJicicpO1xuXHR0YWckLmRlZmluZVRhZygnYWRkcmVzcycpO1xuXHR0YWckLmRlZmluZVRhZygnYXJlYScpO1xuXHR0YWckLmRlZmluZVRhZygnYXJ0aWNsZScpO1xuXHR0YWckLmRlZmluZVRhZygnYXNpZGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2F1ZGlvJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdiJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdiYXNlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdiZGknKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2JkbycpO1xuXHR0YWckLmRlZmluZVRhZygnYmlnJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdibG9ja3F1b3RlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdib2R5Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdicicpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2J1dHRvbicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0QXV0b2ZvY3VzID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpc2FibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2NhbnZhcycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYgKHRoaXMud2lkdGgoKSAhPSB2YWwpIHsgdGhpcy5kb20oKS53aWR0aCA9IHZhbCB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYgKHRoaXMuaGVpZ2h0KCkgIT0gdmFsKSB7IHRoaXMuZG9tKCkuaGVpZ2h0ID0gdmFsIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLndpZHRoO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLmhlaWdodDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uICh0eXBlKXtcblx0XHRcdGlmKHR5cGUgPT09IHVuZGVmaW5lZCkgdHlwZSA9ICcyZCc7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5nZXRDb250ZXh0KHR5cGUpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2NhcHRpb24nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2NpdGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2NvZGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2NvbCcpO1xuXHR0YWckLmRlZmluZVRhZygnY29sZ3JvdXAnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RhdGEnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RhdGFsaXN0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkZCcpO1xuXHR0YWckLmRlZmluZVRhZygnZGVsJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkZXRhaWxzJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkZm4nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RpdicpO1xuXHR0YWckLmRlZmluZVRhZygnZGwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2R0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdlbScpO1xuXHR0YWckLmRlZmluZVRhZygnZW1iZWQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2ZpZWxkc2V0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdmaWdjYXB0aW9uJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdmaWd1cmUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2Zvb3RlcicpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2Zvcm0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbWV0aG9kJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE1ldGhvZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbWV0aG9kJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hY3Rpb24gPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdhY3Rpb24nKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0QWN0aW9uID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdhY3Rpb24nLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaDEnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2gyJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoMycpO1xuXHR0YWckLmRlZmluZVRhZygnaDQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2g1Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoNicpO1xuXHR0YWckLmRlZmluZVRhZygnaGVhZCcpO1xuXHR0YWckLmRlZmluZVRhZygnaGVhZGVyJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdocicpO1xuXHR0YWckLmRlZmluZVRhZygnaHRtbCcpO1xuXHR0YWckLmRlZmluZVRhZygnaScpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2lmcmFtZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzcmMnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1nJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NyYycsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbnB1dCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0Ly8gY2FuIHVzZSBhdHRyIGluc3RlYWRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncmVxdWlyZWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmVxdWlyZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXV0b2ZvY3VzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnYXV0b2ZvY3VzJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEF1dG9mb2N1cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnYXV0b2ZvY3VzJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkudmFsdWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpe1xuXHRcdFx0aWYgKHYgIT0gdGhpcy5kb20oKS52YWx1ZSkgeyB0aGlzLmRvbSgpLnZhbHVlID0gdiB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHYpe1xuXHRcdFx0aWYgKHYgIT0gdGhpcy5kb20oKS5wbGFjZWhvbGRlcikgeyB0aGlzLmRvbSgpLnBsYWNlaG9sZGVyID0gdiB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5wbGFjZWhvbGRlcjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2hlY2tlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuY2hlY2tlZDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2hlY2tlZCA9IGZ1bmN0aW9uIChib29sKXtcblx0XHRcdGlmIChib29sICE9IHRoaXMuZG9tKCkuY2hlY2tlZCkgeyB0aGlzLmRvbSgpLmNoZWNrZWQgPSBib29sIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbnMnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2tiZCcpO1xuXHR0YWckLmRlZmluZVRhZygna2V5Z2VuJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdsYWJlbCcpO1xuXHR0YWckLmRlZmluZVRhZygnbGVnZW5kJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdsaScpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2xpbmsnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVsID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncmVsJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgncmVsJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIcmVmID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdocmVmJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tZWRpYSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ21lZGlhJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE1lZGlhID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdtZWRpYScsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdtYWluJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdtYXAnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ21hcmsnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ21lbnUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ21lbnVpdGVtJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbWV0YScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnY29udGVudCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdjb250ZW50Jyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jaGFyc2V0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnY2hhcnNldCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGFyc2V0ID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdjaGFyc2V0Jyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ21ldGVyJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCduYXYnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ25vc2NyaXB0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdvYmplY3QnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ29sJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdvcHRncm91cCcpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ29wdGlvbicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdvdXRwdXQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3AnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3BhcmFtJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdwcmUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3Byb2dyZXNzJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdxJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdycCcpO1xuXHR0YWckLmRlZmluZVRhZygncnQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3J1YnknKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3MnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3NhbXAnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdzY3JpcHQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hc3luYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FzeW5jJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEFzeW5jID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdhc3luYycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVmZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkZWZlcicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREZWZlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnZGVmZXInLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc2VjdGlvbicpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3NlbGVjdCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdWx0aXBsZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ211bHRpcGxlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE11bHRpcGxlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgncmVxdWlyZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpc2FibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkudmFsdWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpe1xuXHRcdFx0aWYgKHYgIT0gdGhpcy5kb20oKS52YWx1ZSkgeyB0aGlzLmRvbSgpLnZhbHVlID0gdiB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3NtYWxsJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzb3VyY2UnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3NwYW4nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3N0cm9uZycpO1xuXHR0YWckLmRlZmluZVRhZygnc3R5bGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3N1YicpO1xuXHR0YWckLmRlZmluZVRhZygnc3VtbWFyeScpO1xuXHR0YWckLmRlZmluZVRhZygnc3VwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0YWJsZScpO1xuXHR0YWckLmRlZmluZVRhZygndGJvZHknKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RkJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygndGV4dGFyZWEnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncmVxdWlyZWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmVxdWlyZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb3dzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm93cycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSb3dzID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyb3dzJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2xzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnY29scycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb2xzID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdjb2xzJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0QXV0b2ZvY3VzID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS52YWx1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodil7XG5cdFx0XHRpZiAodiAhPSB0aGlzLmRvbSgpLnZhbHVlKSB7IHRoaXMuZG9tKCkudmFsdWUgPSB2IH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAodil7XG5cdFx0XHRpZiAodiAhPSB0aGlzLmRvbSgpLnBsYWNlaG9sZGVyKSB7IHRoaXMuZG9tKCkucGxhY2Vob2xkZXIgPSB2IH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnBsYWNlaG9sZGVyO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3Rmb290Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0aCcpO1xuXHR0YWckLmRlZmluZVRhZygndGhlYWQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RpbWUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RpdGxlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0cicpO1xuXHR0YWckLmRlZmluZVRhZygndHJhY2snKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3UnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3VsJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd2aWRlbycpO1xuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3dicicpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0XG5cdHRhZyQuU1ZHLmRlZmluZVRhZygnc3ZnZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLm5hbWVzcGFjZVVSSSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciB0eXBlcyA9IFwiY2lyY2xlIGRlZnMgZWxsaXBzZSBnIGxpbmUgbGluZWFyR3JhZGllbnQgbWFzayBwYXRoIHBhdHRlcm4gcG9seWdvbiBwb2x5bGluZSByYWRpYWxHcmFkaWVudCByZWN0IHN0b3Agc3ZnIHRleHQgdHNwYW5cIi5zcGxpdChcIiBcIik7XG5cdFx0XG5cdFx0dGFnLmJ1aWxkTm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGRvbSA9IEltYmEuZG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlModGhpcy5uYW1lc3BhY2VVUkkoKSx0aGlzLl9ub2RlVHlwZSk7XG5cdFx0XHR2YXIgY2xzID0gdGhpcy5fY2xhc3Nlcy5qb2luKFwiIFwiKTtcblx0XHRcdGlmIChjbHMpIHsgZG9tLmNsYXNzTmFtZS5iYXNlVmFsID0gY2xzIH07XG5cdFx0XHRyZXR1cm4gZG9tO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLmluaGVyaXQgPSBmdW5jdGlvbiAoY2hpbGQpe1xuXHRcdFx0Y2hpbGQuX3Byb3RvRG9tID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKGlkeCQoY2hpbGQuX25hbWUsdHlwZXMpID49IDApIHtcblx0XHRcdFx0Y2hpbGQuX25vZGVUeXBlID0gY2hpbGQuX25hbWU7XG5cdFx0XHRcdHJldHVybiBjaGlsZC5fY2xhc3NlcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25vZGVUeXBlID0gdGhpcy5fbm9kZVR5cGU7XG5cdFx0XHRcdHZhciBjbGFzc05hbWUgPSBcIl9cIiArIGNoaWxkLl9uYW1lLnJlcGxhY2UoL18vZywnLScpO1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQuX2NsYXNzZXMgPSB0aGlzLl9jbGFzc2VzLmNvbmNhdChjbGFzc05hbWUpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdEltYmEuYXR0cih0YWcsJ3gnKTtcblx0XHRJbWJhLmF0dHIodGFnLCd5Jyk7XG5cdFx0XG5cdFx0SW1iYS5hdHRyKHRhZywnd2lkdGgnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdoZWlnaHQnKTtcblx0XHRcblx0XHRJbWJhLmF0dHIodGFnLCdzdHJva2UnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdzdHJva2Utd2lkdGgnKTtcblx0fSk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ3N2ZycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywndmlld2JveCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuU1ZHLmRlZmluZVRhZygnZycpO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdkZWZzJyk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ3N5bWJvbCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywncHJlc2VydmVBc3BlY3RSYXRpbycpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3ZpZXdCb3gnKTtcblx0fSk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ21hcmtlcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywnbWFya2VyVW5pdHMnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdyZWZYJyk7XG5cdFx0SW1iYS5hdHRyKHRhZywncmVmWScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ21hcmtlcldpZHRoJyk7XG5cdFx0SW1iYS5hdHRyKHRhZywnbWFya2VySGVpZ2h0Jyk7XG5cdFx0SW1iYS5hdHRyKHRhZywnb3JpZW50Jyk7XG5cdH0pO1xuXHRcblx0XG5cdC8vIEJhc2ljIHNoYXBlc1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdyZWN0JywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCdyeCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3J5Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdjaXJjbGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdEltYmEuYXR0cih0YWcsJ2N4Jyk7XG5cdFx0SW1iYS5hdHRyKHRhZywnY3knKTtcblx0XHRJbWJhLmF0dHIodGFnLCdyJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdlbGxpcHNlJywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCdjeCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ2N5Jyk7XG5cdFx0SW1iYS5hdHRyKHRhZywncngnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdyeScpO1xuXHR9KTtcblx0XG5cdHRhZyQuU1ZHLmRlZmluZVRhZygncGF0aCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywnZCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3BhdGhMZW5ndGgnKTtcblx0fSk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ2xpbmUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdEltYmEuYXR0cih0YWcsJ3gxJyk7XG5cdFx0SW1iYS5hdHRyKHRhZywneDInKTtcblx0XHRJbWJhLmF0dHIodGFnLCd5MScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3kyJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdwb2x5bGluZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywncG9pbnRzJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdwb2x5Z29uJywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCdwb2ludHMnKTtcblx0fSk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ3RleHQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdEltYmEuYXR0cih0YWcsJ2R4Jyk7XG5cdFx0SW1iYS5hdHRyKHRhZywnZHknKTtcblx0XHRJbWJhLmF0dHIodGFnLCd0ZXh0LWFuY2hvcicpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3JvdGF0ZScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3RleHRMZW5ndGgnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdsZW5ndGhBZGp1c3QnKTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5TVkcuZGVmaW5lVGFnKCd0c3BhbicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywnZHgnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdkeScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3JvdGF0ZScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3RleHRMZW5ndGgnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdsZW5ndGhBZGp1c3QnKTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLnN2Zy5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QpIHtcblx0XHR0YWckLmV4dGVuZFRhZygnaHRtbGVsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFx0XG5cdFx0XHR0YWcucHJvdG90eXBlLmhhc0ZsYWcgPSBmdW5jdGlvbiAocmVmKXtcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyByZWYgKyAnKFxcXFxzfCQpJykudGVzdCh0aGlzLl9kb20uY2xhc3NOYW1lKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRhZy5wcm90b3R5cGUuYWRkRmxhZyA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdFx0XHRpZiAodGhpcy5oYXNGbGFnKHJlZikpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSArPSAodGhpcy5fZG9tLmNsYXNzTmFtZSA/ICgnICcpIDogKCcnKSkgKyByZWY7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGFnLnByb3RvdHlwZS51bmZsYWcgPSBmdW5jdGlvbiAocmVmKXtcblx0XHRcdFx0aWYgKCF0aGlzLmhhc0ZsYWcocmVmKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XHR2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCcoXnxcXFxccykqJyArIHJlZiArICcoXFxcXHN8JCkqJywnZycpO1xuXHRcdFx0XHR0aGlzLl9kb20uY2xhc3NOYW1lID0gdGhpcy5fZG9tLmNsYXNzTmFtZS5yZXBsYWNlKHJlZ2V4LCcnKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YWcucHJvdG90eXBlLnRvZ2dsZUZsYWcgPSBmdW5jdGlvbiAocmVmKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaGFzRmxhZyhyZWYpID8gKHRoaXMudW5mbGFnKHJlZikpIDogKHRoaXMuZmxhZyhyZWYpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRhZy5wcm90b3R5cGUuZmxhZyA9IGZ1bmN0aW9uIChyZWYsYm9vbCl7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIgJiYgISFib29sID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnVuZmxhZyhyZWYpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRGbGFnKHJlZik7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5sZWdhY3kuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBkb2MgPSBkb2N1bWVudDtcblx0dmFyIHdpbiA9IHdpbmRvdztcblx0XG5cdHZhciBoYXNUb3VjaEV2ZW50cyA9IHdpbmRvdyAmJiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSB1bmRlZmluZWQ7XG5cdFxuXHRJbWJhLlBvaW50ZXIgPSBmdW5jdGlvbiBQb2ludGVyKCl7XG5cdFx0dGhpcy5zZXRCdXR0b24oLTEpO1xuXHRcdHRoaXMuc2V0RXZlbnQoe3g6IDAseTogMCx0eXBlOiAndW5pbml0aWFsaXplZCd9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5waGFzZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcGhhc2U7IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXRQaGFzZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9waGFzZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUucHJldkV2ZW50ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wcmV2RXZlbnQ7IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXRQcmV2RXZlbnQgPSBmdW5jdGlvbih2KXsgdGhpcy5fcHJldkV2ZW50ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5idXR0b24gPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2J1dHRvbjsgfVxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnNldEJ1dHRvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9idXR0b24gPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLmV2ZW50ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ldmVudDsgfVxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnNldEV2ZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX2V2ZW50ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5kaXJ0eSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGlydHk7IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXREaXJ0eSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kaXJ0eSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuZXZlbnRzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ldmVudHM7IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXRFdmVudHMgPSBmdW5jdGlvbih2KXsgdGhpcy5fZXZlbnRzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdG91Y2g7IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXRUb3VjaCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90b3VjaCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dGhpcy5zZXRFdmVudChlKTtcblx0XHR0aGlzLnNldERpcnR5KHRydWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gdGhpcyBpcyBqdXN0IGZvciByZWd1bGFyIG1vdXNlIG5vd1xuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgZTEgPSB0aGlzLmV2ZW50KCk7XG5cdFx0XG5cdFx0aWYgKHRoaXMuZGlydHkoKSkge1xuXHRcdFx0dGhpcy5zZXRQcmV2RXZlbnQoZTEpO1xuXHRcdFx0dGhpcy5zZXREaXJ0eShmYWxzZSk7XG5cdFx0XHRcblx0XHRcdC8vIGJ1dHRvbiBzaG91bGQgb25seSBjaGFuZ2Ugb24gbW91c2Vkb3duIGV0Y1xuXHRcdFx0aWYgKGUxLnR5cGUgPT0gJ21vdXNlZG93bicpIHtcblx0XHRcdFx0dGhpcy5zZXRCdXR0b24oZTEuYnV0dG9uKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGRvIG5vdCBjcmVhdGUgdG91Y2ggZm9yIHJpZ2h0IGNsaWNrXG5cdFx0XHRcdGlmICh0aGlzLmJ1dHRvbigpID09IDIgfHwgKHRoaXMudG91Y2goKSAmJiB0aGlzLmJ1dHRvbigpICE9IDApKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY2FuY2VsIHRoZSBwcmV2aW91cyB0b3VjaFxuXHRcdFx0XHRpZiAodGhpcy50b3VjaCgpKSB7IHRoaXMudG91Y2goKS5jYW5jZWwoKSB9O1xuXHRcdFx0XHR0aGlzLnNldFRvdWNoKG5ldyBJbWJhLlRvdWNoKGUxLHRoaXMpKTtcblx0XHRcdFx0dGhpcy50b3VjaCgpLm1vdXNlZG93bihlMSxlMSk7XG5cdFx0XHR9IGVsc2UgaWYgKGUxLnR5cGUgPT0gJ21vdXNlbW92ZScpIHtcblx0XHRcdFx0aWYgKHRoaXMudG91Y2goKSkgeyB0aGlzLnRvdWNoKCkubW91c2Vtb3ZlKGUxLGUxKSB9O1xuXHRcdFx0fSBlbHNlIGlmIChlMS50eXBlID09ICdtb3VzZXVwJykge1xuXHRcdFx0XHR0aGlzLnNldEJ1dHRvbigtMSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy50b3VjaCgpICYmIHRoaXMudG91Y2goKS5idXR0b24oKSA9PSBlMS5idXR0b24pIHtcblx0XHRcdFx0XHR0aGlzLnRvdWNoKCkubW91c2V1cChlMSxlMSk7XG5cdFx0XHRcdFx0dGhpcy5zZXRUb3VjaChudWxsKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gdHJpZ2dlciBwb2ludGVydXBcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLnRvdWNoKCkpIHsgdGhpcy50b3VjaCgpLmlkbGUoKSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gSW1iYS5QT0lOVEVSUztcblx0fTtcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUueCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmV2ZW50KCkueDtcblx0fTtcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS55ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQoKS55O1xuXHR9O1xuXHRcblx0Ly8gZGVwcmVjYXRlZCAtLSBzaG91bGQgcmVtb3ZlXG5cdEltYmEuUG9pbnRlci51cGRhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjb25zb2xlLmxvZygndXBkYXRlIHRvdWNoJylcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoSW1iYS5QT0lOVEVSUyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJ5W2ldLnByb2Nlc3MoKTtcblx0XHR9O1xuXHRcdC8vIG5lZWQgdG8gYmUgYWJsZSB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0b3VjaCwgbm8/XG5cdFx0d2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShJbWJhLlBvaW50ZXIudXBkYXRlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHZhciBsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXAgPSAwO1xuXHR2YXIgbGFzdE5hdGl2ZVRvdWNoVGltZW91dCA9IDUwO1xuXHRcblx0Ly8gSW1iYS5Ub3VjaFxuXHQvLyBCZWdhblx0QSBmaW5nZXIgdG91Y2hlZCB0aGUgc2NyZWVuLlxuXHQvLyBNb3ZlZFx0QSBmaW5nZXIgbW92ZWQgb24gdGhlIHNjcmVlbi5cblx0Ly8gU3RhdGlvbmFyeVx0QSBmaW5nZXIgaXMgdG91Y2hpbmcgdGhlIHNjcmVlbiBidXQgaGFzbid0IG1vdmVkLlxuXHQvLyBFbmRlZFx0QSBmaW5nZXIgd2FzIGxpZnRlZCBmcm9tIHRoZSBzY3JlZW4uIFRoaXMgaXMgdGhlIGZpbmFsIHBoYXNlIG9mIGEgdG91Y2guXG5cdC8vIENhbmNlbGVkIFRoZSBzeXN0ZW0gY2FuY2VsbGVkIHRyYWNraW5nIGZvciB0aGUgdG91Y2guXG5cdFxuXHQvKlxuXHRDb25zb2xpZGF0ZXMgbW91c2UgYW5kIHRvdWNoIGV2ZW50cy4gVG91Y2ggb2JqZWN0cyBwZXJzaXN0IGFjcm9zcyBhIHRvdWNoLFxuXHRmcm9tIHRvdWNoc3RhcnQgdW50aWwgZW5kL2NhbmNlbC4gV2hlbiBhIHRvdWNoIHN0YXJ0cywgaXQgd2lsbCB0cmF2ZXJzZVxuXHRkb3duIGZyb20gdGhlIGlubmVybW9zdCB0YXJnZXQsIHVudGlsIGl0IGZpbmRzIGEgbm9kZSB0aGF0IHJlc3BvbmRzIHRvXG5cdG9udG91Y2hzdGFydC4gVW5sZXNzIHRoZSB0b3VjaCBpcyBleHBsaWNpdGx5IHJlZGlyZWN0ZWQsIHRoZSB0b3VjaCB3aWxsXG5cdGNhbGwgb250b3VjaG1vdmUgYW5kIG9udG91Y2hlbmQgLyBvbnRvdWNoY2FuY2VsIG9uIHRoZSByZXNwb25kZXIgd2hlbiBhcHByb3ByaWF0ZS5cblx0XG5cdFx0dGFnIGRyYWdnYWJsZVxuXHRcdFx0IyBjYWxsZWQgd2hlbiBhIHRvdWNoIHN0YXJ0c1xuXHRcdFx0ZGVmIG9udG91Y2hzdGFydCB0b3VjaFxuXHRcdFx0XHRmbGFnICdkcmFnZ2luZydcblx0XHRcdFx0c2VsZlxuXHRcdFx0XG5cdFx0XHQjIGNhbGxlZCB3aGVuIHRvdWNoIG1vdmVzIC0gc2FtZSB0b3VjaCBvYmplY3Rcblx0XHRcdGRlZiBvbnRvdWNobW92ZSB0b3VjaFxuXHRcdFx0XHQjIG1vdmUgdGhlIG5vZGUgd2l0aCB0b3VjaFxuXHRcdFx0XHRjc3MgdG9wOiB0b3VjaC5keSwgbGVmdDogdG91Y2guZHhcblx0XHRcdFxuXHRcdFx0IyBjYWxsZWQgd2hlbiB0b3VjaCBlbmRzXG5cdFx0XHRkZWYgb250b3VjaGVuZCB0b3VjaFxuXHRcdFx0XHR1bmZsYWcgJ2RyYWdnaW5nJ1xuXHRcblx0QGluYW1lIHRvdWNoXG5cdCovXG5cdFxuXHRJbWJhLlRvdWNoID0gZnVuY3Rpb24gVG91Y2goZXZlbnQscG9pbnRlcil7XG5cdFx0Ly8gQG5hdGl2ZSAgPSBmYWxzZVxuXHRcdHRoaXMuc2V0RXZlbnQoZXZlbnQpO1xuXHRcdHRoaXMuc2V0RGF0YSh7fSk7XG5cdFx0dGhpcy5zZXRBY3RpdmUodHJ1ZSk7XG5cdFx0dGhpcy5fYnV0dG9uID0gZXZlbnQgJiYgZXZlbnQuYnV0dG9uIHx8IDA7XG5cdFx0dGhpcy5fc3VwcHJlc3MgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxuXHRcdHRoaXMuX2NhcHR1cmVkID0gZmFsc2U7XG5cdFx0dGhpcy5zZXRCdWJibGUoZmFsc2UpO1xuXHRcdHBvaW50ZXIgPSBwb2ludGVyO1xuXHRcdHRoaXMuc2V0VXBkYXRlcygwKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHZhciB0b3VjaGVzID0gW107XG5cdHZhciBjb3VudCA9IDA7XG5cdHZhciBpZGVudGlmaWVycyA9IHt9O1xuXHRcblx0SW1iYS5Ub3VjaC5jb3VudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBjb3VudDtcblx0fTtcblx0XG5cdEltYmEuVG91Y2gubG9va3VwID0gZnVuY3Rpb24gKGl0ZW0pe1xuXHRcdHJldHVybiBpdGVtICYmIChpdGVtLl9fdG91Y2hfXyB8fCBpZGVudGlmaWVyc1tpdGVtLmlkZW50aWZpZXJdKTtcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucmVsZWFzZSA9IGZ1bmN0aW9uIChpdGVtLHRvdWNoKXtcblx0XHR2YXIgdl8sICQxO1xuXHRcdCgoKHZfID0gaWRlbnRpZmllcnNbaXRlbS5pZGVudGlmaWVyXSksZGVsZXRlIGlkZW50aWZpZXJzW2l0ZW0uaWRlbnRpZmllcl0sIHZfKSk7XG5cdFx0KCgoJDEgPSBpdGVtLl9fdG91Y2hfXyksZGVsZXRlIGl0ZW0uX190b3VjaF9fLCAkMSkpO1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChlLmNoYW5nZWRUb3VjaGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0ID0gYXJ5W2ldO1xuXHRcdFx0aWYgKHRoaXMubG9va3VwKHQpKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0dmFyIHRvdWNoID0gaWRlbnRpZmllcnNbdC5pZGVudGlmaWVyXSA9IG5ldyB0aGlzKGUpOyAvLyAoZSlcblx0XHRcdHQuX190b3VjaF9fID0gdG91Y2g7XG5cdFx0XHR0b3VjaGVzLnB1c2godG91Y2gpO1xuXHRcdFx0Y291bnQrKztcblx0XHRcdHRvdWNoLnRvdWNoc3RhcnQoZSx0KTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5vbnRvdWNobW92ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgdG91Y2g7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGUuY2hhbmdlZFRvdWNoZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCB0OyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHQgPSBhcnlbaV07XG5cdFx0XHRpZiAodG91Y2ggPSB0aGlzLmxvb2t1cCh0KSkge1xuXHRcdFx0XHR0b3VjaC50b3VjaG1vdmUoZSx0KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub250b3VjaGVuZCA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgdG91Y2g7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGUuY2hhbmdlZFRvdWNoZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCB0OyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHQgPSBhcnlbaV07XG5cdFx0XHRpZiAodG91Y2ggPSB0aGlzLmxvb2t1cCh0KSkge1xuXHRcdFx0XHR0b3VjaC50b3VjaGVuZChlLHQpO1xuXHRcdFx0XHR0aGlzLnJlbGVhc2UodCx0b3VjaCk7XG5cdFx0XHRcdGNvdW50LS07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZS5wcmV2ZW50RGVmYXVsdFxuXHRcdC8vIG5vdCBhbHdheXMgc3VwcG9ydGVkIVxuXHRcdC8vIHRvdWNoZXMgPSB0b3VjaGVzLmZpbHRlcih8fClcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub250b3VjaGNhbmNlbCA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgdG91Y2g7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGUuY2hhbmdlZFRvdWNoZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCB0OyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHQgPSBhcnlbaV07XG5cdFx0XHRpZiAodG91Y2ggPSB0aGlzLmxvb2t1cCh0KSkge1xuXHRcdFx0XHR0b3VjaC50b3VjaGNhbmNlbChlLHQpO1xuXHRcdFx0XHR0aGlzLnJlbGVhc2UodCx0b3VjaCk7XG5cdFx0XHRcdGNvdW50LS07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9ubW91c2Vkb3duID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub25tb3VzZXVwID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUucGhhc2UgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BoYXNlOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFBoYXNlID0gZnVuY3Rpb24odil7IHRoaXMuX3BoYXNlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9hY3RpdmU7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24odil7IHRoaXMuX2FjdGl2ZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmV2ZW50ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ldmVudDsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRFdmVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ldmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnBvaW50ZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BvaW50ZXI7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0UG9pbnRlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wb2ludGVyID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90YXJnZXQ7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24odil7IHRoaXMuX3RhcmdldCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2hhbmRsZXI7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0SGFuZGxlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oYW5kbGVyID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudXBkYXRlcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdXBkYXRlczsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRVcGRhdGVzID0gZnVuY3Rpb24odil7IHRoaXMuX3VwZGF0ZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zdXBwcmVzcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc3VwcHJlc3M7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0U3VwcHJlc3MgPSBmdW5jdGlvbih2KXsgdGhpcy5fc3VwcHJlc3MgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kYXRhOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGF0YSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuX19idWJibGUgPSB7Y2hhaW5hYmxlOiB0cnVlLG5hbWU6ICdidWJibGUnfTtcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24odil7IHJldHVybiB2ICE9PSB1bmRlZmluZWQgPyAodGhpcy5zZXRCdWJibGUodiksdGhpcykgOiB0aGlzLl9idWJibGU7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0QnViYmxlID0gZnVuY3Rpb24odil7IHRoaXMuX2J1YmJsZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5nZXN0dXJlcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZ2VzdHVyZXM7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0R2VzdHVyZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fZ2VzdHVyZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdC8qXG5cdFx0XG5cdFxuXHRcdEBpbnRlcm5hbFxuXHRcdEBjb25zdHJ1Y3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5jYXB0dXJlID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fY2FwdHVyZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2V2ZW50ICYmIHRoaXMuX2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5pc0NhcHR1cmVkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuICEhdGhpcy5fY2FwdHVyZWQ7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEV4dGVuZCB0aGUgdG91Y2ggd2l0aCBhIHBsdWdpbiAvIGdlc3R1cmUuIFxuXHRcdEFsbCBldmVudHMgKHRvdWNoc3RhcnQsbW92ZSBldGMpIGZvciB0aGUgdG91Y2hcblx0XHR3aWxsIGJlIHRyaWdnZXJlZCBvbiB0aGUgcGx1Z2lucyBpbiB0aGUgb3JkZXIgdGhleVxuXHRcdGFyZSBhZGRlZC5cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKHBsdWdpbil7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRlZCBnZXN0dXJlISEhXCJcblx0XHR0aGlzLl9nZXN0dXJlcyB8fCAodGhpcy5fZ2VzdHVyZXMgPSBbXSk7XG5cdFx0dGhpcy5fZ2VzdHVyZXMucHVzaChwbHVnaW4pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZWRpcmVjdCB0b3VjaCB0byBzcGVjaWZpZWQgdGFyZ2V0LiBvbnRvdWNoc3RhcnQgd2lsbCBhbHdheXMgYmVcblx0XHRjYWxsZWQgb24gdGhlIG5ldyB0YXJnZXQuXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uICh0YXJnZXQpe1xuXHRcdHRoaXMuX3JlZGlyZWN0ID0gdGFyZ2V0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRTdXBwcmVzcyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIuIFdpbGwgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3Jcblx0XHRhbGwgbmF0aXZlIGV2ZW50cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSB0b3VjaC5cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc3VwcHJlc3MgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjb2xsaXNpb24gd2l0aCB0aGUgc3VwcHJlc3MgcHJvcGVydHlcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFN1cHByZXNzID0gZnVuY3Rpb24gKHZhbHVlKXtcblx0XHRjb25zb2xlLndhcm4oJ0ltYmEuVG91Y2gjc3VwcHJlc3M9IGlzIGRlcHJlY2F0ZWQnKTtcblx0XHR0aGlzLl9zdXByZXNzID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0dGhpcy5fZXZlbnQgPSBlO1xuXHRcdHRoaXMuX3RvdWNoID0gdDtcblx0XHR0aGlzLl9idXR0b24gPSAwO1xuXHRcdHRoaXMuX3ggPSB0LmNsaWVudFg7XG5cdFx0dGhpcy5feSA9IHQuY2xpZW50WTtcblx0XHR0aGlzLmJlZ2FuKCk7XG5cdFx0aWYgKGUgJiYgdGhpcy5pc0NhcHR1cmVkKCkpIHsgZS5wcmV2ZW50RGVmYXVsdCgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR0aGlzLl9ldmVudCA9IGU7XG5cdFx0dGhpcy5feCA9IHQuY2xpZW50WDtcblx0XHR0aGlzLl95ID0gdC5jbGllbnRZO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0aWYgKGUgJiYgdGhpcy5pc0NhcHR1cmVkKCkpIHsgZS5wcmV2ZW50RGVmYXVsdCgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHRoaXMuX2V2ZW50ID0gZTtcblx0XHR0aGlzLl94ID0gdC5jbGllbnRYO1xuXHRcdHRoaXMuX3kgPSB0LmNsaWVudFk7XG5cdFx0dGhpcy5lbmRlZCgpO1xuXHRcdFxuXHRcdGxhc3ROYXRpdmVUb3VjaFRpbWVTdGFtcCA9IGUudGltZVN0YW1wO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9tYXhkciA8IDIwKSB7XG5cdFx0XHR2YXIgdGFwID0gbmV3IEltYmEuRXZlbnQoZSk7XG5cdFx0XHR0YXAuc2V0VHlwZSgndGFwJyk7XG5cdFx0XHR0YXAucHJvY2VzcygpO1xuXHRcdFx0aWYgKHRhcC5fcmVzcG9uZGVyKSB7IGUucHJldmVudERlZmF1bHQoKSB9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGUgJiYgdGhpcy5pc0NhcHR1cmVkKCkpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudG91Y2hjYW5jZWwgPSBmdW5jdGlvbiAoZSx0KXtcblx0XHRyZXR1cm4gdGhpcy5jYW5jZWwoKTtcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLl9ldmVudCA9IGU7XG5cdFx0c2VsZi5fYnV0dG9uID0gZS5idXR0b247XG5cdFx0c2VsZi5feCA9IHQuY2xpZW50WDtcblx0XHRzZWxmLl95ID0gdC5jbGllbnRZO1xuXHRcdHNlbGYuYmVnYW4oKTtcblx0XHRcblx0XHRzZWxmLl9tb3VzZW1vdmUgPSBmdW5jdGlvbihlKSB7IHJldHVybiBzZWxmLm1vdXNlbW92ZShlLGUpOyB9O1xuXHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLHNlbGYuX21vdXNlbW92ZSx0cnVlKTtcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHRoaXMuX3ggPSB0LmNsaWVudFg7XG5cdFx0dGhpcy5feSA9IHQuY2xpZW50WTtcblx0XHR0aGlzLl9ldmVudCA9IGU7XG5cdFx0aWYgKHRoaXMuaXNDYXB0dXJlZCgpKSB7IGUucHJldmVudERlZmF1bHQoKSB9O1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0dGhpcy5tb3ZlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5tb3VzZXVwID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0dGhpcy5feCA9IHQuY2xpZW50WDtcblx0XHR0aGlzLl95ID0gdC5jbGllbnRZO1xuXHRcdHRoaXMuZW5kZWQoKTtcblx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyx0aGlzLl9tb3VzZW1vdmUsdHJ1ZSk7XG5cdFx0dGhpcy5fbW91c2Vtb3ZlID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmlkbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmJlZ2FuID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fbWF4ZHIgPSB0aGlzLl9kciA9IDA7XG5cdFx0dGhpcy5feDAgPSB0aGlzLl94O1xuXHRcdHRoaXMuX3kwID0gdGhpcy5feTtcblx0XHRcblx0XHR2YXIgZG9tID0gdGhpcy5ldmVudCgpLnRhcmdldDtcblx0XHR2YXIgbm9kZSA9IG51bGw7XG5cdFx0XG5cdFx0dGhpcy5fc291cmNlVGFyZ2V0ID0gZG9tICYmIHRhZyR3cmFwKGRvbSk7XG5cdFx0XG5cdFx0d2hpbGUgKGRvbSl7XG5cdFx0XHRub2RlID0gdGFnJHdyYXAoZG9tKTtcblx0XHRcdGlmIChub2RlICYmIG5vZGUub250b3VjaHN0YXJ0KSB7XG5cdFx0XHRcdHRoaXMuX2J1YmJsZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnNldFRhcmdldChub2RlKTtcblx0XHRcdFx0dGhpcy50YXJnZXQoKS5vbnRvdWNoc3RhcnQodGhpcyk7XG5cdFx0XHRcdGlmICghdGhpcy5fYnViYmxlKSB7IGJyZWFrOyB9O1xuXHRcdFx0fTtcblx0XHRcdGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fdXBkYXRlcysrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRhcmdldF87XG5cdFx0aWYgKCF0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcblx0XHR2YXIgZHIgPSBNYXRoLnNxcnQodGhpcy5keCgpICogdGhpcy5keCgpICsgdGhpcy5keSgpICogdGhpcy5keSgpKTtcblx0XHRpZiAoZHIgPiB0aGlzLl9kcikgeyB0aGlzLl9tYXhkciA9IGRyIH07XG5cdFx0dGhpcy5fZHIgPSBkcjtcblx0XHRcblx0XHQvLyBjYXRjaGluZyBhIHRvdWNoLXJlZGlyZWN0PyE/XG5cdFx0aWYgKHRoaXMuX3JlZGlyZWN0KSB7XG5cdFx0XHRpZiAodGhpcy5fdGFyZ2V0ICYmIHRoaXMuX3RhcmdldC5vbnRvdWNoY2FuY2VsKSB7XG5cdFx0XHRcdHRoaXMuX3RhcmdldC5vbnRvdWNoY2FuY2VsKHRoaXMpO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuc2V0VGFyZ2V0KHRoaXMuX3JlZGlyZWN0KTtcblx0XHRcdHRoaXMuX3JlZGlyZWN0ID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLnRhcmdldCgpLm9udG91Y2hzdGFydCkgeyB0aGlzLnRhcmdldCgpLm9udG91Y2hzdGFydCh0aGlzKSB9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGhpcy5fdXBkYXRlcysrO1xuXHRcdGlmICh0aGlzLl9nZXN0dXJlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2dlc3R1cmVzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFyeVtpXS5vbnRvdWNodXBkYXRlKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdCh0YXJnZXRfID0gdGhpcy50YXJnZXQoKSkgJiYgdGFyZ2V0Xy5vbnRvdWNodXBkYXRlICAmJiAgdGFyZ2V0Xy5vbnRvdWNodXBkYXRlKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0YXJnZXRfO1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2dlc3R1cmVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fZ2VzdHVyZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBnOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0ZyA9IGFyeVtpXTtcblx0XHRcdFx0aWYgKGcub250b3VjaG1vdmUpIHsgZy5vbnRvdWNobW92ZSh0aGlzLHRoaXMuX2V2ZW50KSB9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdCh0YXJnZXRfID0gdGhpcy50YXJnZXQoKSkgJiYgdGFyZ2V0Xy5vbnRvdWNobW92ZSAgJiYgIHRhcmdldF8ub250b3VjaG1vdmUodGhpcyx0aGlzLl9ldmVudCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5lbmRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0YXJnZXRfO1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0dGhpcy5fdXBkYXRlcysrO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9nZXN0dXJlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2dlc3R1cmVzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFyeVtpXS5vbnRvdWNoZW5kKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdCh0YXJnZXRfID0gdGhpcy50YXJnZXQoKSkgJiYgdGFyZ2V0Xy5vbnRvdWNoZW5kICAmJiAgdGFyZ2V0Xy5vbnRvdWNoZW5kKHRoaXMpO1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKCF0aGlzLl9jYW5jZWxsZWQpIHtcblx0XHRcdHRoaXMuX2NhbmNlbGxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmNhbmNlbGxlZCgpO1xuXHRcdFx0aWYgKHRoaXMuX21vdXNlbW92ZSkgeyBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyx0aGlzLl9tb3VzZW1vdmUsdHJ1ZSkgfTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuY2FuY2VsbGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRhcmdldF87XG5cdFx0aWYgKCF0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcblx0XHR0aGlzLl9jYW5jZWxsZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3VwZGF0ZXMrKztcblx0XHRcblx0XHRpZiAodGhpcy5fZ2VzdHVyZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9nZXN0dXJlcyksIGxlbiA9IGFyeS5sZW5ndGgsIGc7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRnID0gYXJ5W2ldO1xuXHRcdFx0XHRpZiAoZy5vbnRvdWNoY2FuY2VsKSB7IGcub250b3VjaGNhbmNlbCh0aGlzKSB9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdCh0YXJnZXRfID0gdGhpcy50YXJnZXQoKSkgJiYgdGFyZ2V0Xy5vbnRvdWNoY2FuY2VsICAmJiAgdGFyZ2V0Xy5vbnRvdWNoY2FuY2VsKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRUaGUgYWJzb2x1dGUgZGlzdGFuY2UgdGhlIHRvdWNoIGhhcyBtb3ZlZCBmcm9tIHN0YXJ0aW5nIHBvc2l0aW9uIFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZHIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZHI7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFRoZSBkaXN0YW5jZSB0aGUgdG91Y2ggaGFzIG1vdmVkIGhvcml6b250YWxseVxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZHggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5feCAtIHRoaXMuX3gwO1xuXHR9O1xuXHRcblx0Lypcblx0XHRUaGUgZGlzdGFuY2UgdGhlIHRvdWNoIGhhcyBtb3ZlZCB2ZXJ0aWNhbGx5XG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5keSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl95IC0gdGhpcy5feTA7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEluaXRpYWwgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0b3VjaFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUueDAgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5feDA7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEluaXRpYWwgdmVydGljYWwgcG9zaXRpb24gb2YgdG91Y2hcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnkwID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3kwO1xuXHR9O1xuXHRcblx0Lypcblx0XHRIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRvdWNoXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS54ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRvdWNoXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS55ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEhvcml6b250YWwgcG9zaXRpb24gb2YgdG91Y2ggcmVsYXRpdmUgdG8gdGFyZ2V0XG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS50eCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX3RhcmdldEJveCB8fCAodGhpcy5fdGFyZ2V0Qm94ID0gdGhpcy5fdGFyZ2V0LmRvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcblx0XHRyZXR1cm4gdGhpcy5feCAtIHRoaXMuX3RhcmdldEJveC5sZWZ0O1xuXHR9O1xuXHRcblx0Lypcblx0XHRWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0b3VjaCByZWxhdGl2ZSB0byB0YXJnZXRcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fdGFyZ2V0Qm94IHx8ICh0aGlzLl90YXJnZXRCb3ggPSB0aGlzLl90YXJnZXQuZG9tKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuXHRcdHJldHVybiB0aGlzLl95IC0gdGhpcy5fdGFyZ2V0Qm94LnRvcDtcblx0fTtcblx0XG5cdC8qXG5cdFx0QnV0dG9uIHByZXNzZWQgaW4gdGhpcyB0b3VjaC4gTmF0aXZlIHRvdWNoZXMgZGVmYXVsdHMgdG8gbGVmdC1jbGljayAoMClcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmJ1dHRvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9idXR0b247XG5cdH07IC8vIEBwb2ludGVyID8gQHBvaW50ZXIuYnV0dG9uIDogMFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc291cmNlVGFyZ2V0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3NvdXJjZVRhcmdldDtcblx0fTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoR2VzdHVyZSA9IGZ1bmN0aW9uIFRvdWNoR2VzdHVyZSgpeyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5fX2FjdGl2ZSA9IHsnZGVmYXVsdCc6IGZhbHNlLG5hbWU6ICdhY3RpdmUnfTtcblx0SW1iYS5Ub3VjaEdlc3R1cmUucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih2KXsgdGhpcy5fYWN0aXZlID0gdjsgcmV0dXJuIHRoaXM7IH1cblx0SW1iYS5Ub3VjaEdlc3R1cmUucHJvdG90eXBlLl9hY3RpdmUgPSBmYWxzZTtcblx0XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUub250b3VjaHVwZGF0ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5vbnRvdWNoZW5kID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdC8vIEEgVG91Y2gtZXZlbnQgaXMgY3JlYXRlZCBvbiBtb3VzZWRvd24gKGFsd2F5cylcblx0Ly8gYW5kIHdoaWxlIGl0IGV4aXN0cywgbW91c2Vtb3ZlIGFuZCBtb3VzZXVwIHdpbGxcblx0Ly8gYmUgZGVsZWdhdGVkIHRvIHRoaXMgYWN0aXZlIGV2ZW50LlxuXHRJbWJhLlBPSU5URVIgPSBuZXcgSW1iYS5Qb2ludGVyKCk7XG5cdEltYmEuUE9JTlRFUlMgPSBbSW1iYS5QT0lOVEVSXTtcblx0XG5cdFxuXHQvLyByZWd1bGFyIGV2ZW50IHN0dWZmXG5cdEltYmEuS0VZTUFQID0ge1xuXHRcdFwiOFwiOiAnYmFja3NwYWNlJyxcblx0XHRcIjlcIjogJ3RhYicsXG5cdFx0XCIxM1wiOiAnZW50ZXInLFxuXHRcdFwiMTZcIjogJ3NoaWZ0Jyxcblx0XHRcIjE3XCI6ICdjdHJsJyxcblx0XHRcIjE4XCI6ICdhbHQnLFxuXHRcdFwiMTlcIjogJ2JyZWFrJyxcblx0XHRcIjIwXCI6ICdjYXBzJyxcblx0XHRcIjI3XCI6ICdlc2MnLFxuXHRcdFwiMzJcIjogJ3NwYWNlJyxcblx0XHRcIjM1XCI6ICdlbmQnLFxuXHRcdFwiMzZcIjogJ2hvbWUnLFxuXHRcdFwiMzdcIjogJ2xhcnInLFxuXHRcdFwiMzhcIjogJ3VhcnInLFxuXHRcdFwiMzlcIjogJ3JhcnInLFxuXHRcdFwiNDBcIjogJ2RhcnInLFxuXHRcdFwiNDVcIjogJ2luc2VydCcsXG5cdFx0XCI0NlwiOiAnZGVsZXRlJyxcblx0XHRcIjEwN1wiOiAncGx1cycsXG5cdFx0XCIxMDZcIjogJ211bHQnLFxuXHRcdFwiOTFcIjogJ21ldGEnXG5cdH07XG5cdFxuXHRJbWJhLkNIQVJNQVAgPSB7XG5cdFx0XCIlXCI6ICdtb2R1bG8nLFxuXHRcdFwiKlwiOiAnbXVsdGlwbHknLFxuXHRcdFwiK1wiOiAnYWRkJyxcblx0XHRcIi1cIjogJ3N1YicsXG5cdFx0XCIvXCI6ICdkaXZpZGUnLFxuXHRcdFwiLlwiOiAnZG90J1xuXHR9O1xuXHRcblx0Lypcblx0SW1iYSBoYW5kbGVzIGFsbCBldmVudHMgaW4gdGhlIGRvbSB0aHJvdWdoIGEgc2luZ2xlIG1hbmFnZXIsXG5cdGxpc3RlbmluZyBhdCB0aGUgcm9vdCBvZiB5b3VyIGRvY3VtZW50LiBJZiBJbWJhIGZpbmRzIGEgdGFnXG5cdHRoYXQgbGlzdGVucyB0byBhIGNlcnRhaW4gZXZlbnQsIHRoZSBldmVudCB3aWxsIGJlIHdyYXBwZWQgXG5cdGluIGFuIGBJbWJhLkV2ZW50YCwgd2hpY2ggbm9ybWFsaXplcyBzb21lIG9mIHRoZSBxdWlya3MgYW5kIFxuXHRicm93c2VyIGRpZmZlcmVuY2VzLlxuXHRcblx0QGluYW1lIGV2ZW50XG5cdCovXG5cdFxuXHRJbWJhLkV2ZW50ID0gZnVuY3Rpb24gRXZlbnQoZSl7XG5cdFx0dGhpcy5zZXRFdmVudChlKTtcblx0XHR0aGlzLnNldEJ1YmJsZSh0cnVlKTtcblx0fTtcblx0XG5cdC8qIHJlZmVyZW5jZSB0byB0aGUgbmF0aXZlIGV2ZW50ICovXG5cdFxuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmV2ZW50ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ldmVudDsgfVxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5zZXRFdmVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ldmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0LyogcmVmZXJlbmNlIHRvIHRoZSBuYXRpdmUgZXZlbnQgKi9cblx0XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUucHJlZml4ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wcmVmaXg7IH1cblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0UHJlZml4ID0gZnVuY3Rpb24odil7IHRoaXMuX3ByZWZpeCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kYXRhOyB9XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGF0YSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Lypcblx0XHRzaG91bGQgcmVtb3ZlIHRoaXMgYWxsdG9nZXRoZXI/XG5cdFx0QGRlcHJlY2F0ZWRcblx0XHQqL1xuXHRcblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3NvdXJjZTsgfVxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5zZXRTb3VyY2UgPSBmdW5jdGlvbih2KXsgdGhpcy5fc291cmNlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHQvKiBBIHtCb29sZWFufSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGV2ZW50IGJ1YmJsZXMgdXAgb3Igbm90ICovXG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuX19idWJibGUgPSB7dHlwZTogQm9vbGVhbixjaGFpbmFibGU6IHRydWUsbmFtZTogJ2J1YmJsZSd9O1xuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCA/ICh0aGlzLnNldEJ1YmJsZSh2KSx0aGlzKSA6IHRoaXMuX2J1YmJsZTsgfVxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5zZXRCdWJibGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fYnViYmxlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLkV2ZW50LndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIG5ldyB0aGlzKGUpO1xuXHR9O1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uICh0eXBlKXtcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0QHJldHVybiB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGNhc2UtaW5zZW5zaXRpdmUpXG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSB8fCB0aGlzLmV2ZW50KCkudHlwZTtcblx0fTtcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZSB8fCAodGhpcy5fbmFtZSA9IHRoaXMudHlwZSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFw6L2csJycpKTtcblx0fTtcblx0XG5cdC8vIG1pbWMgZ2V0c2V0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uICh2KXtcblx0XHRpZiAodiAhPSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0QnViYmxlKHYpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcy5fYnViYmxlO1xuXHR9O1xuXHRcblx0Lypcblx0XHRQcmV2ZW50cyBmdXJ0aGVyIHByb3BhZ2F0aW9uIG9mIHRoZSBjdXJyZW50IGV2ZW50LlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnNldEJ1YmJsZShmYWxzZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENhbmNlbCB0aGUgZXZlbnQgKGlmIGNhbmNlbGFibGUpLiBJbiB0aGUgY2FzZSBvZiBuYXRpdmUgZXZlbnRzIGl0XG5cdFx0d2lsbCBjYWxsIGBwcmV2ZW50RGVmYXVsdGAgb24gdGhlIHdyYXBwZWQgZXZlbnQgb2JqZWN0LlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLmV2ZW50KCkucHJldmVudERlZmF1bHQpIHsgdGhpcy5ldmVudCgpLnByZXZlbnREZWZhdWx0KCkgfTtcblx0XHR0aGlzLl9jYW5jZWwgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgZXZlbnQuY2FuY2VsIGhhcyBiZWVuIGNhbGxlZC5cblx0XG5cdFx0QHJldHVybiB7Qm9vbGVhbn1cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuaXNQcmV2ZW50ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpICYmIHRoaXMuZXZlbnQoKS5kZWZhdWx0UHJldmVudGVkIHx8IHRoaXMuX2NhbmNlbDtcblx0fTtcblx0XG5cdC8qXG5cdFx0QSByZWZlcmVuY2UgdG8gdGhlIGluaXRpYWwgdGFyZ2V0IG9mIHRoZSBldmVudC5cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRhZyR3cmFwKHRoaXMuZXZlbnQoKS5fdGFyZ2V0IHx8IHRoaXMuZXZlbnQoKS50YXJnZXQpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRBIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IHJlc3BvbmRpbmcgdG8gdGhlIGV2ZW50LlxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5yZXNwb25kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fcmVzcG9uZGVyO1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZWRpcmVjdCB0aGUgZXZlbnQgdG8gbmV3IHRhcmdldFxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHR0aGlzLl9yZWRpcmVjdCA9IG5vZGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEdldCB0aGUgbm9ybWFsaXplZCBjaGFyYWN0ZXIgZm9yIEtleWJvYXJkRXZlbnQvVGV4dEV2ZW50XG5cdFx0QHJldHVybiB7U3RyaW5nfVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5rZXljaGFyID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuZXZlbnQoKSBpbnN0YW5jZW9mIFRleHRFdmVudCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZXZlbnQoKS5kYXRhO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuZXZlbnQoKSBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcblx0XHRcdHZhciBraSA9IHRoaXMuZXZlbnQoKS5rZXlJZGVudGlmaWVyO1xuXHRcdFx0dmFyIHN5bSA9IEltYmEuS0VZTUFQW3RoaXMuZXZlbnQoKS5rZXlDb2RlXTtcblx0XHRcdFxuXHRcdFx0Ly8gcCAna2V5c3ltIScsa2ksc3ltXG5cdFx0XHRcblx0XHRcdGlmICghc3ltICYmIGtpLnN1YnN0cigwLDIpID09IFwiVStcIikge1xuXHRcdFx0XHRzeW0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGtpLnN1YnN0cigyKSwxNikpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBzeW07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdC8qXG5cdFx0QGRlcHJlY2F0ZWRcblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUua2V5Y29tYm8gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc3ltO1xuXHRcdGlmICghKHN5bSA9IHRoaXMua2V5Y2hhcigpKSkgeyByZXR1cm4gfTtcblx0XHRzeW0gPSBJbWJhLkNIQVJNQVBbc3ltXSB8fCBzeW07XG5cdFx0dmFyIGNvbWJvID0gW10sZSA9IHRoaXMuZXZlbnQoKTtcblx0XHRpZiAoZS5jdHJsS2V5KSB7IGNvbWJvLnB1c2goJ2N0cmwnKSB9O1xuXHRcdGlmIChlLnNoaWZ0S2V5KSB7IGNvbWJvLnB1c2goJ3NoaWZ0JykgfTtcblx0XHRpZiAoZS5hbHRLZXkpIHsgY29tYm8ucHVzaCgnYWx0JykgfTtcblx0XHRpZiAoZS5tZXRhS2V5KSB7IGNvbWJvLnB1c2goJ2NtZCcpIH07XG5cdFx0Y29tYm8ucHVzaChzeW0pO1xuXHRcdHJldHVybiBjb21iby5qb2luKFwiX1wiKS50b0xvd2VyQ2FzZSgpO1xuXHR9O1xuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbm9kZTtcblx0XHR2YXIgbWV0aCA9IChcIm9uXCIgKyAodGhpcy5fcHJlZml4IHx8ICcnKSArIHRoaXMubmFtZSgpKTtcblx0XHR2YXIgYXJncyA9IG51bGw7XG5cdFx0dmFyIGRvbXRhcmdldCA9IHRoaXMuZXZlbnQoKS5fdGFyZ2V0IHx8IHRoaXMuZXZlbnQoKS50YXJnZXQ7XG5cdFx0Ly8gdmFyIG5vZGUgPSA8e2RvbXRhcmdldDpfcmVzcG9uZGVyIG9yIGRvbXRhcmdldH0+XG5cdFx0Ly8gbmVlZCB0byBjbGVhbiB1cCBhbmQgZG9jdW1lbnQgdGhpcyBiZWhhdmlvdXJcblx0XHRcblx0XHR2YXIgZG9tbm9kZSA9IGRvbXRhcmdldC5fcmVzcG9uZGVyIHx8IGRvbXRhcmdldDtcblx0XHQvLyBAdG9kbyBuZWVkIHRvIHN0b3AgaW5maW5pdGUgcmVkaXJlY3QtcnVsZXMgaGVyZVxuXHRcdFxuXHRcdHZhciAkMTt3aGlsZSAoZG9tbm9kZSl7XG5cdFx0XHR0aGlzLl9yZWRpcmVjdCA9IG51bGw7XG5cdFx0XHRpZiAobm9kZSA9IHRhZyR3cmFwKGRvbW5vZGUpKSB7IC8vIG5vdCBvbmx5IHRhZyBcblx0XHRcdFx0XG5cdFx0XHRcdGlmICgodHlwZW9mIG5vZGVbKCQxID0gbWV0aCldPT0nc3RyaW5nJ3x8bm9kZVskMV0gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHJlbWVtYmVyIHRoZSByZWNlaXZlciBvZiB0aGUgZXZlbnRcblx0XHRcdFx0XHRtZXRoID0gbm9kZVttZXRoXTtcblx0XHRcdFx0XHRjb250aW51ZTsgLy8gc2hvdWxkIG5vdCBjb250aW51ZT9cblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChub2RlW21ldGhdIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRhcmdzID0gbm9kZVttZXRoXS5jb25jYXQobm9kZSk7XG5cdFx0XHRcdFx0bWV0aCA9IGFyZ3Muc2hpZnQoKTtcblx0XHRcdFx0XHRjb250aW51ZTsgLy8gc2hvdWxkIG5vdCBjb250aW51ZT9cblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChub2RlW21ldGhdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0XHR0aGlzLl9yZXNwb25kZXIgfHwgKHRoaXMuX3Jlc3BvbmRlciA9IG5vZGUpO1xuXHRcdFx0XHRcdC8vIHNob3VsZCBhdXRvc3RvcCBidWJibGUgaGVyZT9cblx0XHRcdFx0XHRhcmdzID8gKG5vZGVbbWV0aF0uYXBwbHkobm9kZSxhcmdzKSkgOiAobm9kZVttZXRoXSh0aGlzLHRoaXMuZGF0YSgpKSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBhZGQgbm9kZS5uZXh0RXZlbnRSZXNwb25kZXIgYXMgYSBzZXBhcmF0ZSBtZXRob2QgaGVyZT9cblx0XHRcdGlmICghKHRoaXMuYnViYmxlKCkgJiYgKGRvbW5vZGUgPSAodGhpcy5fcmVkaXJlY3QgfHwgKG5vZGUgPyAobm9kZS5wYXJlbnQoKSkgOiAoZG9tbm9kZS5wYXJlbnROb2RlKSkpKSkpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5wcm9jZXNzZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5wcm9jZXNzZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRJbWJhLmVtaXQoSW1iYSwnZXZlbnQnLFt0aGlzXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJldHVybiB0aGUgeC9sZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIC8gcG9pbnRlciBmb3IgdGhpcyBldmVudFxuXHRcdEByZXR1cm4ge051bWJlcn0geCBjb29yZGluYXRlIG9mIG1vdXNlIC8gcG9pbnRlciBmb3IgZXZlbnRcblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUueCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmV2ZW50KCkueDtcblx0fTtcblx0XG5cdC8qXG5cdFx0UmV0dXJuIHRoZSB5L3RvcCBjb29yZGluYXRlIG9mIHRoZSBtb3VzZSAvIHBvaW50ZXIgZm9yIHRoaXMgZXZlbnRcblx0XHRAcmV0dXJuIHtOdW1iZXJ9IHkgY29vcmRpbmF0ZSBvZiBtb3VzZSAvIHBvaW50ZXIgZm9yIGV2ZW50XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLnk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJldHVybnMgYSBOdW1iZXIgcmVwcmVzZW50aW5nIGEgc3lzdGVtIGFuZCBpbXBsZW1lbnRhdGlvblxuXHRcdGRlcGVuZGVudCBudW1lcmljIGNvZGUgaWRlbnRpZnlpbmcgdGhlIHVubW9kaWZpZWQgdmFsdWUgb2YgdGhlXG5cdFx0cHJlc3NlZCBrZXk7IHRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBrZXlDb2RlLlxuXHRcblx0XHRGb3IgbW91c2UtZXZlbnRzLCB0aGUgcmV0dXJuZWQgdmFsdWUgaW5kaWNhdGVzIHdoaWNoIGJ1dHRvbiB3YXNcblx0XHRwcmVzc2VkIG9uIHRoZSBtb3VzZSB0byB0cmlnZ2VyIHRoZSBldmVudC5cblx0XG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS53aGljaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmV2ZW50KCkud2hpY2g7XG5cdH07XG5cdFxuXHRcblx0Lypcblx0XG5cdE1hbmFnZXIgZm9yIGxpc3RlbmluZyB0byBhbmQgZGVsZWdhdGluZyBldmVudHMgaW4gSW1iYS4gQSBzaW5nbGUgaW5zdGFuY2Vcblx0aXMgYWx3YXlzIGNyZWF0ZWQgYnkgSW1iYSAoYXMgYEltYmEuRXZlbnRzYCksIHdoaWNoIGhhbmRsZXMgYW5kIGRlbGVnYXRlcyBhbGxcblx0ZXZlbnRzIGF0IHRoZSB2ZXJ5IHJvb3Qgb2YgdGhlIGRvY3VtZW50LiBJbWJhIGRvZXMgbm90IGNhcHR1cmUgYWxsIGV2ZW50c1xuXHRieSBkZWZhdWx0LCBzbyBpZiB5b3Ugd2FudCB0byBtYWtlIHN1cmUgZXhvdGljIG9yIGN1c3RvbSBET01FdmVudHMgYXJlIGRlbGVnYXRlZFxuXHRpbiBJbWJhIHlvdSB3aWxsIG5lZWQgdG8gcmVnaXN0ZXIgdGhlbSBpbiBgSW1iYS5FdmVudHMucmVnaXN0ZXIobXlDdXN0b21FdmVudE5hbWUpYFxuXHRcblx0QGluYW1lIG1hbmFnZXJcblx0XG5cdCovXG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uIEV2ZW50TWFuYWdlcihub2RlLHBhcnMpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZighcGFyc3x8cGFycy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSBwYXJzID0ge307XG5cdFx0dmFyIGV2ZW50cyA9IHBhcnMuZXZlbnRzICE9PSB1bmRlZmluZWQgPyBwYXJzLmV2ZW50cyA6IFtdO1xuXHRcdHNlbGYuc2V0Um9vdChub2RlKTtcblx0XHRzZWxmLnNldENvdW50KDApO1xuXHRcdHNlbGYuc2V0TGlzdGVuZXJzKFtdKTtcblx0XHRzZWxmLnNldERlbGVnYXRvcnMoe30pO1xuXHRcdHNlbGYuc2V0RGVsZWdhdG9yKGZ1bmN0aW9uKGUpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZGVsZWdhdGluZyBldmVudD8hIHtlfVwiXG5cdFx0XHRzZWxmLmRlbGVnYXRlKGUpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGV2ZW50cyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0c2VsZi5yZWdpc3RlcihhcnlbaV0pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb290OyB9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXRSb290ID0gZnVuY3Rpb24odil7IHRoaXMuX3Jvb3QgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvdW50OyB9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXRDb3VudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jb3VudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLl9fZW5hYmxlZCA9IHsnZGVmYXVsdCc6IGZhbHNlLHdhdGNoOiAnZW5hYmxlZERpZFNldCcsbmFtZTogJ2VuYWJsZWQnfTtcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7IH1cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbih2KXtcblx0XHR2YXIgYSA9IHRoaXMuZW5hYmxlZCgpO1xuXHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9lbmFibGVkID0gdjsgfVxuXHRcdGlmKHYgIT0gYSkgeyB0aGlzLmVuYWJsZWREaWRTZXQgJiYgdGhpcy5lbmFibGVkRGlkU2V0KHYsYSx0aGlzLl9fZW5hYmxlZCkgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2xpc3RlbmVyczsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0TGlzdGVuZXJzID0gZnVuY3Rpb24odil7IHRoaXMuX2xpc3RlbmVycyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5kZWxlZ2F0b3JzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kZWxlZ2F0b3JzOyB9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXREZWxlZ2F0b3JzID0gZnVuY3Rpb24odil7IHRoaXMuX2RlbGVnYXRvcnMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZGVsZWdhdG9yID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kZWxlZ2F0b3I7IH1cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnNldERlbGVnYXRvciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kZWxlZ2F0b3IgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5lbmFibGVkRGlkU2V0ID0gZnVuY3Rpb24gKGJvb2wpe1xuXHRcdGJvb2wgPyAodGhpcy5vbmVuYWJsZSgpKSA6ICh0aGlzLm9uZGlzYWJsZSgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFxuXHRcdFRlbGwgdGhlIGN1cnJlbnQgRXZlbnRNYW5hZ2VyIHRvIGludGVyY2VwdCBhbmQgaGFuZGxlIGV2ZW50IG9mIGEgY2VydGFpbiBuYW1lLlxuXHRcdEJ5IGRlZmF1bHQsIEltYmEuRXZlbnRzIHdpbGwgcmVnaXN0ZXIgaW50ZXJjZXB0b3JzIGZvcjogKmtleWRvd24qLCAqa2V5dXAqLCBcblx0XHQqa2V5cHJlc3MqLCAqdGV4dElucHV0KiwgKmlucHV0KiwgKmNoYW5nZSosICpzdWJtaXQqLCAqZm9jdXNpbiosICpmb2N1c291dCosIFxuXHRcdCpibHVyKiwgKmNvbnRleHRtZW51KiwgKmRibGNsaWNrKiwgKm1vdXNld2hlZWwqLCAqd2hlZWwqXG5cdFxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSxoYW5kbGVyKXtcblx0XHRpZihoYW5kbGVyID09PSB1bmRlZmluZWQpIGhhbmRsZXIgPSB0cnVlO1xuXHRcdGlmIChuYW1lIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChuYW1lKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXIoYXJ5W2ldLGhhbmRsZXIpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuZGVsZWdhdG9ycygpW25hbWVdKSB7IHJldHVybiB0aGlzIH07XG5cdFx0Ly8gY29uc29sZS5sb2coXCJyZWdpc3RlciBmb3IgZXZlbnQge25hbWV9XCIpXG5cdFx0dmFyIGZuID0gdGhpcy5kZWxlZ2F0b3JzKClbbmFtZV0gPSBoYW5kbGVyIGluc3RhbmNlb2YgRnVuY3Rpb24gPyAoaGFuZGxlcikgOiAodGhpcy5kZWxlZ2F0b3IoKSk7XG5cdFx0aWYgKHRoaXMuZW5hYmxlZCgpKSB7IHJldHVybiB0aGlzLnJvb3QoKS5hZGRFdmVudExpc3RlbmVyKG5hbWUsZm4sdHJ1ZSkgfTtcblx0fTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAobmFtZSxoYW5kbGVyLGNhcHR1cmUpe1xuXHRcdGlmKGNhcHR1cmUgPT09IHVuZGVmaW5lZCkgY2FwdHVyZSA9IHRydWU7XG5cdFx0dGhpcy5saXN0ZW5lcnMoKS5wdXNoKFtuYW1lLGhhbmRsZXIsY2FwdHVyZV0pO1xuXHRcdGlmICh0aGlzLmVuYWJsZWQoKSkgeyB0aGlzLnJvb3QoKS5hZGRFdmVudExpc3RlbmVyKG5hbWUsaGFuZGxlcixjYXB0dXJlKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmRlbGVnYXRlID0gZnVuY3Rpb24gKGUpe1xuXHRcdHRoaXMuc2V0Q291bnQodGhpcy5jb3VudCgpICsgMSk7XG5cdFx0dmFyIGV2ZW50ID0gSW1iYS5FdmVudC53cmFwKGUpO1xuXHRcdGV2ZW50LnByb2Nlc3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAodHlwZSx0YXJnZXQscGFycyl7XG5cdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdHZhciBkYXRhID0gcGFycy5kYXRhICE9PSB1bmRlZmluZWQgPyBwYXJzLmRhdGEgOiBudWxsO1xuXHRcdHZhciBzb3VyY2UgPSBwYXJzLnNvdXJjZSAhPT0gdW5kZWZpbmVkID8gcGFycy5zb3VyY2UgOiBudWxsO1xuXHRcdHZhciBldmVudCA9IEltYmEuRXZlbnQud3JhcCh7dHlwZTogdHlwZSx0YXJnZXQ6IHRhcmdldH0pO1xuXHRcdGlmIChkYXRhKSB7IChldmVudC5zZXREYXRhKGRhdGEpLGRhdGEpIH07XG5cdFx0aWYgKHNvdXJjZSkgeyAoZXZlbnQuc2V0U291cmNlKHNvdXJjZSksc291cmNlKSB9O1xuXHRcdHJldHVybiBldmVudDtcblx0fTtcblx0XG5cdC8vIHVzZSBjcmVhdGUgaW5zdGVhZD9cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpLnByb2Nlc3MoKTtcblx0fTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5vbmVuYWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGZvciAodmFyIG8gPSB0aGlzLmRlbGVnYXRvcnMoKSwgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdHRoaXMucm9vdCgpLmFkZEV2ZW50TGlzdGVuZXIoa2V5c1tpXSxvW2tleXNbaV1dLHRydWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMubGlzdGVuZXJzKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCBpdGVtOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGl0ZW0gPSBhcnlbaV07XG5cdFx0XHR0aGlzLnJvb3QoKS5hZGRFdmVudExpc3RlbmVyKGl0ZW1bMF0saXRlbVsxXSxpdGVtWzJdKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLm9uZGlzYWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGZvciAodmFyIG8gPSB0aGlzLmRlbGVnYXRvcnMoKSwgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdHRoaXMucm9vdCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5c1tpXSxvW2tleXNbaV1dLHRydWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMubGlzdGVuZXJzKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCBpdGVtOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGl0ZW0gPSBhcnlbaV07XG5cdFx0XHR0aGlzLnJvb3QoKS5yZW1vdmVFdmVudExpc3RlbmVyKGl0ZW1bMF0saXRlbVsxXSxpdGVtWzJdKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdEVEID0gSW1iYS5FdmVudHMgPSBuZXcgSW1iYS5FdmVudE1hbmFnZXIoZG9jdW1lbnQse2V2ZW50czogW1xuXHRcdCdrZXlkb3duJywna2V5dXAnLCdrZXlwcmVzcycsJ3RleHRJbnB1dCcsJ2lucHV0JywnY2hhbmdlJywnc3VibWl0Jyxcblx0XHQnZm9jdXNpbicsJ2ZvY3Vzb3V0JywnYmx1cicsJ2NvbnRleHRtZW51JywnZGJsY2xpY2snLFxuXHRcdCdtb3VzZXdoZWVsJywnd2hlZWwnXG5cdF19KTtcblx0XG5cdC8vIHNob3VsZCBzZXQgdGhlc2UgdXAgaW5zaWRlIHRoZSBJbWJhLkV2ZW50cyBvYmplY3QgaXRzZWxmXG5cdC8vIHNvIHRoYXQgd2UgY2FuIGhhdmUgZGlmZmVyZW50IEV2ZW50TWFuYWdlciBmb3IgZGlmZmVyZW50IHJvb3RzXG5cdFxuXHRpZiAoaGFzVG91Y2hFdmVudHMpIHtcblx0XHRJbWJhLkV2ZW50cy5saXN0ZW4oJ3RvdWNoc3RhcnQnLGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBFdmVudHNfLCB2Xztcblx0XHRcdCgoKEV2ZW50c18gPSBJbWJhLkV2ZW50cykuc2V0Q291bnQodl8gPSBFdmVudHNfLmNvdW50KCkgKyAxKSx2XykpIC0gMTtcblx0XHRcdHJldHVybiBJbWJhLlRvdWNoLm9udG91Y2hzdGFydChlKTtcblx0XHR9KTtcblx0XHRcblx0XHRJbWJhLkV2ZW50cy5saXN0ZW4oJ3RvdWNobW92ZScsZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIEV2ZW50c18sIHZfO1xuXHRcdFx0KCgoRXZlbnRzXyA9IEltYmEuRXZlbnRzKS5zZXRDb3VudCh2XyA9IEV2ZW50c18uY291bnQoKSArIDEpLHZfKSkgLSAxO1xuXHRcdFx0cmV0dXJuIEltYmEuVG91Y2gub250b3VjaG1vdmUoZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0SW1iYS5FdmVudHMubGlzdGVuKCd0b3VjaGVuZCcsZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIEV2ZW50c18sIHZfO1xuXHRcdFx0KCgoRXZlbnRzXyA9IEltYmEuRXZlbnRzKS5zZXRDb3VudCh2XyA9IEV2ZW50c18uY291bnQoKSArIDEpLHZfKSkgLSAxO1xuXHRcdFx0cmV0dXJuIEltYmEuVG91Y2gub250b3VjaGVuZChlKTtcblx0XHR9KTtcblx0XHRcblx0XHRJbWJhLkV2ZW50cy5saXN0ZW4oJ3RvdWNoY2FuY2VsJyxmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgRXZlbnRzXywgdl87XG5cdFx0XHQoKChFdmVudHNfID0gSW1iYS5FdmVudHMpLnNldENvdW50KHZfID0gRXZlbnRzXy5jb3VudCgpICsgMSksdl8pKSAtIDE7XG5cdFx0XHRyZXR1cm4gSW1iYS5Ub3VjaC5vbnRvdWNoY2FuY2VsKGUpO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0SW1iYS5FdmVudHMucmVnaXN0ZXIoJ2NsaWNrJyxmdW5jdGlvbihlKSB7XG5cdFx0Ly8gT25seSBmb3IgbWFpbiBtb3VzZWJ1dHRvbiwgbm8/XG5cdFx0aWYgKChlLnRpbWVTdGFtcCAtIGxhc3ROYXRpdmVUb3VjaFRpbWVTdGFtcCkgPiBsYXN0TmF0aXZlVG91Y2hUaW1lb3V0KSB7XG5cdFx0XHR2YXIgdGFwID0gbmV3IEltYmEuRXZlbnQoZSk7XG5cdFx0XHR0YXAuc2V0VHlwZSgndGFwJyk7XG5cdFx0XHR0YXAucHJvY2VzcygpO1xuXHRcdFx0aWYgKHRhcC5fcmVzcG9uZGVyKSB7XG5cdFx0XHRcdHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Ly8gZGVsZWdhdGUgdGhlIHJlYWwgY2xpY2sgZXZlbnRcblx0XHRyZXR1cm4gSW1iYS5FdmVudHMuZGVsZWdhdGUoZSk7XG5cdH0pO1xuXHRcblx0SW1iYS5FdmVudHMubGlzdGVuKCdtb3VzZWRvd24nLGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoKGUudGltZVN0YW1wIC0gbGFzdE5hdGl2ZVRvdWNoVGltZVN0YW1wKSA+IGxhc3ROYXRpdmVUb3VjaFRpbWVvdXQpIHtcblx0XHRcdGlmIChJbWJhLlBPSU5URVIpIHsgcmV0dXJuIEltYmEuUE9JTlRFUi51cGRhdGUoZSkucHJvY2VzcygpIH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHQvLyBJbWJhLkV2ZW50cy5saXN0ZW4oOm1vdXNlbW92ZSkgZG8gfGV8XG5cdC8vIFx0IyBjb25zb2xlLmxvZyAnbW91c2Vtb3ZlJyxlOnRpbWVTdGFtcFxuXHQvLyBcdGlmIChlOnRpbWVTdGFtcCAtIGxhc3ROYXRpdmVUb3VjaFRpbWVTdGFtcCkgPiBsYXN0TmF0aXZlVG91Y2hUaW1lb3V0XG5cdC8vIFx0XHRJbWJhLlBPSU5URVIudXBkYXRlKGUpLnByb2Nlc3MgaWYgSW1iYS5QT0lOVEVSICMgLnByb2Nlc3MgaWYgdG91Y2ggIyBzaG91bGQgbm90IGhhcHBlbj8gV2UgcHJvY2VzcyB0aHJvdWdoIFxuXHRcblx0SW1iYS5FdmVudHMubGlzdGVuKCdtb3VzZXVwJyxmdW5jdGlvbihlKSB7XG5cdFx0Ly8gY29uc29sZS5sb2cgJ21vdXNldXAnLGU6dGltZVN0YW1wXG5cdFx0aWYgKChlLnRpbWVTdGFtcCAtIGxhc3ROYXRpdmVUb3VjaFRpbWVTdGFtcCkgPiBsYXN0TmF0aXZlVG91Y2hUaW1lb3V0KSB7XG5cdFx0XHRpZiAoSW1iYS5QT0lOVEVSKSB7IHJldHVybiBJbWJhLlBPSU5URVIudXBkYXRlKGUpLnByb2Nlc3MoKSB9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdEltYmEuRXZlbnRzLnJlZ2lzdGVyKFsnbW91c2Vkb3duJywnbW91c2V1cCddKTtcblx0cmV0dXJuIChJbWJhLkV2ZW50cy5zZXRFbmFibGVkKHRydWUpLHRydWUpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5ldmVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBJbWJhVGFnID0gSW1iYS5UQUdTLmVsZW1lbnQ7XG5cdFxuXHRmdW5jdGlvbiByZW1vdmVOZXN0ZWQocm9vdCxub2RlLGNhcmV0KXtcblx0XHQvLyBpZiBub2RlL25vZGVzIGlzYSBTdHJpbmdcblx0XHQvLyBcdHdlIG5lZWQgdG8gdXNlIHRoZSBjYXJldCB0byByZW1vdmUgZWxlbWVudHNcblx0XHQvLyBcdGZvciBub3cgd2Ugd2lsbCBzaW1wbHkgbm90IHN1cHBvcnQgdGhpc1xuXHRcdGlmIChub2RlIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0cm9vdC5yZW1vdmVDaGlsZChub2RlKTtcblx0XHR9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGUpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVtb3ZlTmVzdGVkKHJvb3QsYXJ5W2ldLGNhcmV0KTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHdoYXQgaWYgdGhpcyBpcyBub3QgbnVsbD8hPyE/XG5cdFx0XHQvLyB0YWtlIGEgY2hhbmNlIGFuZCByZW1vdmUgYSB0ZXh0LWVsZW1lbnRuZ1xuXHRcdFx0dmFyIG5leHQgPSBjYXJldCA/IChjYXJldC5uZXh0U2libGluZykgOiAocm9vdC5fZG9tLmZpcnN0Q2hpbGQpO1xuXHRcdFx0aWYgKChuZXh0IGluc3RhbmNlb2YgVGV4dCkgJiYgbmV4dC50ZXh0Q29udGVudCA9PSBub2RlKSB7XG5cdFx0XHRcdHJvb3QucmVtb3ZlQ2hpbGQobmV4dCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyAnY2Fubm90IHJlbW92ZSBzdHJpbmcnO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBjYXJldDtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGFwcGVuZE5lc3RlZChyb290LG5vZGUpe1xuXHRcdGlmIChub2RlIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0cm9vdC5hcHBlbmRDaGlsZChub2RlKTtcblx0XHR9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGUpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXBwZW5kTmVzdGVkKHJvb3QsYXJ5W2ldKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChub2RlICE9IG51bGwgJiYgbm9kZSAhPT0gZmFsc2UpIHtcblx0XHRcdHJvb3QuYXBwZW5kQ2hpbGQoSW1iYS5kb2N1bWVudCgpLmNyZWF0ZVRleHROb2RlKG5vZGUpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdFxuXHQvLyBpbnNlcnQgbm9kZXMgYmVmb3JlIGEgY2VydGFpbiBub2RlXG5cdC8vIGRvZXMgbm90IG5lZWQgdG8gcmV0dXJuIGFueSB0YWlsLCBhcyBiZWZvcmVcblx0Ly8gd2lsbCBzdGlsbCBiZSBjb3JyZWN0IHRoZXJlXG5cdC8vIGJlZm9yZSBtdXN0IGJlIGFuIGFjdHVhbCBkb21ub2RlXG5cdGZ1bmN0aW9uIGluc2VydE5lc3RlZEJlZm9yZShyb290LG5vZGUsYmVmb3JlKXtcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdHJvb3QuaW5zZXJ0QmVmb3JlKG5vZGUsYmVmb3JlKTtcblx0XHR9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGUpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aW5zZXJ0TmVzdGVkQmVmb3JlKHJvb3QsYXJ5W2ldLGJlZm9yZSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobm9kZSAhPSBudWxsICYmIG5vZGUgIT09IGZhbHNlKSB7XG5cdFx0XHRyb290Lmluc2VydEJlZm9yZShJbWJhLmRvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUobm9kZSksYmVmb3JlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBiZWZvcmU7XG5cdH07XG5cdFxuXHQvLyBhZnRlciBtdXN0IGJlIGFuIGFjdHVhbCBkb21ub2RlXG5cdGZ1bmN0aW9uIGluc2VydE5lc3RlZEFmdGVyKHJvb3Qsbm9kZSxhZnRlcil7XG5cdFx0dmFyIGJlZm9yZSA9IGFmdGVyID8gKGFmdGVyLm5leHRTaWJsaW5nKSA6IChyb290Ll9kb20uZmlyc3RDaGlsZCk7XG5cdFx0XG5cdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0aW5zZXJ0TmVzdGVkQmVmb3JlKHJvb3Qsbm9kZSxiZWZvcmUpO1xuXHRcdFx0cmV0dXJuIGJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFwcGVuZE5lc3RlZChyb290LG5vZGUpO1xuXHRcdFx0cmV0dXJuIHJvb3QuX2RvbS5sYXN0Q2hpbGQ7XG5cdFx0fTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHJlY29uY2lsZUNvbGxlY3Rpb25DaGFuZ2VzKHJvb3QsbmV3JCxvbGQsY2FyZXQpe1xuXHRcdFxuXHRcdHZhciBuZXdMZW4gPSBuZXckLmxlbmd0aDtcblx0XHR2YXIgbGFzdE5ldyA9IG5ldyRbbmV3TGVuIC0gMV07XG5cdFx0XG5cdFx0Ly8gVGhpcyByZS1vcmRlciBhbGdvcml0aG0gaXMgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBwcmluY2lwbGU6XG5cdFx0Ly8gXG5cdFx0Ly8gV2UgYnVpbGQgYSBcImNoYWluXCIgd2hpY2ggc2hvd3Mgd2hpY2ggaXRlbXMgYXJlIGFscmVhZHkgc29ydGVkLlxuXHRcdC8vIElmIHdlJ3JlIGdvaW5nIGZyb20gWzEsIDIsIDNdIC0+IFsyLCAxLCAzXSwgdGhlIHRyZWUgbG9va3MgbGlrZTpcblx0XHQvL1xuXHRcdC8vIFx0MyAtPiAgMCAoaWR4KVxuXHRcdC8vIFx0MiAtPiAtMSAoaWR4KVxuXHRcdC8vIFx0MSAtPiAtMSAoaWR4KVxuXHRcdC8vXG5cdFx0Ly8gVGhpcyB0ZWxscyB1cyB0aGF0IHdlIGhhdmUgdHdvIGNoYWlucyBvZiBvcmRlcmVkIGl0ZW1zOlxuXHRcdC8vIFxuXHRcdC8vIFx0KDEsIDMpIGFuZCAoMilcblx0XHQvLyBcblx0XHQvLyBUaGUgb3B0aW1hbCByZS1vcmRlcmluZyB0aGVuIGJlY29tZXMgdHdvIGtlZXAgdGhlIGxvbmdlc3QgY2hhaW4gaW50YWN0LFxuXHRcdC8vIGFuZCBtb3ZlIGFsbCB0aGUgb3RoZXIgaXRlbXMuXG5cdFx0XG5cdFx0dmFyIG5ld1Bvc2l0aW9uID0gW107XG5cdFx0XG5cdFx0Ly8gVGhlIHRyZWUvZ3JhcGggaXRzZWxmXG5cdFx0dmFyIHByZXZDaGFpbiA9IFtdO1xuXHRcdC8vIFRoZSBsZW5ndGggb2YgdGhlIGNoYWluXG5cdFx0dmFyIGxlbmd0aENoYWluID0gW107XG5cdFx0XG5cdFx0Ly8gS2VlcCB0cmFjayBvZiB0aGUgbG9uZ2VzdCBjaGFpblxuXHRcdHZhciBtYXhDaGFpbkxlbmd0aCA9IDA7XG5cdFx0dmFyIG1heENoYWluRW5kID0gMDtcblx0XHRcblx0XHRmb3IgKHZhciBpZHggPSAwLCBhcnkgPSBpdGVyJChvbGQpLCBsZW4gPSBhcnkubGVuZ3RoLCBub2RlOyBpZHggPCBsZW47IGlkeCsrKSB7XG5cdFx0XHRub2RlID0gYXJ5W2lkeF07XG5cdFx0XHR2YXIgbmV3UG9zID0gbmV3JC5pbmRleE9mKG5vZGUpO1xuXHRcdFx0bmV3UG9zaXRpb24ucHVzaChuZXdQb3MpO1xuXHRcdFx0XG5cdFx0XHRpZiAobmV3UG9zID09IC0xKSB7XG5cdFx0XHRcdHJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdFx0XHRcdHByZXZDaGFpbi5wdXNoKC0xKTtcblx0XHRcdFx0bGVuZ3RoQ2hhaW4ucHVzaCgtMSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHByZXZJZHggPSBuZXdQb3NpdGlvbi5sZW5ndGggLSAyO1xuXHRcdFx0XG5cdFx0XHQvLyBCdWlsZCB0aGUgY2hhaW46XG5cdFx0XHR3aGlsZSAocHJldklkeCA+PSAwKXtcblx0XHRcdFx0aWYgKG5ld1Bvc2l0aW9uW3ByZXZJZHhdID09IC0xKSB7XG5cdFx0XHRcdFx0cHJldklkeC0tO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5ld1BvcyA+IG5ld1Bvc2l0aW9uW3ByZXZJZHhdKSB7XG5cdFx0XHRcdFx0Ly8gWWF5LCB3ZSdyZSBiaWdnZXIgdGhhbiB0aGUgcHJldmlvdXMhXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gTm9wZSwgbGV0J3Mgd2FsayBiYWNrIHRoZSBjaGFpblxuXHRcdFx0XHRcdHByZXZJZHggPSBwcmV2Q2hhaW5bcHJldklkeF07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRwcmV2Q2hhaW4ucHVzaChwcmV2SWR4KTtcblx0XHRcdFxuXHRcdFx0dmFyIGN1cnJMZW5ndGggPSAocHJldklkeCA9PSAtMSkgPyAoMCkgOiAobGVuZ3RoQ2hhaW5bcHJldklkeF0gKyAxKTtcblx0XHRcdFxuXHRcdFx0aWYgKGN1cnJMZW5ndGggPiBtYXhDaGFpbkxlbmd0aCkge1xuXHRcdFx0XHRtYXhDaGFpbkxlbmd0aCA9IGN1cnJMZW5ndGg7XG5cdFx0XHRcdG1heENoYWluRW5kID0gaWR4O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0bGVuZ3RoQ2hhaW4ucHVzaChjdXJyTGVuZ3RoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBzdGlja3lOb2RlcyA9IFtdO1xuXHRcdFxuXHRcdC8vIE5vdyB3ZSBjYW4gd2FsayB0aGUgbG9uZ2VzdCBjaGFpbiBiYWNrd2FyZHMgYW5kIG1hcmsgdGhlbSBhcyBcInN0aWNreVwiLFxuXHRcdC8vIHdoaWNoIGltcGxpZXMgdGhhdCB0aGV5IHNob3VsZCBub3QgYmUgbW92ZWRcblx0XHR2YXIgY3Vyc29yID0gbmV3UG9zaXRpb24ubGVuZ3RoIC0gMTtcblx0XHR3aGlsZSAoY3Vyc29yID49IDApe1xuXHRcdFx0aWYgKGN1cnNvciA9PSBtYXhDaGFpbkVuZCAmJiBuZXdQb3NpdGlvbltjdXJzb3JdICE9IC0xKSB7XG5cdFx0XHRcdHN0aWNreU5vZGVzW25ld1Bvc2l0aW9uW2N1cnNvcl1dID0gdHJ1ZTtcblx0XHRcdFx0bWF4Q2hhaW5FbmQgPSBwcmV2Q2hhaW5bbWF4Q2hhaW5FbmRdO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y3Vyc29yIC09IDE7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBBbmQgbGV0J3MgaXRlcmF0ZSBmb3J3YXJkLCBidXQgb25seSBtb3ZlIG5vbi1zdGlja3kgbm9kZXNcblx0XHRmb3IgKHZhciBpZHgxID0gMCwgYXJ5ID0gaXRlciQobmV3JCksIGxlbiA9IGFyeS5sZW5ndGg7IGlkeDEgPCBsZW47IGlkeDErKykge1xuXHRcdFx0aWYgKCFzdGlja3lOb2Rlc1tpZHgxXSkge1xuXHRcdFx0XHR2YXIgYWZ0ZXIgPSBuZXckW2lkeDEgLSAxXTtcblx0XHRcdFx0aW5zZXJ0TmVzdGVkQWZ0ZXIocm9vdCxhcnlbaWR4MV0sKGFmdGVyICYmIGFmdGVyLl9kb20pIHx8IGNhcmV0KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBzaG91bGQgdHJ1c3QgdGhhdCB0aGUgbGFzdCBpdGVtIGluIG5ldyBsaXN0IGlzIHRoZSBjYXJldFxuXHRcdHJldHVybiBsYXN0TmV3ICYmIGxhc3ROZXcuX2RvbSB8fCBjYXJldDtcblx0fTtcblx0XG5cdFxuXHQvLyBleHBlY3RzIGEgZmxhdCBub24tc3BhcnNlIGFycmF5IG9mIG5vZGVzIGluIGJvdGggbmV3IGFuZCBvbGQsIGFsd2F5c1xuXHRmdW5jdGlvbiByZWNvbmNpbGVDb2xsZWN0aW9uKHJvb3QsbmV3JCxvbGQsY2FyZXQpe1xuXHRcdHZhciBrID0gbmV3JC5sZW5ndGg7XG5cdFx0dmFyIGkgPSBrO1xuXHRcdHZhciBsYXN0ID0gbmV3JFtrIC0gMV07XG5cdFx0XG5cdFx0XG5cdFx0aWYgKGsgPT0gb2xkLmxlbmd0aCAmJiBuZXckWzBdID09PSBvbGRbMF0pIHtcblx0XHRcdC8vIHJ1bm5pbmcgdGhyb3VnaCB0byBjb21wYXJlXG5cdFx0XHR3aGlsZSAoaS0tKXtcblx0XHRcdFx0aWYgKG5ldyRbaV0gIT09IG9sZFtpXSkgeyBicmVhazsgfTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaSA9PSAtMSkge1xuXHRcdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5fZG9tIHx8IGNhcmV0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gcmVjb25jaWxlQ29sbGVjdGlvbkNoYW5nZXMocm9vdCxuZXckLG9sZCxjYXJldCk7XG5cdFx0fTtcblx0fTtcblx0XG5cdC8vIHRoZSBnZW5lcmFsIHJlY29uY2lsZXIgdGhhdCByZXNwZWN0cyBjb25kaXRpb25zIGV0Y1xuXHQvLyBjYXJldCBpcyB0aGUgY3VycmVudCBub2RlIHdlIHdhbnQgdG8gaW5zZXJ0IHRoaW5ncyBhZnRlclxuXHRmdW5jdGlvbiByZWNvbmNpbGVOZXN0ZWQocm9vdCxuZXckLG9sZCxjYXJldCl7XG5cdFx0XG5cdFx0Ly8gaWYgbmV3ID09IG51bGwgb3IgbmV3ID09PSBmYWxzZSBvciBuZXcgPT09IHRydWVcblx0XHQvLyBcdGlmIG5ldyA9PT0gb2xkXG5cdFx0Ly8gXHRcdHJldHVybiBjYXJldFxuXHRcdC8vIFx0aWYgb2xkICYmIG5ldyAhPSBvbGRcblx0XHQvLyBcdFx0cmVtb3ZlTmVzdGVkKHJvb3Qsb2xkLGNhcmV0KSBpZiBvbGRcblx0XHQvLyBcblx0XHQvLyBcdHJldHVybiBjYXJldFxuXHRcdFxuXHRcdC8vIHZhciBza2lwbmV3ID0gbmV3ID09IG51bGwgb3IgbmV3ID09PSBmYWxzZSBvciBuZXcgPT09IHRydWVcblx0XHR2YXIgbmV3SXNOdWxsID0gbmV3JCA9PSBudWxsIHx8IG5ldyQgPT09IGZhbHNlO1xuXHRcdHZhciBvbGRJc051bGwgPSBvbGQgPT0gbnVsbCB8fCBvbGQgPT09IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdGlmIChuZXckID09PSBvbGQpIHtcblx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgdGhlIGNhcmV0IG11c3QgYmUgYW4gYWN0dWFsIGRvbSBlbGVtZW50XG5cdFx0XHQvLyB3ZSBzaG91bGQgaW5zdGVhZCBtb3ZlIHRoZSBhY3R1YWwgY2FyZXQ/IC0gdHJ1c3Rcblx0XHRcdGlmIChuZXdJc051bGwpIHtcblx0XHRcdFx0cmV0dXJuIGNhcmV0O1xuXHRcdFx0fSBlbHNlIGlmIChuZXckICYmIG5ldyQuX2RvbSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3JC5fZG9tO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNhcmV0ID8gKGNhcmV0Lm5leHRTaWJsaW5nKSA6IChyb290Ll9kb20uZmlyc3RDaGlsZCk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobmV3JCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRpZiAob2xkIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0aWYgKG5ldyQuc3RhdGljIHx8IG9sZC5zdGF0aWMpIHtcblx0XHRcdFx0XHQvLyBpZiB0aGUgc3RhdGljIGlzIG5vdCBuZXN0ZWQgLSB3ZSBjb3VsZCBnZXQgYSBoaW50IGZyb20gY29tcGlsZXJcblx0XHRcdFx0XHQvLyBhbmQganVzdCBza2lwIGl0XG5cdFx0XHRcdFx0aWYgKG5ldyQuc3RhdGljID09IG9sZC5zdGF0aWMpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChuZXckKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgd2hlcmUgd2UgY291bGQgZG8gdGhlIHRyaXBsZSBlcXVhbCBkaXJlY3RseVxuXHRcdFx0XHRcdFx0XHRjYXJldCA9IHJlY29uY2lsZU5lc3RlZChyb290LGFyeVtpXSxvbGRbaV0sY2FyZXQpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiBjYXJldDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVtb3ZlTmVzdGVkKHJvb3Qsb2xkLGNhcmV0KTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGlmIHRoZXkgYXJlIG5vdCB0aGUgc2FtZSB3ZSBjb250aW51ZSB0aHJvdWdoIHRvIHRoZSBkZWZhdWx0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlY29uY2lsZUNvbGxlY3Rpb24ocm9vdCxuZXckLG9sZCxjYXJldCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKG9sZCBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdFx0cm9vdC5yZW1vdmVDaGlsZChvbGQpO1xuXHRcdFx0fSBlbHNlIGlmICghb2xkSXNOdWxsKSB7XG5cdFx0XHRcdC8vIG9sZCB3YXMgYSBzdHJpbmctbGlrZSBvYmplY3Q/XG5cdFx0XHRcdHJvb3QucmVtb3ZlQ2hpbGQoY2FyZXQgPyAoY2FyZXQubmV4dFNpYmxpbmcpIDogKHJvb3QuX2RvbS5maXJzdENoaWxkKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gaW5zZXJ0TmVzdGVkQWZ0ZXIocm9vdCxuZXckLGNhcmV0KTtcblx0XHRcdC8vIHJlbW92ZSBvbGRcblx0XHR9IGVsc2UgaWYgKG5ldyQgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRpZiAoIW9sZElzTnVsbCkgeyByZW1vdmVOZXN0ZWQocm9vdCxvbGQsY2FyZXQpIH07XG5cdFx0XHRpbnNlcnROZXN0ZWRBZnRlcihyb290LG5ldyQsY2FyZXQpO1xuXHRcdFx0cmV0dXJuIG5ldyQ7XG5cdFx0fSBlbHNlIGlmIChuZXdJc051bGwpIHtcblx0XHRcdGlmICghb2xkSXNOdWxsKSB7IHJlbW92ZU5lc3RlZChyb290LG9sZCxjYXJldCkgfTtcblx0XHRcdHJldHVybiBjYXJldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgb2xkIGRpZCBub3QgZXhpc3Qgd2UgbmVlZCB0byBhZGQgYSBuZXcgZGlyZWN0bHlcblx0XHRcdHZhciBuZXh0Tm9kZTtcblx0XHRcdC8vIGlmIG9sZCB3YXMgYXJyYXkgb3IgaW1iYXRhZyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBhbmQgdGhlbiBhZGRcblx0XHRcdGlmIChvbGQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRyZW1vdmVOZXN0ZWQocm9vdCxvbGQsY2FyZXQpO1xuXHRcdFx0fSBlbHNlIGlmIChvbGQgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRcdHJvb3QucmVtb3ZlQ2hpbGQob2xkKTtcblx0XHRcdH0gZWxzZSBpZiAoIW9sZElzTnVsbCkge1xuXHRcdFx0XHQvLyAuLi5cblx0XHRcdFx0bmV4dE5vZGUgPSBjYXJldCA/IChjYXJldC5uZXh0U2libGluZykgOiAocm9vdC5fZG9tLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRpZiAoKG5leHROb2RlIGluc3RhbmNlb2YgVGV4dCkgJiYgbmV4dE5vZGUudGV4dENvbnRlbnQgIT0gbmV3JCkge1xuXHRcdFx0XHRcdG5leHROb2RlLnRleHRDb250ZW50ID0gbmV3JDtcblx0XHRcdFx0XHRyZXR1cm4gbmV4dE5vZGU7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBub3cgYWRkIHRoZSB0ZXh0bm9kZVxuXHRcdFx0cmV0dXJuIGluc2VydE5lc3RlZEFmdGVyKHJvb3QsbmV3JCxjYXJldCk7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRyZXR1cm4gdGFnJC5leHRlbmRUYWcoJ2h0bWxlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENoaWxkcmVuID0gZnVuY3Rpb24gKG5ldyQsdHlwKXtcblx0XHRcdHZhciBvbGQgPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdC8vIHZhciBpc0FycmF5ID0gbm9kZXMgaXNhIEFycmF5XG5cdFx0XHRpZiAobmV3JCA9PT0gb2xkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKCFvbGQpIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpO1xuXHRcdFx0XHRhcHBlbmROZXN0ZWQodGhpcyxuZXckKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwID09IDIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAxKSB7XG5cdFx0XHRcdC8vIGhlcmUgd2UgX2tub3cgX3RoYXQgaXQgaXMgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBzaGFwZVxuXHRcdFx0XHQvLyBldmVyeSB0aW1lXG5cdFx0XHRcdHZhciBjYXJldCA9IG51bGw7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChuZXckKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Ly8gcHJldiA9IG9sZFtpXVxuXHRcdFx0XHRcdGNhcmV0ID0gcmVjb25jaWxlTmVzdGVkKHRoaXMsYXJ5W2ldLG9sZFtpXSxjYXJldCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAzKSB7XG5cdFx0XHRcdC8vIHRoaXMgaXMgcG9zc2libHkgZnVsbHkgZHluYW1pYy4gSXQgb2Z0ZW4gaXNcblx0XHRcdFx0Ly8gYnV0IHRoZSBvbGQgb3IgbmV3IGNvdWxkIGJlIHN0YXRpYyB3aGlsZSB0aGUgb3RoZXIgaXMgbm90XG5cdFx0XHRcdC8vIHRoaXMgaXMgbm90IGhhbmRsZWQgbm93XG5cdFx0XHRcdC8vIHdoYXQgaWYgaXQgd2FzIHByZXZpb3VzbHkgYSBzdGF0aWMgYXJyYXk/IGVkZ2VjYXNlIC0gYnV0IG11c3Qgd29ya1xuXHRcdFx0XHRpZiAobmV3JCBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdFx0XHR0aGlzLmVtcHR5KCk7XG5cdFx0XHRcdFx0dGhpcy5hcHBlbmRDaGlsZChuZXckKTtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXckIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRpZiAob2xkIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRcdC8vIGlzIHRoaXMgbm90IHRoZSBzYW1lIGFzIHNldHRpbmcgc3RhdGljQ2hpbGRyZW4gbm93IGJ1dCB3aXRoIHRoZVxuXHRcdFx0XHRcdFx0cmVjb25jaWxlQ29sbGVjdGlvbih0aGlzLG5ldyQsb2xkLG51bGwpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVtcHR5KCk7XG5cdFx0XHRcdFx0XHRhcHBlbmROZXN0ZWQodGhpcyxuZXckKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2V0VGV4dChuZXckKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoKG5ldyQgaW5zdGFuY2VvZiBBcnJheSkgJiYgKG9sZCBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRyZWNvbmNpbGVDb2xsZWN0aW9uKHRoaXMsbmV3JCxvbGQsbnVsbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCk7XG5cdFx0XHRcdGFwcGVuZE5lc3RlZCh0aGlzLG5ldyQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5fY2hpbGRyZW4gPSBuZXckO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvLyBvbmx5IGV2ZXIgY2FsbGVkIHdpdGggYXJyYXkgYXMgYXJndW1lbnRcblx0XHR0YWcucHJvdG90eXBlLnNldFN0YXRpY0NoaWxkcmVuID0gZnVuY3Rpb24gKG5ldyQpe1xuXHRcdFx0dmFyIG9sZCA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0XG5cdFx0XHR2YXIgY2FyZXQgPSBudWxsO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5ldyQpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Ly8gcHJldiA9IG9sZFtpXVxuXHRcdFx0XHRjYXJldCA9IHJlY29uY2lsZU5lc3RlZCh0aGlzLGFyeVtpXSxvbGRbaV0sY2FyZXQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5fY2hpbGRyZW4gPSBuZXckO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9jb250ZW50IHx8IHRoaXMuY2hpbGRyZW4oKS50b0FycmF5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRpZiAodGV4dCAhPSB0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0XHR0aGlzLl9jaGlsZHJlbiA9IHRleHQ7XG5cdFx0XHRcdHRoaXMuZG9tKCkudGV4dENvbnRlbnQgPSB0ZXh0ID09IG51bGwgfHwgdGV4dCA9PT0gZmFsc2UgPyAoJycpIDogKHRleHQpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5zdGF0aWMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHQvKlxuXHRUaGUgc3BlY2lhbCBzeW50YXggZm9yIHNlbGVjdG9ycyBpbiBJbWJhIGNyZWF0ZXMgSW1iYS5TZWxlY3RvclxuXHRpbnN0YW5jZXMuXG5cdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yID0gZnVuY3Rpb24gU2VsZWN0b3Ioc2VsLHNjb3BlLG5vZGVzKXtcblx0XHRcblx0XHR0aGlzLl9xdWVyeSA9IHNlbCBpbnN0YW5jZW9mIEltYmEuU2VsZWN0b3IgPyAoc2VsLnF1ZXJ5KCkpIDogKHNlbCk7XG5cdFx0dGhpcy5fY29udGV4dCA9IHNjb3BlO1xuXHRcdFxuXHRcdGlmIChub2Rlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZXMucHVzaCh0YWckd3JhcChhcnlbaV0pKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLl9ub2RlcyA9IHJlcztcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX2xhenkgPSAhbm9kZXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLm9uZSA9IGZ1bmN0aW9uIChzZWwsc2NvcGUpe1xuXHRcdHZhciBlbCA9IChzY29wZSB8fCBJbWJhLmRvY3VtZW50KCkpLnF1ZXJ5U2VsZWN0b3Ioc2VsKTtcblx0XHRyZXR1cm4gZWwgJiYgdGFnJHdyYXAoZWwpIHx8IG51bGw7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLmFsbCA9IGZ1bmN0aW9uIChzZWwsc2NvcGUpe1xuXHRcdHJldHVybiBuZXcgSW1iYS5TZWxlY3RvcihzZWwsc2NvcGUpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcXVlcnk7IH1cblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuc2V0UXVlcnkgPSBmdW5jdGlvbih2KXsgdGhpcy5fcXVlcnkgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX25vZGVzID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGN0eDtcblx0XHRpZiAodGhpcy5fc2NvcGUpIHsgcmV0dXJuIHRoaXMuX3Njb3BlIH07XG5cdFx0aWYgKCEoY3R4ID0gdGhpcy5fY29udGV4dCkpIHsgcmV0dXJuIEltYmEuZG9jdW1lbnQoKSB9O1xuXHRcdHJldHVybiB0aGlzLl9zY29wZSA9IGN0eC50b1Njb3BlID8gKGN0eC50b1Njb3BlKCkpIDogKGN0eCk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEByZXR1cm5zIHtJbWJhLlRhZ30gZmlyc3Qgbm9kZSBtYXRjaGluZyB0aGlzIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2xhenkpIHsgcmV0dXJuIHRhZyR3cmFwKHRoaXMuX2ZpcnN0IHx8ICh0aGlzLl9maXJzdCA9IHRoaXMuc2NvcGUoKS5xdWVyeVNlbGVjdG9yKHRoaXMucXVlcnkoKSkpKSB9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZXMoKVswXTtcblx0XHR9O1xuXHR9O1xuXHRcblx0Lypcblx0XHRAcmV0dXJucyB7SW1iYS5UYWd9IGxhc3Qgbm9kZSBtYXRjaGluZyB0aGlzIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlcygpW3RoaXMuX25vZGVzLmxlbmd0aCAtIDFdO1xuXHR9O1xuXHRcblx0Lypcblx0XHRAcmV0dXJucyBbSW1iYS5UYWddIGFsbCBub2RlcyBtYXRjaGluZyB0aGlzIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX25vZGVzKSB7IHJldHVybiB0aGlzLl9ub2RlcyB9O1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuc2NvcGUoKS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMucXVlcnkoKSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGl0ZW1zKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cmVzLnB1c2godGFnJHdyYXAoYXJ5W2ldKSk7XG5cdFx0fTtcblx0XHR0aGlzLl9ub2RlcyA9IHJlcztcblx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGVzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRUaGUgbnVtYmVyIG9mIG5vZGVzIG1hdGNoaW5nIHRoaXMgc2VsZWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlcygpLmxlbmd0aDtcblx0fTtcblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmxlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLm5vZGVzKCkubGVuZ3RoO1xuXHR9O1xuXHRcblx0Lypcblx0XHRAdG9kbyBBZGQgc3VwcG9ydCBmb3IgYmxvY2sgb3Igc2VsZWN0b3I/XG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jb3VudCgpID49IDE7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEdldCBub2RlIGF0IGluZGV4XG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGlkeCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKVtpZHhdO1xuXHR9O1xuXHRcblx0Lypcblx0XHRMb29wIHRocm91Z2ggbm9kZXNcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChibG9jayl7XG5cdFx0dGhpcy5ub2RlcygpLmZvckVhY2goYmxvY2spO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRNYXAgbm9kZXNcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGJsb2NrKXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlcygpLm1hcChibG9jayk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJldHVybnMgYSBwbGFpbiBhcnJheSBjb250YWluaW5nIG5vZGVzLiBJbXBsaWNpdGx5IGNhbGxlZFxuXHRcdHdoZW4gaXRlcmF0aW5nIG92ZXIgYSBzZWxlY3RvciBpbiBJbWJhIGAobm9kZSBmb3Igbm9kZSBpbiAkKHNlbGVjdG9yKSlgXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlcygpO1xuXHR9O1xuXHRcblx0Ly8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IsIFxuXHQvLyBiZWdpbm5pbmcgYXQgdGhlIGN1cnJlbnQgZWxlbWVudCBhbmQgcHJvZ3Jlc3NpbmcgdXAgdGhyb3VnaCB0aGUgRE9NIHRyZWVcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuY2xvc2VzdCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdC8vIHNlZW1zIHN0cmFuZ2UgdGhhdCB3ZSBhbHRlciB0aGlzIHNlbGVjdG9yP1xuXHRcdHRoaXMuX25vZGVzID0gdGhpcy5tYXAoZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gbm9kZS5jbG9zZXN0KHNlbCk7IH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gR2V0IHRoZSBzaWJsaW5ncyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCBvZiBtYXRjaGVkIGVsZW1lbnRzLCBcblx0Ly8gb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBhIHNlbGVjdG9yLlxuXHQvLyBUT0RPIHJlbW92ZSBkdXBsaWNhdGVzP1xuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5zaWJsaW5ncyA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdHRoaXMuX25vZGVzID0gdGhpcy5tYXAoZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gbm9kZS5zaWJsaW5ncyhzZWwpOyB9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIEdldCB0aGUgZGVzY2VuZGFudHMgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBjdXJyZW50IHNldCBvZiBtYXRjaGVkIFxuXHQvLyBlbGVtZW50cywgZmlsdGVyZWQgYnkgYSBzZWxlY3Rvci5cblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdHRoaXMuX25vZGVzID0gdGhpcy5fX3F1ZXJ5X18oc2VsLnF1ZXJ5KCksdGhpcy5ub2RlcygpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChibGspe1xuXHRcdHJldHVybiB0aGlzLmZpbHRlcihibGssZmFsc2UpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRGaWx0ZXIgdGhlIG5vZGVzIGluIHNlbGVjdG9yIGJ5IGEgZnVuY3Rpb24gb3Igb3RoZXIgc2VsZWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGJsayxib29sKXtcblx0XHRpZihib29sID09PSB1bmRlZmluZWQpIGJvb2wgPSB0cnVlO1xuXHRcdHZhciBmbiA9IChibGsgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgYmxrIHx8IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubWF0Y2hlcyhibGspOyB9O1xuXHRcdHZhciBhcnkgPSB0aGlzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGZuKG4pID09IGJvb2w7IH0pO1xuXHRcdC8vIGlmIHdlIHdhbnQgdG8gcmV0dXJuIGEgbmV3IHNlbGVjdG9yIGZvciB0aGlzLCB3ZSBzaG91bGQgZG8gdGhhdCBmb3Jcblx0XHQvLyBvdGhlcnMgYXMgd2VsbFxuXHRcdHJldHVybiBuZXcgSW1iYS5TZWxlY3RvcihcIlwiLHRoaXMuX3Njb3BlLGFyeSk7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5fX3F1ZXJ5X18gPSBmdW5jdGlvbiAocXVlcnksY29udGV4dHMpe1xuXHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgbCA9IGNvbnRleHRzLmxlbmd0aDtcblx0XHRcblx0XHR3aGlsZSAoaSA8IGwpe1xuXHRcdFx0bm9kZXMucHVzaC5hcHBseShub2Rlcyxjb250ZXh0c1tpKytdLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKTtcblx0XHR9O1xuXHRcdHJldHVybiBub2Rlcztcblx0fTtcblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLl9fbWF0Y2hlc19fID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEFkZCBzcGVjaWZpZWQgZmxhZyB0byBhbGwgbm9kZXMgaW4gc2VsZWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuZmxhZyA9IGZ1bmN0aW9uIChmbGFnKXtcblx0XHRyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZmxhZyhmbGFnKTsgfSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJlbW92ZSBzcGVjaWZpZWQgZmxhZyBmcm9tIGFsbCBub2RlcyBpbiBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS51bmZsYWcgPSBmdW5jdGlvbiAoZmxhZyl7XG5cdFx0cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihuKSB7IHJldHVybiBuLnVuZmxhZyhmbGFnKTsgfSk7XG5cdH07XG5cdFxuXHRcblx0Ly8gZGVmIEltYmEucXVlcnlTZWxlY3RvckFsbFxuXHRxJCA9IGZ1bmN0aW9uKHNlbCxzY29wZSkgeyByZXR1cm4gbmV3IEltYmEuU2VsZWN0b3Ioc2VsLHNjb3BlKTsgfTtcblx0XG5cdC8vIGRlZiBJbWJhLlNlbGVjdG9yLm9uZVxuXHRxJCQgPSBmdW5jdGlvbihzZWwsc2NvcGUpIHtcblx0XHR2YXIgZWwgPSAoc2NvcGUgfHwgSW1iYS5kb2N1bWVudCgpKS5xdWVyeVNlbGVjdG9yKHNlbCk7XG5cdFx0cmV0dXJuIGVsICYmIHRhZyR3cmFwKGVsKSB8fCBudWxsO1xuXHR9O1xuXHRcblx0XG5cdC8vIGV4dGVuZGluZyB0YWdzIHdpdGggcXVlcnktbWV0aG9kc1xuXHQvLyBtdXN0IGJlIGEgYmV0dGVyIHdheSB0byByZW9wZW4gY2xhc3Nlc1xuXHRyZXR1cm4gdGFnJC5leHRlbmRUYWcoJ2VsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uIChxKXtcblx0XHRcdHJldHVybiB0aGlzLl9kb20ucXVlcnlTZWxlY3RvckFsbChxKTtcblx0XHR9O1xuXHRcdHRhZy5wcm90b3R5cGUucXVlcnlTZWxlY3RvciA9IGZ1bmN0aW9uIChxKXtcblx0XHRcdHJldHVybiB0aGlzLl9kb20ucXVlcnlTZWxlY3RvcihxKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCBiZSBtb3ZlZCB0byBJbWJhLlRhZyBpbnN0ZWFkP1xuXHRcdC8vIG9yIHdlIHNob3VsZCBpbXBsZW1lbnQgYWxsIG9mIHRoZW0gaGVyZVxuXHRcdHRhZy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0cmV0dXJuIG5ldyBJbWJhLlNlbGVjdG9yKHNlbCx0aGlzKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvc2VsZWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciB1dGlsO1xuXHRJTURFQlVHID0gdHJ1ZTtcblx0XG5cdC8vIHd0ZiBlciBhbHQgZGV0dGU/XG5cdElNID0ge307XG5cdElNLk5FV0xJTkUgPSAnXFxuJztcblx0SU0uQ0hBUiA9IDA7XG5cdElNLldPUkRfU1RBUlQgPSAxO1xuXHRJTS5XT1JEX0VORCA9IDI7XG5cdElNLlBVTkNUVUFUSU9OX1NUQVJUID0gMztcblx0SU0uUFVOQ1RVQVRJT05fRU5EID0gNDtcblx0SU0uU1VCX1dPUkRfU1RBUlQgPSA1O1xuXHRJTS5TVUJfV09SRF9FTkQgPSA2O1xuXHRJTS5MSU5FX1NUQVJUID0gNztcblx0SU0uTElORV9FTkQgPSA4O1xuXHRJTS5FTVBUWV9MSU5FID0gOTtcblx0XG5cdElNLkZTID0gcmVxdWlyZSgnLi9jb3JlL2ZzJyk7XG5cdFxuXHR2YXIgU291cmNlTWFwID0gcmVxdWlyZSgnc291cmNlLW1hcCcpO1xuXHRcblx0Ly8gaWYgZ2xvYmFsOnJlcXVpcmVcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoXCIuL3JlZ2lvblwiKS5SZWdpb247XG5cdFxuXHRyZXF1aXJlKCcuL2hlbHBlcnMnKTtcblx0XG5cdHJlcXVpcmUoJy4vY29yZS9oaXN0b3J5Jyk7XG5cdHJlcXVpcmUoJy4vY29yZS9sb2dnZXInKTtcblx0cmVxdWlyZSgnLi9jb3JlL3Nob3J0Y3V0cycpO1xuXHRcblx0cmVxdWlyZShcIi4vdmlld3MvY2FwdG9yXCIpO1xuXHRyZXF1aXJlKFwiLi92aWV3XCIpO1xuXHRyZXF1aXJlKFwiLi9lZGl0b3JcIik7XG5cdFxuXHR2YXIgSGlnaGxpZ2h0ZXIgPSByZXF1aXJlKFwiLi9jb3JlL2hpZ2hsaWdodGVyXCIpLkhpZ2hsaWdodGVyO1xuXHR2YXIgSW1iYWNXb3JrZXIgPSByZXF1aXJlKFwiLi9jb3JlL3dvcmtlclwiKS5JbWJhY1dvcmtlcjtcblx0XG5cdElNLndvcmtlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl93b3JrZXIgfHwgKHRoaXMuX3dvcmtlciA9IG5ldyBJbWJhY1dvcmtlcigpKTtcblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLnV0aWwgPSB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcblx0Ly8gbm9kZXNcblx0cmVxdWlyZShcIi4vbm9kZXMvaW5kZXhcIik7XG5cdFxuXHRcblx0ZnVuY3Rpb24gd29ya2VyKCl7XG5cdFx0cmV0dXJuIElNLndvcmtlcigpO1xuXHR9OyBleHBvcnRzLndvcmtlciA9IHdvcmtlcjtcblx0XG5cdG1vZHVsZS5leHBvcnRzLlNvdXJjZU1hcCA9IFNvdXJjZU1hcDtcblx0bW9kdWxlLmV4cG9ydHMuUmVnaW9uID0gUmVnaW9uO1xuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHMuSGlnaGxpZ2h0ZXIgPSBIaWdobGlnaHRlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2luZGV4LmltYmFcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGV4dGVybnM7XG5cdGZ1bmN0aW9uIHNhdmUocGF0aCxjb250ZW50LGVuY29kaW5nLGNiKXtcblx0XHRpZihjYj09dW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyA9PSAnZnVuY3Rpb24nKSBjYiA9IGVuY29kaW5nLGVuY29kaW5nID0gJ3V0Zi04Jztcblx0XHRpZihlbmNvZGluZz09dW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGYtOCc7XG5cdFx0Y29uc29sZS5sb2coJ3NhdmUnLHBhdGgsY29udGVudCxlbmNvZGluZyk7XG5cdFx0XG5cdFx0cmV0dXJuIHhyLnBvc3QocGF0aCx7Ym9keTogY29udGVudH0pLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zb2xlLmxvZygncmVzcG9uZGVkJyk7XG5cdFx0XHRyZXR1cm4gY2IgJiYgY2IoYXJndW1lbnRzKTtcblx0XHR9KTtcblx0fTsgZXhwb3J0cy5zYXZlID0gc2F2ZTtcblx0XG5cdGZ1bmN0aW9uIHJlYWRGaWxlQXN5bmMocGF0aCxlbmNvZGluZyxjYil7XG5cdFx0aWYoY2I9PXVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgPT0gJ2Z1bmN0aW9uJykgY2IgPSBlbmNvZGluZyxlbmNvZGluZyA9ICd1dGYtOCc7XG5cdFx0aWYoZW5jb2Rpbmc9PXVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmLTgnO1xuXHRcdGNvbnNvbGUubG9nKCdzYXZlJyxwYXRoLGVuY29kaW5nKTtcblx0XHRcblx0XHRyZXR1cm4geHIuZ2V0KHBhdGgpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRjb25zb2xlLmxvZygncmVzcG9uZGVkJyxyZXMpO1xuXHRcdFx0Y2IgJiYgY2IoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSk7XG5cdH07IGV4cG9ydHMucmVhZEZpbGVBc3luYyA9IHJlYWRGaWxlQXN5bmM7OyByZXR1cm4gcmVhZEZpbGVBc3luYztcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvZnMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICB2YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gIHZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbiAgLyoqXG4gICAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAgICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gICAgaWYgKCFhQXJncykge1xuICAgICAgYUFyZ3MgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICAgIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICB9XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnZW5lcmF0b3I7XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAgICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICAgKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAgICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICAgKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICAgKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAgICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gICAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gICAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICAgKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAgICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gICAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICAgKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICAgIH1cbiAgICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gICAqXG4gICAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAgICogICAgICB0b2tlbi5cbiAgICpcbiAgICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gICAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgICAgLy8gQ2FzZSAxLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAgICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG1hcHBpbmc7XG4gICAgICB2YXIgbmFtZUlkeDtcbiAgICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc7JztcbiAgICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkpXG4gICAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgICB2YXIgbWFwID0ge1xuICAgICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbntcbiAgdmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbiAgLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4gIC8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuICAvLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbiAgLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuICAvLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbiAgLy9cbiAgLy8gICBDb250aW51YXRpb25cbiAgLy8gICB8ICAgIFNpZ25cbiAgLy8gICB8ICAgIHxcbiAgLy8gICBWICAgIFZcbiAgLy8gICAxMDEwMTFcblxuICB2YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbiAgLy8gYmluYXJ5OiAwMTExMTFcbiAgdmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gICAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gICAqL1xuICBmdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICByZXR1cm4gYVZhbHVlIDwgMFxuICAgICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICAgKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICAgIHJldHVybiBpc05lZ2F0aXZlXG4gICAgICA/IC1zaGlmdGVkXG4gICAgICA6IHNoaWZ0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gICAgdmFyIGRpZ2l0O1xuXG4gICAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgICBkbyB7XG4gICAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgICAgfVxuICAgICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICAgIHJldHVybiBlbmNvZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAgICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gICAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICAgIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgdmFyIGludFRvQ2hhck1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAgICogZmFpbHVyZS5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgdmFyIGJpZ0EgPSA2NTsgICAgIC8vICdBJ1xuICAgIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICAgIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgICB2YXIgbGl0dGxlWiA9IDEyMjsgLy8gJ3onXG5cbiAgICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gICAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gICAgdmFyIHBsdXMgPSA0MzsgICAgIC8vICcrJ1xuICAgIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICAgIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgICB2YXIgbnVtYmVyT2Zmc2V0ID0gNTI7XG5cbiAgICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gICAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgICAgcmV0dXJuIChjaGFyQ29kZSAtIGJpZ0EpO1xuICAgIH1cblxuICAgIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gICAgaWYgKGxpdHRsZUEgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbGl0dGxlWikge1xuICAgICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbiAgICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gNjI6ICtcbiAgICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgICAgcmV0dXJuIDYyO1xuICAgIH1cblxuICAgIC8vIDYzOiAvXG4gICAgaWYgKGNoYXJDb2RlID09IHNsYXNoKSB7XG4gICAgICByZXR1cm4gNjM7XG4gICAgfVxuXG4gICAgLy8gSW52YWxpZCBiYXNlNjQgZGlnaXQuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gICAqIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICAgKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gICAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gICAgfVxuICB9XG4gIGV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG4gIHZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xuICB2YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbiAgZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICAgIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgICBwYXRoOiBtYXRjaFs1XVxuICAgIH07XG4gIH1cbiAgZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG4gIGZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgICB2YXIgdXJsID0gJyc7XG4gICAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gICAgfVxuICAgIHVybCArPSAnLy8nO1xuICAgIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuICAvKipcbiAgICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gICAqXG4gICAqIC0gUmVwbGFjZXMgY29uc2VxdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAgICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAgICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gICAqXG4gICAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICAgIHZhciBwYXRoID0gYVBhdGg7XG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSB1cmwucGF0aDtcbiAgICB9XG4gICAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gICAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgIHVwKys7XG4gICAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgICB1cCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgIHVwLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gICAgfVxuXG4gICAgaWYgKHVybCkge1xuICAgICAgdXJsLnBhdGggPSBwYXRoO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4gIC8qKlxuICAgKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAgICpcbiAgICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICAgKlxuICAgKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICAgKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAgICogICBmaXJzdC5cbiAgICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gICAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICAgKiAgIGlzIHJldHVybmVkLlxuICAgKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gICAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAgICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgYVJvb3QgPSBcIi5cIjtcbiAgICB9XG4gICAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgICBhUGF0aCA9IFwiLlwiO1xuICAgIH1cbiAgICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgICB9XG5cbiAgICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICAgIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgICB9XG5cbiAgICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICA/IGFQYXRoXG4gICAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gICAgfVxuICAgIHJldHVybiBqb2luZWQ7XG4gIH1cbiAgZXhwb3J0cy5qb2luID0gam9pbjtcblxuICBleHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoYVBhdGgpIHtcbiAgICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgISFhUGF0aC5tYXRjaCh1cmxSZWdleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gICAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgICBhUm9vdCA9IFwiLlwiO1xuICAgIH1cblxuICAgIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAgIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gICAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gICAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICAgIHZhciBsZXZlbCA9IDA7XG4gICAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cblxuICAgICAgKytsZXZlbDtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICAgIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gICAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBmdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cbiAgZXhwb3J0cy50b1NldFN0cmluZyA9IHRvU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiBhU3RyLnN1YnN0cigxKTtcbiAgfVxuICBleHBvcnRzLmZyb21TZXRTdHJpbmcgPSBmcm9tU2V0U3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xuICB9XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gICAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICAgKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAgICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAgICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xuICB9XG4gIGV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuICBmdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gICAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAgICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gICAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xuICB9XG4gIGV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gICAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICAgKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gICAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc2V0ID0ge307XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gICAqL1xuICBBcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAgICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gICAqXG4gICAqIEByZXR1cm5zIE51bWJlclxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHZhciBpc0R1cGxpY2F0ZSA9IHRoaXMuX3NldC5oYXNPd25Qcm9wZXJ0eShzU3RyKTtcbiAgICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICAgIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgICB9XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXNPd25Qcm9wZXJ0eShzU3RyKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgaWYgKHRoaXMuX3NldC5oYXNPd25Qcm9wZXJ0eShzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAgICpcbiAgICogQHBhcmFtIE51bWJlciBhSWR4XG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gICAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAgICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAgICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbiAgfTtcblxuICBleHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICAgKiBwb3NpdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gICAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gICAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gICAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICAgKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAgICovXG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICAgIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICAgKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gICAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICAgKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqXG4gICAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICAgKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAgICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAgICogY29weS5cbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hcnJheTtcbiAgfTtcblxuICBleHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG4gIHZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApO1xuICB9XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbiAgLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbiAgLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuICAvLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbiAgLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4gIC8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbiAgLy9cbiAgLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbiAgLy9cbiAgLy8gICAgIHtcbiAgLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbiAgLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4gIC8vICAgICAgICAgICAgIGNvZGUuXG4gIC8vICAgICB9XG4gIC8vXG4gIC8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbiAgLy8gYG51bGxgLlxuICAvL1xuICAvLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuICAvL1xuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICAgIH07XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gICAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAgICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICAgKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gICAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICAgKiBAcGFyYW0gYU9yZGVyXG4gICAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gICAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICAgKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgICB2YXIgbWFwcGluZ3M7XG4gICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gICAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAgICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICAgKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICAgKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAgICpcbiAgICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwcGluZ3M7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gICAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICAgKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gICAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAgICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAgICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICAgKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAgICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICAgKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAgICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gICAqICAgICB9XG4gICAqXG4gICAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICAgKi9cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gICAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgICAgOiBzb3VyY2U7XG4gICAgICB9KTtcblxuICAgIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAgIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gICAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMsIHRydWUpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gIH1cblxuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAgICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAgICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgICAgdmFyIG5hbWVzID0gc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIHJldHVybiBzbWM7XG4gICAgfTtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICAgKi9cbiAgZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICAgIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICAgIHZhciB0ZW1wID0ge307XG4gICAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgICAgLy8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgICAgLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4gICAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBvcmlnaW5hbE1hcHBpbmdzO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICAgKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICAgKiBpbmNsdXNpdmUuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICAgIG5lZWRsZSxcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICAgICk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAgICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gICAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsYWJsZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmw7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICAgIG5lZWRsZSxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICAgICk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAgICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAgICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gICAqIGlucHV0LlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAgICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICAgKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gICAqXG4gICAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAgICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gICAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gICAqICAgICAgIGZpZWxkLlxuICAgKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAgICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAgICpcbiAgICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gICAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gICAqIHVuc3VwcG9ydGVkLlxuICAgKlxuICAgKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICAgKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICAgKlxuICAgKiAge1xuICAgKiAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgZmlsZTogXCJhcHAuanNcIixcbiAgICogICAgc2VjdGlvbnM6IFt7XG4gICAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gICAqICAgICAgbWFwOiB7XG4gICAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICAgKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICAgKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gICAqICAgICAgfVxuICAgKiAgICB9XSxcbiAgICogIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICAgKi9cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgICAgbGluZTogLTEsXG4gICAgICBjb2x1bW46IDBcbiAgICB9O1xuICAgIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocy51cmwpIHtcbiAgICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgICB9XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgICB9LFxuICAgICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3VyY2VzO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIH0pO1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICA6IDApLFxuICAgICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAgICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsYWJsZS5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlcy5pbmRleE9mKHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICAgIDogMClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICAgIHZhciBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbiAgZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAgICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgLy9cbiAgICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIC8vXG4gICAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAgIC8vICAgICAgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50LlxuICAgIC8vXG4gICAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgICAvLyAgICAgIGVsZW1lbnQgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZSByZXR1cm4gLTEuXG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gICAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAgICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAgICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICAgKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICAgKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gICAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAgICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gICAqL1xuICBleHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAgIGlmIChhSGF5c3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gICAgLy8gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci4gSG93ZXZlciwgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgc3VjaFxuICAgIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICAgIGlmIChhQ29tcGFyZShhSGF5c3RhY2tbaW5kZXhdLCBhSGF5c3RhY2tbaW5kZXggLSAxXSwgdHJ1ZSkgIT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAtLWluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3RcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbiAgLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbiAgLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4gIC8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbiAgLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbiAgLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2ZcbiAgLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbiAgLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4gIC8qKlxuICAgKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gICAqICAgICAgICBUaGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICAgKi9cbiAgZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgICBhcnlbeF0gPSBhcnlbeV07XG4gICAgYXJ5W3ldID0gdGVtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICAgKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAgICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gICAqL1xuICBmdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAgICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAgICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAgICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICAgKiBAcGFyYW0ge051bWJlcn0gclxuICAgKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICAgKi9cbiAgZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gICAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gICAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAgIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICAgIGlmIChwIDwgcikge1xuICAgICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgICAgdmFyIGkgPSBwIC0gMTtcblxuICAgICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAgIC8vIHRydWU6XG4gICAgICAvL1xuICAgICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgICAgLy9cbiAgICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgICAgdmFyIHEgPSBpICsgMTtcblxuICAgICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAgICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAgICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAgICovXG4gIGV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xuICB9O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuICAvLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG4gIHZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbiAgLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG4gIHZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuICAvLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4gIC8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4gIC8vIHZlcnNpb25zIVxuICB2YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gICAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICAgKlxuICAgKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gICAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gICAqL1xuICBTb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXksIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgICB2YXIgbmV3TGluZSA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG4gICAgICB9O1xuXG4gICAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICAgIGlmIChyZW1haW5pbmdMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5qb2luKFwiXCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGFDaHVuaykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gICAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAgICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICAgIHZhciBjaHVuaztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICAgKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAgICpcbiAgICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICAgIHZhciBuZXdDaGlsZHJlbjtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgICAgfVxuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICAgKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAgICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAgICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzdHIgKz0gY2h1bms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICAgKiBtYXAuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgICBjb2RlOiBcIlwiLFxuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xuICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gUmVnaW9uKGEsYixyb290LHZpZXcpe1xuXHRcdHRoaXMuX2EgPSBhO1xuXHRcdHRoaXMuX2IgPSBiO1xuXHRcdHRoaXMuX3Jvb3QgPSByb290O1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5SZWdpb24gPSBSZWdpb247IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmEgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2E7IH1cblx0UmVnaW9uLnByb3RvdHlwZS5zZXRBID0gZnVuY3Rpb24odil7IHRoaXMuX2EgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2I7IH1cblx0UmVnaW9uLnByb3RvdHlwZS5zZXRCID0gZnVuY3Rpb24odil7IHRoaXMuX2IgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0UmVnaW9uLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH1cblx0UmVnaW9uLnByb3RvdHlwZS5zZXRSb290ID0gZnVuY3Rpb24odil7IHRoaXMuX3Jvb3QgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdC8vIHJlbW92ZSByb290IGZyb20gcmVnaW9uXG5cdFxuXHRSZWdpb24ubm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCx2aWV3KXtcblx0XHR2YXIgbGluZV87XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIFJlZ2lvbikgeyByZXR1cm4gdmFsIH07XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7IHJldHVybiBuZXcgUmVnaW9uKHZhbFswXSx2YWxbMV0sbnVsbCx2aWV3KSB9O1xuXHRcdGlmICgodHlwZW9mIHZhbD09J251bWJlcid8fHZhbCBpbnN0YW5jZW9mIE51bWJlcikpIHsgcmV0dXJuIG5ldyBSZWdpb24odmFsLHZhbCxudWxsLHZpZXcpIH07XG5cdFx0XG5cdFx0aWYgKCh2YWwgaW5zdGFuY2VvZiBPYmplY3QpICYmICh0eXBlb2YgKGxpbmVfID0gdmFsLmxpbmUpPT0nbnVtYmVyJ3x8bGluZV8gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG5cdFx0XHR2YXIgbGluZXMgPSB2aWV3Ll9idWZmZXIubGluZXMoKTtcblx0XHRcdHZhciBsb2MgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGxpbmVzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGlmIChpIDwgKHZhbC5saW5lIC0gMSkpIHtcblx0XHRcdFx0XHRsb2MgKz0gYXJ5W2ldLmxlbmd0aCArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRsb2MgKz0gKHZhbC5jb2x1bW4gfHwgMCk7XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2lvbihsb2MsbG9jLG51bGwsdmlldyk7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIE1hdGgubWluKHRoaXMuX2EsdGhpcy5fYik7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBNYXRoLm1heCh0aGlzLl9hLHRoaXMuX2IpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChhZCxiZCl7XG5cdFx0aWYoYWQgPT09IHVuZGVmaW5lZCkgYWQgPSAwO1xuXHRcdGlmKGJkID09PSB1bmRlZmluZWQpIGJkID0gMDtcblx0XHRyZXR1cm4gbmV3IFJlZ2lvbih0aGlzLl9hICsgYWQsdGhpcy5fYiArIGJkLHRoaXMuX3Jvb3QsdGhpcy5fdmlldyk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHJlbCl7XG5cdFx0aWYgKHJlbCBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQoKSA8PSByZWwuc3RhcnQoKSAmJiB0aGlzLmVuZCgpID49IHJlbC5lbmQoKTtcblx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgcmVsPT0nbnVtYmVyJ3x8cmVsIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQoKSA8PSByZWwgJiYgdGhpcy5lbmQoKSA+PSByZWw7XG5cdFx0fTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuYWRqdXN0ID0gZnVuY3Rpb24gKHJlbCxhZGQpe1xuXHRcdGlmKGFkZCA9PT0gdW5kZWZpbmVkKSBhZGQgPSB0cnVlO1xuXHRcdGlmIChyZWwuZW5kKCkgPCB0aGlzLnN0YXJ0KCkpIHtcblx0XHRcdGFkZCA/ICh0aGlzLm1vdmUocmVsLnNpemUoKSkpIDogKHRoaXMubW92ZSgtcmVsLnNpemUoKSkpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAocmVsKXtcblx0XHQvLyBpcyB0aGlzIGRlY2VudD9cblx0XHRyZWwgPSBSZWdpb24ubm9ybWFsaXplKHJlbCk7XG5cdFx0dmFyIGEgPSBNYXRoLm1heCh0aGlzLnN0YXJ0KCkscmVsLnN0YXJ0KCkpO1xuXHRcdHZhciBiID0gTWF0aC5taW4odGhpcy5lbmQoKSxyZWwuZW5kKCkpO1xuXHRcdHJldHVybiBiID49IGE7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnJlbGF0aXZlVG8gPSBmdW5jdGlvbiAocmVsKXtcblx0XHQvLyBjb3VsZCB1c2UgbW92ZSBpbnN0ZWFkXG5cdFx0cmV0dXJuIG5ldyBSZWdpb24odGhpcy5fYSAtIHJlbC5zdGFydCgpLHRoaXMuX2IgLSByZWwuc3RhcnQoKSx0aGlzLl9yb290LHRoaXMuX3ZpZXcpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocmVnaW9uKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJlZ2lvbil7XG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQoKSA9PSByZWdpb24uc3RhcnQoKSAmJiB0aGlzLmVuZCgpID09IHJlZ2lvbi5lbmQoKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2FtZSA9IGZ1bmN0aW9uIChyZWdpb24pe1xuXHRcdHJldHVybiByZWdpb24gJiYgcmVnaW9uLmEoKSA9PSB0aGlzLmEoKSAmJiByZWdpb24uYigpID09IHRoaXMuYigpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZW5kKCkgLSB0aGlzLnN0YXJ0KCk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAobnVtKXtcblx0XHRpZihudW0gPT09IHVuZGVmaW5lZCkgbnVtID0gMTtcblx0XHR0aGlzLl9hICs9IG51bTtcblx0XHR0aGlzLl9iICs9IG51bTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuY29sbGFwc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuc2l6ZSgpID09IDA7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYSA9IHRoaXMuX2EsYiA9IHRoaXMuX2I7XG5cdFx0dGhpcy5fYSA9IGI7XG5cdFx0dGhpcy5fYiA9IGE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnJldmVyc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2EgPiB0aGlzLl9iO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYSA9IHRoaXMuc3RhcnQoKTtcblx0XHR2YXIgYiA9IHRoaXMuZW5kKCk7XG5cdFx0dGhpcy5fYSA9IGE7XG5cdFx0dGhpcy5fYiA9IGI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24gKGZvcndhcmQpe1xuXHRcdGlmKGZvcndhcmQgPT09IHVuZGVmaW5lZCkgZm9yd2FyZCA9IHRydWU7XG5cdFx0aWYgKGZvcndhcmQpIHtcblx0XHRcdHRoaXMuX2EgPSB0aGlzLl9iID0gdGhpcy5lbmQoKTtcblx0XHRcdC8vIEBhID0gQGJcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYiA9IHRoaXMuX2E7XG5cdFx0XHR0aGlzLl9hID0gdGhpcy5fYiA9IHRoaXMuc3RhcnQoKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gZXhwYW5kIHRvIGNsb3Nlc3QgL25cblx0UmVnaW9uLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAoYXRTdGFydCxhdEVuZCl7XG5cdFx0aWYgKHRoaXMuYigpIDwgdGhpcy5hKCkpIHtcblx0XHRcdHRoaXMuX2IgKz0gYXRTdGFydDtcblx0XHRcdHRoaXMuX2EgKz0gYXRFbmQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2EgKz0gYXRTdGFydDtcblx0XHRcdHRoaXMuX2IgKz0gYXRFbmQ7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnZpZXcoKS5zdWJzdHIodGhpcyk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIChcIltcIiArICh0aGlzLl9hKSArIFwiLFwiICsgKHRoaXMuX2IpICsgXCJdXCIpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKGluY2x1ZGVFbmRzKXtcblx0XHRpZihpbmNsdWRlRW5kcyA9PT0gdW5kZWZpbmVkKSBpbmNsdWRlRW5kcyA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXMudmlldygpLm5vZGVzSW5SZWdpb24odGhpcyxpbmNsdWRlRW5kcyk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnByZXZOb2RlID0gZnVuY3Rpb24gKHF1ZXJ5KXtcblx0XHR2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKGZhbHNlKTtcblx0XHR2YXIgbm9kZSA9IG5vZGVzLmxmdDtcblx0XHRpZiAoKHF1ZXJ5IGluc3RhbmNlb2YgSW1iYS5TZWxlY3RvcikgfHwgKHR5cGVvZiBxdWVyeT09J3N0cmluZyd8fHF1ZXJ5IGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0dmFyICQxO3doaWxlIChub2RlKXtcblx0XHRcdFx0aWYgKG5vZGUubWF0Y2hlcyhxdWVyeSkpIHsgcmV0dXJuIG5vZGUgfTtcblx0XHRcdFx0bm9kZSA9ICgkMSA9IG5vZGUpICYmICQxLmlzTGFzdCAgJiYgICQxLmlzTGFzdCgpID8gKG5vZGUucGFyZW50KCkpIDogKG51bGwpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLm5leHROb2RlID0gZnVuY3Rpb24gKHF1ZXJ5KXtcblx0XHR2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKGZhbHNlKTtcblx0XHR2YXIgbm9kZSA9IG5vZGVzLnJndDtcblx0XHRpZiAoKHF1ZXJ5IGluc3RhbmNlb2YgSW1iYS5TZWxlY3RvcikgfHwgKHR5cGVvZiBxdWVyeT09J3N0cmluZyd8fHF1ZXJ5IGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0dmFyICQxO3doaWxlIChub2RlKXtcblx0XHRcdFx0aWYgKG5vZGUubWF0Y2hlcyhxdWVyeSkpIHsgcmV0dXJuIG5vZGUgfTtcblx0XHRcdFx0bm9kZSA9ICgkMSA9IG5vZGUpICYmICQxLmlzRmlyc3QgICYmICAkMS5pc0ZpcnN0KCkgPyAobm9kZS5wYXJlbnQoKSkgOiAobnVsbCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbiAocXVlcnkpe1xuXHRcdHZhciBub2RlcyA9IHRoaXMubm9kZXMoZmFsc2UpO1xuXHRcdHZhciBub2RlO1xuXHRcdGlmIChub2Rlcy5sZnQpIHtcblx0XHRcdG5vZGUgPSBub2Rlcy5sZnQudXAocXVlcnkpO1xuXHRcdH0gZWxzZSBpZiAobm9kZXMucmd0KSB7XG5cdFx0XHRub2RlIHx8IChub2RlID0gbm9kZXMucmd0LnVwKHF1ZXJ5KSk7XG5cdFx0fSBlbHNlIGlmIChub2Rlc1swXSkge1xuXHRcdFx0bm9kZSB8fCAobm9kZSA9IG5vZGVzWzBdLm5vZGUuY2xvc2VzdChxdWVyeSkpO1xuXHRcdH07XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmJ1ZmZlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9yb290LmNvZGUoKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuc3RhcnRBdExpbmUgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcigpO1xuXHRcdHZhciBhID0gdGhpcy5zdGFydCgpO1xuXHRcdFxuXHRcdGlmIChidWZmZXJbYV0gPT0gJ1xcbicgJiYgdGhpcy5zaXplKCkgPT0gMCkge1xuXHRcdFx0YS0tOyAvLyBpZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiBhIGxpbmVcblx0XHR9O1xuXHRcdFxuXHRcdHdoaWxlIChhID49IDAgJiYgYnVmZmVyW2FdICE9ICdcXG4nKXtcblx0XHRcdGEtLTtcblx0XHR9O1xuXHRcdHRoaXMuX2EgPSBhO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5lbmRBdExpbmUgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcigpO1xuXHRcdHZhciBiID0gKHRoaXMuZW5kKCkgLSAxKTtcblx0XHR3aGlsZSAoYiA+PSAwICYmIGJ1ZmZlcltiXSAmJiBidWZmZXJbYl0gIT0gJ1xcbicpe1xuXHRcdFx0YisrO1xuXHRcdH07XG5cdFx0dGhpcy5fYiA9IGI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmNlbGwgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52aWV3KCkuX2J1ZmZlci5sb2NUb0NlbGwodGhpcy5hKCkpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yb3cgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jZWxsKClbMF07XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmNvbCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmNlbGwoKVsxXTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucGVla2JlaGluZCA9IGZ1bmN0aW9uIChsZW4pe1xuXHRcdGlmKGxlbiA9PT0gdW5kZWZpbmVkKSBsZW4gPSAxO1xuXHRcdHJldHVybiBsZW4gPT0gMSA/ICh0aGlzLmJ1ZmZlcigpW3RoaXMuc3RhcnQoKSAtIDFdKSA6ICh0aGlzLmJ1ZmZlcigpLnN1YnN0cmluZyh0aGlzLnN0YXJ0KCkgLSBsZW4sdGhpcy5zdGFydCgpKSk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnBlZWthaGVhZCA9IGZ1bmN0aW9uIChsZW4pe1xuXHRcdGlmKGxlbiA9PT0gdW5kZWZpbmVkKSBsZW4gPSAxO1xuXHRcdHJldHVybiBsZW4gPT0gMSA/ICh0aGlzLmJ1ZmZlcigpW3RoaXMuZW5kKCldKSA6ICh0aGlzLmJ1ZmZlcigpLnN1YnN0cih0aGlzLmVuZCgpLGxlbikpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0QXRMaW5lKCkudGV4dCgpLm1hdGNoKC9eXFxuPyhcXHQqKS8pWzFdO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKGJlZm9yZSxhZnRlcil7XG5cdFx0aWYoYmVmb3JlID09PSB1bmRlZmluZWQpIGJlZm9yZSA9IDA7XG5cdFx0aWYoYWZ0ZXIgPT09IHVuZGVmaW5lZCkgYWZ0ZXIgPSAwO1xuXHRcdHJldHVybiB0aGlzLmNsb25lKGJlZm9yZSxhZnRlcikudGV4dCgpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5sbG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHtzdGFydExpbmU6IDAsc3RhcnRDb2w6IDJ9O1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuYSgpLHRoaXMuYigpXTtcblx0fTtcblx0cmV0dXJuIFJlZ2lvbjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL3JlZ2lvbi5pbWJhXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0XG5cdHZhciBLRVlXT1JEUyA9ICd2YXIgaWYgZWxpZiBlbHNlIGZvciB3aGlsZSBkZWYgaW4gaXNhIHdoaWxlIHVudGlsIHN3aXRjaCB3aGVuIHRoZW4gcmV0dXJuIGNsYXNzIHRhZyBsZXQgZG8gYW5kIG9yIHByb3AgYXR0ciBpbiBwcm9wJy5zcGxpdCgnICcpO1xuXHR2YXIgT1BTID0gJysgLSAqIC8gPSArKyAtLSA9PSA9PT0gIT0gIT09ID4gPCA+PSA8PSAmICYmIHwgfHwgb3IgLiA6ID8nLnNwbGl0KCcgJyk7XG5cdFxuXHR2YXIgV0hJVEVTUEFDRSA9IC9eWyBcXHRcXG5dKyQvO1xuXHRcblx0SU0uSEwgPSB7XG5cdFx0bmV3bGluZTogXCI8YiBjbGFzcz0nX2ltbmV3bGluZSc+XFxuPC9iPlwiLFxuXHRcdHNwYWNlOiBmdW5jdGlvbihtKSB7IHJldHVybiAoXCI8YiBjbGFzcz0nX2ltc3BhY2UnPlwiICsgbSArIFwiPC9iPlwiKTsgfSxcblx0XHR0YWI6IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG5ldyBBcnJheShtLmxlbmd0aCArIDEpLmpvaW4oXCI8YiBjbGFzcz0nX2ltdGFiJz5cXHQ8L2I+XCIpOyB9XG5cdH07XG5cdFxuXHRcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4vcmVnaW9uJykuUmVnaW9uO1xuXHR2YXIgSGlnaGxpZ2h0ZXIgPSByZXF1aXJlKCcuL2NvcmUvaGlnaGxpZ2h0ZXInKS5IaWdobGlnaHRlcjtcblx0XG5cdHZhciBNQVRDSEVSUyA9IHtcblx0XHRrZXl3b3JkOiBmdW5jdGlvbih2KSB7IHJldHVybiBLRVlXT1JEUy5pbmRleE9mKHYpID49IDA7IH0sXG5cdFx0c2VsZjogL14odGhpc3xzZWxmKSQvLFxuXHRcdGNvbnN0OiBmdW5jdGlvbih2KSB7IHJldHVybiAoL15bQS1aXVtcXHdcXF9dKiQvKS50ZXN0KHYpOyB9LFxuXHRcdGl2YXI6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuICgvXkBbXFx3XFxfXSskLykudGVzdCh2KTsgfSxcblx0XHRib29sOiBmdW5jdGlvbih2KSB7IHJldHVybiAoL14odHJ1ZXx5ZXN8ZmFsc2V8bm98bnVsbHx1bmRlZmluZWQpJC8pLnRlc3Qodik7IH0sXG5cdFx0aWRlbnRpZmllcjogL15bXFwkYS16X11bXFx3XFxfXFwkXSooXFwtW1xcJFxcd1xcX10rKSokLyxcblx0XHRmbG9hdDogL15cXGQrXFwuXFxkKyQvLFxuXHRcdGludDogL15cXGQrJC8sXG5cdFx0Y29tbWVudDogL15cXCMoWyBcXHRdW15cXG5dKik/JC9cblx0fTtcblx0XG5cdHZhciBNT0RFUyA9IHtcblx0XHRhbGw6IE9iamVjdC5rZXlzKE1BVENIRVJTKVxuXHR9O1xuXHRcblx0XG5cdFx0XG5cdFx0U3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbiAobnVtKXtcblx0XHRcdHJldHVybiBuZXcgQXJyYXkobnVtICsgMSkuam9pbih0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFN0cmluZy5wcm90b3R5cGUuaW5zID0gZnVuY3Rpb24gKHN0cixyZWdpb24pe1xuXHRcdFx0dmFyIHRleHQgPSB0aGlzLnRvU3RyaW5nKCk7XG5cdFx0XHRpZiAocmVnaW9uID09ICdhcHBlbmQnKSB7XG5cdFx0XHRcdHJldHVybiB0ZXh0ICsgc3RyO1xuXHRcdFx0fSBlbHNlIGlmIChyZWdpb24gPT0gJ3ByZXBlbmQnKSB7XG5cdFx0XHRcdHJldHVybiBcIlwiICsgc3RyICsgdGV4dDtcblx0XHRcdH0gZWxzZSBpZiAocmVnaW9uIGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHRcdHJldHVybiB0ZXh0LnN1YnN0cigwLHJlZ2lvbi5zdGFydCgpKSArIHN0ciArIHRleHQuc2xpY2UocmVnaW9uLmVuZCgpKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBpc1doaXRlc3BhY2Uoc3RyKXtcblx0XHRyZXR1cm4gV0hJVEVTUEFDRS50ZXN0KHN0cik7XG5cdH07IGV4cG9ydHMuaXNXaGl0ZXNwYWNlID0gaXNXaGl0ZXNwYWNlO1xuXHRcblx0SU0ubnVtID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0cmV0dXJuIHRhZyQuJGltbnVtKCkuZmxhZygnbnVtYmVyJykuc2V0VGV4dCh2YWwpLmVuZCgpO1xuXHR9O1xuXHRcblx0SU0udGFiID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRhZyQuJGltdGFiKCkuc2V0VGV4dCgnXFx0JykuZW5kKCk7XG5cdH07XG5cdFxuXHRJTS5uZXdsaW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRhZyQuJGltbmV3bGluZSgpLnNldFRleHQoJ1xcbicpLmVuZCgpO1xuXHR9O1xuXHRcblx0SU0ub3AgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gdGFnJC4kaW1vcCgpLmZsYWcoJ29wJykuc2V0VGV4dCh2YWwpLmVuZCgpO1xuXHR9O1xuXHRcblx0XG5cdElNLnRvayA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdGlmICh2YWwgJiYgdmFsLl9kb20pIHsgcmV0dXJuIHZhbCB9O1xuXHRcdGlmICh2YWwubWF0Y2goV0hJVEVTUEFDRSkpIHsgcmV0dXJuIElNLnBhcnNlV2hpdGVzcGFjZSh2YWwpIH07XG5cdFx0aWYgKE9QUy5pbmRleE9mKHZhbCkgPj0gMCkgeyByZXR1cm4gSU0ub3AodmFsKSB9OyAvLyBzaG91bGQgdXNlIHRva2VuIGRpcmVjdGx5XG5cdFx0Ly8gcmV0dXJuIElNLm51bSh2YWwpIGlmIHZhbC5tYXRjaCgvXlxcZCsoXFwuXFxkKyk/JC8pICMgc2hvdWxkIHVzZSB0b2tlbiBkaXJlY3RseVxuXHRcdHJldHVybiB0YWckLiRpbXRvaygpLnNldFRleHQodmFsKS5lbmQoKTtcblx0fTtcblx0XG5cdElNLnJhdyA9IGZ1bmN0aW9uICh2YWwsY3R4KXtcblx0XHRyZXR1cm4gdGFnJC4kaW1yYXcoKS5zZXRSYXcodmFsKS5lbmQoKTtcblx0fTtcblx0XG5cdElNLmlzV2hpdGVzcGFjZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHJldHVybiBXSElURVNQQUNFLnRlc3QodmFsKTtcblx0fTtcblx0XG5cdElNLmlzT3AgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gT1BTLmluZGV4T2YodmFsKSA+PSAwO1xuXHR9O1xuXHRcblx0SU0ucGFyc2VXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKHRleHQscmljaCl7XG5cdFx0aWYocmljaCA9PT0gdW5kZWZpbmVkKSByaWNoID0gdHJ1ZTtcblx0XHR2YXIgaGwgPSBJTS5ITDtcblx0XHRcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXFxufFsgXSt8W1xcdF0rKS9nLGZ1bmN0aW9uKG0sbCkge1xuXHRcdFx0aWYgKGwgPT0gJ1xcbicpIHtcblx0XHRcdFx0cmV0dXJuIGhsLm5ld2xpbmUgfHwgJ1xcbic7XG5cdFx0XHR9IGVsc2UgaWYgKGxbMF0gPT0gJyAnKSB7XG5cdFx0XHRcdHJldHVybiBobC5zcGFjZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gKGhsLnNwYWNlKGwpKSA6IChsKTtcblx0XHRcdH0gZWxzZSBpZiAobFswXSA9PSAnXFx0Jykge1xuXHRcdFx0XHRyZXR1cm4gaGwudGFiIGluc3RhbmNlb2YgRnVuY3Rpb24gPyAoaGwudGFiKGwpKSA6IChsKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKHJpY2ggJiYgdGV4dC5pbmRleE9mKCc8JykgPj0gMCkge1xuXHRcdFx0cmV0dXJuIHRhZyQuJGltZnJhZ21lbnQoKS5zZXRDb250ZW50KHRleHQsMCkuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGV4dDtcblx0fTtcblx0XG5cdElNLmlkZW50aWZ5ID0gZnVuY3Rpb24gKHZhbCxtb2RlKXtcblx0XHRpZihtb2RlID09PSB1bmRlZmluZWQpIG1vZGUgPSAnYWxsJztcblx0XHR2YXIgcnVsZXMgPSBNT0RFU1ttb2RlXTtcblx0XHR2YXIgcmVzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChydWxlcyksIGxlbiA9IGFyeS5sZW5ndGgsIG5hbWU7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0bmFtZSA9IGFyeVtpXTtcblx0XHRcdHZhciBydWxlID0gTUFUQ0hFUlNbbmFtZV07XG5cdFx0XHRcblx0XHRcdGlmIChydWxlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0cmVzID0gcnVsZSh2YWwsbW9kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdFx0cmVzID0gcnVsZS50ZXN0KHZhbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAocmVzKSB7XG5cdFx0XHRcdHJldHVybiByZXMgPT09IHRydWUgPyAobmFtZSkgOiAocmVzKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdElNLnBhcnNlID0gZnVuY3Rpb24gKGNvZGUsY29udGV4dCl7XG5cdFx0Ly8gZGVjaWRlIGlmIGZ1bGw/XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJwYXJzZSBjb2RlIHtjb2RlOmxlbmd0aH0ge2NvZGUuc3Vic3RyKDAsMjApfVwiXG5cdFx0aWYgKHR5cGVvZiBjb2RlICE9ICdzdHJpbmcnKSB7IHJldHVybiBjb2RlIH07XG5cdFx0XG5cdFx0aWYgKFdISVRFU1BBQ0UudGVzdChjb2RlKSkge1xuXHRcdFx0cmV0dXJuIElNLnBhcnNlV2hpdGVzcGFjZShjb2RlLGZhbHNlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciB3cyA9IGNvZGUubWF0Y2goL14oWyBcXHRdKikoW15dKj8pKFsgXFx0XSopJC8pIHx8IFsnJywnJyxjb2RlLCcnXTtcblx0XHR2YXIgaGw7XG5cdFx0XG5cdFx0aWYgKHdzWzFdIHx8IHdzWzNdKSB7XG5cdFx0XHRjb2RlID0gd3NbMl07XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgaWQgPSBJTS5pZGVudGlmeShjb2RlKTtcblx0XHRcblx0XHRpZiAoaWQpIHtcblx0XHRcdHZhciB0eXAgPSAnc3Bhbic7XG5cdFx0XHR2YXIgY2xzID0gSGlnaGxpZ2h0ZXIuTWFwcGluZ1tpZF0gfHwgaWQ7IC8vIHRoaXMgaXMgdGhlIGlzc3VlLCBubz9cblx0XHRcdFxuXHRcdFx0aWYgKGNscyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdHR5cCA9IGNsc1swXTtcblx0XHRcdFx0Y2xzID0gY2xzWzFdO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKCFjbHMubWF0Y2goL1xcYl9bXFx3XS8pKSB7IGNscyA9ICdfaW10b2sgJyArIGNscyB9O1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3BhcnNlZCBhcyB0eXBlJyxpZCxjbHNcblx0XHRcdGhsID0gJzwnICsgdHlwICsgJyBjbGFzcz1cIicgKyBjbHMgKyAnXCI+JyArIGNvZGUgKyAnPC8nICsgdHlwICsgJz4nO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCFobCkge1xuXHRcdFx0aGwgPSBIaWdobGlnaHRlci5oaWdobGlnaHQoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAod3MpIHtcblx0XHRcdGhsID0gSU0ucGFyc2VXaGl0ZXNwYWNlKHdzWzFdLGZhbHNlKSArIGhsICsgSU0ucGFyc2VXaGl0ZXNwYWNlKHdzWzNdLGZhbHNlKTtcblx0XHR9O1xuXHRcdGlmIChobCkge1xuXHRcdFx0cmV0dXJuIGhsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gY29kZTtcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdHJldHVybiBJTS50ZXh0Tm9kZXMgPSBmdW5jdGlvbiAocm9vdCxtYXJrKXtcblx0XHQvLyBjb25zb2xlLnRpbWUoJ3RleHROb2RlczInKVxuXHRcdGlmKG1hcmsgPT09IHVuZGVmaW5lZCkgbWFyayA9IGZhbHNlO1xuXHRcdHJvb3QgPSByb290Ll9kb20gfHwgcm9vdDtcblx0XHR2YXIgZWw7XG5cdFx0dmFyIG5vZGVzID0gW107XG5cdFx0dmFyIHBvcyA9IDA7XG5cdFx0dmFyIHdhbGsgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHJvb3QsTm9kZUZpbHRlci5TSE9XX1RFWFQsbnVsbCxmYWxzZSk7XG5cdFx0XG5cdFx0d2hpbGUgKGVsID0gd2Fsay5uZXh0Tm9kZSgpKXtcblx0XHRcdGlmIChtYXJrKSB7XG5cdFx0XHRcdHZhciBsZW4gPSBlbC5sZW5ndGg7XG5cdFx0XHRcdGVsLl9sb2MgPSBwb3M7XG5cdFx0XHRcdHBvcyArPSBsZW47XG5cdFx0XHR9O1xuXHRcdFx0bm9kZXMucHVzaChlbCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gbm9kZXM7XG5cdH07XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9oZWxwZXJzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHQvLyB2YXIgaW1iYWMgPSBnbG9iYWwuSW1iYWNcblx0dmFyIExleGVyID0gcmVxdWlyZSgnaW1iYS9zcmMvY29tcGlsZXIvbGV4ZXInKS5MZXhlcjtcblx0XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cdFxuXHR2YXIgTk9ERVRZUEUgPSAnYic7XG5cdHZhciBLRVlXT1JEUyA9IFtcblx0XHQnbnVsbCcsJ3RoaXMnLFxuXHRcdCdkZWxldGUnLCd0eXBlb2YnLCdpbicsJ2luc3RhbmNlb2YnLFxuXHRcdCd0aHJvdycsJ2JyZWFrJywnY29udGludWUnLCdkZWJ1Z2dlcicsXG5cdFx0J2lmJywnZWxzZScsJ3N3aXRjaCcsJ2ZvcicsJ3doaWxlJywnZG8nLCd0cnknLCdjYXRjaCcsJ2ZpbmFsbHknLFxuXHRcdCdjbGFzcycsJ2V4dGVuZHMnLCdzdXBlcicsJ3JldHVybicsXG5cdFx0J3VuZGVmaW5lZCcsJ3RoZW4nLCd1bmxlc3MnLCd1bnRpbCcsJ2xvb3AnLCdvZicsJ2J5Jyxcblx0XHQnd2hlbicsJ2RlZicsJ3RhZycsJ2RvJywnZWxpZicsJ2JlZ2luJywndmFyJywnbGV0Jywnc2VsZicsJ2F3YWl0JywnaW1wb3J0Jyxcblx0XHQnYW5kJywnb3InLCdpcycsJ2lzbnQnLCdub3QnLCdpc2EnLCdjYXNlJywnbmlsJ1xuXHRdO1xuXHRcblx0dmFyIGNsYXNzZXMgPSB7XG5cdFx0JysnOiAnX2ltb3Agb3AgYWRkIG1hdGgnLFxuXHRcdCcrKyc6ICdfaW1vcCBvcCBpbmNyIG1hdGgnLFxuXHRcdCctLSc6ICdfaW1vcCBvcCBkZWNyIG1hdGgnLFxuXHRcdCctJzogJ19pbW9wIG9wIHN1YiBtYXRoJyxcblx0XHQnPSc6ICdfaW1vcCBvcCBlcScsXG5cdFx0Jy8nOiAnX2ltb3Agb3AgZGl2IG1hdGgnLFxuXHRcdCcqJzogJ19pbW9wIG9wIG11bHQgbWF0aCcsXG5cdFx0Jz8nOiAnX2ltb3Agb3AgdGVybmFyeScsXG5cdFx0JywnOiAnX2ltb3Agb3AgY29tbWEnLFxuXHRcdCc6JzogJ19pbW9wIG9wIGNvbG9uJyxcblx0XHQnLic6ICdfaW1vcCBvcCBkb3QnLFxuXHRcdCcuOic6ICdfaW1vcCBvcCBjZG90Jyxcblx0XHQnISc6ICdfaW1vcCBvcCB1bmFyeScsXG5cdFx0Jz8uJzogJ19pbW9wIG9wIHFkb3QnLFxuXHRcdCdbJzogJ19pbW9wZW4gc2Igc2JsJyxcblx0XHQnXSc6ICdfaW1jbG9zZSBzYiBzYnInLFxuXHRcdCcoJzogJ19pbW9wZW4gcmIgcmJsJyxcblx0XHQnKSc6ICdfaW1jbG9zZSByYiByYnInLFxuXHRcdCd7JzogJ19pbW9wZW4gY2IgY2JsJyxcblx0XHQnfSc6ICdfaW1jbG9zZSBjYiBjYnInLFxuXHRcdCcjJzogJ19pbW9wIG9wIGhhc2gnLFxuXHRcdCdjYWxsX3N0YXJ0JzogJ19pbW9wZW4gY2FsbCByYiByYmwnLFxuXHRcdCdjYWxsX2VuZCc6ICdfaW1jbG9zZSBjYWxsIHJiIHJicicsXG5cdFx0J3RhZ19zdGFydCc6ICdfaW1vcGVuIHRhZ19vcGVuJyxcblx0XHQndGFnX2VuZCc6ICdfaW1jbG9zZSB0YWdfY2xvc2UnLFxuXHRcdFxuXHRcdCd0cnVlJzogJ19pbWJvb2wgdHJ1ZScsXG5cdFx0J3llcyc6ICdfaW1ib29sIHRydWUnLFxuXHRcdCdmYWxzZSc6ICdfaW1ib29sIGZhbHNlJyxcblx0XHQnbm8nOiAnX2ltYm9vbCBmYWxzZScsXG5cdFx0XG5cdFx0J3t7JzogJ19pbW9wZW4nLFxuXHRcdCd9fSc6ICdfaW1jbG9zZScsXG5cdFx0XG5cdFx0J1wiJzogJ2RvdWJsZXF1b3RlJyxcblx0XHRcIidcIjogJ3NpbmdsZXF1b3RlJyxcblx0XHRcblx0XHQncmVnZXgnOiAnX2ltcmVnZXggcmVnZXgnLFxuXHRcdCdpZGVudGlmaWVyJzogJ19pbXRvayBfaW1pZGVudGlmaWVyIGlkZW50aWZpZXInLFxuXHRcdFxuXHRcdCdjb21wb3VuZF9hc3NpZ24nOiAnb3AgYXNzaWduIGNvbXBvdW5kJyxcblx0XHQnc3RyJzogJ19pbXN0ciBzdHJpbmcnLFxuXHRcdCdudW0nOiAnX2ltbnVtIG51bWJlcicsXG5cdFx0J3N0cmluZyc6ICdfaW1zdHIgc3RyaW5nJyxcblx0XHQnbnVtYmVyJzogJ19pbW51bSBudW1iZXInLFxuXHRcdCdtYXRoJzogJ19pbW9wIG9wIG1hdGgnLFxuXHRcdCd1bmFyeSc6ICdfaW1vcCBvcCB1bmFyeScsXG5cdFx0J2ZvcmluJzogJ2tleXdvcmQgaW4nLFxuXHRcdCdmb3JvZic6ICdrZXl3b3JkIG9mJyxcblx0XHQnb3duJzogJ2tleXdvcmQgb3duJyxcblx0XHQnY29tcGFyZSc6ICdfaW1vcCBvcCBjb21wYXJlJyxcblx0XHQnaGVyZWNvbW1lbnQnOiAnX2hlcmVjb21tZW50Jyxcblx0XHQncmVsYXRpb24nOiAna2V5d29yZCByZWxhdGlvbicsXG5cdFx0J2V4cG9ydCc6ICdrZXl3b3JkIGV4cG9ydCcsXG5cdFx0J2dsb2JhbCc6ICdrZXl3b3JkIGdsb2JhbCcsXG5cdFx0J2V4dGVybic6ICdrZXl3b3JkIGdsb2JhbCcsXG5cdFx0J2V4dGVuZCc6ICdrZXl3b3JkIGV4dGVuZCcsXG5cdFx0J3JlcXVpcmUnOiAna2V5d29yZCByZXF1aXJlJyxcblx0XHQnZnJvbSc6ICdrZXl3b3JkIGZyb20nLFxuXHRcdCdsb2dpYyc6ICdrZXl3b3JkIGxvZ2ljJyxcblx0XHQncG9zdF9pZic6ICdrZXl3b3JkIGlmIHBvc3RfaWYnLFxuXHRcdCdwb3N0X2Zvcic6ICdrZXl3b3JkIGZvciBwb3N0X2ZvcicsXG5cdFx0J3Byb3AnOiAna2V5d29yZCBwcm9wJyxcblx0XHQnYXR0cic6ICdrZXl3b3JkIGF0dHInLFxuXHRcdFxuXHRcdCdzZWxlY3Rvcl9zdGFydCc6ICdfaW1vcGVuIF9pbXNlbG9wZW4gc2VsZWN0b3Jfc3RhcnQnLFxuXHRcdCdzZWxlY3Rvcl9lbmQnOiAnX2ltY2xvc2UgX2ltc2VsY2xvc2Ugc2VsZWN0b3JfZW5kJyxcblx0XHQnaW5kZXhfc3RhcnQnOiAnX2ltb3BlbiBpbmRleF9zdGFydCcsXG5cdFx0J2luZGV4X2VuZCc6ICdfaW1jbG9zZSBpbmRleF9lbmQnLFxuXHRcdCdibG9ja19wYXJhbV9zdGFydCc6ICdfaW1vcGVuJyxcblx0XHQnYmxvY2tfcGFyYW1fZW5kJzogJ19pbWNsb3NlJyxcblx0XHRcblx0XHQnc3RyaW5nX3N0YXJ0JzogJ19pbXN0cnN0YXJ0IHN0cmluZ19zdGFydCcsXG5cdFx0J3N0cmluZ19lbmQnOiAnX2ltc3RyZW5kIHN0cmluZ19lbmQnLFxuXHRcdCduZW9zdHJpbmcnOiAnX2ltdG9rIF9pbW5lb3N0cmluZydcblx0fTtcblx0XG5cdHZhciBJTlRFUlBPTEFUSU5HID0gJ19pbWlzdHJpbmcnO1xuXHRcblx0dmFyIE9QRU4gPSB7XG5cdFx0J3RhZ19zdGFydCc6ICdfaW10YWdub2RlIHRhZ25vZGUnLFxuXHRcdCdjYWxsX3N0YXJ0JzogJ19pbXBhcmVucyBjYWxsJyxcblx0XHQnc2VsZWN0b3Jfc3RhcnQnOiAnX2ltc2VsIHNlbGVjdG9yJyxcblx0XHQnc3RyaW5nX3N0YXJ0JzogJ19pbWlzdHJpbmcnLFxuXHRcdCdpbmRleF9zdGFydCc6ICdpbmRleCcsXG5cdFx0J2Jsb2NrX3BhcmFtX3N0YXJ0JzogJ19pbXBhaXIgX2ltYmxvY2twYXJhbXMnLFxuXHRcdC8vICdpbmRlbnQnOiAnX2luZGVudCdcblx0XHQnKCc6ICdfaW1wYXJlbnMgcGFyZW4nLFxuXHRcdCd7eyc6ICdfaW1pZXhwcicsXG5cdFx0J3snOiAnX2ltY3VybHkgY3VybHknLFxuXHRcdCdbJzogJ19pbXNxdWFyZSBzcXVhcmUnLFxuXHRcdCcoXCInOiAnX2ltaXN0cmluZydcblx0fTtcblx0XG5cdFxuXHRcblx0dmFyIENMT1NFID0ge1xuXHRcdCd0YWdfZW5kJzogJ3RhZycsXG5cdFx0J2NhbGxfZW5kJzogJ19pbXBhcmVucyBjYWxsJyxcblx0XHQnc3RyaW5nX2VuZCc6ICdfaW1pc3RyaW5nJyxcblx0XHQnc2VsZWN0b3JfZW5kJzogJ3NlbCcsXG5cdFx0J2luZGV4X2VuZCc6ICdpbmRleCcsXG5cdFx0J2Jsb2NrX3BhcmFtX2VuZCc6ICdfaW1wYWlyIF9pbWJsb2NrcGFyYW1zJyxcblx0XHQnfX0nOiAnX2ltaWV4cHInLFxuXHRcdCcpJzogJ3BhcmVuJyxcblx0XHQnXSc6ICdzcXVhcmUnLFxuXHRcdCd9JzogJ2N1cmx5Jyxcblx0XHQnXCIpJzogJ3N0cmluZydcblx0fTtcblx0XG5cdHZhciBPUFMgPSAnKyAtICogLyA9ICsrIC0tID09ID09PSAhPSAhPT0gPiA8ID49IDw9ICYgJiYgfCB8fCBvciAuIDogPycuc3BsaXQoJyAnKTtcblx0XG5cdHZhciBobG8gPSB7XG5cdFx0bmV3bGluZTogXCI8YiBjbGFzcz0nX2ltbmV3bGluZSc+XFxuPC9iPlwiLFxuXHRcdHNwYWNlOiBmdW5jdGlvbihtKSB7IHJldHVybiAoXCI8YiBjbGFzcz0nX2ltc3BhY2UnPlwiICsgbSArIFwiPC9iPlwiKTsgfSxcblx0XHR0YWI6IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG5ldyBBcnJheShtLmxlbmd0aCArIDEpLmpvaW4oXCI8YiBjbGFzcz0nX2ltdGFiJz5cXHQ8L2I+XCIpOyB9XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBTdGFjaygpe1xuXHRcdHRoaXMuX3N0YWNrID0gW107XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHRoaXMuX3N0YWNrLnB1c2godmFsKTtcblx0XHR0aGlzLl9jdXJyZW50ID0gdmFsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBsZW4gPSB0aGlzLl9zdGFjay5wb3AoKTtcblx0XHR0aGlzLl9jdXJyZW50ID0gdGhpcy5fc3RhY2tbbGVuIC0gMV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudDtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFRva2VuKHR5cGUsdmFsdWUsbGluZSxsb2MsbGVuKXtcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuX21ldGEgPSBudWxsO1xuXHRcdHRoaXMuX2xpbmUgPSBsaW5lIHx8IDA7XG5cdFx0dGhpcy5fY29sID0gLTE7XG5cdFx0dGhpcy5fbG9jID0gbG9jIHx8IDA7XG5cdFx0dGhpcy5fbGVuID0gbGVuIHx8IDA7XG5cdFx0dGhpcy5nZW5lcmF0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLm5ld0xpbmUgPSBmYWxzZTtcblx0XHR0aGlzLnNwYWNlZCA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRleHBvcnRzLlRva2VuID0gVG9rZW47IC8vIGV4cG9ydCBjbGFzcyBcblx0VG9rZW4ucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbG9jO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLmxlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9sZW47XG5cdH07XG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIEhpZ2hsaWdodGVyKGNvZGUsdG9rZW5zLGFzdCxvKXtcblx0XHR2YXIgaGxfO1xuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdHRoaXMuX2NvZGUgPSBjb2RlO1xuXHRcdHRoaXMuX3Rva2VucyA9IHRva2Vucztcblx0XHR0aGlzLl9hc3QgPSBhc3Q7XG5cdFx0XG5cdFx0by5yZW5kZXIgfHwgKG8ucmVuZGVyID0ge30pO1xuXHRcdG8uaGwgfHwgKG8uaGwgPSB7fSk7XG5cdFx0KGhsXyA9IG8uaGwpLm5ld2xpbmUgfHwgKGhsXy5uZXdsaW5lID0gJzxiIGNsYXNzPVwiX25cIj5cXG48L2I+Jyk7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG87XG5cdFx0XG5cdFx0dGhpcy5fb3B0aW9ucy5uZXh0VmFyQ291bnRlciB8fCAodGhpcy5fb3B0aW9ucy5uZXh0VmFyQ291bnRlciA9IDApO1xuXHRcdHRoaXMuX3ZhclJlZnMgPSB7fTtcblx0XHRcblx0XHRpZiAoby5tb2RlID09ICdmdWxsJyAmJiAhYXN0KSB7XG5cdFx0XHR0aGlzLl9hc3QgPSBJbWJhYy5wYXJzZSh0aGlzLl90b2tlbnMse30pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkhpZ2hsaWdodGVyID0gSGlnaGxpZ2h0ZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0SGlnaGxpZ2h0ZXIuTWFwcGluZyA9IGNsYXNzZXM7XG5cdFxuXHRIaWdobGlnaHRlci5sb2dnZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gVklFVy5sb2dnZXIoKTtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLnRva2VuaXplID0gZnVuY3Rpb24gKGNvZGUsbyl7XG5cdFx0Ly8gY29uc29sZS5sb2cgJ3Rva2VuaXplIHVzaW5nIGxvY2FsIGxleGVyJ1xuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdGlmIChnbG9iYWwuSW1iYWMpIHtcblx0XHRcdHJldHVybiBJbWJhYy50b2tlbml6ZShjb2RlLG8pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fbGV4ZXIgfHwgKHRoaXMuX2xleGVyID0gbmV3IExleGVyKCkpO1xuXHRcdHRoaXMuX2xleGVyLnJlc2V0KCk7XG5cdFx0cmV0dXJuIHRoaXMuX2xleGVyLnRva2VuaXplKGNvZGUsbyk7XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci5yZWNsYXNzaWZ5ID0gZnVuY3Rpb24gKGRvbW5vZGUsdHlwZSx0b2tlbixuZXdDb2RlLG9sZENvZGUpe1xuXHRcdFxuXHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cdFx0Ly8gY29uc29sZS5sb2cgJ3JlY2xhc3NpZnkgbm9kZSBhcyB0eXBlJyxkb21ub2RlLHR5cGUsdG9rZW5cblx0XHR2YXIgY2xzID0gSU0uVHlwZXNbdHlwZV0gfHwgSW1iYS5UQUdTWyhcImltXCIgKyB0eXBlKV0gfHwgSU0uVHlwZXMudG9rZW47XG5cdFx0XG5cdFx0dmFyIG5vZGUgPSB0YWckd3JhcChkb21ub2RlKTtcblx0XHRcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIGNscykge1xuXHRcdFx0cmV0dXJuIG5vZGUucmV1c2UodG9rZW4sbmV3Q29kZSxvbGRDb2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChjbHMpIHtcblx0XHRcdG5vZGUgPSBuZXcgY2xzKGRvbW5vZGUpLnNldHVwKHRva2VuLG5ld0NvZGUsb2xkQ29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblx0XG5cdFxuXHRIaWdobGlnaHRlci5uZXN0VG9rZW5zID0gZnVuY3Rpb24gKHRva2VucyxvZmZzZXQpe1xuXHRcdHZhciBwYWlyaW5nID0ge1xuXHRcdFx0J1RBR19TVEFSVCc6ICdUQUdfRU5EJyxcblx0XHRcdCdTRUxFQ1RPUl9TVEFSVCc6ICdTRUxFQ1RPUl9FTkQnLFxuXHRcdFx0J0NBTExfU1RBUlQnOiAnQ0FMTF9FTkQnLFxuXHRcdFx0J0lOREVYX1NUQVJUJzogJ0lOREVYX0VORCcsXG5cdFx0XHQnU1RSSU5HX1NUQVJUJzogJ1NUUklOR19FTkQnLFxuXHRcdFx0J0JMT0NLX1BBUkFNX1NUQVJUJzogJ0JMT0NLX1BBUkFNX0VORCcsXG5cdFx0XHQne3snOiAnfX0nLFxuXHRcdFx0J3snOiAnfScsXG5cdFx0XHQnWyc6ICddJyxcblx0XHRcdCcoJzogJyknXG5cdFx0fTtcblx0XHRcblx0XHR2YXIgbmFtaW5nID0ge1xuXHRcdFx0J1RBR19TVEFSVCc6ICd0YWdub2RlJyxcblx0XHRcdCdTRUxFQ1RPUl9TVEFSVCc6ICdzZWxlY3RvcicsXG5cdFx0XHQnU1RSSU5HX1NUQVJUJzogJ2lzdHJpbmcnLFxuXHRcdFx0J0NBTExfU1RBUlQnOiAncGFyZW5zJyxcblx0XHRcdCdJTkRFWF9TVEFSVCc6ICdzcXVhcmUnLFxuXHRcdFx0J0JMT0NLX1BBUkFNX1NUQVJUJzogJ2Jsb2NrcGFyYW1zJyxcblx0XHRcdCd7eyc6ICdpZXhwcicsXG5cdFx0XHQneyc6ICdjdXJseScsXG5cdFx0XHQnWyc6ICdzcXVhcmUnLFxuXHRcdFx0JygnOiAncGFyZW5zJ1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGlkeCA9IDA7XG5cdFx0XG5cdFx0dmFyIHJvb3QgPSB7XG5cdFx0XHRfbG9jOiAwLFxuXHRcdFx0X29mZnNldDogMCxcblx0XHRcdF9jaGlsZHJlbjogW11cblx0XHR9O1xuXHRcdFxuXHRcdHZhciBzdGFjayA9IFtyb290XTtcblx0XHR2YXIgZW5kcyA9IFtdO1xuXHRcdHZhciBvZmZzZXQgPSAwO1xuXHRcdFxuXHRcdHZhciBsb2MsdmFsLHR5cCxjdHgsdG9rO1xuXHRcdFxuXHRcdHdoaWxlICh0b2sgPSB0b2tlbnNbaWR4KytdKXtcblx0XHRcdGxvYyA9IHRvay5fbG9jO1xuXHRcdFx0dmFsID0gdG9rLl92YWx1ZTtcblx0XHRcdHR5cCA9IHRvay5fdHlwZTtcblx0XHRcdFxuXHRcdFx0Ly8gbm9ybWFsaXppbmcgYmVjYXVzZSB3ZSBkb250IHJld3JpdGUgdG9rZW5zIChzaG91bGQgc3RhcnQgd2l0aCB0aGF0KVxuXHRcdFx0aWYgKHR5cCA9PSAnSURFTlRJRklFUicgJiYgKHZhbCA9PSAncHJvcCcgfHwgdmFsID09ICdhdHRyJykpIHsgdHlwID0gdG9rLl90eXBlID0gJ0tFWVdPUkQnIH07IC8vIG5vdCBhbHdheXNcblx0XHRcdGlmICh0eXAgPT0gJ0lOREVYX1NUQVJUJykgeyB0eXAgPSB0b2suX3R5cGUgPSAnWycgfTtcblx0XHRcdGlmICh0eXAgPT0gJ0lOREVYX0VORCcpIHsgdHlwID0gdG9rLl90eXBlID0gJ10nIH07XG5cdFx0XHRpZiAodHlwID09ICdDQUxMX1NUQVJUJykgeyB0eXAgPSB0b2suX3R5cGUgPSAnKCcgfTtcblx0XHRcdGlmICh0eXAgPT0gJ0NBTExfRU5EJykgeyB0eXAgPSB0b2suX3R5cGUgPSAnKScgfTtcblx0XHRcdFxuXHRcdFx0Y3R4ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHRcblx0XHRcdGxvYyAtPSBjdHguX29mZnNldDtcblx0XHRcdC8vIG9mZnNldCByZWxhdGl2ZSB0byBjb250ZXh0XG5cdFx0XHR2YXIgY2xvc2VyID0gcGFpcmluZ1t0eXBdO1xuXHRcdFx0XG5cdFx0XHRpZiAoY2xvc2VyKSB7XG5cdFx0XHRcdHZhciBncm91cCA9IG5ldyBUb2tlbihuYW1pbmdbdHlwXSwnJywtMSxsb2MpO1xuXHRcdFx0XHRncm91cC5fb2Zmc2V0ID0gY3R4Ll9vZmZzZXQgKyBsb2M7XG5cdFx0XHRcdG9mZnNldCArPSBsb2M7XG5cdFx0XHRcdGdyb3VwLl9jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRlbmRzLnB1c2goY2xvc2VyKTtcblx0XHRcdFx0c3RhY2sucHVzaChncm91cCk7XG5cdFx0XHRcdGN0eC5fY2hpbGRyZW4ucHVzaChncm91cCk7XG5cdFx0XHRcdGN0eCA9IGdyb3VwO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dG9rLl9sb2MgLT0gY3R4Ll9vZmZzZXQ7XG5cdFx0XHRcblx0XHRcdC8vIHVwZGF0ZSBsZW5ndGggYXQgYWxsIHRpbWVzXG5cdFx0XHRpZiAodG9rLl9sZW4gPj0gMSkge1xuXHRcdFx0XHRjdHguX2NoaWxkcmVuLnB1c2godG9rKTtcblx0XHRcdFx0Y3R4Ll9sZW4gPSB0b2suX2xvYyArIHRvay5fbGVuO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGVuZHNbZW5kcy5sZW5ndGggLSAxXSA9PSB0eXApIHtcblx0XHRcdFx0ZW5kcy5wb3AoKTtcblx0XHRcdFx0Y3R4Ll9sZW4gPSB0b2suX2xvYyArIHRvay5fbGVuO1xuXHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0Ly8gb2Zmc2V0IC09IGN0eC5Ab2Zmc2V0XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgJ2NoaWxkcmVuIGhlcmUnLHJvb3QuQGNoaWxkcmVuXG5cdFx0cmV0dXJuIHJvb3QuX2NoaWxkcmVuO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIubm9ybWFsaXplVG9rZW5zID0gZnVuY3Rpb24gKGNvZGUsdG9rZW5zLG9mZnNldCl7XG5cdFx0aWYob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XG5cdFx0dmFyIGlkeCA9IDA7XG5cdFx0dmFyIGNhcmV0ID0gMDtcblx0XHR2YXIgbmV3JCA9IFtdO1xuXHRcdHZhciB0b2ssbmV4dCx0eXAsdmFsO1xuXHRcdHZhciBsb2MgPSAwO1xuXHRcdFxuXHRcdHZhciBzdGFjayA9IG5ldyBTdGFjaygpO1xuXHRcdFxuXHRcdHZhciB3cyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld3RvayA9IG51bGw7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChsb2MgPiBjYXJldCl7XG5cdFx0XHRcdHZhciBjaHIgPSBjb2RlW2NhcmV0XTtcblx0XHRcdFx0aWYgKGNociA9PSAnXFx0Jykge1xuXHRcdFx0XHRcdG5ld3RvayA9IG5ldyBUb2tlbigndGFiJyxjaHIsLTEsY2FyZXQsMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICdcXG4nKSB7XG5cdFx0XHRcdFx0bmV3dG9rID0gbmV3IFRva2VuKCduZXdsaW5lJyxjaHIsLTEsY2FyZXQsMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICc7Jykge1xuXHRcdFx0XHRcdG5ld3RvayA9IG5ldyBUb2tlbignc2VtaWNvbG9uJyxjaHIsLTEsY2FyZXQsMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICcgJykge1xuXHRcdFx0XHRcdGlmIChuZXd0b2sgJiYgbmV3dG9rLl90eXBlID09ICd3aGl0ZXNwYWNlJykge1xuXHRcdFx0XHRcdFx0bmV3dG9rLl92YWx1ZSArPSAnICc7XG5cdFx0XHRcdFx0XHRuZXd0b2suX2xlbiArPSAxO1xuXHRcdFx0XHRcdFx0Y2FyZXQrKztcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0bmV3dG9rID0gbmV3IFRva2VuKCd3aGl0ZXNwYWNlJyxjaHIsLTEsY2FyZXQsMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuXHRcdFx0XHRcdHZhciBzdGFydGxvYyA9IGNhcmV0O1xuXHRcdFx0XHRcdHZhciBjb21tZW50ID0gJyc7XG5cdFx0XHRcdFx0d2hpbGUgKGNhcmV0IDwgbG9jICYmIGNvZGVbY2FyZXRdICE9ICdcXG4nKXtcblx0XHRcdFx0XHRcdGNvbW1lbnQgKz0gY29kZVtjYXJldF07XG5cdFx0XHRcdFx0XHRjYXJldCsrO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0bmV3JC5wdXNoKG5ldyBUb2tlbignY29tbWVudCcsY29tbWVudCwtMSxzdGFydGxvYyxjb21tZW50Lmxlbmd0aCkpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld3RvayA9IG51bGw7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXJldCsrO1xuXHRcdFx0XHRpZiAobmV3dG9rKSB7IG5ldyQucHVzaChuZXd0b2spIH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHNraXAgPSBbJ1RFUk1JTkFUT1InLCdJTkRFTlQnLCdPVVRERU5UJywnICcsJyBcXHQnXTtcblx0XHRcblx0XHR3aGlsZSAodG9rID0gdG9rZW5zW2lkeCsrXSl7XG5cdFx0XHRuZXh0ID0gdG9rZW5zW2lkeF07XG5cdFx0XHRsb2MgPSB0b2suX2xvYztcblx0XHRcdHZhbCA9IHRvay5fdmFsdWU7XG5cdFx0XHR0eXAgPSB0b2suX3R5cGU7XG5cdFx0XHRcblx0XHRcdGlmICh0eXAgPT0gJyMnICYmIG5leHQgJiYgbmV4dC5fdHlwZSA9PSAnSURFTlRJRklFUicpIHtcblx0XHRcdFx0bmV4dC5fdHlwZSA9ICdJRFJFRic7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwID09ICcoJyAmJiB2YWwgPT0gJyhcIicpIHtcblx0XHRcdFx0c3RhY2sucHVzaCh2YWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHNraXAuaW5kZXhPZih0eXApID49IDApIHsgY29udGludWU7IH07XG5cdFx0XHRcblx0XHRcdGlmIChsb2MgPiBjYXJldCkgeyB3cygpIH07XG5cdFx0XHRjYXJldCA9IHRvay5fbG9jICsgdG9rLl9sZW47XG5cdFx0XHRuZXckLnB1c2godG9rKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG1vdmUgdG8gdGhlIGVuZCB0byBwb3NzaWJseSBwYXJzZSBtb3JlIHdoaXRlc3BhY2Vcblx0XHRsb2MgPSBjb2RlLmxlbmd0aDtcblx0XHR3cygpO1xuXHRcdC8vIG5vdyBuZXN0IHRoZSB0b2tlbnNcblx0XHRuZXckID0gdGhpcy5uZXN0VG9rZW5zKG5ldyQpO1xuXHRcdHJldHVybiBuZXckO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIud2hpdGVzcGFjZVRvVG9rZW5zID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0dmFyIHRvaztcblx0XHR2YXIgdG9rZW5zID0gW107XG5cdFx0dmFyIGNhcmV0ID0gMDtcblx0XHR2YXIgbGVuID0gc3RyLmxlbmd0aDtcblx0XHRcblx0XHR3aGlsZSAobGVuID4gY2FyZXQpe1xuXHRcdFx0dmFyIGxvYyA9IGNhcmV0O1xuXHRcdFx0dmFyIGNociA9IHN0cltjYXJldCsrXTtcblx0XHRcdGlmIChjaHIgPT0gJ1xcdCcpIHtcblx0XHRcdFx0dG9rZW5zLnB1c2godG9rID0gbmV3IFRva2VuKCd0YWInLGNociwtMSxsb2MsMSkpO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJ1xcbicpIHtcblx0XHRcdFx0dG9rZW5zLnB1c2godG9rID0gbmV3IFRva2VuKCduZXdsaW5lJyxjaHIsLTEsbG9jLDEpKTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICcgJykge1xuXHRcdFx0XHRpZiAodG9rICYmIHRvay5fdHlwZSA9PSAnd2hpdGVzcGFjZScpIHtcblx0XHRcdFx0XHR0b2suX3ZhbHVlICs9ICcgJztcblx0XHRcdFx0XHR0b2suX2xlbiArPSAxO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0b2tlbnMucHVzaCh0b2sgPSBuZXcgVG9rZW4oJ3doaXRlc3BhY2UnLGNociwtMSxsb2MsMSkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0b2tlbnM7XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci5yZXBhcnNlID0gZnVuY3Rpb24gKG8pe1xuXHRcdFxuXHRcdHZhciAkMTtcblx0XHRpZiAobyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcblx0XHRcdHZhciBlbCA9IHRhZyR3cmFwKG8pO1xuXHRcdFx0aWYgKGVsKSB7ICgkMSA9IGVsKSAmJiAkMS5tdXRhdGVkICAmJiAgJDEubXV0YXRlZCgpIH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgbm9kZXMgPSBvLm5vZGVzO1xuXHRcdHZhciBjb2RlID0gby5jb2RlO1xuXHRcdHZhciB0b2tlbnMgPSBvLnRva2Vucztcblx0XHQvLyBzaG91bGQgdXNlIGEgZ2xvYmFsIGxvZ2dlci1pbnN0YW5jZVxuXHRcdHRoaXMubG9nZ2VyKCkuZ3JvdXBDb2xsYXBzZWQoJ3JlcGFyc2UgJXMnLEpTT04uc3RyaW5naWZ5KGNvZGUpKTtcblx0XHRcblx0XHRpZiAodXRpbC5pc1doaXRlc3BhY2UoY29kZSkgJiYgIXRva2Vucykge1xuXHRcdFx0Y29uc29sZS5sb2coJ3VzaW5nIHdoaXRlc3BhY2VUb1Rva2VucycpO1xuXHRcdFx0dG9rZW5zID0gdGhpcy53aGl0ZXNwYWNlVG9Ub2tlbnMoY29kZSk7XG5cdFx0fTtcblx0XHQvLyBsb2dnZXIubG9nIG5vZGVzLnNsaWNlXG5cdFx0Ly8gYmlnIGhhY2sgLSBhZGRpbmcgYSBzcGFjZSBhdCB0aGUgZW5kIHRvIGNsb3NlIHVwIHNlbGVjdG9yc1xuXHRcdC8vIHNob3VsZCByYXRoZXIgZHJvcCBpbmxpbmUgYW5kIGxldCB0aGUgcGFyc2VyIHBhaXIgdXAgbG9vc2UgZW5kcz9cblx0XHRpZiAoIXRva2Vucykge1xuXHRcdFx0dG9rZW5zID0gdGhpcy50b2tlbml6ZShjb2RlICsgJyAnLHtpbmxpbmU6IHRydWUsc2lsZW50OiB0cnVlLHJld3JpdGU6IGZhbHNlfSk7XG5cdFx0XHR0b2tlbnMgPSB0aGlzLm5vcm1hbGl6ZVRva2Vucyhjb2RlLHRva2Vucyk7XG5cdFx0XHR0aGlzLmxvZ2dlcigpLmxvZyh0b2tlbnMuc2xpY2UoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLmxvZ2dlcigpLmxvZyhub2Rlcy5zbGljZSgpKTtcblx0XHR0aGlzLmFwcGx5VG9rZW5zKGNvZGUsdG9rZW5zLG5vZGVzLG8ubmVzdGVkLG8ucGFyZW50KTtcblx0XHR0aGlzLmxvZ2dlcigpLmdyb3VwRW5kKCk7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIuYXBwbHlUb2tlbnMgPSBmdW5jdGlvbiAoY29kZSx0b2tlbnMsbm9kZXMsbmVzdGVkLHBhcmVudCl7XG5cdFx0Ly8gd2hhdCBhYm91dCBsZW4gYW5kIGxvYyBmb3IgaW5uZXIgbm9kZXM/IFNob3VsZCB0aGlzIGJlIHNldCBhbHJlYWR5P1xuXHRcdFxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgbm9kZTtcblx0XHR2YXIgcHJldk5vZGU7XG5cdFx0XG5cdFx0dmFyIGFkZE5vZGUgPSBmdW5jdGlvbihub2RlcyxpbmRleCxhZnRlcikge1xuXHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coJ2FkZE5vZGUnLGluZGV4KTtcblx0XHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoTk9ERVRZUEUpO1xuXHRcdFx0XG5cdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0aWYgKGFmdGVyLm5leHRTaWJsaW5nKSB7XG5cdFx0XHRcdFx0YWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsYWZ0ZXIubmV4dFNpYmxpbmcpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFmdGVyLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHRhZnRlci5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAocGFyZW50KSB7XG5cdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRub2Rlcy5zcGxpY2UoaW5kZXgsMCxlbCk7XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgcmVtb3ZlTm9kZSA9IGZ1bmN0aW9uKG5vZGVzLGluZGV4KSB7XG5cdFx0XHRzZWxmLmxvZ2dlcigpLmxvZygncmVtb3ZlTm9kZScsaW5kZXgpO1xuXHRcdFx0dmFyIGVsID0gbm9kZXNbaW5kZXhdO1xuXHRcdFx0aWYgKGVsICYmIGVsLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIG5vZGVzLnNwbGljZShpbmRleCwxKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGxvb3AgdGhyb3VnaCB0byBzZXQgdGhlIGxvY2F0aW9ucyBvZiB0aGUgbm9kZXNcblx0XHR2YXIgbmxvYyA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbm9kZTE7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0bm9kZTEgPSBhcnlbaV07XG5cdFx0XHRub2RlMS5fbG9jID0gbmxvYztcblx0XHRcdG5sb2MgKz0gKG5vZGUxLl9sZW4gPSBub2RlMS50ZXh0Q29udGVudC5sZW5ndGgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRva2VucyksIGxlbiA9IGFyeS5sZW5ndGgsIHRvazsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0b2sgPSBhcnlbaV07XG5cdFx0XHRub2RlID0gbm9kZXNbaV07XG5cdFx0XHR2YXIgdGxvYyA9IHRvay5fbG9jO1xuXHRcdFx0bmxvYyA9IG5vZGUgJiYgbm9kZS5fbG9jO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAobm9kZSAmJiBub2RlLl9sZW4gPT0gMCl7XG5cdFx0XHRcdHNlbGYubG9nZ2VyKCkubG9nKCdyZW1vdmUgbm9kZSBiZWNhdXNlIGl0IGlzIGVtcHR5Jyxub2RlKTtcblx0XHRcdFx0cmVtb3ZlTm9kZShub2RlcyxpKTtcblx0XHRcdFx0bm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRcdC8vIG5lZWQgdG8gaW5zZXJ0IG5ldyBub2RlIGhlcmUgLSBcblx0XHRcdFx0bm9kZSA9IGFkZE5vZGUobm9kZXMsaSxwcmV2Tm9kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKG5sb2MgPiB0bG9jKSB7XG5cdFx0XHRcdG5vZGUgPSBhZGROb2RlKG5vZGVzLGkscHJldk5vZGUpO1xuXHRcdFx0fSBlbHNlIGlmICh0bG9jID4gbmxvYykge1xuXHRcdFx0XHRyZW1vdmVOb2RlKG5vZGVzLGkpO1xuXHRcdFx0XHRub2RlID0gbm9kZXNbaV07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBuZWVkIHRvIGluc2VydCBuZXcgbm9kZSBoZXJlIC0gXG5cdFx0XHRpZiAoIW5vZGUpIHsgbm9kZSA9IGFkZE5vZGUobm9kZXMsaSxwcmV2Tm9kZSkgfTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvay5fdHlwZSA9PSAnU1RSSU5HJyAmJiB0b2suX3ZhbHVlLm1hdGNoKC9cXMKnezN9LykpIHtcblx0XHRcdFx0aWYgKG5lc3RlZCkge1xuXHRcdFx0XHRcdG5lc3RlZC5wb3AoKTsgLy8gdGhpcyBpcyB0aGUgbm9kZVxuXHRcdFx0XHRcdHByZXZOb2RlID0gbm9kZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHdhbnQgdG8gbWFrZSBzdXJlIGl0IGlzIGEgcGxhY2Vob2xkZXIgZm9yIHRoZSByaWdodCB0aGluZ1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGN2YWwgPSBjb2RlLnN1YnN0cih0bG9jLHRvay5fbGVuKTtcblx0XHRcdHZhciBjcHJldiA9IG5vZGUudGV4dENvbnRlbnQ7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHNlbGYucmVjbGFzc2lmeShub2RlLHRvay5fdHlwZSx0b2ssY3ZhbCxjcHJldik7XG5cdFx0XHRcblx0XHRcdGlmICh0b2suX2NoaWxkcmVuKSB7XG5cdFx0XHRcdHZhciBjbm9kZXMgPSBub2RlLmNoaWxkcmVuO1xuXHRcdFx0XHRpZiAoY25vZGVzLmxlbmd0aCAmJiBjbm9kZXMubGVuZ3RoID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRzZWxmLmxvZ2dlcigpLmxvZygncmV1c2UgdGhlIGNub2RlcyghKScsY25vZGVzKTtcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2hvdWxkIHJlbW92ZSB0aGUgdGV4dE5vZGVzP1xuXHRcdFx0XHRcdC8vIGNvbnZlcnQgdG8gYXJyYXlcblx0XHRcdFx0XHRjbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjbm9kZXMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYubG9nZ2VyKCkubG9nKCd3cm9uZyBsZW5ndGgnKTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMCwgaXRlbXMgPSBpdGVyJChub2RlLmNoaWxkTm9kZXMpLCBsZW5fID0gaXRlbXMubGVuZ3RoOyBqIDwgbGVuXzsgaisrKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmxvZ2dlcigpLmxvZyhpdGVtc1tqXSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHQvLyBzZWUgaWYgcHJldmlvdXMgdmFsdWUgaXMgdGhlIHNhbWU/IVxuXHRcdFx0XHRcdG5vZGUuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdFx0Y25vZGVzID0gW107XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBsZXQgbyA9XG5cdFx0XHRcdC8vIFx0Y29kZTogY3ZhbFxuXHRcdFx0XHQvLyBcdG5vZGVzOiBjbm9kZXNcblx0XHRcdFx0Ly8gXHR0b2tlbnM6IHRvay5AY2hpbGRyZW4gIyBhbHJlYWR5IHBhcnNlZFxuXHRcdFx0XHQvLyBcdG5lc3RlZDogbmVzdGVkXG5cdFx0XHRcdC8vIFx0cGFyZW50OiBub2RlXG5cdFx0XHRcdFxuXHRcdFx0XHRzZWxmLmFwcGx5VG9rZW5zKGN2YWwsdG9rLl9jaGlsZHJlbixjbm9kZXMsbmVzdGVkLG5vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjcHJldiAhPSBjdmFsKSB7XG5cdFx0XHRcdG5vZGUudGV4dENvbnRlbnQgPSBjdmFsOyAvLyB0b2suQHZhbHVlXG5cdFx0XHRcdGVsZW1lbnQucmVwYXJzZWQoY3ZhbCxjcHJldik7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRwcmV2Tm9kZSA9IG5vZGU7XG5cdFx0XHQvLyB0b2suQGxlblxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHRva2Vucz8gbm90IHN1cmUgaXQgd29ya3MgZHVlIHRvIHRoZSBpc3N1ZXMgd2l0aCB3aGl0ZXNwYWNlP1xuXHRcdFxuXHRcdC8vIHJlbW92ZSBleGNlc3Mgb3JpZ2luYWwgbm9kZXNcblx0XHR3aGlsZSAobm9kZXMubGVuZ3RoID4gdG9rZW5zLmxlbmd0aCl7XG5cdFx0XHRub2RlID0gbm9kZXMucG9wKCk7XG5cdFx0XHRpZiAobm9kZS5wYXJlbnROb2RlKSB7IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKSB9O1xuXHRcdFx0Ly8gbm9kZS5vcnBoYW5pemVcblx0XHR9O1xuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0Ly8gc2hvdWxkIGxhdGVyIGJlIGFibGUgdG8gcmVoaWdobGlnaHQgdGhlIHRleHQgLyBub2RlcyBkaXJlY3RseSBpbnN0ZWFkXG5cdC8vIHByb2JhYmx5IG1vcmUgZWZmaWNpZW50XG5cdEhpZ2hsaWdodGVyLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdC8vIGZpcnN0IHRyeSB0byBwYXJzZSBldGM/XG5cdFx0Ly8gY291bGQgaGlnaGxpZ2h0IHNpbmdsZSB3b3JkcyBhcyB3ZWxsXG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0by5obCB8fCAoby5obCA9IGhsbyk7XG5cdFx0dmFyIHRva2VucyA9IG8udG9rZW5zIHx8IG51bGw7XG5cdFx0XG5cdFx0aWYgKCF0b2tlbnMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIHN1cmUgd2UgZG9udCB3YW50IHRvIHJld3JpdGUgYW55dGhpbmcgbm93P1xuXHRcdFx0XHRpZiAoREVCVUcpIHsgY29uc29sZS50aW1lKCd0b2tlbml6ZScpIH07XG5cdFx0XHRcdGlmIChvLm1vZGUgPT0gJ2Z1bGwnKSB7XG5cdFx0XHRcdFx0dG9rZW5zID0gdGhpcy50b2tlbml6ZShjb2RlLHt9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0b2tlbnMgPSB0aGlzLnRva2VuaXplKGNvZGUse2lubGluZTogdHJ1ZSxzaWxlbnQ6IHRydWUscmV3cml0ZTogZmFsc2V9KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKERFQlVHKSB7IGNvbnNvbGUudGltZUVuZCgndG9rZW5pemUnKSB9O1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRpZiAoZS5fb3B0aW9ucykgeyB0b2tlbnMgPSBlLl9vcHRpb25zLnRva2VucyB9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBobCA9IG5ldyB0aGlzKGNvZGUsdG9rZW5zLG51bGwsbyk7XG5cdFx0cmV0dXJuIGhsLnByb2Nlc3MoKTtcblx0fTtcblx0XG5cdFxuXHRcblx0SGlnaGxpZ2h0ZXIucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29wdGlvbnM7IH1cblx0SGlnaGxpZ2h0ZXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbih2KXsgdGhpcy5fb3B0aW9ucyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SGlnaGxpZ2h0ZXIucHJvdG90eXBlLnZhclJlZiA9IGZ1bmN0aW9uICh2YXJpYWJsZSl7XG5cdFx0dmFyICQxO1xuXHRcdHZhciBpID0gdGhpcy5fb3B0aW9ucy5uZXN0ZWQ7XG5cdFx0dmFyIHBmeCA9IGkgPyAoJ2knKSA6ICgnJyk7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhclJlZnNbKCQxID0gdmFyaWFibGUuX3JlZildIHx8ICh0aGlzLl92YXJSZWZzWyQxXSA9IChwZnggKyB0aGlzLl9vcHRpb25zLm5leHRWYXJDb3VudGVyKyspKTtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5wYXJzZVdoaXRlc3BhY2UgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0Ly8gcGFyc2luZyBjb21tZW50c1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgaGwgPSB0aGlzLl9vcHRpb25zLmhsO1xuXHRcdHZhciBjb21tZW50cyA9IFtdO1xuXHRcdFxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyhcXCMpKFteXFxuXSopL2csZnVuY3Rpb24obSxzLHEpIHtcblx0XHRcdGlmIChzZWxmLl9vcHRpb25zLnJlbmRlci5jb21tZW50KSB7XG5cdFx0XHRcdG0gPSBzZWxmLl9vcHRpb25zLnJlbmRlci5jb21tZW50KCdjb21tZW50JyxtKTtcblx0XHRcdH07XG5cdFx0XHR2YXIgbnIgPSBjb21tZW50cy5wdXNoKChcIjxcIiArIE5PREVUWVBFICsgXCIgY2xhc3M9J19pbSBfaW1jb21tZW50Jz5cIiArIG0gKyBcIjwvXCIgKyBOT0RFVFlQRSArIFwiPlwiKSk7XG5cdFx0XHRyZXR1cm4gKFwiJFwiICsgKG5yIC0gMSkgKyBcIiRcIik7XG5cdFx0fSk7XG5cdFx0XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvKFxcbnxbIF0rfFtcXHRdKykvZyxmdW5jdGlvbihtLGwpIHtcblx0XHRcdGlmIChsID09ICdcXG4nKSB7XG5cdFx0XHRcdHJldHVybiBobC5uZXdsaW5lIHx8ICdcXG4nO1xuXHRcdFx0fSBlbHNlIGlmIChsWzBdID09ICcgJykge1xuXHRcdFx0XHRyZXR1cm4gaGwuc3BhY2UgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChobC5zcGFjZShsKSkgOiAobCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxbMF0gPT0gJ1xcdCcpIHtcblx0XHRcdFx0cmV0dXJuIGhsLnRhYiBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gKGhsLnRhYihsKSkgOiAobCk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdFxuXHRcdGlmIChjb21tZW50cy5sZW5ndGgpIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcJChcXGQrKVxcJC9nLGZ1bmN0aW9uKG0sbnIpIHtcblx0XHRcdFx0cmV0dXJuIGNvbW1lbnRzW3BhcnNlSW50KG5yKV07XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rO1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zKCk7XG5cdFx0XG5cdFx0dmFyIHN0ciA9IHRoaXMuX2NvZGU7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3Rva2Vucy5sZW5ndGg7XG5cdFx0XG5cdFx0dmFyIHN0YWNrID0gW107XG5cdFx0dmFyIGRlcHRoID0gMDtcblx0XHR2YXIgY29udGV4dCA9IG51bGw7XG5cdFx0XG5cdFx0dmFyIHB1c2ggPSBmdW5jdGlvbihjdHgpIHtcblx0XHRcdHN0YWNrLnB1c2goY3R4KTtcblx0XHRcdGRlcHRoID0gc3RhY2subGVuZ3RoO1xuXHRcdFx0cmV0dXJuIGNvbnRleHQgPSBzdGFja1tkZXB0aCAtIDFdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHBvcCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRkZXB0aCA9IHN0YWNrLmxlbmd0aDtcblx0XHRcdHJldHVybiBjb250ZXh0ID0gc3RhY2tbZGVwdGggLSAxXTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9hc3QgJiYgdGhpcy5fYXN0LmFuYWx5emUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX2FzdC5hbmFseXplKHt9KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0bnVsbDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgcmVzID0gXCJcIjtcblx0XHRwb3MgPSAwO1xuXHRcdHZhciBjYXJldCA9IDA7XG5cdFx0XG5cdFx0dmFyIG9wZW4sY2xvc2U7XG5cdFx0XG5cdFx0d2hpbGUgKHRvayA9IHRoaXMuX3Rva2Vuc1twb3MrK10pe1xuXHRcdFx0dmFyIG5leHQgPSB0aGlzLl90b2tlbnNbcG9zXTtcblx0XHRcdFxuXHRcdFx0aWYgKGNsb3NlKSB7XG5cdFx0XHRcdGlmICghKG8uaW5uZXIgJiYgZGVwdGggPT0gMSkpIHsgcmVzICs9IChcIjwvXCIgKyBOT0RFVFlQRSArIFwiPlwiKSB9O1xuXHRcdFx0XHRjbG9zZSA9IG51bGw7XG5cdFx0XHRcdHBvcCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHR5cCA9IHRvay5fdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIGxvYyA9IHRvay5fbG9jO1xuXHRcdFx0dmFyIHZhbCA9IHRvay5fdmFsdWU7XG5cdFx0XHR2YXIgbGVuID0gdG9rLl9sZW47IC8vIG9yIHRvay5AdmFsdWU6bGVuZ3RoXG5cdFx0XHR2YXIgbWV0YSA9IHRvay5fbWV0YTtcblx0XHRcdHZhciBhdHRycyA9ICcnO1xuXHRcdFx0XG5cdFx0XHRpZiAobG9jID4gY2FyZXQpIHtcblx0XHRcdFx0dmFyIGFkZCA9IHN0ci5zdWJzdHJpbmcoY2FyZXQsbG9jKTtcblx0XHRcdFx0aWYgKGNvbnRleHQgIT0gSU5URVJQT0xBVElORykgeyBhZGQgPSB0aGlzLnBhcnNlV2hpdGVzcGFjZShhZGQpIH07XG5cdFx0XHRcdHJlcyArPSBhZGQ7XG5cdFx0XHRcdGNhcmV0ID0gbG9jO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y2xvc2UgPSBDTE9TRVt0eXBdO1xuXHRcdFx0XG5cdFx0XHRpZiAob3BlbiA9IE9QRU5bdHlwXSkge1xuXHRcdFx0XHQvLyBvcGVuID0gT1BFTlt2YWxdIHx8IG9wZW5cblx0XHRcdFx0cHVzaChvcGVuKTtcblx0XHRcdFx0aWYgKCEoby5pbm5lciAmJiBkZXB0aCA9PSAxKSkgeyByZXMgKz0gKFwiPFwiICsgTk9ERVRZUEUgKyBcIiBjbGFzcz0nXCIgKyBvcGVuICsgXCInPlwiKSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGxlbiA9PSAwIHx8IHR5cCA9PSAndGVybWluYXRvcicgfHwgdHlwID09ICdpbmRlbnQnIHx8IHR5cCA9PSAnb3V0ZGVudCcpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodG9rLl9jb2wgPT0gLTEgJiYgdG9rLl9sb2MgPD0gMCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBub2RlID0gTk9ERVRZUEU7XG5cdFx0XHR2YXIgY29udGVudCA9IHN0ci5zdWJzdHIobG9jLGxlbik7XG5cdFx0XHQvLyB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCB1bnRpbCB3ZSByZWRlZmluZSByZXF1aXJlIGFzIGFuIGlkZW50aWZpZXJcblx0XHRcdGlmICh0eXAgPT0gJ2NvbnN0JyAmJiBjb250ZW50ID09ICdyZXF1aXJlJykge1xuXHRcdFx0XHR0eXAgPSAncmVxdWlyZSc7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHZhciBjbHMgPSBjbGFzc2VzW3R5cF0gfHwgdHlwO1xuXHRcdFx0XG5cdFx0XHRpZiAoY2xzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0bm9kZSA9IGNsc1swXTtcblx0XHRcdFx0Y2xzID0gY2xzWzFdO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y2xzID0gY2xzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFxuXHRcdFx0aWYgKEtFWVdPUkRTLmluZGV4T2YodHlwKSA+PSAwKSB7XG5cdFx0XHRcdGNscy51bnNoaWZ0KCdrZXl3b3JkJyk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjYXJldCA9IGxvYyArIGxlbjtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cCA9PSAnaWRlbnRpZmllcicpIHtcblx0XHRcdFx0aWYgKGNvbnRlbnRbMF0gPT0gJyMnKSB7XG5cdFx0XHRcdFx0Y2xzLnB1c2goJ2lkcmVmJyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobWV0YSkge1xuXHRcdFx0XHRcdGlmIChtZXRhLnR5cGUgPT0gJ0FDQ0VTUycpIHsgY2xzLnB1c2goJ2FjY2VzcycpIH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY29udGVudCA9PSAnbG9nJykge1xuXHRcdFx0XHRcdGNscy5wdXNoKCdsb2cnKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0b2suX3ZhcmlhYmxlKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRjbHMucHVzaCgnbHZhcicpO1xuXHRcdFx0XHR2YXIgcmVmID0gdGhpcy52YXJSZWYodG9rLl92YXJpYWJsZSk7XG5cdFx0XHRcdGF0dHJzICs9IChcIiBlcmVmPSd2XCIgKyByZWYgKyBcIidcIik7XG5cdFx0XHRcdC8vIGNscy5wdXNoKFwicmVmLVwiK3JlZilcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0eXAgPT0gJ2hlcmVjb21tZW50Jykge1xuXHRcdFx0XHR2YXIgZW5kID0gKFwiPFwiICsgTk9ERVRZUEUgKyBcIj4jIyM8L1wiICsgTk9ERVRZUEUgKyBcIj5cIik7XG5cdFx0XHRcdGNvbnRlbnQgPSBlbmQgKyBjb250ZW50LnNsaWNlKDMsLTMpICsgZW5kO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cCA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZiAoY29udGVudC5tYXRjaCgvXlsnXCJdP1xcLj9cXC5cXC8vKSkgeyBjbHMucHVzaCgncGF0aG5hbWUnKSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGNsc3RyID0gY2xzLmpvaW4oXCIgXCIpO1xuXHRcdFx0aWYgKCFjbHN0ci5tYXRjaCgvXFxiXFxfLykpIHsgY2xzdHIgPSAnX2ltdG9rICcgKyBjbHN0ciB9O1xuXHRcdFx0cmVzICs9IChcIjxcIiArIG5vZGUgKyBcIiBjbGFzcz0nXCIgKyBjbHN0ciArIFwiJ1wiKSArIGF0dHJzICsgXCI+XCIgKyBjb250ZW50ICsgKFwiPC9cIiArIG5vZGUgKyBcIj5cIik7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBjbG9zZSBhZnRlcj9cblx0XHRpZiAoY2xvc2UpIHtcblx0XHRcdHJlcyArPSAoXCI8L1wiICsgTk9ERVRZUEUgKyBcIj5cIik7XG5cdFx0XHRjbG9zZSA9IG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoY2FyZXQgPCBzdHIubGVuZ3RoIC0gMSkge1xuXHRcdFx0YWRkID0gc3RyLnNsaWNlKGNhcmV0KTtcblx0XHRcdGlmIChjb250ZXh0ICE9IElOVEVSUE9MQVRJTkcpIHsgYWRkID0gdGhpcy5wYXJzZVdoaXRlc3BhY2UoYWRkKSB9O1xuXHRcdFx0cmVzICs9IGFkZDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl90b2tlbnMubGVuZ3RoID09IDApIHtcblx0XHRcdHJlcyA9IHRoaXMuX2NvZGU7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xuXHRyZXR1cm4gSGlnaGxpZ2h0ZXI7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL2hpZ2hsaWdodGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gaGVscGVyIGZvciBzdWJjbGFzc2luZ1xuXHRmdW5jdGlvbiBzdWJjbGFzcyQob2JqLHN1cCkge1xuXHRcdGZvciAodmFyIGsgaW4gc3VwKSB7XG5cdFx0XHRpZiAoc3VwLmhhc093blByb3BlcnR5KGspKSBvYmpba10gPSBzdXBba107XG5cdFx0fTtcblx0XHQvLyBvYmouX19zdXBlcl9fID0gc3VwO1xuXHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0fTtcblx0XG5cdHZhciBBTExfS0VZV09SRFM7XG5cdFxuXHR2YXIgVCA9IHJlcXVpcmUoJy4vdG9rZW4nKTtcblx0dmFyIFRva2VuID0gVC5Ub2tlbjtcblx0XG5cdHZhciBydyA9IHJlcXVpcmUoJy4vcmV3cml0ZXInKTtcblx0dmFyIFJld3JpdGVyID0gcncuUmV3cml0ZXI7XG5cdHZhciBJTlZFUlNFUyA9IHJ3LklOVkVSU0VTO1xuXHRcblx0dmFyIEsgPSAwO1xuXHRcblx0dmFyIEVSUiA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cdFxuXHQvLyBDb25zdGFudHNcblx0Ly8gLS0tLS0tLS0tXG5cdFxuXHQvLyBLZXl3b3JkcyB0aGF0IEltYmEgc2hhcmVzIGluIGNvbW1vbiB3aXRoIEphdmFTY3JpcHQuXG5cdHZhciBKU19LRVlXT1JEUyA9IFtcblx0XHQndHJ1ZScsJ2ZhbHNlJywnbnVsbCcsJ3RoaXMnLFxuXHRcdCdkZWxldGUnLCd0eXBlb2YnLCdpbicsJ2luc3RhbmNlb2YnLFxuXHRcdCd0aHJvdycsJ2JyZWFrJywnY29udGludWUnLCdkZWJ1Z2dlcicsXG5cdFx0J2lmJywnZWxzZScsJ3N3aXRjaCcsJ2ZvcicsJ3doaWxlJywnZG8nLCd0cnknLCdjYXRjaCcsJ2ZpbmFsbHknLFxuXHRcdCdjbGFzcycsJ2V4dGVuZHMnLCdzdXBlcicsJ3JldHVybidcblx0XTtcblx0XG5cdC8vIG5ldyBjYW4gYmUgdXNlZCBhcyBhIGtleXdvcmQgaW4gaW1iYSwgc2luY2Ugb2JqZWN0IGluaXRpbmcgaXMgZG9uZSB0aHJvdWdoXG5cdC8vIE15T2JqZWN0Lm5ldy4gbmV3IGlzIGEgdmVyeSB1c2VmdWwgdmFybmFtZS5cblx0XG5cdC8vIFdlIHdhbnQgdG8gdHJlYXQgcmV0dXJuIGxpa2UgYW55IHJlZ3VsYXIgY2FsbCBmb3Igbm93XG5cdC8vIE11c3QgYmUgY2FyZWZ1bCB0byB0aHJvdyB0aGUgZXhjZXB0aW9ucyBpbiBBU1QsIHNpbmNlIHRoZSBwYXJzZXJcblx0Ly8gd29udFxuXHRcblx0Ly8gSW1iYS1vbmx5IGtleXdvcmRzLiB2YXIgc2hvdWxkIG1vdmUgdG8gSlNfS2V5d29yZHNcblx0Ly8gc29tZSB3b3JkcyAobGlrZSB0b2tpZCkgc2hvdWxkIGJlIGNvbnRleHQtc3BlY2lmaWNcblx0dmFyIElNQkFfS0VZV09SRFMgPSBbXG5cdFx0J3VuZGVmaW5lZCcsJ3RoZW4nLCd1bmxlc3MnLCd1bnRpbCcsJ2xvb3AnLCdvZicsJ2J5Jyxcblx0XHQnd2hlbicsJ2RlZicsJ3RhZycsJ2RvJywnZWxpZicsJ2JlZ2luJywndmFyJywnbGV0Jywnc2VsZicsJ2F3YWl0JywnaW1wb3J0J1xuXHRdO1xuXHRcblx0dmFyIElNQkFfQ09OVEVYVFVBTF9LRVlXT1JEUyA9IFsnZXh0ZW5kJywnc3RhdGljJywnbG9jYWwnLCdleHBvcnQnLCdnbG9iYWwnLCdwcm9wJ107XG5cdFxuXHR2YXIgSU1CQV9BTElBU19NQVAgPSB7XG5cdFx0J2FuZCc6ICcmJicsXG5cdFx0J29yJzogJ3x8Jyxcblx0XHQnaXMnOiAnPT0nLFxuXHRcdCdpc250JzogJyE9Jyxcblx0XHQnbm90JzogJyEnLFxuXHRcdCd5ZXMnOiAndHJ1ZScsXG5cdFx0J25vJzogJ2ZhbHNlJyxcblx0XHQnaXNhJzogJ2luc3RhbmNlb2YnLFxuXHRcdCdjYXNlJzogJ3N3aXRjaCcsXG5cdFx0J25pbCc6ICdudWxsJ1xuXHR9O1xuXHRcblx0dmFyIElNQkFfQUxJQVNFUyA9IE9iamVjdC5rZXlzKElNQkFfQUxJQVNfTUFQKTtcblx0SU1CQV9LRVlXT1JEUyA9IElNQkFfS0VZV09SRFMuY29uY2F0KElNQkFfQUxJQVNFUyk7XG5cdFxuXHQvLyBGaXhlZEFycmF5IGZvciBwZXJmb3JtYW5jZVxuXHQvLyB2YXIgQUxMX0tFWVdPUkRTID0gSlNfS0VZV09SRFMuY29uY2F0KElNQkFfS0VZV09SRFMpXG5cdG1vZHVsZS5leHBvcnRzLkFMTF9LRVlXT1JEUyA9IEFMTF9LRVlXT1JEUyA9IFtcblx0XHQndHJ1ZScsJ2ZhbHNlJywnbnVsbCcsJ3RoaXMnLFxuXHRcdCdkZWxldGUnLCd0eXBlb2YnLCdpbicsJ2luc3RhbmNlb2YnLFxuXHRcdCd0aHJvdycsJ2JyZWFrJywnY29udGludWUnLCdkZWJ1Z2dlcicsXG5cdFx0J2lmJywnZWxzZScsJ3N3aXRjaCcsJ2ZvcicsJ3doaWxlJywnZG8nLCd0cnknLCdjYXRjaCcsJ2ZpbmFsbHknLFxuXHRcdCdjbGFzcycsJ2V4dGVuZHMnLCdzdXBlcicsJ3JldHVybicsXG5cdFx0J3VuZGVmaW5lZCcsJ3RoZW4nLCd1bmxlc3MnLCd1bnRpbCcsJ2xvb3AnLCdvZicsJ2J5Jyxcblx0XHQnd2hlbicsJ2RlZicsJ3RhZycsJ2RvJywnZWxpZicsJ2JlZ2luJywndmFyJywnbGV0Jywnc2VsZicsJ2F3YWl0JywnaW1wb3J0Jyxcblx0XHQnYW5kJywnb3InLCdpcycsJ2lzbnQnLCdub3QnLCd5ZXMnLCdubycsJ2lzYScsJ2Nhc2UnLCduaWwnXG5cdF07XG5cdFxuXHQvLyBUaGUgbGlzdCBvZiBrZXl3b3JkcyB0aGF0IGFyZSByZXNlcnZlZCBieSBKYXZhU2NyaXB0LCBidXQgbm90IHVzZWQsIG9yIGFyZVxuXHQvLyB1c2VkIGJ5IEltYmEgaW50ZXJuYWxseS4gV2UgdGhyb3cgYW4gZXJyb3Igd2hlbiB0aGVzZSBhcmUgZW5jb3VudGVyZWQsXG5cdC8vIHRvIGF2b2lkIGhhdmluZyBhIEphdmFTY3JpcHQgZXJyb3IgYXQgcnVudGltZS4gICMgJ3ZhcicsICdsZXQnLCAtIG5vdCBpbnNpZGUgaGVyZVxuXHR2YXIgUkVTRVJWRUQgPSBbJ2Nhc2UnLCdkZWZhdWx0JywnZnVuY3Rpb24nLCd2b2lkJywnd2l0aCcsJ2NvbnN0JywnZW51bScsJ25hdGl2ZSddO1xuXHR2YXIgU1RSSUNUX1JFU0VSVkVEID0gWydjYXNlJywnZnVuY3Rpb24nLCd2b2lkJywnY29uc3QnXTtcblx0XG5cdC8vIFRoZSBzdXBlcnNldCBvZiBib3RoIEphdmFTY3JpcHQga2V5d29yZHMgYW5kIHJlc2VydmVkIHdvcmRzLCBub25lIG9mIHdoaWNoIG1heVxuXHQvLyBiZSB1c2VkIGFzIGlkZW50aWZpZXJzIG9yIHByb3BlcnRpZXMuXG5cdHZhciBKU19GT1JCSURERU4gPSBKU19LRVlXT1JEUy5jb25jYXQoUkVTRVJWRUQpO1xuXHRcblx0dmFyIE1FVEhPRF9JREVOVElGSUVSID0gL14oKChbXFx4MjNdP1tcXCRBLVphLXpfXFx4N2YtXFx1ZmZmZl1bJFxcLVxcd1xceDdmLVxcdWZmZmZdKikoW1xcPV0/KSl8KDw9PnxcXHwoPyFbXFx8PV0pKSkvO1xuXHQvLyByZW1vdmVkIH49fH58IHwmKD8hWyY9XSlcblx0XG5cdC8vIFRva2VuIG1hdGNoaW5nIHJlZ2V4ZXMuXG5cdC8vIGFkZGVkIGh5cGhlbnMgdG8gaWRlbnRpZmllcnMgbm93IC0gdG8gdGVzdFxuXHR2YXIgSURFTlRJRklFUiA9IC9eKChcXCR8QEB8QHxcXCMpW1xcd0EtWmEtel9cXC1cXHg3Zi1cXHVmZmZmXVskXFx3XFx4N2YtXFx1ZmZmZl0qKFxcLVskXFx3XFx4N2YtXFx1ZmZmZl0rKSp8WyRBLVphLXpfXVskXFx3XFx4N2YtXFx1ZmZmZl0qKFxcLVskXFx3XFx4N2YtXFx1ZmZmZl0rKSopKFteXFxuXFxTXSo6KD8hW1xcKlxcPTokXFx3XFx4N2YtXFx1ZmZmZl0pKT8vO1xuXHRcblx0dmFyIE9CSkVDVF9LRVkgPSAvXigoXFwkfEBAfEB8KVskQS1aYS16X1xceDdmLVxcdWZmZmZcXC1dWyRcXHdcXHg3Zi1cXHVmZmZmXFwtXSopKFteXFxuXFxTXFxzXSo6KD8hW1xcKlxcPTokXFx3XFx4N2YtXFx1ZmZmZl0pKS87XG5cdFxuXHR2YXIgVEFHID0gL14oXFw8fCUpKD89W0EtWmEtelxcI1xcLlxce1xcQFxcPl0pLztcblx0XG5cdHZhciBUQUdfVFlQRSA9IC9eKFxcd1tcXHdcXGRdKjopPyhcXHdbXFx3XFxkXSopKC1bXFx3XFxkXSspKi87XG5cdHZhciBUQUdfSUQgPSAvXiMoKFxcd1tcXHdcXGRdKikoLVtcXHdcXGRdKykqKS87XG5cdFxuXHR2YXIgVEFHX0FUVFIgPSAvXihbXFwuXFw6XT9bXFx3XFxfXSsoW1xcLVxcOl1bXFx3XSspKikoXFxzKSpcXD0vO1xuXHRcblx0dmFyIFNFTEVDVE9SID0gL14oWyVcXCRdezEsMn0pKFtcXChcXHdcXCNcXC5cXFtdKS87XG5cdHZhciBTRUxFQ1RPUl9QQVJUID0gL14oXFwjfFxcLnw6fDo6KT8oW1xcd10rKFxcLVtcXHddKykqKS87XG5cdHZhciBTRUxFQ1RPUl9DT01CSU5BVE9SID0gL14gKFxcK3xcXD58XFx+KSpcXHMqKD89W1xcd1xcLlxcI1xcOlxce1xcKlxcW10pLztcblx0XG5cdHZhciBTRUxFQ1RPUl9QU0VVRE9fQ0xBU1MgPSAvXig6Oj8pKFtcXHddKyhcXC1bXFx3XSspKikvO1xuXHR2YXIgU0VMRUNUT1JfQVRUUl9PUCA9IC9eKFxcJD18XFx+PXxcXF49fFxcKj18XFx8PXw9fFxcIT0pLztcblx0dmFyIFNFTEVDVE9SX0FUVFIgPSAvXlxcWyhbXFx3XFxfXFwtXSspKFxcJD18XFx+PXxcXF49fFxcKj18XFx8PXw9fFxcIT0pLztcblx0XG5cdHZhciBTWU1CT0wgPSAvXlxcOigoKFtcXCpcXEAkXFx3XFx4N2YtXFx1ZmZmZl0rKSsoW1xcLVxcXFwvXFxcXFxcOl1bXFx3XFx4N2YtXFx1ZmZmZl0rKSopfD09fFxcPD1cXD58XFxbXFxdfFxcW1xcXVxcPXxcXCp8W1xcXFwvLFxcXFxdKS87XG5cdFxuXHRcblx0dmFyIE5VTUJFUiA9IC9eMHhbXFxkYS1mXSt8XjBiWzAxXSt8XlxcZCpcXC4/XFxkKyg/OmVbKy1dP1xcZCspPy9pO1xuXHRcblx0dmFyIEhFUkVET0MgPSAvXihcIlwiXCJ8JycnKShbXFxzXFxTXSo/KSg/OlxcblteXFxuXFxTXSopP1xcMS87XG5cdFxuXHR2YXIgT1BFUkFUT1IgPSAvXig/OlstPV09Pnw9PT18LT58IT09fFstKypcXC8lPD4mfF4hPz1dPXw9PHw+Pj49P3woWy0rOl0pXFwxfChbJnw8Pl0pXFwyPT98XFw/XFwufFxcP1xcOnxcXC57MiwzfXxcXCooPz1bYS16QS1aXFxfXSkpLztcblx0XG5cdC8vIEZJWE1FIHNwbGF0IHNob3VsZCBvbmx5IGJlIGFsbG93ZWQgd2hlbiB0aGUgcHJldmlvdXMgdGhpbmcgaXMgc3BhY2VkIG9yIGluc2lkZSBjYWxsP1xuXHRcblx0dmFyIFdISVRFU1BBQ0UgPSAvXlteXFxuXFxTXSsvO1xuXHRcblx0dmFyIENPTU1FTlQgPSAvXiMjIyhbXiNdW1xcc1xcU10qPykoPzojIyNbXlxcblxcU10qfCg/OiMjIyk/JCkvO1xuXHQvLyBDT01NRU5UICAgID0gL14jIyMoW14jXVtcXHNcXFNdKj8pKD86IyMjW15cXG5cXFNdKnwoPzojIyMpPyQpfF4oPzpcXHMqKCNcXHMuKnwjXFxzKiQpKSsvXG5cdHZhciBJTkxJTkVfQ09NTUVOVCA9IC9eKFxccyopKCNbIFxcdFxcIV0oLiopfCNbIFxcdF0/KD89XFxufCQpKSsvO1xuXHRcblx0dmFyIENPREUgPSAvXlstPV09Pi87XG5cdFxuXHR2YXIgTVVMVElfREVOVCA9IC9eKD86XFxuW15cXG5cXFNdKikrLztcblx0XG5cdHZhciBTSU1QTEVTVFIgPSAvXidbXlxcXFwnXSooPzpcXFxcLlteXFxcXCddKikqJy87XG5cdFxuXHR2YXIgSlNUT0tFTiA9IC9eYFteXFxcXGBdKig/OlxcXFwuW15cXFxcYF0qKSpgLztcblx0XG5cdC8vIFJlZ2V4LW1hdGNoaW5nLXJlZ2V4ZXMuXG5cdHZhciBSRUdFWCA9IC9eKFxcLyg/IVtcXHM9XSlbXltcXC9cXG5cXFxcXSooPzooPzpcXFxcW1xcc1xcU118XFxbW15cXF1cXG5cXFxcXSooPzpcXFxcW1xcc1xcU11bXlxcXVxcblxcXFxdKikqXSlbXltcXC9cXG5cXFxcXSopKlxcLykoW2ltZ3ldezAsNH0pKD8hXFx3KS87XG5cdFxuXHR2YXIgSEVSRUdFWCA9IC9eXFwvezN9KFtcXHNcXFNdKz8pXFwvezN9KFtpbWd5XXswLDR9KSg/IVxcdykvO1xuXHRcblx0dmFyIEhFUkVHRVhfT01JVCA9IC9cXHMrKD86Iy4qKT8vZztcblx0XG5cdC8vIFRva2VuIGNsZWFuaW5nIHJlZ2V4ZXMuXG5cdHZhciBNVUxUSUxJTkVSID0gL1xcbi9nO1xuXHRcblx0dmFyIEhFUkVET0NfSU5ERU5UID0gL1xcbisoW15cXG5cXFNdKikvZztcblx0XG5cdHZhciBIRVJFRE9DX0lMTEVHQUwgPSAvXFwqXFwvLztcblx0XG5cdC8vIGV4cGVuc2l2ZT9cblx0dmFyIExJTkVfQ09OVElOVUVSID0gL15cXHMqKD86LHxcXD8/XFwuKD8hWy5cXGRdKXw6OikvO1xuXHRcblx0dmFyIFRSQUlMSU5HX1NQQUNFUyA9IC9cXHMrJC87XG5cdFxuXHR2YXIgQ09OU1RfSURFTlRJRklFUiA9IC9eW0EtWl0vO1xuXHRcblx0dmFyIEFSR1ZBUiA9IC9eXFwkXFxkJC87XG5cdFxuXHQvLyBDb21wb3VuZCBhc3NpZ25tZW50IHRva2Vucy5cblx0dmFyIENPTVBPVU5EX0FTU0lHTiA9IFsnLT0nLCcrPScsJy89JywnKj0nLCclPScsJ3x8PScsJyYmPScsJz89JywnPDw9JywnPj49JywnPj4+PScsJyY9JywnXj0nLCd8PScsJz08J107XG5cdFxuXHQvLyBVbmFyeSB0b2tlbnMuXG5cdHZhciBVTkFSWSA9IFsnIScsJ34nLCdORVcnLCdUWVBFT0YnLCdERUxFVEUnXTtcblx0XG5cdC8vIExvZ2ljYWwgdG9rZW5zLlxuXHR2YXIgTE9HSUMgPSBbJyYmJywnfHwnLCcmJywnfCcsJ14nXTtcblx0XG5cdC8vIEJpdC1zaGlmdGluZyB0b2tlbnMuXG5cdHZhciBTSElGVCA9IFsnPDwnLCc+PicsJz4+PiddO1xuXHRcblx0Ly8gQ29tcGFyaXNvbiB0b2tlbnMuXG5cdHZhciBDT01QQVJFID0gWyc9PT0nLCchPT0nLCc9PScsJyE9JywnPCcsJz4nLCc8PScsJz49JywnPT09JywnIT09J107XG5cdFxuXHQvLyBPdmVyaWRlYWJsZSBtZXRob2RzXG5cdHZhciBPUF9NRVRIT0RTID0gWyc8PT4nLCc8PCcsJy4uJ107XG5cdFxuXHQvLyBNYXRoZW1hdGljYWwgdG9rZW5zLlxuXHR2YXIgTUFUSCA9IFsnKicsJy8nLCclJywn4oiqJywn4oipJywn4oiaJ107XG5cdFxuXHQvLyBSZWxhdGlvbmFsIHRva2VucyB0aGF0IGFyZSBuZWdhdGFibGUgd2l0aCBgbm90YCBwcmVmaXguXG5cdHZhciBSRUxBVElPTiA9IFsnSU4nLCdPRicsJ0lOU1RBTkNFT0YnLCdJU0EnXTtcblx0XG5cdC8vIEJvb2xlYW4gdG9rZW5zLlxuXHR2YXIgQk9PTCA9IFsnVFJVRScsJ0ZBTFNFJywnTlVMTCcsJ1VOREVGSU5FRCddO1xuXHRcblx0Ly8gT3VyIGxpc3QgaXMgc2hvcnRlciwgZHVlIHRvIHNhbnMtcGFyZW50aGVzZXMgbWV0aG9kIGNhbGxzLlxuXHR2YXIgTk9UX1JFR0VYID0gWydOVU1CRVInLCdSRUdFWCcsJ0JPT0wnLCdUUlVFJywnRkFMU0UnLCcrKycsJy0tJywnXSddO1xuXHRcblx0Ly8gSWYgdGhlIHByZXZpb3VzIHRva2VuIGlzIG5vdCBzcGFjZWQsIHRoZXJlIGFyZSBtb3JlIHByZWNlZGluZyB0b2tlbnMgdGhhdFxuXHQvLyBmb3JjZSBhIGRpdmlzaW9uIHBhcnNlOlxuXHR2YXIgTk9UX1NQQUNFRF9SRUdFWCA9IFsnTlVNQkVSJywnUkVHRVgnLCdCT09MJywnVFJVRScsJ0ZBTFNFJywnKysnLCctLScsJ10nLCcpJywnfScsJ1RISVMnLCdTRUxGJywnSURFTlRJRklFUicsJ1NUUklORyddO1xuXHRcblx0Ly8gVG9rZW5zIHdoaWNoIGNvdWxkIGxlZ2l0aW1hdGVseSBiZSBpbnZva2VkIG9yIGluZGV4ZWQuIEFuIG9wZW5pbmdcblx0Ly8gcGFyZW50aGVzZXMgb3IgYnJhY2tldCBmb2xsb3dpbmcgdGhlc2UgdG9rZW5zIHdpbGwgYmUgcmVjb3JkZWQgYXMgdGhlIHN0YXJ0XG5cdC8vIG9mIGEgZnVuY3Rpb24gaW52b2NhdGlvbiBvciBpbmRleGluZyBvcGVyYXRpb24uXG5cdC8vIHJlYWxseT8hXG5cdFxuXHR2YXIgVU5GSU5JU0hFRCA9IFsnXFxcXCcsJy4nLCc/LicsJz86JywnVU5BUlknLCdNQVRIJywnKycsJy0nLCdTSElGVCcsJ1JFTEFUSU9OJywnQ09NUEFSRScsJ0xPR0lDJywnQ09NUE9VTkRfQVNTSUdOJywnVEhST1cnLCdFWFRFTkRTJ107XG5cdFxuXHQvLyB9IHNob3VsZCBub3QgYmUgY2FsbGFibGUgYW55bW9yZSEhISAnfScsICc6OicsXG5cdHZhciBDQUxMQUJMRSA9IFsnSURFTlRJRklFUicsJ1NUUklORycsJ1JFR0VYJywnKScsJ10nLCdUSElTJywnU1VQRVInLCdUQUdfRU5EJywnSVZBUicsJ0dWQVInLCdTRUxGJywnQ09OU1QnLCdORVcnLCdBUkdWQVInLCdTWU1CT0wnLCdSRVRVUk4nXTtcblx0Ly8gdmFyIElOREVYQUJMRSA9IENBTExBQkxFLmNvbmNhdCAnTlVNQkVSJywgJ0JPT0wnLCAnVEFHX1NFTEVDVE9SJywgJ0lEUkVGJywgJ0FSR1VNRU5UUycsJ30nICMgYXJlIGJvb2xlYW5zIGluZGV4YWJsZT8gcmVhbGx5P1xuXHQvLyBvcHRpbWl6ZSBmb3IgRml4ZWRBcnJheVxuXHR2YXIgSU5ERVhBQkxFID0gW1xuXHRcdCdJREVOVElGSUVSJywnU1RSSU5HJywnUkVHRVgnLCcpJywnXScsJ1RISVMnLCdTVVBFUicsJ1RBR19FTkQnLCdJVkFSJywnR1ZBUicsJ1NFTEYnLCdDT05TVCcsJ05FVycsJ0FSR1ZBUicsJ1NZTUJPTCcsJ1JFVFVSTicsXG5cdFx0J05VTUJFUicsJ0JPT0wnLCdUQUdfU0VMRUNUT1InLCdJRFJFRicsJ0FSR1VNRU5UUycsJ30nLCdUQUdfVFlQRSdcblx0XTtcblx0XG5cdHZhciBHTE9CQUxfSURFTlRJRklFUlMgPSBbJ2dsb2JhbCcsJ2V4cG9ydHMnLCdyZXF1aXJlJ107XG5cdFxuXHQvLyBUb2tlbnMgdGhhdCwgd2hlbiBpbW1lZGlhdGVseSBwcmVjZWRpbmcgYSBgV0hFTmAsIGluZGljYXRlIHRoYXQgdGhlIGBXSEVOYFxuXHQvLyBvY2N1cnMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS4gV2UgZGlzYW1iaWd1YXRlIHRoZXNlIGZyb20gdHJhaWxpbmcgd2hlbnMgdG9cblx0Ly8gYXZvaWQgYW4gYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyLlxuXHR2YXIgTElORV9CUkVBSyA9IFsnSU5ERU5UJywnT1VUREVOVCcsJ1RFUk1JTkFUT1InXTtcblx0XG5cdFxuXHRmdW5jdGlvbiBMZXhlckVycm9yKG1lc3NhZ2UsZmlsZSxsaW5lKXtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdHRoaXMuZmlsZSA9IGZpbGU7XG5cdFx0dGhpcy5saW5lID0gbGluZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0c3ViY2xhc3MkKExleGVyRXJyb3IsU3ludGF4RXJyb3IpO1xuXHRleHBvcnRzLkxleGVyRXJyb3IgPSBMZXhlckVycm9yOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIGxhc3QoYXJyYXksYmFjayl7XG5cdFx0aWYoYmFjayA9PT0gdW5kZWZpbmVkKSBiYWNrID0gMDtcblx0XHRyZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gYmFjayAtIDFdO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gY291bnQoc3RyLHN1YnN0cil7XG5cdFx0cmV0dXJuIHN0ci5zcGxpdChzdWJzdHIpLmxlbmd0aCAtIDE7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiByZXBlYXRTdHJpbmcoc3RyLHRpbWVzKXtcblx0XHR2YXIgcmVzID0gJyc7XG5cdFx0d2hpbGUgKHRpbWVzID4gMCl7XG5cdFx0XHRpZiAodGltZXMgJSAyID09IDEpIHtcblx0XHRcdFx0cmVzICs9IHN0cjtcblx0XHRcdH07XG5cdFx0XHRzdHIgKz0gc3RyO1xuXHRcdFx0dGltZXMgPj49IDE7XG5cdFx0fTtcblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xuXHRcblx0dmFyIHRUID0gVC50eXA7XG5cdHZhciB0ViA9IFQudmFsO1xuXHR2YXIgdFRzID0gVC5zZXRUeXA7XG5cdHZhciB0VnMgPSBULnNldFZhbDtcblx0XG5cdC8vIFRoZSBMZXhlciBjbGFzcyByZWFkcyBhIHN0cmVhbSBvZiBJbWJhIGFuZCBkaXZ2aWVzIGl0IHVwIGludG8gdG9raWRnZWRcblx0Ly8gdG9rZW5zLiBTb21lIHBvdGVudGlhbCBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIgaGFzIGJlZW4gYXZvaWRlZCBieVxuXHQvLyBwdXNoaW5nIHNvbWUgZXh0cmEgc21hcnRzIGludG8gdGhlIExleGVyLlxuXHRcblx0Ly8gQmFzZWQgb24gdGhlIG9yaWdpbmFsIGxleGVyLmNvZmZlZSBmcm9tIENvZmZlZVNjcmlwdFxuXHRmdW5jdGlvbiBMZXhlcigpe1xuXHRcdHRoaXMucmVzZXQoKTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5MZXhlciA9IExleGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdExleGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX2NvZGUgPSBudWxsO1xuXHRcdHRoaXMuX2NodW5rID0gbnVsbDsgLy8gVGhlIHJlbWFpbmRlciBvZiB0aGUgc291cmNlIGNvZGUuXG5cdFx0dGhpcy5fb3B0cyA9IG51bGw7XG5cdFx0XG5cdFx0dGhpcy5faW5kZW50ID0gMDsgLy8gVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwuXG5cdFx0dGhpcy5faW5kZWJ0ID0gMDsgLy8gVGhlIG92ZXItaW5kZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0dGhpcy5fb3V0ZGVidCA9IDA7IC8vIFRoZSB1bmRlci1vdXRkZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0XG5cdFx0dGhpcy5faW5kZW50cyA9IFtdOyAvLyBUaGUgc3RhY2sgb2YgYWxsIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWxzLlxuXHRcdHRoaXMuX2VuZHMgPSBbXTsgLy8gVGhlIHN0YWNrIGZvciBwYWlyaW5nIHVwIHRva2Vucy5cblx0XHR0aGlzLl9jb250ZXh0cyA9IFtdOyAvLyBzdXBsZW1lbnRzIEBlbmRzXG5cdFx0dGhpcy5fc2NvcGVzID0gW107XG5cdFx0dGhpcy5fbmV4dFNjb3BlID0gbnVsbDsgLy8gdGhlIHNjb3BlIHRvIGFkZCBvbiB0aGUgbmV4dCBpbmRlbnRcblx0XHQvLyBzaG91bGQgcmF0aGVyIG1ha2UgaXQgbGlrZSBhIHN0YXRlbWFjaGluZSB0aGF0IG1vdmVzIGZyb20gQ0xBU1NfREVGIHRvIENMQVNTX0JPRFkgZXRjXG5cdFx0Ly8gVGhpbmdzIHNob3VsZCBjb21waWxlIGRpZmZlcmVudGx5IHdoZW4geW91IGFyZSBpbiBhIENMQVNTX0JPRFkgdGhhbiB3aGVuIGluIGEgREVGX0JPRFkrK1xuXHRcdFxuXHRcdHRoaXMuX3Rva2VucyA9IFtdOyAvLyBTdHJlYW0gb2YgcGFyc2VkIHRva2VucyBpbiB0aGUgZm9ybSBgWydUWVBFJywgdmFsdWUsIGxpbmVdYC5cblx0XHR0aGlzLl9zZWVuRm9yID0gZmFsc2U7XG5cdFx0dGhpcy5fbG9jID0gMDtcblx0XHR0aGlzLl9sb2NPZmZzZXQgPSAwO1xuXHRcdFxuXHRcdHRoaXMuX2VuZCA9IG51bGw7XG5cdFx0dGhpcy5fY2hhciA9IG51bGw7XG5cdFx0dGhpcy5fYnJpZGdlID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0ID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0VHlwID0gJyc7XG5cdFx0dGhpcy5fbGFzdFZhbCA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuamlzb25CcmlkZ2UgPSBmdW5jdGlvbiAoamlzb24pe1xuXHRcdHJldHVybiB0aGlzLl9icmlkZ2UgPSB7XG5cdFx0XHRsZXg6IFQubGV4LFxuXHRcdFx0c2V0SW5wdXQ6IGZ1bmN0aW9uKHRva2Vucykge1xuXHRcdFx0XHR0aGlzLnRva2VucyA9IHRva2Vucztcblx0XHRcdFx0cmV0dXJuIHRoaXMucG9zID0gMDtcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcIjsgfVxuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKGNvZGUsbyl7XG5cdFx0XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0aWYgKGNvZGUubGVuZ3RoID09IDApIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghby5pbmxpbmUpIHtcblx0XHRcdGlmIChXSElURVNQQUNFLnRlc3QoY29kZSkpIHtcblx0XHRcdFx0Y29kZSA9IChcIlxcblwiICsgY29kZSk7XG5cdFx0XHRcdGlmIChjb2RlLm1hdGNoKC9eXFxzKiQvZykpIHsgcmV0dXJuIFtdIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb2RlID0gY29kZS5yZXBsYWNlKC9cXHIvZywnJykucmVwbGFjZSgvW1xcdCBdKyQvZywnJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9sYXN0ID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0VHlwID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0VmFsID0gbnVsbDtcblx0XHRcblx0XHR0aGlzLl9jb2RlID0gY29kZTtcblx0XHR0aGlzLl9vcHRzID0gbztcblx0XHR0aGlzLl9sb2NPZmZzZXQgPSBvLmxvYyB8fCAwO1xuXHRcdC8vIGFkZCBhIHJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvYmplY3Rcblx0XHRvLl90b2tlbnMgPSB0aGlzLl90b2tlbnM7XG5cdFx0Ly8gd2hhdCBhYm91dCBjb2wgaGVyZT9cblx0XHRcblx0XHQvLyBAaW5kZW50ICA9IDAgIyBUaGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC5cblx0XHQvLyBAaW5kZWJ0ICA9IDAgIyBUaGUgb3Zlci1pbmRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHQvLyBAb3V0ZGVidCA9IDAgIyBUaGUgdW5kZXItb3V0ZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdC8vIEBpbmRlbnRzID0gW10gIyBUaGUgc3RhY2sgb2YgYWxsIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWxzLlxuXHRcdC8vIEBlbmRzICAgID0gW10gIyBUaGUgc3RhY2sgZm9yIHBhaXJpbmcgdXAgdG9rZW5zLlxuXHRcdC8vIEB0b2tlbnMgID0gW10gIyBTdHJlYW0gb2YgcGFyc2VkIHRva2VucyBpbiB0aGUgZm9ybSBgWydUWVBFJywgdmFsdWUsIGxpbmVdYC5cblx0XHQvLyBAY2hhciA9IG5pbFxuXHRcdFxuXHRcdGlmIChvLnByb2ZpbGUpIHsgY29uc29sZS50aW1lKFwidG9rZW5pemU6bGV4ZXJcIikgfTtcblx0XHR0aGlzLnBhcnNlKGNvZGUpO1xuXHRcdGlmICghby5pbmxpbmUpIHRoaXMuY2xvc2VJbmRlbnRhdGlvbigpO1xuXHRcdGlmICghby5zaWxlbnQgJiYgdGhpcy5fZW5kcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuZXJyb3IoKFwibWlzc2luZyBcIiArICh0aGlzLl9lbmRzLnBvcCgpKSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG8ucHJvZmlsZSkgeyBjb25zb2xlLnRpbWVFbmQoXCJ0b2tlbml6ZTpsZXhlclwiKSB9O1xuXHRcdGlmIChvLnJld3JpdGUgPT0gZmFsc2UgfHwgby5ub3Jld3JpdGUpIHsgcmV0dXJuIHRoaXMuX3Rva2VucyB9O1xuXHRcdHJldHVybiBuZXcgUmV3cml0ZXIoKS5yZXdyaXRlKHRoaXMuX3Rva2VucyxvKTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHBpID0gMDtcblx0XHRcblx0XHR3aGlsZSAodGhpcy5fY2h1bmsgPSBjb2RlLnNsaWNlKGkpKXtcblx0XHRcdHRoaXMuX2xvYyA9IHRoaXMuX2xvY09mZnNldCArIGk7XG5cdFx0XHRwaSA9ICh0aGlzLl9lbmQgPT0gJ1RBRycgJiYgdGhpcy50YWdEZWZDb250ZXh0VG9rZW4oKSkgfHwgKHRoaXMuX2luVGFnICYmIHRoaXMudGFnQ29udGV4dFRva2VuKCkpIHx8IHRoaXMuYmFzaWNDb250ZXh0KCk7XG5cdFx0XHRpICs9IHBpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmJhc2ljQ29udGV4dCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnNlbGVjdG9yVG9rZW4oKSB8fCB0aGlzLnN5bWJvbFRva2VuKCkgfHwgdGhpcy5tZXRob2ROYW1lVG9rZW4oKSB8fCB0aGlzLmlkZW50aWZpZXJUb2tlbigpIHx8IHRoaXMud2hpdGVzcGFjZVRva2VuKCkgfHwgdGhpcy5saW5lVG9rZW4oKSB8fCB0aGlzLmNvbW1lbnRUb2tlbigpIHx8IHRoaXMuaGVyZWRvY1Rva2VuKCkgfHwgdGhpcy50YWdUb2tlbigpIHx8IHRoaXMuc3RyaW5nVG9rZW4oKSB8fCB0aGlzLm51bWJlclRva2VuKCkgfHwgdGhpcy5yZWdleFRva2VuKCkgfHwgdGhpcy5qc1Rva2VuKCkgfHwgdGhpcy5saXRlcmFsVG9rZW4oKSB8fCAwO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLm1vdmVDYXJldCA9IGZ1bmN0aW9uIChpKXtcblx0XHRyZXR1cm4gdGhpcy5fbG9jICs9IGk7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV07XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuaW5Db250ZXh0ID0gZnVuY3Rpb24gKGtleSl7XG5cdFx0dmFyIG8gPSB0aGlzLl9jb250ZXh0c1t0aGlzLl9jb250ZXh0cy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4gbyAmJiBvW2tleV07XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucHVzaEVuZCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwicHVzaGluZyBlbmRcIix2YWxcblx0XHR0aGlzLl9lbmRzLnB1c2godmFsKTtcblx0XHR0aGlzLl9jb250ZXh0cy5wdXNoKG51bGwpO1xuXHRcdHRoaXMuX2VuZCA9IHZhbDtcblx0XHR0aGlzLnJlZnJlc2hTY29wZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnBvcEVuZCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHRoaXMuX2VuZHMucG9wKCk7XG5cdFx0dGhpcy5fY29udGV4dHMucG9wKCk7XG5cdFx0dGhpcy5fZW5kID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdO1xuXHRcdHRoaXMucmVmcmVzaFNjb3BlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucmVmcmVzaFNjb3BlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGN0eDAgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0dmFyIGN0eDEgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMl07XG5cdFx0cmV0dXJuIHRoaXMuX2luVGFnID0gY3R4MCA9PSAnVEFHX0VORCcgfHwgKGN0eDEgPT0gJ1RBR19FTkQnICYmIGN0eDAgPT0gJ09VVERFTlQnKTtcblx0fTtcblx0XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLnF1ZXVlU2NvcGUgPSBmdW5jdGlvbiAodmFsKXtcblx0XHQvLyBjb25zb2xlLmxvZyhcInB1c2hpbmcgc2NvcGUge3ZhbH0gLSB7QGluZGVudHN9IHtAaW5kZW50czpsZW5ndGh9XCIpXG5cdFx0Ly8gQHNjb3Blcy5wdXNoKHZhbCkgIyBubyBub1xuXHRcdHRoaXMuX3Njb3Blc1t0aGlzLl9pbmRlbnRzLmxlbmd0aF0gPSB2YWw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucG9wU2NvcGUgPSBmdW5jdGlvbiAodmFsKXtcblx0XHR0aGlzLl9zY29wZXMucG9wKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuZ2V0U2NvcGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGVzW3RoaXMuX2luZGVudHMubGVuZ3RoIC0gMV07XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbiAoc3ltLG9wdHMpe1xuXHRcdHZhciBsZW4gPSB0aGlzLl9lbmRzLnB1c2godGhpcy5fZW5kID0gc3ltKTtcblx0XHR0aGlzLl9jb250ZXh0cy5wdXNoKG9wdHMgfHwgbnVsbCk7XG5cdFx0cmV0dXJuIHN5bTtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuY2xvc2VTZWxlY3RvciA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9lbmQgPT0gJyUnKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9FTkQnLCclJywwKTtcblx0XHRcdHJldHVybiB0aGlzLnBhaXIoJyUnKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5vcGVuRGVmID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMucHVzaEVuZCgnREVGJyk7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLmNsb3NlRGVmID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuY29udGV4dCgpID09ICdERUYnKSB7XG5cdFx0XHR2YXIgcHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiY2xvc2UgZGVmIHtwcmV2fVwiXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnY2xvc2VEZWYgd2l0aCBsYXN0PicscHJldilcblx0XHRcdGlmICh0VChwcmV2KSA9PSAnREVGX0ZSQUdNRU5UJykge1xuXHRcdFx0XHR0cnVlO1xuXHRcdFx0fSBlbHNlIGlmICh0VChwcmV2KSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJoZXJlPyE/P1wiXG5cdFx0XHRcdHZhciBuID0gdGhpcy5fdG9rZW5zLnBvcCgpO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBuXG5cdFx0XHRcdHRoaXMudG9rZW4oJ0RFRl9CT0RZJywnREVGX0JPRFknLDApO1xuXHRcdFx0XHQvLyB0b2tlbignVEVSTUlOQVRPUicsICcnLDApIHVubGVzcyBuLkB2YWx1ZS5pbmRleE9mKCcvLycpID49IDBcblx0XHRcdFx0dGhpcy5fdG9rZW5zLnB1c2gobik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdERUZfQk9EWScsJ0RFRl9CT0RZJywwKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMucGFpcignREVGJyk7XG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUudGFnQ29udGV4dFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdGlmICh0aGlzLl9jaHVua1swXSA9PSAnIycpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdmb3VuZCBpZCAjIGluIHRhZ0NvbnRleHRUb2tlbicpXG5cdFx0XHR0aGlzLnRva2VuKCcjJywnIycsMSk7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChtYXRjaCA9IFRBR19BVFRSLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnVEFHX1NERFNBVFRSIElOIHRva2lkJyxtYXRjaFxuXHRcdFx0Ly8gdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHRcdC8vIGlmIHRoZSBwcmV2IGlzIGEgdGVybWluYXRvciwgd2UgZG9udCByZWFsbHkgbmVlZCB0byBjYXJlP1xuXHRcdFx0aWYgKHRoaXMuX2xhc3RUeXAgIT0gJ1RBR19OQU1FJykge1xuXHRcdFx0XHRpZiAodGhpcy5fbGFzdFR5cCA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygncHJldiB3YXMgdGVybWluYXRvciAtLSBkcm9wIGl0PycpXG5cdFx0XHRcdFx0dHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRva2VuKFwiLFwiLFwiLFwiKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBsID0gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnRva2VuKCdUQUdfQVRUUicsbWF0Y2hbMV0sbCAtIDEpOyAvLyBhZGQgdG8gbG9jP1xuXHRcdFx0dGhpcy5fbG9jICs9IGwgLSAxO1xuXHRcdFx0dGhpcy50b2tlbignPScsJz0nLDEpO1xuXHRcdFx0cmV0dXJuIGw7XG5cdFx0fTtcblx0XHRyZXR1cm4gMDtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS50YWdEZWZDb250ZXh0VG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcInRhZ0NvbnRleHRUb2tlblwiXG5cdFx0dmFyIG1hdGNoO1xuXHRcdGlmIChtYXRjaCA9IFRBR19UWVBFLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdUQUdfVFlQRScsbWF0Y2hbMF0sbWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAobWF0Y2ggPSBUQUdfSUQuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHZhciBpbnB1dCA9IG1hdGNoWzBdO1xuXHRcdFx0dGhpcy50b2tlbignVEFHX0lEJyxpbnB1dCxpbnB1dC5sZW5ndGgpO1xuXHRcdFx0cmV0dXJuIGlucHV0Lmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiAwO1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS50YWdUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCwgYXJ5O1xuXHRcdGlmICghKG1hdGNoID0gVEFHLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdHZhciBhcnkgPSBpdGVyJChtYXRjaCk7dmFyIGlucHV0ID0gYXJ5WzBdLHR5cGUgPSBhcnlbMV0saWRlbnRpZmllciA9IGFyeVsyXTtcblx0XHRcblx0XHRpZiAodHlwZSA9PSAnPCcpIHtcblx0XHRcdHRoaXMudG9rZW4oJ1RBR19TVEFSVCcsJzwnLDEpO1xuXHRcdFx0dGhpcy5wdXNoRW5kKElOVkVSU0VTLlRBR19TVEFSVCk7XG5cdFx0XHRcblx0XHRcdGlmIChtYXRjaCA9IFRBR19UWVBFLmV4ZWModGhpcy5fY2h1bmsuc3Vic3RyKDEsNDApKSkge1xuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2Ugc2hvdWxkIHByb2JhYmx5IGJlIGhhbmRsZWQgaW4gQVNUXG5cdFx0XHRcdGlmIChtYXRjaFswXSAhPSAnc2VsZicpIHtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdUQUdfVFlQRScsbWF0Y2hbMF0sbWF0Y2hbMF0ubGVuZ3RoLDEpO1xuXHRcdFx0XHRcdHJldHVybiBpbnB1dC5sZW5ndGggKyBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoaWRlbnRpZmllcikge1xuXHRcdFx0XHRpZiAoaWRlbnRpZmllci5zdWJzdHIoMCwxKSA9PSAneycpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHlwZS5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignVEFHX05BTUUnLGlucHV0LnN1YnN0cigxKSwwKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gaW5wdXQubGVuZ3RoO1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5zZWxlY3RvclRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyeSwgc3RyaW5nO1xuXHRcdHZhciBtYXRjaDtcblx0XHRcblx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGlmIHdlIGFyZSBpbiB0aGlzIGNvbnRleHRcblx0XHRpZiAodGhpcy5fZW5kID09ICclJykge1xuXHRcdFx0dmFyIGNociA9IHRoaXMuX2NodW5rLmNoYXJBdCgwKTtcblx0XHRcdHZhciBvcGVuID0gdGhpcy5pbkNvbnRleHQoJ29wZW4nKTtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIGFkZCBmb3IgKywgfiBldGNcblx0XHRcdC8vIHNob3VsZCBtYXliZSByYXRoZXIgbG9vayBmb3IgdGhlIGNvcnJlY3QgdHlwZSBvZiBjaGFyYWN0ZXI/XG5cdFx0XHRcblx0XHRcdGlmIChvcGVuICYmIChjaHIgPT0gJyAnIHx8IGNociA9PSAnXFxuJyB8fCBjaHIgPT0gJywnIHx8IGNociA9PSAnKycgfHwgY2hyID09ICd+JyB8fCBjaHIgPT0gJyknIHx8IGNociA9PSAnXScpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiY2xvc2UgdGhpcyBzZWxlY3RvciBkaXJlY3RseVwiXG5cdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0VORCcsJyUnLDApO1xuXHRcdFx0XHR0aGlzLnBhaXIoJyUnKTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2ggPSBTRUxFQ1RPUl9DT01CSU5BVE9SLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRcdC8vIHNwYWNlcyBiZXR3ZWVuPyAtLSBpbmNsdWRlIHRoZSB3aG9sZVxuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9DT01CSU5BVE9SJyxtYXRjaFsxXSB8fCBcIiBcIixtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRjaCA9IFNFTEVDVE9SX1BBUlQuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBtYXRjaFsxXTtcblx0XHRcdFx0dmFyIGlkID0gbWF0Y2hbMl07XG5cdFx0XHRcdFxuXHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICcuJzpcblx0XHRcdFx0XHRcdHRva2lkID0gJ1NFTEVDVE9SX0NMQVNTJzticmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlICcjJzpcblx0XHRcdFx0XHRcdHRva2lkID0gJ1NFTEVDVE9SX0lEJzticmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlICc6Jzpcblx0XHRcdFx0XHRcdHRva2lkID0gJ1NFTEVDVE9SX1BTRVVET19DTEFTUyc7YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSAnOjonOlxuXHRcdFx0XHRcdFx0dG9raWQgPSAnU0VMRUNUT1JfUFNFVURPX0NMQVNTJzticmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dmFyIHRva2lkID0gJ1NFTEVDVE9SX1RBRyc7XG5cdFx0XHRcdFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy50b2tlbih0b2tpZCxtYXRjaFsyXSxtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJ1snKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1snLCdbJywxKTtcblx0XHRcdFx0dGhpcy5wdXNoRW5kKCddJyk7XG5cdFx0XHRcdGlmIChtYXRjaCA9IFNFTEVDVE9SX0FUVFIuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdFx0XHQvLyBmdWNrIHRoaXMgbGVuZ3RoIHNoaXRcblx0XHRcdFx0XHR2YXIgaWRvZmZzZXQgPSBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzFdKTtcblx0XHRcdFx0XHR2YXIgb3BvZmZzZXQgPSBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzJdKTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdJREVOVElGSUVSJyxtYXRjaFsxXSxtYXRjaFsxXS5sZW5ndGgsaWRvZmZzZXQpO1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0FUVFJfT1AnLG1hdGNoWzJdLG1hdGNoWzJdLmxlbmd0aCxvcG9mZnNldCk7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnfCcpIHtcblx0XHRcdFx0dmFyIHRvayA9IHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdHRUcyh0b2ssJ1NFTEVDVE9SX05TJyk7XG5cdFx0XHRcdC8vIHRva1swXSA9ICdTRUxFQ1RPUl9OUycgIyBGSVhcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnLCcpIHtcblx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfR1JPVVAnLCcsJywxKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnKicpIHtcblx0XHRcdFx0dGhpcy50b2tlbignVU5JVkVSU0FMX1NFTEVDVE9SJywnKicsMSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJyknKSB7XG5cdFx0XHRcdHRoaXMucGFpcignJScpO1xuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9FTkQnLCcpJywxKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGlkeCQoY2hyLFsnKScsJ30nLCddJywnJ10pID49IDApIHtcblx0XHRcdFx0dGhpcy5wYWlyKCclJyk7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gU0VMRUNUT1IuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKG1hdGNoKTt2YXIgaW5wdXQgPSBhcnlbMF0saWQgPSBhcnlbMV0sa2luZCA9IGFyeVsyXTtcblx0XHRcblx0XHQvLyB0aGlzIGlzIGEgY2xvc2VkIHNlbGVjdG9yXG5cdFx0aWYgKGtpbmQgPT0gJygnKSB7XG5cdFx0XHQvLyB0b2tlbiAnKCcsJygnXG5cdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9TVEFSVCcsaWQsaWQubGVuZ3RoICsgMSk7XG5cdFx0XHQvLyBzZWxmLnB1c2hFbmQoJyknKSAjIGFyZSB3ZSBzbyBzdXJlIGFib3V0IHRoaXM/XG5cdFx0XHR0aGlzLnB1c2hFbmQoJyUnKTtcblx0XHRcdFxuXHRcdFx0Ly8gQGVuZHMucHVzaCAnKSdcblx0XHRcdC8vIEBlbmRzLnB1c2ggJyUnXG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoICsgMTtcblx0XHR9IGVsc2UgaWYgKGlkID09ICclJykge1xuXHRcdFx0Ly8gd2UgYXJlIGFscmVhZHkgc2NvcGVkIGluIG9uIGEgc2VsZWN0b3Jcblx0XHRcdGlmICh0aGlzLmNvbnRleHQoKSA9PSAnJScpIHsgcmV0dXJuIDEgfTtcblx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX1NUQVJUJyxpZCxpZC5sZW5ndGgpO1xuXHRcdFx0Ly8gdGhpcyBpcyBhIHNlcGFyYXRlIC0gc2NvcGUuIEZ1bGwgc2VsZWN0b3Igc2hvdWxkIHJhdGhlciBiZSAkLCBhbmQga2VlcCB0aGUgc2luZ2xlIHNlbGVjdG9yIGFzICVcblx0XHRcdFxuXHRcdFx0dGhpcy5zY29wZSgnJScse29wZW46IHRydWV9KTtcblx0XHRcdC8vIEBlbmRzLnB1c2ggJyUnXG5cdFx0XHQvLyBtYWtlIHN1cmUgYSB0ZXJtaW5hdG9yIGJyZWFrcyBvdXRcblx0XHRcdHJldHVybiBpZC5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKChpZCA9PSAnJScgfHwgaWQgPT0gJyQnKSAmJiBbJyUnLCckJywnQCcsJygnLCdbJ10uaW5kZXhPZihjaHIpID49IDApIHtcblx0XHRcdHZhciBpZHggPSAyO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vIFZFUlkgdGVtcG9yYXJ5IHdheSBvZiBzb2x2aW5nIHRoaXNcblx0XHRcdGlmICgoY2hyID09ICclJyB8fCBjaHIgPT0gJyQnIHx8IGNociA9PSAnQCcpKSB7XG5cdFx0XHRcdGlkICs9IGNocjtcblx0XHRcdFx0aWR4ID0gMztcblx0XHRcdFx0Y2hyID0gdGhpcy5fY2h1bmsuY2hhckF0KDIpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRpZiAoY2hyID09ICcoJykge1xuXHRcdFx0XHRpZiAoIShzdHJpbmcgPSB0aGlzLmJhbGFuY2VkU2VsZWN0b3IodGhpcy5fY2h1bmssJyknKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcdFx0aWYgKDAgPCBzdHJpbmcuaW5kZXhPZigneycsMSkpIHtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUicsaWQpO1xuXHRcdFx0XHRcdC8vIGlzIHRoaXMgZXZlbiB1c2VkIGFueW1vcmU/IElmIHNvIC0gd2UgbmVlZCB0byBmaXggaXRcblx0XHRcdFx0XHR0aGlzLmludGVycG9sYXRlU3RyaW5nKHN0cmluZy5zbGljZShpZHgsLTEpKTtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUicsaWQpO1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJygnLCcoJyk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HJywnXCInICsgc3RyaW5nLnNsaWNlKGlkeCwtMSkgKyAnXCInKTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCcpJywnKScpO1xuXHRcdFx0XHRcdHJldHVybiBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJ1snKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SJyxpZCk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHQvLyB0b2tlbiAnWycsJ1snXG5cdFx0XHRcdC8vIEBlbmRzLnB1c2ggJydcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvLyBpcyB0aGlzIHJlYWxseSBuZWVkZWQ/IFNob3VsZCBiZSBwb3NzaWJsZSB0b1xuXHQvLyBwYXJzZSB0aGUgaWRlbnRpZmllcnMgYW5kID0gZXRjIGkgamlzb24/XG5cdC8vIHdoYXQgaXMgc3BlY2lhbCBhYm91dCBtZXRob2ROYW1lVG9rZW4/IHJlYWxseT9cblx0TGV4ZXIucHJvdG90eXBlLm1ldGhvZE5hbWVUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IGFmdGVyIGEgZGVmIHNpbXBseVxuXHRcdC8vIGZldGNoaW5nIGFsbCB0aGUgd2F5IGFmdGVyIHRoZSBkZWYgdW50aWwgYSBzcGFjZSBvciAoXG5cdFx0Ly8gYW5kIHRoZW4gYWRkIHRoaXMgdG8gdGhlIGRlZi10b2tlbiBpdHNlbGYgKGFzIHdpdGggZnJhZ21lbnQpXG5cdFx0aWYgKHRoaXMuX2NodW5rLmNoYXJBdCgwKSA9PSAnICcpIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHR2YXIgbWF0Y2g7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2VuZCA9PSAnKScpIHtcblx0XHRcdHZhciBvdXRlcmN0eCA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAyXTtcblx0XHRcdC8vIHdlaXJkIGFzc3VtcHRpb24sIG5vP1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2NvbnRleHQgaXMgaW5zaWRlISEhJ1xuXHRcdFx0aWYgKG91dGVyY3R4ID09ICclJyAmJiAobWF0Y2ggPSBUQUdfQVRUUi5leGVjKHRoaXMuX2NodW5rKSkpIHtcblx0XHRcdFx0dGhpcy50b2tlbignVEFHX0FUVFJfU0VUJyxtYXRjaFsxXSk7XG5cdFx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBNRVRIT0RfSURFTlRJRklFUi5leGVjKHRoaXMuX2NodW5rKSkpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0Ly8gdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHR2YXIgbGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFxuXHRcdHZhciBpZCA9IG1hdGNoWzBdO1xuXHRcdHZhciBsdHlwID0gdGhpcy5fbGFzdFR5cDtcblx0XHR2YXIgdHlwID0gJ0lERU5USUZJRVInO1xuXHRcdHZhciBwcmUgPSBpZC5jaGFyQXQoMCk7XG5cdFx0dmFyIHNwYWNlID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIG00ID0gbWF0Y2hbNF07IC8vIG1pZ2h0IGJlIG91dCBvZiBib3VuZHM/IHNob3VsZCByYXRoZXIgY2hlY2sgY2hhckF0XG5cdFx0Ly8gZHJvcCBtYXRjaCA0Pz9cblx0XHRcblx0XHQvLyBzaG91bGQgdGhpcyBub3QgcXVpdCBoZXJlIGluIHByYWN0aWNhbGx5IGFsbCBjYXNlcz9cblx0XHRpZiAoISgobHR5cCA9PSAnLicgfHwgbHR5cCA9PSAnREVGJykgfHwgKG00ID09ICchJyB8fCBtNCA9PSAnPycpIHx8IG1hdGNoWzVdKSkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBhZ2Fpbiwgd2h5P1xuXHRcdGlmIChpZCA9PSAnc2VsZicgfHwgaWQgPT0gJ3RoaXMnIHx8IGlkID09ICdzdXBlcicpIHsgLy8gaW4gWydTRUxGJywnVEhJUyddXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpZCA9PSAnbmV3Jykge1xuXHRcdFx0dHlwID0gJ05FVyc7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaWQgPT0gJy4uLicgJiYgWycsJywnKCcsJ0NBTExfU1RBUlQnLCdCTE9DS19QQVJBTV9TVEFSVCcsJ1BBUkFNX1NUQVJUJ10uaW5kZXhPZihsdHlwKSA+PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpZCA9PSAnfCcpIHtcblx0XHRcdC8vIGhhY2t5IHdheSB0byBpbXBsZW1lbnQgdGhpc1xuXHRcdFx0Ly8gd2l0aCBuZXcgbGV4ZXIgd2UnbGwgdXNlIHsgLi4uIH0gaW5zdGVhZCwgYW5kIGFzc3VtZSBvYmplY3QtY29udGV4dCxcblx0XHRcdC8vIHRoZW4gZ28gYmFjayBhbmQgY29ycmVjdCB3aGVuIHdlIHNlZSB0aGUgY29udGV4dCBpcyBpbnZhbGlkXG5cdFx0XHRpZiAobHR5cCA9PSAnKCcgfHwgbHR5cCA9PSAnQ0FMTF9TVEFSVCcpIHtcblx0XHRcdFx0dGhpcy50b2tlbignRE8nLCdETycsMCk7XG5cdFx0XHRcdHRoaXMucHVzaEVuZCgnfCcpO1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoICd8J1xuXHRcdFx0XHR0aGlzLnRva2VuKCdCTE9DS19QQVJBTV9TVEFSVCcsaWQsMSk7XG5cdFx0XHRcdHJldHVybiBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKGx0eXAgPT0gJ0RPJyB8fCBsdHlwID09ICd7Jykge1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoICd8J1xuXHRcdFx0XHR0aGlzLnB1c2hFbmQoJ3wnKTtcblx0XHRcdFx0dGhpcy50b2tlbignQkxPQ0tfUEFSQU1fU1RBUlQnLGlkLDEpO1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV0gPT0gJ3wnKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0JMT0NLX1BBUkFNX0VORCcsJ3wnLDEpO1xuXHRcdFx0XHR0aGlzLnBhaXIoJ3wnKTtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHdoYWF0P1xuXHRcdC8vIGNvbnNvbGUubG9nKFwibWV0aG9kIGlkZW50aWZpZXJcIixpZClcblx0XHRpZiAoKFsnJicsJ14nLCc8PCcsJzw8PCcsJz4+J10uaW5kZXhPZihpZCkgPj0gMCB8fCAoaWQgPT0gJ3wnICYmIHRoaXMuY29udGV4dCgpICE9ICd8JykpKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChPUF9NRVRIT0RTLmluZGV4T2YoaWQpID49IDApIHtcblx0XHRcdHNwYWNlID0gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG5vdCBldmVuIGFueXRoaW5nIHdlIHNob3VsZCB1c2U/IT9cblx0XHRpZiAocHJlID09ICdAJykge1xuXHRcdFx0dHlwID0gJ0lWQVInO1xuXHRcdH0gZWxzZSBpZiAocHJlID09ICckJykge1xuXHRcdFx0dHJ1ZTtcblx0XHRcdC8vIHR5cCA9ICdHVkFSJ1xuXHRcdH0gZWxzZSBpZiAocHJlID09ICcjJykge1xuXHRcdFx0dHlwID0gJ1RBR0lEJztcblx0XHR9IGVsc2UgaWYgKENPTlNUX0lERU5USUZJRVIudGVzdChwcmUpIHx8IGlkID09ICdyZXF1aXJlJyB8fCBpZCA9PSAnZ2xvYmFsJyB8fCBpZCA9PSAnZXhwb3J0cycpIHtcblx0XHRcdC8vIHJlYWxseT8gc2VlbXMgdmVyeSBzdHJhbmdlXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnZ2xvYmFsISEnLHR5cCxpZClcblx0XHRcdHR5cCA9ICdDT05TVCc7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB3aGF0IGlzIHRoaXMgcmVhbGx5IGZvcj9cblx0XHRpZiAobWF0Y2hbNV0gJiYgWydJREVOVElGSUVSJywnQ09OU1QnLCdHVkFSJywnQ1ZBUicsJ0lWQVInLCdTRUxGJywnVEhJUycsJ10nLCd9JywnKScsJ05VTUJFUicsJ1NUUklORycsJ0lEUkVGJ10uaW5kZXhPZihsdHlwKSA+PSAwKSB7XG5cdFx0XHR0aGlzLnRva2VuKCcuJywnLicsMCk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRva2VuKHR5cCxpZCxsZW5ndGgpO1xuXHRcdFxuXHRcdGlmIChzcGFjZSkge1xuXHRcdFx0dGhpcy5fbGFzdC5zcGFjZWQgPSB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGxlbmd0aDtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuaW5UYWcgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbGVuID0gdGhpcy5fZW5kcy5sZW5ndGg7XG5cdFx0aWYgKGxlbiA+IDApIHtcblx0XHRcdHZhciBjdHgwID0gdGhpcy5fZW5kc1tsZW4gLSAxXTtcblx0XHRcdHZhciBjdHgxID0gbGVuID4gMSA/ICh0aGlzLl9lbmRzW2xlbiAtIDJdKSA6IChjdHgwKTtcblx0XHRcdHJldHVybiBjdHgwID09ICdUQUdfRU5EJyB8fCAoY3R4MSA9PSAnVEFHX0VORCcgJiYgY3R4MCA9PSAnT1VUREVOVCcpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uIChpZCl7XG5cdFx0aWYgKChpZCA9PSAnYXR0cicgfHwgaWQgPT0gJ3Byb3AnKSkge1xuXHRcdFx0dmFyIHNjb3AgPSB0aGlzLmdldFNjb3BlKCk7XG5cdFx0XHR2YXIgaW5jbHMgPSBzY29wID09ICdDTEFTUycgfHwgc2NvcCA9PSAnVEFHJztcblx0XHRcdC8vIHZhciBzY29wZXMgPSBAaW5kZW50cy5tYXAofGluZCxpfCBAc2NvcGVzW2ldIG9yICdOT05FJylcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiaWQgaXMgcHJvcDoge3Njb3Blcy5qb2luKFwiIC0+IFwiKX0gfCB7QGluZGVudHMuam9pbihcIiAtPiBcIil9XCJcblx0XHRcdGlmIChpbmNscykgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIEFMTF9LRVlXT1JEUy5pbmRleE9mKGlkKSA+PSAwO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBpZGVudGlmeWluZyBsaXRlcmFsczogdmFyaWFibGVzLCBrZXl3b3JkcywgbWV0aG9kIG5hbWVzLCBldGMuXG5cdC8vIENoZWNrIHRvIGVuc3VyZSB0aGF0IEphdmFTY3JpcHQgcmVzZXJ2ZWQgd29yZHMgYXJlbid0IGJlaW5nIHVzZWQgYXNcblx0Ly8gaWRlbnRpZmllcnMuIEJlY2F1c2UgSW1iYSByZXNlcnZlcyBhIGhhbmRmdWwgb2Yga2V5d29yZHMgdGhhdCBhcmVcblx0Ly8gYWxsb3dlZCBpbiBKYXZhU2NyaXB0LCB3ZSdyZSBjYXJlZnVsIG5vdCB0byB0b2tpZCB0aGVtIGFzIGtleXdvcmRzIHdoZW5cblx0Ly8gcmVmZXJlbmNlZCBhcyBwcm9wZXJ0eSBuYW1lcyBoZXJlLCBzbyB5b3UgY2FuIHN0aWxsIGRvIGBqUXVlcnkuaXMoKWAgZXZlblxuXHQvLyB0aG91Z2ggYGlzYCBtZWFucyBgPT09YCBvdGhlcndpc2UuXG5cdExleGVyLnByb3RvdHlwZS5pZGVudGlmaWVyVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBtYXRjaDtcblx0XHRcblx0XHR2YXIgY3R4MCA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgY3R4MSA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAyXTtcblx0XHR2YXIgaW5uZXJjdHggPSBjdHgwO1xuXHRcdHZhciB0eXA7XG5cdFx0dmFyIHJlc2VydmVkID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIGFkZExvYyA9IGZhbHNlO1xuXHRcdHZhciBpblRhZyA9IGN0eDAgPT0gJ1RBR19FTkQnIHx8IChjdHgxID09ICdUQUdfRU5EJyAmJiBjdHgwID09ICdPVVRERU5UJyk7XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgY3R4MSxjdHgwXG5cdFx0XG5cdFx0aWYgKGluVGFnICYmIChtYXRjaCA9IFRBR19BVFRSLmV4ZWModGhpcy5fY2h1bmspKSkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ1RBR19BVFRSIElOIHRva2lkJyxtYXRjaFxuXHRcdFx0Ly8gdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHRcdC8vIGlmIHRoZSBwcmV2IGlzIGEgdGVybWluYXRvciwgd2UgZG9udCByZWFsbHkgbmVlZCB0byBjYXJlP1xuXHRcdFx0aWYgKHRoaXMuX2xhc3RUeXAgIT0gJ1RBR19OQU1FJykge1xuXHRcdFx0XHRpZiAodGhpcy5fbGFzdFR5cCA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygncHJldiB3YXMgdGVybWluYXRvciAtLSBkcm9wIGl0PycpXG5cdFx0XHRcdFx0dHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRva2VuKFwiLFwiLFwiLFwiKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBsID0gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnRva2VuKCdUQUdfQVRUUicsbWF0Y2hbMV0sbCAtIDEpOyAvLyBhZGQgdG8gbG9jP1xuXHRcdFx0dGhpcy5fbG9jICs9IGwgLSAxO1xuXHRcdFx0dGhpcy50b2tlbignPScsJz0nLDEpO1xuXHRcdFx0cmV0dXJuIGw7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBzZWUgaWYgdGhpcyBpcyBhIHBsYWluIG9iamVjdC1rZXlcblx0XHQvLyB3YXkgdG9vIG11Y2ggbG9naWMgZ29pbmcgb24gaGVyZT9cblx0XHQvLyB0aGUgYXN0IHNob3VsZCBub3JtYWxpemUgd2hldGhlciBrZXlzXG5cdFx0Ly8gYXJlIGFjY2Vzc2FibGUgYXMga2V5cyBvciBzdHJpbmdzIGV0Y1xuXHRcdGlmIChtYXRjaCA9IE9CSkVDVF9LRVkuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHZhciBpZCA9IG1hdGNoWzFdO1xuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInO1xuXHRcdFx0XG5cdFx0XHQvLyBGSVhNRSBsb2Mgb2Yga2V5IGluY2x1ZGVzIGNvbG9uXG5cdFx0XHQvLyBtb3ZlQ2FyZXQoaWQ6bGVuZ3RoKVxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJva1wiXG5cdFx0XHRpZiAodHJ1ZSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImdvdCBoZXJlPyB7bWF0Y2h9XCJcblx0XHRcdFx0dGhpcy50b2tlbih0eXAsaWQsaWQubGVuZ3RoKTtcblx0XHRcdFx0dGhpcy5tb3ZlQ2FyZXQoaWQubGVuZ3RoKTtcblx0XHRcdFx0dGhpcy50b2tlbignOicsJzonLG1hdGNoWzNdLmxlbmd0aCk7XG5cdFx0XHRcdHRoaXMubW92ZUNhcmV0KC1pZC5sZW5ndGgpO1xuXHRcdFx0XHQvLyBtb3ZlQ2FyZXQobWF0Y2hbM106bGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbW92ZUNhcmV0KG1hdGNoWzJdOmxlbmd0aClcblx0XHRcdC8vIHJldHVybiAwXG5cdFx0XHRjb25zb2xlLmxvZyhtYXRjaFszXS5sZW5ndGgpO1xuXHRcdFx0dGhpcy50b2tlbih0eXAsaWQsbWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdHRoaXMudG9rZW4oJzonLCc6JywxKTtcblx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IElERU5USUZJRVIuZXhlYyh0aGlzLl9jaHVuaykpKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBhcnkgPSBpdGVyJChtYXRjaCk7dmFyIGlucHV0ID0gYXJ5WzBdLGlkID0gYXJ5WzFdLHR5cCA9IGFyeVsyXSxtMyA9IGFyeVszXSxtNCA9IGFyeVs0XSxjb2xvbiA9IGFyeVs1XTtcblx0XHR2YXIgaWRsZW4gPSBpZC5sZW5ndGg7XG5cdFx0XG5cdFx0Ly8gV2hhdCBpcyB0aGUgbG9naWMgaGVyZT9cblx0XHRpZiAoaWQgPT0gJ293bicgJiYgdGhpcy5sYXN0VG9rZW5UeXBlKCkgPT0gJ0ZPUicpIHtcblx0XHRcdHRoaXMudG9rZW4oJ09XTicsaWQsaWQubGVuZ3RoKTtcblx0XHRcdHJldHVybiBpZC5sZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgcHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHR2YXIgbGFzdFR5cCA9IHRoaXMuX2xhc3RUeXA7XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHdlIGZvcmNlIHRoaXMgdG8gYmUgYW4gaWRlbnRpZmllciBldmVuIGlmIGl0IGlzIGEgcmVzZXJ2ZWQgd29yZD9cblx0XHQvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBmb3Igd2hlbiBwYXJ0IG9mIG9iamVjdCBldGNcblx0XHQvLyB3aWxsIHByZXYgZXZlciBiZSBAPz8/XG5cdFx0dmFyIGZvcmNlZElkZW50aWZpZXI7XG5cdFx0XG5cdFx0Ly8gYWdhaW5cblx0XHRmb3JjZWRJZGVudGlmaWVyID0gY29sb24gfHwgbGFzdFR5cCA9PSAnLicgfHwgbGFzdFR5cCA9PSAnPy4nOyAvLyBpbiBbJy4nLCAnPy4nXG5cdFx0XG5cdFx0XG5cdFx0Ly8gdGVtcCBoYWNrISBuZWVkIHRvIHNvbHZlIGZvciBvdGhlciBrZXl3b3JkcyBldGMgYXMgd2VsbFxuXHRcdC8vIHByb2JsZW0gYXBwZWFycyB3aXRoIHRlcm5hcnkgY29uZGl0aW9ucy5cblx0XHRcblx0XHQvLyB3ZWxsIC0tIGl0IHNob3VsZCBzdGlsbCBiZSBhbiBpbmRlbnRpZmllciBpZiBpbiBvYmplY3Q/XG5cdFx0Ly8gZm9yY2VkSWRlbnRpZmllciA9IG5vIGlmIGlkIGluIFsndW5kZWZpbmVkJywnYnJlYWsnXVxuXHRcdFxuXHRcdGlmIChjb2xvbiAmJiBsYXN0VHlwID09ICc/JykgeyBmb3JjZWRJZGVudGlmaWVyID0gZmFsc2UgfTsgLy8gZm9yIHRlcm5hcnlcblx0XHRcblx0XHQvLyBpZiB3ZSBhcmUgbm90IGF0IHRoZSB0b3AgbGV2ZWw/IC0tIGhhY2t5XG5cdFx0aWYgKGlkID09ICd0YWcnICYmIHRoaXMuX2NodW5rLmluZGV4T2YoXCJ0YWcoXCIpID09IDApIHsgLy8gQGNodW5rLm1hdGNoKC9edG9raWRcXCgvKVxuXHRcdFx0Zm9yY2VkSWRlbnRpZmllciA9IHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgaXNLZXl3b3JkID0gZmFsc2U7XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJtYXRjaFwiLG1hdGNoXG5cdFx0Ly8gY29uc29sZS5sb2cgXCJ0eXAgaXMge3R5cH1cIlxuXHRcdC8vIGxpdHRsZSByZWFzb24gdG8gY2hlY2sgZm9yIHRoaXMgcmlnaHQgaGVyZT8gYnV0IEkgZ3Vlc3MgaXQgaXMgb25seSBhIHNpbXBsZSBjaGVja1xuXHRcdGlmICh0eXAgPT0gJyQnICYmIEFSR1ZBUi50ZXN0KGlkKSkgeyAvLyBpZC5tYXRjaCgvXlxcJFxcZCQvKVxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJUWVAgJFwiXG5cdFx0XHRpZiAoaWQgPT0gJyQwJykge1xuXHRcdFx0XHR0eXAgPSAnQVJHVU1FTlRTJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cCA9ICdBUkdWQVInO1xuXHRcdFx0XHRpZCA9IGlkLnN1YnN0cigxKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0AnKSB7XG5cdFx0XHR0eXAgPSAnSVZBUic7XG5cdFx0XHRcblx0XHRcdC8vIGlkOnJlc2VydmVkID0geWVzIGlmIGNvbG9uXG5cdFx0fSBlbHNlIGlmICh0eXAgPT0gJyMnKSB7XG5cdFx0XHQvLyB3ZSBhcmUgdHJ5aW5nIHRvIG1vdmUgdG8gZ2VuZXJpYyB0b2tlbnMsXG5cdFx0XHQvLyBzbyB3ZSBhcmUgc3RhcnRpbmcgdG8gc3BsaXR0aW5nIHVwIHRoZSBzeW1ib2xzIGFuZCB0aGUgaXRlbXNcblx0XHRcdC8vIHdlJ2xsIHNlZSBpZiB0aGF0IHdvcmtzXG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0XHR0aGlzLnRva2VuKCcjJywnIycpO1xuXHRcdFx0aWQgPSBpZC5zdWJzdHIoMSk7XG5cdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0BAJykge1xuXHRcdFx0dHlwID0gJ0NWQVInO1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICckJyAmJiAhY29sb24pIHtcblx0XHRcdHR5cCA9ICdJREVOVElGSUVSJztcblx0XHRcdC8vIHR5cCA9ICdHVkFSJ1xuXHRcdH0gZWxzZSBpZiAoQ09OU1RfSURFTlRJRklFUi50ZXN0KGlkKSB8fCBpZCA9PSAncmVxdWlyZScgfHwgaWQgPT0gJ2dsb2JhbCcgfHwgaWQgPT0gJ2V4cG9ydHMnKSB7XG5cdFx0XHQvLyB0aG91cyBzaG91bGQgcmVhbGx5IGJlIGhhbmRsZWQgYnkgdGhlIGFzdCBpbnN0ZWFkXG5cdFx0XHR0eXAgPSAnQ09OU1QnO1xuXHRcdH0gZWxzZSBpZiAoaWQgPT0gJ2VsaWYnKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdFTFNFJywnZWxpZicsaWQubGVuZ3RoKTtcblx0XHRcdHRoaXMudG9rZW4oJ0lGJywnaWYnKTtcblx0XHRcdHJldHVybiBpZC5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHR5cCA9ICdJREVOVElGSUVSJztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdC8vIHRoaXMgY2F0Y2hlcyBhbGwgXG5cdFx0aWYgKCFmb3JjZWRJZGVudGlmaWVyICYmIChpc0tleXdvcmQgPSB0aGlzLmlzS2V5d29yZChpZCkpKSB7XG5cdFx0XHQvLyAoaWQgaW4gSlNfS0VZV09SRFMgb3IgaWQgaW4gSU1CQV9LRVlXT1JEUylcblx0XHRcdHR5cCA9IGlkLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRhZGRMb2MgPSB0cnVlO1xuXHRcdFx0XG5cdFx0XHQvLyBjbHVtc3kgLSBidXQgdGVzdGluZyBwZXJmb3JtYW5jZVxuXHRcdFx0aWYgKHR5cCA9PSAnWUVTJykge1xuXHRcdFx0XHR0eXAgPSAnVFJVRSc7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnTk8nKSB7XG5cdFx0XHRcdHR5cCA9ICdGQUxTRSc7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnTklMJykge1xuXHRcdFx0XHR0eXAgPSAnTlVMTCc7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnVkFSJykge1xuXHRcdFx0XHRpZiAodGhpcy5fbGFzdFZhbCA9PSAnZXhwb3J0Jykge1xuXHRcdFx0XHRcdHRUcyhwcmV2LCdFWFBPUlQnKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdJRicgfHwgdHlwID09ICdFTFNFJyB8fCB0eXAgPT0gJ1RSVUUnIHx8IHR5cCA9PSAnRkFMU0UnIHx8IHR5cCA9PSAnTlVMTCcpIHtcblx0XHRcdFx0dHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdUQUcnKSB7XG5cdFx0XHRcdHRoaXMucHVzaEVuZCgnVEFHJyk7XG5cdFx0XHRcdC8vIEBlbmRzLnB1c2goJ1RBRycpXG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnREVGJykge1xuXHRcdFx0XHQvLyBzaG91bGQgcHJvYmFibHkgc2hpZnQgY29udGV4dCBhbmQgb3B0aW1pemUgdGhpc1xuXHRcdFx0XHR0aGlzLm9wZW5EZWYoKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdETycpIHtcblx0XHRcdFx0aWYgKHRoaXMuY29udGV4dCgpID09ICdERUYnKSB0aGlzLmNsb3NlRGVmKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnV0hFTicgJiYgTElORV9CUkVBSy5pbmRleE9mKHRoaXMubGFzdFRva2VuVHlwZSgpKSA+PSAwKSB7XG5cdFx0XHRcdHR5cCA9ICdMRUFESU5HX1dIRU4nO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0ZPUicpIHtcblx0XHRcdFx0dGhpcy5fc2VlbkZvciA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnVU5MRVNTJykge1xuXHRcdFx0XHR0eXAgPSAnSUYnOyAvLyBXQVJOXG5cdFx0XHR9IGVsc2UgaWYgKFVOQVJZLmluZGV4T2YodHlwKSA+PSAwKSB7XG5cdFx0XHRcdHR5cCA9ICdVTkFSWSc7XG5cdFx0XHR9IGVsc2UgaWYgKFJFTEFUSU9OLmluZGV4T2YodHlwKSA+PSAwKSB7XG5cdFx0XHRcdGlmICh0eXAgIT0gJ0lOU1RBTkNFT0YnICYmIHR5cCAhPSAnSVNBJyAmJiB0aGlzLl9zZWVuRm9yKSB7XG5cdFx0XHRcdFx0dHlwID0gJ0ZPUicgKyB0eXA7IC8vID9cblx0XHRcdFx0XHR0aGlzLl9zZWVuRm9yID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHlwID0gJ1JFTEFUSU9OJztcblx0XHRcdFx0XHRpZiAoU3RyaW5nKHRoaXMudmFsdWUoKSkgPT0gJyEnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90b2tlbnMucG9wKCk7IC8vIGlzIGZ1Y2tlZCB1cD8/IVxuXHRcdFx0XHRcdFx0Ly8gV0FSTiB3ZSBuZWVkIHRvIGtlZXAgdGhlIGxvYywgbm8/XG5cdFx0XHRcdFx0XHRpZCA9ICchJyArIGlkO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGlkID09ICdzdXBlcicpIHtcblx0XHRcdHR5cCA9ICdTVVBFUic7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBkbyB3ZSByZWFsbHkgd2FudCB0byBjaGVjayB0aGlzIGhlcmVcblx0XHRpZiAoIWZvcmNlZElkZW50aWZpZXIpIHtcblx0XHRcdC8vIHNob3VsZCBhbHJlYWR5IGhhdmUgZGVhbHQgd2l0aCB0aGlzXG5cdFx0XHRcblx0XHRcdGlmIChpc0tleXdvcmQgJiYgSU1CQV9BTElBU0VTLmluZGV4T2YoaWQpID49IDApIHsgaWQgPSBJTUJBX0FMSUFTX01BUFtpZF0gfTtcblx0XHRcdC8vIHRoZXNlIHJlYWxseSBzaG91bGQgbm90IGdvIGhlcmU/IT9cblx0XHRcdHN3aXRjaCAoaWQpIHtcblx0XHRcdFx0Y2FzZSAnISc6XG5cdFx0XHRcdFx0dHlwID0gJ1VOQVJZJzticmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgJz09Jzpcblx0XHRcdFx0Y2FzZSAnIT0nOlxuXHRcdFx0XHRjYXNlICc9PT0nOlxuXHRcdFx0XHRjYXNlICchPT0nOlxuXHRcdFx0XHRcdHR5cCA9ICdDT01QQVJFJzticmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgJyYmJzpcblx0XHRcdFx0Y2FzZSAnfHwnOlxuXHRcdFx0XHRcdHR5cCA9ICdMT0dJQyc7YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICdicmVhayc6XG5cdFx0XHRcdGNhc2UgJ2NvbnRpbnVlJzpcblx0XHRcdFx0Y2FzZSAnZGVidWdnZXInOlxuXHRcdFx0XHRjYXNlICdhcmd1bWVudHMnOlxuXHRcdFx0XHRcdHR5cCA9IGlkLnRvVXBwZXJDYXNlKCk7YnJlYWs7XG5cdFx0XHRcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcblx0XHRcblx0XHQvLyBzaG91bGQgYmUgc3RyaWN0IGFib3V0IHRoZSBvcmRlciwgY2hlY2sgdGhpcyBtYW51YWxseSBpbnN0ZWFkXG5cdFx0aWYgKHR5cCA9PSAnQ0xBU1MnIHx8IHR5cCA9PSAnREVGJyB8fCB0eXAgPT0gJ1RBRycpIHtcblx0XHRcdHRoaXMucXVldWVTY29wZSh0eXApO1xuXHRcdFx0XG5cdFx0XHR2YXIgaSA9IHRoaXMuX3Rva2Vucy5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChpKXtcblx0XHRcdFx0cHJldiA9IHRoaXMuX3Rva2Vuc1stLWldO1xuXHRcdFx0XHR2YXIgY3RybCA9IFwiXCIgKyB0VihwcmV2KTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJjdHJsIGlzIHtjdHJsfVwiKVxuXHRcdFx0XHQvLyBuZWVkIHRvIGNvZXJjZSB0byBzdHJpbmcgYmVjYXVzZSBvZiBzdHVwaWQgQ1MgPT09XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwicHJldiBpc1wiLHByZXZbMF0scHJldlsxXSlcblx0XHRcdFx0aWYgKGlkeCQoY3RybCxJTUJBX0NPTlRFWFRVQUxfS0VZV09SRFMpID49IDApIHtcblx0XHRcdFx0XHR0VHMocHJldixjdHJsLnRvVXBwZXJDYXNlKCkpO1xuXHRcdFx0XHRcdC8vIHByZXZbMF0gPSBjdHJsLnRvVXBwZXJDYXNlICMgRklYXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdJRicpIHtcblx0XHRcdHRoaXMucXVldWVTY29wZSh0eXApO1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdJTVBPUlQnKSB7XG5cdFx0XHQvLyBjb3VsZCBtYW51YWxseSBwYXJzZSB0aGUgd2hvbGUgdGluZyBoZXJlP1xuXHRcdFx0dGhpcy5wdXNoRW5kKCdJTVBPUlQnKTtcblx0XHRcdC8vIEBlbmRzLnB1c2ggJ0lNUE9SVCdcblx0XHR9IGVsc2UgaWYgKGlkID09ICdmcm9tJyAmJiBjdHgwID09ICdJTVBPUlQnKSB7XG5cdFx0XHR0eXAgPSAnRlJPTSc7XG5cdFx0XHR0aGlzLnBhaXIoJ0lNUE9SVCcpO1xuXHRcdH0gZWxzZSBpZiAoaWQgPT0gJ2FzJyAmJiBjdHgwID09ICdJTVBPUlQnKSB7XG5cdFx0XHR0eXAgPSAnQVMnO1xuXHRcdFx0dGhpcy5wYWlyKCdJTVBPUlQnKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0eXAgPT0gJ0lERU5USUZJRVInKSB7XG5cdFx0XHQvLyBzZWUgaWYgcHJldmlvdXMgd2FzIGNhdGNoIC0tIGJlbG9uZ3MgaW4gcmV3cml0ZXI/XG5cdFx0XHRpZiAobGFzdFR5cCA9PSAnQ0FUQ0gnKSB7XG5cdFx0XHRcdHR5cCA9ICdDQVRDSF9WQVInO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChjb2xvbikge1xuXHRcdFx0dGhpcy50b2tlbih0eXAsaWQsaWRsZW4pO1xuXHRcdFx0dGhpcy5tb3ZlQ2FyZXQoaWRsZW4pO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGQgY29sb24/XCJcblx0XHRcdHRoaXMudG9rZW4oJzonLCc6Jyxjb2xvbi5sZW5ndGgpO1xuXHRcdFx0dGhpcy5tb3ZlQ2FyZXQoLWlkbGVuKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50b2tlbih0eXAsaWQsaWRsZW4pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGxlbjtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgbnVtYmVycywgaW5jbHVkaW5nIGRlY2ltYWxzLCBoZXgsIGFuZCBleHBvbmVudGlhbCBub3RhdGlvbi5cblx0Ly8gQmUgY2FyZWZ1bCBub3QgdG8gaW50ZXJmZXJlIHdpdGggcmFuZ2VzLWluLXByb2dyZXNzLlxuXHRMZXhlci5wcm90b3R5cGUubnVtYmVyVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYmluYXJ5TGl0ZXJhbDtcblx0XHR2YXIgbWF0Y2gsbnVtYmVyLGxleGVkTGVuZ3RoO1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gTlVNQkVSLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdG51bWJlciA9IG1hdGNoWzBdO1xuXHRcdGxleGVkTGVuZ3RoID0gbnVtYmVyLmxlbmd0aDtcblx0XHRcblx0XHRpZiAoYmluYXJ5TGl0ZXJhbCA9IC8wYihbMDFdKykvLmV4ZWMobnVtYmVyKSkge1xuXHRcdFx0XG5cdFx0XHRudW1iZXIgPSBcIlwiICsgcGFyc2VJbnQoYmluYXJ5TGl0ZXJhbFsxXSwyKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdFxuXHRcdGlmIChtYXRjaFswXVswXSA9PSAnLicgJiYgcHJldiAmJiAhcHJldi5zcGFjZWQgJiYgWydJREVOVElGSUVSJywnKScsJ30nLCddJywnTlVNQkVSJ10uaW5kZXhPZih0VChwcmV2KSkgPj0gMCkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJnb3QgaGVyZVwiXG5cdFx0XHR0aGlzLnRva2VuKFwiLlwiLFwiLlwiKTtcblx0XHRcdG51bWJlciA9IG51bWJlci5zdWJzdHIoMSk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0aGlzLnRva2VuKCdOVU1CRVInLG51bWJlcixsZXhlZExlbmd0aCk7XG5cdFx0cmV0dXJuIGxleGVkTGVuZ3RoO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnN5bWJvbFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLHN5bWJvbCxwcmV2O1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gU1lNQk9MLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdHN5bWJvbCA9IG1hdGNoWzBdLnN1YnN0cigxKTtcblx0XHRwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdFxuXHRcdC8vIGlzIHRoaXMgYSBwcm9wZXJ0eS1hY2Nlc3M/XG5cdFx0Ly8gc2hvdWxkIGludmVydCB0aGlzIC0tIG9ubHkgYWxsb3cgd2hlbiBwcmV2IElTIC4uIFxuXHRcdFxuXHRcdC8vIDogc2hvdWxkIGJlIGEgdG9rZW4gaXRzZWxmLCB3aXRoIGEgc3BlY2lmaWNhdGlvbiBvZiBzcGFjaW5nIChMUixSLEwsTk9ORSlcblx0XHRcblx0XHQvLyBGSVhcblx0XHRpZiAocHJldiAmJiAhcHJldi5zcGFjZWQgJiYgaWR4JCh0VChwcmV2KSxbJygnLCd7JywnWycsJy4nLCdDQUxMX1NUQVJUJywnSU5ERVhfU1RBUlQnLCcsJywnPScsJ0lOREVOVCcsJ1RFUk1JTkFUT1InXSkgPT0gLTEpIHtcblx0XHRcdHRoaXMudG9rZW4oJy46JywnOicsMSk7XG5cdFx0XHR2YXIgc3ltID0gc3ltYm9sLnNwbGl0KC9bXFw6XFxcXFxcL10vKVswXTsgLy8gcmVhbGx5P1xuXHRcdFx0Ly8gdG9rZW4gJ1NZTUJPTCcsIFwiJyN7c3ltYm9sfSdcIlxuXHRcdFx0dGhpcy50b2tlbignSURFTlRJRklFUicsc3ltLHN5bS5sZW5ndGgsMSk7XG5cdFx0XHRyZXR1cm4gKHN5bS5sZW5ndGggKyAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdG9rZW4gJ1NZTUJPTCcsIFwiJyN7c3ltYm9sfSdcIlxuXHRcdFx0dGhpcy50b2tlbignU1lNQk9MJyxzeW1ib2wsbWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0fTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5lc2NhcGVTdHIgPSBmdW5jdGlvbiAoc3RyLGhlcmVkb2MscSl7XG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwoaGVyZWRvYyA/ICgnXFxcXG4nKSA6ICgnJykpKTtcblx0XHRpZiAocSkge1xuXHRcdFx0dmFyIHIgPSBSZWdFeHAoKFwiXFxcXFxcXFxbXCIgKyBxICsgXCJdXCIpLFwiZ1wiKTtcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKHIscSk7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZShSZWdFeHAoKFwiXCIgKyBxKSxcImdcIiksJ1xcXFwkJicpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHN0cjtcblx0XHRcblx0XHQvLyBzdHIgPSBzdHIucmVwbGFjZShNVUxUSUxJTkVSLCAnXFxcXG4nKVxuXHRcdC8vIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jylcblx0fTtcblx0Ly8gTWF0Y2hlcyBzdHJpbmdzLCBpbmNsdWRpbmcgbXVsdGktbGluZSBzdHJpbmdzLiBFbnN1cmVzIHRoYXQgcXVvdGF0aW9uIG1hcmtzXG5cdC8vIGFyZSBiYWxhbmNlZCB3aXRoaW4gdGhlIHN0cmluZydzIGNvbnRlbnRzLCBhbmQgd2l0aGluIG5lc3RlZCBpbnRlcnBvbGF0aW9ucy5cblx0TGV4ZXIucHJvdG90eXBlLnN0cmluZ1Rva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLHN0cmluZztcblx0XHRcblx0XHRzd2l0Y2ggKHRoaXMuX2NodW5rLmNoYXJBdCgwKSkge1xuXHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0aWYgKCEobWF0Y2ggPSBTSU1QTEVTVFIuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0XHRcdHN0cmluZyA9IG1hdGNoWzBdO1xuXHRcdFx0XHR0aGlzLnRva2VuKCdTVFJJTkcnLHRoaXMuZXNjYXBlU3RyKHN0cmluZyksc3RyaW5nLmxlbmd0aCk7XG5cdFx0XHRcdC8vIHRva2VuICdTVFJJTkcnLCAoc3RyaW5nID0gbWF0Y2hbMF0pLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxcXG4nKSwgc3RyaW5nOmxlbmd0aFxuXHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0Y2FzZSAnXCInOlxuXHRcdFx0XHRpZiAoIShzdHJpbmcgPSB0aGlzLmJhbGFuY2VkU3RyaW5nKHRoaXMuX2NodW5rLCdcIicpKSkgeyByZXR1cm4gMCB9O1xuXHRcdFx0XHQvLyB3aGF0IGFib3V0IHRyaXBlIHF1b3RlZCBzdHJpbmdzP1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHN0cmluZy5pbmRleE9mKCd7JykgPj0gMCkge1xuXHRcdFx0XHRcdHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIGlmIHRoaXMgaGFzIG5vIGludGVycG9sYXRpb24/XG5cdFx0XHRcdFx0Ly8gd2UgYXJlIG5vdyBtZXNzaW5nIHdpdGggbG9jYXRpb25zIC0gYmV3YXJlXG5cdFx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HX1NUQVJUJyxzdHJpbmcuY2hhckF0KDApLDEpO1xuXHRcdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGVTdHJpbmcoc3RyaW5nLnNsaWNlKDEsLTEpKTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTVFJJTkdfRU5EJyxzdHJpbmcuY2hhckF0KGxlbiAtIDEpLDEsc3RyaW5nLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxlbiA9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdFx0Ly8gc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxcXG4nKVxuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NUUklORycsdGhpcy5lc2NhcGVTdHIoc3RyaW5nKSxsZW4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMubW92ZUhlYWQoc3RyaW5nKTtcblx0XHRyZXR1cm4gc3RyaW5nLmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgaGVyZWRvY3MsIGFkanVzdGluZyBpbmRlbnRhdGlvbiB0byB0aGUgY29ycmVjdCBsZXZlbCwgYXMgaGVyZWRvY3Ncblx0Ly8gcHJlc2VydmUgd2hpdGVzcGFjZSwgYnV0IGlnbm9yZSBpbmRlbnRhdGlvbiB0byB0aGUgbGVmdC5cblx0TGV4ZXIucHJvdG90eXBlLmhlcmVkb2NUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxoZXJlZG9jLHF1b3RlLGRvYztcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IEhFUkVET0MuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0aGVyZWRvYyA9IG1hdGNoWzBdO1xuXHRcdHF1b3RlID0gaGVyZWRvYy5jaGFyQXQoMCk7XG5cdFx0ZG9jID0gdGhpcy5zYW5pdGl6ZUhlcmVkb2MobWF0Y2hbMl0se3F1b3RlOiBxdW90ZSxpbmRlbnQ6IG51bGx9KTtcblx0XHQvLyBjb25zb2xlLmxvZyBcImZvdW5kIGhlcmVkb2Mge21hdGNoWzBdOmxlbmd0aH0ge2RvYzpsZW5ndGh9XCJcblx0XHRcblx0XHRpZiAocXVvdGUgPT0gJ1wiJyAmJiBkb2MuaW5kZXhPZigneycpID49IDApIHtcblx0XHRcdHZhciBvcGVuID0gbWF0Y2hbMV07XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBkb2Muc3Vic3RyKDAsMyksbWF0Y2hbMV1cblx0XHRcdHRoaXMudG9rZW4oJ1NUUklOR19TVEFSVCcsb3BlbixvcGVuLmxlbmd0aCk7XG5cdFx0XHR0aGlzLmludGVycG9sYXRlU3RyaW5nKGRvYyx7aGVyZWRvYzogdHJ1ZSxvZmZzZXQ6IG9wZW4ubGVuZ3RoLHF1b3RlOiBxdW90ZX0pO1xuXHRcdFx0dGhpcy50b2tlbignU1RSSU5HX0VORCcsb3BlbixvcGVuLmxlbmd0aCxoZXJlZG9jLmxlbmd0aCAtIG9wZW4ubGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50b2tlbignU1RSSU5HJyx0aGlzLm1ha2VTdHJpbmcoZG9jLHF1b3RlLHRydWUpLDApO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5tb3ZlSGVhZChoZXJlZG9jKTtcblx0XHRyZXR1cm4gaGVyZWRvYy5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGFuZCBjb25zdW1lcyBjb21tZW50cy5cblx0TGV4ZXIucHJvdG90eXBlLmNvbW1lbnRUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxsZW5ndGgsY29tbWVudCxpbmRlbnQscHJldjtcblx0XHRcblx0XHR2YXIgdHlwID0gJ0hFUkVDT01NRU5UJztcblx0XHRcblx0XHRpZiAobWF0Y2ggPSBJTkxJTkVfQ09NTUVOVC5leGVjKHRoaXMuX2NodW5rKSkgeyAvLyAubWF0Y2goSU5MSU5FX0NPTU1FTlQpXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcIm1hdGNoIGlubGluZSBjb21tZW50XCJcblx0XHRcdGxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdGluZGVudCA9IG1hdGNoWzFdO1xuXHRcdFx0Y29tbWVudCA9IG1hdGNoWzJdO1xuXHRcdFx0XG5cdFx0XHRwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdFx0dmFyIHB0ID0gcHJldiAmJiB0VChwcmV2KTtcblx0XHRcdHZhciBub3RlID0gJy8vJyArIGNvbW1lbnQuc3Vic3RyKDEpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5fbGFzdCAmJiB0aGlzLl9sYXN0LnNwYWNlZCkge1xuXHRcdFx0XHRub3RlID0gJyAnICsgbm90ZTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJ0aGUgcHJldmlvdXMgbm9kZSB3YXMgU1BBQ0VEXCJcblx0XHRcdH07XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImNvbW1lbnQge25vdGV9IC0gaW5kZW50KHtpbmRlbnR9KSAtIHtsZW5ndGh9IHtjb21tZW50Omxlbmd0aH1cIlxuXHRcdFx0XG5cdFx0XHRpZiAoKHB0ICYmIHB0ICE9ICdJTkRFTlQnICYmIHB0ICE9ICdURVJNSU5BVE9SJykgfHwgIXB0KSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwic2tpcCBjb21tZW50XCJcblx0XHRcdFx0Ly8gdG9rZW4gJ0lOTElORUNPTU1FTlQnLCBjb21tZW50LnN1YnN0cigyKVxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImFkZGluZyBhcyB0ZXJtaW5hdG9yXCJcblx0XHRcdFx0dGhpcy50b2tlbignVEVSTUlOQVRPUicsbm90ZSxsZW5ndGgpOyAvLyArICdcXG4nXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImFkZCBjb21tZW50ICh7bm90ZX0pXCJcblx0XHRcdFx0aWYgKHB0ID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHRcdHRWcyhwcmV2LHRWKHByZXYpICsgbm90ZSk7XG5cdFx0XHRcdFx0Ly8gcHJldlsxXSArPSBub3RlXG5cdFx0XHRcdH0gZWxzZSBpZiAocHQgPT0gJ0lOREVOVCcpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImFkZGluZyBjb21tZW50IHRvIElOREVOVDoge25vdGV9XCIgIyB3aHkgbm90IGFkZCBkaXJlY3RseSBoZXJlP1xuXHRcdFx0XHRcdHRoaXMuYWRkTGluZWJyZWFrcygxLG5vdGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiY29tbWVudCBoZXJlXCJcblx0XHRcdFx0XHQvLyBzaG91bGQgd2UgZXZlciBnZXQgaGVyZT9cblx0XHRcdFx0XHR0aGlzLnRva2VuKHR5cCxjb21tZW50LnN1YnN0cigyKSxsZW5ndGgpOyAvLyBhcmUgd2Ugc3VyZT9cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBsZW5ndGg7IC8vIGRpc2FibGUgbm93IHdoaWxlIGNvbXBpbGluZ1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHVzZSBleGVjP1xuXHRcdGlmICghKG1hdGNoID0gQ09NTUVOVC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHRjb21tZW50ID0gbWF0Y2hbMF07XG5cdFx0dmFyIGhlcmUgPSBtYXRjaFsxXTtcblx0XHRcblx0XHRpZiAoaGVyZSkge1xuXHRcdFx0dGhpcy50b2tlbignSEVSRUNPTU1FTlQnLHRoaXMuc2FuaXRpemVIZXJlZG9jKGhlcmUse2hlcmVjb21tZW50OiB0cnVlLGluZGVudDogQXJyYXkodGhpcy5faW5kZW50ICsgMSkuam9pbignICcpfSksY29tbWVudC5sZW5ndGgpO1xuXHRcdFx0dGhpcy50b2tlbignVEVSTUlOQVRPUicsJ1xcbicpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRva2VuKCdIRVJFQ09NTUVOVCcsY29tbWVudCxjb21tZW50Lmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKCdURVJNSU5BVE9SJywnXFxuJyk7IC8vIGF1dG8/IHJlYWxseT9cblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMubW92ZUhlYWQoY29tbWVudCk7XG5cdFx0cmV0dXJuIGNvbW1lbnQubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBKYXZhU2NyaXB0IGludGVycG9sYXRlZCBkaXJlY3RseSBpbnRvIHRoZSBzb3VyY2UgdmlhIGJhY2t0aWNrcy5cblx0TGV4ZXIucHJvdG90eXBlLmpzVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsc2NyaXB0O1xuXHRcdFxuXHRcdGlmICghKHRoaXMuX2NodW5rLmNoYXJBdCgwKSA9PSAnYCcgJiYgKG1hdGNoID0gSlNUT0tFTi5leGVjKHRoaXMuX2NodW5rKSkpKSB7IHJldHVybiAwIH07XG5cdFx0dGhpcy50b2tlbignSlMnLChzY3JpcHQgPSBtYXRjaFswXSkuc2xpY2UoMSwtMSkpO1xuXHRcdHJldHVybiBzY3JpcHQubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMuIExleGluZyByZWd1bGFyIGV4cHJlc3Npb25zIGlzIGRpZmZpY3VsdFxuXHQvLyB0byBkaXN0aW5ndWlzaCBmcm9tIGRpdmlzaW9uLCBzbyB3ZSBib3Jyb3cgc29tZSBiYXNpYyBoZXVyaXN0aWNzIGZyb21cblx0Ly8gSmF2YVNjcmlwdCBhbmQgUnVieS5cblx0TGV4ZXIucHJvdG90eXBlLnJlZ2V4VG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBtYXRjaCxsZW5ndGgscHJldjtcblx0XHRcblx0XHRpZiAodGhpcy5fY2h1bmsuY2hhckF0KDApICE9ICcvJykgeyByZXR1cm4gMCB9O1xuXHRcdGlmIChtYXRjaCA9IEhFUkVHRVguZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdGxlbmd0aCA9IHRoaXMuaGVyZWdleFRva2VuKG1hdGNoKTtcblx0XHRcdHRoaXMubW92ZUhlYWQobWF0Y2hbMF0pO1xuXHRcdFx0cmV0dXJuIGxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0Ly8gRklYXG5cdFx0aWYgKHByZXYgJiYgKGlkeCQodFQocHJldiksKHByZXYuc3BhY2VkID8gKFxuXHRcdFx0Tk9UX1JFR0VYXG5cdFx0KSA6IChcblx0XHRcdE5PVF9TUEFDRURfUkVHRVhcblx0XHQpKSkgPj0gMCkpIHsgcmV0dXJuIDAgfTtcblx0XHRpZiAoIShtYXRjaCA9IFJFR0VYLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdHZhciBhcnkgPSBpdGVyJChtYXRjaCk7dmFyIG0gPSBhcnlbMF0scmVnZXggPSBhcnlbMV0sZmxhZ3MgPSBhcnlbMl07XG5cdFx0XG5cdFx0Ly8gRklYTUVcblx0XHQvLyBpZiByZWdleFsuLjFdIGlzICcvKidcblx0XHQvL1x0ZXJyb3IgJ3JlZ3VsYXIgZXhwcmVzc2lvbnMgY2Fubm90IGJlZ2luIHdpdGggYCpgJ1xuXHRcdFxuXHRcdGlmIChyZWdleCA9PSAnLy8nKSB7XG5cdFx0XHRyZWdleCA9ICcvKD86KS8nO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy50b2tlbignUkVHRVgnLChcIlwiICsgcmVnZXggKyBmbGFncyksbS5sZW5ndGgpO1xuXHRcdHJldHVybiBtLmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgbXVsdGlsaW5lIGV4dGVuZGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG5cdC8vIFRoZSBlc2NhcGluZyBzaG91bGQgcmF0aGVyIGhhcHBlbiBpbiBBU1QgLSBwb3NzaWJseSBhcyBhbiBhZGRpdGlvbmFsIGZsYWc/XG5cdExleGVyLnByb3RvdHlwZS5oZXJlZ2V4VG9rZW4gPSBmdW5jdGlvbiAobWF0Y2gpe1xuXHRcdHZhciBhcnk7XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKG1hdGNoKTt2YXIgaGVyZWdleCA9IGFyeVswXSxib2R5ID0gYXJ5WzFdLGZsYWdzID0gYXJ5WzJdO1xuXHRcdFxuXHRcdGlmICgwID4gYm9keS5pbmRleE9mKCcjeycpKSB7XG5cdFx0XHRcblx0XHRcdHZhciByZSA9IGJvZHkucmVwbGFjZShIRVJFR0VYX09NSVQsJycpLnJlcGxhY2UoL1xcLy9nLCdcXFxcLycpO1xuXHRcdFx0XG5cdFx0XHRpZiAocmUubWF0Y2goL15cXCovKSkge1xuXHRcdFx0XHR0aGlzLmVycm9yKCdyZWd1bGFyIGV4cHJlc3Npb25zIGNhbm5vdCBiZWdpbiB3aXRoIGAqYCcpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy50b2tlbignUkVHRVgnLChcIi9cIiArIChyZSB8fCAnKD86KScpICsgXCIvXCIgKyBmbGFncyksaGVyZWdleC5sZW5ndGgpO1xuXHRcdFx0cmV0dXJuIGhlcmVnZXgubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdXNlIG1vcmUgYmFzaWMgcmVnZXggdHlwZVxuXHRcdFxuXHRcdHRoaXMudG9rZW4oJ0NPTlNUJywnUmVnRXhwJyk7XG5cdFx0dGhpcy5fdG9rZW5zLnB1c2goVC50b2tlbignQ0FMTF9TVEFSVCcsJygnLDApKTtcblx0XHR2YXIgdG9rZW5zID0gW107XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGl0ZW1zID0gaXRlciQodGhpcy5pbnRlcnBvbGF0ZVN0cmluZyhib2R5LHtyZWdleDogdHJ1ZX0pKSwgbGVuID0gaXRlbXMubGVuZ3RoLCBwYWlyOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFxuXHRcdFx0cGFpciA9IGl0ZW1zW2ldO1xuXHRcdFx0dmFyIHRvayA9IHRUKHBhaXIpOyAvLyBGSVhcblx0XHRcdHZhciB2YWx1ZSA9IHRWKHBhaXIpOyAvLyBGSVhcblx0XHRcdFxuXHRcdFx0aWYgKHRvayA9PSAnVE9LRU5TJykge1xuXHRcdFx0XHQvLyBGSVhNRSB3aGF0IGlzIHRoaXM/XG5cdFx0XHRcdHRva2Vucy5wdXNoLmFwcGx5KHRva2Vucyx2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJ3aGF0Pz9cIik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoISh2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoSEVSRUdFWF9PTUlULCcnKSkpIHsgY29udGludWU7IH07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywnXFxcXFxcXFwnKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goVC50b2tlbignU1RSSU5HJyx0aGlzLm1ha2VTdHJpbmcodmFsdWUsJ1wiJyx0cnVlKSwwKSk7IC8vIEZJWFxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dG9rZW5zLnB1c2goVC50b2tlbignKycsJysnLDApKTsgLy8gRklYXG5cdFx0fTtcblx0XHRcblx0XHR0b2tlbnMucG9wKCk7XG5cdFx0XG5cdFx0Ly8gRklYXG5cdFx0aWYgKCEodG9rZW5zWzBdICYmIHRUKHRva2Vuc1swXSkgPT0gJ1NUUklORycpKSB7XG5cdFx0XHQvLyBGSVhcblx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKFQudG9rZW4oJ1NUUklORycsJ1wiXCInKSxULnRva2VuKCcrJywnKycpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX3Rva2Vucy5wdXNoLmFwcGx5KHRoaXMuX3Rva2Vucyx0b2tlbnMpOyAvLyB3aGF0IGlzIHRoaXM/XG5cdFx0Ly8gRklYXG5cdFx0XG5cdFx0aWYgKGZsYWdzKSB7XG5cdFx0XHR0aGlzLl90b2tlbnMucHVzaChULnRva2VuKCcsJywnLCcsMCkpO1xuXHRcdFx0dGhpcy5fdG9rZW5zLnB1c2goVC50b2tlbignU1RSSU5HJywnXCInICsgZmxhZ3MgKyAnXCInLDApKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMudG9rZW4oJyknLCcpJywwKTtcblx0XHRcblx0XHRyZXR1cm4gaGVyZWdleC5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIG5ld2xpbmVzLCBpbmRlbnRzLCBhbmQgb3V0ZGVudHMsIGFuZCBkZXRlcm1pbmVzIHdoaWNoIGlzIHdoaWNoLlxuXHQvLyBJZiB3ZSBjYW4gZGV0ZWN0IHRoYXQgdGhlIGN1cnJlbnQgbGluZSBpcyBjb250aW51ZWQgb250byB0aGUgdGhlIG5leHQgbGluZSxcblx0Ly8gdGhlbiB0aGUgbmV3bGluZSBpcyBzdXBwcmVzc2VkOlxuXHQvL1xuXHQvLyAgICAgZWxlbWVudHNcblx0Ly8gICAgICAgLmVhY2goIC4uLiApXG5cdC8vICAgICAgIC5tYXAoIC4uLiApXG5cdC8vXG5cdC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBsZXZlbCBvZiBpbmRlbnRhdGlvbiwgYmVjYXVzZSBhIHNpbmdsZSBvdXRkZW50IHRva2VuXG5cdC8vIGNhbiBjbG9zZSBtdWx0aXBsZSBpbmRlbnRzLCBzbyB3ZSBuZWVkIHRvIGtub3cgaG93IGZhciBpbiB3ZSBoYXBwZW4gdG8gYmUuXG5cdExleGVyLnByb3RvdHlwZS5saW5lVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2g7XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBNVUxUSV9ERU5ULmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdC8vIHNob3VsZCBpdCBub3QgcGFpciBieSBpdHNlbGYgdG9rZW4oJ1NFTEVDVE9SX0VORCcsJyUnLDApXG5cdFx0Ly8gaWYgQGVuZCA9PSAnJSdcblx0XHQvLyBcdGNvbnNvbGUubG9nIFwicGFpcmluZyBzZWxlY3RvciBpbiBsaW5lVG9rZW4ge0BjaHVuay5zdWJzdHIoMCwxMCl9XCJcblx0XHQvLyBcdCMgc2hvdWxkIG5vdCBuZWVkIHRvIGFkZCBhbnl0aGluZyBoZXJlP1xuXHRcdC8vIFx0cGFpcignJScpXG5cdFx0XG5cdFx0dmFyIGluZGVudCA9IG1hdGNoWzBdO1xuXHRcdC8vIHZhciBickNvdW50ID0gY291bnQgaW5kZW50LCAnXFxuJ1xuXHRcdHZhciBickNvdW50ID0gdGhpcy5tb3ZlSGVhZChpbmRlbnQpO1xuXHRcdHRoaXMuX3NlZW5Gb3IgPSBmYWxzZTtcblx0XHQvLyByZXNldCBjb2x1bW4gYXMgd2VsbD9cblx0XHRcblx0XHR2YXIgcHJldiA9IGxhc3QodGhpcy5fdG9rZW5zLDEpO1xuXHRcdHZhciBzaXplID0gaW5kZW50Lmxlbmd0aCAtIDEgLSBpbmRlbnQubGFzdEluZGV4T2YoJ1xcbicpO1xuXHRcdHZhciBub05ld2xpbmVzID0gdGhpcy51bmZpbmlzaGVkKCk7XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJub05ld2xpbmVzXCIsbm9OZXdsaW5lc1xuXHRcdC8vIGNvbnNvbGUubG9nIFwibGluZVRva2VuIC0tIFwiLEBjaHVuay5zdWJzdHIoMCwxMCksXCItLVwiXG5cdFx0aWYgKCgvXlxcbiNcXHMvKS50ZXN0KHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dGhpcy5hZGRMaW5lYnJlYWtzKDEpO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoc2l6ZSAtIHRoaXMuX2luZGVidCA9PSB0aGlzLl9pbmRlbnQpIHtcblx0XHRcdGlmIChub05ld2xpbmVzKSB7XG5cdFx0XHRcdHRoaXMuc3VwcHJlc3NOZXdsaW5lcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5uZXdsaW5lVG9rZW4oYnJDb3VudCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGluZGVudC5sZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoc2l6ZSA+IHRoaXMuX2luZGVudCkge1xuXHRcdFx0aWYgKG5vTmV3bGluZXMpIHtcblx0XHRcdFx0dGhpcy5faW5kZWJ0ID0gc2l6ZSAtIHRoaXMuX2luZGVudDtcblx0XHRcdFx0dGhpcy5zdXBwcmVzc05ld2xpbmVzKCk7XG5cdFx0XHRcdHJldHVybiBpbmRlbnQubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaW5UYWcoKSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImluZGVudCBpbnNpZGUgdG9raWQ/IT9cIlxuXHRcdFx0XHQvLyBAaW5kZWJ0ID0gc2l6ZSAtIEBpbmRlbnRcblx0XHRcdFx0Ly8gc3VwcHJlc3NOZXdsaW5lcygpXG5cdFx0XHRcdHJldHVybiBpbmRlbnQubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHR2YXIgZGlmZiA9IHNpemUgLSB0aGlzLl9pbmRlbnQgKyB0aGlzLl9vdXRkZWJ0O1xuXHRcdFx0dGhpcy5jbG9zZURlZigpO1xuXHRcdFx0XG5cdFx0XHR2YXIgaW1tZWRpYXRlID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdFx0XG5cdFx0XHRpZiAoaW1tZWRpYXRlICYmIHRUKGltbWVkaWF0ZSkgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdHRUcyhpbW1lZGlhdGUsJ0lOREVOVCcpO1xuXHRcdFx0XHRpbW1lZGlhdGUuX21ldGEgfHwgKGltbWVkaWF0ZS5fbWV0YSA9IHtwcmU6IHRWKGltbWVkaWF0ZSkscG9zdDogJyd9KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHNob3VsZCByYXRoZXIgYWRkIHRvIG1ldGEgc29tZWhvdz8hP1xuXHRcdFx0XHQvLyB0VnMoaW1tZWRpYXRlLHRWKGltbWVkaWF0ZSkgKyAnJXwlJykgIyBjcmF6eVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy50b2tlbignSU5ERU5UJyxcIlwiICsgZGlmZiwwKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiaW5kZW50aW5nXCIsIHByZXYsIGxhc3QoQHRva2VucywxKVxuXHRcdFx0Ly8gaWYgcHJldiBhbmQgcHJldlswXSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdC8vICAgY29uc29sZS5sb2cgXCJ0ZXJtaW5hdG9yIGJlZm9yZSBpbmRlbnQ/P1wiXG5cdFx0XHRcblx0XHRcdC8vIGNoZWNrIGZvciBjb21tZW50cyBhcyB3ZWxsID9cblx0XHRcdFxuXHRcdFx0dGhpcy5faW5kZW50cy5wdXNoKGRpZmYpO1xuXHRcdFx0dGhpcy5wdXNoRW5kKCdPVVRERU5UJyk7XG5cdFx0XHQvLyBAZW5kcy5wdXNoICdPVVRERU5UJ1xuXHRcdFx0dGhpcy5fb3V0ZGVidCA9IHRoaXMuX2luZGVidCA9IDA7XG5cdFx0XHR0aGlzLmFkZExpbmVicmVha3MoYnJDb3VudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2luZGVidCA9IDA7XG5cdFx0XHR0aGlzLm91dGRlbnRUb2tlbih0aGlzLl9pbmRlbnQgLSBzaXplLG5vTmV3bGluZXMsYnJDb3VudCk7XG5cdFx0XHR0aGlzLmFkZExpbmVicmVha3MoYnJDb3VudCAtIDEpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJvdXRkZW50XCIsbm9OZXdsaW5lcyx0b2tpZCgpXG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9pbmRlbnQgPSBzaXplO1xuXHRcdHJldHVybiBpbmRlbnQubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gUmVjb3JkIGFuIG91dGRlbnQgdG9rZW4gb3IgbXVsdGlwbGUgdG9rZW5zLCBpZiB3ZSBoYXBwZW4gdG8gYmUgbW92aW5nIGJhY2tcblx0Ly8gaW53YXJkcyBwYXN0IHNldmVyYWwgcmVjb3JkZWQgaW5kZW50cy5cblx0TGV4ZXIucHJvdG90eXBlLm91dGRlbnRUb2tlbiA9IGZ1bmN0aW9uIChtb3ZlT3V0LG5vTmV3bGluZXMsbmV3bGluZUNvdW50KXtcblx0XHQvLyBoZXJlIHdlIHNob3VsZCBhbHNvIHRha2UgY2FyZSB0byBwb3AgLyByZXNldCB0aGUgc2NvcGUtYm9keVxuXHRcdC8vIG9yIGNvbnRleHQtdHlwZSBmb3IgaW5kZW50YXRpb24gXG5cdFx0dmFyIGRlbnQgPSAwO1xuXHRcdHdoaWxlIChtb3ZlT3V0ID4gMCl7XG5cdFx0XHR2YXIgbGVuID0gdGhpcy5faW5kZW50cy5sZW5ndGggLSAxO1xuXHRcdFx0aWYgKHRoaXMuX2luZGVudHNbbGVuXSA9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bW92ZU91dCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2luZGVudHNbbGVuXSA9PSB0aGlzLl9vdXRkZWJ0KSB7XG5cdFx0XHRcdG1vdmVPdXQgLT0gdGhpcy5fb3V0ZGVidDtcblx0XHRcdFx0dGhpcy5fb3V0ZGVidCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2luZGVudHNbbGVuXSA8IHRoaXMuX291dGRlYnQpIHtcblx0XHRcdFx0dGhpcy5fb3V0ZGVidCAtPSB0aGlzLl9pbmRlbnRzW2xlbl07XG5cdFx0XHRcdG1vdmVPdXQgLT0gdGhpcy5faW5kZW50c1tsZW5dO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVudCA9IHRoaXMuX2luZGVudHMucG9wKCkgLSB0aGlzLl9vdXRkZWJ0O1xuXHRcdFx0XHRtb3ZlT3V0IC09IGRlbnQ7XG5cdFx0XHRcdHRoaXMuX291dGRlYnQgPSAwO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFub05ld2xpbmVzKSB7IHRoaXMuYWRkTGluZWJyZWFrcygxKSB9O1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5wYWlyKCdPVVRERU5UJyk7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ09VVERFTlQnLFwiXCIgKyBkZW50LDApO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChkZW50KSB7IHRoaXMuX291dGRlYnQgLT0gbW92ZU91dCB9O1xuXHRcdFxuXHRcdHdoaWxlICh0aGlzLmxhc3RUb2tlblZhbHVlKCkgPT0gJzsnKXtcblx0XHRcdHRoaXMuX3Rva2Vucy5wb3AoKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghKHRoaXMubGFzdFRva2VuVHlwZSgpID09ICdURVJNSU5BVE9SJyB8fCBub05ld2xpbmVzKSkgeyB0aGlzLnRva2VuKCdURVJNSU5BVE9SJywnXFxuJywwKSB9O1xuXHRcdFxuXHRcdC8vIGNhcHBpbmcgc2NvcGVzIHNvIHRoZXkgZG9udCBoYW5nIGFyb3VuZCBcblx0XHR0aGlzLl9zY29wZXMubGVuZ3RoID0gdGhpcy5faW5kZW50cy5sZW5ndGg7XG5cdFx0XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dCgpO1xuXHRcdGlmIChjdHggPT0gJyUnIHx8IGN0eCA9PSAnVEFHJykgeyB0aGlzLnBhaXIoY3R4KSB9OyAvLyByZWFsbHk/XG5cdFx0dGhpcy5jbG9zZURlZigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBhbmQgY29uc3VtZXMgbm9uLW1lYW5pbmdmdWwgd2hpdGVzcGFjZS4gdG9raWQgdGhlIHByZXZpb3VzIHRva2VuXG5cdC8vIGFzIGJlaW5nIFwic3BhY2VkXCIsIGJlY2F1c2UgdGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgaXQgbWFrZXMgYSBkaWZmZXJlbmNlLlxuXHRMZXhlci5wcm90b3R5cGUud2hpdGVzcGFjZVRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLG5saW5lLHByZXY7XG5cdFx0aWYgKCEoKG1hdGNoID0gV0hJVEVTUEFDRS5leGVjKHRoaXMuX2NodW5rKSkgfHwgKG5saW5lID0gdGhpcy5fY2h1bmsuY2hhckF0KDApID09ICdcXG4nKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdFxuXHRcdC8vIEZJWCAtIHdoeSBvaCB3aHk/XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRwcmV2LnNwYWNlZCA9IHRydWU7XG5cdFx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcmV2Lm5ld0xpbmUgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH07XG5cdFx0fTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5hZGROZXdsaW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLCdcXG4nKTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5tb3ZlSGVhZCA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHZhciBiciA9IGNvdW50KHN0ciwnXFxuJyk7XG5cdFx0cmV0dXJuIGJyO1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5hZGRMaW5lYnJlYWtzID0gZnVuY3Rpb24gKGNvdW50LHJhdyl7XG5cdFx0dmFyIGJyO1xuXHRcdFxuXHRcdGlmICghcmF3ICYmIGNvdW50ID09IDApIHsgcmV0dXJuIHRoaXMgfTsgLy8gbm8gdGVybWluYXRvcnM/XG5cdFx0XG5cdFx0dmFyIHByZXYgPSB0aGlzLl9sYXN0O1xuXHRcdFxuXHRcdGlmICghcmF3KSB7XG5cdFx0XHRpZiAoY291bnQgPT0gMSkge1xuXHRcdFx0XHRiciA9ICdcXG4nO1xuXHRcdFx0fSBlbHNlIGlmIChjb3VudCA9PSAyKSB7XG5cdFx0XHRcdGJyID0gJ1xcblxcbic7XG5cdFx0XHR9IGVsc2UgaWYgKGNvdW50ID09IDMpIHtcblx0XHRcdFx0YnIgPSAnXFxuXFxuXFxuJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyID0gcmVwZWF0U3RyaW5nKCdcXG4nLGNvdW50KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyBGSVhcblx0XHRpZiAocHJldikge1xuXHRcdFx0dmFyIHQgPSBwcmV2Ll90eXBlOyAvLyBAbGFzdFR5cFxuXHRcdFx0dmFyIHYgPSB0VihwcmV2KTtcblx0XHRcdFxuXHRcdFx0Ly8gd2UgcmVhbGx5IHdhbnQgdG8gYWRkIHRoaXNcblx0XHRcdGlmICh0ID09ICdJTkRFTlQnKSB7XG5cdFx0XHRcdC8vIFRPRE8gd2Ugd2FudCB0byBhZGQgdG8gdGhlIGluZGVudFxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImFkZCB0aGUgY29tbWVudCB0byB0aGUgaW5kZW50IC0tIHByZT8ge3Jhd30ge2JyfVwiXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgbWV0YSA9IHByZXYuX21ldGEgfHwgKHByZXYuX21ldGEgPSB7cHJlOiAnJyxwb3N0OiAnJ30pO1xuXHRcdFx0XHRtZXRhLnBvc3QgKz0gKHJhdyB8fCBicik7XG5cdFx0XHRcdC8vIHRWcyh2ICsgKHJhdyBvciBicikpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh0ID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImFscmVhZHkgZXhpc3RzIHRlcm1pbmF0b3Ige2JyfSB7cmF3fVwiXG5cdFx0XHRcdHRWcyhwcmV2LHYgKyAocmF3IHx8IGJyKSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLGJyLDApO1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIEdlbmVyYXRlIGEgbmV3bGluZSB0b2tlbi4gQ29uc2VjdXRpdmUgbmV3bGluZXMgZ2V0IG1lcmdlZCB0b2dldGhlci5cblx0TGV4ZXIucHJvdG90eXBlLm5ld2xpbmVUb2tlbiA9IGZ1bmN0aW9uIChsaW5lcyl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJuZXdsaW5lVG9rZW5cIlxuXHRcdHdoaWxlICh0aGlzLmxhc3RUb2tlblZhbHVlKCkgPT0gJzsnKXtcblx0XHRcdGNvbnNvbGUubG9nKFwicG9wIHRva2VuXCIsdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXSk7XG5cdFx0XHR0aGlzLl90b2tlbnMucG9wKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLmFkZExpbmVicmVha3MobGluZXMpO1xuXHRcdFxuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQoKTtcblx0XHQvLyBXQVJOIG5vdyBpbXBvcnQgY2Fubm90IGdvIG92ZXIgbXVsdGlwbGUgbGluZXNcblx0XHRpZiAoY3R4ID09ICdUQUcnIHx8IGN0eCA9PSAnSU1QT1JUJykgeyB0aGlzLnBhaXIoY3R4KSB9O1xuXHRcdHRoaXMuY2xvc2VEZWYoKTsgLy8gY2xvc2UgZGVmIC0tIHJlYWxseT9cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIFVzZSBhIGBcXGAgYXQgYSBsaW5lLWVuZGluZyB0byBzdXBwcmVzcyB0aGUgbmV3bGluZS5cblx0Ly8gVGhlIHNsYXNoIGlzIHJlbW92ZWQgaGVyZSBvbmNlIGl0cyBqb2IgaXMgZG9uZS5cblx0TGV4ZXIucHJvdG90eXBlLnN1cHByZXNzTmV3bGluZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy52YWx1ZSgpID09ICdcXFxcJykgeyB0aGlzLl90b2tlbnMucG9wKCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIFdlIHRyZWF0IGFsbCBvdGhlciBzaW5nbGUgY2hhcmFjdGVycyBhcyBhIHRva2VuLiBFLmcuOiBgKCApICwgLiAhYFxuXHQvLyBNdWx0aS1jaGFyYWN0ZXIgb3BlcmF0b3JzIGFyZSBhbHNvIGxpdGVyYWwgdG9rZW5zLCBzbyB0aGF0IEppc29uIGNhbiBhc3NpZ25cblx0Ly8gdGhlIHByb3BlciBvcmRlciBvZiBvcGVyYXRpb25zLiBUaGVyZSBhcmUgc29tZSBzeW1ib2xzIHRoYXQgd2UgdG9raWQgc3BlY2lhbGx5XG5cdC8vIGhlcmUuIGA7YCBhbmQgbmV3bGluZXMgYXJlIGJvdGggdHJlYXRlZCBhcyBhIGBURVJNSU5BVE9SYCwgd2UgZGlzdGluZ3Vpc2hcblx0Ly8gcGFyZW50aGVzZXMgdGhhdCBpbmRpY2F0ZSBhIG1ldGhvZCBjYWxsIGZyb20gcmVndWxhciBwYXJlbnRoZXNlcywgYW5kIHNvIG9uLlxuXHRMZXhlci5wcm90b3R5cGUubGl0ZXJhbFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLHZhbHVlO1xuXHRcdGlmIChtYXRjaCA9IE9QRVJBVE9SLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHR2YWx1ZSA9IG1hdGNoWzBdO1xuXHRcdFx0aWYgKENPREUudGVzdCh2YWx1ZSkpIHRoaXMudGFnUGFyYW1ldGVycygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX2NodW5rLmNoYXJBdCgwKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBlbmQxID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdO1xuXHRcdHZhciBlbmQyID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDJdO1xuXHRcdFxuXHRcdHZhciBpblRhZyA9IGVuZDEgPT0gJ1RBR19FTkQnIHx8IGVuZDEgPT0gJ09VVERFTlQnICYmIGVuZDIgPT0gJ1RBR19FTkQnO1xuXHRcdFxuXHRcdHZhciB0b2tpZCA9IHZhbHVlO1xuXHRcdHZhciBwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdHZhciBwdCA9IHByZXYgJiYgdFQocHJldik7XG5cdFx0dmFyIHB2ID0gcHJldiAmJiB0VihwcmV2KTtcblx0XHR2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFxuXHRcdC8vIGlzIHRoaXMgbmVlZGVkP1xuXHRcdGlmICh2YWx1ZSA9PSAnPScgJiYgcHJldikge1xuXHRcdFx0XG5cdFx0XHRpZiAocHYgPT0gJ3x8JyB8fCBwdiA9PSAnJiYnKSB7IC8vIGluIFsnfHwnLCAnJiYnXVxuXHRcdFx0XHR0VHMocHJldiwnQ09NUE9VTkRfQVNTSUdOJyk7XG5cdFx0XHRcdHRWcyhwcmV2LHB2ICsgJz0nKTtcblx0XHRcdFx0Ly8gcHJldlswXSA9ICdDT01QT1VORF9BU1NJR04nXG5cdFx0XHRcdC8vIHByZXZbMV0gKz0gJz0nXG5cdFx0XHRcdHJldHVybiB2YWx1ZS5sZW5ndGg7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHZhbHVlID09ICc7Jykge1xuXHRcdFx0dGhpcy5fc2VlbkZvciA9IGZhbHNlO1xuXHRcdFx0dG9raWQgPSAnVEVSTUlOQVRPUic7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnKCcgJiYgaW5UYWcgJiYgcHQgIT0gJz0nICYmIHByZXYuc3BhY2VkKSB7IC8vIEZJWGVkXG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnc3BhY2VkIGJlZm9yZSAoIGluIHRva2lkJ1xuXHRcdFx0Ly8gRklYTUUgLSBzaG91bGQgcmF0aGVyIGFkZCBhIHNwZWNpYWwgdG9rZW4gbGlrZSBUQUdfUEFSQU1TX1NUQVJUXG5cdFx0XHR0aGlzLnRva2VuKCcsJywnLCcpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJy0+JyAmJiBpblRhZykge1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCc7XG5cdFx0XHR0aGlzLnBhaXIoJ1RBR19FTkQnKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICcvPicgJiYgaW5UYWcpIHtcblx0XHRcdHRva2lkID0gJ1RBR19FTkQnO1xuXHRcdFx0dGhpcy5wYWlyKCdUQUdfRU5EJyk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnPicgJiYgaW5UYWcpIHtcblx0XHRcdHRva2lkID0gJ1RBR19FTkQnO1xuXHRcdFx0dGhpcy5wYWlyKCdUQUdfRU5EJyk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnPicgJiYgdGhpcy5jb250ZXh0KCkgPT0gJ0RFRicpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdwaWNrZWQgdXAgPiEhJylcblx0XHRcdHRva2lkID0gJ0RFRl9GUkFHTUVOVCc7XG5cdFx0XHRcblx0XHRcdC8vIGVsaWYgdmFsdWUgaXMgJ1RFUk1JTkFUT1InIGFuZCBlbmQxIGlzICclJyBcblx0XHRcdC8vIFx0Y2xvc2VTZWxlY3RvcigpXG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnVEVSTUlOQVRPUicgJiYgZW5kMSA9PSAnREVGJykge1xuXHRcdFx0dGhpcy5jbG9zZURlZigpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJyYnICYmIHRoaXMuY29udGV4dCgpID09ICdERUYnKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIm9rYXkhXCIpXG5cdFx0XHR0b2tpZCA9ICdCTE9DS19BUkcnO1xuXHRcdFx0Ly8gY2hhbmdlIHRoZSBuZXh0IGlkZW50aWZpZXIgaW5zdGVhZD9cblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICcqJyAmJiB0aGlzLl9jaHVuay5jaGFyQXQoMSkubWF0Y2goL1tBLVphLXpcXF9cXEBcXFtdLykgJiYgKHByZXYuc3BhY2VkIHx8IFsnLCcsJygnLCdbJywneycsJ3wnLCdcXG4nLCdcXHQnXS5pbmRleE9mKHB2KSA+PSAwKSkge1xuXHRcdFx0dG9raWQgPSBcIlNQTEFUXCI7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAn4oiaJykge1xuXHRcdFx0dG9raWQgPSAnU1FSVCc7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnxpInKSB7XG5cdFx0XHR0b2tpZCA9ICdGVU5DJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsTUFUSCkgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnTUFUSCc7XG5cdFx0fSBlbHNlIGlmIChpZHgkKHZhbHVlLENPTVBBUkUpID49IDApIHtcblx0XHRcdHRva2lkID0gJ0NPTVBBUkUnO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxDT01QT1VORF9BU1NJR04pID49IDApIHtcblx0XHRcdHRva2lkID0gJ0NPTVBPVU5EX0FTU0lHTic7XG5cdFx0fSBlbHNlIGlmIChpZHgkKHZhbHVlLFVOQVJZKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdVTkFSWSc7XG5cdFx0fSBlbHNlIGlmIChpZHgkKHZhbHVlLFNISUZUKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdTSElGVCc7XG5cdFx0fSBlbHNlIGlmIChpZHgkKHZhbHVlLExPR0lDKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdMT0dJQyc7IC8vIG9yIHZhbHVlIGlzICc/JyBhbmQgcHJldj86c3BhY2VkIFxuXHRcdH0gZWxzZSBpZiAocHJldiAmJiAhcHJldi5zcGFjZWQpIHtcblx0XHRcdC8vIG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoZXNlXG5cdFx0XHRpZiAodmFsdWUgPT0gJygnICYmIGVuZDEgPT0gJyUnKSB7XG5cdFx0XHRcdHRva2lkID0gJ1RBR19BVFRSU19TVEFSVCc7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICcoJyAmJiBpZHgkKHB0LENBTExBQkxFKSA+PSAwKSB7XG5cdFx0XHRcdC8vIG5vdCB1c2luZyB0aGlzID8/P1xuXHRcdFx0XHQvLyBwcmV2WzBdID0gJ0ZVTkNfRVhJU1QnIGlmIHByZXZbMF0gaXMgJz8nXG5cdFx0XHRcdHRva2lkID0gJ0NBTExfU1RBUlQnO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnWycgJiYgaWR4JChwdCxJTkRFWEFCTEUpID49IDApIHtcblx0XHRcdFx0dG9raWQgPSAnSU5ERVhfU1RBUlQnO1xuXHRcdFx0XHRpZiAocHQgPT0gJz8nKSB7IHRUcyhwcmV2LCdJTkRFWF9TT0FLJykgfTtcblx0XHRcdFx0Ly8gcHJldlswXSA9ICdJTkRFWF9TT0FLJyBpZiBwcmV2WzBdID09ICc/J1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHN3aXRjaCAodmFsdWUpIHtcblx0XHRcdGNhc2UgJygnOlxuXHRcdFx0Y2FzZSAneyc6XG5cdFx0XHRjYXNlICdbJzpcblx0XHRcdFx0dGhpcy5wdXNoRW5kKElOVkVSU0VTW3ZhbHVlXSk7YnJlYWs7XG5cdFx0XHRcblx0XHRcdGNhc2UgJyknOlxuXHRcdFx0Y2FzZSAnfSc6XG5cdFx0XHRjYXNlICddJzpcblx0XHRcdFx0dGhpcy5wYWlyKHZhbHVlKTticmVhaztcblx0XHRcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGhhY2t5IHJ1bGUgdG8gdHJ5IHRvIGFsbG93IGZvciB0dXBsZS1hc3NpZ25tZW50cyBpbiBibG9ja3Ncblx0XHQvLyBpZiB2YWx1ZSBpcyAnLCcgYW5kIHByZXZbMF0gaXMgJ0lERU5USUZJRVInIGFuZCBAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMl1bMF0gaW4gWydURVJNSU5BVE9SJywnSU5ERU5UJ11cblx0XHQvLyAgICMgdG9rZW4gXCJUVVBMRVwiLCBcInR1cGxlXCIgIyBzaG91bGQgcmF0aGVyIGluc2VydCBpdCBzb21ld2hlcmUgZWxzZSwgbm8/XG5cdFx0Ly8gICBjb25zb2xlLmxvZyhcImZvdW5kIGNvbW1hXCIpXG5cdFx0XG5cdFx0dGhpcy50b2tlbih0b2tpZCx2YWx1ZSx2YWx1ZS5sZW5ndGgpO1xuXHRcdHJldHVybiB2YWx1ZS5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBUb2tlbiBNYW5pcHVsYXRvcnNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFxuXHQvLyBTYW5pdGl6ZSBhIGhlcmVkb2Mgb3IgaGVyZWNvbW1lbnQgYnlcblx0Ly8gZXJhc2luZyBhbGwgZXh0ZXJuYWwgaW5kZW50YXRpb24gb24gdGhlIGxlZnQtaGFuZCBzaWRlLlxuXHRMZXhlci5wcm90b3R5cGUuc2FuaXRpemVIZXJlZG9jID0gZnVuY3Rpb24gKGRvYyxvcHRpb25zKXtcblx0XHR2YXIgbWF0Y2g7XG5cdFx0dmFyIGluZGVudCA9IG9wdGlvbnMuaW5kZW50O1xuXHRcdHZhciBoZXJlY29tbWVudCA9IG9wdGlvbnMuaGVyZWNvbW1lbnQ7XG5cdFx0XG5cdFx0aWYgKGhlcmVjb21tZW50KSB7XG5cdFx0XHRpZiAoSEVSRURPQ19JTExFR0FMLnRlc3QoZG9jKSkge1xuXHRcdFx0XHR0aGlzLmVycm9yKFwiYmxvY2sgY29tbWVudCBjYW5ub3QgY29udGFpbiAnKi8nIHN0YXJ0aW5nXCIpO1xuXHRcdFx0fTtcblx0XHRcdGlmIChkb2MuaW5kZXhPZignXFxuJykgPD0gMCkgeyByZXR1cm4gZG9jIH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsZW5ndGhfO3doaWxlIChtYXRjaCA9IEhFUkVET0NfSU5ERU5ULmV4ZWMoZG9jKSl7XG5cdFx0XHRcdHZhciBhdHRlbXB0ID0gbWF0Y2hbMV07XG5cdFx0XHRcdGlmIChpbmRlbnQgPT0gbnVsbCB8fCAwIDwgKGxlbmd0aF8gPSBhdHRlbXB0Lmxlbmd0aCkgJiYgbGVuZ3RoXyA8IGluZGVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHRpbmRlbnQgPSBhdHRlbXB0O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpbmRlbnQpIHsgZG9jID0gZG9jLnJlcGxhY2UoUmVnRXhwKChcIlxcXFxuXCIgKyBpbmRlbnQpLFwiZ1wiKSwnXFxuJykgfTtcblx0XHRpZiAoIWhlcmVjb21tZW50KSB7IGRvYyA9IGRvYy5yZXBsYWNlKC9eXFxuLywnJykgfTtcblx0XHRyZXR1cm4gZG9jO1xuXHR9O1xuXHRcblx0Ly8gQSBzb3VyY2Ugb2YgYW1iaWd1aXR5IGluIG91ciBncmFtbWFyIHVzZWQgdG8gYmUgcGFyYW1ldGVyIGxpc3RzIGluIGZ1bmN0aW9uXG5cdC8vIGRlZmluaXRpb25zIHZlcnN1cyBhcmd1bWVudCBsaXN0cyBpbiBmdW5jdGlvbiBjYWxscy4gV2FsayBiYWNrd2FyZHMsIHRva2lkZ2luZ1xuXHQvLyBwYXJhbWV0ZXJzIHNwZWNpYWxseSBpbiBvcmRlciB0byBtYWtlIHRoaW5ncyBlYXNpZXIgZm9yIHRoZSBwYXJzZXIuXG5cdExleGVyLnByb3RvdHlwZS50YWdQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRvaztcblx0XHRpZiAodGhpcy5sYXN0VG9rZW5UeXBlKCkgIT0gJyknKSB7IHJldHVybiB0aGlzIH07XG5cdFx0dmFyIHN0YWNrID0gW107XG5cdFx0dmFyIHRva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHR2YXIgaSA9IHRva2Vucy5sZW5ndGg7XG5cdFx0XG5cdFx0dFRzKHRva2Vuc1stLWldLCdQQVJBTV9FTkQnKTtcblx0XHRcblx0XHR3aGlsZSAodG9rID0gdG9rZW5zWy0taV0pe1xuXHRcdFx0dmFyIHQgPSB0VCh0b2spO1xuXHRcdFx0c3dpdGNoICh0KSB7XG5cdFx0XHRcdGNhc2UgJyknOlxuXHRcdFx0XHRcdHN0YWNrLnB1c2godG9rKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgJygnOlxuXHRcdFx0XHRjYXNlICdDQUxMX1NUQVJUJzpcblx0XHRcdFx0XHRpZiAoc3RhY2subGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHQgPT0gJygnKSB7XG5cdFx0XHRcdFx0XHR0VHModG9rLCdQQVJBTV9TVEFSVCcpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIENsb3NlIHVwIGFsbCByZW1haW5pbmcgb3BlbiBibG9ja3MgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cblx0TGV4ZXIucHJvdG90eXBlLmNsb3NlSW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjdHggPSBjb250ZXh0XG5cdFx0Ly8gcGFpcihjdHgpIGlmIGN0eCBpbiBbJyUnLCdERUYnXVxuXHRcdHRoaXMuY2xvc2VEZWYoKTtcblx0XHR0aGlzLmNsb3NlU2VsZWN0b3IoKTtcblx0XHRyZXR1cm4gdGhpcy5vdXRkZW50VG9rZW4odGhpcy5faW5kZW50LGZhbHNlLDApO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBhIGJhbGFuY2VkIGdyb3VwIHN1Y2ggYXMgYSBzaW5nbGUgb3IgZG91YmxlLXF1b3RlZCBzdHJpbmcuIFBhc3MgaW5cblx0Ly8gYSBzZXJpZXMgb2YgZGVsaW1pdGVycywgYWxsIG9mIHdoaWNoIG11c3QgYmUgbmVzdGVkIGNvcnJlY3RseSB3aXRoaW4gdGhlXG5cdC8vIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBoYXZlIHN0cmluZ3Mgd2l0aGluXG5cdC8vIGludGVycG9sYXRpb25zIHdpdGhpbiBzdHJpbmdzLCBhZCBpbmZpbml0dW0uXG5cdExleGVyLnByb3RvdHlwZS5iYWxhbmNlZFN0cmluZyA9IGZ1bmN0aW9uIChzdHIsZW5kKXtcblx0XHR2YXIgbWF0Y2gsbGV0dGVyLHByZXY7XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgJ2JhbGFuY2luZyBzdHJpbmchJywgc3RyLCBlbmRcblx0XHR2YXIgc3RhY2sgPSBbZW5kXTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0XG5cdFx0Ly8gY291bGQgaXQgbm90IGhhcHBlbiBoZXJlP1xuXHRcdHdoaWxlIChpIDwgKHN0ci5sZW5ndGggLSAxKSl7XG5cdFx0XHRpKys7XG5cdFx0XHRsZXR0ZXIgPSBzdHIuY2hhckF0KGkpO1xuXHRcdFx0c3dpdGNoIChsZXR0ZXIpIHtcblx0XHRcdFx0Y2FzZSAnXFxcXCc6XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSBlbmQ6XG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0aWYgKCFzdGFjay5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHZhciB2ID0gc3RyLnNsaWNlKDAsaSArIDEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRlbmQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGVuZCA9PSAnfScgJiYgKGxldHRlciA9PSAnXCInIHx8IGxldHRlciA9PSBcIidcIikpIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSBsZXR0ZXIpO1xuXHRcdFx0fSBlbHNlIGlmIChlbmQgPT0gJ30nICYmIGxldHRlciA9PSAnLycgJiYgKG1hdGNoID0gKEhFUkVHRVguZXhlYyhzdHIuc2xpY2UoaSkpIHx8IFJFR0VYLmV4ZWMoc3RyLnNsaWNlKGkpKSkpKSB7XG5cdFx0XHRcdGkgKz0gbWF0Y2hbMF0ubGVuZ3RoIC0gMTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID09ICd9JyAmJiBsZXR0ZXIgPT0gJ3snKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gJ30nKTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID09ICdcIicgJiYgbGV0dGVyID09ICd7Jykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9ICd9Jyk7XG5cdFx0XHR9O1xuXHRcdFx0cHJldiA9IGxldHRlcjtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghdGhpcy5fb3B0cy5zaWxlbnQpIHsgcmV0dXJuIHRoaXMuZXJyb3IoKFwibWlzc2luZyBcIiArIChzdGFjay5wb3AoKSkgKyBcIiwgc3RhcnRpbmdcIikpIH07XG5cdH07XG5cdFxuXHQvLyBFeHBhbmQgdmFyaWFibGVzIGFuZCBleHByZXNzaW9ucyBpbnNpZGUgZG91YmxlLXF1b3RlZCBzdHJpbmdzIHVzaW5nXG5cdC8vIFJ1YnktbGlrZSBub3RhdGlvbiBmb3Igc3Vic3RpdHV0aW9uIG9mIGFyYml0cmFyeSBleHByZXNzaW9ucy5cblx0Ly9cblx0Ly8gICAgIFwiSGVsbG8gI3tuYW1lLmNhcGl0YWxpemUoKX0uXCJcblx0Ly9cblx0Ly8gSWYgaXQgZW5jb3VudGVycyBhbiBpbnRlcnBvbGF0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIHJlY3Vyc2l2ZWx5IGNyZWF0ZSBhXG5cdC8vIG5ldyBMZXhlciwgdG9rZW5pemUgdGhlIGludGVycG9sYXRlZCBjb250ZW50cywgYW5kIG1lcmdlIHRoZW0gaW50byB0aGVcblx0Ly8gdG9rZW4gc3RyZWFtLlxuXHRMZXhlci5wcm90b3R5cGUuaW50ZXJwb2xhdGVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyLG9wdGlvbnMpe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwiaW50ZXJwb2xhdGUgc3RyaW5nXCJcblx0XHRpZihvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcblx0XHR2YXIgaGVyZWRvYyA9IG9wdGlvbnMuaGVyZWRvYztcblx0XHR2YXIgcXVvdGUgPSBvcHRpb25zLnF1b3RlO1xuXHRcdHZhciByZWdleCA9IG9wdGlvbnMucmVnZXg7XG5cdFx0dmFyIHByZWZpeCA9IG9wdGlvbnMucHJlZml4O1xuXHRcdFxuXHRcdHZhciBzdGFydExvYyA9IHRoaXMuX2xvYztcblx0XHR2YXIgdG9rZW5zID0gW107XG5cdFx0dmFyIHBpID0gMDtcblx0XHR2YXIgaSA9IC0xO1xuXHRcdHZhciBsb2NPZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAxO1xuXHRcdHZhciBzdHJsZW4gPSBzdHIubGVuZ3RoO1xuXHRcdHZhciBsZXR0ZXI7XG5cdFx0dmFyIGV4cHI7XG5cdFx0XG5cdFx0dmFyIGlzSW50ZXJwb2xhdGVkID0gZmFsc2U7XG5cdFx0Ly8gb3V0IG9mIGJvdW5kc1xuXHRcdHdoaWxlIChsZXR0ZXIgPSBzdHIuY2hhckF0KGkgKz0gMSkpe1xuXHRcdFx0aWYgKGxldHRlciA9PSAnXFxcXCcpIHtcblx0XHRcdFx0aSArPSAxO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICghKHN0ci5jaGFyQXQoaSkgPT0gJ3snICYmIChleHByID0gdGhpcy5iYWxhbmNlZFN0cmluZyhzdHIuc2xpY2UoaSksJ30nKSkpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aXNJbnRlcnBvbGF0ZWQgPSB0cnVlO1xuXHRcdFx0XG5cdFx0XHQvLyB0aGVzZSBoYXZlIG5vIHJlYWwgc2Vuc2Ugb2YgbG9jYXRpb24gb3IgYW55dGhpbmc/XG5cdFx0XHRpZiAocGkgPCBpKSB7XG5cdFx0XHRcdC8vIHRoaXMgaXMgdGhlIHByZWZpeC1zdHJpbmcgLSBiZWZvcmUgYW55IGl0ZW1cblx0XHRcdFx0dmFyIHRvayA9IG5ldyBUb2tlbignTkVPU1RSSU5HJyx0aGlzLmVzY2FwZVN0cihzdHIuc2xpY2UocGksaSksaGVyZWRvYyxxdW90ZSksdGhpcy5fbG9jICsgcGkgKyBsb2NPZmZzZXQsaSAtIHBpKTtcblx0XHRcdFx0Ly8gdG9rLkBsb2MgPSBAbG9jICsgcGlcblx0XHRcdFx0Ly8gdG9rLkBsZW4gPSBpIC0gcGkgKyAyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHRvayk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0b2tlbnMucHVzaChuZXcgVG9rZW4oJ3t7JywneycsdGhpcy5fbG9jICsgaSArIGxvY09mZnNldCwxKSk7XG5cdFx0XHRcblx0XHRcdHZhciBpbm5lciA9IGV4cHIuc2xpY2UoMSwtMSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaW5uZXIgaXMnLGlubmVyXG5cdFx0XHQvLyByZW1vdmUgbGVhZGluZyBzcGFjZXMgXG5cdFx0XHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93IG11Y2ggd2hpdGVzcGFjZSB3ZSBkcm9wcGVkIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRpbm5lciA9IGlubmVyLnJlcGxhY2UoL15bXlxcblxcU10rLywnJyk7XG5cdFx0XHRcblx0XHRcdGlmIChpbm5lci5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gd2UgbmVlZCB0byByZW1lbWJlciB0aGUgbG9jIHdlIHN0YXJ0IGF0XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdpbnRlcnBvbGF0ZSBmcm9tIGxvYycsQGxvYyxpKVxuXHRcdFx0XHQvLyByZWFsbHk/IHdoeSBub3QganVzdCBhZGQgdG8gdGhlIHN0YWNrPz9cblx0XHRcdFx0Ly8gd2hhdCBhYm91dCB0aGUgYWRkZWQgXG5cdFx0XHRcdC8vIHNob3VsZCBzaGFyZSB3aXRoIHRoZSBzZWxlY3RvciBubz9cblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJ0b2tlbml6ZSBpbm5lciBwYXJ0cyBvZiBzdHJpbmdcIixpbm5lclxuXHRcdFx0XHR2YXIgc3BhY2VzID0gMDtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuX2xvYyArIGkgKyAoZXhwci5sZW5ndGggLSBpbm5lci5sZW5ndGgpIC0gMTtcblx0XHRcdFx0Ly8gd2h5IGNyZWF0ZSBhIHdob2xlIG5ldyBsZXhlcj8gU2hvdWxkIHJhdGhlciByZXVzZSBvbmVcblx0XHRcdFx0Ly8gbXVjaCBiZXR0ZXIgdG8gc2ltcGx5IG1vdmUgaW50byBpbnRlcnBvbGF0aW9uIG1vZGUgd2hlcmVcblx0XHRcdFx0Ly8gd2UgY29udGludWUgcGFyc2luZyB1bnRpbCB3ZSBtZWV0IHVucGFpcmVkIH1cblx0XHRcdFx0dmFyIG5lc3RlZCA9IG5ldyBMZXhlcigpLnRva2VuaXplKGlubmVyLHtpbmxpbmU6IHRydWUscmV3cml0ZTogZmFsc2UsbG9jOiBvZmZzZXQgKyBsb2NPZmZzZXR9KTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgbmVzdGVkLnBvcFxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5lc3RlZFswXSAmJiB0VChuZXN0ZWRbMF0pID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHRcdG5lc3RlZC5zaGlmdCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5lc3RlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHR0b2tlbnMucHVzaC5hcHBseSh0b2tlbnMsbmVzdGVkKTsgLy8gVC50b2tlbignVE9LRU5TJyxuZXN0ZWQsMClcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHNob3VsZCByYXRoZXIgYWRkIHRoZSBhbW91bnQgYnkgd2hpY2ggb3VyIGxleGVyIGhhcyBtb3ZlZD9cblx0XHRcdGkgKz0gZXhwci5sZW5ndGggLSAxO1xuXHRcdFx0dG9rZW5zLnB1c2gobmV3IFRva2VuKCd9fScsJ30nLHRoaXMuX2xvYyArIGkgKyBsb2NPZmZzZXQsMSkpO1xuXHRcdFx0cGkgPSBpICsgMTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGFkZGluZyB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBzdHJpbmcgaGVyZVxuXHRcdGlmIChpID49IHBpICYmIHBpIDwgc3RyLmxlbmd0aCkge1xuXHRcdFx0Ly8gc2V0IHRoZSBsZW5ndGggYXMgd2VsbCAtIG9yP1xuXHRcdFx0Ly8gdGhlIHN0cmluZyBhZnRlcj9cblx0XHRcdC8vIGNvbnNvbGUubG9nICdwdXNoIG5lb3N0cmluZydcblx0XHRcdHRva2Vucy5wdXNoKG5ldyBUb2tlbignTkVPU1RSSU5HJyx0aGlzLmVzY2FwZVN0cihzdHIuc2xpY2UocGkpLGhlcmVkb2MscXVvdGUpLHRoaXMuX2xvYyArIHBpICsgbG9jT2Zmc2V0LHN0ci5sZW5ndGggLSBwaSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgdG9rZW5zOmxlbmd0aFxuXHRcdGlmIChyZWdleCkgeyByZXR1cm4gdG9rZW5zIH07XG5cdFx0XG5cdFx0aWYgKCF0b2tlbnMubGVuZ3RoKSB7IHJldHVybiB0aGlzLnRva2VuKCdORU9TVFJJTkcnLCdcIlwiJykgfTtcblx0XHRcblx0XHRmb3IgKHZhciBqID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG5cdFx0XHR0aGlzLl90b2tlbnMucHVzaCh0b2tlbnNbal0pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRva2Vucztcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgYSBiYWxhbmNlZCBncm91cCBzdWNoIGFzIGEgc2luZ2xlIG9yIGRvdWJsZS1xdW90ZWQgc3RyaW5nLiBQYXNzIGluXG5cdC8vIGEgc2VyaWVzIG9mIGRlbGltaXRlcnMsIGFsbCBvZiB3aGljaCBtdXN0IGJlIG5lc3RlZCBjb3JyZWN0bHkgd2l0aGluIHRoZVxuXHQvLyBjb250ZW50cyBvZiB0aGUgc3RyaW5nLiBUaGlzIG1ldGhvZCBhbGxvd3MgdXMgdG8gaGF2ZSBzdHJpbmdzIHdpdGhpblxuXHQvLyBpbnRlcnBvbGF0aW9ucyB3aXRoaW4gc3RyaW5ncywgYWQgaW5maW5pdHVtLlxuXHRMZXhlci5wcm90b3R5cGUuYmFsYW5jZWRTZWxlY3RvciA9IGZ1bmN0aW9uIChzdHIsZW5kKXtcblx0XHR2YXIgcHJldjtcblx0XHR2YXIgbGV0dGVyO1xuXHRcdHZhciBzdGFjayA9IFtlbmRdO1xuXHRcdC8vIEZJWE1FXG5cdFx0Zm9yICh2YXIgbGVuID0gc3RyLmxlbmd0aCwgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0c3dpdGNoIChsZXR0ZXIgPSBzdHIuY2hhckF0KGkpKSB7XG5cdFx0XHRcdGNhc2UgJ1xcXFwnOlxuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgZW5kOlxuXHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGlmICghc3RhY2subGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyLnNsaWNlKDAsaSArIDEpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZW5kID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdH07XG5cdFx0XHRpZiAoZW5kID09ICd9JyAmJiBsZXR0ZXIgPT0gWycpJ10pIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSBsZXR0ZXIpO1xuXHRcdFx0fSBlbHNlIGlmIChlbmQgPT0gJ30nICYmIGxldHRlciA9PSAneycpIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSAnfScpO1xuXHRcdFx0fSBlbHNlIGlmIChlbmQgPT0gJyknICYmIGxldHRlciA9PSAneycpIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSAnfScpO1xuXHRcdFx0fTtcblx0XHRcdHByZXYgPSBsZXR0ZXI7IC8vIHdoYXQsIHdoeT9cblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzLmVycm9yKChcIm1pc3NpbmcgXCIgKyAoc3RhY2sucG9wKCkpICsgXCIsIHN0YXJ0aW5nXCIpKTtcblx0fTtcblx0XG5cdC8vIFBhaXJzIHVwIGEgY2xvc2luZyB0b2tlbiwgZW5zdXJpbmcgdGhhdCBhbGwgbGlzdGVkIHBhaXJzIG9mIHRva2VucyBhcmVcblx0Ly8gY29ycmVjdGx5IGJhbGFuY2VkIHRocm91Z2hvdXQgdGhlIGNvdXJzZSBvZiB0aGUgdG9rZW4gc3RyZWFtLlxuXHRMZXhlci5wcm90b3R5cGUucGFpciA9IGZ1bmN0aW9uICh0b2spe1xuXHRcdHZhciB3YW50ZWQgPSBsYXN0KHRoaXMuX2VuZHMpO1xuXHRcdGlmICh0b2sgIT0gd2FudGVkKSB7XG5cdFx0XHRpZiAoJ09VVERFTlQnICE9IHdhbnRlZCkgeyB0aGlzLmVycm9yKChcInVubWF0Y2hlZCBcIiArIHRvaykpIH07XG5cdFx0XHR2YXIgc2l6ZSA9IGxhc3QodGhpcy5faW5kZW50cyk7XG5cdFx0XHR0aGlzLl9pbmRlbnQgLT0gc2l6ZTtcblx0XHRcdHRoaXMub3V0ZGVudFRva2VuKHNpemUsdHJ1ZSwwKTtcblx0XHRcdHJldHVybiB0aGlzLnBhaXIodG9rKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzLnBvcEVuZCgpO1xuXHR9O1xuXHRcblx0XG5cdC8vIEhlbHBlcnNcblx0Ly8gLS0tLS0tLVxuXHRcblx0Ly8gQWRkIGEgdG9rZW4gdG8gdGhlIHJlc3VsdHMsIHRha2luZyBub3RlIG9mIHRoZSBsaW5lIG51bWJlci5cblx0TGV4ZXIucHJvdG90eXBlLnRva2VuID0gZnVuY3Rpb24gKGlkLHZhbHVlLGxlbixvZmZzZXQpe1xuXHRcdHRoaXMuX2xhc3RUeXAgPSBpZDtcblx0XHR0aGlzLl9sYXN0VmFsID0gdmFsdWU7XG5cdFx0dmFyIHRvayA9IHRoaXMuX2xhc3QgPSBuZXcgVG9rZW4oaWQsdmFsdWUsdGhpcy5fbG9jICsgKG9mZnNldCB8fCAwKSxsZW4gfHwgMCk7XG5cdFx0dGhpcy5fdG9rZW5zLnB1c2godG9rKTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUubGFzdFRva2VuVHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0b2tlbiA9IHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV07XG5cdFx0cmV0dXJuIHRva2VuID8gKHRUKHRva2VuKSkgOiAoJ05PTkUnKTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5sYXN0VG9rZW5WYWx1ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0b2tlbiA9IHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV07XG5cdFx0cmV0dXJuIHRva2VuID8gKHRva2VuLl92YWx1ZSkgOiAoJycpO1xuXHR9O1xuXHRcblx0Ly8gUGVlayBhdCBhIHRva2lkIGluIHRoZSBjdXJyZW50IHRva2VuIHN0cmVhbS5cblx0TGV4ZXIucHJvdG90eXBlLnRva2lkID0gZnVuY3Rpb24gKGluZGV4LHZhbCl7XG5cdFx0dmFyIHRvaztcblx0XHRpZiAodG9rID0gbGFzdCh0aGlzLl90b2tlbnMsaW5kZXgpKSB7XG5cdFx0XHRpZiAodmFsKSB7IHRUcyh0b2ssdmFsKSB9O1xuXHRcdFx0cmV0dXJuIHRUKHRvayk7XG5cdFx0XHQvLyB0b2suQHR5cGUgPSB0b2tpZCBpZiB0b2tpZCAjIHdoeT9cblx0XHRcdC8vIHRvay5AdHlwZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9O1xuXHRcblx0Ly8gUGVlayBhdCBhIHZhbHVlIGluIHRoZSBjdXJyZW50IHRva2VuIHN0cmVhbS5cblx0TGV4ZXIucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKGluZGV4LHZhbCl7XG5cdFx0dmFyIHRvaztcblx0XHRpZiAodG9rID0gbGFzdCh0aGlzLl90b2tlbnMsaW5kZXgpKSB7XG5cdFx0XHRpZiAodmFsKSB7IHRWcyh0b2ssdmFsKSB9O1xuXHRcdFx0cmV0dXJuIHRWKHRvayk7XG5cdFx0XHQvLyB0b2suQHZhbHVlID0gdmFsIGlmIHZhbCAjIHdoeT9cblx0XHRcdC8vIHRvay5AdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHQvLyBBcmUgd2UgaW4gdGhlIG1pZHN0IG9mIGFuIHVuZmluaXNoZWQgZXhwcmVzc2lvbj9cblx0TGV4ZXIucHJvdG90eXBlLnVuZmluaXNoZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAoTElORV9DT05USU5VRVIudGVzdCh0aGlzLl9jaHVuaykpIHsgcmV0dXJuIHRydWUgfTtcblx0XHRyZXR1cm4gVU5GSU5JU0hFRC5pbmRleE9mKHRoaXMuX2xhc3RUeXApID49IDA7XG5cdH07XG5cdFxuXHQvLyB2YXIgdG9rZW5zID0gWydcXFxcJywnLicsICc/LicsICdVTkFSWScsICdNQVRIJywgJysnLCAnLScsICdTSElGVCcsICdSRUxBVElPTicsICdDT01QQVJFJywgJ0xPR0lDJywgJ0NPTVBPVU5EX0FTU0lHTicsICdUSFJPVycsICdFWFRFTkRTJ11cblx0XG5cdC8vIENvbnZlcnRzIG5ld2xpbmVzIGZvciBzdHJpbmcgbGl0ZXJhbHMuXG5cdExleGVyLnByb3RvdHlwZS5lc2NhcGVMaW5lcyA9IGZ1bmN0aW9uIChzdHIsaGVyZWRvYyl7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKE1VTFRJTElORVIsKGhlcmVkb2MgPyAoJ1xcXFxuJykgOiAoJycpKSk7XG5cdH07XG5cdFxuXHQvLyBDb25zdHJ1Y3RzIGEgc3RyaW5nIHRva2VuIGJ5IGVzY2FwaW5nIHF1b3RlcyBhbmQgbmV3bGluZXMuXG5cdExleGVyLnByb3RvdHlwZS5tYWtlU3RyaW5nID0gZnVuY3Rpb24gKGJvZHkscXVvdGUsaGVyZWRvYyl7XG5cdFx0aWYgKCFib2R5KSB7IHJldHVybiBxdW90ZSArIHF1b3RlIH07XG5cdFx0Ym9keSA9IGJvZHkucmVwbGFjZSgvXFxcXChbXFxzXFxTXSkvZyxmdW5jdGlvbihtYXRjaCxjb250ZW50cykge1xuXHRcdFx0cmV0dXJuIChjb250ZW50cyA9PSAnXFxuJyB8fCBjb250ZW50cyA9PSBxdW90ZSkgPyAoY29udGVudHMpIDogKG1hdGNoKTtcblx0XHR9KTtcblx0XHQvLyBEb2VzIG5vdCB3b3JrIG5vd1xuXHRcdGJvZHkgPSBib2R5LnJlcGxhY2UoUmVnRXhwKChcIlwiICsgcXVvdGUpLFwiZ1wiKSwnXFxcXCQmJyk7XG5cdFx0cmV0dXJuIHF1b3RlICsgdGhpcy5lc2NhcGVMaW5lcyhib2R5LGhlcmVkb2MpICsgcXVvdGU7XG5cdH07XG5cdFxuXHQvLyBUaHJvd3MgYSBzeW50YXggZXJyb3Igb24gdGhlIGN1cnJlbnQgYEBsaW5lYC5cblx0TGV4ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsbGVuKXtcblx0XHRpZiAoKHR5cGVvZiB0aGlzLl9saW5lPT0nbnVtYmVyJ3x8dGhpcy5fbGluZSBpbnN0YW5jZW9mIE51bWJlcikpIHsgbWVzc2FnZSA9IChcIlwiICsgbWVzc2FnZSArIFwiIG9uIGxpbmUgXCIgKyAodGhpcy5fbGluZSkpIH07XG5cdFx0XG5cdFx0aWYgKGxlbikge1xuXHRcdFx0bWVzc2FnZSArPSAoXCIgW1wiICsgKHRoaXMuX2xvYykgKyBcIjpcIiArICh0aGlzLl9sb2MgKyBsZW4pICsgXCJdXCIpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcblx0XHRlcnIubGluZSA9IHRoaXMuX2xpbmU7XG5cdFx0Ly8gZXJyOmNvbHVtbk51bWJlclxuXHRcdGVyciA9IG5ldyBFUlIuSW1iYVBhcnNlRXJyb3IoZXJyLHt0b2tlbnM6IHRoaXMuX3Rva2Vucyxwb3M6IHRoaXMuX3Rva2Vucy5sZW5ndGh9KTtcblx0XHRlcnIucmVnaW9uID0gW3RoaXMuX2xvYyx0aGlzLl9sb2MgKyAobGVuIHx8IDApXTtcblx0XHR0aHJvdyBlcnI7XG5cdH07XG5cdHJldHVybiBMZXhlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9zcmMvY29tcGlsZXIvbGV4ZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0dmFyIFRPSywgTEJSQUNLRVQsIFJCUkFDS0VULCBMUEFSRU4sIFJQQVJFTiwgSU5ERU5ULCBPVVRERU5UO1xuXHRcblx0XG5cdG1vZHVsZS5leHBvcnRzLlRPSyA9IFRPSyA9IHt9O1xuXHR2YXIgVFRFUk1JTkFUT1IgPSBUT0suVEVSTUlOQVRPUiA9IDE7XG5cdHZhciBUSURFTlRJRklFUiA9IFRPSy5JREVOVElGSUVSID0gMjtcblx0VElERU5USUZJRVIgPSBUT0suSVZBUiA9IDI7XG5cdHZhciBDT05TVCA9IFRPSy5DT05TVCA9IDM7XG5cdHZhciBWQVIgPSBUT0suVkFSID0gNDtcblx0dmFyIElGID0gVE9LLklGID0gNTtcblx0dmFyIEVMU0UgPSBUT0suRUxTRSA9IDY7XG5cdHZhciBERUYgPSBUT0suREVGID0gNztcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gVG9rZW4odHlwZSx2YWx1ZSxsb2MsbGVuKXtcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuX2xvYyA9IGxvYyAhPSBudWxsID8gKGxvYykgOiAoLTEpO1xuXHRcdHRoaXMuX2xlbiA9IGxlbiB8fCAwO1xuXHRcdHRoaXMuX21ldGEgPSBudWxsO1xuXHRcdHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5uZXdMaW5lID0gZmFsc2U7XG5cdFx0dGhpcy5zcGFjZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuVG9rZW4gPSBUb2tlbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRUb2tlbi5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gXCJcIiArIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLmNoYXJBdCA9IGZ1bmN0aW9uIChpKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUuY2hhckF0KGkpO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGkpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZS5zbGljZShpKTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX2xvYyx0aGlzLl9sb2MgKyAodGhpcy5fbGVuIHx8IHRoaXMuX3ZhbHVlLmxlbmd0aCldO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnNvdXJjZU1hcE1hcmtlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9sb2MgPT0gLTEgPyAoJzonKSA6ICgoXCIlJFwiICsgKHRoaXMuX2xvYykgKyBcIiQlXCIpKTtcblx0XHQvLyBAY29sID09IC0xID8gJycgOiBcIiUle0BsaW5lfSR7QGNvbH0lJVwiXG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gbGV4KCl7XG5cdFx0dmFyIHRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5wb3MrK107XG5cdFx0dmFyIHR0YWc7XG5cdFx0XG5cdFx0aWYgKHRva2VuKSB7XG5cdFx0XHR0dGFnID0gdG9rZW4uX3R5cGU7XG5cdFx0XHR0aGlzLnl5dGV4dCA9IHRva2VuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0dGFnID0gJyc7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdHRhZztcblx0fTsgZXhwb3J0cy5sZXggPSBsZXg7XG5cdFxuXHRcblx0Ly8gZXhwb3J0IGRlZiB0b2tlbiB0eXAsIHZhbCwgbGluZSwgY29sLCBsZW4gZG8gVG9rZW4ubmV3KHR5cCx2YWwsbGluZSwgY29sIG9yIDAsIGxlbiBvciAwKSAjIFtudWxsLHR5cCx2YWwsbG9jXVxuXHRmdW5jdGlvbiB0b2tlbih0eXAsdmFsKXtcblx0XHRyZXR1cm4gbmV3IFRva2VuKHR5cCx2YWwsLTEsMCk7XG5cdH07IGV4cG9ydHMudG9rZW4gPSB0b2tlbjtcblx0XG5cdGZ1bmN0aW9uIHR5cCh0b2spe1xuXHRcdHJldHVybiB0b2suX3R5cGU7XG5cdH07IGV4cG9ydHMudHlwID0gdHlwO1xuXHRmdW5jdGlvbiB2YWwodG9rKXtcblx0XHRyZXR1cm4gdG9rLl92YWx1ZTtcblx0fTsgZXhwb3J0cy52YWwgPSB2YWw7IC8vIHRva1tvZmZzZXQgKyAxXVxuXHRmdW5jdGlvbiBsaW5lKHRvayl7XG5cdFx0cmV0dXJuIHRvay5fbGluZTtcblx0fTsgZXhwb3J0cy5saW5lID0gbGluZTsgLy8gdG9rW29mZnNldCArIDJdXG5cdGZ1bmN0aW9uIGxvYyh0b2spe1xuXHRcdHJldHVybiB0b2suX2xvYztcblx0fTsgZXhwb3J0cy5sb2MgPSBsb2M7IC8vIHRva1tvZmZzZXQgKyAyXVxuXHRcblx0ZnVuY3Rpb24gc2V0VHlwKHRvayx2KXtcblx0XHRyZXR1cm4gdG9rLl90eXBlID0gdjtcblx0fTsgZXhwb3J0cy5zZXRUeXAgPSBzZXRUeXA7XG5cdGZ1bmN0aW9uIHNldFZhbCh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fdmFsdWUgPSB2O1xuXHR9OyBleHBvcnRzLnNldFZhbCA9IHNldFZhbDtcblx0ZnVuY3Rpb24gc2V0TGluZSh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fbGluZSA9IHY7XG5cdH07IGV4cG9ydHMuc2V0TGluZSA9IHNldExpbmU7XG5cdGZ1bmN0aW9uIHNldExvYyh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fbG9jID0gdjtcblx0fTsgZXhwb3J0cy5zZXRMb2MgPSBzZXRMb2M7XG5cdFxuXHRcblx0bW9kdWxlLmV4cG9ydHMuTEJSQUNLRVQgPSBMQlJBQ0tFVCA9IG5ldyBUb2tlbigneycsJ3snLDAsMCwwKTtcblx0bW9kdWxlLmV4cG9ydHMuUkJSQUNLRVQgPSBSQlJBQ0tFVCA9IG5ldyBUb2tlbignfScsJ30nLDAsMCwwKTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLkxQQVJFTiA9IExQQVJFTiA9IG5ldyBUb2tlbignKCcsJygnLDAsMCwwKTtcblx0bW9kdWxlLmV4cG9ydHMuUlBBUkVOID0gUlBBUkVOID0gbmV3IFRva2VuKCcpJywnKScsMCwwLDApO1xuXHRcblx0TEJSQUNLRVQuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0UkJSQUNLRVQuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0TFBBUkVOLmdlbmVyYXRlZCA9IHRydWU7XG5cdFJQQVJFTi5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMuSU5ERU5UID0gSU5ERU5UID0gbmV3IFRva2VuKCdJTkRFTlQnLCcyJywwLDAsMCk7XG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cy5PVVRERU5UID0gT1VUREVOVCA9IG5ldyBUb2tlbignT1VUREVOVCcsJzInLDAsMCwwKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYVxuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHR2YXIgSU5WRVJTRVMsIExJTkVCUkVBS1M7XG5cdFxuXHQvLyBUaGUgSW1iYSBsYW5ndWFnZSBoYXMgYSBnb29kIGRlYWwgb2Ygb3B0aW9uYWwgc3ludGF4LCBpbXBsaWNpdCBzeW50YXgsXG5cdC8vIGFuZCBzaG9ydGhhbmQgc3ludGF4LiBUaGlzIGNhbiBncmVhdGx5IGNvbXBsaWNhdGUgYSBncmFtbWFyIGFuZCBibG9hdFxuXHQvLyB0aGUgcmVzdWx0aW5nIHBhcnNlIHRhYmxlLiBJbnN0ZWFkIG9mIG1ha2luZyB0aGUgcGFyc2VyIGhhbmRsZSBpdCBhbGwsIHdlIHRha2Vcblx0Ly8gYSBzZXJpZXMgb2YgcGFzc2VzIG92ZXIgdGhlIHRva2VuIHN0cmVhbSwgdXNpbmcgdGhpcyAqKlJld3JpdGVyKiogdG8gY29udmVydFxuXHQvLyBzaG9ydGhhbmQgaW50byB0aGUgdW5hbWJpZ3VvdXMgbG9uZyBmb3JtLCBhZGQgaW1wbGljaXQgaW5kZW50YXRpb24gYW5kXG5cdC8vIHBhcmVudGhlc2VzLCBhbmQgZ2VuZXJhbGx5IGNsZWFuIHRoaW5ncyB1cC5cblx0XG5cdHZhciBUID0gcmVxdWlyZSgnLi90b2tlbicpO1xuXHR2YXIgVG9rZW4gPSBULlRva2VuO1xuXHRcblx0Ly8gQmFzZWQgb24gdGhlIG9yaWdpbmFsIHJld3JpdGVyLmNvZmZlZSBmcm9tIENvZmZlZVNjcmlwdFxuXHRmdW5jdGlvbiBSZXdyaXRlcigpeyB9O1xuXHRcblx0ZXhwb3J0cy5SZXdyaXRlciA9IFJld3JpdGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFJld3JpdGVyLnByb3RvdHlwZS50b2tlbnMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdG9rZW5zO1xuXHR9O1xuXHRcblx0Ly8gSGVscGZ1bCBzbmlwcGV0IGZvciBkZWJ1Z2dpbmc6XG5cdC8vICAgICBjb25zb2xlLmxvZyAodFswXSArICcvJyArIHRbMV0gZm9yIHQgaW4gQHRva2Vucykuam9pbiAnICdcblx0Ly8gUmV3cml0ZSB0aGUgdG9rZW4gc3RyZWFtIGluIG11bHRpcGxlIHBhc3Nlcywgb25lIGxvZ2ljYWwgZmlsdGVyIGF0XG5cdC8vIGEgdGltZS4gVGhpcyBjb3VsZCBjZXJ0YWlubHkgYmUgY2hhbmdlZCBpbnRvIGEgc2luZ2xlIHBhc3MgdGhyb3VnaCB0aGVcblx0Ly8gc3RyZWFtLCB3aXRoIGEgYmlnIG9sJyBlZmZpY2llbnQgc3dpdGNoLCBidXQgaXQncyBtdWNoIG5pY2VyIHRvIHdvcmsgd2l0aFxuXHQvLyBsaWtlIHRoaXMuIFRoZSBvcmRlciBvZiB0aGVzZSBwYXNzZXMgbWF0dGVycyAtLSBpbmRlbnRhdGlvbiBtdXN0IGJlXG5cdC8vIGNvcnJlY3RlZCBiZWZvcmUgaW1wbGljaXQgcGFyZW50aGVzZXMgY2FuIGJlIHdyYXBwZWQgYXJvdW5kIGJsb2NrcyBvZiBjb2RlLlxuXHRSZXdyaXRlci5wcm90b3R5cGUucmV3cml0ZSA9IGZ1bmN0aW9uICh0b2tlbnMsb3B0cyl7XG5cdFx0dmFyIHRva2VuO1xuXHRcdGlmKG9wdHMgPT09IHVuZGVmaW5lZCkgb3B0cyA9IHt9O1xuXHRcdHRoaXMuX3Rva2VucyA9IHRva2Vucztcblx0XHR0aGlzLl9vcHRpb25zID0gb3B0cztcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyBcInRva2VucyBpbjogXCIgKyB0b2tlbnM6bGVuZ3RoXG5cdFx0aWYgKG9wdHMucHJvZmlsZSkgeyBjb25zb2xlLnRpbWUoXCJ0b2tlbml6ZTpyZXdyaXRlXCIpIH07XG5cdFx0XG5cdFx0dmFyIGkgPSAwO1xuXHRcdC8vIGZsYWcgZW1wdHkgbWV0aG9kc1xuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHR2YXIgbmV4dCA9IHRva2Vuc1tpICsgMV07XG5cdFx0XHRpZiAodG9rZW4uX3R5cGUgPT0gJ0RFRl9CT0RZJyAmJiBuZXh0ICYmIG5leHQuX3R5cGUgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdHRva2VuLl90eXBlID0gJ0RFRl9FTVBUWSc7XG5cdFx0XHR9O1xuXHRcdFx0aSsrO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5zdGVwKFwiZW5zdXJlRmlyc3RMaW5lXCIpO1xuXHRcdHRoaXMuc3RlcChcInJlbW92ZUxlYWRpbmdOZXdsaW5lc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJyZW1vdmVNaWRFeHByZXNzaW9uTmV3bGluZXNcIik7XG5cdFx0dGhpcy5zdGVwKFwidGFnRGVmQXJndW1lbnRzXCIpO1xuXHRcdHRoaXMuc3RlcChcImNsb3NlT3BlbkNhbGxzXCIpO1xuXHRcdHRoaXMuc3RlcChcImNsb3NlT3BlbkluZGV4ZXNcIik7XG5cdFx0dGhpcy5zdGVwKFwiY2xvc2VPcGVuVGFnc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJjbG9zZU9wZW5UYWdBdHRyTGlzdHNcIik7XG5cdFx0dGhpcy5zdGVwKFwiYWRkSW1wbGljaXRJbmRlbnRhdGlvblwiKTtcblx0XHR0aGlzLnN0ZXAoXCJ0YWdQb3N0Zml4Q29uZGl0aW9uYWxzXCIpO1xuXHRcdHRoaXMuc3RlcChcImFkZEltcGxpY2l0QnJhY2VzXCIpO1xuXHRcdHRoaXMuc3RlcChcImFkZEltcGxpY2l0UGFyZW50aGVzZXNcIik7XG5cdFx0XG5cdFx0aWYgKG9wdHMucHJvZmlsZSkgeyBjb25zb2xlLnRpbWVFbmQoXCJ0b2tlbml6ZTpyZXdyaXRlXCIpIH07XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJ0b2tlbnMgb3V0OiBcIiArIEB0b2tlbnM6bGVuZ3RoXG5cdFx0cmV0dXJuIHRoaXMuX3Rva2Vucztcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKGZuKXtcblx0XHRpZiAodGhpcy5fb3B0aW9ucy5wcm9maWxlKSB7XG5cdFx0XHRjb25zb2xlLmxvZygoXCItLS0tIHN0YXJ0aW5nIFwiICsgZm4gKyBcIiAtLS0tIFwiKSk7XG5cdFx0XHRjb25zb2xlLnRpbWUoZm4pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpc1tmbl0oKTtcblx0XHRcblx0XHRpZiAodGhpcy5fb3B0aW9ucy5wcm9maWxlKSB7XG5cdFx0XHRjb25zb2xlLnRpbWVFbmQoZm4pO1xuXHRcdFx0Y29uc29sZS5sb2coXCJcXG5cXG5cIik7XG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBSZXdyaXRlIHRoZSB0b2tlbiBzdHJlYW0sIGxvb2tpbmcgb25lIHRva2VuIGFoZWFkIGFuZCBiZWhpbmQuXG5cdC8vIEFsbG93IHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGJsb2NrIHRvIHRlbGwgdXMgaG93IG1hbnkgdG9rZW5zIHRvIG1vdmVcblx0Ly8gZm9yd2FyZHMgKG9yIGJhY2t3YXJkcykgaW4gdGhlIHN0cmVhbSwgdG8gbWFrZSBzdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmdcblx0Ly8gYXMgdG9rZW5zIGFyZSBpbnNlcnRlZCBhbmQgcmVtb3ZlZCwgYW5kIHRoZSBzdHJlYW0gY2hhbmdlcyBsZW5ndGggdW5kZXJcblx0Ly8gb3VyIGZlZXQuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5zY2FuVG9rZW5zID0gZnVuY3Rpb24gKGJsb2NrKXtcblx0XHR2YXIgdG9rZW47XG5cdFx0dmFyIHRva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHRcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdGkgKz0gYmxvY2suY2FsbCh0aGlzLHRva2VuLGksdG9rZW5zKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmRldGVjdEVuZCA9IGZ1bmN0aW9uIChpLGNvbmRpdGlvbixhY3Rpb24pe1xuXHRcdHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7XG5cdFx0dmFyIGxldmVscyA9IDA7XG5cdFx0dmFyIHN0YXJ0cyA9IFtdO1xuXHRcdHZhciB0b2tlbjtcblx0XHR2YXIgdCx2O1xuXHRcdFxuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHRpZiAobGV2ZWxzID09IDAgJiYgY29uZGl0aW9uLmNhbGwodGhpcyx0b2tlbixpLHN0YXJ0cykpIHtcblx0XHRcdFx0cmV0dXJuIGFjdGlvbi5jYWxsKHRoaXMsdG9rZW4saSk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCF0b2tlbiB8fCBsZXZlbHMgPCAwKSB7XG5cdFx0XHRcdHJldHVybiBhY3Rpb24uY2FsbCh0aGlzLHRva2VuLGkgLSAxKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHQgPSBULnR5cCh0b2tlbik7XG5cdFx0XHRcblx0XHRcdGlmIChFWFBSRVNTSU9OX1NUQVJULmluZGV4T2YodCkgPj0gMCkge1xuXHRcdFx0XHRpZiAobGV2ZWxzID09IDApIHsgc3RhcnRzLnB1c2goaSkgfTtcblx0XHRcdFx0bGV2ZWxzICs9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKEVYUFJFU1NJT05fRU5ELmluZGV4T2YodCkgPj0gMCkge1xuXHRcdFx0XHRsZXZlbHMgLT0gMTtcblx0XHRcdH07XG5cdFx0XHRpICs9IDE7XG5cdFx0fTtcblx0XHRyZXR1cm4gaSAtIDE7XG5cdH07XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUuZW5zdXJlRmlyc3RMaW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRvayA9IHRoaXMuX3Rva2Vuc1swXTtcblx0XHRcblx0XHRpZiAoVC50eXAodG9rKSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkaW5nIGJvZHlzdGFydFwiXG5cdFx0XHR0aGlzLl90b2tlbnMgPSBbVC50b2tlbignQk9EWVNUQVJUJywnQk9EWVNUQVJUJyldLmNvbmNhdCh0aGlzLl90b2tlbnMpO1xuXHRcdFx0Ly8gVC5zZXRUeXAodG9rLCdIRUFERVInKVxuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gTGVhZGluZyBuZXdsaW5lcyB3b3VsZCBpbnRyb2R1Y2UgYW4gYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyLCBzbyB3ZVxuXHQvLyBkaXNwYXRjaCB0aGVtIGhlcmUuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5yZW1vdmVMZWFkaW5nTmV3bGluZXMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYXQgPSAwO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl90b2tlbnMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChULnR5cChhcnlbaV0pICE9ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHRhdCA9IGk7YnJlYWs7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGF0KSB7IHRoaXMuX3Rva2Vucy5zcGxpY2UoMCxhdCkgfTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBTb21lIGJsb2NrcyBvY2N1ciBpbiB0aGUgbWlkZGxlIG9mIGV4cHJlc3Npb25zIC0tIHdoZW4gd2UncmUgZXhwZWN0aW5nXG5cdC8vIHRoaXMsIHJlbW92ZSB0aGVpciB0cmFpbGluZyBuZXdsaW5lcy5cblx0UmV3cml0ZXIucHJvdG90eXBlLnJlbW92ZU1pZEV4cHJlc3Npb25OZXdsaW5lcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGksdG9rZW5zKSB7IC8vIGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdHZhciBuZXh0ID0gc2VsZi50b2tlblR5cGUoaSArIDEpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIShULnR5cCh0b2tlbikgPT0gJ1RFUk1JTkFUT1InICYmIEVYUFJFU1NJT05fQ0xPU0UuaW5kZXhPZihuZXh0KSA+PSAwKSkgeyByZXR1cm4gMSB9O1xuXHRcdFx0aWYgKG5leHQgPT0gJ09VVERFTlQnKSB7IHJldHVybiAxIH07XG5cdFx0XHR0b2tlbnMuc3BsaWNlKGksMSk7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9KTtcblx0fTtcblx0XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUudGFnRGVmQXJndW1lbnRzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvLyBUaGUgbGV4ZXIgaGFzIHRhZ2dlZCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvZiBhIG1ldGhvZCBjYWxsLiBNYXRjaCBpdCB3aXRoXG5cdC8vIGl0cyBwYWlyZWQgY2xvc2UuIFdlIGhhdmUgdGhlIG1pcy1uZXN0ZWQgb3V0ZGVudCBjYXNlIGluY2x1ZGVkIGhlcmUgZm9yXG5cdC8vIGNhbGxzIHRoYXQgY2xvc2Ugb24gdGhlIHNhbWUgbGluZSwganVzdCBiZWZvcmUgdGhlaXIgb3V0ZGVudC5cblx0UmV3cml0ZXIucHJvdG90eXBlLmNsb3NlT3BlbkNhbGxzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHR2YXIgdCA9IFQudHlwKHRva2VuKTtcblx0XHRcdHJldHVybiAodCA9PSAnKScgfHwgdCA9PSAnQ0FMTF9FTkQnKSB8fCB0ID09ICdPVVRERU5UJyAmJiBzZWxmLnRva2VuVHlwZShpIC0gMSkgPT0gJyknO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHZhciB0ID0gVC50eXAodG9rZW4pO1xuXHRcdFx0dmFyIHRvayA9IHNlbGYuX3Rva2Vuc1t0ID09ICdPVVRERU5UJyA/IChpIC0gMSkgOiAoaSldO1xuXHRcdFx0cmV0dXJuIFQuc2V0VHlwKHRvaywnQ0FMTF9FTkQnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0aWYgKFQudHlwKHRva2VuKSA9PSAnQ0FMTF9TVEFSVCcpIHsgc2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGFjdGlvbikgfTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0Ly8gVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYW4gaW5kZXhpbmcgb3BlcmF0aW9uIGNhbGwuXG5cdC8vIE1hdGNoIGl0IHdpdGggaXRzIHBhaXJlZCBjbG9zZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLmNsb3NlT3BlbkluZGV4ZXMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIGlkeCQoVC50eXAodG9rZW4pLFsnXScsJ0lOREVYX0VORCddKSA+PSAwOyB9O1xuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBULnNldFR5cCh0b2tlbiwnSU5ERVhfRU5EJyk7IH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRpZiAoVC50eXAodG9rZW4pID09ICdJTkRFWF9TVEFSVCcpIHsgc2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGFjdGlvbikgfTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5jbG9zZU9wZW5UYWdBdHRyTGlzdHMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIGlkeCQoVC50eXAodG9rZW4pLFsnKScsJ1RBR19BVFRSU19FTkQnXSkgPj0gMDsgfTtcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gVC5zZXRUeXAodG9rZW4sJ1RBR19BVFRSU19FTkQnKTsgfTsgLy8gJ1RBR19BVFRSU19FTkQnXG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRpZiAoVC50eXAodG9rZW4pID09ICdUQUdfQVRUUlNfU1RBUlQnKSB7IHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmRpdGlvbixhY3Rpb24pIH07XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdC8vIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGFuIGluZGV4aW5nIG9wZXJhdGlvbiBjYWxsLlxuXHQvLyBNYXRjaCBpdCB3aXRoIGl0cyBwYWlyZWQgY2xvc2UuIFNob3VsZCBiZSBkb25lIGluIGxleGVyIGRpcmVjdGx5XG5cdFJld3JpdGVyLnByb3RvdHlwZS5jbG9zZU9wZW5UYWdzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBpZHgkKFQudHlwKHRva2VuKSxbJz4nLCdUQUdfRU5EJ10pID49IDA7IH07XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIFQuc2V0VHlwKHRva2VuLCdUQUdfRU5EJyk7IH07IC8vIHRva2VuWzBdID0gJ1RBR19FTkQnXG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRpZiAoVC50eXAodG9rZW4pID09ICdUQUdfU1RBUlQnKSB7IHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmRpdGlvbixhY3Rpb24pIH07XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdENvbW1hcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdEJsb2NrQ2FsbHMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rZW47XG5cdFx0dmFyIGkgPSAxO1xuXHRcdHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7XG5cdFx0XG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdHZhciB0ID0gdG9rZW4uX3R5cGU7XG5cdFx0XHR2YXIgdiA9IHRva2VuLl92YWx1ZTtcblx0XHRcdC8vIGhtbVxuXHRcdFx0aWYgKHQgPT0gJ0RPJyAmJiAodiA9PSAnSU5ERVhfRU5EJyB8fCB2ID09ICdJREVOVElGSUVSJyB8fCB2ID09ICdORVcnKSkge1xuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGkgKyAxLDAsVC50b2tlbignQ0FMTF9FTkQnLCcpJykpO1xuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGkgKyAxLDAsVC50b2tlbignQ0FMTF9TVEFSVCcsJygnKSk7XG5cdFx0XHRcdGkrKztcblx0XHRcdH07XG5cdFx0XHRpKys7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBPYmplY3QgbGl0ZXJhbHMgbWF5IGJlIHdyaXR0ZW4gd2l0aCBpbXBsaWNpdCBicmFjZXMsIGZvciBzaW1wbGUgY2FzZXMuXG5cdC8vIEluc2VydCB0aGUgbWlzc2luZyBicmFjZXMgaGVyZSwgc28gdGhhdCB0aGUgcGFyc2VyIGRvZXNuJ3QgaGF2ZSB0by5cblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0QnJhY2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciBzdGFydCA9IG51bGw7XG5cdFx0dmFyIHN0YXJ0SW5kZW50ID0gMDtcblx0XHR2YXIgc3RhcnRJZHggPSBudWxsO1xuXHRcdFxuXHRcdHZhciBub0JyYWNlVGFnID0gWydDTEFTUycsJ0lGJywnVU5MRVNTJywnVEFHJywnV0hJTEUnLCdGT1InLCdVTlRJTCcsJ0NBVENIJywnRklOQUxMWScsJ01PRFVMRScsJ0xFQURJTkdfV0hFTiddO1xuXHRcdHZhciBub0JyYWNlQ29udGV4dCA9IFsnSUYnLCdURVJOQVJZJywnRk9SJ107XG5cdFx0XG5cdFx0dmFyIG5vQnJhY2UgPSBmYWxzZTtcblx0XHRcblx0XHR2YXIgc2NvcGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSB8fCBbXTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdG9rZW5zLnNwbGljZShpLDAsVC5SQlJBQ0tFVCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgb3BlbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHJldHVybiBzZWxmLl90b2tlbnMuc3BsaWNlKGksMCxULkxCUkFDS0VUKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBjbG9zZSA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHJldHVybiBzZWxmLl90b2tlbnMuc3BsaWNlKGksMCxULlJCUkFDS0VUKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBzdGFja1Rva2VuID0gZnVuY3Rpb24oYSxiKSB7XG5cdFx0XHRyZXR1cm4gW2EsYl07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGksdG9rZW5zKSB7XG5cdFx0XHR2YXIgdHlwZSA9IFQudHlwKHRva2VuKTtcblx0XHRcdHZhciB2ID0gVC52YWwodG9rZW4pO1xuXHRcdFx0dmFyIGN0eCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdIHx8IFtdO1xuXHRcdFx0dmFyIGlkeDtcblx0XHRcdFxuXHRcdFx0aWYgKG5vQnJhY2VDb250ZXh0LmluZGV4T2YodHlwZSkgPj0gMCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImZvdW5kIG5vQnJhY2VUYWcge3R5cGV9XCJcblx0XHRcdFx0c3RhY2sucHVzaChzdGFja1Rva2VuKHR5cGUsaSkpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh2ID09ICc/Jykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnVEVSTkFSWSBPUEVSQVRPUiEnKVxuXHRcdFx0XHRzdGFjay5wdXNoKHN0YWNrVG9rZW4oJ1RFUk5BUlknLGkpKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBubyBuZWVkIHRvIHRlc3QgZm9yIHRoaXMgaGVyZSBhcyB3ZWxsIGFzIGluXG5cdFx0XHRpZiAoRVhQUkVTU0lPTl9TVEFSVC5pbmRleE9mKHR5cGUpID49IDApIHtcblx0XHRcdFx0aWYgKHR5cGUgPT0gJ0lOREVOVCcgJiYgbm9CcmFjZUNvbnRleHQuaW5kZXhPZihjdHhbMF0pID49IDApIHtcblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdleHByZXNzaW9uIHN0YXJ0Jyx0eXBlLGN0eFswXSlcblx0XHRcdFx0aWYgKHR5cGUgPT0gJ0lOREVOVCcgJiYgc2VsZi50b2tlblR5cGUoaSAtIDEpID09ICd7Jykge1xuXHRcdFx0XHRcdC8vIHN0YWNrID8hPyBubyB0b2tlblxuXHRcdFx0XHRcdHN0YWNrLnB1c2goc3RhY2tUb2tlbigneycsaSkpOyAvLyBzaG91bGQgbm90IGF1dG9nZW5lcmF0ZSBhbm90aGVyP1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YWNrLnB1c2goc3RhY2tUb2tlbih0eXBlLGkpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoRVhQUkVTU0lPTl9FTkQuaW5kZXhPZih0eXBlKSA+PSAwKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiRVhQUkVTU0lPTl9FTkQgYXQge3R5cGV9IC0gc3RhY2sgaXMge2N0eFswXX1cIlxuXHRcdFx0XHRpZiAoY3R4WzBdID09ICdURVJOQVJZJykgeyAvLyBGSVg/XG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGFydCA9IHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRpZiAoIXN0YXJ0KSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJOTyBTVEFDSyEhXCIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRzdGFydFsyXSA9IGk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBzZWVtcyBsaWtlIHRoZSBzdGFjayBzaG91bGQgdXNlIHRva2Vucywgbm8/KVxuXHRcdFx0XHRpZiAoc3RhcnRbMF0gPT0gJ3snICYmIHN0YXJ0LmdlbmVyYXRlZCkgeyAvLyAgIyB0eXBlICE9ICd9JyAjIGFuZCBzdGFydDpnZW5lcmF0ZWRcblx0XHRcdFx0XHRjbG9zZSh0b2tlbixpKTtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gaXMgdGhpcyBjb3JyZWN0PyBzYW1lIGZvciBpZi9jbGFzcyBldGM/XG5cdFx0XHRpZiAoY3R4WzBdID09ICdURVJOQVJZJyAmJiAodHlwZSA9PSAnVEVSTUlOQVRPUicgfHwgdHlwZSA9PSAnT1VUREVOVCcpKSB7XG5cdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPj0gMCAmJiB0eXBlID09ICdJTkRFTlQnKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwicG9wcGluZyBub0JyYWNlQ29udGV4dFwiKTtcblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnLCcpIHtcblx0XHRcdFx0Ly8gYXV0b21hdGljYWxseSBhZGQgYW4gZW5kaW5nIGhlcmUgaWYgaW5zaWRlOmdlbmVyYXRlZCBzY29wZT9cblx0XHRcdFx0Ly8gaXQgaXMgaW1wb3J0YW50IHRoYXQgdGhpcyBpczpnZW5lcmF0ZWQoISlcblx0XHRcdFx0aWYgKGN0eFswXSA9PSAneycgJiYgY3R4LmdlbmVyYXRlZCkge1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwwLFQuUkJSQUNLRVQpO1xuXHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0cnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gZm91bmQgYSB0eXBlXG5cdFx0XHRpZiAodHlwZSA9PSAnOicgJiYgY3R4WzBdICE9ICd7JyAmJiBjdHhbMF0gIT0gJ1RFUk5BUlknICYmIChub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPT0gLTEpKSB7XG5cdFx0XHRcdC8vIGNvdWxkIGp1c3QgY2hlY2sgaWYgdGhlIGVuZCB3YXMgcmlnaHQgYmVmb3JlIHRoaXM/XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3RhcnQgJiYgc3RhcnRbMl0gPT0gaSAtIDEpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygndGhpcyBleHByZXNzaW9uIHdhcyBqdXN0IGVuZGluZyBiZWZvcmUgY29sb24hJylcblx0XHRcdFx0XHRpZHggPSBzdGFydFsxXSAtIDE7IC8vIHRoZXNlIGFyZSB0aGUgc3RhY2tUb2tlbnNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcInJld3JpdGUgaGVyZT8gI3tpfVwiXG5cdFx0XHRcdFx0aWR4ID0gaSAtIDI7IC8vIGlmIHN0YXJ0IHRoZW4gc3RhcnRbMV0gLSAxIGVsc2UgaSAtIDJcblx0XHRcdFx0XHQvLyBpZHggPSBpZHggLSAxIGlmIHRva2VuVHlwZShpZHgpIGlzICdURVJNSU5BVE9SJ1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHNlbGYudG9rZW5UeXBlKGlkeCAtIDEpID09ICdIRVJFQ09NTUVOVCcpe1xuXHRcdFx0XHRcdGlkeCAtPSAyO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHQwID0gdG9rZW5zW2lkeCAtIDFdO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHQwICYmIFQudHlwKHQwKSA9PSAnfScgJiYgdDAuZ2VuZXJhdGVkKSB7XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpZHggLSAxLDEpO1xuXHRcdFx0XHRcdHZhciBzID0gc3RhY2tUb2tlbigneycpO1xuXHRcdFx0XHRcdHMuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHMpO1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQwICYmIFQudHlwKHQwKSA9PSAnLCcgJiYgc2VsZi50b2tlblR5cGUoaWR4IC0gMikgPT0gJ30nKSB7XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpZHggLSAyLDEpO1xuXHRcdFx0XHRcdHMgPSBzdGFja1Rva2VuKCd7Jyk7XG5cdFx0XHRcdFx0cy5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHN0YWNrLnB1c2gocyk7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cyA9IHN0YWNrVG9rZW4oJ3snKTtcblx0XHRcdFx0XHRzLmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChzKTtcblx0XHRcdFx0XHRvcGVuKHRva2VuLGlkeCArIDEpO1xuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gd2UgcHJvYmFibHkgbmVlZCB0byBydW4gdGhyb3VnaCBhdXRvY2FsbCBmaXJzdD8hXG5cdFx0XHRcblx0XHRcdGlmICh0eXBlID09ICdETycpIHsgLy8gYW5kIGN0eDpnZW5lcmF0ZWRcblx0XHRcdFx0dmFyIHByZXYgPSBULnR5cCh0b2tlbnNbaSAtIDFdKTsgLy8gWzBdXG5cdFx0XHRcdGlmIChbJ05VTUJFUicsJ1NUUklORycsJ1JFR0VYJywnU1lNQk9MJywnXScsJ30nLCcpJywnU1RSSU5HX0VORCddLmluZGV4T2YocHJldikgPj0gMCkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciB0b2sgPSBULnRva2VuKCcsJywnLCcpO1xuXHRcdFx0XHRcdHRvay5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwwLHRvayk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGN0eC5nZW5lcmF0ZWQpIHtcblx0XHRcdFx0XHRcdGNsb3NlKHRva2VuLGkpO1xuXHRcdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKCh0eXBlID09ICdURVJNSU5BVE9SJyB8fCB0eXBlID09ICdPVVRERU5UJyB8fCB0eXBlID09ICdERUZfQk9EWScpICYmIGN0eC5nZW5lcmF0ZWQpIHtcblx0XHRcdFx0Y2xvc2UodG9rZW4saSk7XG5cdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0Ly8gTWV0aG9kcyBtYXkgYmUgb3B0aW9uYWxseSBjYWxsZWQgd2l0aG91dCBwYXJlbnRoZXNlcywgZm9yIHNpbXBsZSBjYXNlcy5cblx0Ly8gSW5zZXJ0IHRoZSBpbXBsaWNpdCBwYXJlbnRoZXNlcyBoZXJlLCBzbyB0aGF0IHRoZSBwYXJzZXIgZG9lc24ndCBoYXZlIHRvXG5cdC8vIGRlYWwgd2l0aCB0aGVtLlxuXHQvLyBQcmFjdGljYWxseSBldmVyeXRoaW5nIHdpbGwgbm93IGJlIGNhbGxhYmxlIHRoaXMgd2F5IChldmVyeSBpZGVudGlmaWVyKVxuXHRSZXdyaXRlci5wcm90b3R5cGUuYWRkSW1wbGljaXRQYXJlbnRoZXNlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdHZhciBzZWxmID0gdGhpcywgdG9rZW47XG5cdFx0dmFyIG5vQ2FsbFRhZyA9IFsnQ0xBU1MnLCdJRicsJ1VOTEVTUycsJ1RBRycsJ1dISUxFJywnRk9SJywnVU5USUwnLCdDQVRDSCcsJ0ZJTkFMTFknLCdNT0RVTEUnLCdMRUFESU5HX1dIRU4nXTtcblx0XHRcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0cmV0dXJuIHNlbGYuX3Rva2Vucy5zcGxpY2UoaSwwLFQudG9rZW4oJ0NBTExfRU5EJywnKScpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkaW5nIGltcGxpY2l0IHBhcmVudGhlc2lzXCIgIyAsc2VsZjpzY2FuVG9rZW5zXG5cdFx0dmFyIHRva2VucyA9IHNlbGYuX3Rva2Vucztcblx0XHRcblx0XHR2YXIgbm9DYWxsID0gZmFsc2U7XG5cdFx0dmFyIHNlZW5Gb3IgPSBmYWxzZTtcblx0XHR2YXIgZW5kQ2FsbEF0VGVybWluYXRvciA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBpID0gMDtcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0XG5cdFx0XHQvLyB0byBoYW5kbGUgY2FzZXMgbGlrZTpcblx0XHRcdC8vIGlmIGEoZG8geWVzKS50ZXN0XG5cdFx0XHQvLyBcdHllc1xuXHRcdFx0Ly8gd2UgbmVlZCB0byBrZWVwIGEgc3RhY2sgZm9yIGJhbGFuY2VkIHBhaXJzXG5cdFx0XHQvLyB1bnRpbCB0aGVuIHlvdSBtdXN0IGV4cGxpY2l0bHkgZW5kIHRoZSBjYWxsIGxpa2Vcblx0XHRcdC8vIGlmIGEoZG8geWVzKS50ZXN0KClcblx0XHRcdC8vIFx0eWVzXG5cdFx0XHRcblx0XHRcdHZhciB0eXBlID0gdG9rZW4uX3R5cGU7XG5cdFx0XHRcblx0XHRcdHZhciBwcmV2ID0gdG9rZW5zW2kgLSAxXTtcblx0XHRcdHZhciBjdXJyZW50ID0gdG9rZW5zW2ldO1xuXHRcdFx0dmFyIG5leHQgPSB0b2tlbnNbaSArIDFdO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHQgPSBwcmV2ICYmIHByZXYuX3R5cGU7XG5cdFx0XHR2YXIgbnQgPSBuZXh0ICYmIG5leHQuX3R5cGU7XG5cdFx0XHRcblx0XHRcdC8vIGlmIHB0ID09ICdXSEVOJ1xuXHRcdFx0Ly8gTmV2ZXIgbWFrZSB0aGVzZSB0YWdzIGltcGxpY2l0bHkgY2FsbFxuXHRcdFx0Ly8gc2hvdWxkIHdlIG5vdCBqdXN0IHJlbW92ZSB0aGVzZSBmcm9tIElNUExJQ0lUX0ZVTkM/XG5cdFx0XHRpZiAoKHB0ID09ICcpJyB8fCBwdCA9PSAnXScpICYmIHR5cGUgPT0gJ0lOREVOVCcpIHtcblx0XHRcdFx0bm9DYWxsID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChub0NhbGxUYWcuaW5kZXhPZihwdCkgPj0gMCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInNlZW4gbm9jYWxsIHRhZyB7cHR9ICh7cHR9IHt0eXBlfSB7bnR9KVwiKVxuXHRcdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0gdHJ1ZTtcblx0XHRcdFx0bm9DYWxsID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHB0ID09ICdGT1InKSB7IHNlZW5Gb3IgPSB0cnVlIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHZhciBjYWxsT2JqZWN0ID0gZmFsc2U7XG5cdFx0XHR2YXIgY2FsbEluZGVudCA9IGZhbHNlO1xuXHRcdFx0XG5cdFx0XHQvLyBbcHJldiwgY3VycmVudCwgbmV4dF0gPSB0b2tlbnNbaSAtIDEgLi4gaSArIDFdXG5cdFx0XHRcblx0XHRcdC8vIGNoZWNrIGZvciBjb21tZW50c1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJkZXRlY3QgZW5kPz9cIlxuXHRcdFx0aWYgKCFub0NhbGwgJiYgdHlwZSA9PSAnSU5ERU5UJyAmJiBuZXh0KSB7XG5cdFx0XHRcdHZhciBwcmV2SW1wRnVuYyA9IHB0ICYmIElNUExJQ0lUX0ZVTkMuaW5kZXhPZihwdCkgPj0gMDtcblx0XHRcdFx0dmFyIG5leHRJbXBDYWxsID0gbnQgJiYgSU1QTElDSVRfQ0FMTC5pbmRleE9mKG50KSA+PSAwO1xuXHRcdFx0XHRjYWxsT2JqZWN0ID0gKChuZXh0LmdlbmVyYXRlZCAmJiBudCA9PSAneycpIHx8IG5leHRJbXBDYWxsKSAmJiBwcmV2SW1wRnVuYztcblx0XHRcdFx0Y2FsbEluZGVudCA9IG5leHRJbXBDYWxsICYmIHByZXZJbXBGdW5jO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHNlZW5TaW5nbGUgPSBmYWxzZTtcblx0XHRcdHZhciBzZWVuQ29udHJvbCA9IGZhbHNlO1xuXHRcdFx0Ly8gSG1tID9cblx0XHRcdFxuXHRcdFx0Ly8gdGhpcyBpcyBub3QgY29ycmVjdCBpZiB0aGlzIGlzIGluc2lkZSBhIGJsb2NrLG5vP1xuXHRcdFx0aWYgKCh0eXBlID09ICdURVJNSU5BVE9SJyB8fCB0eXBlID09ICdPVVRERU5UJyB8fCB0eXBlID09ICdJTkRFTlQnKSkge1xuXHRcdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0gZmFsc2U7XG5cdFx0XHRcdG5vQ2FsbCA9IGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGUgPT0gJz8nICYmIHByZXYgJiYgIXByZXYuc3BhY2VkKSB7IHRva2VuLmNhbGwgPSB0cnVlIH07XG5cdFx0XHRcblx0XHRcdC8vIHdoZXJlIGRvZXMgZnJvbVRoZW0gY29tZSBmcm9tP1xuXHRcdFx0aWYgKHRva2VuLmZyb21UaGVuKSB7XG5cdFx0XHRcdGkgKz0gMTtjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHQvLyBoZXJlIHdlIGRlYWwgd2l0aCA6c3BhY2VkIGFuZCA6bmV3TGluZVxuXHRcdFx0aWYgKCEoY2FsbE9iamVjdCB8fCBjYWxsSW5kZW50IHx8IChwcmV2ICYmIHByZXYuc3BhY2VkKSAmJiAocHJldi5jYWxsIHx8IElNUExJQ0lUX0ZVTkMuaW5kZXhPZihwdCkgPj0gMCkgJiYgKElNUExJQ0lUX0NBTEwuaW5kZXhPZih0eXBlKSA+PSAwIHx8ICEodG9rZW4uc3BhY2VkIHx8IHRva2VuLm5ld0xpbmUpICYmIElNUExJQ0lUX1VOU1BBQ0VEX0NBTEwuaW5kZXhPZih0eXBlKSA+PSAwKSkpIHtcblx0XHRcdFx0aSArPSAxO2NvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHR0b2tlbnMuc3BsaWNlKGksMCxULnRva2VuKCdDQUxMX1NUQVJUJywnKCcpKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkZWQgKCB7cHJldn1cIlxuXHRcdFx0dmFyIGNvbmQgPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gVC50eXAodG9rZW4pO1xuXHRcdFx0XHRpZiAoIXNlZW5TaW5nbGUgJiYgdG9rZW4uZnJvbVRoZW4pIHsgcmV0dXJuIHRydWUgfTtcblx0XHRcdFx0dmFyIGlmZWxzZSA9IHR5cGUgPT0gJ0lGJyB8fCB0eXBlID09ICdVTkxFU1MnIHx8IHR5cGUgPT0gJ0VMU0UnO1xuXHRcdFx0XHRpZiAoaWZlbHNlIHx8IHR5cGUgPT0gJ0NBVENIJykgeyBzZWVuU2luZ2xlID0gdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoaWZlbHNlIHx8IHR5cGUgPT0gJ1NXSVRDSCcgfHwgdHlwZSA9PSAnVFJZJykgeyBzZWVuQ29udHJvbCA9IHRydWUgfTtcblx0XHRcdFx0dmFyIHByZXYgPSBzZWxmLnRva2VuVHlwZShpIC0gMSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoKHR5cGUgPT0gJy4nIHx8IHR5cGUgPT0gJz8uJyB8fCB0eXBlID09ICc6OicpICYmIHByZXYgPT0gJ09VVERFTlQnKSB7IHJldHVybiB0cnVlIH07XG5cdFx0XHRcdGlmIChlbmRDYWxsQXRUZXJtaW5hdG9yICYmICh0eXBlID09ICdJTkRFTlQnIHx8IHR5cGUgPT0gJ1RFUk1JTkFUT1InKSkgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoKHR5cGUgPT0gJ1dIRU4nIHx8IHR5cGUgPT0gJ0JZJykgJiYgIXNlZW5Gb3IpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImRvbnQgY2xvc2UgaW1wbGljaXQgY2FsbCBvdXRzaWRlIGZvclwiXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHBvc3QgPSB0b2tlbnNbaSArIDFdO1xuXHRcdFx0XHR2YXIgcG9zdFR5cCA9IHBvc3QgJiYgVC50eXAocG9zdCk7XG5cdFx0XHRcdC8vIFdURlxuXHRcdFx0XHRyZXR1cm4gIXRva2VuLmdlbmVyYXRlZCAmJiBwcmV2ICE9ICcsJyAmJiAoSU1QTElDSVRfRU5ELmluZGV4T2YodHlwZSkgPj0gMCB8fCAodHlwZSA9PSAnSU5ERU5UJyAmJiAhc2VlbkNvbnRyb2wpIHx8ICh0eXBlID09ICdET1MnICYmIHByZXYgIT0gJz0nKSkgJiYgKHR5cGUgIT0gJ0lOREVOVCcgfHwgKHNlbGYudG9rZW5UeXBlKGkgLSAyKSAhPSAnQ0xBU1MnICYmIElNUExJQ0lUX0JMT0NLLmluZGV4T2YocHJldikgPT0gLTEgJiYgIShwb3N0ICYmICgocG9zdC5nZW5lcmF0ZWQgJiYgcG9zdFR5cCA9PSAneycpIHx8IElNUExJQ0lUX0NBTEwuaW5kZXhPZihwb3N0VHlwKSA+PSAwKSkpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBhY3Rpb24gZm9yIGRldGVjdGluZyB3aGVuIHRoZSBjYWxsIHNob3VsZCBlbmRcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZGV0ZWN0IGVuZD8/XCJcblx0XHRcdHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmQsYWN0aW9uKTtcblx0XHRcdGlmIChULnR5cChwcmV2KSA9PSAnPycpIHsgVC5zZXRUeXAocHJldiwnRlVOQ19FWElTVCcpIH07XG5cdFx0XHRpICs9IDI7XG5cdFx0XHQvLyBuZWVkIHRvIHJlc2V0IGFmdGVyIGEgbWF0Y2hcblx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSBmYWxzZTtcblx0XHRcdG5vQ2FsbCA9IGZhbHNlO1xuXHRcdFx0c2VlbkZvciA9IGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gQmVjYXVzZSBvdXIgZ3JhbW1hciBpcyBMQUxSKDEpLCBpdCBjYW4ndCBoYW5kbGUgc29tZSBzaW5nbGUtbGluZVxuXHQvLyBleHByZXNzaW9ucyB0aGF0IGxhY2sgZW5kaW5nIGRlbGltaXRlcnMuIFRoZSAqKlJld3JpdGVyKiogYWRkcyB0aGUgaW1wbGljaXRcblx0Ly8gYmxvY2tzLCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8uICcpJyBjYW4gY2xvc2UgYSBzaW5nbGUtbGluZSBibG9jayxcblx0Ly8gYnV0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgYmFsYW5jZWQuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdEluZGVudGF0aW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0XG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCB0b2tlbjtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHRva2VucyA9IHNlbGYuX3Rva2Vucztcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0dmFyIHR5cGUgPSBULnR5cCh0b2tlbik7XG5cdFx0XHR2YXIgbmV4dCA9IHNlbGYudG9rZW5UeXBlKGkgKyAxKTtcblx0XHRcdFxuXHRcdFx0Ly8gd2h5IGFyZSB3ZSByZW1vdmluZyB0ZXJtaW5hdG9ycyBhZnRlciB0aGVuPyBzaG91bGQgYmUgYWJsZSB0byBoYW5kbGVcblx0XHRcdGlmICh0eXBlID09ICdURVJNSU5BVE9SJyAmJiBuZXh0ID09ICdUSEVOJykge1xuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksMSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGUgPT0gJ0NBVENIJyAmJiBpZHgkKHNlbGYudG9rZW5UeXBlKGkgKyAyKSxbJ09VVERFTlQnLCdURVJNSU5BVE9SJywnRklOQUxMWSddKSA+PSAwKSB7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UuYXBwbHkodG9rZW5zLFtdLmNvbmNhdChbaSArIDIsMF0sIFtdLnNsaWNlLmNhbGwoc2VsZi5pbmRlbnRhdGlvbih0b2tlbikpKSk7XG5cdFx0XHRcdGkgKz0gNDtjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChTSU5HTEVfTElORVJTLmluZGV4T2YodHlwZSkgPj0gMCAmJiAobmV4dCAhPSAnSU5ERU5UJyAmJiBuZXh0ICE9ICdCTE9DS19QQVJBTV9TVEFSVCcpICYmICEodHlwZSA9PSAnRUxTRScgJiYgbmV4dCA9PSAnSUYnKSAmJiB0eXBlICE9ICdFTElGJykge1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHN0YXJ0ZXIgPSB0eXBlO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGluZGVudCA9IFQudG9rZW4oJ0lOREVOVCcsJzInKTtcblx0XHRcdFx0dmFyIG91dGRlbnQgPSBULk9VVERFTlQ7XG5cdFx0XHRcdC8vIHZhciBpbmRlbnQsIG91dGRlbnQgPSBpbmRlbnRhdGlvbih0b2tlbilcblx0XHRcdFx0aWYgKHN0YXJ0ZXIgPT0gJ1RIRU4nKSB7IGluZGVudC5mcm9tVGhlbiA9IHRydWUgfTsgLy8gc2V0dGluZyBzcGVjaWFsIHZhbHVlcyBmb3IgdGhlc2UgLS0gY2Fubm90IHJlYWxseSByZXVzZT9cblx0XHRcdFx0aW5kZW50LmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdC8vIG91dGRlbnQ6Z2VuZXJhdGVkID0gdHJ1ZVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGkgKyAxLDAsaW5kZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSBULnR5cCh0b2tlbik7XG5cdFx0XHRcdFx0cmV0dXJuIFQudmFsKHRva2VuKSAhPSAnOycgJiYgU0lOR0xFX0NMT1NFUlMuaW5kZXhPZih0KSA+PSAwICYmICEodCA9PSAnRUxTRScgJiYgc3RhcnRlciAhPSAnSUYnICYmIHN0YXJ0ZXIgIT0gJ1RIRU4nKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRcdFx0dmFyIGlkeCA9IHNlbGYudG9rZW5UeXBlKGkgLSAxKSA9PSAnLCcgPyAoaSAtIDEpIDogKGkpO1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMuc3BsaWNlKGlkeCwwLG91dGRlbnQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0c2VsZi5kZXRlY3RFbmQoaSArIDIsY29uZGl0aW9uLGFjdGlvbik7XG5cdFx0XHRcdGlmICh0eXBlID09ICdUSEVOJykgeyB0b2tlbnMuc3BsaWNlKGksMSkgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGkrKztcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIFRhZyBwb3N0Zml4IGNvbmRpdGlvbmFscyBhcyBzdWNoLCBzbyB0aGF0IHdlIGNhbiBwYXJzZSB0aGVtIHdpdGggYVxuXHQvLyBkaWZmZXJlbnQgcHJlY2VkZW5jZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLnRhZ1Bvc3RmaXhDb25kaXRpb25hbHMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIGlkeCQoVC50eXAodG9rZW4pLFsnVEVSTUlOQVRPUicsJ0lOREVOVCddKSA+PSAwOyB9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0dmFyIHR5cCA9IFQudHlwKHRva2VuKTtcblx0XHRcdGlmICghKHR5cCA9PSAnSUYnIHx8IHR5cCA9PSAnRk9SJykpIHsgcmV0dXJuIDEgfTtcblx0XHRcdHZhciBvcmlnaW5hbCA9IHRva2VuO1xuXHRcdFx0c2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdFx0aWYgKFQudHlwKHRva2VuKSAhPSAnSU5ERU5UJykgeyByZXR1cm4gVC5zZXRUeXAob3JpZ2luYWwsJ1BPU1RfJyArIFQudHlwKG9yaWdpbmFsKSkgfTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQvLyBHZW5lcmF0ZSB0aGUgaW5kZW50YXRpb24gdG9rZW5zLCBiYXNlZCBvbiBhbm90aGVyIHRva2VuIG9uIHRoZSBzYW1lIGxpbmUuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICh0b2tlbil7XG5cdFx0cmV0dXJuIFtULnRva2VuKCdJTkRFTlQnLCcyJyksVC50b2tlbignT1VUREVOVCcsJzInKV07XG5cdH07XG5cdFxuXHQvLyBMb29rIHVwIGEgdHlwZSBieSB0b2tlbiBpbmRleC5cblx0UmV3cml0ZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoaSl7XG5cdFx0Ly8gaWYgaSA8IDAgdGhlbiByZXR1cm4gbnVsbFxuXHRcdHZhciB0b2sgPSB0aGlzLl90b2tlbnNbaV07XG5cdFx0cmV0dXJuIHRvayAmJiBULnR5cCh0b2spO1xuXHRcdC8vIGlmIHRvayB0aGVuIHRva1swXSBlbHNlIG51bGxcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS50b2tlblR5cGUgPSBmdW5jdGlvbiAoaSl7XG5cdFx0dmFyIHRvayA9IHRoaXMuX3Rva2Vuc1tpXTtcblx0XHRyZXR1cm4gdG9rICYmIFQudHlwKHRvayk7XG5cdFx0Ly8gcmV0dXJuIHRvayBhbmQgdG9rWzBdXG5cdH07XG5cdFxuXHQvLyBDb25zdGFudHNcblx0Ly8gLS0tLS0tLS0tXG5cdFxuXHQvLyBMaXN0IG9mIHRoZSB0b2tlbiBwYWlycyB0aGF0IG11c3QgYmUgYmFsYW5jZWQuXG5cdHZhciBCQUxBTkNFRF9QQUlSUyA9IFtcblx0XHRbJygnLCcpJ10sXG5cdFx0WydbJywnXSddLFxuXHRcdFsneycsJ30nXSxcblx0XHRbJ3t7JywnfX0nXSxcblx0XHRbJ0lOREVOVCcsJ09VVERFTlQnXSxcblx0XHRbJ0NBTExfU1RBUlQnLCdDQUxMX0VORCddLFxuXHRcdFsnUEFSQU1fU1RBUlQnLCdQQVJBTV9FTkQnXSxcblx0XHRbJ0lOREVYX1NUQVJUJywnSU5ERVhfRU5EJ10sXG5cdFx0WydUQUdfU1RBUlQnLCdUQUdfRU5EJ10sXG5cdFx0WydUQUdfUEFSQU1fU1RBUlQnLCdUQUdfUEFSQU1fRU5EJ10sXG5cdFx0WydUQUdfQVRUUlNfU1RBUlQnLCdUQUdfQVRUUlNfRU5EJ10sXG5cdFx0WydCTE9DS19QQVJBTV9TVEFSVCcsJ0JMT0NLX1BBUkFNX0VORCddXG5cdF07XG5cdFxuXHQvLyBUaGUgaW52ZXJzZSBtYXBwaW5ncyBvZiBgQkFMQU5DRURfUEFJUlNgIHdlJ3JlIHRyeWluZyB0byBmaXggdXAsIHNvIHdlIGNhblxuXHQvLyBsb29rIHRoaW5ncyB1cCBmcm9tIGVpdGhlciBlbmQuXG5cdG1vZHVsZS5leHBvcnRzLklOVkVSU0VTID0gSU5WRVJTRVMgPSB7fTtcblx0XG5cdC8vIFRoZSB0b2tlbnMgdGhhdCBzaWduYWwgdGhlIHN0YXJ0L2VuZCBvZiBhIGJhbGFuY2VkIHBhaXIuXG5cdC8vIHZhciBFWFBSRVNTSU9OX1NUQVJUID0gW11cblx0Ly8gdmFyIEVYUFJFU1NJT05fRU5EICAgPSBbXVxuXHRcblx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKEJBTEFOQ0VEX1BBSVJTKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcGFpcjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cGFpciA9IGFyeVtpXTtcblx0XHR2YXIgbGVmdCA9IHBhaXJbMF07XG5cdFx0dmFyIHJpdGUgPSBwYWlyWzFdO1xuXHRcdElOVkVSU0VTW3JpdGVdID0gbGVmdDtcblx0XHRJTlZFUlNFU1tsZWZ0XSA9IHJpdGU7XG5cdH07XG5cdFxuXHR2YXIgRVhQUkVTU0lPTl9TVEFSVCA9IFsnKCcsJ1snLCd7JywnSU5ERU5UJywnQ0FMTF9TVEFSVCcsJ1BBUkFNX1NUQVJUJywnSU5ERVhfU1RBUlQnLCdUQUdfUEFSQU1fU1RBUlQnLCdCTE9DS19QQVJBTV9TVEFSVCcsJ1NUUklOR19TVEFSVCcsJ3t7JywnVEFHX1NUQVJUJ107XG5cdHZhciBFWFBSRVNTSU9OX0VORCA9IFsnKScsJ10nLCd9JywnT1VUREVOVCcsJ0NBTExfRU5EJywnUEFSQU1fRU5EJywnSU5ERVhfRU5EJywnVEFHX1BBUkFNX0VORCcsJ0JMT0NLX1BBUkFNX0VORCcsJ1NUUklOR19FTkQnLCd9fScsJ1RBR19FTkQnXTtcblx0XG5cdHZhciBJREVOVElGSUVSUyA9IFsnSURFTlRJRklFUicsJ0dWQVInLCdJVkFSJywnQ1ZBUicsJ0NPTlNUJywnQVJHVkFSJ107XG5cdFxuXHQvLyBUb2tlbnMgdGhhdCBpbmRpY2F0ZSB0aGUgY2xvc2Ugb2YgYSBjbGF1c2Ugb2YgYW4gZXhwcmVzc2lvbi5cblx0dmFyIEVYUFJFU1NJT05fQ0xPU0UgPSBbJ0NBVENIJywnV0hFTicsJ0VMU0UnLCdGSU5BTExZJ10uY29uY2F0KEVYUFJFU1NJT05fRU5EKTtcblx0XG5cdC8vIFRva2VucyB0aGF0LCBpZiBmb2xsb3dlZCBieSBhbiBgSU1QTElDSVRfQ0FMTGAsIGluZGljYXRlIGEgZnVuY3Rpb24gaW52b2NhdGlvbi5cblx0dmFyIElNUExJQ0lUX0ZVTkMgPSBbJ0lERU5USUZJRVInLCdTVVBFUicsJ0AnLCdUSElTJywnU0VMRicsJ0VWRU5UJywnVFJJR0dFUicsJ1RBR19FTkQnLCdJVkFSJyxcblx0J0dWQVInLCdDT05TVCcsJ0FSR1ZBUicsJ05FVycsJ0JSRUFLJywnQ09OVElOVUUnLCdSRVRVUk4nXTtcblx0XG5cdC8vIElmIHByZWNlZGVkIGJ5IGFuIGBJTVBMSUNJVF9GVU5DYCwgaW5kaWNhdGVzIGEgZnVuY3Rpb24gaW52b2NhdGlvbi5cblx0dmFyIElNUExJQ0lUX0NBTEwgPSBbXG5cdFx0J1NFTEVDVE9SJywnSURFTlRJRklFUicsJ05VTUJFUicsJ1NUUklORycsJ1NZTUJPTCcsJ0pTJywnUkVHRVgnLCdORVcnLCdQQVJBTV9TVEFSVCcsJ0NMQVNTJyxcblx0XHQnSUYnLCdVTkxFU1MnLCdUUlknLCdTV0lUQ0gnLCdUSElTJywnQk9PTCcsJ1RSVUUnLCdGQUxTRScsJ05VTEwnLCdVTkRFRklORUQnLCdVTkFSWScsJ1NVUEVSJywnSVZBUicsJ0dWQVInLCdDT05TVCcsJ0FSR1ZBUicsJ1NFTEYnLFxuXHRcdCdAJywnWycsJygnLCd7JywnLS0nLCcrKycsJ1NFTEVDVE9SJywnVEFHX1NUQVJUJywnVEFHSUQnLCcjJywnU0VMRUNUT1JfU1RBUlQnLCdJRFJFRicsJ1NQTEFUJywnRE8nLCdCTE9DS19BUkcnLFxuXHRcdCdGT1InLCdTVFJJTkdfU1RBUlQnLCdDT05USU5VRScsJ0JSRUFLJ1xuXHRdOyAvLyAnLT4nLCAnPT4nLCB3aHkgZG9lcyBpdCBub3Qgd29yayB3aXRoIHN5bWJvbD9cblx0XG5cdHZhciBJTVBMSUNJVF9JTkRFTlRfQ0FMTCA9IFtcblx0XHQnRk9SJ1xuXHRdO1xuXHQvLyBpcyBub3QgZG8gYW4gaW1wbGljaXQgY2FsbD8/XG5cdFxuXHR2YXIgSU1QTElDSVRfVU5TUEFDRURfQ0FMTCA9IFsnKycsJy0nXTtcblx0XG5cdC8vIFRva2VucyBpbmRpY2F0aW5nIHRoYXQgdGhlIGltcGxpY2l0IGNhbGwgbXVzdCBlbmNsb3NlIGEgYmxvY2sgb2YgZXhwcmVzc2lvbnMuXG5cdHZhciBJTVBMSUNJVF9CTE9DSyA9IFsneycsJ1snLCcsJywnQkxPQ0tfUEFSQU1fRU5EJywnRE8nXTsgLy8gJy0+JywgJz0+JywgXG5cdFxuXHR2YXIgQ09ORElUSU9OQUxfQVNTSUdOID0gWyd8fD0nLCcmJj0nLCc/PScsJyY9JywnfD0nXTtcblx0dmFyIENPTVBPVU5EX0FTU0lHTiA9IFsnLT0nLCcrPScsJy89JywnKj0nLCclPScsJ3x8PScsJyYmPScsJz89JywnPDw9JywnPj49JywnPj4+PScsJyY9JywnXj0nLCd8PSddO1xuXHR2YXIgVU5BUlkgPSBbJyEnLCd+JywnTkVXJywnVFlQRU9GJywnREVMRVRFJ107XG5cdHZhciBMT0dJQyA9IFsnJiYnLCd8fCcsJyYnLCd8JywnXiddO1xuXHRcblx0Ly8gb3B0aW1pemUgZm9yIGZpeGVkIGFycmF5c1xuXHR2YXIgTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTCA9IFtcblx0XHQnQ0FMTF9FTkQnLCc9JywnREVGX0JPRFknLCcoJywnQ0FMTF9TVEFSVCcsJywnLCc6JywnUkVUVVJOJyxcblx0XHQnLT0nLCcrPScsJy89JywnKj0nLCclPScsJ3x8PScsJyYmPScsJz89JywnPDw9JywnPj49JywnPj4+PScsJyY9JywnXj0nLCd8PSdcblx0XTsgLy8gLmNvbmNhdChDT01QT1VORF9BU1NJR04pXG5cdFxuXHRcblx0Ly8gY29uc29sZS5sb2cgTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTDpsZW5ndGhcblx0Ly8gTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTFxuXHQvLyBJTVBMSUNJVF9DT01NQSA9IFsnLT4nLCAnPT4nLCAneycsICdbJywgJ05VTUJFUicsICdTVFJJTkcnLCAnU1lNQk9MJywgJ0lERU5USUZJRVInLCdETyddXG5cdFxuXHR2YXIgSU1QTElDSVRfQ09NTUEgPSBbJ0RPJ107XG5cdFxuXHQvLyBUb2tlbnMgdGhhdCBhbHdheXMgbWFyayB0aGUgZW5kIG9mIGFuIGltcGxpY2l0IGNhbGwgZm9yIHNpbmdsZS1saW5lcnMuXG5cdHZhciBJTVBMSUNJVF9FTkQgPSBbJ1BPU1RfSUYnLCdQT1NUX1VOTEVTUycsJ1BPU1RfRk9SJywnV0hJTEUnLCdVTlRJTCcsJ1dIRU4nLCdCWScsJ0xPT1AnLCdURVJNSU5BVE9SJywnREVGX0JPRFknLCdERUZfRlJBR01FTlQnXTtcblx0XG5cdC8vIFNpbmdsZS1saW5lIGZsYXZvcnMgb2YgYmxvY2sgZXhwcmVzc2lvbnMgdGhhdCBoYXZlIHVuY2xvc2VkIGVuZGluZ3MuXG5cdC8vIFRoZSBncmFtbWFyIGNhbid0IGRpc2FtYmlndWF0ZSB0aGVtLCBzbyB3ZSBpbnNlcnQgdGhlIGltcGxpY2l0IGluZGVudGF0aW9uLlxuXHR2YXIgU0lOR0xFX0xJTkVSUyA9IFsnRUxTRScsJ1RSWScsJ0ZJTkFMTFknLCdUSEVOJywnQkxPQ0tfUEFSQU1fRU5EJywnRE8nLCdCRUdJTicsJ0NBVENIX1ZBUiddOyAvLyAnLT4nLCAnPT4nLCByZWFsbHk/XG5cdHZhciBTSU5HTEVfQ0xPU0VSUyA9IFsnVEVSTUlOQVRPUicsJ0NBVENIJywnRklOQUxMWScsJ0VMU0UnLCdPVVRERU5UJywnTEVBRElOR19XSEVOJ107XG5cdFxuXHQvLyBUb2tlbnMgdGhhdCBlbmQgYSBsaW5lLlxuXHRyZXR1cm4gTElORUJSRUFLUyA9IFsnVEVSTUlOQVRPUicsJ0lOREVOVCcsJ09VVERFTlQnXTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9zcmMvY29tcGlsZXIvcmV3cml0ZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0Ly8gaGVscGVyIGZvciBzdWJjbGFzc2luZ1xuXHRmdW5jdGlvbiBzdWJjbGFzcyQob2JqLHN1cCkge1xuXHRcdGZvciAodmFyIGsgaW4gc3VwKSB7XG5cdFx0XHRpZiAoc3VwLmhhc093blByb3BlcnR5KGspKSBvYmpba10gPSBzdXBba107XG5cdFx0fTtcblx0XHQvLyBvYmouX19zdXBlcl9fID0gc3VwO1xuXHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0fTtcblx0XG5cdC8vIGNyZWF0ZSBzZXBhcmF0ZSBlcnJvci10eXBlcyB3aXRoIGFsbCB0aGUgbG9naWNcblx0XG5cdGZ1bmN0aW9uIEltYmFQYXJzZUVycm9yKGUsbyl7XG5cdFx0dGhpcy5lcnJvciA9IGU7XG5cdFx0dGhpcy5tZXNzYWdlID0gZS5tZXNzYWdlO1xuXHRcdHRoaXMuZmlsZW5hbWUgPSBlLmZpbGVuYW1lO1xuXHRcdHRoaXMubGluZSA9IGUubGluZTtcblx0XHR0aGlzLl9vcHRpb25zID0gbyB8fCB7fTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKEltYmFQYXJzZUVycm9yLEVycm9yKTtcblx0ZXhwb3J0cy5JbWJhUGFyc2VFcnJvciA9IEltYmFQYXJzZUVycm9yOyAvLyBleHBvcnQgY2xhc3MgXG5cdEltYmFQYXJzZUVycm9yLndyYXAgPSBmdW5jdGlvbiAoZXJyKXtcblx0XHQvLyB3aGF0IGFib3V0IHRoZSBzdGFja3RyYWNlP1xuXHRcdHJldHVybiBuZXcgSW1iYVBhcnNlRXJyb3IoZXJyKTtcblx0fTtcblx0XG5cdEltYmFQYXJzZUVycm9yLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob3B0cyl7XG5cdFx0dGhpcy5fb3B0aW9ucyB8fCAodGhpcy5fb3B0aW9ucyA9IHt9KTtcblx0XHRmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG9wdHMpLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0dGhpcy5fb3B0aW9uc1trZXlzW2ldXSA9IG9wdHNba2V5c1tpXV07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmFQYXJzZUVycm9yLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBvID0gdGhpcy5fb3B0aW9ucztcblx0XHR2YXIgaWR4ID0gby5wb3MgLSAxO1xuXHRcdHZhciB0b2sgPSBvLnRva2VucyAmJiBvLnRva2Vuc1tpZHhdO1xuXHRcdHdoaWxlICh0b2sgJiYgdG9rLl9sb2MgPT0gLTEpe1xuXHRcdFx0dG9rID0gby50b2tlbnNbLS1pZHhdO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRvaztcblx0fTtcblx0XG5cdEltYmFQYXJzZUVycm9yLnByb3RvdHlwZS5kZXNjID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG8gPSB0aGlzLl9vcHRpb25zO1xuXHRcdHZhciBtc2cgPSB0aGlzLm1lc3NhZ2U7XG5cdFx0aWYgKG8udG9rZW4gJiYgby50b2tlbi5fbG9jID09IC0xKSB7XG5cdFx0XHRyZXR1cm4gJ1N5bnRheCBFcnJvcic7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBtc2c7XG5cdFx0fTtcblx0fTtcblx0XG5cdEltYmFQYXJzZUVycm9yLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc3RhcnRfO1xuXHRcdHJldHVybiAoc3RhcnRfID0gdGhpcy5zdGFydCgpKSAmJiBzdGFydF8ucmVnaW9uICAmJiAgc3RhcnRfLnJlZ2lvbigpO1xuXHR9O1xuXHRcblx0SW1iYVBhcnNlRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBvID0gdGhpcy5fb3B0aW9ucztcblx0XHR2YXIgdG9rID0gdGhpcy5zdGFydCgpO1xuXHRcdC8vIHZhciB0b2sgPSBvOnRva2VucyBhbmQgbzp0b2tlbnNbbzpwb3MgLSAxXVxuXHRcdC8vIHZhciBsb2MgPSB0b2sgYW5kIFt0b2suQGxvYyx0b2suQGxvYyArICh0b2suQGxlbiBvciB0b2suQHZhbHVlOmxlbmd0aCldIG9yIFswLDBdXG5cdFx0Ly8gLCBjb2w6IHRvay5AY29sLCBsaW5lOiB0b2suQGxpbmVcblx0XHQvLyBnZXQgdGhlIHRva2VuIGl0c2VsZj9cblx0XHRyZXR1cm4ge3dhcm46IHRydWUsbWVzc2FnZTogdGhpcy5kZXNjKCksbG9jOiB0aGlzLmxvYygpfTtcblx0fTtcblx0cmV0dXJuIEltYmFQYXJzZUVycm9yO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL3NyYy9jb21waWxlci9lcnJvcnMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0XG5cdFxuXHRmdW5jdGlvbiBpc1doaXRlc3BhY2Uoc3RyKXtcblx0XHRyZXR1cm4gKC9eW1xcblxcdFxcIF0rJC8pLnRlc3Qoc3RyKTtcblx0fTsgZXhwb3J0cy5pc1doaXRlc3BhY2UgPSBpc1doaXRlc3BhY2U7XG5cdFxuXHRmdW5jdGlvbiBjb21tb25BbmNlc3RvcihhLGIpe1xuXHRcdGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHZhciBhcnIgPSBhLnNsaWNlKCk7XG5cdFx0XHRyZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbihwcmV2LGN1cnIsaSkge1xuXHRcdFx0XHRyZXR1cm4gY29tbW9uQW5jZXN0b3IocHJldixjdXJyKTtcblx0XHRcdH0sYXJyLnNoaWZ0KCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCFhIHx8ICFiKSB7IHJldHVybiAoYSB8fCBiKSB9O1xuXHRcdFxuXHRcdGEgPSBhLl9kb20gfHwgYTtcblx0XHRiID0gYi5fZG9tIHx8IGI7XG5cdFx0XG5cdFx0d2hpbGUgKCFhLmNvbnRhaW5zKGIpKXtcblx0XHRcdGEgPSBhLnBhcmVudE5vZGU7XG5cdFx0fTtcblx0XHR3aGlsZSAoIWIuY29udGFpbnMoYSkpe1xuXHRcdFx0YiA9IGIucGFyZW50Tm9kZTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0YWckd3JhcChhKTtcblx0fTsgZXhwb3J0cy5jb21tb25BbmNlc3RvciA9IGNvbW1vbkFuY2VzdG9yO1xuXHRcblx0XG5cdHZhciBwYWlycyA9IHtcblx0XHQnXCInOiAnXCInLFxuXHRcdFwiJ1wiOiBcIidcIixcblx0XHQnKCc6ICcpJyxcblx0XHQnPCc6ICc+Jyxcblx0XHQnWyc6ICddJyxcblx0XHQneyc6ICd9J1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gd3JhcFRleHQodGV4dCxvcGVuLGNsb3NlKXtcblx0XHRjbG9zZSB8fCAoY2xvc2UgPSBwYWlyc1tvcGVuXSk7XG5cdFx0aWYgKG9wZW4gPT0gXCInXCIpIHsgdGV4dCA9IHRleHQucmVwbGFjZSgvXFwnL2csXCJcXFxcJ1wiKSB9O1xuXHRcdHJldHVybiAob3BlbiB8fCAnJykgKyB0ZXh0ICsgKGNsb3NlIHx8ICcnKTtcblx0fTsgZXhwb3J0cy53cmFwVGV4dCA9IHdyYXBUZXh0O1xuXHRcblx0XG5cdGZ1bmN0aW9uIHN0cmluZ0lzQmFsYW5jZWQoc3RyKXtcblx0XHR2YXIgb3BlbnMgPSAnW3soXCJcXCcnO1xuXHRcdHZhciBjbG9zZXMgPSAnXX0pXCJcXCcnO1xuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcyxlbmQ7XG5cdFx0XG5cdFx0d2hpbGUgKHMgPSBzdHJbaSsrXSl7XG5cdFx0XHR2YXIgb2lkID0gb3BlbnMuaW5kZXhPZihzKTtcblx0XHRcdFxuXHRcdFx0aWYgKHMgPT0gZW5kKSB7XG5cdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRlbmQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdH0gZWxzZSBpZiAob2lkID49IDApIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSBjbG9zZXNbb2lkXSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHN0YWNrLmxlbmd0aCA9PSAwID8gKHRydWUpIDogKGZhbHNlKTtcblx0fTsgZXhwb3J0cy5zdHJpbmdJc0JhbGFuY2VkID0gc3RyaW5nSXNCYWxhbmNlZDtcblx0XG5cdGZ1bmN0aW9uIGNvbFRvTG9jKGxpbmUsY29sLHRhYnNpemUpe1xuXHRcdGlmKHRhYnNpemUgPT09IHVuZGVmaW5lZCkgdGFic2l6ZSA9IDQ7XG5cdFx0dmFyIGNpID0gMDtcblx0XHR2YXIgcmNpID0gMDsgLy8gcmVhbCBjb2x1bW5cblx0XHR2YXIgY2hhciQ7XG5cdFx0XG5cdFx0aWYgKGNvbCA9PSAwKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0d2hpbGUgKGNoYXIkID0gbGluZVtjaSsrXSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcdCcpIHtcblx0XHRcdFx0dmFyIHJlc3QgPSB0YWJzaXplIC0gcmNpICUgdGFic2l6ZTtcblx0XHRcdFx0cmNpICs9IHJlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyY2kgKz0gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChyY2kgPj0gY29sKSB7XG5cdFx0XHRcdHJldHVybiBjaTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbGluZS5sZW5ndGg7XG5cdH07IGV4cG9ydHMuY29sVG9Mb2MgPSBjb2xUb0xvYztcblx0XG5cdGZ1bmN0aW9uIGNvbFRvVmlld0NvbChsaW5lLGNvbCx0YWJzaXplKXtcblx0XHRpZih0YWJzaXplID09PSB1bmRlZmluZWQpIHRhYnNpemUgPSA0O1xuXHRcdHZhciBjaSA9IDA7XG5cdFx0dmFyIHJjaSA9IDA7IC8vIHJlYWwgY29sdW1uXG5cdFx0dmFyIGNoYXIkO1xuXHRcdFxuXHRcdGlmIChjb2wgPT0gMCkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdHdoaWxlIChjaGFyJCA9IGxpbmVbY2krK10pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXHQnKSB7XG5cdFx0XHRcdHZhciByZXN0ID0gdGFic2l6ZSAtIHJjaSAlIHRhYnNpemU7XG5cdFx0XHRcdGlmIChyZXN0ID4gMyAmJiBjb2wgPD0gcmNpICsgMikgeyBicmVhazsgfTtcblx0XHRcdFx0cmNpICs9IHJlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyY2kgKz0gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjb2wgPD0gcmNpKSB7IGJyZWFrOyB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHJjaTtcblx0fTsgZXhwb3J0cy5jb2xUb1ZpZXdDb2wgPSBjb2xUb1ZpZXdDb2w7XG5cdFxuXHRmdW5jdGlvbiBjb2xzRm9yTGluZShsaW5lLHRhYnNpemUpe1xuXHRcdGlmKHRhYnNpemUgPT09IHVuZGVmaW5lZCkgdGFic2l6ZSA9IDQ7XG5cdFx0dmFyIGNvbCA9IDA7XG5cdFx0dmFyIGlkeCA9IDA7XG5cdFx0dmFyIGNoYXIkO1xuXHRcdHdoaWxlIChjaGFyJCA9IGxpbmVbaWR4KytdKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFx0Jykge1xuXHRcdFx0XHR2YXIgcmVzdCA9IHRhYnNpemUgLSBjb2wgJSB0YWJzaXplO1xuXHRcdFx0XHRjb2wgKz0gcmVzdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbCArPSAxO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiBjb2w7XG5cdH07IGV4cG9ydHMuY29sc0ZvckxpbmUgPSBjb2xzRm9yTGluZTtcblx0XG5cdGZ1bmN0aW9uIHJvd2NvbChidWYsbG9jLHRhYnNpemUpe1xuXHRcdGlmKHRhYnNpemUgPT09IHVuZGVmaW5lZCkgdGFic2l6ZSA9IDQ7XG5cdFx0YnVmID0gYnVmLnRvU3RyaW5nKCk7XG5cdFx0dmFyIHBvcyA9IGxvYztcblx0XHR2YXIgY29sID0gMDtcblx0XHR2YXIgbGluZSA9IDA7XG5cdFx0dmFyIGNoYXIkO1xuXHRcdFxuXHRcdC8vIGdvIGJhY2sgdG8gc3RhcnQgb2YgbGluZVxuXHRcdHdoaWxlIChjaGFyJCA9IGJ1Zltwb3MgLSAxXSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcbicpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9O1xuXHRcdFx0cG9zLS07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBnZXQgY29sdW1uIGZvciBzbGljZVxuXHRcdHdoaWxlICgocG9zIDwgbG9jKSAmJiAoY2hhciQgPSBidWZbcG9zXSkpe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXHQnKSB7XG5cdFx0XHRcdHZhciByZXN0ID0gdGFic2l6ZSAtIChjb2wgJSB0YWJzaXplKTtcblx0XHRcdFx0Y29sICs9IHJlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2wgKz0gMTtcblx0XHRcdH07XG5cdFx0XHRwb3MrKztcblx0XHR9O1xuXHRcdFxuXHRcdHdoaWxlIChjaGFyJCA9IGJ1Zltwb3MgLSAxXSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcbicpIHtcblx0XHRcdFx0bGluZSsrO1xuXHRcdFx0fTtcblx0XHRcdHBvcy0tO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIFtsaW5lLGNvbF07XG5cdH07IGV4cG9ydHMucm93Y29sID0gcm93Y29sO1xuXHRcblx0ZnVuY3Rpb24gaW5jcmVhc2VJbmRlbnQoc3RyKXtcblx0XHR2YXIgcmVnID0gL14oXFxzKiguKlxcPVxccyopPyhleHBvcnQgfGdsb2JhbCB8ZXh0ZW5kICk/KGNsYXNzfGRlZnx0YWd8dW5sZXNzfGlmfGVsc2V8ZWxpZnxzd2l0Y2h8dHJ5fGNhdGNofGZpbmFsbHl8Zm9yfHdoaWxlfHVudGlsfGRvKSkvO1xuXHRcdHZhciBvdGhlciA9IC9cXGIoZG8pXFxiLztcblx0XHRyZXR1cm4gcmVnLnRlc3Qoc3RyKSB8fCBvdGhlci50ZXN0KHN0cik7XG5cdH07IGV4cG9ydHMuaW5jcmVhc2VJbmRlbnQgPSBpbmNyZWFzZUluZGVudDtcblx0XG5cdFxuXHRmdW5jdGlvbiByZXBlYXRTdHJpbmcoc3RyLGNvdW50KXtcblx0XHRyZXR1cm4gbmV3IEFycmF5KGNvdW50ICsgMSkuam9pbihzdHIpO1xuXHR9OyBleHBvcnRzLnJlcGVhdFN0cmluZyA9IHJlcGVhdFN0cmluZztcblx0XG5cdFxuXHRmdW5jdGlvbiBwYXRjaFN0cmluZyhvcmlnLHN0cixtb2RlKXtcblx0XHR2YXIgcmVnaW9uO1xuXHRcdHZhciB0ZXh0ID0gb3JpZy50b1N0cmluZygpO1xuXHRcdFxuXHRcdGlmIChtb2RlID09ICdhcHBlbmQnKSB7XG5cdFx0XHRyZXR1cm4gdGV4dCArIHN0cjtcblx0XHR9IGVsc2UgaWYgKG1vZGUgPT0gJ3ByZXBlbmQnKSB7XG5cdFx0XHRyZXR1cm4gXCJcIiArIHN0ciArIHRleHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChyZWdpb24gPSBSZWdpb24ubm9ybWFsaXplKG1vZGUpKSB7XG5cdFx0XHRcdC8vIGxldCByZWdpb24gPSBSZWdpb24ubm9ybWFsaXplKClcblx0XHRcdFx0cmV0dXJuIHRleHQuc3Vic3RyKDAscmVnaW9uLnN0YXJ0KCkpICsgc3RyICsgdGV4dC5zbGljZShyZWdpb24uZW5kKCkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9OyBleHBvcnRzLnBhdGNoU3RyaW5nID0gcGF0Y2hTdHJpbmc7OyByZXR1cm4gcGF0Y2hTdHJpbmc7XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvdXRpbC5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBoZWxwZXIgZm9yIHN1YmNsYXNzaW5nXG5cdGZ1bmN0aW9uIHN1YmNsYXNzJChvYmosc3VwKSB7XG5cdFx0Zm9yICh2YXIgayBpbiBzdXApIHtcblx0XHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIG9ialtrXSA9IHN1cFtrXTtcblx0XHR9O1xuXHRcdC8vIG9iai5fX3N1cGVyX18gPSBzdXA7XG5cdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gSGlzdG9yeVN0YXRlKGRhdGEpe1xuXHRcdGlmKGRhdGEgPT09IHVuZGVmaW5lZCkgZGF0YSA9IHt9O1xuXHRcdHRoaXMuX3RpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdFxuXHRcblx0SGlzdG9yeVN0YXRlLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kYXRhOyB9XG5cdEhpc3RvcnlTdGF0ZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kYXRhID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGlzdG9yeVN0YXRlLnByb3RvdHlwZS50aW1lc3RhbXAgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RpbWVzdGFtcDsgfVxuXHRIaXN0b3J5U3RhdGUucHJvdG90eXBlLnNldFRpbWVzdGFtcCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90aW1lc3RhbXAgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEhpc3RvcnlTdGF0ZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5U3RhdGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKXtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0XHR0aGlzLl90aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIEZ1bGxIaXN0b3J5U3RhdGUoKXsgcmV0dXJuIEhpc3RvcnlTdGF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChGdWxsSGlzdG9yeVN0YXRlLEhpc3RvcnlTdGF0ZSk7XG5cdEZ1bGxIaXN0b3J5U3RhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHZpZXcubG9hZFN0YXRlKHRoaXMuX2RhdGEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gRGlmZkhpc3RvcnlTdGF0ZSgpeyByZXR1cm4gSGlzdG9yeVN0YXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKERpZmZIaXN0b3J5U3RhdGUsSGlzdG9yeVN0YXRlKTtcblx0XG5cdFxuXHR2YXIgdHlwZXMgPSB7fTtcblx0XG5cdGZ1bmN0aW9uIENvbW1hbmQocGFyYW1zKXtcblx0XHR0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ByZXY7IH1cblx0Q29tbWFuZC5wcm90b3R5cGUuc2V0UHJldiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wcmV2ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbmV4dDsgfVxuXHRDb21tYW5kLnByb3RvdHlwZS5zZXROZXh0ID0gZnVuY3Rpb24odil7IHRoaXMuX25leHQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5mcmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZnJhbWU7IH1cblx0Q29tbWFuZC5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5fZnJhbWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdENvbW1hbmQuc3ltID0gZnVuY3Rpb24gKHN5bSl7XG5cdFx0dmFyICQwID0gYXJndW1lbnRzLCBpID0gJDAubGVuZ3RoO1xuXHRcdHZhciBwYXJzID0gbmV3IEFycmF5KGk+MSA/IGktMSA6IDApO1xuXHRcdHdoaWxlKGk+MSkgcGFyc1stLWkgLSAxXSA9ICQwW2ldO1xuXHRcdHRoaXMucHJvdG90eXBlLl9zeW1ib2wgPSBzeW07XG5cdFx0dGhpcy5wcm90b3R5cGUuX3NpZ25hdHVyZSA9IHBhcnM7XG5cdFx0dHlwZXNbc3ltXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRDb21tYW5kLmxvYWQgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIHR5cCA9IHR5cGVzW29bMF1dO1xuXHRcdHZhciBmcmFtZSA9IG9bMV07XG5cdFx0dmFyIGNtZCA9IHR5cC5idWlsZChvWzJdKTtcblx0XHRjbWQuc2V0RnJhbWUoZnJhbWUpO1xuXHRcdHJldHVybiBjbWQ7XG5cdH07XG5cdFxuXHRDb21tYW5kLmJ1aWxkID0gZnVuY3Rpb24gKHBhcmFtcyl7XG5cdFx0cmV0dXJuIG5ldyB0aGlzKHBhcmFtcyk7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fcGFyYW1zO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRyZXR1cm4gdGhpcy5wcmV2KCk7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdl87XG5cdFx0aWYgKHRoaXMucHJldigpKSB7ICh0aGlzLnByZXYoKS5zZXROZXh0KHZfID0gdGhpcy5uZXh0KCkpLHZfKSB9O1xuXHRcdGlmICh0aGlzLm5leHQoKSkgeyAodGhpcy5uZXh0KCkuc2V0UHJldih2XyA9IHRoaXMucHJldigpKSx2XykgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5fc3ltYm9sLHRoaXMuX2ZyYW1lIHx8IDAsdGhpcy5wYXJhbXMoKSB8fCBbXV07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBNYXJrKCl7IHJldHVybiBDb21tYW5kLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKE1hcmssQ29tbWFuZCk7XG5cdE1hcmsuc3ltKCdNJywndmFsdWUnKTtcblx0XG5cdFxuXHRmdW5jdGlvbiBTbmFwc2hvdChwYXJhbXMpe1xuXHRcdHRoaXMuX2NvZGUgPSBwYXJhbXNbMF07XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoU25hcHNob3QsTWFyayk7XG5cdFNuYXBzaG90LnN5bSgnUycsJ2NvZGUnKTtcblx0XG5cdFNuYXBzaG90LnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX2NvZGVdO1xuXHR9O1xuXHRcblx0U25hcHNob3QucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Y29uc29sZS5sb2coJ2xvYWQnLHRoaXMuX2NvZGUpO1xuXHRcdHZpZXcubG9hZCh0aGlzLl9jb2RlKTtcblx0XHQvLyBtdXN0IHJlcGFpcj8gd2hhdCBhYm91dCBhbm5vdGF0aW9ucz9cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFNlbGVjdGlvbihwYXJhbXMpe1xuXHRcdHRoaXMuX29sZCA9IHBhcmFtc1swXTtcblx0XHR0aGlzLl9uZXcgPSBwYXJhbXNbMV07XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoU2VsZWN0aW9uLENvbW1hbmQpO1xuXHRTZWxlY3Rpb24uc3ltKCd8Jywnb2xkJywnbmV3Jyk7XG5cdFxuXHRTZWxlY3Rpb24ubG9hZCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHJldHVybiBuZXcgdGhpcyh2YWwpO1xuXHR9O1xuXHRcblx0U2VsZWN0aW9uLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX29sZCx0aGlzLl9uZXddO1xuXHR9O1xuXHRcblx0U2VsZWN0aW9uLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHZpZXcuY2FyZXQoKS5zZXQoSlNPTi5wYXJzZSh0aGlzLl9uZXcpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFNlbGVjdGlvbi5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0dGhpcy5yZWRvKHZpZXcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U2VsZWN0aW9uLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdC8vIHdlIG5lZWQgdG8ga25vdyBhYm91dCB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGZvciB0aGlzP1xuXHRcdC8vIGNhbiBlaXRoZXIgc3RvcmUgYm90aCAtIG9yIHRyYXZlcnNlIGJhY2t3YXJkcyB0byB0aGUgcHJldmlvdXNcblx0XHQvLyBjb21tYW5kIGxpa2UgdGhpc1xuXHRcdHZhciBvbGQgPSBKU09OLnBhcnNlKHRoaXMuX29sZCk7XG5cdFx0Y29uc29sZS5sb2coJ21vdmUgc2VsZWN0aW9uIGJhY2sgdG8gb2xkJyxvbGQsdGhpcy5kYXRhKCkpO1xuXHRcdHZpZXcuY2FyZXQoKS5zZXQob2xkKTtcblx0XHRyZXR1cm4gdGhpcy5wcmV2KCk7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gSW5zZXJ0KHBhcnMpe1xuXHRcdHRoaXMuX3BvaW50ID0gcGFyc1swXTtcblx0XHR0aGlzLl9zdHIgPSBwYXJzWzFdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKEluc2VydCxDb21tYW5kKTtcblx0SW5zZXJ0LnN5bSgnKycsJ3BvaW50Jywnc3RyJyk7XG5cdFxuXHRJbnNlcnQucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5fcG9pbnQsdGhpcy5fc3RyXTtcblx0fTtcblx0XG5cdEluc2VydC5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRjb25zb2xlLmxvZygncmVkbyBJbnNlcnQnKTtcblx0XHRyZXR1cm4gdmlldy5pbnNlcnQodGhpcy5fcG9pbnQsdGhpcy5fc3RyKTtcblx0fTtcblx0XG5cdEluc2VydC5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRjb25zb2xlLmxvZygndW5kbyBJbnNlcnQnKTtcblx0XHR2aWV3LmVyYXNlKFt0aGlzLl9wb2ludCx0aGlzLl9wb2ludCArIHRoaXMuX3N0ci5sZW5ndGhdKTtcblx0XHRyZXR1cm4gdGhpcy5wcmV2KCk7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBFcmFzZShwYXJhbXMpe1xuXHRcdHRoaXMuX3JlZ2lvbiA9IHBhcmFtc1swXTtcblx0XHR0aGlzLl9zdHIgPSBwYXJhbXNbMV07XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoRXJhc2UsQ29tbWFuZCk7XG5cdEVyYXNlLnN5bSgnLScsJ3JlZ2lvbicsJ3N0cicpO1xuXHRcblx0RXJhc2UucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5fcmVnaW9uLHRoaXMuX3N0cl07XG5cdH07XG5cdFxuXHRFcmFzZS5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRjb25zb2xlLmxvZygncmVkbyBFcmFzZScpO1xuXHRcdHJldHVybiB2aWV3LmVyYXNlKHRoaXMuX3JlZ2lvbik7XG5cdH07XG5cdFxuXHRFcmFzZS5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHQvLyBpZiB3ZSBkb250IGtub3cgdGhlIHRleHQgdG8gXG5cdFx0Y29uc29sZS5sb2coJ3VuZG8gRXJhc2UnKTtcblx0XHR2aWV3Lmluc2VydCh0aGlzLl9yZWdpb24uc3RhcnQoKSx0aGlzLl9zdHIpO1xuXHRcdHJldHVybiB0aGlzLnByZXYoKTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBIaXN0b3J5KHZpZXcpe1xuXHRcdHRoaXMuX21vZGUgPSAnbm9ybWFsJztcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLnNldEN1cnJlbnQodGhpcy5fc2VlZCA9IG5ldyBNYXJrKCkpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkhpc3RvcnkgPSBIaXN0b3J5OyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubW9kZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbW9kZTsgfVxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24odil7IHRoaXMuX21vZGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdEhpc3RvcnkucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7IH1cblx0SGlzdG9yeS5wcm90b3R5cGUuc2V0RW5hYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lbmFibGVkID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY3VycmVudDsgfVxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZXRDdXJyZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX2N1cnJlbnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZWVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zZWVkOyB9XG5cdEhpc3RvcnkucHJvdG90eXBlLnNldFNlZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2VlZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnRhaWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RhaWw7IH1cblx0SGlzdG9yeS5wcm90b3R5cGUuc2V0VGFpbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90YWlsID0gdjsgcmV0dXJuIHRoaXM7IH07IC8vIGlzIHRoaXMgYmVoaW5kIG9yIGluIHRoZSB2ZXJ5IGZyb250P1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0sbW92ZSxmcmFtZSl7XG5cdFx0aWYobW92ZSA9PT0gdW5kZWZpbmVkKSBtb3ZlID0gdHJ1ZTtcblx0XHRpZihmcmFtZSA9PT0gdW5kZWZpbmVkKSBmcmFtZSA9IHRoaXMudmlldygpLmZyYW1lcygpO1xuXHRcdGl0ZW0uc2V0RnJhbWUoZnJhbWUpO1xuXHRcdFxuXHRcdGlmICh0aGlzLmN1cnJlbnQoKSkge1xuXHRcdFx0Ly8gaWYgY3VycmVudCBoYXMgYSBuZXh0IGV2ZW50XG5cdFx0XHQvLyB0aGlzIHNob3VsZCBiZSBkZXRhY2hlZCBoZXJlP1xuXHRcdFx0aXRlbS5zZXRQcmV2KHRoaXMuY3VycmVudCgpKTtcblx0XHRcdHRoaXMuY3VycmVudCgpLnNldE5leHQoaXRlbSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAobW92ZSkgeyAodGhpcy5zZXRDdXJyZW50KGl0ZW0pLGl0ZW0pIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGN1cnJlbnRfO1xuXHRcdHJldHVybiAoY3VycmVudF8gPSB0aGlzLmN1cnJlbnQoKSkgJiYgY3VycmVudF8ubmV4dCAgJiYgIGN1cnJlbnRfLm5leHQoKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgY3VycmVudF87XG5cdFx0cmV0dXJuIChjdXJyZW50XyA9IHRoaXMuY3VycmVudCgpKSAmJiBjdXJyZW50Xy5wcmV2ICAmJiAgY3VycmVudF8ucHJldigpO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChkaXIpe1xuXHRcdGlmKGRpciA9PT0gdW5kZWZpbmVkKSBkaXIgPSAxO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLmFwcGx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlcyA9IFtdO3doaWxlIChzZWxmLm5leHQoKSl7XG5cdFx0XHRcdHNlbGYubmV4dCgpLnJlZG8oc2VsZi52aWV3KCksc2VsZik7XG5cdFx0XHRcdHNlbGYuc2V0Q3VycmVudChzZWxmLm5leHQoKSk7XG5cdFx0XHRcdGlmIChzZWxmLmN1cnJlbnQoKSBpbnN0YW5jZW9mIE1hcmspIHsgYnJlYWs7IH07XG5cdFx0XHR9O3JldHVybiByZXM7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYuYXBwbHkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBzaG91bGQgYmUgcG9zc2libGUgdG8gdW5kbyBcblx0XHRcdHZhciByZXMgPSBbXSwgdl8sIGN1cnJlbnRfO3doaWxlIChzZWxmLmN1cnJlbnQoKSl7XG5cdFx0XHRcdGlmIChzZWxmLnByZXYoKSkgeyAoc2VsZi5zZXRDdXJyZW50KHZfID0gc2VsZi5jdXJyZW50KCkudW5kbyhzZWxmLnZpZXcoKSxzZWxmKSksdl8pIH07XG5cdFx0XHRcdChjdXJyZW50XyA9IHNlbGYuY3VycmVudCgpKSAmJiBjdXJyZW50Xy5lbnRlciAgJiYgIGN1cnJlbnRfLmVudGVyKHNlbGYudmlldygpLHNlbGYpO1xuXHRcdFx0XHRpZiAoc2VsZi5jdXJyZW50KCkgaW5zdGFuY2VvZiBNYXJrKSB7IGJyZWFrOyB9O1xuXHRcdFx0fTtyZXR1cm4gcmVzO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoY2Ipe1xuXHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7XG5cdFx0Y2IgJiYgY2IoKTtcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24gKGNiKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKHN0YXRlKXtcblx0XHRzdGF0ZS5hcHBseSh0aGlzLnZpZXcoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5vbmVyYXNlID0gZnVuY3Rpb24gKHJlZyxzdHIsZWRpdCl7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHJldHVybiB0aGlzLmFkZChuZXcgRXJhc2UoW3JlZyxzdHJdKSk7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5vbmluc2VydCA9IGZ1bmN0aW9uIChsb2Msc3RyLGVkaXQpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRyZXR1cm4gdGhpcy5hZGQobmV3IEluc2VydChbbG9jLHN0cl0pKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLm9uY2FyZXQgPSBmdW5jdGlvbiAob2xkLG5ldyQpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRyZXR1cm4gdGhpcy5hZGQobmV3IFNlbGVjdGlvbihbb2xkLG5ldyRdKSk7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5vbmxvYWQgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHZhciBtYXJrID0gbmV3IFNuYXBzaG90KFtjb2RlXSk7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKG1hcmspO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHZhciBtYXJrID0gbmV3IE1hcmsoW3ZhbHVlXSk7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKG1hcmspO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZiAoc2VsZi5fbW9kZSA9PSAncGxheScpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdwbHlhaW5nJ1xuXHRcdFx0dmFyIGZyYW1lID0gc2VsZi52aWV3KCkuZnJhbWVzKCkgLSBzZWxmLl9vZmZzZXQ7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaGlzdG9yeS50aWNrIHdpbGwgcGxheScsZnJhbWUsbmV4dCxjdXJyZW50XG5cdFx0XHRzZWxmLmFwcGx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmVzID0gW10sIHZfO3doaWxlIChzZWxmLm5leHQoKSAmJiBzZWxmLm5leHQoKS5mcmFtZSgpIDw9IGZyYW1lKXtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnaGlzdG9yeS50aWNrIHBsYXknLGZyYW1lLG5leHQsY3VycmVudFxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdyZXBsYXkgZnJhbWUhJ1xuXHRcdFx0XHRcdHNlbGYubmV4dCgpLnJlZG8oc2VsZi52aWV3KCksc2VsZik7XG5cdFx0XHRcdFx0cmVzLnB1c2goKChzZWxmLnNldEN1cnJlbnQodl8gPSBzZWxmLm5leHQoKSksdl8pKSk7XG5cdFx0XHRcdH07cmV0dXJuIHJlcztcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoIShzZWxmLm5leHQoKSkpIHtcblx0XHRcdFx0c2VsZi5zZXRNb2RlKCdsaXZlJyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gc2hvdWxkIHByb2JhYmx5IGhhcHBlbiBpbiBhIGRpZmZlcmVudCBtYW5hZ2VyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBzbmFwID0gc2VsZi5zZWVkKCk7XG5cdFx0d2hpbGUgKCEoIXNuYXAgfHwgKHNuYXAgaW5zdGFuY2VvZiBTbmFwc2hvdCkpKXtcblx0XHRcdHNuYXAgPSBzbmFwLm5leHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHNlbGYuX29mZnNldCA9IHNlbGYudmlldygpLmZyYW1lcygpIC0gc25hcC5mcmFtZSgpO1xuXHRcdGNvbnNvbGUubG9nKFwicGxheWluZyBmcm9tIHNlZWRcIixzbmFwLHNlbGYuX29mZnNldCk7XG5cdFx0Ly8gY29uc29sZS5sb2cgJ2ZvdW5kIHNuYXBzaG90PyE/IC0tIG9mZnNldCBmcmFtZScsQG9mZnNldFxuXHRcdHNlbGYuYXBwbHkoZnVuY3Rpb24oKSB7IHZhciB2Xztcblx0XHRyZXR1cm4gKHNlbGYuc2V0Q3VycmVudCh2XyA9IHNuYXAucmVkbyhzZWxmLnZpZXcoKSxzZWxmKSksdl8pOyB9KTtcblx0XHRzZWxmLnNldE1vZGUoJ3BsYXknKTtcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBkYXRhID0gW107XG5cdFx0dmFyIHN0ZXAgPSB0aGlzLl9zZWVkO1xuXHRcdFxuXHRcdHdoaWxlIChzdGVwKXtcblx0XHRcdGRhdGEucHVzaChzdGVwLnRvSlNPTigpKTtcblx0XHRcdHN0ZXAgPSBzdGVwLm5leHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB7Y29tbWFuZHM6IGRhdGF9O1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChkYXRhKXtcblx0XHR2YXIgc3RlcCA9IHRoaXMuc2VlZCgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChkYXRhLmNvbW1hbmRzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IENvbW1hbmQubG9hZChhcnlbaV0pO1xuXHRcdFx0aXRlbS5zZXRQcmV2KHN0ZXApO1xuXHRcdFx0c3RlcC5zZXROZXh0KGl0ZW0pO1xuXHRcdFx0c3RlcCA9IGl0ZW07XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9hZCBpdGVtJyxpdGVtXG5cdFx0fTtcblx0XHQvLyBjb25zb2xlLmxvZyAnbG9hZGVkJ1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRyZXR1cm4gSGlzdG9yeTtcblx0XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9oaXN0b3J5LmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRmdW5jdGlvbiBMb2dnZXIodmlldyl7XG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lbmFibGVkOyB9XG5cdExvZ2dlci5wcm90b3R5cGUuc2V0RW5hYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lbmFibGVkID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdExvZ2dlci5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9lbmFibGVkIHx8IERFQlVHKSB7IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgREVCVUcpIHsgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMb2dnZXIucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdGlmICh0aGlzLl9lbmFibGVkIHx8IERFQlVHKSB7IGNvbnNvbGUuZ3JvdXAuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMb2dnZXIucHJvdG90eXBlLmdyb3VwQ29sbGFwc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgREVCVUcpIHsgY29uc29sZS5ncm91cENvbGxhcHNlZC5hcHBseShjb25zb2xlLGFyZ3VtZW50cykgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExvZ2dlci5wcm90b3R5cGUuZ3JvdXBFbmQgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCBERUJVRykgeyBjb25zb2xlLmdyb3VwRW5kKCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cmV0dXJuIExvZ2dlcjtcblx0XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9sb2dnZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cdFxuXHR2YXIgc3BlY2lhbEtleXMgPSB7XG5cdFx0ODogXCJiYWNrc3BhY2VcIixcblx0XHQ5OiBcInRhYlwiLFxuXHRcdDEwOiBcInJldHVyblwiLFxuXHRcdDEzOiBcInJldHVyblwiLFxuXHRcdDE2OiBcInNoaWZ0XCIsXG5cdFx0MTc6IFwiY3RybFwiLFxuXHRcdDE4OiBcImFsdFwiLFxuXHRcdDE5OiBcInBhdXNlXCIsXG5cdFx0MjA6IFwiY2Fwc2xvY2tcIixcblx0XHQyNzogXCJlc2NcIixcblx0XHQzMjogXCJzcGFjZVwiLFxuXHRcdDMzOiBcInBhZ2V1cFwiLFxuXHRcdDM0OiBcInBhZ2Vkb3duXCIsXG5cdFx0MzU6IFwiZW5kXCIsXG5cdFx0MzY6IFwiaG9tZVwiLFxuXHRcdDM3OiBcImxlZnRcIixcblx0XHQzODogXCJ1cFwiLFxuXHRcdDM5OiBcInJpZ2h0XCIsXG5cdFx0NDA6IFwiZG93blwiLFxuXHRcdDQ1OiBcImluc2VydFwiLFxuXHRcdDQ2OiBcImRlbFwiLFxuXHRcdDU5OiBcIjtcIixcblx0XHQ2MTogXCI9XCIsXG5cdFx0OTY6IFwiMFwiLFxuXHRcdDk3OiBcIjFcIixcblx0XHQ5ODogXCIyXCIsXG5cdFx0OTk6IFwiM1wiLFxuXHRcdDEwMDogXCI0XCIsXG5cdFx0MTAxOiBcIjVcIixcblx0XHQxMDI6IFwiNlwiLFxuXHRcdDEwMzogXCI3XCIsXG5cdFx0MTA0OiBcIjhcIixcblx0XHQxMDU6IFwiOVwiLFxuXHRcdDEwNjogXCIqXCIsXG5cdFx0MTA3OiBcIitcIixcblx0XHQxMDk6IFwiLVwiLFxuXHRcdDExMDogXCIuXCIsXG5cdFx0MTExOiBcIi9cIixcblx0XHQxMTI6IFwiZjFcIixcblx0XHQxMTM6IFwiZjJcIixcblx0XHQxMTQ6IFwiZjNcIixcblx0XHQxMTU6IFwiZjRcIixcblx0XHQxMTY6IFwiZjVcIixcblx0XHQxMTc6IFwiZjZcIixcblx0XHQxMTg6IFwiZjdcIixcblx0XHQxMTk6IFwiZjhcIixcblx0XHQxMjA6IFwiZjlcIixcblx0XHQxMjE6IFwiZjEwXCIsXG5cdFx0MTIyOiBcImYxMVwiLFxuXHRcdDEyMzogXCJmMTJcIixcblx0XHQxNDQ6IFwibnVtbG9ja1wiLFxuXHRcdDE0NTogXCJzY3JvbGxcIixcblx0XHQxNzM6IFwiLVwiLFxuXHRcdDE4NjogXCI7XCIsXG5cdFx0MTg3OiBcIj1cIixcblx0XHQxODg6IFwiLFwiLFxuXHRcdDE4OTogXCItXCIsXG5cdFx0MTkwOiBcIi5cIixcblx0XHQxOTE6IFwiL1wiLFxuXHRcdDE5MjogXCJgXCIsXG5cdFx0MjE5OiBcIltcIixcblx0XHQyMjA6IFwiXFxcXFwiLFxuXHRcdDIyMTogXCJdXCIsXG5cdFx0MjIyOiBcIidcIlxuXHR9O1xuXHRcblx0dmFyIHNoaWZ0TnVtcyA9IHtcblx0XHRcImBcIjogXCJ+XCIsXG5cdFx0XCIxXCI6IFwiIVwiLFxuXHRcdFwiMlwiOiBcIkBcIixcblx0XHRcIjNcIjogXCIjXCIsXG5cdFx0XCI0XCI6IFwiJFwiLFxuXHRcdFwiNVwiOiBcIiVcIixcblx0XHRcIjZcIjogXCJeXCIsXG5cdFx0XCI3XCI6IFwiJlwiLFxuXHRcdFwiOFwiOiBcIipcIixcblx0XHRcIjlcIjogXCIoXCIsXG5cdFx0XCIwXCI6IFwiKVwiLFxuXHRcdFwiLVwiOiBcIl9cIixcblx0XHRcIj1cIjogXCIrXCIsXG5cdFx0XCI7XCI6IFwiOiBcIixcblx0XHRcIidcIjogJ1wiJyxcblx0XHRcIixcIjogXCI8XCIsXG5cdFx0XCIuXCI6IFwiPlwiLFxuXHRcdFwiL1wiOiBcIj9cIixcblx0XHRcIlxcXFxcIjogXCJ8XCJcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHRyaWdnZXIoa2V5LG8pe1xuXHRcdGlmIChvIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdG8gPSB7Y29tbWFuZDogb307XG5cdFx0fTtcblx0XHRvLnRyaWdnZXIgPSBrZXk7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBjb21ibyhrZXlzLG8pe1xuXHRcdGlmIChvIGluc3RhbmNlb2YgRnVuY3Rpb24pIHsgbyA9IHtjb21tYW5kOiBvfSB9O1xuXHRcdG8ua2V5cyA9IGtleXM7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHRJTS5LZXlCaW5kaW5ncyA9IFtcblx0XHRcblx0XHRjb21ibyhbJ3N1cGVyK3onXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC52aWV3KCkuaGlzdG9yeSgpLnVuZG8oKTsgfSksXG5cdFx0Y29tYm8oW1wic3VwZXIrc2hpZnQrelwiXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC52aWV3KCkuaGlzdG9yeSgpLnJlZG8oKTsgfSksXG5cdFx0Y29tYm8oW1wiYWx0K3N1cGVyK3BcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudmlldygpLmhpc3RvcnkoKS5wbGF5KCk7IH0pLFxuXHRcdC8vIGNvbWJvIFtcImFsdCtzaGlmdCtyXCJdIGRvIHxzZWx8IHNlbC52aWV3Lmhpc3RvcnkucGxheVxuXHRcdFxuXHRcdGNvbWJvKFtcInN1cGVyK3NcIl0se2NvbW1hbmQ6IFwic2F2ZVwifSksXG5cdFx0Y29tYm8oW1wic3VwZXIrYlwiXSx7Y29tbWFuZDogXCJydW5cIn0pLFxuXHRcdGNvbWJvKFtcImFsdCtzdXBlcitzXCJdLHtjb21tYW5kOiBcInNhdmVTZXNzaW9uXCJ9KSxcblx0XHRjb21ibyhbXCJhbHQrc2hpZnQrbFwiXSx7Y29tbWFuZDogXCJyZXBhcnNlXCJ9KSxcblx0XHRjb21ibyhbXCJhbHQrc2hpZnQra1wiXSx7Y29tbWFuZDogXCJyZXBhcnNlRXh0ZW50XCJ9KSxcblx0XHRcblx0XHRjb21ibyhbXCJzdXBlcithXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnNlbGVjdEFsbCgpOyB9KSxcblx0XHRcblx0XHRcblx0XHRjb21ibyhbJ3RhYiddLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC50ZXh0KCkuaW5kZXhPZignXFxuJykgPj0gMDsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHtcblx0XHRcdHNlbC5leHBhbmRUb0xpbmVzKCk7XG5cdFx0XHR2YXIgcmVnaW9uID0gc2VsLnJlZ2lvbigpO1xuXHRcdFx0dmFyIG5vZGVzID0gc2VsLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHJlZ2lvbik7XG5cdFx0XHRcblx0XHRcdG5vZGVzLm1hcChmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRpZiAobWF0Y2gubm9kZS5tYXRjaGVzKCcuX2ltbmV3bGluZScpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ2ZvdW5kIHRhYiBpbiBzZWxlY3Rpb24nLG1hdGNoKTtcblx0XHRcdFx0XHRpZiAobWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gubm9kZS5pbmRlbnQoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2VsLmRpcnR5KCk7XG5cdFx0fX0pLFxuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdGNvbWJvKFtcInNoaWZ0K3RhYlwiXSx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudGV4dCgpLmluZGV4T2YoJ1xcbicpID49IDA7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRzZWwuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0dmFyIHJlZ2lvbiA9IHNlbC5yZWdpb24oKTtcblx0XHRcdHZhciBub2RlcyA9IHNlbC52aWV3KCkubm9kZXNJblJlZ2lvbihyZWdpb24pO1xuXHRcdFx0XG5cdFx0XHRub2Rlcy5tYXAoZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0aWYgKG1hdGNoLm5vZGUubWF0Y2hlcygnLl9pbW5ld2xpbmUnKSAmJiBtYXRjaC5tb2RlICE9ICdzdGFydCcpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gubm9kZS51bmRlbnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNlbC5kaXJ0eSgpO1xuXHRcdH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJzaGlmdCt0YWJcIl0se2NvbnRleHQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHJldHVybiB0cnVlOyAvLyBTdHJpbmcoZS52aWV3LnNlbGVjdGlvbikuaW5kZXhPZignXFxuJykgPj0gMFxuXHRcdH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRjb25zb2xlLmxvZygndHJ5IHVuZGVudCcpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fX0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcImFsdCtzaGlmdCtyZXR1cm5cIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBjb25zb2xlLmxvZygncHJldHRpZnknKTsgfSksXG5cdFx0XG5cdFx0Y29tYm8oW1wiYmFja3NwYWNlXCJdLHtjb250ZXh0OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnZGVsZXRlTGVmdFJpZ2h0IGJhY2tzcGFjZT8hPycsZS5yZWdpb24oKSxlLnJlZ2lvbigpLnBlZWsoLTEsMSkpO1xuXHRcdFx0cmV0dXJuIGlkeCQoZS5yZWdpb24oKS5wZWVrKC0xLDEpLFsnW10nLCd7fScsJzw+JywnKCknLCdcIlwiJyxcIicnXCJdKSA+PSAwO1xuXHRcdH0sXG5cdFx0XG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnbW92aW5nISEnKTtcblx0XHRcdHNlbC5leHBhbmQoLTEsMSk7XG5cdFx0XHRyZXR1cm4gc2VsLmVyYXNlKCk7XG5cdFx0fX0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcImJhY2tzcGFjZVwiXSx7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHtcblx0XHRcdHZhciByZWcgPSBzZWwucmVnaW9uKCk7XG5cdFx0XHRpZiAocmVnLnNpemUoKSA9PSAwKSB7XG5cdFx0XHRcdGlmIChvLm5vZGUgPSByZWcucHJldk5vZGUoJy5faW1wYWlyLC5faW1zdHInKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCxvKSB7IHZhciB2Xztcblx0XHRyZXR1cm4gKHNlbC5zZXRSZWdpb24odl8gPSBvLm5vZGUucmVnaW9uKCkuY2xvbmUoKS5yZXZlcnNlKCkpLHZfKTsgfX0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcImJhY2tzcGFjZVwiXSx7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHtcblx0XHRcdGlmIChzZWwudGV4dCgpICYmICF1dGlsLnN0cmluZ0lzQmFsYW5jZWQoc2VsLnRleHQoKSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsLG8pIHsgcmV0dXJuIHRydWU7IH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJiYWNrc3BhY2VcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuZXJhc2UoKTsgfSksXG5cdFx0Y29tYm8oW1wic2hpZnQrYmFja3NwYWNlXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmVyYXNlKCk7IH0pLFxuXHRcdGNvbWJvKFtcImFsdCtiYWNrc3BhY2VcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuZXJhc2UoSU0uV09SRF9TVEFSVCk7IH0pLFxuXHRcdGNvbWJvKFtcInN1cGVyK2JhY2tzcGFjZVwiXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5lcmFzZShJTS5MSU5FX1NUQVJUKTsgfSksXG5cdFx0XG5cdFx0Y29tYm8oW1wicmV0dXJuXCIsJ3NoaWZ0K3JldHVybicsJ3N1cGVyK3JldHVybiddLGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0dmFyIGluZCA9IHNlbC5pbmRlbnQoKTtcblx0XHRcdGlmICh1dGlsLmluY3JlYXNlSW5kZW50KHNlbC5oZWFkKCkucGVla2JlaGluZCgpKSkgeyBpbmQgKz0gJ1xcdCcgfTtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIG5vdCBoYXBwZW4gaW4gc3RyaW5nXG5cdFx0XHRpZiAoaWR4JChzZWwucmVnaW9uKCkucGVlaygtMSwxKSxbJ1tdJywne30nLCcoKSddKSA+PSAwKSB7XG5cdFx0XHRcdHNlbC5pbnNlcnQoJ1xcblxcdCcgKyBpbmQpO1xuXHRcdFx0XHRzZWwudmlldygpLmluc2VydChzZWwuaGVhZCgpLmxvYygpLCdcXG4nICsgaW5kKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbC5pbnNlcnQoJ1xcbicgKyBpbmQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSksXG5cdFx0XG5cdFx0XG5cdFx0Y29tYm8oWydzcGFjZScsJ3NoaWZ0K3NwYWNlJ10sZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRpZiAoc2VsLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gJzw+Jykge1xuXHRcdFx0XHRzZWwubW92ZSgxKS5lcmFzZSgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbC5pbnNlcnQoJyAnKTtcblx0XHR9KSxcblx0XHRcblx0XHRjb21ibyhbJ3RhYiddLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgnXFx0Jyk7IH0pLFxuXHRcdFxuXHRcdFxuXHRcdGNvbWJvKFsnc3VwZXIrdXAnXSxmdW5jdGlvbihzZWwpIHtcblx0XHRcdHNlbC5jb2xsYXBzZSgpLmhlYWQoKS5zZXQoMCwwKS5ub3JtYWxpemUoKTtcblx0XHRcdHJldHVybiBzZWwuZGlydHkoKTtcblx0XHR9KSxcblx0XHRcblx0XHRjb21ibyhbJ3N1cGVyK2Rvd24nXSxmdW5jdGlvbihzZWwpIHtcblx0XHRcdHNlbC5jb2xsYXBzZSgpLmhlYWQoKS5zZXQoMTAwMDAwLDApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmV0dXJuIHNlbC5kaXJ0eSgpO1xuXHRcdH0pLFxuXHRcdFxuXHRcdGNvbWJvKFsnc3VwZXIrdSddLGZ1bmN0aW9uKHNlbCxvKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhzZWwudGFyZ2V0KCksXCJmb3VuZCB1dCEhIVwiKTtcblx0XHRcdHJldHVybiBjb25zb2xlLmxvZyhzZWwudGFyZ2V0KCkuYnViYmxlKCd1bndyYXAnLHt9KSk7XG5cdFx0fSksXG5cdFx0XG5cdFx0Y29tYm8oWydhbHQrc3VwZXIrciddLGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpOyB9KVxuXHRdO1xuXHRcblx0SU0uVHJpZ2dlcnMgPSBbXG5cdFx0XG5cdFx0dHJpZ2dlcignfCcse2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gJ3x8JzsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5tb3ZlKDEpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcignWycsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCdbJDBdJyk7IH0pLFxuXHRcdHRyaWdnZXIoJ3wnLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgnfCQwfCcpOyB9KSxcblx0XHR0cmlnZ2VyKCcoJyxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJygkMCknKTsgfSksXG5cdFx0dHJpZ2dlcigneycsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCd7JDB9Jyk7IH0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJzwnLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuICFzZWwucGVla2JlaGluZCgvKFxcYih0YWd8aWZ8Y2xhc3MpIHxcXGRcXHMqJCkvKTsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJzwkMD4nKTsgfX0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJ1wiJyx7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHtcblx0XHRcdGlmIChzZWwucmVnaW9uKCkucGVlaygtMSwwKSA9PSAnXFxcXCcgJiYgKG8ubm9kZSA9IHNlbC5yZWdpb24oKS5zY29wZShxJCgnLl9pbXN0cicsc2VsZikpKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJ1wiJyk7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKFwiJ1wiLHtjb250ZXh0OiBmdW5jdGlvbihzZWwsbykgeyByZXR1cm4gc2VsLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gXCInJ1wiOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLm1vdmUoMSk7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKFwiJ1wiLHtjb250ZXh0OiBmdW5jdGlvbihzZWwsbykgeyByZXR1cm4gby5ub2RlID0gc2VsLnJlZ2lvbigpLnNjb3BlKHEkKCcuX2ltc3RyJyxzZWxmKSk7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KFwiXFxcXCdcIik7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKCdcIicsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCdcIiQwXCInKTsgfSksXG5cdFx0dHJpZ2dlcihcIidcIixmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoXCInJDAnXCIpOyB9KSxcblx0XHRcblx0XHR0cmlnZ2VyKCddJyx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwucmVnaW9uKCkucGVlaygwLDEpID09ICddJzsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5tb3ZlKDEpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcignfScse2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnJlZ2lvbigpLnBlZWsoMCwxKSA9PSAnfSc7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwubW92ZSgxKTsgfX0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJyknLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5yZWdpb24oKS5wZWVrKDAsMSkgPT0gJyknOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLm1vdmUoMSk7IH19KVxuXHRdO1xuXHRcblx0ZnVuY3Rpb24gU2hvcnRjdXRNYW5hZ2VyKHZpZXcsYmluZGluZ3Mpe1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHRcdHRoaXMuX2JpbmRpbmdzID0gYmluZGluZ3MgfHwgSU0uS2V5QmluZGluZ3M7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGdsb2JhbC5TaG9ydGN1dE1hbmFnZXIgPSBTaG9ydGN1dE1hbmFnZXI7IC8vIGdsb2JhbCBjbGFzcyBcblx0U2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXc7XG5cdH07XG5cdFxuXHRTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmtleXNGb3JFdmVudCA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgY29tYm8gPSBbXTtcblx0XHR2YXIgc3BlY2lhbCA9IHNwZWNpYWxLZXlzW2Uud2hpY2hdO1xuXHRcdHZhciBjaHIgPSBzcGVjaWFsIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCk7XG5cdFx0XG5cdFx0Y2hyID0gY2hyLnRvTG93ZXJDYXNlKCk7IC8vIHVubGVzcyBlOnNoaWZ0S2V5XG5cdFx0XG5cdFx0aWYgKGUuY3RybEtleSAmJiBzcGVjaWFsICE9ICdjdHJsJykgeyBjb21iby5wdXNoKCdjdHJsJykgfTtcblx0XHRpZiAoZS5hbHRLZXkgJiYgc3BlY2lhbCAhPSAnYWx0JykgeyBjb21iby5wdXNoKCdhbHQnKSB9O1xuXHRcdGlmIChlLm1ldGFLZXkgJiYgIWUuY3RybEtleSAmJiBzcGVjaWFsICE9PSAnbWV0YScpIHsgY29tYm8ucHVzaCgnc3VwZXInKSB9O1xuXHRcdGlmIChlLnNoaWZ0S2V5ICYmIHNwZWNpYWwgIT0gJ3NoaWZ0JykgeyBjb21iby5wdXNoKCdzaGlmdCcpIH07XG5cdFx0aWYgKGNvbWJvLmluZGV4T2YoY2hyKSA8IDApIHsgY29tYm8ucHVzaChjaHIpIH07XG5cdFx0XG5cdFx0cmV0dXJuIGNvbWJvLmpvaW4oJysnKTtcblx0fTtcblx0XG5cdFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUuY29tbWFuZHNGb3JLZXlzID0gZnVuY3Rpb24gKGNvbWJvKXtcblx0XHRyZXR1cm4gdGhpcy5fYmluZGluZ3MuZmlsdGVyKGZ1bmN0aW9uKGJpbmRpbmcpIHsgcmV0dXJuIGJpbmRpbmcua2V5cyA9PSBjb21ibzsgfSk7XG5cdH07XG5cdFxuXHRTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmdldFNob3J0Y3V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdHZhciBjb21ibyA9IHRoaXMua2V5c0ZvckV2ZW50KGUuZXZlbnQoKSk7XG5cdFx0Y29uc29sZS5sb2coY29tYm8pO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9iaW5kaW5ncyksIGxlbiA9IGFyeS5sZW5ndGgsIGNtZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbWQgPSBhcnlbaV07XG5cdFx0XHRpZiAoY21kLmtleXMuaW5kZXhPZihjb21ibykgPj0gMCkge1xuXHRcdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnZm91bmQgc2hvcnRjdXQnLGNvbWJvLGNtZDprZXlzXG5cdFx0XHRcdGlmICghY21kLmNvbnRleHQgfHwgY21kLmNvbnRleHQuY2FsbCh0aGlzLnZpZXcoKSx0aGlzLnZpZXcoKS5jYXJldCgpLG8sZSx0aGlzLnZpZXcoKSkpIHtcblx0XHRcdFx0XHRjbWQuZGF0YSA9IG87XG5cdFx0XHRcdFx0cmV0dXJuIGNtZDtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUuZ2V0VHJpZ2dlciA9IGZ1bmN0aW9uICh2aWV3LHRleHQpe1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChJTS5UcmlnZ2VycyksIGxlbiA9IGFyeS5sZW5ndGgsIGNtZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbWQgPSBhcnlbaV07XG5cdFx0XHRpZiAoY21kLnRyaWdnZXIgPT0gdGV4dCkge1xuXHRcdFx0XHR2YXIgcmVzID0gY21kLmNvbnRleHQgPyAoY21kLmNvbnRleHQuY2FsbCh2aWV3LHZpZXcuY2FyZXQoKSx2aWV3LHRleHQpKSA6ICh0cnVlKTtcblx0XHRcdFx0aWYgKHJlcykgeyByZXR1cm4gY21kIH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdHJldHVybiBTaG9ydGN1dE1hbmFnZXI7XG5cdFxuXHRcblx0XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9zaG9ydGN1dHMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWNhcHRvcicsICdpbnB1dCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICghdGhpcy5kb20oKS52YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLnZhbHVlID0gJ3gnO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuZG9tKCkuc2VsZWN0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHRhZy5fX3N1cGVyX18uYnVpbGQuYXBwbHkoc2VsZixhcmd1bWVudHMpO1xuXHRcdFx0c2VsZi5kb20oKS5vbmZvY3VzID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnZG9tIG9uZm9jdXMhISEhJyk7XG5cdFx0XHRcdHZhciBldmVudCA9IEltYmEuRXZlbnQud3JhcCh7dHlwZTogJ2lucHV0Zm9jdXMnLHRhcmdldDogc2VsZi5kb20oKX0pO1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQucHJvY2VzcygpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0c2VsZi5kb20oKS5vbmJsdXIgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdkb20gb25ibHVyISEhIScsZSk7XG5cdFx0XHRcdHZhciBldmVudCA9IEltYmEuRXZlbnQud3JhcCh7dHlwZTogJ2lucHV0Ymx1cicsdGFyZ2V0OiBzZWxmLmRvbSgpLHJlbGF0ZWRUYXJnZXQ6IGUucmVsYXRlZFRhcmdldH0pO1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQucHJvY2VzcygpO1xuXHRcdFx0XHQvLyBJbWJhLkV2ZW50cy50cmlnZ2VyKCdpbnB1dGJsdXInLGRvbSlcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvdmlld3MvY2FwdG9yLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdC8vIGRpc2FibGluZyBsb2dzIGZvciBub3dcblx0Ly8gY29uc29sZTpsb2cgPSBkbyB0cnVlXG5cdC8vIGV4dGVybnM7XG5cdFxuXHR2YXIgT1BFTiA9IFsnXCInLFwiJ1wiLCcoJywnWycsJ3snLCc8J107XG5cdHZhciBDTE9TRSA9IFsnXCInLFwiJ1wiLCcpJywnXScsJ30nLCc+J107XG5cdFxuXHRpZiAoSW1iYS5FdmVudHMpIHtcblx0XHRJbWJhLkV2ZW50cy5yZWdpc3RlcihbJ2NvcHknLCdwYXN0ZScsJ2N1dCcsJ2JlZm9yZWN1dCcsJ2JlZm9yZXBhc3RlJywnYmVmb3JlY29weScsJ2tleXByZXNzJ10pO1xuXHR9O1xuXHRcblx0dmFyIExvZ2dlciA9IHJlcXVpcmUoJy4vY29yZS9sb2dnZXInKS5Mb2dnZXI7XG5cdHZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi9jb3JlL2hpc3RvcnknKS5IaXN0b3J5O1xuXHR2YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9jb3JlL2J1ZmZlcicpLkJ1ZmZlcjtcblx0dmFyIE9ic2VydmVyID0gcmVxdWlyZSgnLi9jb3JlL29ic2VydmVyJykuT2JzZXJ2ZXI7XG5cdFxuXHR2YXIgUmVnaW9uID0gcmVxdWlyZSgnLi9yZWdpb24nKS5SZWdpb247XG5cdHZhciBoaW50cyQgPSByZXF1aXJlKCcuL2NvcmUvaGludHMnKSwgSGludHMgPSBoaW50cyQuSGludHMsIEhpbnQgPSBoaW50cyQuSGludDtcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdFxuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cdFxuXHRyZXF1aXJlKCcuL2NvcmUvY2FyZXQnKTtcblx0XG5cdHJlcXVpcmUoJy4vdmlld3Mvb3ZlcmxheXMnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWRpbXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2ggPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIHVuY2FjaGVcblx0XHRcdGlmICh0aGlzLl9vdyAhPSB0aGlzLmRvbSgpLm9mZnNldFdpZHRoKSB7XG5cdFx0XHRcdHRoaXMuX293ID0gdGhpcy5kb20oKS5vZmZzZXRXaWR0aDtcblx0XHRcdFx0dGhpcy5fY2ggPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2NoIHx8ICh0aGlzLl9jaCA9IHRoaXMuZG9tKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltdmlld2JvZHknKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXZpZXcnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZmlsZW5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRGaWxlbmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9maWxlbmFtZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub2JzZXJ2ZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29ic2VydmVyOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRPYnNlcnZlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vYnNlcnZlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGlzdG9yeTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGlzdG9yeSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oaXN0b3J5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oaW50cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGludHM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhpbnRzID0gZnVuY3Rpb24odil7IHRoaXMuX2hpbnRzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2dnZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2xvZ2dlcjsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TG9nZ2VyID0gZnVuY3Rpb24odil7IHRoaXMuX2xvZ2dlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2hvcnRjdXRzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zaG9ydGN1dHM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNob3J0Y3V0cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9zaG9ydGN1dHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fZm9jdXNOb2RlID0ge3dhdGNoOiAnZm9jdXNOb2RlRGlkU2V0JyxuYW1lOiAnZm9jdXNOb2RlJ307XG5cdFx0dGFnLnByb3RvdHlwZS5mb2N1c05vZGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2ZvY3VzTm9kZTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Rm9jdXNOb2RlID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMuZm9jdXNOb2RlKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fZm9jdXNOb2RlID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuZm9jdXNOb2RlRGlkU2V0ICYmIHRoaXMuZm9jdXNOb2RlRGlkU2V0KHYsYSx0aGlzLl9fZm9jdXNOb2RlKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2FyZXQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NhcmV0OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDYXJldCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jYXJldCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZnJhbWVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9mcmFtZXM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEZyYW1lcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9mcmFtZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlYWRvbmx5ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZWFkb25seTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmVhZG9ubHkgPSBmdW5jdGlvbih2KXsgdGhpcy5fcmVhZG9ubHkgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhpZ2hsaWdodGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gSGlnaGxpZ2h0ZXI7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxpbmVIZWlnaHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kaW1zLmRvbSgpLm9mZnNldEhlaWdodDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2hhcldpZHRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGltcy5jaCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc1JlYWRPbmx5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5oaXN0b3J5KCkubW9kZSgpID09ICdwbGF5Jztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGFiU2l6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIDQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnYnVpbGQgaW12aWV3J1xuXHRcdFx0VklFVyA9IHRoaXM7XG5cdFx0XHR0aGlzLnNldFRhYmluZGV4KDApO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9yZWFkb25seSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcih0aGlzKTtcblx0XHRcdHRoaXMuX2ZyYW1lcyA9IDA7XG5cdFx0XHR0aGlzLl9jaGFuZ2VzID0gMDtcblx0XHRcdFxuXHRcdFx0dGhpcy5faGludHMgPSBuZXcgSGludHModGhpcyk7XG5cdFx0XHR0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMpO1xuXHRcdFx0dGhpcy5faGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMpO1xuXHRcdFx0dGhpcy5fc2hvcnRjdXRzID0gbmV3IFNob3J0Y3V0TWFuYWdlcih0aGlzKTtcblx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHR0aGlzLl9vYnNlcnZlciA9IG5ldyBPYnNlcnZlcih0aGlzKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5zZXRSZWdpb24obmV3IFJlZ2lvbigwLDAsdGhpcy5yb290KCksdGhpcykpO1xuXHRcdFx0XG5cdFx0XHQvLyBiaW5kIHRvIG1vdXNlbW92ZSBvZiBkb20/XG5cdFx0XHRcblx0XHRcdHRoaXMuZG9tKCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJyxmdW5jdGlvbihlKSB7IHJldHVybiBJbWJhLkV2ZW50cy5kZWxlZ2F0ZShlKTsgfSk7XG5cdFx0XHR0aGlzLmRvbSgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JyxmdW5jdGlvbihlKSB7IHJldHVybiBJbWJhLkV2ZW50cy5kZWxlZ2F0ZShlKTsgfSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldElucHV0ID0gZnVuY3Rpb24gKGlucHV0KXtcblx0XHRcdFxuXHRcdFx0aWYgKGlucHV0ICE9IHRoaXMuX2lucHV0KSB7XG5cdFx0XHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdzZXQgaW5wdXQhISEnLEBpbnB1dFxuXHRcdFx0XHR0aGlzLl9pbnB1dC5kb20oKS5fcmVzcG9uZGVyID0gdGhpcy5kb20oKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5wdXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9pbnB1dCB8fCB0aGlzLl9jYXJldC5pbnB1dCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY2FsbGVkIGV2ZXJ5IGZyYW1lIC0gbG9va2luZyBmb3IgY2hhbmdlZCBub2RlcyB0byBkZWFsIHdpdGhcblx0XHQvLyB0byBkZWFsIHdpdGggbXV0YXRpb25zLlxuXHRcdHRhZy5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5fZnJhbWVzKys7XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS50aWNrKCk7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB0aGlzLnJlcGFpcigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudGljaygpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBsb2dnZXJfO1xuXHRcdFx0KGxvZ2dlcl8gPSB0aGlzLmxvZ2dlcigpKS5sb2cuYXBwbHkobG9nZ2VyXyxhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVkaXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0c2VsZi5fY2hhbmdlcysrO1xuXHRcdFx0c2VsZi5fZGlydHkgPSB0cnVlO1xuXHRcdFx0c2VsZi5fYnVmZmVyLnJlZnJlc2goKTtcblx0XHRcdFxuXHRcdFx0c2VsZi52aWV3KCkuaGludHMoKS5yZW0oZnVuY3Rpb24oaGludCkge1xuXHRcdFx0XHRyZXR1cm4gaGludC5ncm91cCgpID09ICdydW50aW1lJztcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRzZWxmLmhpbnRzKCkuY2xlYW51cCgpO1xuXHRcdFx0XG5cdFx0XHRzZWxmLmRlbGF5KCdkaWRjaGFuZ2UnLDUwLGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gSW1iYS5FdmVudHMudHJpZ2dlcignZWRpdGVkOmFzeW5jJyxzZWxmLHtkYXRhOiBzZWxmfSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gd2UgY2FuIGltcHJvdmUgaG93L3doZW4gd2UgY2hvb3NlIHRvIGFubm90YXRlLlxuXHRcdFx0Ly8gY3VycmVudGx5IHdlIGRvIGl0IGFmdGVyIGV2ZXJ5IGVkaXQgLSBidXQgaXQgc2hvdWxkXG5cdFx0XHQvLyByZWFsbHkgb25seSBiZSBuZWVkZWQgd2hlbiB3ZSBoYXZlIGNoYW5nZWQgaWRlbnRpZmllcnMuXG5cdFx0XHQvLyBzaG91bGQgYWxzbyBvbmx5IHJlYW5ub3RhdGUgdGhlIGNsb3Nlc3Qga25vd24gc2NvcGUsXG5cdFx0XHQvLyBidXQgdGhpcyBjb21lcyBsYXRlciB3aXRoIHJlZmFjdG9yaW5nIGZyb20gd2hvbGUgZmlsZXNcblx0XHRcdC8vIHRvIHNjb3Blcy5cblx0XHRcdHNlbGYuZGVsYXkoJ2Fubm90YXRlJyw1MDAsZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLmFubm90YXRlKCk7IH0pO1xuXHRcdFx0c2VsZi5kZWxheSgncmVjb21waWxlJywtMSk7IC8vIGNhbmNlbCByZWNvbXBpbGF0aW9uXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5mbGFnKCdhY3RpdmUnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnVuZmxhZygnYWN0aXZlJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX2JvZHk9dGhpcy5fYm9keSB8fCB0YWckLiRpbXZpZXdib2R5KCkuc2V0UmVmKCdib2R5Jyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdCh0aGlzLl9kaW1zID0gdGhpcy5fZGltcyB8fCB0YWckLiRpbWRpbXMoKS5zZXRSZWYoJ2RpbXMnLHRoaXMpKS5zZXRUZXh0KFwieFwiKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMuX2NhcmV0ID0gdGhpcy5fY2FyZXQgfHwgdGFnJC4kaW1jYXJldCgpLnNldFJlZignY2FyZXQnLHRoaXMpKS5zZXRWaWV3KHRoaXMpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy5fcm9vdCA9IHRoaXMuX3Jvb3QgfHwgdGFnJC4kaW1yb290KCkuc2V0UmVmKCdyb290Jyx0aGlzKS5mbGFnKCdpbWJhJykpLnNldFZpZXcodGhpcykuZW5kKClcblx0XHRcdF0sMikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhlYWRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZvb3RlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm92ZXJsYXlzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX292ZXJsYXlzID0gdGhpcy5fb3ZlcmxheXMgfHwgdGFnJC4kc2NyaW1ibGFfb3ZlcmxheXMoKS5zZXRSZWYoJ292ZXJsYXlzJyx0aGlzKSkuc2V0Vmlldyh0aGlzKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdyZWFkb25seScsdGhpcy5pc1JlYWRPbmx5KCkpLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGhpcy5oZWFkZXIoKSxcblx0XHRcdFx0dGhpcy5ib2R5KCksXG5cdFx0XHRcdHRoaXMuZm9vdGVyKClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWwgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNhcmV0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9yb290O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWZmZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9idWZmZXI7XG5cdFx0XHQvLyByb290LmNvZGVcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMucm9vdCgpLnNpemUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdFx0dmFyIHBhcnNlZDtcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0dGhpcy5zZXRGaWxlbmFtZShvLmZpbGVuYW1lKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdsb2FkaW5nIGZpbGUgd2l0aCBmaWxlbmFtZScsbzpmaWxlbmFtZVxuXHRcdFx0Ly8gb2JzZXJ2ZXIucGF1c2UgZG9cblx0XHRcdGlmIChvLmh0bWwpIHtcblx0XHRcdFx0dGhpcy5yb290KCkuZG9tKCkuaW5uZXJIVE1MID0gby5odG1sO1xuXHRcdFx0XHR0aGlzLl9idWZmZXIucmVmcmVzaCgpO1xuXHRcdFx0XHR0aGlzLmhpc3RvcnkoKS5vbmxvYWQodGhpcy5jb2RlKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc2hvdWxkIHVzZSBvdXIgbmV3IHBhcnNlclxuXHRcdFx0XHRpZiAocGFyc2VkID0gdGhpcy5wYXJzZShjb2RlKSkge1xuXHRcdFx0XHRcdGlmIChwYXJzZWQuaGlnaGxpZ2h0ZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMucm9vdCgpLmRvbSgpLmlubmVySFRNTCA9IHBhcnNlZC5oaWdobGlnaHRlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yb290KCkuZG9tKCkudGV4dENvbnRlbnQgPSBjb2RlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuX2J1ZmZlci5yZWZyZXNoKCk7XG5cdFx0XHRcdHRoaXMuaGlzdG9yeSgpLm9ubG9hZChjb2RlKTtcblx0XHRcdFx0dGhpcy5hbm5vdGF0ZSgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdC8vIGhlcmUgd2UgY2FuIHBhcnNlIHRoZSBmdWxsIGNvZGVcblx0XHRcdHJldHVybiB7aGlnaGxpZ2h0ZWQ6IElNLnBhcnNlKGNvZGUpfTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVmb2N1cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5pbnB1dCgpLmRvbSgpKSB7IHRoaXMuaW5wdXQoKS5mb2N1cygpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dGZvY3VzID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Y29uc29sZS5sb2coJ29uaW5wdXRmb2N1cyEhJyk7XG5cdFx0XHRWSUVXID0gdGhpczsgLy8gaGFja1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnZm9jdXMnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dGJsdXIgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gdGhpcy51bmZsYWcoJ2ZvY3VzJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZm9jdXNpbiA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdFZJRVcgPSB0aGlzOyAvLyBoYWNrXG5cdFx0XHR0aGlzLmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHRjb25zb2xlLmxvZygnZm9jdXMnLGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZm9jdXNvdXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLnVuZmxhZygnZm9jdXMnKTtcblx0XHRcdGNvbnNvbGUubG9nKCd1bmZvY3VzJyxlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmlucHV0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udGV4dGlucHV0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4ZWNBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uLGtleWRvd24pe1xuXHRcdFx0dmFyIGNvbW1hbmRfO1xuXHRcdFx0aWYgKGFjdGlvbi5jb21tYW5kIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIGFjdGlvbi5jb21tYW5kLmNhbGwodGhpcyx0aGlzLmNhcmV0KCksYWN0aW9uLmRhdGEgfHwge2V2ZW50OiBrZXlkb3dufSx0aGlzKTtcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiAoY29tbWFuZF8gPSBhY3Rpb24uY29tbWFuZCk9PSdzdHJpbmcnfHxjb21tYW5kXyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0dGhpcy5sb2coJ2NvbW1hbmQgaXMgc3RyaW5nJyxhY3Rpb24uY29tbWFuZCk7XG5cdFx0XHRcdHZhciBldiA9IEltYmEuRXZlbnRzLnRyaWdnZXIoYWN0aW9uLmNvbW1hbmQsdGhpcyx7ZGF0YTogYWN0aW9ufSk7XG5cdFx0XHRcdHRoaXMubG9nKGV2KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50cnlDb21tYW5kID0gZnVuY3Rpb24gKGNtZCx0YXJnZXQscGFyYW1zKXtcblx0XHRcdGlmKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSBwYXJhbXMgPSBbXTtcblx0XHRcdGlmIChjbWQuY29udGV4dCkge1xuXHRcdFx0XHR2YXIgZ3VhcmQgPSBjbWQuY29udGV4dC5hcHBseSh0YXJnZXQgfHwgdGhpcyxwYXJhbXMpO1xuXHRcdFx0XHRpZiAoIWd1YXJkKSB7IHJldHVybiBmYWxzZSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGNtZC5jb21tYW5kIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIGNtZC5jb21tYW5kLmFwcGx5KHRhcmdldCB8fCB0aGlzLHBhcmFtcyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmtleWRvd24gPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgYXJyO1xuXHRcdFx0VklFVyA9IHRoaXM7IC8vIGhhY2tcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0Ly8gdmFyIGNvbWJvID0gZS5rZXljb21ib1xuXHRcdFx0dmFyIGNvbWJvID0gdGhpcy5zaG9ydGN1dHMoKS5rZXlzRm9yRXZlbnQoZS5ldmVudCgpKTtcblx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLnNob3J0Y3V0cygpLmdldFNob3J0Y3V0KGUpO1xuXHRcdFx0dmFyIGlucyA9IG51bGw7XG5cdFx0XHRcblx0XHRcdHZhciBzaGlmdCA9ICgvXFxic2hpZnRcXGIvKS50ZXN0KGNvbWJvKTtcblx0XHRcdHZhciBhbHQgPSAoL1xcYmFsdFxcYi8pLnRlc3QoY29tYm8pO1xuXHRcdFx0dmFyIHN1cCA9ICgvXFxic3VwZXJcXGIvKS50ZXN0KGNvbWJvKTtcblx0XHRcdFxuXHRcdFx0Ly8gbG9nICdpbXZpZXcga2V5ZG93bicsY29tYm9cblx0XHRcdFxuXHRcdFx0aWYgKGFjdGlvbikge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnYWN0aW9uIGhlcmU/IScsYWN0aW9uXG5cdFx0XHRcdGlmICh0aGlzLmV4ZWNBY3Rpb24oYWN0aW9uLGUpKSB7IGUuY2FuY2VsKCkgfTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbW92ZSB0aGVzZSBpbnRvIGNvbW1hbmRzIGFzIHdlbGxcblx0XHRcdC8vIHRoaXNzaG91bGQgbW92ZSB0aGlzIGludG8gY29tbWFuZHMgaW5zdGVhZFxuXHRcdFx0aWYgKGFyciA9IGNvbWJvLm1hdGNoKC9cXGIobGVmdHxyaWdodHx1cHxkb3duKS8pKSB7XG5cdFx0XHRcdHRoaXMuaGludHMoKS5hY3RpdmF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGlzQ29sbGFwc2VkID0gdGhpcy5jYXJldCgpLmlzQ29sbGFwc2VkKCk7XG5cdFx0XHRcdHZhciBlbmRzID0gdGhpcy5jYXJldCgpLmVuZHMoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHNoaWZ0ID8gKHRoaXMuY2FyZXQoKS5kZWNvbGxhcHNlKCkpIDogKHRoaXMuY2FyZXQoKS5jb2xsYXBzZSgpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhcnJbMF0gPT0gJ2Rvd24nKSB7XG5cdFx0XHRcdFx0dGhpcy5jYXJldCgpLm1vdmVEb3duKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGUuY2FuY2VsKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJyWzBdID09ICd1cCcpIHtcblx0XHRcdFx0XHR0aGlzLmNhcmV0KCkubW92ZVVwKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGUuY2FuY2VsKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgbW9kZSA9IElNLkNIQVJBQ1RFUlM7XG5cdFx0XHRcdHZhciBkaXIgPSAwO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGFyclswXSA9PSAnbGVmdCcpIHtcblx0XHRcdFx0XHRkaXIgPSAtMTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhcnJbMF0gPT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYWx0KSB7XG5cdFx0XHRcdFx0bW9kZSA9IGRpciA+IDAgPyAoSU0uV09SRF9FTkQpIDogKElNLldPUkRfU1RBUlQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN1cCkge1xuXHRcdFx0XHRcdG1vZGUgPSBkaXIgPiAwID8gKElNLkxJTkVfRU5EKSA6IChJTS5MSU5FX1NUQVJUKTtcblx0XHRcdFx0fSBlbHNlIGlmICghc2hpZnQgJiYgIWlzQ29sbGFwc2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5jYXJldCgpLmhlYWQoKS5zZXQoZGlyID4gMCA/IChlbmRzWzFdKSA6IChlbmRzWzBdKSk7XG5cdFx0XHRcdFx0dGhpcy5jYXJldCgpLmRpcnR5KCk7IC8vIHNob3VsZCBub3QgbmVlZCB0byBjYWxsIHRoaXMgYWxsIHRoZSB0aW1lXG5cdFx0XHRcdFx0cmV0dXJuIGUuY2FuY2VsKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmNhcmV0KCkubW92ZShkaXIsbW9kZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZS5jYW5jZWwoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChlLmV2ZW50KCkud2hpY2ggPT0gMjI5KSB7XG5cdFx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjb21iby5tYXRjaCgvXnN1cGVyXFwrKGN8dnx4KSQvKSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnbWF0Y2hpbmcgY29tYm8gZm9yIGNvcHkgcGFzdGUnXG5cdFx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0XHR0aGlzLl9hd2FpdENvbWJvID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5yZWZvY3VzKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChpbnMgIT0gbnVsbCkge1xuXHRcdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdFx0dGhpcy5jYXJldCgpLmluc2VydChpbnMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmtleXByZXNzID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0aWYgKHRoaXMuX2F3YWl0Q29tYm8pIHtcblx0XHRcdFx0dGhpcy5fYXdhaXRDb21ibyA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdHZhciB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLmV2ZW50KCkuY2hhckNvZGUpO1xuXHRcdFx0ZS5fdGV4dCA9IHRleHQ7XG5cdFx0XHRlLmNhbmNlbCgpO1xuXHRcdFx0dGhpcy5vbnR5cGUoZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250ZXh0aW5wdXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdGUuX3RleHQgPSBlLmV2ZW50KCkuZGF0YTtcblx0XHRcdHRoaXMub250eXBlKGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ua2V5dXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmlucHV0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250eXBlID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIGlucyA9IGUuX3RleHQ7XG5cdFx0XHRcdC8vIGxvZyAnb250eXBlJyxlLGluc1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHNwYW5zID0gdGhpcy52aWV3KCkubm9kZXNJblJlZ2lvbih0aGlzLmNhcmV0KCkucmVnaW9uKCksZmFsc2UsdHJ1ZSk7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBzcGFuc1swXTtcblx0XHRcdFx0dmFyIGNtZDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzcGFucy5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdC8vIGxvZyAnc2luZ2xlIG5vZGUgZm9yIG5vZGVzSW5SZWdpb24nLHRhcmdldDpub2RlXG5cdFx0XHRcdFx0aWYgKGNtZCA9IHRhcmdldC5ub2RlWyhcInRyaWdnZXItXCIgKyBpbnMpXSkge1xuXHRcdFx0XHRcdFx0Ly8gbG9nIFwiZm91bmQgY29tYm8gZm9yIHRoaXMhPz8hXCIsY21kXG5cdFx0XHRcdFx0XHRpZiAodGhpcy50cnlDb21tYW5kKGNtZCx0aGlzLmNhcmV0KCksW3RhcmdldC5ub2RlLHRhcmdldF0pKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y21kID0gdGhpcy5zaG9ydGN1dHMoKS5nZXRUcmlnZ2VyKHRoaXMsaW5zKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjbWQgJiYgKGNtZC5jb21tYW5kIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG5cdFx0XHRcdFx0Ly8gbG9nICdmb3VuZCBjb21tYW5kISEnLGNtZFxuXHRcdFx0XHRcdC8vIHNob3VsZCByYXRoZXIgcnVuIHRyeUNvbW1hbmQ/IT9cblx0XHRcdFx0XHRyZXR1cm4gY21kLmNvbW1hbmQodGhpcy5jYXJldCgpLHRoaXMsaW5zLGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpbnMpIHsgcmV0dXJuIHRoaXMuY2FyZXQoKS5pbnNlcnQoaW5zKSB9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5sb2coJ2Vycm9yIGZyb20gb250eXBlJyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmJhY2tzcGFjZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuY2FuY2VsKCkuaGFsdCgpO1xuXHRcdFx0dGhpcy5jYXJldCgpLmVyYXNlKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uYmVmb3JlY29weSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmIChERUJVRykgeyBjb25zb2xlLmxvZygnb25iZWZvcmVjb3B5JyxlKSB9O1xuXHRcdFx0dGhpcy5pbnB1dCgpLnNlbGVjdCgpO1xuXHRcdFx0dmFyIGRhdGEgPSBlLmV2ZW50KCkuY2xpcGJvYXJkRGF0YTtcblx0XHRcdGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsdGhpcy5jYXJldCgpLnRleHQoKSk7XG5cdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY29weSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmIChERUJVRykgeyBjb25zb2xlLmxvZygnb25jb3B5JyxlLHRoaXMuY2FyZXQoKS50ZXh0KCkpIH07XG5cdFx0XHR2YXIgZGF0YSA9IGUuZXZlbnQoKS5jbGlwYm9hcmREYXRhO1xuXHRcdFx0ZGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJyx0aGlzLmNhcmV0KCkudGV4dCgpKTtcblx0XHRcdGUuaGFsdCgpLmNhbmNlbCgpO1xuXHRcdFx0dGhpcy5yZWZvY3VzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY3V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0aWYgKERFQlVHKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdvbmN1dCcsZSk7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGRhdGEgPSBlLmV2ZW50KCkuY2xpcGJvYXJkRGF0YTtcblx0XHRcdGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsdGhpcy5jYXJldCgpLnRleHQoKSk7XG5cdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdHJldHVybiB0aGlzLmNhcmV0KCkuZXJhc2UoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25iZWZvcmVwYXN0ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiBjb25zb2xlLmxvZygnb25iZWZvcmVwYXN0ZScsZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ucGFzdGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRjb25zb2xlLmxvZygnb25wYXN0ZScsZSk7XG5cdFx0XHR2YXIgZGF0YSA9IGUuZXZlbnQoKS5jbGlwYm9hcmREYXRhO1xuXHRcdFx0dmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblx0XHRcdGUuaGFsdCgpLmNhbmNlbCgpO1xuXHRcdFx0dGhpcy5jYXJldCgpLmluc2VydCh0ZXh0KTtcblx0XHRcdHRoaXMucmVmb2N1cygpO1xuXHRcdFx0cmV0dXJuIHRoaXMucmVwYWlyKCk7XG5cdFx0XHQvLyBlZGl0IHRleHQ6IGRhdGFcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gZm9jdXNOb2RlID0gc2VsLm5vZGUgIyBvbmx5IGlmIGl0IGlzIGluc2lkZSB0aGUgc2NvcGU/XG5cdFx0XHQvLyBjYXJldC5yZWdpb24gPSBzZWwucmVnaW9uXG5cdFx0XHR0aGlzLmNhcmV0KCkucmVuZGVyKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdHZhciBmbiA9IG8uY29tbWFuZDtcblx0XHRcdHZhciBhcmdzID0gby5hcmdzIHx8IFtdO1xuXHRcdFx0dmFyIGV2ID0gbmV3IEltYmEuRXZlbnQoe3R5cGU6ICdjb21tYW5kJyx0YXJnZXQ6IHRoaXMuZG9tKCksZGF0YTogb30pO1xuXHRcdFx0ZXYuc2V0RGF0YShvKTtcblx0XHRcdGV2LnByb2Nlc3MoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodG91Y2gpe1xuXHRcdFx0dmFyIGFyeTtcblx0XHRcdHRoaXMuX3JlY3QgPSB0aGlzLl9ib2R5LmRvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAodG91Y2guYnV0dG9uKCkgIT0gMCkgeyByZXR1cm4gfTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvdWNoLl90b3VjaCkge1xuXHRcdFx0XHQvLyBpcyBpdCBub3QgcmVkaXJlY3RlZD9cblx0XHRcdFx0cmV0dXJuIHRvdWNoLnJlZGlyZWN0KHt9KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBlID0gdG91Y2guZXZlbnQoKTtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdC8vIHNlZSBpZiBzaGlmdCBpcyBkb3duPyBzaG91bGQgY2hhbmdlIGJlaGF2aW91clxuXHRcdFx0dmFyIHNoaWZ0ID0gZS5zaGlmdEtleTtcblx0XHRcdC8vIGxvZyAnb250b3VjaHN0YXJ0Jyx0b3VjaCx0b3VjaC54LHRvdWNoLnksZSx0b3VjaC5idXR0b25cblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLnJjRm9yVG91Y2godG91Y2gpKTt2YXIgciA9IGFyeVswXSxjID0gYXJ5WzFdO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2hpZnQpIHtcblx0XHRcdFx0dGhpcy5jYXJldCgpLnNlbGVjdGFibGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY2FyZXQoKS5jb2xsYXBzZSgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5jYXJldCgpLmhlYWQoKS5zZXQocixjKS5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5kaXJ0eSgpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3RvdWNoIHN0YXJ0IHJlZm9jdXM/J1xuXHRcdFx0dGhpcy5yZWZvY3VzKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUueHlUb1Jvd0NvbCA9IGZ1bmN0aW9uICh4LHkpe1xuXHRcdFx0dmFyIGNvbCA9IE1hdGgubWF4KE1hdGgucm91bmQoeCAvIHRoaXMuY2hhcldpZHRoKCkpLDApO1xuXHRcdFx0dmFyIHJvdyA9IE1hdGgubWF4KE1hdGguY2VpbCh5IC8gdGhpcy5saW5lSGVpZ2h0KCkpLDEpO1xuXHRcdFx0cmV0dXJuIFtyb3cgLSAxLGNvbF07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJjRm9yVG91Y2ggPSBmdW5jdGlvbiAodG91Y2gpe1xuXHRcdFx0dmFyIHggPSBNYXRoLm1heCh0b3VjaC54KCkgLSB0aGlzLl9yZWN0LmxlZnQsMCk7XG5cdFx0XHR2YXIgeSA9IE1hdGgubWF4KHRvdWNoLnkoKSAtIHRoaXMuX3JlY3QudG9wLDApO1xuXHRcdFx0cmV0dXJuIHRoaXMueHlUb1Jvd0NvbCh4LHkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRvdWNodXBkYXRlID0gZnVuY3Rpb24gKHRvdWNoKXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHRpZiAodG91Y2guYnV0dG9uKCkgIT0gMCkgeyByZXR1cm4gfTtcblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLnJjRm9yVG91Y2godG91Y2gpKTt2YXIgciA9IGFyeVswXSxjID0gYXJ5WzFdO1xuXHRcdFx0dGhpcy5jYXJldCgpLnNlbGVjdGFibGUoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5oZWFkKCkuc2V0KHIsYykubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRvdWNoZW5kID0gZnVuY3Rpb24gKHRvdWNoKXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHRpZiAodG91Y2guYnV0dG9uKCkgIT0gMCkgeyByZXR1cm4gfTtcblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLnJjRm9yVG91Y2godG91Y2gpKTt2YXIgciA9IGFyeVswXSxjID0gYXJ5WzFdO1xuXHRcdFx0dGhpcy5jYXJldCgpLmhlYWQoKS5zZXQocixjKS5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24gKHJlZyxlZGl0KXtcblx0XHRcdHJlZyA9IFJlZ2lvbi5ub3JtYWxpemUocmVnLHRoaXMpO1xuXHRcdFx0XG5cdFx0XHR2YXIgdGV4dCA9IHJlZy50ZXh0KCk7XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS5vbmVyYXNlKHJlZyx0ZXh0LGVkaXQpO1xuXHRcdFx0XG5cdFx0XHR2YXIgc3BhbnMgPSB0aGlzLm5vZGVzSW5SZWdpb24ocmVnLGZhbHNlLHRydWUpO1xuXHRcdFx0Ly8gZ3JvcHUgdGhlIG5vZGVzXG5cdFx0XHR0aGlzLm9ic2VydmVyKCkucGF1c2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChzcGFucy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0c3BhbnNbMV0ubm9kZS5zZXRQcmV2KHRhZyQuJGltaW5zZXJ0KCkuZmxhZygnZGlydHknKS5lbmQoKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3BhbnNbMF0gJiYgc3BhbnNbMF0ubW9kZSA9PSAnYWxsJykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdyZW1vdmluZyBzaW5nbGUgbm9kZT8hJyk7XG5cdFx0XHRcdFx0dmFyIGJlZm9yZSA9IHNwYW5zWzBdLm5vZGUucHJldigpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHNwYW5zWzBdLm5vZGUuc2V0UHJldih0YWckLiRpbWluc2VydCgpLmZsYWcoJ2RpcnR5JykuZW5kKCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNwYW5zKSwgbGVuID0gYXJ5Lmxlbmd0aCwgc2VsLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Ly8gYnVmZmVyIG5lZWQgdG8gdXBkYXRlZCBkdXJpbmcgdGhpcz9cblx0XHRcdFx0XHRzZWwgPSBhcnlbaV07XG5cdFx0XHRcdFx0cmVzLnB1c2goc2VsLm5vZGUuZXJhc2Uoc2VsLnJlZ2lvbixzZWwubW9kZSxlZGl0KSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gZGVsYXkoJ2Fubm90YXRlJyw1MDApIGRvIGFubm90YXRlXG5cdFx0XHRyZXR1cm4gdGhpcy5lcmFzZWQocmVnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ZWQgPSBmdW5jdGlvbiAobG9jLHN0cil7XG5cdFx0XHRjb25zb2xlLmxvZygnaW5zZXJ0ZWQnLGxvYyxzdHIpO1xuXHRcdFx0dmFyIHJlZyA9IG5ldyBSZWdpb24obG9jLGxvYyArIHN0ci5sZW5ndGgsbnVsbCx0aGlzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmhpbnRzKCkpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldLmFkanVzdChyZWcsdHJ1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gaGludHMuY2xlYW51cFxuXHRcdFx0dGhpcy5lZGl0ZWQoKTtcblx0XHRcdGlmICh1dGlsLmlzV2hpdGVzcGFjZShzdHIpKSB0aGlzLnJlcGFpcigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVyYXNlZCA9IGZ1bmN0aW9uIChyZWcpe1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuaGludHMoKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0uYWRqdXN0KHJlZyxmYWxzZSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5lZGl0ZWQoKTtcblx0XHRcdHJldHVybiB0aGlzLnJlcGFpcigpOyAvLyByZXBhaXIgc3luY2hyb25vdXNseVxuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocG9pbnQsc3RyLGVkaXQpe1xuXHRcdFx0aWYgKHBvaW50IGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHRcdGlmIChwb2ludC5zaXplKCkgPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy5sb2dnZXIoKS53YXJuKCd1bmNvbGxhcHNlZCByZWdpb24gaW4gaW5zZXJ0IGlzIG5vdCBhbGxvd2VkJyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHBvaW50ID0gcG9pbnQuc3RhcnQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMubG9nKCdpbnNlcnQnLHBvaW50LHN0cik7XG5cdFx0XHQvLyBzaG91bGQgbWF5YmUgY3JlYXRlIHRoaXMgYXMgYSBjb21tYW5kIC0gYW5kIHRoZW4gbWFrZSBpdCBoYXBwZW4/XG5cdFx0XHRcblx0XHRcdHRoaXMuaGlzdG9yeSgpLm9uaW5zZXJ0KHBvaW50LHN0cixlZGl0KTtcblx0XHRcdFxuXHRcdFx0Ly8gbG9nICdpbnNlcnQgaW4gdmlldydcblx0XHRcdHZhciBzcGFucyA9IHRoaXMubm9kZXNJblJlZ2lvbihSZWdpb24ubm9ybWFsaXplKHBvaW50LHRoaXMpLGZhbHNlKTtcblx0XHRcdHZhciBtaWQgPSBzcGFuc1swXTtcblx0XHRcdHZhciB0YXJnZXQgPSBtaWQgfHwgc3BhbnMucHJldiB8fCBzcGFucy5uZXh0O1xuXHRcdFx0dmFyIGxmdCA9IHNwYW5zLmxmdCxyZ3QgPSBzcGFucy5yZ3Q7XG5cdFx0XHR2YXIgbm9kZTtcblx0XHRcdHZhciByZWc7XG5cdFx0XHRcblx0XHRcdC8vIGxvZyBzcGFucyxtaWQsbGZ0LHJndFxuXHRcdFx0dGhpcy5sb2coJ2JlZm9yZSBhbmQgYWZ0ZXInLGxmdCxyZ3Qsc3RyKTtcblx0XHRcdFxuXHRcdFx0aWYgKG1pZCkge1xuXHRcdFx0XHR0aGlzLmxvZygnaW5zZXJ0IG1pZCcsbWlkLm5vZGUpO1xuXHRcdFx0XHRtaWQubm9kZS5pbnNlcnQobWlkLnJlZ2lvbixzdHIsZWRpdCxtaWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChyZ3Qpe1xuXHRcdFx0XHRcdGlmIChyZ3QuY2FuUHJlcGVuZChzdHIpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxvZygncHJlcGVuZCcscmd0LHN0cik7XG5cdFx0XHRcdFx0XHRyZ3QuaW5zZXJ0KCdwcmVwZW5kJyxzdHIsZWRpdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRlZChwb2ludCxzdHIpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmd0LmlzRmlyc3QoKSkge1xuXHRcdFx0XHRcdFx0cmd0ID0gcmd0LnBhcmVudCgpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGZpbmQgdGhlIGNsb3Nlc3QgcGFyZW50XG5cdFx0XHRcdHdoaWxlIChsZnQpe1xuXHRcdFx0XHRcdGlmIChsZnQuY2FuQXBwZW5kKHN0cikpIHtcblx0XHRcdFx0XHRcdHRoaXMubG9nKCdhcHBlbmQnLGxmdCxzdHIpO1xuXHRcdFx0XHRcdFx0bGZ0Lmluc2VydCgnYXBwZW5kJyxzdHIsZWRpdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRlZChwb2ludCxzdHIpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGZ0LmlzTGFzdCgpKSB7XG5cdFx0XHRcdFx0XHRsZnQgPSBsZnQucGFyZW50KCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0bm9kZSA9IHRhZyQuJGltaW5zZXJ0KCkuZW5kKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobGZ0KSB7XG5cdFx0XHRcdFx0bGZ0LnNldE5leHQobm9kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmd0KSB7XG5cdFx0XHRcdFx0cmd0LnNldFByZXYobm9kZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbXVzdCBiZSBlbXB0eVxuXHRcdFx0XHRcdHRoaXMucm9vdCgpLmRvbSgpLmFwcGVuZENoaWxkKG5vZGUuZG9tKCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0bm9kZS5pbnNlcnQoJ2FwcGVuZCcsc3RyLGVkaXQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0ZWQocG9pbnQsc3RyKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25tdXRhdGlvbnMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHR2YXIgZWxzID0gdGhpcy5kb20oKS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdkaXJ0eScpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZWxzLmxlbmd0aCkge1xuXHRcdFx0XHQvLyBsb2dnZXIubG9nIFwie2VsczpsZW5ndGh9IGRpcnR5IG5vZGVzIHRvIHJlcGFpclwiXG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBtdXRzID0gW10sIGkgPSAwLCBhcnkgPSBpdGVyJChlbHMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRtdXRzLnB1c2godGFnJHdyYXAoYXJ5W2ldKSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobXV0cyksIGxlbiA9IGFyeS5sZW5ndGgsIG11dDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bXV0ID0gYXJ5W2ldO1xuXHRcdFx0XHRcdG11dC51bmZsYWcoJ2RpcnR5Jyk7XG5cdFx0XHRcdFx0bXV0Lm11dGF0ZWQobXV0cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9yb290LmRvbSgpLnRleHRDb250ZW50O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5mb2N1c05vZGVEaWRTZXQgPSBmdW5jdGlvbiAobmV3JCxvbGQpe1xuXHRcdFx0aWYgKCF0aGlzLnJvb3QoKS5jb250YWlucyhuZXckKSkgeyByZXR1cm4gfTtcblx0XHRcdFxuXHRcdFx0dmFyIHBhdGggPSBbXTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKG5ldyQgJiYgbmV3JCAhPSB0aGlzLnJvb3QoKSl7XG5cdFx0XHRcdHBhdGgucHVzaChuZXckKTtcblx0XHRcdFx0bmV3JCA9IG5ldyQucGFyZW50KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRxJCgnLmZvY3VzXycsdGhpcykubWFwKGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0aWYgKHBhdGguaW5kZXhPZihuKSA8IDApIHsgcmV0dXJuIG4udW5mbGFnKCdmb2N1c18nKSB9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHBhdGhbaV0uZmxhZygnZm9jdXNfJyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlY29tcGlsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gc2hvdWxkIGhhcHBlbiBpbiBhIHNlcGFyYXRlIHRocmVhZCAtIGFuZCBiZSBkZWxheWVkXG5cdFx0XHRjb25zb2xlLmxvZygncmVjb21waWxlJyk7XG5cdFx0XHR2YXIgcmVzO1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXMgPSBJbWJhYy5jb21waWxlKHRoaXMuY29kZSgpLHtiYXJlOiB0cnVlfSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IH07XG5cdFx0XHRcblx0XHRcdGlmIChyZXMpIHtcblx0XHRcdFx0dGhpcy5jb21waWxlZChyZXMpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygncmVwYXJzZScpO1xuXHRcdFx0dGhpcy5yb290KCkucmVoaWdobGlnaHQoe2lubmVyOiB0cnVlfSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29tcGlsZWQgPSBmdW5jdGlvbiAocmVzKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnJ1bmVycm9yID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Y29uc29sZS5sb2coJ29ucnVuZXJyb3InLGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFkZEVycm9yID0gZnVuY3Rpb24gKG1zZyxsb2Mpe1xuXHRcdFx0dmFyIG5vZGU7XG5cdFx0XHR2YXIgcmVnID0gUmVnaW9uLm5vcm1hbGl6ZShsb2MsdGhpcyk7XG5cdFx0XHRjb25zb2xlLmxvZygnZm91bmQgd2FybmluZ3MnLHJlZyxtc2csbG9jKTtcblx0XHRcdGlmIChub2RlID0gdGhpcy5ub2RlQXRSZWdpb24ocmVnKSkge1xuXHRcdFx0XHR0aGlzLmxvZygnbm9kZSBhdCByZWdpb24gaXM/IScsbm9kZSk7XG5cdFx0XHRcdG1zZyA9IG1zZy5zcGxpdCgvZXJyb3IgYXQgKFxcW1tcXGRcXDpdKlxcXSlcXDpcXHMqLykucG9wKCk7XG5cdFx0XHRcdG5vZGUuZmxhZygnZXJyJyk7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdlcnJvcicsbXNnKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLmRlbGF5KCdhbm5vdGF0ZScsLTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFubm90YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnYW5ub3RhdGUnXG5cdFx0XHRcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBzdGF0ZSA9IHNlbGYucm9vdCgpLmNvZGVTdGF0ZSgpO1xuXHRcdFx0dmFyIGNvZGUgPSBzdGF0ZS5jb2RlO1xuXHRcdFx0XG5cdFx0XHR2YXIgYXBwbHkgPSBmdW5jdGlvbihtZXRhKSB7XG5cdFx0XHRcdHZhciB2YXJzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChtZXRhLnNjb3BlcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBpdGVtcyA9IGl0ZXIkKGFyeVtpXS52YXJzKSwgbGVuXyA9IGl0ZW1zLmxlbmd0aDsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHRcdFx0dmFycy5wdXNoKGl0ZW1zW2pdKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHdhcm5pbmdzID0gbWV0YS53YXJuaW5ncyB8fCBbXTtcblx0XHRcdFx0dmFyIG9sZFdhcm5pbmdzID0gc2VsZi5oaW50cygpLmZpbHRlcihmdW5jdGlvbihoaW50KSB7IHJldHVybiBoaW50Lmdyb3VwKCkgPT0gJ2FuYWx5c2lzJzsgfSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAob2xkV2FybmluZ3MpIHtcblx0XHRcdFx0XHQvLyBjb3VsZCBpbnRlbGxpZ2VudGx5IGtlZXAgdGhlbSBpbnN0ZWFkXG5cdFx0XHRcdFx0c2VsZi5oaW50cygpLnJlbShvbGRXYXJuaW5ncyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQod2FybmluZ3MpLCBsZW4gPSBhcnkubGVuZ3RoLCB3YXJuOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHR3YXJuID0gYXJ5W2ldO1xuXHRcdFx0XHRcdHdhcm4udHlwZSB8fCAod2Fybi50eXBlID0gJ2Vycm9yJyk7XG5cdFx0XHRcdFx0d2Fybi5ncm91cCA9ICdhbmFseXNpcyc7XG5cdFx0XHRcdFx0c2VsZi5oaW50cygpLmFkZCh3YXJuKS5hY3RpdmF0ZSgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHdhcm5pbmdzLmxlbmd0aCkgeyByZXR1cm4gc2VsZiB9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIG5vZGVzID0gSU0udGV4dE5vZGVzKHNlbGYucm9vdCgpLmRvbSgpLHRydWUpO1xuXHRcdFx0XHQvLyB3aGF0IGFib3V0IHJlbW92aW5nIG9sZCB3YXJuaW5ncz9cblx0XHRcdFx0XG5cdFx0XHRcdHZhciBtYXAgPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbm9kZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGFyeVtpXTtcblx0XHRcdFx0XHRtYXBbbm9kZS5fbG9jXSA9IG5vZGU7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBnZXQgdGV4dE5vZGVzIHdpdGggbWFwcGluZyghKVxuXHRcdFx0XHRmb3IgKHZhciBpMSA9IDAsIGxlbiA9IHZhcnMubGVuZ3RoOyBpMSA8IGxlbjsgaTErKykge1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwLCBhcnkgPSBpdGVyJCh2YXJzW2kxXS5yZWZzKSwgbGVuXyA9IGFyeS5sZW5ndGgsIHJlZjsgayA8IGxlbl87IGsrKykge1xuXHRcdFx0XHRcdFx0cmVmID0gYXJ5W2tdO1xuXHRcdFx0XHRcdFx0dmFyIGEgPSByZWYubG9jWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSByZWYubG9jWzFdO1xuXHRcdFx0XHRcdFx0dmFyIGVyZWYgPSAoXCJ2XCIgKyBpMSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChtYXBbYV0pIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRvbSA9IG1hcFthXS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHR2YXIgb2xkUmVmID0gZG9tLmdldEF0dHJpYnV0ZSgnZXJlZicpO1xuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnc2V0dGluZyB0aGUgcmVmIGZvciBub2RlPycsZG9tLGRvbS5AdGFnXG5cdFx0XHRcdFx0XHRcdHRhZyR3cmFwKGRvbSkuc2V0RXJlZihlcmVmKTtcblx0XHRcdFx0XHRcdFx0Ly8gaWYgZG9tLkB0YWdcblx0XHRcdFx0XHRcdFx0Ly8gXHRkb20uQHRhZy5lcmVmID0gZXJlZlxuXHRcdFx0XHRcdFx0XHQvLyBlbHNlXG5cdFx0XHRcdFx0XHRcdC8vIFx0ZG9tLnNldEF0dHJpYnV0ZSgnZXJlZicsZXJlZikgdW5sZXNzIG9sZFJlZiA9PSBlcmVmXG5cdFx0XHRcdFx0XHRcdC8vIFx0ZG9tOmNsYXNzTGlzdC5hZGQoJ2x2YXInKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnNvbGUudGltZSgnYW5hbHl6ZScpO1xuXHRcdFx0XHRJTS53b3JrZXIoKS5hbmFseXplKGNvZGUse2JhcmU6IHRydWV9LGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdyZXN1bHQgZnJvbSB3b3JrZXIgYW5hbHl6ZScpO1xuXHRcdFx0XHRcdGNvbnNvbGUudGltZUVuZCgnYW5hbHl6ZScpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChyZXMuZGF0YSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS50aW1lKCdhbm5vdGF0ZScpO1xuXHRcdFx0XHRcdFx0YXBwbHkocmVzLmRhdGEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnNvbGUudGltZUVuZCgnYW5ub3RhdGUnKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5sb2coJ2Vycm9yIGZyb20gYW5ub3RhdGUnLGUpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY29tbWFuZCA9IGZ1bmN0aW9uIChlLGMpe1xuXHRcdFx0aWYgKHRoaXNbYy5jb21tYW5kXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHRoaXNbYy5jb21tYW5kXS5jYWxsKHRoaXMsYy5hcmdzIHx8IFtdKTtcblx0XHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmR1bXBTdGF0ZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aHRtbDogdGhpcy5yb290KCkuZG9tKCkuaW5uZXJIVE1MLFxuXHRcdFx0XHRjb2RlOiB0aGlzLnJvb3QoKS5jb2RlKCksXG5cdFx0XHRcdHNlbGVjdGlvbjogdGhpcy5jYXJldCgpLnJlZ2lvbigpLFxuXHRcdFx0XHR0aW1lc3RhbXA6IG5ldyBEYXRlKClcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvYWRTdGF0ZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0c2VsZi5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdl87XG5cdFx0XHRcdGlmIChvLmh0bWwpIHtcblx0XHRcdFx0XHRzZWxmLnJvb3QoKS5kb20oKS5pbm5lckhUTUwgPSBvLmh0bWw7XG5cdFx0XHRcdH0gZWxzZSBpZiAoby5jb2RlKSB7XG5cdFx0XHRcdFx0c2VsZi5sb2FkKG8uY29kZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChvLnNlbGVjdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiAoc2VsZi5jYXJldCgpLnNldFJlZ2lvbih2XyA9IG8uc2VsZWN0aW9uKSx2Xyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkU2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKXtcblx0XHRcdHRoaXMuaGlzdG9yeSgpLmxvYWQoc2Vzc2lvbik7XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS5wbGF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGV4dE5vZGVzID0gZnVuY3Rpb24gKHJlbCl7XG5cdFx0XHRpZihyZWwgPT09IHVuZGVmaW5lZCkgcmVsID0gdGhpcy5yb290KCk7XG5cdFx0XHRyZXR1cm4gSU0udGV4dE5vZGVzKHJlbCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBTaG91bGQgYmUgc2VwYXJhdGUgZnJvbSB0aGUgdmlld2NvZGU/XG5cdFx0dGFnLnByb3RvdHlwZS5yZWdpb25Gb3JOb2RlID0gZnVuY3Rpb24gKG5vZGUscmVsKXtcblx0XHRcdGlmKHJlbCA9PT0gdW5kZWZpbmVkKSByZWwgPSB0aGlzLnJvb3QoKTtcblx0XHRcdHZhciBlbCA9IG5vZGUuX2RvbSB8fCBub2RlO1xuXHRcdFx0dmFyIGxlbiA9IGVsLnRleHRDb250ZW50Lmxlbmd0aDtcblx0XHRcdHZhciBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXHRcdFx0cm5nLnNldFN0YXJ0KHJlbC5fZG9tIHx8IHJlbCwwKTtcblx0XHRcdHJuZy5zZXRFbmQobm9kZS5fZG9tIHx8IG5vZGUsMCk7XG5cdFx0XHR2YXIgcHJlID0gcm5nLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2lvbihwcmUubGVuZ3RoLHByZS5sZW5ndGggKyBsZW4scmVsLHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gU2hvdWxkIG1lcmdlIHdpdGggbm9kZXNJblJlZ2lvblxuXHRcdHRhZy5wcm90b3R5cGUubm9kZUF0UmVnaW9uID0gZnVuY3Rpb24gKHJlZ2lvbixleGFjdCl7XG5cdFx0XHRpZihleGFjdCA9PT0gdW5kZWZpbmVkKSBleGFjdCA9IGZhbHNlO1xuXHRcdFx0Y29uc29sZS50aW1lKCdub2RlQXRSZWdpb24nKTtcblx0XHRcdHZhciByZWwgPSB0aGlzLnJvb3QoKTtcblx0XHRcdHZhciBhID0gcmVnaW9uLmEoKTtcblx0XHRcdHZhciBiID0gcmVnaW9uLmIoKTtcblx0XHRcdFxuXHRcdFx0dmFyIG5vZGVzID0gdGhpcy50ZXh0Tm9kZXMocmVsKTtcblx0XHRcdC8vIG1vdmUgaW50byByZWdpb24gaW5zdGVhZD9cblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIG1hdGNoID0gbnVsbDtcblx0XHRcdHZhciBhZGlzdCxiZGlzdCxzdHIsbGVuO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobm9kZXMpLCBsZW5fID0gYXJ5Lmxlbmd0aCwgbm9kZTsgaSA8IGxlbl87IGkrKykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9va2luZyB0aHJvdWdoIG5vZGVzJ1xuXHRcdFx0XHRub2RlID0gYXJ5W2ldO1xuXHRcdFx0XHRhZGlzdCA9IGEgLSBwb3M7XG5cdFx0XHRcdGJkaXN0ID0gYiAtIHBvcztcblx0XHRcdFx0c3RyID0gbm9kZS50ZXh0Q29udGVudDtcblx0XHRcdFx0bGVuID0gc3RyLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhZGlzdCA+PSAwICYmIGFkaXN0IDwgbGVuKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZvdW5kIHN0YXJ0aW5nIHBvaW50Pycsbm9kZSxzdHIsYWRpc3Rcblx0XHRcdFx0XHRtYXRjaCA9IG5vZGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIHRhZyhub2RlOnBhcmVudE5vZGUpXG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYmRpc3QgPj0gMCAmJiBiZGlzdCA8IGxlbikge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmb3VuZCBlbmRpbmcgcG9pbnQnLG5vZGUsc3RyLGJkaXN0XG5cdFx0XHRcdFx0Ly8gcmFuZ2Uuc2V0RW5kKG5vZGUsYmRpc3QpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0cG9zICs9IGxlbjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBlbCA9IHRhZyR3cmFwKG1hdGNoLnBhcmVudE5vZGUpO1xuXHRcdFx0Ly8gd2Ugd2FudCB0byBtYXRjaCB0aGUgb25lIHRoYXQgaXMgZnVsbCBsZW5ndGhcblx0XHRcdGlmIChleGFjdCAmJiBsZW4gPCByZWdpb24uc2l6ZSgpKSB7XG5cdFx0XHRcdHdoaWxlIChlbCl7XG5cdFx0XHRcdFx0Ly8gYmUgY2FyZWZ1bFxuXHRcdFx0XHRcdHZhciBlbHJlZyA9IGVsLnJlZ2lvbigpO1xuXHRcdFx0XHRcdGlmIChyZWdpb24uZXF1YWxzKGVscmVnKSkgeyByZXR1cm4gZWwgfTtcblx0XHRcdFx0XHRlbCA9IGVsLnBhcmVudCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS50aW1lRW5kKCdub2RlQXRSZWdpb24nKTtcblx0XHRcdHJldHVybiBtYXRjaCA/ICh0YWckd3JhcChtYXRjaC5wYXJlbnROb2RlKSkgOiAobnVsbCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5vZGVzRm9yRW50aXR5ID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRyZXR1cm4gcSQoJ1tlcmVmPVwiJysoXCJcIiArIHJlZikrJ1wiXScsdGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBkb2VzIG5vdCBuZWVkIHRvIGJlbG9uZyB0byB2aWV3IGRpcmVjdGx5XG5cdFx0dGFnLnByb3RvdHlwZS5ub2Rlc0luUmVnaW9uID0gZnVuY3Rpb24gKHJlZ2lvbixpbmNsdWRlRW5kcyxnZW5lcmFsaXplKXtcblx0XHRcdGlmKGluY2x1ZGVFbmRzID09PSB1bmRlZmluZWQpIGluY2x1ZGVFbmRzID0gdHJ1ZTtcblx0XHRcdGlmKGdlbmVyYWxpemUgPT09IHVuZGVmaW5lZCkgZ2VuZXJhbGl6ZSA9IGZhbHNlO1xuXHRcdFx0Y29uc29sZS50aW1lKCdub2Rlc0luUmVnaW9uJyk7XG5cdFx0XHRyZWdpb24gPSBSZWdpb24ubm9ybWFsaXplKHJlZ2lvbix0aGlzKS5ub3JtYWxpemUoKTtcblx0XHRcdHZhciBhID0gcmVnaW9uLnN0YXJ0KCk7XG5cdFx0XHR2YXIgYiA9IHJlZ2lvbi5lbmQoKTtcblx0XHRcdFxuXHRcdFx0Ly8gY2FuIGJlIG9wdGltaXplZCBieSBzdXBwbHlpbmcgdGhlIHJlZ2lvbnNcblx0XHRcdHZhciBub2RlcyA9IElNLnRleHROb2RlcyhyZWdpb24ucm9vdCgpIHx8IHRoaXMucm9vdCgpKTtcblx0XHRcdHZhciBtYXRjaGVzID0gW107XG5cdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHQvLyBtb3ZlIGludG8gcmVnaW9uIGluc3RlYWQ/XG5cdFx0XHRtYXRjaGVzLmluY2x1ZGVFbmRzID0gaW5jbHVkZUVuZHM7XG5cdFx0XHRtYXRjaGVzLnJlZ2lvbiA9IHJlZ2lvbjtcblx0XHRcdFxuXHRcdFx0dmFyIHBvcyA9IDA7XG5cdFx0XHR2YXIgZW5kcyA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpMSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuXyA9IGFyeS5sZW5ndGgsIG5vZGU7IGkxIDwgbGVuXzsgaTErKykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9va2luZyB0aHJvdWdoIG5vZGVzJ1xuXHRcdFx0XHRub2RlID0gYXJ5W2kxXTtcblx0XHRcdFx0dmFyIGFkaXN0ID0gYSAtIHBvcztcblx0XHRcdFx0dmFyIGJkaXN0ID0gYiAtIHBvcztcblx0XHRcdFx0dmFyIHN0ciA9IG5vZGUudGV4dENvbnRlbnQ7XG5cdFx0XHRcdHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKChwb3MgKyBsZW4pID49IGEgJiYgcG9zIDw9IGIpIHtcblx0XHRcdFx0XHRlbCA9IHRhZyR3cmFwKG5vZGUucGFyZW50Tm9kZSk7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCxhIC0gcG9zKTtcblx0XHRcdFx0XHR2YXIgZW5kID0gTWF0aC5taW4obGVuLE1hdGgubWF4KGIgLSBwb3MsMCkpO1xuXHRcdFx0XHRcdHZhciBwYXI7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bWF0Y2ggPSB7XG5cdFx0XHRcdFx0XHRub2RlOiBlbCxcblx0XHRcdFx0XHRcdHN0YXJ0T2Zmc2V0OiBzdGFydCxcblx0XHRcdFx0XHRcdGVuZE9mZnNldDogZW5kLFxuXHRcdFx0XHRcdFx0cmVnaW9uOiBuZXcgUmVnaW9uKHN0YXJ0LGVuZCxlbCx0aGlzKSxcblx0XHRcdFx0XHRcdHNpemU6IGxlblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gbG9nIFwibm9kZSBhdCB7cG9zfSArIHtsZW59IC0gbG9va2luZyBpbiByYW5nZSB7YX0gLSB7Yn1cIlxuXHRcdFx0XHRcdHZhciBtb2RlID0gJ2FsbCc7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHN0YXJ0ID09IGxlbikge1xuXHRcdFx0XHRcdFx0bW9kZSA9ICdlbmQnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZW5kID09IDApIHtcblx0XHRcdFx0XHRcdG1vZGUgPSAnc3RhcnQnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhcnQgPT0gMCAmJiBlbmQgPT0gbGVuKSB7XG5cdFx0XHRcdFx0XHRwYXIgPSBlbC5kb20oKS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0dmFyIGlzT3BlbmVyID0gcGFyICE9IHRoaXMuX3Jvb3QuZG9tKCkgJiYgZWwuZG9tKCkgPT0gcGFyLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdFx0XHR2YXIgaXNDbG9zZXIgPSBwYXIgIT0gdGhpcy5fcm9vdC5kb20oKSAmJiBlbC5kb20oKSA9PSBwYXIubGFzdENoaWxkO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoaXNPcGVuZXIpIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2gub3BlbnMgPSBlbC5wYXJlbnQoKTtcblx0XHRcdFx0XHRcdFx0ZW5kcy5wdXNoKG1hdGNoKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChpc0Nsb3Nlcikge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0XHRcdGlmIChlbmQgJiYgZW5kLm9wZW5zID09IGVsLnBhcmVudCgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kLmNsb3NlciA9IG1hdGNoO1xuXHRcdFx0XHRcdFx0XHRcdG1hdGNoLm9wZW5lciA9IGVuZDtcblx0XHRcdFx0XHRcdFx0XHRlbmRzLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0bWF0Y2guY2xvc2VzID0gZWwucGFyZW50KCk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRtb2RlID0gJ2FsbCc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1vZGUgPSAncGFydGlhbCc7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRtYXRjaC5tb2RlID0gbW9kZTtcblx0XHRcdFx0XHRtYXRjaGVzLnB1c2gobWF0Y2gpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0cG9zICs9IGxlbjtcblx0XHRcdFx0aWYgKHBvcyA+IGIpIHsgYnJlYWs7IH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgZmlyc3QgPSBtYXRjaGVzWzBdO1xuXHRcdFx0dmFyIGxhc3QgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcblx0XHRcdGlmIChmaXJzdCAmJiBmaXJzdC5tb2RlID09ICdlbmQnKSB7XG5cdFx0XHRcdG1hdGNoZXMucHJldiA9IGZpcnN0O1xuXHRcdFx0XHRtYXRjaGVzLmxmdCA9IGZpcnN0Lm5vZGU7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpZiBmaXJzdDpub2RlIGlzYSBJTS5UeXBlczpjbG9zZVxuXHRcdFx0XHQvLyBcdG1hdGNoZXM6bGZ0ID0gZmlyc3Q6bm9kZS5wYXJlbnRcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghaW5jbHVkZUVuZHMpIHsgbWF0Y2hlcy5zaGlmdCgpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobGFzdCAmJiBsYXN0Lm1vZGUgPT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRtYXRjaGVzLm5leHQgPSBsYXN0O1xuXHRcdFx0XHRtYXRjaGVzLnJndCA9IGxhc3Qubm9kZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGlmIGxhc3Q6bm9kZSBpc2EgSU0uVHlwZXM6b3BlblxuXHRcdFx0XHQvLyBcdG1hdGNoZXM6cmd0ID0gbGFzdDpub2RlLnBhcmVudFxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFpbmNsdWRlRW5kcykgeyBtYXRjaGVzLnBvcCgpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vIG5vcm1hbGl6ZSB0aGUgbm9kZXMgaW4gZ3JvdXBzXG5cdFx0XHRpZiAoZ2VuZXJhbGl6ZSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnZ2VuZXJhbGl6ZSEnLG1hdGNoZXNcblx0XHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0XHR2YXIgbTtcblx0XHRcdFx0d2hpbGUgKG0gPSBtYXRjaGVzW2ldKXtcblx0XHRcdFx0XHRpZiAobS5jbG9zZXIpIHtcblx0XHRcdFx0XHRcdHZhciBpZHggPSBtYXRjaGVzLmluZGV4T2YobS5jbG9zZXIpO1xuXHRcdFx0XHRcdFx0bGVuID0gbS5vcGVucy5zaXplKCk7XG5cdFx0XHRcdFx0XHR2YXIgbmV3JCA9IHtcblx0XHRcdFx0XHRcdFx0bW9kZTogJ2FsbCcsXG5cdFx0XHRcdFx0XHRcdHJlZ2lvbjogbmV3IFJlZ2lvbigwLGxlbixtLm9wZW5zLHRoaXMpLFxuXHRcdFx0XHRcdFx0XHRzdGFydE9mZnNldDogMCxcblx0XHRcdFx0XHRcdFx0ZW5kT2Zmc2V0OiBsZW4sXG5cdFx0XHRcdFx0XHRcdG5vZGU6IG0ub3BlbnNcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR2YXIgcmVtID0gbWF0Y2hlcy5zcGxpY2UoaSxpZHggLSBpICsgMSxuZXckKTtcblx0XHRcdFx0XHRcdG5ldyQuY2hpbGRyZW4gPSByZW07XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnc2xpY2UgYXdheSB0aGUgaXRlbXMnXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zb2xlLnRpbWVFbmQoJ25vZGVzSW5SZWdpb24nKTtcblx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIG1vdmUgdG8gQnVmZmVyIGNsYXNzXG5cdFx0dGFnLnByb3RvdHlwZS5saW5lY291bnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmJ1ZmZlcigpLmxpbmVjb3VudCgpO1xuXHRcdFx0Ly8gYnVmZmVyLnNwbGl0KCdcXG4nKVs6bGVuZ3RoXVxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHJlZ2lvbiBhcyBhIHN0cmluZy5cblx0XHQvLyBSZXR1cm5zIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBwb2ludC5cblx0XHR0YWcucHJvdG90eXBlLnN1YnN0ciA9IGZ1bmN0aW9uIChyZWdpb24sbGVuKXtcblx0XHRcdHJldHVybiB0aGlzLmJ1ZmZlcigpLnN1YnN0cihyZWdpb24sbGVuKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG1vdmUgaW50byBCdWZmZXJcblx0XHR0YWcucHJvdG90eXBlLmxpbmVzdHIgPSBmdW5jdGlvbiAobnIpe1xuXHRcdFx0cmV0dXJuIHRoaXMuYnVmZmVyKCkubGluZShucik7XG5cdFx0XHQvLyBpZiBuciBpc2EgTnVtYmVyXG5cdFx0XHQvLyBcdGJ1ZmZlci5zcGxpdCgnXFxuJylbbnJdIG9yICcnXG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4cGFuZFJlZ2lvblRvID0gZnVuY3Rpb24gKHJlZ2lvbixtYXRjaCxmb3J3YXJkKXtcblx0XHRcdGlmKGZvcndhcmQgPT09IHVuZGVmaW5lZCkgZm9yd2FyZCA9IHRydWU7XG5cdFx0XHR2YXIgYnVmID0gdGhpcy5idWZmZXIoKS50b1N0cmluZygpO1xuXHRcdFx0dmFyIHBvcyA9IHJlZ2lvbi5zdGFydCgpO1xuXHRcdFx0dmFyIGVuZCA9IHJlZ2lvbi5lbmQoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGZvcndhcmQpIHtcblx0XHRcdFx0d2hpbGUgKGJ1ZltlbmQgKyAxXSAhPSBtYXRjaCl7XG5cdFx0XHRcdFx0ZW5kKys7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoYnVmW3BvcyAtIDFdICE9IG1hdGNoKXtcblx0XHRcdFx0XHRwb3MtLTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgUmVnaW9uKHBvcyxlbmQsdGhpcyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0cmV0dXJuIFZJRVcgPSBudWxsO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvdmlldy5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0XG5cdGZ1bmN0aW9uIEJ1ZmZlcih2aWV3KXtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHR0aGlzLl9idWZmZXIgPSAnJztcblx0XHR0aGlzLl9jYWNoZSA9IHt9O1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRCdWZmZXIucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoYnVmZmVyKXtcblx0XHRpZiAoYnVmZmVyID09IHRoaXMuX2J1ZmZlcikge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9idWZmZXIgPSBidWZmZXI7XG5cdFx0dGhpcy5fY2FjaGUgPSB7fTtcblx0XHR0aGlzLl9saW5lcyA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5zZXQodGhpcy52aWV3KCkucm9vdCgpLmNvZGUoKSk7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2xpbmVzIHx8ICh0aGlzLl9saW5lcyA9ICh0cnVlKSAmJiAoXG5cdFx0XHR0aGlzLl9idWZmZXIuc3BsaXQoJ1xcbicpXG5cdFx0KSk7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2J1ZmZlci5zcGxpdC5hcHBseSh0aGlzLl9idWZmZXIsYXJndW1lbnRzKTtcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUubGluZWNvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubGluZXMoKS5sZW5ndGg7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxpbmUgPSBmdW5jdGlvbiAobnIpe1xuXHRcdGlmICgodHlwZW9mIG5yPT0nbnVtYmVyJ3x8bnIgaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5saW5lcygpW25yXSB8fCAnJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH07XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9idWZmZXIubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gbG9jYXRpb24gdG8gXG5cdEJ1ZmZlci5wcm90b3R5cGUubG9jVG9SYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5sb2NhdGlvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5sb2NUb1JvdyA9IGZ1bmN0aW9uIChsb2Mpe1xuXHRcdHZhciBsbiA9IDA7XG5cdFx0dmFyIGxlbiA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMubGluZXMoKSksIGxlbl8gPSBhcnkubGVuZ3RoOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRsZW4gKz0gYXJ5W2ldLmxlbmd0aCArIDE7XG5cdFx0XHRpZiAobG9jIDwgbGVuKSB7IHJldHVybiBpIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcy5saW5lcygpLmxlbmd0aDtcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUubG9jVG9DZWxsID0gZnVuY3Rpb24gKGxvYyl7XG5cdFx0aWYgKHRoaXMuX2NhY2hlW2xvY10pIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWNoZVtsb2NdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHBvcyA9IGxvYztcblx0XHR2YXIgY29sID0gMDtcblx0XHR2YXIgcm93ID0gMDtcblx0XHR2YXIgY2hhciQ7XG5cdFx0XG5cdFx0dmFyIGJ1ZiA9IHRoaXMuX2J1ZmZlcjtcblx0XHR2YXIgdGFic2l6ZSA9IHRoaXMuX3ZpZXcudGFiU2l6ZSgpO1xuXHRcdFxuXHRcdC8vIGdvIGJhY2sgdG8gc3RhcnQgb2YgbGluZVxuXHRcdC8vIGdvZXMgdGhyb3VnaCB0aGUgd2hvbGVcblx0XHR3aGlsZSAoY2hhciQgPSBidWZbcG9zIC0gMV0pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXG4nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fTtcblx0XHRcdHBvcy0tO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZ2V0IGNvbHVtbiBmb3Igc2xpY2Vcblx0XHR3aGlsZSAoKHBvcyA8IGxvYykgJiYgKGNoYXIkID0gYnVmW3Bvc10pKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFx0Jykge1xuXHRcdFx0XHR2YXIgcmVzdCA9IHRhYnNpemUgLSAoY29sICUgdGFic2l6ZSk7XG5cdFx0XHRcdGNvbCArPSByZXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sICs9IDE7XG5cdFx0XHR9O1xuXHRcdFx0cG9zKys7XG5cdFx0fTtcblx0XHRcblx0XHR3aGlsZSAoY2hhciQgPSBidWZbcG9zIC0gMV0pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXG4nKSB7XG5cdFx0XHRcdHJvdysrO1xuXHRcdFx0fTtcblx0XHRcdHBvcy0tO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuX2NhY2hlW2xvY10gPSBbcm93LGNvbF07XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnN1YnN0ciA9IGZ1bmN0aW9uIChyZWdpb24sbGVuKXtcblx0XHRpZiAocmVnaW9uIGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyLnN1YnN0cihyZWdpb24uc3RhcnQoKSxyZWdpb24uc2l6ZSgpKTtcblx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgcmVnaW9uPT0nbnVtYmVyJ3x8cmVnaW9uIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2J1ZmZlci5zdWJzdHIocmVnaW9uLGxlbiB8fCAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgJ211c3QgYmUgcmVnaW9uIG9yIG51bWJlcic7XG5cdFx0fTtcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyIHx8ICcnO1xuXHR9O1xuXHRyZXR1cm4gQnVmZmVyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9idWZmZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblx0XG5cdGZ1bmN0aW9uIE9ic2VydmVyKHZpZXcsY2ZnKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fYWN0aXZlID0gZmFsc2U7XG5cdFx0c2VsZi5fdmlldyA9IHZpZXc7XG5cdFx0c2VsZi5fY29uZmlnID0gY2ZnIHx8IHthdHRyaWJ1dGVzOiBmYWxzZSxjaGlsZExpc3Q6IHRydWUsY2hhcmFjdGVyRGF0YTogdHJ1ZSxzdWJ0cmVlOiB0cnVlfTtcblx0XHRzZWxmLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKG11dHMpIHsgcmV0dXJuIHNlbGYub25tdXRhdGlvbnMobXV0cyk7IH0pO1xuXHRcdHNlbGY7XG5cdH07XG5cdFxuXHRleHBvcnRzLk9ic2VydmVyID0gT2JzZXJ2ZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRPYnNlcnZlci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRPYnNlcnZlci5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY29uZmlnOyB9XG5cdE9ic2VydmVyLnByb3RvdHlwZS5zZXRDb25maWcgPSBmdW5jdGlvbih2KXsgdGhpcy5fY29uZmlnID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG5cdE9ic2VydmVyLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih2KXsgdGhpcy5fYWN0aXZlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRPYnNlcnZlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKCF0aGlzLl9hY3RpdmUpIHtcblx0XHRcdHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy52aWV3KCkucm9vdCgpLmRvbSgpLHRoaXMuY29uZmlnKCkpO1xuXHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKGJsayl7XG5cdFx0dmFyIHdhc0FjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRpZiAod2FzQWN0aXZlKSB7IHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKSB9O1xuXHRcdFxuXHRcdGlmIChibGsgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0YmxrKCk7XG5cdFx0XHRpZiAod2FzQWN0aXZlKSB0aGlzLnJlc3VtZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRPYnNlcnZlci5wcm90b3R5cGUucGF1c2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuICF0aGlzLl9hY3RpdmU7XG5cdH07XG5cdFxuXHRPYnNlcnZlci5wcm90b3R5cGUub25tdXRhdGlvbnMgPSBmdW5jdGlvbiAobXV0YXRpb25zKXtcblx0XHR2YXIgZWw7XG5cdFx0dGhpcy52aWV3KCkubG9nZ2VyKCkuZ3JvdXAoJ211dGF0aW9ucycpO1xuXHRcdFxuXHRcdHZhciBkZWVwID0gZmFsc2U7XG5cdFx0dmFyIG5vZGVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG11dGF0aW9ucyksIGxlbiA9IGFyeS5sZW5ndGgsIG11dDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRtdXQgPSBhcnlbaV07XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2coJ211dGF0aW9uJyxtdXQpO1xuXHRcdFx0dmFyIHR5cGUgPSBtdXQudHlwZTtcblx0XHRcdHZhciB0YXJnZXQgPSBtdXQucHJldmlvdXNTaWJsaW5nIHx8IG11dC50YXJnZXQ7XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlID09ICdjaGFyYWN0ZXJEYXRhJykge1xuXHRcdFx0XHR0aGlzLnZpZXcoKS5sb2coKFwidXBkYXRlZCBjb2RlIHRvIFwiICsgKHRhcmdldC50ZXh0Q29udGVudCkpKTtcblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gJ2NoaWxkTGlzdCcpIHtcblx0XHRcdFx0ZGVlcCA9IHRydWU7XG5cdFx0XHRcdHZhciBhZGQgPSBtdXQuYWRkZWROb2Rlcztcblx0XHRcdFx0aWYgKGFkZC5sZW5ndGggPT0gMSAmJiAoYWRkWzBdIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSBhZGRbMF07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2codGFyZ2V0LHRhZyR3cmFwKHRhcmdldCkpO1xuXHRcdFx0Ly8gdmFyIGFkZGVkID0gbXV0OmFkZGVkTm9kZXNcblx0XHRcdC8vIGZvciBub2RlIGluIG11dDphZGRlZE5vZGVzXG5cdFx0XHQvLyBpZiB0YXJnZXQgYW5kIHRhcmdldDpwYXJlbnROb2RlICMgYW5kIHRhcmdldC5AdGFnXG5cdFx0XHRpZiAoZWwgPSB0YWckd3JhcCh0YXJnZXQpKSB7XG5cdFx0XHRcdHRoaXMudmlldygpLmxvZygnYWRkIHRhcmdldD8hJyk7XG5cdFx0XHRcdGlmIChub2Rlcy5pbmRleE9mKGVsKSA8IDApIHsgbm9kZXMucHVzaChlbCkgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGlmIHdlIGhhdmUgYWRkZWQgYSBub2RlIGluc3RlYWRcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG11dGF0aW9ucyBhcmUgbm90IHJlZ2lzdGVyZWQgb24gbm9kZS1sZXZlbCBidXQgb24gZXh0ZW50XG5cdFx0Ly8gbm90IHJlYWxseSBob3cgdGhpcyBzaG91bGQgaGFwcGVuXG5cdFx0XG5cdFx0dmFyIGNvbW1vbiA9IHV0aWwuY29tbW9uQW5jZXN0b3Iobm9kZXMpO1xuXHRcdFxuXHRcdHRoaXMudmlldygpLmxvZygnY29tbW9uIGNvbnRhaW5lciBmb3IgbXV0YXRpb25zIGlzJyxjb21tb24sbm9kZXMpO1xuXHRcdFxuXHRcdHZhciBleHRlbnQ7XG5cdFx0XG5cdFx0aWYgKG5vZGVzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2coJ2Egc2luZ2xlIG5vZGUgd2FzIG11dGF0ZWQnLG5vZGVzWzBdKTtcblx0XHRcdG5vZGVzWzBdLm11dGF0ZWQoe2RlZXA6IGRlZXAsbXV0YXRpb25zOiBtdXRhdGlvbnN9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gY29sbGVjdCBleHRlbnRzIGZvciBhbGwgbm9kZXM/XG5cdFx0XHQvLyByYXRoZXIgbWFrZSBhIHJlZ2lvbiBleHBhbmQgXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoZXh0ZW50ICYmIGV4dGVudC5jb250YWlucyhub2RlLmRvbSgpKSkgeyAvLyA6bm9kZXMuaW5kZXhPZihub2RlLmRvbSkgPj0gMFxuXHRcdFx0XHRcdHRoaXMudmlldygpLmxvZygndGhpcyBub2RlIGlzIGFscmVhZHkgcGFydCBvZiB0aGUgZXh0ZW50Jyxub2RlLmRvbSgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRleHRlbnQgPSBub2RlLmRpcnR5RXh0ZW50KCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIG5vZGU/Lm11dGF0ZWRcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChleHRlbnQpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZvdW5kIGV4dGVudCghKScsZXh0ZW50XG5cdFx0XHRcdHRoaXMucGF1c2UoZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnZpZXcoKS5sb2dnZXIoKS5ncm91cEVuZCgpO1xuXHRcdHRoaXMudmlldygpLm9ubXV0YXRpb25zKHtub2Rlczogbm9kZXMsbXV0YXRpb25zOiBtdXRhdGlvbnMsZXh0ZW50OiBleHRlbnR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cmV0dXJuIE9ic2VydmVyO1xuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvb2JzZXJ2ZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0XG5cdHZhciBsYWJlbHMgPSB7XG5cdFx0XCJVbmV4cGVjdGVkICdUQUdfRU5EJ1wiOiAnVGFnIGNsb3NlZCB1bmV4cGVjdGVkbHknLFxuXHRcdFwiVW5leHBlY3RlZCAnVEVSTUlOQVRPUidcIjogJ1VuZXhwZWN0ZWQg4o+OJyxcblx0XHRcIlVuZXhwZWN0ZWQgJ1BPU1RfSUYnXCI6ICdNaXNzaW5nIGJvZHkgaW4gPGI+SUY8L2I+J1xuXHR9O1xuXHRcblx0dmFyIHJ1bGVzID0gW1xuXHRcdFsvVW5jYXVnaHQgRXJyb3I6IHRhZyAoXFx3KykgaXMgbm90IGRlZmluZWQvLFwidGFnIDxiPiQxPC9iPiBkb2VzIG5vdCBleGlzdFwiXVxuXHRdO1xuXHRcblx0ZnVuY3Rpb24gSGludChvcHRzLHZpZXcpe1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHRcdHRoaXMuX2RhdGEgPSBvcHRzO1xuXHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdHRoaXMuX3JlZ2lvbiA9IG9wdHMubG9jID8gKFJlZ2lvbi5ub3JtYWxpemUob3B0cy5sb2MsdmlldykpIDogKG51bGwpO1xuXHRcdC8vIHRyeSB0byBmaW5kIHRoZSBub2RlIGltbWVkaWF0ZWx5XG5cdFx0dGhpcy5fbm9kZSA9IG9wdHMubm9kZSB8fCB0aGlzLm5vZGUoKTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5IaW50ID0gSGludDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRIaW50LmJ1aWxkID0gZnVuY3Rpb24gKG8sdmlldyl7XG5cdFx0cmV0dXJuIG5ldyB0aGlzKG8sdmlldyk7XG5cdH07XG5cdFxuXHRcblx0XG5cdEhpbnQucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0SGludC5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGludC5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZWdpb247IH1cblx0SGludC5wcm90b3R5cGUuc2V0UmVnaW9uID0gZnVuY3Rpb24odil7IHRoaXMuX3JlZ2lvbiA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpbnQucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG5cdEhpbnQucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hY3RpdmUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChrZXkpe1xuXHRcdHJldHVybiB0aGlzLl9kYXRhW2tleV07XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0dGhpcy5fZGF0YVtrZXldID0gdmFsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kYXRhLnR5cGUgfHwgJ2Vycm9yJztcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGEuZ3JvdXA7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YS5yZWY7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGUgfHwgKHRoaXMuX25vZGUgPSB0aGlzLl9yZWdpb24gJiYgdGhpcy52aWV3KCkubm9kZUF0UmVnaW9uKHRoaXMuX3JlZ2lvbikpO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMucmVnaW9uKCkucm93KCk7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5jb2wgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5yZWdpb24oKS5jb2woKTtcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGxibDtcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWwgfHwgKHRoaXMuX2xhYmVsID0gKHRydWUpICYmIChcblx0XHRcdGxibCA9IHRoaXMuX2RhdGEubGFiZWwgfHwgdGhpcy5fZGF0YS5tZXNzYWdlIHx8ICdIaW50Jyxcblx0XHRcdGxibCA9IGxibC5zcGxpdCgvZXJyb3IgYXQgKFxcW1tcXGRcXDpdKlxcXSlcXDpcXHMqLykucG9wKCksXG5cdFx0XHRsYmwgPSBsYWJlbHNbbGJsXSB8fCBsYmxcblx0XHQpKTtcblx0fTtcblx0XG5cdFxuXHRIaW50LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBub2RlXztcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkge1xuXHRcdFx0Ly8gbm9kZT8uc2V0QXR0cmlidXRlKCdoaW50JyxyZWYpXG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXHRcdFx0KG5vZGVfID0gdGhpcy5ub2RlKCkpICYmIG5vZGVfLnNldEhpbnQgICYmICBub2RlXy5zZXRIaW50KHRoaXMpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0Y29uc29sZS5sb2coJ2RlYWN0aXZhdGUgaGludCEhJyk7XG5cdFx0dGhpcy5zZXRBY3RpdmUoZmFsc2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHRcdC8vIGNsZWFudXBcblx0XHQvLyByZW1vdmVcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLnBydW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmlldygpLmhpbnRzKCkucHJ1bmUodGhpcyk7XG5cdH07XG5cdFxuXHQvLyBzaG91bGQgbWFrZSB0aGlzIGhpbnQgcmVhZHkgdG8gYmUgcmVtb3ZlZFxuXHRIaW50LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX25vZGUpIHtcblx0XHRcdGlmICh0aGlzLl9ub2RlLmhpbnQoKSA9PSB0aGlzKSB7IHRoaXMuX25vZGUuc2V0SGludChudWxsKSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnZpZXcoKS5oaW50cygpLnJlbSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjb25zb2xlLmxvZyAnZGVhY3RpdmF0ZSBvbiBjaGFuZ2VkISdcblx0XHQvLyBAZGVhY3RpdmF0ZSA9IHllc1xuXHRcdHRoaXMucHJ1bmUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmFkanVzdCA9IGZ1bmN0aW9uIChyZWcsaW5zKXtcblx0XHRpZihpbnMgPT09IHVuZGVmaW5lZCkgaW5zID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5yZWdpb24oKS5pbnRlcnNlY3RzKHJlZykpIHtcblx0XHRcdC8vIGRlYWN0aXZhdGVcblx0XHRcdHRoaXMucHJ1bmUoKTtcblx0XHRcdC8vIEBkZWFjdGl2YXRlID0geWVzXG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnJlZ2lvbigpLmFkanVzdChyZWcsaW5zKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEhpbnRzKHZpZXcpe1xuXHRcdHRoaXMuX3BydW5lID0gW107XG5cdFx0dGhpcy5fYXJyYXkgPSBbXTtcblx0XHR0aGlzLl9tYXAgPSB7fTtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0fTtcblx0XG5cdGV4cG9ydHMuSGludHMgPSBIaW50czsgLy8gZXhwb3J0IGNsYXNzIFxuXHR2YXIgbnIgPSAwO1xuXHRcblx0SGludHMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYXJyYXk7XG5cdH07XG5cdFxuXHRIaW50cy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0cmV0dXJuIHRoaXMuX21hcFtyZWZdO1xuXHR9O1xuXHRcblx0SGludHMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2FycmF5KSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnlbaV0uYWN0aXZhdGUoKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gdGhpcyBzaG91bGQgdGFrZSBjYXJlIG9mIGRlYWxsb2NhdGluZyB0aGUgaGludCBubz9cblx0SGludHMucHJvdG90eXBlLnJlbSA9IGZ1bmN0aW9uIChoaW50KXtcblx0XHRpZiAoaGludCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRoaW50ID0gdGhpcy5fYXJyYXkuZmlsdGVyKGhpbnQpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGhpbnQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGhpbnQpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5yZW0oYXJ5W2ldKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaGludDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICgodHlwZW9mIGhpbnQ9PSdzdHJpbmcnfHxoaW50IGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtKHRoaXMuZ2V0KGhpbnQpKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9hcnJheS5pbmRleE9mKGhpbnQpID49IDApIHtcblx0XHRcdGhpbnQuY2xlYW51cCgpO1xuXHRcdFx0dGhpcy5fYXJyYXkuc3BsaWNlKHRoaXMuX2FycmF5LmluZGV4T2YoaGludCksMSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gaGludDtcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5wcnVuZSA9IGZ1bmN0aW9uIChoaW50KXtcblx0XHRpZiAodGhpcy5fcHJ1bmUuaW5kZXhPZihoaW50KSA8IDApIHsgdGhpcy5fcHJ1bmUucHVzaChoaW50KSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyciA9IHRoaXMuX2FycmF5O1xuXHRcdHRoaXMuX2FycmF5ID0gW107XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGFyciksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJ5W2ldLmRlYWN0aXZhdGUoKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludHMucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fYXJyYXkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmIChzZWxmLl9wcnVuZS5pbmRleE9mKGl0ZW0pID49IDApIHtcblx0XHRcdFx0aXRlbS5kZWFjdGl2YXRlKCk7XG5cdFx0XHRcdHJldHVybiBzZWxmLnJlbShpdGVtKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0c2VsZi5fcHJ1bmUgPSBbXTtcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdFxuXHRIaW50cy5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGNiKXtcblx0XHRyZXR1cm4gdGhpcy5fYXJyYXkuZmlsdGVyKGNiKTtcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIHJlZiA9IG8ucmVmID0gKFwiaGludFwiICsgKG5yKyspKTtcblx0XHRpZiAoISgobyBpbnN0YW5jZW9mIEhpbnQpKSkgeyBvID0gSGludC5idWlsZChvLHRoaXMuX3ZpZXcpIH07XG5cdFx0dGhpcy5fbWFwW3JlZl0gPSBvO1xuXHRcdHRoaXMuX2FycmF5LnB1c2gobyk7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdHJldHVybiBIaW50cztcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGludHMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0XG5cdGZ1bmN0aW9uIFJvd0NvbChyb3csY29sLGNhcmV0KXtcblx0XHRpZihyb3cgPT09IHVuZGVmaW5lZCkgcm93ID0gMDtcblx0XHRpZihjb2wgPT09IHVuZGVmaW5lZCkgY29sID0gMDtcblx0XHRpZihjYXJldCA9PT0gdW5kZWZpbmVkKSBjYXJldCA9IG51bGw7XG5cdFx0dGhpcy5fcm93ID0gcm93O1xuXHRcdHRoaXMuX2NvbCA9IGNvbDtcblx0XHR0aGlzLl9jYXJldCA9IGNhcmV0O1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb3c7IH1cblx0Um93Q29sLnByb3RvdHlwZS5zZXRSb3cgPSBmdW5jdGlvbih2KXsgdGhpcy5fcm93ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0Um93Q29sLnByb3RvdHlwZS5jb2wgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvbDsgfVxuXHRSb3dDb2wucHJvdG90eXBlLnNldENvbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jb2wgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLmNhcmV0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jYXJldDsgfVxuXHRSb3dDb2wucHJvdG90eXBlLnNldENhcmV0ID0gZnVuY3Rpb24odil7IHRoaXMuX2NhcmV0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jYXJldCgpLnZpZXcoKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fY29sID0gdGhpcy5yZWFsQ29sKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyb3csY29sKXtcblx0XHR2YXIgYXJ5O1xuXHRcdGlmIChyb3cgaW5zdGFuY2VvZiBSb3dDb2wpIHtcblx0XHRcdGNvbCA9IHJvdy5jb2woKTtcblx0XHRcdHJvdyA9IHJvdy5yb3coKTtcblx0XHRcdFxuXHRcdFx0Ly8gcmV0dXJuIHNldChyb3cucm93LHJvdy5jb2wpXG5cdFx0fTtcblx0XHRcblx0XHRpZiAocm93IGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodXRpbC5yb3djb2wodGhpcy52aWV3KCkuX2J1ZmZlcixyb3cuc3RhcnQoKSkpO3JvdyA9IGFyeVswXTtjb2wgPSBhcnlbMV07XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgbGMgPSB0aGlzLnZpZXcoKS5fYnVmZmVyLmxpbmVjb3VudCgpO1xuXHRcdFxuXHRcdGlmIChyb3cgPj0gbGMpIHtcblx0XHRcdHJvdyA9IGxjIC0gMTtcblx0XHRcdGNvbCA9IDEwMDA7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9yb3cgPSByb3c7XG5cdFx0dGhpcy5fY29sID0gY29sO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChvZmZzZXQpe1xuXHRcdHRoaXMubm9ybWFsaXplKCk7XG5cdFx0XG5cdFx0dmFyIGNvbCA9IHRoaXMucmVhbENvbCgpICsgb2Zmc2V0O1xuXHRcdHZhciBsbGVuID0gdGhpcy5saW5lbGVuKCk7XG5cdFx0XG5cdFx0dmFyIGxsb2MgPSB0aGlzLmxpbmVsb2MoKTtcblx0XHQvLyBmaW5kIHRoZSByZWFsIG9mZnNldCBpbiBjaGFyYWN0ZXJzIChub3QgY29sdW1ucylcblx0XHRcblx0XHRcblx0XHQvLyBpZiBvZmZzZXQgPCAwXG5cdFx0Ly8gXHQjIG5vcm1hbGl6ZT9cblx0XHQvLyBcdEBjb2wgPSBNYXRoLm1pbihAY29sLGxsZW4pXG5cdFx0XG5cdFx0aWYgKGNvbCA8IDApIHtcblx0XHRcdGlmICh0aGlzLl9yb3cgPiAwKSB7XG5cdFx0XHRcdHRoaXMubW92ZVVwKCk7XG5cdFx0XHRcdHRoaXMuX2NvbCA9IHRoaXMubGluZWxlbigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcm93ID0gMDtcblx0XHRcdFx0dGhpcy5fY29sID0gMDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IGVsc2UgaWYgKGNvbCA+IGxsZW4pIHtcblx0XHRcdGlmICh0aGlzLl9yb3cgPj0gKHRoaXMudmlldygpLl9idWZmZXIubGluZWNvdW50KCkgLSAxKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMubW92ZURvd24oKTtcblx0XHRcdHZhciByZXN0ID0gTWF0aC5tYXgoMCxjb2wgLSBsbGVuIC0gMSk7XG5cdFx0XHR2YXIgbW92ZXMgPSB1dGlsLmNvbHNGb3JMaW5lKHRoaXMubGluZXN0cigpLnN1YnN0cigwLHJlc3QpKTtcblx0XHRcdHRoaXMuX2NvbCA9IG1vdmVzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB0aGlzIHNob3VsZCB3b3JrXG5cdFx0dGhpcy5fY29sID0gdXRpbC5jb2xzRm9yTGluZSh0aGlzLmxpbmVzdHIoKS5zdWJzdHIoMCxsbG9jICsgb2Zmc2V0KSk7XG5cdFx0Ly8gQGNvbCArPSBvZmZzZXRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubW92ZVVwID0gZnVuY3Rpb24gKGxlbil7XG5cdFx0dGhpcy5fcm93ID0gTWF0aC5tYXgoMCx0aGlzLl9yb3cgLSAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubW92ZURvd24gPSBmdW5jdGlvbiAobGVuKXtcblx0XHRjb25zb2xlLmxvZygnbW92ZURvd24nKTtcblx0XHR2YXIgbGMgPSB0aGlzLnZpZXcoKS5fYnVmZmVyLmxpbmVjb3VudCgpOyAvLyBzcGxpdCgnXFxuJylbOmxlbmd0aF1cblx0XHR0aGlzLl9yb3cgPSB0aGlzLl9yb3cgKyAxO1xuXHRcdGlmICh0aGlzLl9yb3cgPj0gbGMpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdvdXQgb2YgYm91bmRzJyk7XG5cdFx0XHR0aGlzLnNldExvYyh0aGlzLnZpZXcoKS5fYnVmZmVyLmxlbigpKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBuZXcgUm93Q29sKHRoaXMucm93KCksdGhpcy5jb2woKSx0aGlzLmNhcmV0KCkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5saW5lbGVuID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHV0aWwuY29sc0ZvckxpbmUodGhpcy5saW5lc3RyKCkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5saW5lbG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHV0aWwuY29sVG9Mb2ModGhpcy5saW5lc3RyKCksdGhpcy5yZWFsQ29sKCkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5yZWFsQ29sID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHJjID0gdXRpbC5jb2xUb1ZpZXdDb2wodGhpcy5saW5lc3RyKCksdGhpcy5fY29sKTtcblx0XHRyZXR1cm4gcmM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLmxpbmVzdHIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52aWV3KCkubGluZXN0cih0aGlzLnJvdygpKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUucGVla2JlaGluZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzdHIgPSB0aGlzLmxpbmVzdHIoKTtcblx0XHRyZXR1cm4gc3RyLnN1YnN0cigwLHV0aWwuY29sVG9Mb2Moc3RyLHRoaXMucmVhbENvbCgpKSk7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnBlZWthaGVhZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzdHIgPSB0aGlzLmxpbmVzdHIoKTtcblx0XHRyZXR1cm4gc3RyLnNsaWNlKHV0aWwuY29sVG9Mb2Moc3RyLHRoaXMucmVhbENvbCgpKSk7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnNldExvYyA9IGZ1bmN0aW9uIChsb2Mpe1xuXHRcdHZhciBhcnk7XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKHV0aWwucm93Y29sKHRoaXMudmlldygpLl9idWZmZXIsbG9jKSk7dmFyIHJvdyA9IGFyeVswXSxjb2wgPSBhcnlbMV07XG5cdFx0dGhpcy5zZXQocm93LGNvbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLmxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHNob3VsZCBjYWNoZSghKVxuXHRcdHZhciBsaW5lcyA9IHRoaXMudmlldygpLl9idWZmZXIubGluZXMoKTtcblx0XHQvLyB2YXIgbGluZXMgPSB2aWV3LmJ1ZmZlci5zcGxpdCgnXFxuJylcblx0XHR2YXIgbG9jID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobGluZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBsaW5lOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGxpbmUgPSBhcnlbaV07XG5cdFx0XHR2YXIgbG4gPSBsaW5lLmxlbmd0aDtcblx0XHRcdGlmIChpIDwgdGhpcy5fcm93KSB7XG5cdFx0XHRcdGxvYyArPSBsbiArIDE7IC8vIGluY2x1ZGUgbmV3bGluZVxuXHRcdFx0fSBlbHNlIGlmIChpID09IHRoaXMuX3Jvdykge1xuXHRcdFx0XHR2YXIgdmlld2NvbCA9IHV0aWwuY29sVG9WaWV3Q29sKGxpbmUsdGhpcy5fY29sKTtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHV0aWwuY29sVG9Mb2MobGluZSx2aWV3Y29sKTtcblx0XHRcdFx0bG9jICs9IE1hdGgubWluKGxuLG9mZnNldCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIGxvYztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUudGFiID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gd3JvbmcgLSBuZWVkIHRvIHJvdW5kIGluc3RlYWQ/XG5cdFx0XG5cdFx0dmFyIGxmdCA9IHRoaXMuY29sKCkgJSA0O1xuXHRcdHRoaXMuc2V0Q29sKHRoaXMuY29sKCkgKyAoNCAtIGxmdCkpOyAvLyBNYXRoLmZsb29yKGNvbCAvIDQpICogNCArIDRcblx0XHRjb25zb2xlLmxvZygnbWFya2VyIHRhYicsbGZ0LHRoaXMuY29sKCksdGhpcy5yZWFsQ29sKCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS51bnRhYiA9IGZ1bmN0aW9uICgpe1xuXHRcdGNvbnNvbGUubG9nKCd1bnRhYicsdGhpcy5jb2woKSk7XG5cdFx0dmFyIHJlc3QgPSA0IC0gdGhpcy5jb2woKSAlIDQ7XG5cdFx0dGhpcy5zZXRDb2woTWF0aC5jZWlsKHRoaXMuY29sKCkgLyA0KSAqIDQgLSA0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUuYWx0ZXIgPSBmdW5jdGlvbiAobW9kZSxkaXIpe1xuXHRcdHZhciAkMSwgJDIsICQzLCAkNCwgJDUsICQ2O1xuXHRcdHZhciBub2RlcyA9IHRoaXMuY2FyZXQoKS52aWV3KCkubm9kZXNJblJlZ2lvbih0aGlzLmxvYygpLGZhbHNlKTtcblx0XHR2YXIgbm9kZSA9IG5vZGVzWzBdO1xuXHRcdHZhciBtaWQgPSBub2RlICYmIG5vZGUubm9kZTtcblx0XHR2YXIgbGZ0ID0gbm9kZXMucHJldiAmJiBub2Rlcy5wcmV2Lm5vZGU7XG5cdFx0dmFyIHJndCA9IG5vZGVzLm5leHQgJiYgbm9kZXMubmV4dC5ub2RlO1xuXHRcdHZhciBwYXJ0O1xuXHRcdFxuXHRcdC8vIGxvZyAnbW92ZScsb2Zmc2V0LG1vZGUsbm9kZXNcblx0XHRpZiAobW9kZSA9PSBJTS5XT1JEX1NUQVJUKSB7XG5cdFx0XHR2YXIgZWwgPSBtaWQgfHwgbGZ0O1xuXHRcdFx0aWYgKCgkMSA9IGxmdCkgJiYgJDEubWF0Y2hlcyAgJiYgICQxLm1hdGNoZXMocSQoJy5faW1jbG9zZScsdGhpcykpKSB7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKGxmdC5wYXJlbnQoKS5yZWdpb24oKS5zdGFydCgpKTtcblx0XHRcdH0gZWxzZSBpZiAoKCQyID0gbGZ0KSAmJiAkMi5tYXRjaGVzICAmJiAgJDIubWF0Y2hlcyhxJCgnLl9pbXN0cicsdGhpcykpKSB7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKGxmdC5yZWdpb24oKS5zdGFydCgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBsb2MgPSB0aGlzLmxvYygpO1xuXHRcdFx0XHQvLyBsZXQgYnVmID0gdmlldy5idWZmZXJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3BlZWtiZWhpbmQnLHBlZWtiZWhpbmQsbG9jLHN0clxuXHRcdFx0XHR2YXIgc3RyID0gdGhpcy5wZWVrYmVoaW5kKCkuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcblx0XHRcdFx0bG9jIC09IHN0ci5tYXRjaCgvXihbXFxzXFx0XFwuXSouKz98KShcXGJ8JCkvKVsxXS5sZW5ndGg7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKGxvYyk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobW9kZSA9PSBJTS5XT1JEX0VORCkge1xuXHRcdFx0ZWwgPSBtaWQgfHwgcmd0O1xuXHRcdFx0aWYgKCgkMyA9IHJndCkgJiYgJDMubWF0Y2hlcyAgJiYgICQzLm1hdGNoZXMocSQoJy5faW1vcGVuJyx0aGlzKSkpIHtcblx0XHRcdFx0dGhpcy5zZXRMb2Mocmd0LnBhcmVudCgpLnJlZ2lvbigpLmVuZCgpKTtcblx0XHRcdH0gZWxzZSBpZiAoKCQ0ID0gcmd0KSAmJiAkNC5tYXRjaGVzICAmJiAgJDQubWF0Y2hlcyhxJCgnLl9pbXN0cicsdGhpcykpKSB7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKHJndC5yZWdpb24oKS5lbmQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbG9jMSA9IHRoaXMubG9jKCk7XG5cdFx0XHRcdC8vIGxldCBidWYgPSB2aWV3LmJ1ZmZlclxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdwZWVrYWhlYWQnLHBlZWthaGVhZCxsb2Ncblx0XHRcdFx0bG9jMSArPSB0aGlzLnBlZWthaGVhZCgpLm1hdGNoKC9eKFtcXHNcXC5dKi4rP3wpKFxcYnwkKS8pWzFdLmxlbmd0aDtcblx0XHRcdFx0Ly8gbG9jKysgdW50aWwgYnVmW2xvY10ubWF0Y2goL1tcXG5cXF0vKVxuXHRcdFx0XHR0aGlzLnNldExvYyhsb2MxKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChtb2RlID09IElNLkxJTkVfRU5EKSB7XG5cdFx0XHR0aGlzLnNldCh0aGlzLnJvdygpLDEwMDApO1xuXHRcdH0gZWxzZSBpZiAobW9kZSA9PSBJTS5MSU5FX1NUQVJUKSB7XG5cdFx0XHQvLyBGSVhNRSB0YWJzLWZvci1zcGFjZXNcblx0XHRcdHZhciB0YWJzID0gdGhpcy5saW5lc3RyKCkubWF0Y2goL15cXHQqLylbMF0ubGVuZ3RoO1xuXHRcdFx0dmFyIG5ld2NvbCA9IHRhYnMgKiB0aGlzLnZpZXcoKS50YWJTaXplKCk7XG5cdFx0XHR0aGlzLnNldENvbCh0aGlzLmNvbCgpID4gbmV3Y29sID8gKG5ld2NvbCkgOiAoMCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoZGlyIDwgMCAmJiAoJDUgPSBsZnQpICYmICQ1Lm1hdGNoZXMgICYmICAkNS5tYXRjaGVzKCcuX2ltdGFiJykpIHtcblx0XHRcdFx0Ly8gaGVhZC5jb2wgPSBoZWFkLmNvbCAtIDRcblx0XHRcdFx0Ly8gY2FyZXQudmlldy5sb2cgJ3JpZ2h0IGlzIHRhYicsbGZ0LnJlZ2lvblxuXHRcdFx0XHR0aGlzLnNldExvYyhsZnQucmVnaW9uKCkuc3RhcnQoKSk7XG5cdFx0XHRcdC8vIGhlYWQudW50YWJcblx0XHRcdH0gZWxzZSBpZiAoZGlyID4gMCAmJiAoJDYgPSByZ3QpICYmICQ2Lm1hdGNoZXMgICYmICAkNi5tYXRjaGVzKCcuX2ltdGFiJykpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHVzZSB0YWIgaW5zdGVhZFxuXHRcdFx0XHR0aGlzLnRhYigpO1xuXHRcdFx0XHQvLyBoZWFkLmNvbCA9IGhlYWQuY29sICsgNFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gLi4uXG5cdFx0XHRcdHRoaXMubW92ZShkaXIpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltY2FyZXRoZWFkJyk7XG5cdFxuXHQvLyBzaG91bGQgbW92ZSBpbnRvIE1hcmtlciAobGlrZSBBdG9tKVxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltY2FyZXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZWdpb247IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlZ2lvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZWdpb24gPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubGluZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2xpbmVzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMaW5lcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9saW5lcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmFuZ2VzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yYW5nZXM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJhbmdlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yYW5nZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fbW9kZSA9IHt3YXRjaDogJ21vZGVEaWRTZXQnLG5hbWU6ICdtb2RlJ307XG5cdFx0dGFnLnByb3RvdHlwZS5tb2RlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9tb2RlOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMubW9kZSgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX21vZGUgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5tb2RlRGlkU2V0ICYmIHRoaXMubW9kZURpZFNldCh2LGEsdGhpcy5fX21vZGUpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2NvbCA9IHsnZGVmYXVsdCc6IDAsd2F0Y2g6ICdkaXJ0eScsbmFtZTogJ2NvbCd9O1xuXHRcdHRhZy5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb2w7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldENvbCA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmNvbCgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2NvbCA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmRpcnR5ICYmIHRoaXMuZGlydHkodixhLHRoaXMuX19jb2wpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0YWcucHJvdG90eXBlLl9jb2wgPSAwOyAvLyB0aGUgcmVhbCBjb2x1bW4gb2YgdGhlIGNhcmV0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX3JvdyA9IHsnZGVmYXVsdCc6IDAsd2F0Y2g6ICdkaXJ0eScsbmFtZTogJ3Jvdyd9O1xuXHRcdHRhZy5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb3c7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvdyA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLnJvdygpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX3JvdyA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmRpcnR5ICYmIHRoaXMuZGlydHkodixhLHRoaXMuX19yb3cpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0YWcucHJvdG90eXBlLl9yb3cgPSAwO1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5wdXQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2lucHV0OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pbnB1dCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGFpbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdGFpbDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGFpbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90YWlsID0gdjsgcmV0dXJuIHRoaXM7IH07IC8vIHJvd2NvbFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGVhZDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGVhZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oZWFkID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9oYXNoOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIYXNoID0gZnVuY3Rpb24odil7IHRoaXMuX2hhc2ggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIChsZnQscmd0KXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHRpZihsZnQgPT09IHVuZGVmaW5lZCkgbGZ0ID0gMDtcblx0XHRcdGlmKHJndCA9PT0gdW5kZWZpbmVkKSByZ3QgPSAwO1xuXHRcdFx0dGhpcy5sb2coJ2ltY2FyZXQgZXhwYW5kJyxsZnQscmd0KTtcblx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0dmFyIGFyeSA9IGl0ZXIkKHRoaXMuZW5kcygpKTt2YXIgYSA9IGFyeVswXSxiID0gYXJ5WzFdO1xuXHRcdFx0YS5tb3ZlKGxmdCk7XG5cdFx0XHRiLm1vdmUocmd0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG5cdFx0XHRcdHJldHVybiBbdGhpcy5oZWFkKCkucm93KCksdGhpcy5oZWFkKCkuY29sKCldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIFt0aGlzLmhlYWQoKS5yb3coKSx0aGlzLmhlYWQoKS5jb2woKSx0aGlzLnRhaWwoKS5yb3coKSx0aGlzLnRhaWwoKS5jb2woKV07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAnWycgKyB0aGlzLnRvQXJyYXkoKS5qb2luKCcsJykgKyAnXSc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYgKHZhbCBpbnN0YW5jZW9mIElNLlR5cGVzLlRvaykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXQodmFsLnJlZ2lvbigpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh2YWwgaW5zdGFuY2VvZiBSZWdpb24pIHtcblx0XHRcdFx0cmV0dXJuICh0aGlzLnNldFJlZ2lvbih2YWwpLHZhbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0dGhpcy5oZWFkKCkuc2V0Um93KHZhbFswXSk7XG5cdFx0XHRcdHRoaXMuaGVhZCgpLnNldENvbCh2YWxbMV0pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHZhbC5sZW5ndGggPT0gNCkge1xuXHRcdFx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0XHRcdHRoaXMudGFpbCgpLnNldFJvdyh2YWxbMl0pO1xuXHRcdFx0XHRcdHRoaXMudGFpbCgpLnNldENvbCh2YWxbM10pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2V0VGFpbCh0aGlzLmhlYWQoKSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4cGFuZFRvTGluZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHR0aGlzLnNlbGVjdGFibGUoKTtcblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLmVuZHMoKSk7dmFyIGEgPSBhcnlbMF0sYiA9IGFyeVsxXTtcblx0XHRcdGEuc2V0Q29sKDApO1xuXHRcdFx0Yi5zZXRDb2woMTAwMCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0dGhpcy50YWlsKCkuc2V0TG9jKDApO1xuXHRcdFx0dGhpcy5oZWFkKCkuc2V0TG9jKHRoaXMudmlldygpLl9idWZmZXIubGVuKCkpOyAvLyA6bGVuZ3RoXG5cdFx0XHR0aGlzLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsZWN0YWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5kZWNvbGxhcHNlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVjb2xsYXBzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHZfO1xuXHRcdFx0aWYgKHRoaXMudGFpbCgpID09IHRoaXMuaGVhZCgpKSB7ICh0aGlzLnNldFRhaWwodl8gPSB0aGlzLmhlYWQoKS5jbG9uZSgpKSx2XykgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2xsYXBzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5zZXRUYWlsKHRoaXMuaGVhZCgpKTtcblx0XHRcdHRoaXMuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2xsYXBzZVRvU3RhcnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICh0aGlzLmlzUmV2ZXJzZWQoKSkge1xuXHRcdFx0XHR0aGlzLnNldFRhaWwodGhpcy5oZWFkKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRIZWFkKHRoaXMudGFpbCgpKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub3JpZW50YXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmlzUmV2ZXJzZWQoKSA/ICgncmV2ZXJzZWQnKSA6ICgnbm9ybWFsJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzQ29sbGFwc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy50YWlsKCkgPT0gdGhpcy5oZWFkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzUmV2ZXJzZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmhlYWQoKS5yb3coKSA8IHRoaXMudGFpbCgpLnJvdygpIHx8ICh0aGlzLnRhaWwoKS5yb3coKSA9PSB0aGlzLmhlYWQoKS5yb3coKSAmJiB0aGlzLmhlYWQoKS5jb2woKSA8IHRoaXMudGFpbCgpLmNvbCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc3RyID0gdGhpcy5oZWFkKCkubGluZXN0cigpO1xuXHRcdFx0dmFyIGluZCA9IHN0ci5tYXRjaCgvXihcXHQqKS8pWzBdO1xuXHRcdFx0cmV0dXJuIGluZDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGVla2JlaGluZCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0dmFyIHN0ciA9IHRoaXMuZW5kcygpWzBdLnBlZWtiZWhpbmQoKTtcblx0XHRcdGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHsgcmV0dXJuIHN0ci5tYXRjaCh2YWwpIH07XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKG9mZnNldCxtb2RlKXtcblx0XHRcdGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAxO1xuXHRcdFx0aWYobW9kZSA9PT0gdW5kZWZpbmVkKSBtb2RlID0gMDtcblx0XHRcdHRoaXMuaGVhZCgpLmFsdGVyKG1vZGUsb2Zmc2V0KTtcblx0XHRcdHJldHVybiB0aGlzLmRpcnR5KCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB3aGF0IGlmIHdlIFxuXHRcdHRhZy5wcm90b3R5cGUubW92ZURvd24gPSBmdW5jdGlvbiAobGVuKXtcblx0XHRcdGlmKGxlbiA9PT0gdW5kZWZpbmVkKSBsZW4gPSAxO1xuXHRcdFx0dGhpcy5oZWFkKCkubW92ZURvd24oKTtcblx0XHRcdHJldHVybiB0aGlzLmRpcnR5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1vdmVVcCA9IGZ1bmN0aW9uIChsZW4pe1xuXHRcdFx0aWYobGVuID09PSB1bmRlZmluZWQpIGxlbiA9IDE7XG5cdFx0XHR0aGlzLmhlYWQoKS5tb3ZlVXAoKTtcblx0XHRcdHJldHVybiB0aGlzLmRpcnR5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVuZHMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmlzUmV2ZXJzZWQoKSA/IChbdGhpcy5oZWFkKCksdGhpcy50YWlsKCldKSA6IChbdGhpcy50YWlsKCksdGhpcy5oZWFkKCldKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMucmVnaW9uKCkudGV4dCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGdldCB0aGUgYWN0dWFsIHJlZ2lvbiBiYXNlZCBvbiBoZWFkIGFuZCB0YWlsXG5cdFx0XHQvLyBnZXR0aW5nIHRoZSBjb2RlIG1pZ2h0IGJlIGV4cGVuc2l2ZSBpZiBkb25lXG5cdFx0XHQvLyB0b28gbWFueSB0aW1lcyAtLSBidXQgZWFzeSB0byBjYWNoZVxuXHRcdFx0Ly8gc2VuZCB0aGlzIHRvIHV0aWwgaW5zdGVhZFxuXHRcdFx0dmFyIGFyeTtcblx0XHRcdHZhciBjb2RlID0gdGhpcy52aWV3KCkuY29kZSgpO1xuXHRcdFx0dmFyIGxpbmVzID0gY29kZS5zcGxpdCgnXFxuJyk7XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5lbmRzKCkpO3ZhciBhID0gYXJ5WzBdLGIgPSBhcnlbMV07XG5cdFx0XHRcblx0XHRcdHZhciBzdGFydCA9IDA7XG5cdFx0XHR2YXIgZW5kID0gMDtcblx0XHRcdHZhciBsbiA9IDA7XG5cdFx0XHRcblx0XHRcdHZhciBhciA9IGEucm93KCksYWMgPSBhLmNvbCgpLGJyID0gYi5yb3coKSxiYyA9IGIuY29sKCk7XG5cdFx0XHR2YXIgY2hhciQ7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpdGVtcyA9IGl0ZXIkKGxpbmVzKSwgbGVuID0gaXRlbXMubGVuZ3RoLCBsaW5lOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bGluZSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRsbiA9IGxpbmUubGVuZ3RoO1xuXHRcdFx0XHRpZiAoaSA8IGFyKSB7XG5cdFx0XHRcdFx0c3RhcnQgKz0gbG4gKyAxOyAvLyBpbmNsdWRlIG5ld2xpbmVcblx0XHRcdFx0fSBlbHNlIGlmIChpID09IGFyKSB7XG5cdFx0XHRcdFx0dmFyIG9mZnNldCA9IHV0aWwuY29sVG9Mb2MobGluZSxhYyk7XG5cdFx0XHRcdFx0c3RhcnQgKz0gTWF0aC5taW4obG4sb2Zmc2V0KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChpIDwgYnIpIHtcblx0XHRcdFx0XHRlbmQgKz0gbG4gKyAxOyAvLyBpbmNsdWRlIG5ld2xpbmVcblx0XHRcdFx0fSBlbHNlIGlmIChpID09IGJyKSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdXRpbC5jb2xUb0xvYyhsaW5lLGJjKTtcblx0XHRcdFx0XHRlbmQgKz0gTWF0aC5taW4obG4sb2Zmc2V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgUmVnaW9uKHN0YXJ0LGVuZCx0aGlzLnZpZXcoKS5yb290KCksdGhpcy52aWV3KCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZWdpb24gPSBmdW5jdGlvbiAocmVnKXtcblx0XHRcdHZhciBidWYgPSB0aGlzLnZpZXcoKS5jb2RlKCk7XG5cdFx0XHR2YXIgYSA9IHV0aWwucm93Y29sKGJ1ZixyZWcuYSgpKTtcblx0XHRcdHZhciBiID0gdXRpbC5yb3djb2woYnVmLHJlZy5iKCkpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnNldEhlYWQobmV3IFJvd0NvbChiWzBdLGJbMV0sdGhpcykpO1xuXHRcdFx0XG5cdFx0XHRpZiAocmVnLnNpemUoKSA9PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2V0VGFpbCh0aGlzLmhlYWQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldFRhaWwobmV3IFJvd0NvbChhWzBdLGFbMV0sdGhpcykpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzLmRpcnR5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKHJlZyl7XG5cdFx0XHRpZihyZWcgPT09IHVuZGVmaW5lZCkgcmVnID0gdGhpcy5yZWdpb24oKTtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHJlZyx0aGlzLmlzQ29sbGFwc2VkKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHJhdGhlciBtb3ZlIHRoaXMgdG8gcmVnaW9uIGl0c2VsZlxuXHRcdHRhZy5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24gKHJlZyl7XG5cdFx0XHRpZihyZWcgPT09IHVuZGVmaW5lZCkgcmVnID0gdGhpcy5yZWdpb24oKTtcblx0XHRcdHZhciBub2RlcyA9IHRoaXMubm9kZXMocmVnKTtcblx0XHRcdGlmIChub2Rlcy5sZW5ndGggPiAyKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsLmNvbW1vbkFuY2VzdG9yKG5vZGVzLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBuLm5vZGU7IH0pKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbm9kZXNbMF0ubm9kZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHRleHQsZWRpdCl7XG5cdFx0XHRcblx0XHRcdHZhciBzdWIgPSAnJztcblx0XHRcdHRoaXMudmlldygpLmhpc3RvcnkoKS5tYXJrKCdhY3Rpb24nKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEodGhpcy5pc0NvbGxhcHNlZCgpKSkge1xuXHRcdFx0XHR2YXIgcmVnID0gdGhpcy5yZWdpb24oKTtcblx0XHRcdFx0c3ViID0gcmVnLnRleHQoKTtcblx0XHRcdFx0dGhpcy52aWV3KCkuZXJhc2UocmVnKTtcblx0XHRcdFx0dGhpcy5jb2xsYXBzZVRvU3RhcnQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBtb3ZlID0gMDtcblx0XHRcdHZhciBzZWw7XG5cdFx0XHRcblx0XHRcdC8vIG5lZWQgYSBkaWZmZXJlbnQgc3ludGF4IGZvciAkMCAtLSBjYW4gYmUgaW4gcmVndWxhciBwYXN0ZWQgY29kZVxuXHRcdFx0Ly8gc2hvdWxkIGhhdmUgYSBzZXBhcmF0ZSBjb21tYW5kIGZvciBpbnNlcnRTbmlwcGV0IHByb2JhYmx5LlxuXHRcdFx0aWYgKHRleHQuaW5kZXhPZignJDAnKSA+PSAwKSB7XG5cdFx0XHRcdHNlbCA9IHRoaXMucmVnaW9uKCkuY2xvbmUoMCxzdWIubGVuZ3RoKS5tb3ZlKHRleHQuaW5kZXhPZignJDAnKSk7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoJyQwJyxzdWIpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0ZWRpdCB8fCAoZWRpdCA9IHtzaXplOiB0ZXh0Lmxlbmd0aH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmhlYWQoKS5ub3JtYWxpemUoKTtcblx0XHRcdHZhciByZXMgPSB0aGlzLnZpZXcoKS5pbnNlcnQodGhpcy5yZWdpb24oKS5zdGFydCgpLHRleHQsZWRpdCk7XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2coJ2luc2VydGVkIC0tIG5vdyBtb3ZlJyxlZGl0LnNpemUpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2VsKSB7XG5cdFx0XHRcdHRoaXMuc2V0UmVnaW9uKHNlbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBtb3ZlIGxvY2F0aW9uc1xuXHRcdFx0XHR0aGlzLmhlYWQoKS5zZXRMb2ModGhpcy5oZWFkKCkubG9jKCkgKyBlZGl0LnNpemUpO1xuXHRcdFx0XHQvLyBoZWFkLm1vdmUoZWRpdDpzaXplKVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5kaXJ0eSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbiAobW9kZSl7XG5cdFx0XHR0aGlzLnZpZXcoKS5oaXN0b3J5KCkubWFyaygnYWN0aW9uJyk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcblx0XHRcdFx0dGhpcy5sb2coJ2lzQ29sbGFwc2VkJyxtb2RlKTtcblx0XHRcdFx0dGhpcy5kZWNvbGxhcHNlKCk7XG5cdFx0XHRcdHRoaXMuaGVhZCgpLmFsdGVyKG1vZGUsLTEpOyAvLyBcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGRpcnR5XG5cdFx0XHRcdC8vIHJldHVybiBlcmFzZSAjIGNhbGwgYWdhaW4gbm93XG5cdFx0XHR9O1xuXHRcdFx0Y29uc29sZS5sb2coJ2VyYXNpbmcgcmVnaW9uJyx0aGlzLnJlZ2lvbigpKTtcblx0XHRcdHRoaXMudmlldygpLmVyYXNlKHRoaXMucmVnaW9uKCkpO1xuXHRcdFx0Ly8gbG9nICdub3cgY29sbGFwc2UgcmVnaW9uIHRvIHN0YXJ0JyxyZWdpb25cblx0XHRcdHRoaXMuY29sbGFwc2VUb1N0YXJ0KCk7XG5cdFx0XHQvLyBsb2cgcmVnaW9uXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0KHRoaXMucmVnKCkpO1xuXHRcdFx0dGhpcy5zZXRSZWdpb24odGhpcy5yZWcoKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5lZGl0KFxuXHRcdFx0XHR7dGV4dDogJycsXG5cdFx0XHRcdHRhcmdldDogdGFyZ2V0LFxuXHRcdFx0XHRyZWdpb246IHRoaXMucmVnKCksXG5cdFx0XHRcdGNhcmV0OiB0aGlzLnJlZygpLmNsb25lKCkuY29sbGFwc2UoZmFsc2UpfVxuXHRcdFx0KTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciAkMSwgJDI7XG5cdFx0XHR0aGlzLl90aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0Ly8gdmFyIGhhc2ggPSB0b0FycmF5LmpvaW4oXCJcIilcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX2hhc2ggIT0gdGhpcy50b0hhc2goKSkge1xuXHRcdFx0XHQvLyB0aGUgcmVhbENvbCB2YWx1ZXMgY291bGQgaGF2ZSBjaGFuZ2VkIHRob3VnaD9cblx0XHRcdFx0dGhpcy52aWV3KCkuaGlzdG9yeSgpLm9uY2FyZXQodGhpcy5faGFzaCx0aGlzLnRvSGFzaCgpLHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9oYXNoID0gdGhpcy50b0hhc2goKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2NhcmV0IGhhcyBhY3R1YWxseSBjaGFuZ2VkJyxAaGFzaFxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHJldiA9IHRoaXMuaXNSZXZlcnNlZCgpO1xuXHRcdFx0dmFyIGEgPSB0aGlzLnRhaWwoKTtcblx0XHRcdHZhciBiID0gdGhpcy5oZWFkKCk7XG5cdFx0XHRcblx0XHRcdGlmIChyZXYpIHsgJDEgPSBiLCQyID0gYSxhID0gJDEsYiA9ICQyIH07XG5cdFx0XHRcblx0XHRcdHZhciBsYyA9IGIucm93KCkgLSBhLnJvdygpO1xuXHRcdFx0dmFyIHJvdyA9IGEucm93KCk7XG5cdFx0XHRcblx0XHRcdHZhciBhYyA9IGEucmVhbENvbCgpOyAvLyBNYXRoLm1pbiggYS5jb2wsIHV0aWwuY29sc0ZvckxpbmUodmlldy5saW5lc3RyKGEucm93KSApIClcblx0XHRcdHZhciBiYyA9IGIucmVhbENvbCgpOyAvLyBNYXRoLm1pbiggYi5jb2wsIHV0aWwuY29sc0ZvckxpbmUodmlldy5saW5lc3RyKGIucm93KSApIClcblx0XHRcdHZhciBoYyx0Yztcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNSZXZlcnNlZCgpKSB7XG5cdFx0XHRcdGhjID0gYWM7XG5cdFx0XHRcdHRjID0gYmM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYyA9IGJjO1xuXHRcdFx0XHR0YyA9IGFjO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbG9nICdkaXJ0eScscmVnaW9uLGEucm93LGEuY29sLGIucm93LGIuY29sLGhjLHRjLGhlYWQsdGFpbCxyZXZcblx0XHRcdFxuXHRcdFx0dGhpcy5jc3Moe3RyYW5zZm9ybTogKFwidHJhbnNsYXRlKDBweCxcIiArIChhLnJvdygpICogMTAwKSArIFwiJSlcIil9KTtcblx0XHRcdC8vIGNvbnZlcnQgdGhlIHJvdyBhbmQgY29sdW1uIHRvIGEgcmVnaW9uIChzaG91bGQgZ28gYm90aCB3YXlzKVxuXHRcdFx0dGhpcy5fY2FyZXQuY3NzKHt0cmFuc2Zvcm06IChcInRyYW5zbGF0ZShcIiArIGhjICsgXCJjaCxcIiArICgodGhpcy5oZWFkKCkucm93KCkgLSByb3cpICogMTAwKSArIFwiJSlcIil9KTtcblx0XHRcdHRoaXMuX3N0YXJ0LmNzcyh7bWFyZ2luTGVmdDogKFwiXCIgKyBhYyArIFwiY2hcIiksd2lkdGg6IFwiYXV0b1wifSk7XG5cdFx0XHR0aGlzLl9lbmQuY3NzKHt3aWR0aDogKFwiXCIgKyBiYyArIFwiY2hcIil9KTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuXHRcdFx0XHR0aGlzLnNldE1vZGUoJ2NvbGxhcHNlZCcpO1xuXHRcdFx0fSBlbHNlIGlmIChsYyA9PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2V0TW9kZSgnc2luZ2xlJyk7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0LmNzcyh7d2lkdGg6IChiYyAtIGFjKSArIFwiY2hcIn0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbWlkLnNldFRleHQobGMgPiAxID8gKCgnXFxuJykucmVwZWF0KGxjIC0gMSkpIDogKCcnKSk7XG5cdFx0XHRcdHRoaXMuc2V0TW9kZSgnbXVsdGknKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZWxhcHNlZCA9IChuZXcgRGF0ZSgpIC0gdGhpcy5fdGltZXN0YW1wKTtcblx0XHRcdHZhciBmbGlwID0gTWF0aC5yb3VuZChlbGFwc2VkIC8gNTAwKSAlIDI7XG5cdFx0XHRcblx0XHRcdGlmIChmbGlwICE9IHRoaXMuX2ZsaXApIHtcblx0XHRcdFx0dGhpcy5fY2FyZXQuZmxhZygnYmxpbmsnLGZsaXApO1xuXHRcdFx0XHR0aGlzLl9mbGlwID0gZmxpcDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHZfLCB0MDtcblx0XHRcdHRoaXMuc2V0VGFpbCgodGhpcy5zZXRIZWFkKHZfID0gbmV3IFJvd0NvbCgwLDAsdGhpcykpLHZfKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0Ly8gPGltY2FwdG9yQGlucHV0IHZhbHVlPSd4Jz5cblx0XHRcdFx0KHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJHNwYW4oKS5mbGFnKCdkaW0nKSkuc2V0VGV4dCgneCcpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy5fY2FyZXQgPSB0aGlzLl9jYXJldCB8fCB0YWckLiRpbWNhcmV0aGVhZCgpLnNldFJlZignY2FyZXQnLHRoaXMpKS5lbmQoKSxcblx0XHRcdFx0KHQwID0gdGhpcy5fbGluZXM9dGhpcy5fbGluZXMgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdsaW5lcycsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0aGlzLl9zdGFydCA9IHRoaXMuX3N0YXJ0IHx8IHRhZyQuJGRpdigpLnNldFJlZignc3RhcnQnLHRoaXMpKS5zZXRUZXh0KFwiIFwiKS5lbmQoKSxcblx0XHRcdFx0XHQodGhpcy5fbWlkID0gdGhpcy5fbWlkIHx8IHRhZyQuJGRpdigpLnNldFJlZignbWlkJyx0aGlzKSkuZW5kKCksXG5cdFx0XHRcdFx0KHRoaXMuX2VuZCA9IHRoaXMuX2VuZCB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2VuZCcsdGhpcykpLnNldFRleHQoXCIgXCIpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdF0sMikuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5oZWFkKCkubm9ybWFsaXplKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubW9kZURpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHR0aGlzLnVuZmxhZyhvbGQpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZyhuZXckKTtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvY2FyZXQuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdzY3JpbWJsYS1vdmVybGF5JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihKU09OLnN0cmluZ2lmeSh0aGlzLm9iamVjdCgpKSwzKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnc2NyaW1ibGEtb3ZlcmxheXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodHlwZSxkYXRhKXtcblx0XHRcdGlmKGRhdGEgPT09IHVuZGVmaW5lZCkgZGF0YSA9IHt9O1xuXHRcdFx0Y29uc29sZS5sb2coJ2FkZCBvdmVybGF5IScpO1xuXHRcdFx0dGhpcy5hcHBlbmQodGFnJC4kc2NyaW1ibGFfb3ZlcmxheSgpLnNldFZpZXcodGhpcy52aWV3KCkpLnNldE9iamVjdChkYXRhKS5lbmQoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwb3NpdGlvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy92aWV3cy9vdmVybGF5cy5pbWJhXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWVkaXRvcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFxuXHRcdFx0XHQodGhpcy5fdmlldyA9IHRoaXMuX3ZpZXcgfHwgdGFnJC4kaW12aWV3KCkuc2V0UmVmKCd2aWV3Jyx0aGlzKSkuZW5kKClcblx0XHRcdCwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZpZXc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5hY3RpdmF0ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMudmlldygpLmRlYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvZGUsb3B0cyl7XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2FkKGNvZGUsb3B0cyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZnMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBJTS5GUztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25jb21tYW5kID0gZnVuY3Rpb24gKGUsYyl7XG5cdFx0XHRpZiAodGhpc1tjLmNvbW1hbmRdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0dGhpc1tjLmNvbW1hbmRdLmNhbGwodGhpcyxjLmFyZ3MgfHwgW10pO1xuXHRcdFx0XHRlLmhhbHQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25zYXZlc2Vzc2lvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Y29uc29sZS5sb2coXCJpbWVkaXRvci5zYXZlU2Vzc2lvblwiLHRoaXMpO1xuXHRcdFx0dmFyIHBhdGggPSB0aGlzLnZpZXcoKS5maWxlbmFtZSgpLnJlcGxhY2UoL1xcLmltYmEkLywnLmltYmFzZXNzaW9uJyk7XG5cdFx0XHR2YXIgYm9keSA9IEpTT04uc3RyaW5naWZ5KHRoaXMudmlldygpLmhpc3RvcnkoKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBJTS5GUy5zYXZlKHBhdGgsYm9keSxmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGNvbnNvbGUubG9nKCdyZXR1cm5lZCBmcm9tIHNhdmluZyEnLHBhdGgpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9lZGl0b3IuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdC8qXG5cdEJyaWRnZSBmb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBJbWJhIGNvbXBpbGVyIGluIGEgd29ya2VyXG5cdCovXG5cdFxuXHRmdW5jdGlvbiBJbWJhY1dvcmtlcihwYXRoKXtcblx0XHRpZihwYXRoID09PSB1bmRlZmluZWQpIHBhdGggPSBcIi92ZW5kb3IvaW1iYS9pbWJhYy53b3JrZXIubWluLmpzXCI7XG5cdFx0dGhpcy5fcGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5fY2FsbGJhY2tzID0gW107XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuSW1iYWNXb3JrZXIgPSBJbWJhY1dvcmtlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbWJhY1dvcmtlci5wcm90b3R5cGUud29ya2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwcm9jZXNzMTtcblx0XHRyZXR1cm4gc2VsZi5fd29ya2VyIHx8IChzZWxmLl93b3JrZXIgPSAodHJ1ZSkgJiYgKFxuXHRcdFx0cHJvY2VzczEgPSBuZXcgV29ya2VyKHNlbGYuX3BhdGgpLFxuXHRcdFx0cHJvY2VzczEub25tZXNzYWdlID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi5vbm1lc3NhZ2UoZSk7IH0sXG5cdFx0XHRwcm9jZXNzMVxuXHRcdCkpO1xuXHR9O1xuXHRcblx0SW1iYWNXb3JrZXIucHJvdG90eXBlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgZm47XG5cdFx0aWYgKGZuID0gdGhpcy5fY2FsbGJhY2tzLnNoaWZ0KCkpIHtcblx0XHRcdHJldHVybiBmbihlLmRhdGEsZSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdEltYmFjV29ya2VyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGNvZGUsbyxjYil7XG5cdFx0dGhpcy5fY2FsbGJhY2tzLnB1c2goY2IpO1xuXHRcdHRoaXMud29ya2VyKCkucG9zdE1lc3NhZ2UoWydjb21waWxlJyxjb2RlLG9dKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmFjV29ya2VyLnByb3RvdHlwZS5hbmFseXplID0gZnVuY3Rpb24gKGNvZGUsbyxjYil7XG5cdFx0dGhpcy5fY2FsbGJhY2tzLnB1c2goY2IpO1xuXHRcdHRoaXMud29ya2VyKCkucG9zdE1lc3NhZ2UoWydhbmFseXplJyxjb2RlLG9dKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cmV0dXJuIEltYmFjV29ya2VyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS93b3JrZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0cmVxdWlyZShcIi4vYmFzZVwiKTtcblx0cmVxdWlyZShcIi4vdG9rZW5cIik7XG5cdHJlcXVpcmUoXCIuL2Jsb2NrXCIpO1xuXHRyZXF1aXJlKFwiLi9yb290XCIpO1xuXHRyZXF1aXJlKFwiLi9saXRlcmFsc1wiKTtcblx0cmVxdWlyZShcIi4vb3BlcmF0b3JzXCIpO1xuXHRyZXF1aXJlKFwiLi9zZWxlY3RvclwiKTtcblx0cmVxdWlyZShcIi4vd2hpdGVzcGFjZVwiKTtcblx0cmV0dXJuIHJlcXVpcmUoXCIuL2Fubm90YXRpb25zXCIpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvaW5kZXguaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi4vY29yZS9oaWdobGlnaHRlcicpLkhpZ2hsaWdodGVyO1xuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXHRcblx0Ly8gZGFuZ2Vyb3VzIHRvIGV4dGVuZCBhbGwgaHRtbGVsZW1lbnQgdGFncyBnbG9iYWxseVxuXHR0YWckLmV4dGVuZFRhZygnaHRtbGVsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gKG5hbWUsZGF0YSl7XG5cdFx0XHQvLyBsb2cgXCJidWJibGUgZXZlbnRcIixuYW1lLGRhdGFcblx0XHRcdHZhciBldiA9IEltYmEuRXZlbnRzLnRyaWdnZXIobmFtZSx0aGlzLHtkYXRhOiBkYXRhLGJ1YmJsZTogdHJ1ZX0pO1xuXHRcdFx0cmV0dXJuIGV2O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChuYW1lLHRpbWUsYmxrKXtcblx0XHRcdHRoaXMuX3RpbWVvdXRzIHx8ICh0aGlzLl90aW1lb3V0cyA9IHt9KTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0c1tuYW1lXSk7XG5cdFx0XHRpZiAodGltZSAhPSAtMSkgeyB0aGlzLl90aW1lb3V0c1tuYW1lXSA9IHNldFRpbWVvdXQoYmxrLHRpbWUpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIChlbCl7XG5cdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBJTUZyYWdtZW50KSB7XG5cdFx0XHRcdGVsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuZG9tKCkuY2hpbGROb2Rlcyk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZWwucmV2ZXJzZSgpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXROZXh0KGFyeVtpXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGN1cnIgPSB0aGlzLmRvbSgpLm5leHRTaWJsaW5nO1xuXHRcdFx0aWYgKCh0eXBlb2YgZWw9PSdzdHJpbmcnfHxlbCBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0ZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY3Vycikge1xuXHRcdFx0XHR0aGlzLnBhcmVudCgpLmluc2VydEJlZm9yZShlbCxjdXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucGFyZW50KCkuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQcmV2ID0gZnVuY3Rpb24gKGVsKXtcblx0XHRcdGlmIChlbCBpbnN0YW5jZW9mIElNRnJhZ21lbnQpIHtcblx0XHRcdFx0ZWwgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5kb20oKS5jaGlsZE5vZGVzKTtcblx0XHRcdFx0Ly8gZWwgPSBbXS5jb25jYXQoZWwuZG9tOmNoaWxkTm9kZXMpXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZWwpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLnNldFByZXYoYXJ5W2ldKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgY3VyciA9IHRoaXMuZG9tKCkucHJldlNpYmxpbmc7XG5cdFx0XHRpZiAoKHR5cGVvZiBlbD09J3N0cmluZyd8fGVsIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0XHRlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGVsKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnBhcmVudCgpLmluc2VydEJlZm9yZShlbCx0aGlzKTtcblx0XHRcdC8vIHBhcmVudC5pbnNlcnQoZWwsIGJlZm9yZTogc2VsZilcblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmV4dE5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLm5leHRTaWJsaW5nO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wcmV2Tm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucHJldlNpYmxpbmc7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRJTS5UeXBlcyA9IHt9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltJywgJ2InLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5rZXkgPSBmdW5jdGlvbiAoa2V5LGhhbmRsZXIpe1xuXHRcdFx0dGhpcy5wcm90b3R5cGVbKFwiaGFuZGxlXCIgKyBrZXkpXSA9IGhhbmRsZXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5uYXRpdmUgPSBmdW5jdGlvbiAodHlwKXtcblx0XHRcdHRoaXMuX25hdGl2ZVR5cGUgPSB0eXA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy50eXBlID0gZnVuY3Rpb24gKHR5cCl7XG5cdFx0XHRJTS5UeXBlc1t0eXBdID0gdGhpcztcblx0XHRcdHRoaXMuX3R5cGUgPSB0eXA7XG5cdFx0XHR0aGlzLnByb3RvdHlwZS5fdHlwZSA9IHR5cDtcblx0XHRcdC8vIEBkb21GbGFncy5wdXNoKHR5cCkgaWYgQGRvbUZsYWdzXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy50eXBlKCdUb2snKTtcblx0XHRcblx0XHR0YWcuYWxpYXMgPSBmdW5jdGlvbiAodHlwKXtcblx0XHRcdElNLlR5cGVzW3R5cF0gPSB0aGlzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcudHJpZ2dlciA9IGZ1bmN0aW9uIChtYXRjaCxjbWQpe1xuXHRcdFx0aWYgKGNtZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdGNtZCA9IHtjb21tYW5kOiBjbWR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y21kLnRyaWdnZXIgPSBtYXRjaDtcblx0XHRcdHJldHVybiB0aGlzLnByb3RvdHlwZVsoXCJ0cmlnZ2VyLVwiICsgbWF0Y2gpXSA9IGNtZDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGludCA9IGZ1bmN0aW9uIChoaW50KXtcblx0XHRcdGlmIChoaW50ICYmIGhpbnQgIT0gdGhpcy5faGludCkge1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnaGludCcsaGludC5yZWYoKSk7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKFwiaGludC10eXBlXCIsaGludC50eXBlKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2hpbnQnKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2hpbnQtdHlwZScpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzLl9oaW50ID0gaGludDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGludCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gc3RyYW5nZSBubz9cdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5faGludCB8fCB0aGlzLnZpZXcoKS5oaW50cygpLmdldCh0aGlzLmdldEF0dHJpYnV0ZSgnaGludCcpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGdvIG92ZXIgdG8gdXNpbmcgdGhpcyBcblx0XHR0YWcucHJvdG90eXBlLndhbGtUZXh0Tm9kZXMgPSBmdW5jdGlvbiAobWFyayl7XG5cdFx0XHRpZihtYXJrID09PSB1bmRlZmluZWQpIG1hcmsgPSBmYWxzZTtcblx0XHRcdHRoaXMuc2V0Um9vdCh0aGlzLmRvbSgpKTtcblx0XHRcdHZhciBlbDtcblx0XHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdFx0dmFyIHBvcyA9IDA7XG5cdFx0XHR2YXIgd2FsayA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIodGhpcy5yb290KCksTm9kZUZpbHRlci5TSE9XX1RFWFQsbnVsbCxmYWxzZSk7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChlbCA9IHdhbGsubmV4dE5vZGUoKSl7XG5cdFx0XHRcdGlmIChtYXJrKSB7XG5cdFx0XHRcdFx0dmFyIGxlbiA9IGVsLmxlbmd0aDtcblx0XHRcdFx0XHRlbC5fbG9jID0gcG9zO1xuXHRcdFx0XHRcdHBvcyArPSBsZW47XG5cdFx0XHRcdH07XG5cdFx0XHRcdG5vZGVzLnB1c2goZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5vZGVzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51dGlsID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdXRpbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuY2FyZXQoKS5zZXQodGhpcy5yZWdpb24oKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhblByZXBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhbkFwcGVuZCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgbG9nZ2VyXztcblx0XHRcdChsb2dnZXJfID0gdGhpcy52aWV3KCkubG9nZ2VyKCkpLmxvZy5hcHBseShsb2dnZXJfLGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLm91dGVySFRNTDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3BhY2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5kb20oKS5uZXh0U2libGluZyBpbnN0YW5jZW9mIFRleHQpIHtcblx0XHRcdFx0cmV0dXJuICgvW1xcdCBdLykudGVzdCh0aGlzLmRvbSgpLm5leHRTaWJsaW5nLnRleHRDb250ZW50WzBdKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnVuc3BhY2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gISh0aGlzLnNwYWNlZCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmV4dEltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY291bGQgYmUgdGV4dCBhcyB3ZWxsP1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkubmV4dFNpYmxpbmcgaW5zdGFuY2VvZiBUZXh0ID8gKG51bGwpIDogKHRoaXMubmV4dCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJldkltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY291bGQgYmUgdGV4dCBhcyB3ZWxsP1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucHJldmlvdXNTaWJsaW5nIGluc3RhbmNlb2YgVGV4dCA/IChudWxsKSA6ICh0aGlzLnByZXYoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnRleHRDb250ZW50O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0dGhpcy5kb20oKS50ZXh0Q29udGVudCA9IHRleHQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkudGV4dENvbnRlbnQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENvZGUgPSBmdW5jdGlvbiAoY29kZSxzaWxlbnQpe1xuXHRcdFx0dmFyIGhpbnRfO1xuXHRcdFx0aWYoc2lsZW50ID09PSB1bmRlZmluZWQpIHNpbGVudCA9IGZhbHNlO1xuXHRcdFx0dmFyIHByZXYgPSB0aGlzLmNvZGUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX2RvbS5maXJzdENoaWxkID09IHRoaXMuX2RvbS5sYXN0Q2hpbGQgJiYgKHRoaXMuX2RvbS5maXJzdENoaWxkIGluc3RhbmNlb2YgVGV4dCkpIHtcblx0XHRcdFx0Ly8gc3RpbGwgc2V0IGlmIGl0IGhhcyBub3QgY2hhbmdlZD9cblx0XHRcdFx0dGhpcy5fZG9tLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgPSBjb2RlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZG9tLnRleHRDb250ZW50ID0gY29kZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjb2RlICE9IHByZXYpIHtcblx0XHRcdFx0KGhpbnRfID0gdGhpcy5oaW50KCkpICYmIGhpbnRfLmNoYW5nZWQgICYmICBoaW50Xy5jaGFuZ2VkKCk7XG5cdFx0XHRcdGlmICghc2lsZW50KSB7IHRoaXMub25jaGFuZ2VkKGNvZGUscHJldikgfTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25jaGFuZ2VkID0gZnVuY3Rpb24gKGNvZGUscHJldil7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdkaXJ0eScpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKCkubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcGFyZW50Xztcblx0XHRcdHJldHVybiB0aGlzLl92aWV3IHx8ICgocGFyZW50XyA9IHRoaXMucGFyZW50KCkpICYmIHBhcmVudF8udmlldyAgJiYgIHBhcmVudF8udmlldygpKSB8fCBWSUVXO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWwgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5jYXJldCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5yZWdpb25Gb3JOb2RlKHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnJlZ2lvbigpLmxvYygpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVjcmVhc2VJbmRlbnQgPSBmdW5jdGlvbiAocHJlLHN0YXRlKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5jcmVhc2VJbmRlbnQgPSBmdW5jdGlvbiAocHJlLHN0YXRlKXtcblx0XHRcdHZhciByZWcgPSAvXihcXHMqKC4qXFw9XFxzKik/KGNsYXNzfGRlZnx0YWd8dW5sZXNzfGlmfGVsc2V8ZWxpZnxzd2l0Y2h8dHJ5fGNhdGNofGZpbmFsbHl8Zm9yfHdoaWxlfHVudGlsfGRvKSkvO1xuXHRcdFx0cmV0dXJuIHJlZy50ZXN0KHByZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24gKHJlZ2lvbixtb2RlKXtcblx0XHRcdGlmIChtb2RlID09ICdhbGwnKSB7XG5cdFx0XHRcdHRoaXMub3JwaGFuaXplKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldENvZGUodXRpbC5wYXRjaFN0cmluZyh0aGlzLmNvZGUoKSwnJyxyZWdpb24pKTsgLy8gY29kZS5pbnMoJycscmVnaW9uKVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVnaW9uLHN0cixlZGl0LHBhcnMpe1xuXHRcdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdFx0dmFyIG1vZGUgPSBwYXJzLm1vZGUgIT09IHVuZGVmaW5lZCA/IHBhcnMubW9kZSA6IG51bGw7XG5cdFx0XHR0aGlzLnNldENvZGUodXRpbC5wYXRjaFN0cmluZyh0aGlzLmNvZGUoKSxzdHIscmVnaW9uKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnNlcnRlZCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmNvbW1hbmQgPSBmdW5jdGlvbiAoZSxjbWQpe1xuXHRcdFx0dmFyIG5hbWUgPSBjbWQuY29tbWFuZDtcblx0XHRcdHZhciBmbiA9IHRoaXNbbmFtZV07XG5cdFx0XHR0aGlzLmxvZygncnVuIG9uY29tbWFuZCcsbmFtZSxjbWQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRmbi5jYWxsKHRoaXMsZSxjbWQpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbmRlbnRCbG9jayA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCdpbS5pbmRlbnRCbG9jaycsYXJndW1lbnRzLHRoaXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0XHRyZXR1cm4gSU0udG9rKHZhbCkuY2xhc3NpZnkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzRmlyc3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBwYXIgPSB0aGlzLnBhcmVudCgpO1xuXHRcdFx0cmV0dXJuIChwYXIgaW5zdGFuY2VvZiBJTS5UeXBlcy5Ub2spICYmIHBhci5kb20oKS5maXJzdENoaWxkID09IHRoaXMuZG9tKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzTGFzdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHBhciA9IHRoaXMucGFyZW50KCk7XG5cdFx0XHRyZXR1cm4gKHBhciBpbnN0YW5jZW9mIElNLlR5cGVzLlRvaykgJiYgcGFyLmRvbSgpLmxhc3RDaGlsZCA9PSB0aGlzLmRvbSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0aWYoY29kZSA9PT0gdW5kZWZpbmVkKSBjb2RlID0gdGhpcy50ZXh0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWxpZGF0ZShjb2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWFya0ludmFsaWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZmxhZygnaW52YWxpZCcpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1hcmtWYWxpZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy51bmZsYWcoJ2ludmFsaWQnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0ludmFsaWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmhhc0ZsYWcoJ2ludmFsaWQnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xhc3NpZnkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdW53cmFwIC8gcmVtb3ZlIHRoaXMgbm9kZSBmcm9tIHBhcmVudFxuXHRcdHRhZy5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZWwgPSB0aGlzLmRvbSgpO1xuXHRcdFx0dmFyIHBhciA9IGVsLnBhcmVudE5vZGU7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChlbC5maXJzdENoaWxkKXtcblx0XHRcdFx0cGFyLmluc2VydEJlZm9yZShlbC5maXJzdENoaWxkLGVsKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAob3RoZXIpe1xuXHRcdFx0dGhpcy5zZXRQcmV2KG90aGVyKTtcblx0XHRcdHJldHVybiB0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xvc2VzdChxJCgnLl9pbmRlbnQnLHRoaXMpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uIChtdXRzKXtcblx0XHRcdC8vIHJlbW92ZSBub2RlIGlmIGl0IGlzIG9ycGhhbml6ZWRcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmIChzZWxmLmNvZGUoKSA9PSAnJykge1xuXHRcdFx0XHRzZWxmLmxvZygncmVtb3ZlIHdob2xlIG5vZGUnKTtcblx0XHRcdFx0Ly8gc2hvdWxkIHBvc3NpYmx5XG5cdFx0XHRcdHJldHVybiBzZWxmLm9ycGhhbml6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5sb2coJ211dGF0ZWQgLS0gcmVwYXJzZScpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKHNlbGYuZGlydHlFeHRlbnQoKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVjbGFzc2lmeSA9IGZ1bmN0aW9uICh0eXBlKXtcblx0XHRcdC8vIHJlY2xhc3NpZnkgc2hvdWxkIGhhcHBlbiB0aHJvdWdoIHRoZSBoaWdobGlnaHRlclxuXHRcdFx0Ly8gbG9nICdyZWNsYXNzaWZ5IG5vZGUgYXMgdHlwZScsdHlwZVxuXHRcdFx0dmFyIGNscyA9IElNLlR5cGVzW3R5cGVdIHx8IEltYmEuVEFHU1soXCJpbVwiICsgdHlwZSldO1xuXHRcdFx0XG5cdFx0XHRpZiAoY2xzKSB7XG5cdFx0XHRcdC8vIGxvZyAnZm91bmQgY2xhc3MgdG8gcmVjbGFzc2lmeSBhcycsY2xzLHNlbGY6Y29uc3RydWN0b3Jcblx0XHRcdFx0aWYgKGNscyA9PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBsb2cgJ2ZvdW5kIGNsYXNzIHRvIHJlY2xhc3NpZnkgYXMnLGNsc1xuXHRcdFx0XHR2YXIgbm9kZSA9IG5ldyBjbHModGhpcy5kb20oKSkuc2V0dXAoKTtcblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFyc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYmFzZUNsYXNzZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBjbHMgPSB0aGlzLmNvbnN0cnVjdG9yLmRvbSgpLmNsYXNzTmFtZTtcblx0XHRcdGlmICh0aGlzLl90eXBlKSB7IGNscyArPSAnICcgKyB0aGlzLl90eXBlIH07XG5cdFx0XHRyZXR1cm4gY2xzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzZXMoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXVzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0dXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0F0b21pYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZmluZCB0aGUgbm9kZXMgLyByZWdpb24gdGhhdCBzaG91bGQgYmUgcmVwYXJzZWQgaWYgdGhpcyBlbGVtZW50IGhhcyBjaGFuZ2VkXG5cdFx0Ly8gdGhpcyBpcyBjdXJyZW50bHkgcXVvdGUgXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kaXJ0eUV4dGVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gM2xvZyBcImdldCBkaXJ0eSBleHRlbnQgZm9yXCIsZG9tXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHNlbCwgc2VsMSwgc2VsMiwgJDE7XG5cdFx0XHRpZiAoc2VsID0gc2VsZi51cChxJCgnLnNlbGVjdG9yJyxzZWxmKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbC5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0fSBlbHNlIGlmIChzZWwxID0gc2VsZi51cChxJCgnLl9pbXRhZ25vZGUnLHNlbGYpKSkge1xuXHRcdFx0XHRyZXR1cm4gc2VsMS5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0fSBlbHNlIGlmIChzZWwyID0gc2VsZi51cChxJCgnLl9pbWlzdHJpbmcnLHNlbGYpKSkge1xuXHRcdFx0XHRyZXR1cm4gc2VsMi5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlbGYuaXNBdG9taWMoKSkgeyAvLyBobW1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRub2RlczogW3NlbGYuZG9tKCldLFxuXHRcdFx0XHRcdGNvZGU6IHNlbGYuY29kZSgpLFxuXHRcdFx0XHRcdGNvbnRhaW5zOiBmdW5jdGlvbihlbCkgeyByZXR1cm4gc2VsZi5kb20oKS5jb250YWlucyhlbC5fZG9tIHx8IGVsKTsgfVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHN0YXJ0ID0gc2VsZi5kb20oKTtcblx0XHRcdHZhciBlbmQgPSBzZWxmLmRvbSgpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHJldixuZXh0O1xuXHRcdFx0dmFyIG5vZGVzID0gW3NlbGYuZG9tKCldO1xuXHRcdFx0dmFyIG9wZW5lcixjbG9zZXI7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChwcmV2ID0gc3RhcnQucHJldmlvdXNTaWJsaW5nKXtcblx0XHRcdFx0aWYgKHByZXYgaW5zdGFuY2VvZiBUZXh0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJldi5tYXRjaGVzKCcuX2ltbmV3bGluZSwuX2ltdGFiJykpIHsgLy8gLC5faW1vcGVuLC5faW1jbG9zZVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHByZXYubWF0Y2hlcygnLl9pbW9wZW4nKSkge1xuXHRcdFx0XHRcdG9wZW5lciA9IHByZXY7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGFydCA9IHByZXY7XG5cdFx0XHRcdG5vZGVzLnVuc2hpZnQoc3RhcnQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKG5leHQgPSBlbmQubmV4dFNpYmxpbmcpe1xuXHRcdFx0XHRpZiAobmV4dCBpbnN0YW5jZW9mIFRleHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIGlmIChuZXh0Lm1hdGNoZXMoJy5faW1uZXdsaW5lJykpIHsgLy8gLl9pbW9wZW4sLl9pbWNsb3NlXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmV4dC5tYXRjaGVzKCcuX2ltY2xvc2UnKSkge1xuXHRcdFx0XHRcdGNsb3NlciA9IG5leHQ7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRlbmQgPSBuZXh0O1xuXHRcdFx0XHRub2Rlcy5wdXNoKGVuZCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBzZWUgaWYgd2UgaW5jbHVkZSBhbiBvcGVuIG9yIGNsb3NlLXRhZ1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVzdWx0ID0ge1xuXHRcdFx0XHRub2Rlczogbm9kZXMsXG5cdFx0XHRcdGNvZGU6IFwiXCIsXG5cdFx0XHRcdHRhcmdldDogc2VsZi5kb20oKSxcblx0XHRcdFx0bmVzdGVkOiBbXSxcblx0XHRcdFx0Y29udGFpbnM6IGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZihub2RlKSA+PSAwOyB9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAob3BlbmVyIHx8IGNsb3Nlcikge1xuXHRcdFx0XHQvLyBsb2cgXCJpbmNsdWRlcyBvcGVuZXIgYW5kIC8gb3IgY2xvc2VyXCIsb3BlbmVyLGNsb3NlclxuXHRcdFx0XHR2YXIgcGFyID0gdGFnJHdyYXAoKG9wZW5lciB8fCBjbG9zZXIpLnBhcmVudE5vZGUpO1xuXHRcdFx0XHRpZiAoKCQxID0gcGFyKSAmJiAkMS5pc0F0b21pYyAgJiYgICQxLmlzQXRvbWljKCkpIHtcblx0XHRcdFx0XHQvLyBsb2cgJ3JldHVybiB0aGUgcGFyZW50IGRpcnR5IGV4dGVudCcscGFyXG5cdFx0XHRcdFx0cmV0dXJuIHBhci5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKChvcGVuZXIgfHwgY2xvc2VyKS5wYXJlbnROb2RlLmNoaWxkcmVuKSwgbGVuXyA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdFx0cmVzLnB1c2goYXJ5W2ldKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0bm9kZXMgPSByZXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbG9jID0gMDtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIHVzZSB0aGUgdGFncyBkaXJlY3RseVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuXyA9IGFyeS5sZW5ndGgsIG5vZGU7IGkgPCBsZW5fOyBpKyspIHtcblx0XHRcdFx0bm9kZSA9IGFyeVtpXTtcblx0XHRcdFx0dmFyIHJpY2ggPSB0YWckd3JhcChub2RlKTtcblx0XHRcdFx0dmFyIHRleHQgPSBub2RlLnRleHRDb250ZW50O1xuXHRcdFx0XHR2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZmFsc2UgJiYgcmljaCAmJiAoKHJpY2ggaW5zdGFuY2VvZiBJTS5UeXBlcy5wYWlyKSB8fCByaWNoLmlzSW52YWxpZCgpKSkge1xuXHRcdFx0XHRcdHRleHQgPSBcIifCp8KnwqcnXCI7XG5cdFx0XHRcdFx0bGVuID0gNTtcblx0XHRcdFx0XHRzZWxmLmxvZyhcImFkZGVkIG5vZGUgYXMgbmVzdGVkIHJlZmVyZW5jZVwiLHJpY2guZG9tKCkpO1xuXHRcdFx0XHRcdC8vIHRoaXMgaXMgZnVja2VkIHVwXG5cdFx0XHRcdFx0Ly8gdGhpcyByZWFsbHkgZG9lcyBtZXNzIHVwIHRoZSByaWNoIG5vZGVzIGhlcmUoPyEpXG5cdFx0XHRcdFx0cmVzdWx0Lm5lc3RlZC5wdXNoKHJpY2gpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0cmVzdWx0LmNvZGUgKz0gdGV4dDtcblx0XHRcdFx0bG9jICs9IGxlbjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJlc3VsdC5ub2RlcyA9IG5vZGVzO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYXJzZUV4dGVudCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHJldHVybiBzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZGlydHkgPSBzZWxmLmRpcnR5RXh0ZW50KCk7XG5cdFx0XHRcdGlmIChlKSB7IGUuaGFuZGxlZCgpIH07XG5cdFx0XHRcdHJldHVybiBIaWdobGlnaHRlci5yZXBhcnNlKGRpcnR5KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdC8vIHBpZWNlIG9mIHVucGFyc2VkIGNvZGVcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcmF3JywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgncmF3Jyk7XG5cdFx0dGFnLmFsaWFzKCdAJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSYXcgPSBmdW5jdGlvbiAocmF3KXtcblx0XHRcdHRoaXMuX3JhdyA9IHJhdztcblx0XHRcdHRoaXMuX2RvbS50ZXh0Q29udGVudCA9IHJhdztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVkaXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLnNldENvZGUoZS5wYXRjaCh0aGlzKSk7XG5cdFx0XHRyZXR1cm4gZS5oYW5kbGVkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1mcmFnbWVudCcsICdpbXJhdycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2ZyYWdtZW50Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpe1xuXHRcdFx0aWYgKHR5cGVvZiBjb250ZW50ID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gY29udGVudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhZy5fX3N1cGVyX18uc2V0Q29udGVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy51bndyYXAoKTtcblx0XHRcdHRoaXMub3JwaGFuaXplKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdElNRnJhZ21lbnQgPSBJbWJhLlRBR1MuaW1mcmFnbWVudDtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbW9wZW4nLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdC8vIEBub2RlVHlwZSA9ICdzJ1xuXHRcdHRhZy50eXBlKCdvcGVuJyk7XG5cdFx0XG5cdFx0dGFnLmFsaWFzKCdbJyk7XG5cdFx0dGFnLmFsaWFzKCcoJyk7XG5cdFx0dGFnLmFsaWFzKCd7Jyk7XG5cdFx0dGFnLmFsaWFzKCd7eycpO1xuXHRcdHRhZy5hbGlhcygnaW5kZXhfc3RhcnQnKTtcblx0XHR0YWcuYWxpYXMoJ2Jsb2NrX3BhcmFtX3N0YXJ0Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltY2xvc2UnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCdjbG9zZScpO1xuXHRcdC8vIEBub2RlVHlwZSA9ICdzJ1xuXHRcdFxuXHRcdHRhZy5hbGlhcygnXScpO1xuXHRcdHRhZy5hbGlhcygnKScpO1xuXHRcdHRhZy5hbGlhcygnfScpO1xuXHRcdHRhZy5hbGlhcygnfX0nKTtcblx0XHR0YWcuYWxpYXMoJ2luZGV4X2VuZCcpO1xuXHRcdHRhZy5hbGlhcygnYmxvY2tfcGFyYW1fZW5kJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcnBhcmVuJywgJ2ltY2xvc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdycGFyZW4nKTtcblx0XHR0YWcuYWxpYXMoJyknKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWdvcGVuJywgJ2ltb3BlbicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3RhZ19zdGFydCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXRhZ2Nsb3NlJywgJ2ltY2xvc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCd0YWdfZW5kJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc2Vsb3BlbicsICdpbW9wZW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzZWxlY3Rvcl9zdGFydCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGNsb3NlJywgJ2ltY2xvc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzZWxlY3Rvcl9lbmQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1xdW90ZScsICdpbScpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc2luZ2xlcXVvdGUnLCAnaW1xdW90ZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoXCInXCIpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWRvdWJsZXF1b3RlJywgJ2ltcXVvdGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdcIicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXN0cnN0YXJ0JywgJ2ltb3BlbicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N0cmluZ19zdGFydCcpO1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW1zdHJlbmQnLCAnaW1jbG9zZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N0cmluZ19lbmQnKTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9iYXNlLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHR2YXIgUmVnaW9uID0gcmVxdWlyZSgnLi4vcmVnaW9uJykuUmVnaW9uO1xuXHR2YXIgSGlnaGxpZ2h0ZXIgPSByZXF1aXJlKCcuLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdFxuXHRcblx0dmFyIGtleXdvcmRzID0gW1xuXHRcdCd0cnVlJywnZmFsc2UnLCdudWxsJywndGhpcycsXG5cdFx0J2RlbGV0ZScsJ3R5cGVvZicsJ2luJywnaW5zdGFuY2VvZicsXG5cdFx0J3Rocm93JywnYnJlYWsnLCdjb250aW51ZScsJ2RlYnVnZ2VyJyxcblx0XHQnaWYnLCdlbHNlJywnc3dpdGNoJywnZm9yJywnd2hpbGUnLCdkbycsJ3RyeScsJ2NhdGNoJywnZmluYWxseScsXG5cdFx0J2NsYXNzJywnZXh0ZW5kcycsJ3N1cGVyJywncmV0dXJuJyxcblx0XHQndW5kZWZpbmVkJywndGhlbicsJ3VubGVzcycsJ3VudGlsJywnbG9vcCcsJ29mJywnYnknLFxuXHRcdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHRcdCdhbmQnLCdvcicsJ2lzJywnaXNudCcsJ25vdCcsJ3llcycsJ25vJywnaXNhJywnY2FzZScsJ25pbCcsJ2V4dGVuZCcsJ2V4cG9ydCcsJ293bidcblx0XTtcblx0XG5cdC8vIHRoaXMgaXMgcmVhbGx5IHRoZSBnZW5lcmFsIHRva2VuXG5cdHRhZyQuZGVmaW5lVGFnKCdpbXRvaycsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLmFsaWFzKCd0b2tlbicpO1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19lcmVmID0ge3dhdGNoOiAnZXJlZkRpZFNldCcsbmFtZTogJ2VyZWYnfTtcblx0XHR0YWcucHJvdG90eXBlLmVyZWYgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdlcmVmJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEVyZWYgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5lcmVmKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2VyZWYnLHYpOyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5lcmVmRGlkU2V0ICYmIHRoaXMuZXJlZkRpZFNldCh2LGEsdGhpcy5fX2VyZWYpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lcmVmRGlkU2V0ID0gZnVuY3Rpb24gKG5ldyQsb2xkKXtcblx0XHRcdC8vIGV4cGVyaW1lbnRhbFxuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2VyZWZEaWRTZXQnLG5ldyxvbGRcblx0XHRcdGlmICghKG5ldyQgJiYgb2xkKSkgeyB0aGlzLmZsYWcoJ2x2YXInLCEoIShuZXckKSkpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNWYXJSZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmhhc0ZsYWcoJ2x2YXInKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xlYXJWYXJSZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuc2V0RXJlZihudWxsKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0cmV0dXJuIElNLnRvayh2YWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0dGFnLl9fc3VwZXJfXy5zZXRUZXh0LmNhbGwodGhpcyx0ZXh0KTtcblx0XHRcdHRoaXMuY2xhc3NpZnkoKTtcblx0XHRcdFxuXHRcdFx0dmFyIHR5cCA9IElNLmlkZW50aWZ5KHRleHQpO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdyZWNsYXNzaWZ5aW5nIGltdG9rIGltbWVkaWF0ZWx5Jyk7XG5cdFx0XHRcdHRoaXMuc2V0Q29kZSh0ZXh0KTtcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVjbGFzc2lmeSh0eXApO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gcmV0dXJuIHJhdyB0b2tlbiBpZiBub3QgY2xhc3NpZmllZD9cblx0XHRcdHJldHVybiB0aGlzLl90eXAgPyAodGhpcykgOiAodGFnJC4kaW1yYXcoKS5zZXRSYXcodGV4dCkuZW5kKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhbkFwcGVuZCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbGFzc2lmeSA9IGZ1bmN0aW9uIChtYXApe1xuXHRcdFx0bWFwIHx8IChtYXAgPSBJTS5pZGVudGlmeSh0aGlzLmNvZGUoKSkpO1xuXHRcdFx0aWYgKG1hcCkge1xuXHRcdFx0XHRpZiAoIW1hcC5tYXRjaCgvXFxiX1tcXHddLykpIHsgbWFwID0gJ19pbXRvayAnICsgbWFwIH07XG5cdFx0XHRcdHRoaXMuZG9tKCkuY2xhc3NOYW1lID0gbWFwO1xuXHRcdFx0XHR0aGlzLl90eXAgPSBtYXA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90eXAgPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYWlyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygncmVwYWlyJyk7XG5cdFx0XHR0aGlzLmNsYXNzaWZ5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAocmVnaW9uKXtcblx0XHRcdHJlZ2lvbiA9IFJlZ2lvbi5ub3JtYWxpemUocmVnaW9uKTtcblx0XHRcdHZhciBsZnQgPSB0aGlzLmNvZGUoKS5zdWJzdHJpbmcoMCxyZWdpb24uc3RhcnQoKSk7XG5cdFx0XHR2YXIgcmd0ID0gdGhpcy5jb2RlKCkuc2xpY2UocmVnaW9uLmVuZCgpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zZXRDb2RlKGxmdCk7XG5cdFx0XHR0aGlzLnNldE5leHQoSU0udG9rKHJndCkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdHZhciBkaXJ0eSA9IHRoaXMuZGlydHlFeHRlbnQoKTtcblx0XHRcdHRoaXMudmlldygpLm9ic2VydmVyKCkucGF1c2UoZnVuY3Rpb24oKSB7IHJldHVybiBIaWdobGlnaHRlci5yZXBhcnNlKGRpcnR5KTsgfSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmV1c2UgPSBmdW5jdGlvbiAodG9rLG5ldyQsb2xkKXtcblx0XHRcdGlmIChuZXckID09IG9sZCkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ucmV1c2UuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoIW8uZGVlcCAmJiB0aGlzLnZhbGlkYXRlKHRoaXMuY29kZSgpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ubXV0YXRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZGJsY2xpY2sgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdHJldHVybiB0aGlzLnNlbGVjdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5lcmVmKCkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmlldygpLm5vZGVzRm9yRW50aXR5KHRoaXMuZXJlZigpKS5tYXAoZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsLmZsYWcoJ2hsJyk7IH0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25tb3VzZW91dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0aWYgKHRoaXMuZXJlZigpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5ub2Rlc0ZvckVudGl0eSh0aGlzLmVyZWYoKSkubWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC51bmZsYWcoJ2hsJyk7IH0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pZGVudGlmaWVyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnaWRlbnRpZmllcicpO1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHQvLyByZWdleCBmb3IgaWRlbnRpZmllclxuXHRcdFx0cmV0dXJuICgvXlthLXpdKC0/W1xcd0EtWmEtel9cXC1cXHg3Zi1cXHVmZmZmXFwkXSspKiQvKS50ZXN0KGNvZGUpICYmIGtleXdvcmRzLmluZGV4T2YoY29kZSkgPT0gLTE7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKHRvayxuZXckLG9sZCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaWRlbnRpZmllciBzZXR1cCcsYmFzZUNsYXNzZXNcblx0XHRcdHZhciB2Xztcblx0XHRcdGlmICh0b2sgJiYgdG9rLl92YWx1ZSkgeyAodGhpcy5zZXROYW1lKHZfID0gdG9rLl92YWx1ZSksdl8pIH07XG5cdFx0XHR0aGlzLl9kb20uY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NlcygpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdpbWlkZW50aWZpZXIgbXV0YXRlZCdcblx0XHRcdHRoaXMuc2V0TmFtZSh0aGlzLmNvZGUoKSk7XG5cdFx0XHRpZiAodGhpcy5pc1ZhclJlZigpKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJWYXJSZWYoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5tdXRhdGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXRhZ3R5cGUnLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCd0YWdfdHlwZScpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXRhZ2lkJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX2lkJyk7XG5cdFx0dGFnLmFsaWFzKCdpZHJlZicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWNvbnN0JywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnY29uc3QnKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuICgvXltBLVpdKC0/W1xcd0EtWmEtel9cXC1cXHg3Zi1cXHVmZmZmXFwkXSspKiQvKS50ZXN0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZGVmIG9uY2hhbmdlZCBjb2RlLCBwcmV2XG5cdFx0Ly8gXHQjIGNvbnNvbGUubG9nICdpbWNvbnN0IG9uY2hhbmdlZCcsY29kZSxwcmV2XG5cdFx0Ly8gXHRmbGFnKCdkaXJ0eScpIHVubGVzcyB2YWxpZGF0ZShjb2RlKVxuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pdmFyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnaXZhcicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWN2YXInLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdjdmFyJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2lta2V5d29yZCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2tleXdvcmQnKTtcblx0XHR0YWcuYWxpYXMoJ25ldycpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAodG9rLG5ldyQsb2xkKXtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdzZXR1cCBpbWtleXdvcmQnLHRvaywgbmV3LCBvbGRcblx0XHRcdHZhciBjbHMgPSB0aGlzLmJhc2VDbGFzc2VzKCk7XG5cdFx0XHRpZiAodG9rICYmIHRvay5fdmFsdWUpIHsgY2xzICs9ICcgJyArIHRvay5fdmFsdWUgfTtcblx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgPSBjbHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdGtleXdvcmRzLm1hcChmdW5jdGlvbihrZXl3b3JkKSB7IHJldHVybiBJTS5UeXBlc1trZXl3b3JkXSA9IElNLlR5cGVzLmtleXdvcmQ7IH0pO1xuXHRcblx0SU0uVHlwZXMuZm9yaW4gPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRJTS5UeXBlcy5mb3JvZiA9IElNLlR5cGVzLmtleXdvcmQ7XG5cdElNLlR5cGVzLnBvc3RfaWYgPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRJTS5UeXBlcy5wb3N0X3VubGVzcyA9IElNLlR5cGVzLmtleXdvcmQ7XG5cdElNLlR5cGVzLnBvc3RfZm9yID0gSU0uVHlwZXMua2V5d29yZDtcblx0SU0uVHlwZXMucG9zdF93aGlsZSA9IElNLlR5cGVzLmtleXdvcmQ7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1udW0nLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdudW1iZXInKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuICgvXlxcZCsoXFwuXFxkKyk/JC8pLnRlc3QoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJldXNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWludCcsICdpbW51bScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2ludCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWZsb2F0JywgJ2ltbnVtJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnZmxvYXQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1ib29sJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnYm9vbCcpO1xuXHRcdHRhZy5hbGlhcygndHJ1ZScpO1xuXHRcdHRhZy5hbGlhcygnZmFsc2UnKTtcblx0fSk7XG5cdFxuXHQvLyB0aGlzIHNob3VsZCBiZSBtb3JlIGFkdmFuY2VkIC0gbm9cblx0dGFnJC5kZWZpbmVUYWcoJ2ltc3RyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc3RyaW5nJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5xdW90ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpWzBdO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRRdW90ZSA9IGZ1bmN0aW9uIChxdW90ZSl7XG5cdFx0XHR0aGlzLnNldENvZGUocXVvdGUgKyB0aGlzLmNvZGUoKS5zbGljZSgxLC0xKSArIHF1b3RlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICh0b2ssbmV3JCxvbGQpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3NldHVwIHN0cmluZycsdG9rLCBuZXcsIG9sZFxuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzZXMoKTtcblx0XHRcdHRoaXMuc2V0Q29kZShuZXckKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnVud3JhcCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciB2Xztcblx0XHRcdHRoaXMubG9nKCdpbXN0cmluZyBvbnVud3JhcCEhIScsZSk7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdC8vIGxvb2sgYXQgcHJldiBhbmQgbmV4dCBhcyB3ZWxsP1xuXHRcdFx0Ly8gc2hvdWxkIGRvIHRoaXMgdGhyb3VnaCB0aGUgdmlld1xuXHRcdFx0cmV0dXJuICh0aGlzLnNldENvZGUodl8gPSB0aGlzLmNvZGUoKS5zbGljZSgxLC0xKSksdl8pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmRibGNsaWNrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWxlY3QoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRpZiAoY29kZVswXSA9PSAnXCInKSB7XG5cdFx0XHRcdHJldHVybiAoL15cXFwiKFteXCJcXHtdKilcXFwiJC8pLnRlc3QoY29kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvZGVbMF0gPT0gXCInXCIpIHtcblx0XHRcdFx0cmV0dXJuICgvXlxcJyhbXidcXHtdKilcXCckLykudGVzdChjb2RlKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcudHJpZ2dlcignXCInLGZ1bmN0aW9uKHRva2VuLG8pIHtcblx0XHRcdGlmIChvLm1vZGUgPT0gJ2FsbCcpIHtcblx0XHRcdFx0dG9rZW4uc2V0UXVvdGUoJ1wiJyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi5xdW90ZSgpID09ICdcIicpIHtcblx0XHRcdFx0dGhpcy5pbnNlcnQoJ1xcXFxcIicpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmluc2VydCgnXCInKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnRyaWdnZXIoXCInXCIsZnVuY3Rpb24odG9rZW4sbykge1xuXHRcdFx0dmFyIHZfO1xuXHRcdFx0aWYgKG8ubW9kZSA9PSAnYWxsJykge1xuXHRcdFx0XHRyZXR1cm4gKHRva2VuLnNldFF1b3RlKHZfID0gXCInXCIpLHZfKTtcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4ucXVvdGUoKSA9PSBcIidcIikge1xuXHRcdFx0XHR0aGlzLmluc2VydChcIlxcXFwnXCIpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmluc2VydChcIidcIik7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9KTtcblx0XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltbmVvc3RyaW5nJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnbmVvc3RyaW5nJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoIW8uZGVlcCAmJiAhdGhpcy5jb2RlKCkubWF0Y2goL1tcXHtcXFwiXFwnXS8pKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5tdXRhdGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXN5bScsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N5bWJvbCcpO1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW10YWdhdHRyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX2F0dHInKTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy90b2tlbi5pbWJhXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHR2YXIgSGlnaGxpZ2h0ZXIgPSByZXF1aXJlKCcuLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1ibG9jaycsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWxldGVMZWZ0UmlnaHQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1ibG9jayBkZWxldGVMZWZ0UmlnaHQnLGUucmVnaW9uKCkucGVlaygtMSwxKSk7XG5cdFx0XHRcblx0XHRcdGlmIChlLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gdGhpcy5jb2RlKCkpIHtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluZGVudEJsb2NrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0ZS5oYW5kbGVkKCk7XG5cdFx0XHRcblx0XHRcdHNlbGYudmlldygpLmNhcmV0KCkuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0dmFyIHJlZ2lvbiA9IHNlbGYudmlldygpLmNhcmV0KCkucmVnaW9uKCk7XG5cdFx0XHR2YXIgbm9kZXMgPSBzZWxmLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHJlZ2lvbik7XG5cdFx0XHRcblx0XHRcdG5vZGVzLm1hcChmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRpZiAobWF0Y2gubm9kZS5tYXRjaGVzKCcuX2ltbmV3bGluZScpKSB7XG5cdFx0XHRcdFx0c2VsZi5sb2coJ2ZvdW5kIHRhYiBpbiBzZWxlY3Rpb24nLG1hdGNoKTtcblx0XHRcdFx0XHRpZiAobWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gubm9kZS5pbmRlbnQoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHNlbGYudmlldygpLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51bmRlbnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1ibG9jay51bmRlbnQnLGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgbm9kZXMgPSBlLnZpZXcoKS5ub2Rlc0luUmVnaW9uKGUucmVnaW9uKCkuY2xvbmUoKS5zdGFydEF0TGluZSgpKTtcblx0XHRcdG5vZGVzLm1hcChmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRpZiAobWF0Y2gubm9kZS5tYXRjaGVzKCcuX2ltbmV3bGluZScpICYmIG1hdGNoLm1vZGUgIT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaC5ub2RlLnVuZGVudCgpO1xuXHRcdFx0XHRcdC8vIGUuY2FyZXQuZXhwYW5kKDAsLTEpXG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMudmlldygpLmNhcmV0KCkuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYWlyYWJsZSA9IGZ1bmN0aW9uIChzdHIsZSl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRcdHRoaXMuc2V0Q2hpbGRyZW4oW25vZGVdKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGxvZyBcInJlcGFpciBibG9ja1wiXG5cdFx0XHRxJCgnLl9pbXJhdycsdGhpcykubWFwKGZ1bmN0aW9uKHJhdykgeyByZXR1cm4gcmF3LnJlcGFpcigpOyB9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gdmFyIHJlZyA9IHZpZXcuc2VsLnJlZ2lvblxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5jb2RlU3RhdGUoKTtcblx0XHRcdHZhciBobCA9IElNLnBhcnNlKHN0YXRlLmNvZGUpO1xuXHRcdFx0Ly8gY291bGQgc2VuZCB0aGlzIHRocm91Z2ggbG9hZCBpbnN0ZWFkXG5cdFx0XHQvLyB3aGF0IGFib3V0IGFubm90YXRpb25zIGhlcmU/XG5cdFx0XHR0aHJvdyAnZG9udCByZWhpZ2hsaWdodCc7XG5cdFx0XHRcblx0XHRcdGlmIChobCkge1xuXHRcdFx0XHRzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYuZG9tKCkuaW5uZXJIVE1MID0gaGwgKyAnXFxuJztcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUuaW52YWxpZHMubWFwKGZ1bmN0aW9uKGludikge1xuXHRcdFx0XHRcdFx0Ly8gd2UgY291bGQgZ28gbG9jYWwgaW5zdGVhZFxuXHRcdFx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdFx0XHRpZiAobm9kZSA9IHNlbGYudmlldygpLm5vZGVBdFJlZ2lvbihpbnYucmVnaW9uLHRydWUpKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYubG9nKCdmb3VuZCBub2RlIGF0IGludmFsaWQgcG9zaXRpb24nLG5vZGUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZS5yZXBsYWNlV2l0aChpbnYubm9kZSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGJhZCBuYW1pbmdcblx0XHR0YWcucHJvdG90eXBlLmNvZGVTdGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHJlYWwgPSBzZWxmLmNvZGUoKTtcblx0XHRcdHZhciB2YWxpZCA9IHJlYWw7XG5cdFx0XHR2YXIgaW52YWxpZHMgPSBxJCgnLmludmFsaWQnLHNlbGYpO1xuXHRcdFx0dmFyIG93bnJlZyA9IHNlbGYucmVnaW9uKCk7XG5cdFx0XHR2YXIgc2VscmVnID0gc2VsZi52aWV3KCkuc2VsKCkucmVnaW9uKCk7XG5cdFx0XHRcblx0XHRcdHZhciByZW1lbWJlciA9IGludmFsaWRzLm1hcChmdW5jdGlvbihpbnYpIHtcblx0XHRcdFx0Ly8gbXVsdGlsZXZlbCBuZXN0aW5nP1xuXHRcdFx0XHR2YXIgcmVnaW9uID0gaW52LnJlZ2lvbigpO1xuXHRcdFx0XHR2YXIgcmVscmVnID0gcmVnaW9uLnJlbGF0aXZlVG8ob3ducmVnKTtcblx0XHRcdFx0c2VsZi5sb2coJ2ludmFsaWQgcmVnaW9uJyxvd25yZWcsJ3NlbGYnLHJlZ2lvbixyZWxyZWcpO1xuXHRcdFx0XHR2YWxpZCA9IHZhbGlkLmlucyhpbnYucGxhY2Vob2xkZXIoKSxyZWxyZWcpO1xuXHRcdFx0XHRyZXR1cm4ge3JlZ2lvbjogcmVnaW9uLHBsYWNlaG9sZGVyOiBpbnYucGxhY2Vob2xkZXIoKSxyYXc6IGludi5jb2RlKCksbm9kZTogaW52LHJvb3Q6IHNlbGYscmVsUmVnaW9uOiByZWxyZWd9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlZ2lvbjogb3ducmVnLFxuXHRcdFx0XHRtYXJrZXI6IChzZWxyZWcuaW50ZXJzZWN0cyhvd25yZWcpID8gKHNlbHJlZykgOiAobnVsbCkpLFxuXHRcdFx0XHRyYXc6IHJlYWwsXG5cdFx0XHRcdGNvZGU6IHZhbGlkLFxuXHRcdFx0XHRpbnZhbGlkczogcmVtZW1iZXJcblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaW50ZXJwb2xhdGVkJywgJ2ltYmxvY2snKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbmRlbnQnLCAnaW1ibG9jaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBtYXAgPSB7fTtcblx0XHRcdHZhciB2YXJzID0gW107XG5cdFx0XHRxJCgnLl9sdmFyJyx0aGlzKS5tYXAoZnVuY3Rpb24obHZhcikge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGx2YXIudGV4dCgpO1xuXHRcdFx0XHRpZiAoIW1hcFtuYW1lXSkge1xuXHRcdFx0XHRcdG1hcFtuYW1lXSA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIHZhcnMucHVzaChuYW1lKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHZhcnM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1wYWlyJywgJ2ltYmxvY2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdwYWlyJyk7XG5cdFx0XG5cdFx0dGFnLnBhaXIgPSBmdW5jdGlvbiAob3BlbixjbG9zZSl7XG5cdFx0XHR0aGlzLnByb3RvdHlwZS5fb3BlbiA9IG9wZW47XG5cdFx0XHR0aGlzLnByb3RvdHlwZS5fY2xvc2UgPSBjbG9zZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb3BlbiB8fCAnJztcblx0XHR9O1xuXHRcdHRhZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9jbG9zZSB8fCAnJztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZ2VuKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KXtcblx0XHRcdHRocm93ICdzaG91bGQgbm90IGdldCBoZXJlJztcblx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gdGhpcy5vcGVuKCkgKyBJTS5wYXJzZShjb250ZW50KSArIHRoaXMuY2xvc2UoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKCkucmVwbGFjZSgvW1xcc1xcdCBcXG5dLywnJykgPT0gKHRoaXMub3BlbigpICsgdGhpcy5jbG9zZSgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNQYWlyZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBjb2RlID0gdGhpcy5jb2RlKCk7XG5cdFx0XHRyZXR1cm4gY29kZVswXSA9PSB0aGlzLm9wZW4oKSAmJiBjb2RlW2NvZGUubGVuZ3RoIC0gMV0gPT0gdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc09wZW5lZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpWzBdID09IHRoaXMub3BlbigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpW3RoaXMuY29kZSgpLmxlbmd0aCAtIDFdID09IHRoaXMuY2xvc2UoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlbW92ZSB0aGUgd2hvbGUgdGhpbmcnKTtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlbDtcblx0XHRcdFx0dmFyIHBhciA9IHRoaXMucGFyZW50KCk7XG5cdFx0XHRcdHdoaWxlIChlbCA9IHRoaXMuX2RvbS5maXJzdENoaWxkKXtcblx0XHRcdFx0XHRwYXIuZG9tKCkuaW5zZXJ0QmVmb3JlKGVsLHRoaXMuX2RvbSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHJlbW92ZSBzZWxmIGFzIHdlbGxcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub251bndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1wYWlyIG9udW53cmFwISEhJyxlKTtcblx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGFnJC4kaW1vcGVuKCkuc2V0Q29udGVudCh0aGlzLm9wZW4oKSwwKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kaW1jbG9zZSgpLnNldENvbnRlbnQodGhpcy5jbG9zZSgpLDApLmVuZCgpXG5cdFx0XHRdKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmluc2VydGVkID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5zZXRDYXJldCh0aGlzLnJlZ2lvbigpLmNvbGxhcHNlKGZhbHNlKS5tb3ZlKDEpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmxpbmVicmVhayA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBwcmUgPSBlLmxpbmVzdHIoJ3ByZScpO1xuXHRcdFx0dmFyIGluZGVudCA9IGUuaW5kZW50KCk7XG5cdFx0XHR2YXIgbmV3JCA9IHRoaXMudGV4dCgpLmlucygnJyxlLnJlbFJlZ2lvbigpKTtcblx0XHRcdFxuXHRcdFx0Ly8gdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIG5vP1xuXHRcdFx0aWYgKG5ldyQgPT0gKHRoaXMub3BlbigpICsgdGhpcy5jbG9zZSgpKSkge1xuXHRcdFx0XHR2YXIgcHJlZml4ID0gJ1xcbicgKyBpbmRlbnQgKyAnXFx0Jztcblx0XHRcdFx0dmFyIHBvc3QgPSAnXFxuJyArIGluZGVudDtcblx0XHRcdFx0dGhpcy5vbndoaXRlc3BhY2UoZSxwcmVmaXggKyBwb3N0KTtcblx0XHRcdFx0ZS5jYXJldCgpLmNvbGxhcHNlKGZhbHNlKS5tb3ZlKC1wb3N0Lmxlbmd0aCk7XG5cdFx0XHRcdHJldHVybiBlLmhhbmRsZWQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG5lZWQgdG8gZmlyc3QgY29uc2lkZXIgdGhlIHNwbGl0dGluZywgbm8/XG5cdFx0XHRpZiAodGhpcy5pbmNyZWFzZUluZGVudChwcmUpKSB7IGluZGVudCArPSAnXFx0JyB9O1xuXHRcdFx0aWYgKHRoaXMuZGVjcmVhc2VJbmRlbnQocHJlKSkgeyBpbmRlbnQgPSBpbmRlbnQuc2xpY2UoMSkgfTtcblx0XHRcdHRoaXMub253aGl0ZXNwYWNlKGUsJ1xcbicgKyBpbmRlbnQpO1xuXHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdyZXBhaXIgaW10YWcnKTtcblx0XHRcdGlmICghKHRoaXMuaXNQYWlyZWQoKSkpIHsgdGhpcy5yZXZhbGlkYXRlKHRydWUpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ2ltcGFpciBtdXRhdGVkJyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZhbGlkYXRlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlZmF1bHRWYWxpZGF0aW9uTW9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICd0b2tlbml6ZSc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmV2YWxpZGF0ZSA9IGZ1bmN0aW9uIChtb2RlLHdyaXRlKXtcblx0XHRcdC8vIHRyaWNreSBtb3RoZXJmdWNrZXIgLS0gbW9zdGx5IHVzZWZ1bCBmb3IgdmFsaWRhdGlvbnNcblx0XHRcdC8vIEkgc3VwcG9zZSB3ZSBjYW4gZG8gdGhpcyBhIHNpbXBsZXIgd2F5IC0tIGJ5IHR1cm5pbmdcblx0XHRcdC8vIG9mZiBvYnNlcnZlcnMgLS0gdGVtcG9yYXJpbHkgcmVwbGFjaW5nIGlubmVyIGNvZGUgZXRjXG5cdFx0XHRcblx0XHRcdC8vIHdoZW4gYSBibG9jayBjaGVja3MgdmFsaWRpdHkgaXQgc2hvdWxkIHByb2JhYmx5XG5cdFx0XHQvLyBzdWJzdGl0dXRlIGlubmVyIGludmFsaWQgcGFydHMgLSBzbyB0aGF0IHRoZSBibG9ja1xuXHRcdFx0Ly8gdGhpbmcgaXMgc3RpbGwgdmFsaWRcblx0XHRcdHZhciBzZWxmID0gdGhpcywgaGw7XG5cdFx0XHRpZihtb2RlID09PSB1bmRlZmluZWQpIG1vZGUgPSBzZWxmLmRlZmF1bHRWYWxpZGF0aW9uTW9kZSgpO1xuXHRcdFx0aWYod3JpdGUgPT09IHVuZGVmaW5lZCkgd3JpdGUgPSBmYWxzZTtcblx0XHRcdHZhciB3YXNJbnZhbGlkID0gc2VsZi5oYXNGbGFnKCdpbnZhbGlkJyk7XG5cdFx0XHR2YXIgb2xkU3RhdGUgPSBzZWxmLmhhc0ZsYWcoJ2ludmFsaWQnKTtcblx0XHRcdHZhciBzdGF0ZSA9IHNlbGYuY29kZVN0YXRlKCk7XG5cdFx0XHR2YXIgY29kZSA9IHN0YXRlLmNvZGU7XG5cdFx0XHRcblx0XHRcdGlmICghKHNlbGYuaXNQYWlyZWQoKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYubWFya0ludmFsaWQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnNvbGUubG9nKCd3aWxsIHJldmFsaWRhdGUgd2l0aCBjb2RlJyxjb2RlKTtcblx0XHRcdGNvbnNvbGUudGltZSgncmV2YWxpZGF0ZScpO1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAobW9kZSA9PSAnY29tcGlsZScpIHtcblx0XHRcdFx0XHRzZWxmLl9vdXRwdXQgPSBJbWJhYy5jb21waWxlKGNvZGUse2JhcmU6IHRydWV9KTtcblx0XHRcdFx0XHRzZWxmLl90b2tlbnMgPSBzZWxmLl9vdXRwdXQub3B0aW9ucy5fdG9rZW5zO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuX3Rva2VucyA9IEltYmFjLnRva2VuaXplKGNvZGUse2JhcmU6IHRydWV9KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0c2VsZi5tYXJrVmFsaWQoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5fdG9rZW5zID0gbnVsbDtcblx0XHRcdFx0c2VsZi5tYXJrSW52YWxpZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS50aW1lRW5kKCdyZXZhbGlkYXRlJyk7XG5cdFx0XHRcblx0XHRcdGlmICh3YXNJbnZhbGlkICYmIHNlbGYuX3Rva2Vucykge1xuXHRcdFx0XHQvLyBuZWVkIHRvIGZpeCBpbm5lciBmb3Igcm9vdFxuXHRcdFx0XHRpZiAoaGwgPSBIaWdobGlnaHRlci5oaWdobGlnaHQoY29kZSx7dG9rZW5zOiBzZWxmLl90b2tlbnMsaW5uZXI6IHRydWV9KSkge1xuXHRcdFx0XHRcdC8vIHRoaXMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgb3V0IGludG8gYSBzZXBhcmF0ZSBtZXRob2Rcblx0XHRcdFx0XHQvLyBwb3NzaWJseSBkbyBsb2FkU3RhdGUgLyBkdW1wU3RhdGVcblx0XHRcdFx0XHRzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5kb20oKS5pbm5lckhUTUwgPSBobDtcblx0XHRcdFx0XHRcdHN0YXRlLmludmFsaWRzLm1hcChmdW5jdGlvbihpbnYpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdFx0XHRcdGlmIChub2RlID0gc2VsZi52aWV3KCkubm9kZUF0UmVnaW9uKGludi5yZWdpb24sdHJ1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZS5yZXBsYWNlV2l0aChpbnYubm9kZSk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGlmIChzdGF0ZS5tYXJrZXIpIHsgcmV0dXJuIHNlbGYudmlldygpLnNlbCgpLnNldChzdGF0ZS5tYXJrZXIpIH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9wZW4oKSArICgnICcpLnJlcGVhdCh0aGlzLnNpemUoKSAtIDIpICsgdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0F0b21pYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdtdWF0ZWQgaW1jdXJseScpO1xuXHRcdFx0dGhpcy52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKHRoaXMuZGlydHlFeHRlbnQoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWN1cmx5JywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2N1cmx5Jyk7XG5cdFx0dGFnLnBhaXIoJ3snLCd9Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc3F1YXJlJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NxdWFyZScpO1xuXHRcdHRhZy5wYWlyKCdbJywnXScpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJldHRpZnkgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmxvZygncHJldHRpZnkhJyk7XG5cdFx0XHRlLmhhbmRsZWQoKTtcblx0XHRcdHZhciBpbmQgPSBlLnJlZ2lvbigpLmluZGVudCgpO1xuXHRcdFx0c2VsZi5sb2coJ3dpdGggaW5kZW50YXRpb24nLGluZCxpbmQubGVuZ3RoKTtcblx0XHRcdFxuXHRcdFx0c2VsZi52aWV3KCkub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuY2hpbGRyZW4oKSksIGxlbiA9IGFyeS5sZW5ndGgsIGNoaWxkLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Y2hpbGQgPSBhcnlbaV07XG5cdFx0XHRcdFx0cmVzLnB1c2goY2hpbGQubWF0Y2hlcygnLmNvbW1hLC5faW1vcGVuJykgPyAoXG5cdFx0XHRcdFx0XHRjaGlsZC5zZXROZXh0KCdcXG4nICsgaW5kICsgJ1xcdCcpXG5cdFx0XHRcdFx0KSA6ICgoY2hpbGQubWF0Y2hlcygnLl9pbWNsb3NlJykpICYmIChcblx0XHRcdFx0XHRcdGNoaWxkLnNldFByZXYoJ1xcbicgKyBpbmQpXG5cdFx0XHRcdFx0KSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcGFyZW5zJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3BhcmVucycpO1xuXHRcdHRhZy5wYWlyKCcoJywnKScpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub251bndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1wYWlyIG9udW53cmFwISEhJyxlKTtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0Ly8gbG9vayBhdCBwcmV2IGFuZCBuZXh0IGFzIHdlbGw/XG5cdFx0XHQvLyBzaG91bGQgZG8gdGhpcyB0aHJvdWdoIHRoZSB2aWV3XG5cdFx0XHR0aGlzLnNldENvZGUoJyAnICsgdGhpcy5jb2RlKCkuc2xpY2UoMSwtMSkpO1xuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLnJlcGFpcigpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaXN0cmluZycsICdpbXBhaXInLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdpc3RyaW5nJyk7XG5cdFx0dGFnLnBhaXIoJ1wiJywnXCInKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pZXhwcicsICdpbXBhaXInLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdpZXhwcicpO1xuXHRcdHRhZy5wYWlyKCd7JywnfScpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWJsb2NrcGFyYW1zJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2Jsb2NrcGFyYW1zJyk7XG5cdFx0dGFnLnBhaXIoJ3wnLCd8Jyk7XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbXRhZ25vZGUnLCAnaW1wYWlyJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnbm9kZScpO1xuXHRcdHRhZy5wYWlyKCc8JywnPicpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFpcmFibGUgPSBmdW5jdGlvbiAoc3RyLGUpe1xuXHRcdFx0cmV0dXJuIGlkeCQoc3RyLFsneycsJ1snLCcoJywnXCInLFwiJ1wiXSkgPj0gMDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9wZW4oKSArICgneCcpLnJlcGVhdCh0aGlzLnNpemUoKSAtIDIpICsgdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWZhdWx0VmFsaWRhdGlvbk1vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAnY29tcGlsZSc7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9ibG9jay5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbXJvb3QnLCAnaW1ibG9jaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcuX25vZGVUeXBlID0gJ2NvZGUnO1xuXHRcdC8vIGRlZiBzZWxmLmRvbVxuXHRcdC8vXHRAZG9tIHx8PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJylcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRyeVVuZGVudCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYubG9nKCd0cnlVbmRlbnQnKTtcblx0XHRcdHZhciBub2RlcyA9IGUudmlldygpLm5vZGVzSW5SZWdpb24oZS5yZWdpb24oKS5jbG9uZSgpLnN0YXJ0QXRMaW5lKCkpO1xuXHRcdFx0bm9kZXMubWFwKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdGlmIChtYXRjaC5ub2RlLm1hdGNoZXMoJy5faW1uZXdsaW5lJykgJiYgbWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0bWF0Y2gubm9kZS51bmRlbnQoKTtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkuY2FyZXQoKS5tb3ZlKC0xKTtcblx0XHRcdFx0XHQvLyBlLmNhcmV0Lm1vdmUoLTEpXG5cdFx0XHRcdFx0Ly8gZS5jYXJldC5leHBhbmQoMCwtMSlcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBlLm1vdmVDYXJldCA9IDBcblx0XHRcdGUuaGFuZGxlZCgpO1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5kb20oKS5hZGRFdmVudExpc3RlbmVyKCcnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROZXh0ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0dGhpcy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQcmV2ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0dmFyIGZpcnN0ID0gdGhpcy5kb20oKS5maXJzdENoaWxkO1xuXHRcdFx0Zmlyc3QgPyAodGhpcy5pbnNlcnRCZWZvcmUobm9kZSxmaXJzdCkpIDogKHRoaXMuYXBwZW5kQ2hpbGQobm9kZSkpO1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubGluZWJyZWFrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIHByZSA9IGUubGluZXN0cigncHJlJyk7XG5cdFx0XHR2YXIgaW5kZW50ID0gZS5pbmRlbnQoKTtcblx0XHRcdHZhciBuZXckID0gdGhpcy50ZXh0KCkuaW5zKCcnLGUucmVsUmVnaW9uKCkpO1xuXHRcdFx0Ly8gbmVlZCB0byBmaXJzdCBjb25zaWRlciB0aGUgc3BsaXR0aW5nLCBubz9cblx0XHRcdGlmICh0aGlzLmluY3JlYXNlSW5kZW50KHByZSkpIHsgaW5kZW50ICs9ICdcXHQnIH07XG5cdFx0XHRpZiAodGhpcy5kZWNyZWFzZUluZGVudChwcmUpKSB7IGluZGVudCA9IGluZGVudC5zbGljZSgxKSB9O1xuXHRcdFx0dGhpcy5vbndoaXRlc3BhY2UoZSwnXFxuJyArIGluZGVudCk7XG5cdFx0XHRyZXR1cm4gZS5oYW5kbGVkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdpbXJvb3QgbXV0YXRlZCcpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpcnR5RXh0ZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmxvZygnaW1yb290IGRpcnR5RXh0ZW50Jyk7XG5cdFx0XHQvLyBzdXBlclxuXHRcdFx0dmFyIG5vZGVzID0gc2VsZi5jaGlsZHJlbigpLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBuLmRvbSgpOyB9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y29kZTogc2VsZi5jb2RlKCksXG5cdFx0XHRcdG5vZGVzOiBub2Rlcyxcblx0XHRcdFx0cGFyZW50OiBzZWxmLmRvbSgpLFxuXHRcdFx0XHRjb250YWluczogZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHNlbGYuZG9tKCkuY29udGFpbnMoZWwuX2RvbSB8fCBlbCk7IH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9yb290LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGV4dGVybnM7XG5cdFxuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXHRcblx0dmFyIFNJTkdMRV9TVFIgPSAvXidbXiddKickLztcblx0dmFyIERPVUJMRV9TVFIgPSAvXlwiW15cIlxce10qXCIkLztcblx0dmFyIENPTU1FTlQgPSAvXlxcI1sgXFx0XVteXFxuXSokLztcblx0XG5cdERPVUJMRV9TVFIgPSAvXlwiKFteXFxcXFwiXFx7XXxcXFxcXFxcXHxcXFxcXCIpKlwiJC87XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1saXQnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltcmVnZXgnLCAnaW1saXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCdyZWdleCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhaXJpbmcgPSBmdW5jdGlvbiAoY2hyKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXZhbGlkYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcmVnID0gdGhpcy5jb2RlKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgb2JqID0gZXZhbChyZWcpO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyB9O1xuXHRcdFx0dGhpcy5sb2coJ3JlZ2V4IGlzJyxyZWcsb2JqKTtcblx0XHRcdHRoaXMuZmxhZygnaW52YWxpZCcsIW9iaik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ3JlZ2V4IG11dGF0ZWQnKTtcblx0XHRcdHJldHVybiB0aGlzLnJldmFsaWRhdGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAnLycgKyAnUicucmVwZWF0KHRoaXMuc2l6ZSgpIC0gMikgKyAnLyc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzQXRvbWljID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9saXRlcmFscy5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0Ly8gc2hvdWxkIHJhdGhlciByZWNvbmNpbGUgaW50byB0b2tlbiAtIG9yIHNvbWV0aGluZyBsaWtlIGl0XG5cdHZhciBuYW1lcyA9IHtcblx0XHQnLic6ICdkb3QnLFxuXHRcdCc9JzogJ2VxJyxcblx0XHQnPyc6ICdxJyxcblx0XHQnISc6ICd1bmFyeScsXG5cdFx0JzonOiAnY29sb24nLFxuXHRcdCcsJzogJ2NvbW1hJyxcblx0XHQnIyc6ICdoYXNoJyxcblx0XHQnKic6ICdtdWx0Jyxcblx0XHQnPj4nOiAnYml0c2hpZnQnXG5cdH07XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1vcCcsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnR5cGUoJ29wJyk7XG5cdFx0dGFnLmFsaWFzKCdyZWxhdGlvbicpO1xuXHRcdHRhZy5hbGlhcygnY29tcGFyZScpO1xuXHRcdHRhZy5hbGlhcygnY29tcG91bmRfYXNzaWduJyk7XG5cdFx0dGFnLmFsaWFzKCdhc3NpZ24nKTtcblx0XHR0YWcuYWxpYXMoJ2Jsb2NrX2FyZycpO1xuXHRcdHRhZy5hbGlhcygnc3BsYXQnKTtcblx0XHR0YWcuYWxpYXMoJ2xvZ2ljJyk7XG5cdFx0dGFnLmFsaWFzKCdtYXRoJyk7XG5cdFx0dGFnLmFsaWFzKCdzaGlmdCcpO1xuXHRcdHRhZy5hbGlhcygndW5hcnknKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuIElNLmlzT3AoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJhc2VDbGFzc2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5iYXNlQ2xhc3Nlcy5hcHBseSh0aGlzLGFyZ3VtZW50cykgKyAnICcgKyAobmFtZXNbdGhpcy5jb2RlKCldIHx8ICcnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAodG9rZW4pe1xuXHRcdFx0dmFyIHZhbCA9IHRva2VuICYmIHRva2VuLl92YWx1ZSB8fCB0aGlzLmNvZGUoKTtcblx0XHRcdHRoaXMuZG9tKCkuY2xhc3NOYW1lID0gKFwiX2ltIF9pbW9wIG9wIFwiICsgKG5hbWVzW3ZhbF0gfHwgJycpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIG1lcmdlIHdpdGggYSBtb3JlIGdlbmVyaWMgdmVyc2lvbiBmb3IgdG9rZW4gaW4gZ2VuZXJhbFxuXHRcdC8vIHNhbWUgZ29lcyBmb3IgdGV4dCBldGNcblx0XHR0YWcucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGFnLl9fc3VwZXJfXy5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5jb2RlKCkgPT0gJy8vJykge1xuXHRcdFx0XHR0aGlzLmxvZygnaXMgYSByZWdleCEhJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlY2xhc3NpZnkoJ3JlZ2V4Jyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0Ly8gbGluayByZWd1bGFyIG9wcyB0byBvcC1ub2RlXG5cdHJldHVybiAnKyAtICogLyA9ICsrIC0tID09ID09PSAhPSAhPT0gPiA8ID49IDw9ICYgJiYgfCB8fCBvciAuIDogPyAmPSB8fD0gJiY9ID8uID86ICwgISAuLiAuLi4gLjogPj4gPDwgIycuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24ob3ApIHtcblx0XHRyZXR1cm4gSU0uVHlwZXNbb3BdID0gSU0uVHlwZXMub3A7XG5cdH0pO1xuXHRcblx0XG5cdC8vIElNLlR5cGVzOmxvZ2ljID0gSU0uVHlwZXM6b3Bcblx0Ly8gSU0uVHlwZXM6Y29tcGFyZSA9IElNLlR5cGVzOm9wXG5cdC8vIElNLlR5cGVzOm1hdGggPSBJTS5UeXBlczpvcFxuXHQvLyBJTS5UeXBlczpzaGlmdCA9IElNLlR5cGVzOm9wXG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvb3BlcmF0b3JzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHQvLyB0aGlzIHNob3VsZCBiZSBtb3JlIGFkdmFuY2VkIHRoYW4gdGhpcywgbm8/XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0F0b21pYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFyc2VkID0gZnVuY3Rpb24gKGNvZGUsb2xkKXtcblx0XHRcdHRoaXMubG9nKFwiaW1zZWwgcmVwYXJzZWRcIixjb2RlLG9sZCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbHRhZycsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yX3RhZycpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGNsYXNzJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfY2xhc3MnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zZWxjb21iJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfY29tYmluYXRvcicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGF0dHJvcCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yX2F0dHJfb3AnKTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltc2VsYXR0cm9wJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfYXR0cl9vcCcpO1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL3NlbGVjdG9yLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWluc2VydCcsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlZyxpbnMpe1xuXHRcdFx0Y29uc29sZS5sb2coJ2luc2VydCBjb2RlIGludG8gaW1pbnNlcnQhIScsaW5zLHJlZyk7XG5cdFx0XHRcblx0XHRcdGlmIChpbnMgaW5zdGFuY2VvZiBJTS5UeXBlcy5mcmFnbWVudCkge1xuXHRcdFx0XHRpbnMgPSBpbnMuY29kZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChpbnMgaW5zdGFuY2VvZiBJTS5UeXBlcy5yYXcpIHtcblx0XHRcdFx0aW5zID0gaW5zLl9yYXc7XG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgaW5zPT0nc3RyaW5nJ3x8aW5zIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0XHRpbnMgPSAodGhpcy5jb2RlKCkgfHwgXCJcIikuaW5zKGlucyxyZWcpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zZXRDb2RlKGlucyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKCkubWF0Y2goL15bXFxuXFx0XFwgXSskLyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdpbWluc2VydCBtdXRhdGVkJyk7XG5cdFx0XHRcblx0XHRcdHZhciBkaXJ0eSA9IHRoaXMuZGlydHlFeHRlbnQoKTtcblx0XHRcdHRoaXMudmlldygpLmhpZ2hsaWdodGVyKCkucmVwYXJzZShkaXJ0eSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXdoaXRlc3BhY2UnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2FuUHJlcGVuZCA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWRhdGUoc3RyICsgdGhpcy5jb2RlKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHRcdHJldHVybiB0aGlzLnZhbGlkYXRlKHRoaXMuY29kZSgpICsgc3RyKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbW5ld2xpbmUnLCAnaW13aGl0ZXNwYWNlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnbmV3bGluZScpO1xuXHRcdHRhZy5hbGlhcygnXFxuJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0XHRpZiAoc3RyLm1hdGNoKC9eW1xcblxcdFxcIF0rJC8pKSB7XG5cdFx0XHRcdC8vIHNob3VsZCBub3QgcmVhbGx5IGJlIGFibGUgdG8gcHJlcGVuZCBoZXJlXG5cdFx0XHRcdC8vIGl0IHNob2xkIHJhdGhlciBpbnNlcnQgYSBuZXcgbmV3bGluZSBpblxuXHRcdFx0XHQvLyBhbiBpbWluc2VydCwgYW5kIHRoYXQgc2hvdWxkIGJlIGFibGUgdG9cblx0XHRcdFx0Ly8gZGVjaWRlIHRoYXQgbm8gcmVwYXJzZSBpcyBuZWVkZWRcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYodmFsID09PSB1bmRlZmluZWQpIHZhbCA9IHRoaXMuY29kZSgpO1xuXHRcdFx0cmV0dXJuIHZhbCA9PSAnXFxuJztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5pbnNlcnQodGhpcy5yZWdpb24oKS5lbmQoKSwnXFx0Jyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygndW5kZW50IG5ld2xpbmUnKTtcblx0XHRcdHZhciByZWcgPSB0aGlzLnJlZ2lvbigpLmNsb25lKCkuY29sbGFwc2UodHJ1ZSkuY2xvbmUoMCwxKTtcblx0XHRcdGlmIChyZWcudGV4dCgpID09ICdcXHQnKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdjYW4gdW5kZW50ISEnKTtcblx0XHRcdFx0dGhpcy52aWV3KCkuZXJhc2UocmVnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHZpZXcub2JzZXJ2ZXIucGF1c2UgZG9cblx0XHRcdC8vXHRuZXh0Lm9ycGhhbml6ZSBpZiBuZXh0Py5tYXRjaGVzKCcuX2ltdGFiJylcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBsb2cgJ2ltbmV3bGluZSBtdXRhdGVkISEnXG5cdFx0XHQvLyByZW1vdmUgbm9kZSBpZiBpdCBpcyBvcnBoYW5pemVkXG5cdFx0XHRpZiAodGhpcy5jb2RlKCkgPT0gJycpIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlbW92ZSB3aG9sZSBub2RlJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlcGFyc2UgbmV3bGluZScpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKHtub2RlczogW3RoaXMuZG9tKCldLGNvZGU6IHRoaXMuY29kZSgpfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zcGFjZScsICdpbXdoaXRlc3BhY2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCd3aGl0ZXNwYWNlJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYodmFsID09PSB1bmRlZmluZWQpIHZhbCA9IHRoaXMuY29kZSgpO1xuXHRcdFx0cmV0dXJuICgvXlsgXSskLykudGVzdCh2YWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdGhpcyBzaG91bGQgYmUgdGhlIGRlZmF1bHQgZm9yIGFsbCBub2Rlcywgbm8/XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoIW8uZGVlcCAmJiB0aGlzLnZhbGlkYXRlKHRoaXMuY29kZSgpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ubXV0YXRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zZW1pY29sb24nLCAnaW13aGl0ZXNwYWNlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VtaWNvbG9uJyk7XG5cdFx0dGFnLmFsaWFzKCc7Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltdGFiJywgJ2ltd2hpdGVzcGFjZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnR5cGUoJ3RhYicpO1xuXHRcdHRhZy5hbGlhcygnXFx0Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVkaXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoZS5pc1N1cnJvdW5kZWQoKSkge1xuXHRcdFx0XHR0aGlzLmxvZygnZGVsZXRlIHRhYj8hPycpO1xuXHRcdFx0XHRpZiAoZS50ZXh0KCkpIHsgLy8gb3RoZXJ3aXNlIHdlIHJlYWxseSBhcmUgZG9uZVxuXHRcdFx0XHRcdGUucmVkaXJlY3QodGhpcy5wcmV2KCkgfHwgdGhpcy5uZXh0KCkgfHwgdGhpcy5wYXJlbnQoKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZS5oYW5kbGVkKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRlLnJlZ2lvbigpLmNvbGxhcHNlKGZhbHNlKTtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmKHZhbCA9PT0gdW5kZWZpbmVkKSB2YWwgPSB0aGlzLmNvZGUoKTtcblx0XHRcdHJldHVybiB2YWwgPT0gJ1xcdCc7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1jb21tZW50JywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnY29tbWVudCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gQ09NTUVOVC50ZXN0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygnaW1jb21tZW50IG11dGF0ZWQnKTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLm11dGF0ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXM7XG5cdFx0XHR0aGlzLmxvZygncmVwYWlyIGNvbW1lbnQnKTtcblx0XHRcdHZhciByZWdpb24gPSB0aGlzLnJlZ2lvbigpLmVuZEF0TGluZSgpO1xuXHRcdFx0dmFyIGZ1bGwgPSByZWdpb24udGV4dCgpOyAvLyBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxhc3QgbGluZT9cblx0XHRcdHZhciBub2RlcyA9IHJlZ2lvbi5ub2RlcyhmYWxzZSk7XG5cdFx0XHR0aGlzLmxvZygnd2hvbGUgcmVnaW9uIHNob3VsZCBiZScscmVnaW9uLGZ1bGwsbm9kZXMpO1xuXHRcdFx0dGhpcy5sb2coJ2FsbCBub2Rlcycsbm9kZXMpO1xuXHRcdFx0XG5cdFx0XHQvLyBWRVJZIHRlbXBvcmFyeVxuXHRcdFx0aWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dGhpcy5zZXRDb2RlKGZ1bGwpO1xuXHRcdFx0XHR3aGlsZSAobm9kZXMubGVuZ3RoID4gMSl7XG5cdFx0XHRcdFx0dmFyIGVsID0gbm9kZXMucG9wKCk7XG5cdFx0XHRcdFx0ZWwubm9kZS5vcnBoYW5pemUoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnNlcnRlZCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzLnJlcGFpcigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRpZiAoIXRleHQubWF0Y2goL1tcXG5dLykpIHsgcmV0dXJuIHRydWUgfTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHQvLyBhbGxvdyBpbnNlcnRpbmcgYWRkaXRpb25hbCB0YWJzIGRpcmVjdGx5IGhlcmU/XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2VvZicpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvd2hpdGVzcGFjZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXdhcm4nLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ21lc3NhZ2UnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbWVzc2FnZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdidWlsdCBlcnJvciB3aXRoIGVycm9yJyx0aGlzLm9iamVjdCgpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWVycicsICdpbXdhcm4nKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Fubm90YXRpb25zLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciBSb3V0ZXIgPSByZXF1aXJlKCcuL3JvdXRlcicpLlJvdXRlcjtcblx0XG5cdGZ1bmN0aW9uIEFwcCgpe1xuXHRcdHRoaXMuc2V0Q2FjaGUoe30pO1xuXHRcdHRoaXMuc2V0RGVwcyh7fSk7XG5cdFx0dGhpcy5yZXNldCgpO1xuXHRcdHRoaXMudGljaygpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkFwcCA9IEFwcDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdEFwcC5wcm90b3R5cGUucmVxID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZXE7IH1cblx0QXBwLnByb3RvdHlwZS5zZXRSZXEgPSBmdW5jdGlvbih2KXsgdGhpcy5fcmVxID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0QXBwLnByb3RvdHlwZS5yZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3JlczsgfVxuXHRBcHAucHJvdG90eXBlLnNldFJlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLmRlcHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RlcHM7IH1cblx0QXBwLnByb3RvdHlwZS5zZXREZXBzID0gZnVuY3Rpb24odil7IHRoaXMuX2RlcHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLnNpdGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3NpdGU7IH1cblx0QXBwLnByb3RvdHlwZS5zZXRTaXRlID0gZnVuY3Rpb24odil7IHRoaXMuX3NpdGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jYWNoZTsgfVxuXHRBcHAucHJvdG90eXBlLnNldENhY2hlID0gZnVuY3Rpb24odil7IHRoaXMuX2NhY2hlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0QXBwLnByb3RvdHlwZS5pc3N1ZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2lzc3VlczsgfVxuXHRBcHAucHJvdG90eXBlLnNldElzc3VlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pc3N1ZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEFwcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnNldENhY2hlKHt9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUucm91dGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3JvdXRlciB8fCAodGhpcy5fcm91dGVyID0gbmV3IFJvdXRlcih0aGlzKSk7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gSW1iYS5TRVJWRVIgPyAodGhpcy5yZXEoKS5wYXRoKSA6ICh0aGlzLl9wYXRoKTtcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAnJztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBJbWJhLlNFUlZFUiA/ICgnJykgOiAoZG9jdW1lbnQubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpO1xuXHR9O1xuXHRcblx0QXBwLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKCFJbWJhLlNFUlZFUikge1xuXHRcdFx0dGhpcy5fcGF0aCA9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCl7XG5cdFx0SW1iYS5zY2hlZHVsZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUudW5zY2hlZHVsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdEltYmEudW5zY2hlZHVsZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuZmV0Y2hEb2N1bWVudCA9IGZ1bmN0aW9uIChzcmMsY2Ipe1xuXHRcdFxuXHRcdHZhciBkZXBzXywgJDEsICQzLCAkMjtcblx0XHRpZiAoSW1iYS5TRVJWRVIpIHtcblx0XHRcdHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cdFx0XHR2YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblx0XHRcdFxuXHRcdFx0dmFyIGZpbGVwYXRoID0gKFwiXCIgKyBfX2Rpcm5hbWUgKyBcIi8uLi9kb2NzL1wiICsgc3JjKS5yZXBsYWNlKC9cXC9cXC8vZywnLycpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVzID0gdGhpcy5kZXBzKClbc3JjXTtcblx0XHRcdFxuXHRcdFx0aWYgKCFyZXMpIHtcblx0XHRcdFx0dmFyIGJvZHkgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgsJ3V0Zi04Jyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3JjLm1hdGNoKC9cXC5tZCQvKSkge1xuXHRcdFx0XHRcdHJlcyA9IHRoaXMuTWFya2Rvd24ucmVuZGVyKGJvZHkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNyYy5tYXRjaCgvXFwuanNvbiQvKSkge1xuXHRcdFx0XHRcdHJlcyA9IEpTT04ucGFyc2UoYm9keSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3JjLm1hdGNoKC9cXC5pbWJhJC8pKSB7XG5cdFx0XHRcdFx0dmFyIGh0bWwgPSB0aGlzLkhpZ2hsaWdodGVyLmhpZ2hsaWdodChib2R5LHttb2RlOiAnZnVsbCd9KTtcblx0XHRcdFx0XHRyZXMgPSB7Ym9keTogYm9keSxodG1sOiBodG1sfTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdChkZXBzXyA9IHRoaXMuZGVwcygpKVsoJDEgPSBzcmMpXSB8fCAoZGVwc19bJDFdID0gcmVzKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuc2l0ZSgpKSB7XG5cdFx0XHRcdCgkMyA9IHRoaXMuc2l0ZSgpLmRlcHMoKSlbKCQyID0gc3JjKV0gfHwgKCQzWyQyXSA9IHJlcyk7XG5cdFx0XHR9O1xuXHRcdFx0Y2IgJiYgY2IocmVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKERFUFNbc3JjXSkge1xuXHRcdFx0XHRjYiAmJiBjYihERVBTW3NyY10pO1xuXHRcdFx0XHRyZXR1cm4ge3RoZW46IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYocmVzKTsgfX07IC8vIGZha2UgcHJvbWlzZSBoYWNrXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHR4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdERFUFNbc3JjXSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdHJldHVybiBjYiAmJiBjYihERVBTW3NyY10pO1xuXHRcdFx0XHQvLyBYSFIgPSB4aHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3Jlc3BvbnNlIGhlcmUnLHhocjpyZXNwb25zZVRleHRcblx0XHRcdH0pO1xuXHRcdFx0eGhyLm9wZW4oXCJHRVRcIixzcmMpO1xuXHRcdFx0eGhyLnNlbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QXBwLnByb3RvdHlwZS5pc3N1ZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5faXNzdWVzIHx8ICh0aGlzLl9pc3N1ZXMgPSBEb2MuZ2V0KCcvaXNzdWVzL2FsbC5qc29uJykpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gRG9jKHBhdGgpe1xuXHRcdHRoaXMuX3BhdGggPSBwYXRoO1xuXHRcdHRoaXMuX3JlYWR5ID0gZmFsc2U7XG5cdFx0dGhpcy5mZXRjaCgpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkRvYyA9IERvYzsgLy8gZXhwb3J0IGNsYXNzIFxuXHR2YXIgY2FjaGUgPSB7fTtcblx0XG5cdERvYy5nZXQgPSBmdW5jdGlvbiAocGF0aCl7XG5cdFx0dmFyICQxO1xuXHRcdHZhciBjYWNoZSA9IEFQUC5jYWNoZSgpO1xuXHRcdHJldHVybiBjYWNoZVsoJDEgPSAnZG9jLScgKyBwYXRoKV0gfHwgKGNhY2hlWyQxXSA9IG5ldyB0aGlzKHBhdGgpKTtcblx0fTtcblx0XG5cdFxuXHRcblx0RG9jLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXRoOyB9XG5cdERvYy5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0RG9jLnByb3RvdHlwZS5vYmplY3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29iamVjdDsgfVxuXHREb2MucHJvdG90eXBlLnNldE9iamVjdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vYmplY3QgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdERvYy5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fcmVhZHk7XG5cdH07XG5cdFxuXHREb2MucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmIChJbWJhLlNFUlZFUikge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoIEd1aWRlIG9uIHNlcnZlcicscGF0aFxuXHRcdFx0cmV0dXJuIEFQUC5mZXRjaERvY3VtZW50KHNlbGYuX3BhdGgsZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmZXRjaCBHdWlkZSBvbiBzZXJ2ZXIgZG9uZScscGF0aFxuXHRcdFx0XHRyZXR1cm4gc2VsZi5sb2FkKHJlcyk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLl9wcm9taXNlIHx8IChzZWxmLl9wcm9taXNlID0gQVBQLmZldGNoRG9jdW1lbnQoc2VsZi5fcGF0aCxmdW5jdGlvbihyZXMpIHtcblx0XHRcdHJldHVybiBzZWxmLmxvYWQocmVzKTtcblx0XHR9KSk7XG5cdH07XG5cdFxuXHREb2MucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoZG9jKXtcblx0XHR0aGlzLl9vYmplY3QgPSBkb2M7XG5cdFx0dGhpcy5fbWV0YSA9IGRvYy5tZXRhIHx8IHt9O1xuXHRcdHRoaXMuX3JlYWR5ID0gdHJ1ZTtcblx0XHRJbWJhLmVtaXQodGhpcywncmVhZHknKTtcblx0XHRJbWJhLlNjaGVkdWxlci5tYXJrRGlydHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdERvYy5wcm90b3R5cGUudGl0bGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb2JqZWN0LnRpdGxlIHx8ICdwYXRoJztcblx0fTtcblx0XG5cdERvYy5wcm90b3R5cGUudG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX29iamVjdCAmJiB0aGlzLl9vYmplY3QudG9jWzBdO1xuXHR9O1xuXHRcblx0RG9jLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX29iamVjdCAmJiB0aGlzLl9vYmplY3QuYm9keTtcblx0fTtcblx0cmV0dXJuIERvYztcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXBwLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGV4dGVybnM7XG5cdFxuXHRmdW5jdGlvbiBSb3V0ZXIoYXBwKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fYXBwID0gYXBwO1xuXHRcdFxuXHRcdGlmIChJbWJhLmlzQ2xpZW50KCkpIHtcblx0XHRcdHdpbmRvdy5vbnBvcHN0YXRlID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRzZWxmLnJlZnJlc2goKTtcblx0XHRcdFx0cmV0dXJuIEltYmEuc2V0VGltZW91dCgwLGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0c2VsZjtcblx0fTtcblx0XG5cdGV4cG9ydHMuUm91dGVyID0gUm91dGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0Um91dGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXRoOyB9XG5cdFJvdXRlci5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRSb3V0ZXIuc2x1ZyA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCcnKS50b0xvd2VyQ2FzZSgpOyAvLyB0cmltXG5cdFx0Ly8gcmVtb3ZlIGFjY2VudHMsIHN3YXAgw7EgZm9yIG4sIGV0Y1xuXHRcdHZhciBmcm9tID0gXCLDoMOhw6TDosOlw6jDqcOrw6rDrMOtw6/DrsOyw7PDtsO0w7nDusO8w7vDscOnwrcvXyw6O1wiO1xuXHRcdHZhciB0byA9IFwiYWFhYWFlZWVlaWlpaW9vb291dXV1bmMtLS0tLS1cIjtcblx0XHRcblx0XHQvLyBmb3IgKHZhciBpPTAsIGw9ZnJvbS5sZW5ndGggOyBpPGwgOyBpKyspXG5cdFx0Ly8gXHRzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGZyb20uY2hhckF0KGkpLCAnZycpLCB0by5jaGFyQXQoaSkpXG5cdFx0XG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoL1teYS16MC05IC1dL2csJycpOyAvLyByZW1vdmUgaW52YWxpZCBjaGFyc1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9cXHMrL2csJy0nKTsgLy8gY29sbGFwc2Ugd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBieSAtXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoLy0rL2csJy0nKTsgLy8gY29sbGFwc2UgZGFzaGVzXG5cdFx0XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblx0XG5cdFJvdXRlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um91dGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcC5wYXRoKCk7XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYXBwLmhhc2goKTtcblx0fTtcblx0XG5cdFJvdXRlci5wcm90b3R5cGUuZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGgoKTtcblx0XHR2YXIgbSA9IHBhdGgubWF0Y2goL1xcLihbXlxcL10rKSQvKTtcblx0XHRyZXR1cm4gbSAmJiBtWzFdIHx8ICcnO1xuXHR9O1xuXHRcblx0Um91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChocmVmLHN0YXRlLHJlcGxhY2Upe1xuXHRcdGlmKHN0YXRlID09PSB1bmRlZmluZWQpIHN0YXRlID0ge307XG5cdFx0aWYocmVwbGFjZSA9PT0gdW5kZWZpbmVkKSByZXBsYWNlID0gZmFsc2U7XG5cdFx0aWYgKGhyZWYgPT0gJy9pbnN0YWxsJykge1xuXHRcdFx0Ly8gcmVkaXJlY3RzIGhlcmVcblx0XHRcdGhyZWYgPSAnL2d1aWRlcyN0b2MtZ2V0dGluZy1zdGFydGVkLWluc3RhbGxhdGlvbic7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAocmVwbGFjZSkge1xuXHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsbnVsbCxocmVmKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsbnVsbCxocmVmKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghaHJlZi5tYXRjaCgvXFwjLykpIHtcblx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLDApO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLnNjb3BlZCA9IGZ1bmN0aW9uIChyZWcscGFydCl7XG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGgoKSArICcjJyArIHRoaXMuaGFzaCgpO1xuXHRcdGlmICgodHlwZW9mIHJlZz09J3N0cmluZyd8fHJlZyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHZhciBueHQgPSBwYXRoW3JlZy5sZW5ndGhdO1xuXHRcdFx0cmV0dXJuIHBhdGguc3Vic3RyKDAscmVnLmxlbmd0aCkgPT0gcmVnICYmICghbnh0IHx8IG54dCA9PSAnLScgfHwgbnh0ID09ICcvJyB8fCBueHQgPT0gJyMnIHx8IG54dCA9PSAnPycgfHwgbnh0ID09ICdfJyk7XG5cdFx0fSBlbHNlIGlmIChyZWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdHZhciBtID0gcGF0aC5tYXRjaChyZWcpO1xuXHRcdFx0cmV0dXJuIHBhcnQgJiYgbSA/IChtW3BhcnRdKSA6IChtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHJlZyxwYXJ0KXtcblx0XHR2YXIgcGF0aCA9IHRoaXMucGF0aCgpICsgJyMnICsgdGhpcy5oYXNoKCk7XG5cdFx0XG5cdFx0aWYgKCh0eXBlb2YgcmVnPT0nc3RyaW5nJ3x8cmVnIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0cmV0dXJuIHBhdGggPT0gcmVnO1xuXHRcdH0gZWxzZSBpZiAocmVnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHR2YXIgbSA9IHBhdGgubWF0Y2gocmVnKTtcblx0XHRcdHJldHVybiBwYXJ0ICYmIG0gPyAobVtwYXJ0XSkgOiAobSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9O1xuXHRyZXR1cm4gUm91dGVyO1xuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcm91dGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRyZXF1aXJlKCcuL2Jhc2UnKTtcblx0cmVxdWlyZSgnLi9tYXJrZG93bicpO1xuXHRcblx0cmVxdWlyZSgnLi9zaXRlJyk7XG5cdHJlcXVpcmUoJy4vbmF2Jyk7XG5cdHJlcXVpcmUoJy4vcGFnZScpO1xuXHRyZXF1aXJlKCcuL2lzc3VlcycpO1xuXHRyZXF1aXJlKCcuL2hvbWUnKTtcblx0cmVxdWlyZSgnLi9ibG9nJyk7XG5cdHJlcXVpcmUoJy4vZ3VpZGVzJyk7XG5cdHJlcXVpcmUoJy4vZG9jcycpO1xuXHRyZXR1cm4gcmVxdWlyZSgnLi9zbmlwcGV0Jyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2luZGV4LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZXh0ZW5kVGFnKCdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm91dGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um91dGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvdXRlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0Ly8gZGVmIGh0bWw9IGh0bWxcblx0XHQvLyBcdEBkb206aW5uZXJIVE1MID0gaHRtbFxuXHRcdC8vIFx0c2VsZlxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHRtbCA9IGZ1bmN0aW9uIChodG1sKXtcblx0XHRcdGlmIChodG1sICE9IHRoaXMuX2h0bWwpIHtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB0aGlzLl9odG1sID0gaHRtbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAocm91dGUpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEFQUC5yb3V0ZXIoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVyb3V0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5mbGFnKCdzY29wZWQnLHRoaXMucm91dGVyKCkuc2NvcGVkKHRoaXMucm91dGUoKSx0aGlzKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdzZWxlY3RlZCcsdGhpcy5yb3V0ZXIoKS5tYXRjaCh0aGlzLnJvdXRlKCksdGhpcykpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0dGhpcy5jc3MoJ3RyYW5zZm9ybScsdmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY3NzKCd0cmFuc2Zvcm0nKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZXh0ZW5kVGFnKCdodG1sZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIdG1sID0gZnVuY3Rpb24gKGh0bWwpe1xuXHRcdFx0aWYgKGh0bWwgIT0gdGhpcy5faHRtbCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IHRoaXMuX2h0bWwgPSBodG1sO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5leHRlbmRUYWcoJ3NjcmlwdCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGlsZHJlbiA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IHZhbHVlO1xuXHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5leHRlbmRUYWcoJ2NhbnZhcycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kcHIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kcHIgfHwgKHRoaXMuX2RwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCl7XG5cdFx0XHRpZiAod2lkdGggIT0gdGhpcy5fd2lkdGgpIHtcblx0XHRcdFx0dGhpcy5kb20oKS53aWR0aCA9IHdpZHRoICogdGhpcy5kcHIoKTtcblx0XHRcdFx0dGhpcy5jc3Moe3dpZHRoOiB3aWR0aH0pO1xuXHRcdFx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KXtcblx0XHRcdGlmIChoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kcHIoKTtcblx0XHRcdFx0dGhpcy5jc3Moe2hlaWdodDogaGVpZ2h0fSk7XG5cdFx0XHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZXh0ZW5kVGFnKCdhJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcm91dGUgfHwgdGhpcy5ocmVmKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udGFwID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmhyZWYoKS5yZXBsYWNlKC9eaHR0cFxcOlxcL1xcL2ltYmFcXC5pby8sJycpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZS5ldmVudCgpLm1ldGFLZXkgfHwgZS5ldmVudCgpLmFsdEtleSkge1xuXHRcdFx0XHRlLl9yZXNwb25kZXIgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoaHJlZlswXSA9PSAnIycgfHwgaHJlZlswXSA9PSAnLycpIHtcblx0XHRcdFx0ZS5jYW5jZWwoKS5oYWx0KCk7XG5cdFx0XHRcdHRoaXMucm91dGVyKCkuZ28oaHJlZix7fSk7XG5cdFx0XHRcdEltYmEuRXZlbnRzLnRyaWdnZXIoJ3JvdXRlJyx0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGUuX3Jlc3BvbmRlciA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXJvdXRlKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3N0YXInLCAnYScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBvID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncmVwbycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZXBvID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyZXBvJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNldEhyZWYoKFwiaHR0cDovL2dpdGh1Yi5jb20vXCIgKyB0aGlzLnJlcG8oKSkpLnNldFRleHQoXCLimIUgU3RhclwiKS5zeW5jZWQoKTtcblx0XHRcdC8vIDxhIGhyZWY9XCJodHRwOi8vZ2l0aHViLmNvbS97cmVwb31cIj4gXCLimIUgU3RhclwiXG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2Jhc2UuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gZm9yIG1hcmtkb3duIHJlbmRlcmluZ1xuXHR0YWckLmRlZmluZVRhZygnbWQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19zcmMgPSB7d2F0Y2g6ICdyZWxvYWQnLG5hbWU6ICdzcmMnfTtcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5zcmMoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJyx2KTsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMucmVsb2FkICYmIHRoaXMucmVsb2FkKHYsYSx0aGlzLl9fc3JjKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19odG1sID0ge3dhdGNoOiAnaHRtbERpZFNldCcsbmFtZTogJ2h0bWwnfTtcblx0XHR0YWcucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2h0bWw7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEh0bWwgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5odG1sKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5faHRtbCA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmh0bWxEaWRTZXQgJiYgdGhpcy5odG1sRGlkU2V0KHYsYSx0aGlzLl9faHRtbCkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRvYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZG9jOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREb2MgPSBmdW5jdGlvbih2KXsgdGhpcy5fZG9jID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5naHNyYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIChcImh0dHBzOi8vZ2l0aHViLmNvbS9zb21lYmVlL2ltYmEuaW8vYmxvYi9tYXN0ZXIvZG9jc1wiICsgdGhpcy5zcmMoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmh0bWxEaWRTZXQgPSBmdW5jdGlvbiAoaHRtbCl7XG5cdFx0XHR0aGlzLmJvZHkoKS5kb20oKS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0dGhpcy5zZXR1cCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCkgKyAnLm1kJyxmdW5jdGlvbihkb2MpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5hc3NlbWJsZShkb2MpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsZi5fc25pcHBldHMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuX3NuaXBwZXRzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0YXJ5W2ldLmVuZCgpOyAvLyBzaW11bGF0ZSByZWFsIHJlbmRlcmluZyBoZXJlP1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gbm90IG9uIGZyb250cGFnZT8hXG5cdFx0dGFnLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uIChkb2Mpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnbWQnKS5zZXRIdG1sKGRvYy5ib2R5KS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRhZy5fX3N1cGVyX18uYnVpbGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0aWYgKEltYmEuaXNDbGllbnQoKSAmJiB0aGlzLnNyYygpKSB7IHJldHVybiB0aGlzLnJlbG9hZCgpIH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gbG9nIFwiYXdha2VuZWQgbWQgZnJvbSBjbGllbnQoISlcIlxuXHRcdFx0dGhpcy5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0Jyx0aGlzKS50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uIChodG1sKXtcblx0XHRcdHRoaXMuX2RvbS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0dGhpcy5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0Jyx0aGlzKS50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdyZWxvYWRpbmcgbWFya2Rvd24nXG5cdFx0XHRcdHNlbGYuX3NuaXBwZXRzID0gW107XG5cdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCkgKyAnLm1kJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncmV0dXJuZWQgZnJvbSBtYXJrZG93biBoZXJlPyEnLHJlc1xuXHRcdFx0XHRcdHNlbGYuYXNzZW1ibGUoKHNlbGYuc2V0RG9jKHJlcykscmVzKSk7XG5cdFx0XHRcdFx0c2VsZi5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0JyxzZWxmKS50b0FycmF5KCk7XG5cdFx0XHRcdFx0c2VsZi5wYXJlbnQoKS5kb20oKS5zY3JvbGxUb3AgPSAwO1xuXHRcdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblx0XG5cdC8vIGRlZmluZSByZW5kZXJlclxuXHR2YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG5cdHZhciBtZHIgPSBuZXcgKG1hcmtlZC5SZW5kZXJlcikoKTtcblx0XG5cdG1kci5oZWFkaW5nID0gZnVuY3Rpb24gKHRleHQsbHZsKXtcblx0XHRyZXR1cm4gKFwiPGhcIiArIGx2bCArIFwiPlwiICsgdGV4dCArIFwiPC9oXCIgKyBsdmwgKyBcIj5cIik7XG5cdH07XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ21hcmtlZCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXJlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDb250ZW50KHRleHQsMCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAodmFsLHR5cCl7XG5cdFx0XHRpZiAodmFsICE9IHRoaXMuX2NvbnRlbnQpIHtcblx0XHRcdFx0dGhpcy5fY29udGVudCA9IHZhbDtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSBtYXJrZWQodmFsLHtyZW5kZXJlcjogbWRyfSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL21hcmtkb3duLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTQsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWRcbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eXFxuKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rXFxuKikrLyxcbiAgZmVuY2VzOiBub29wLFxuICBocjogL14oICpbLSpfXSl7Myx9ICooPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICooW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS8sXG4gIG5wdGFibGU6IG5vb3AsXG4gIGxoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICooPzpcXG4rfCQpLyxcbiAgYmxvY2txdW90ZTogL14oICo+W15cXG5dKyhcXG4oPyFkZWYpW15cXG5dKykqXFxuKikrLyxcbiAgbGlzdDogL14oICopKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICBodG1sOiAvXiAqKD86Y29tbWVudCAqKD86XFxufFxccyokKXxjbG9zZWQgKig/OlxcbnsyLH18XFxzKiQpfGNsb3NpbmcgKig/OlxcbnsyLH18XFxzKiQpKS8sXG4gIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICtbXCIoXShbXlxcbl0rKVtcIildKT8gKig/Olxcbit8JCkvLFxuICB0YWJsZTogbm9vcCxcbiAgcGFyYWdyYXBoOiAvXigoPzpbXlxcbl0rXFxuPyg/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXx0YWd8ZGVmKSkrKVxcbiovLFxuICB0ZXh0OiAvXlteXFxuXSsvXG59O1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkK1xcLikvO1xuYmxvY2suaXRlbSA9IC9eKCAqKShidWxsKSBbXlxcbl0qKD86XFxuKD8hXFwxYnVsbCApW15cXG5dKikqLztcbmJsb2NrLml0ZW0gPSByZXBsYWNlKGJsb2NrLml0ZW0sICdnbScpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgpO1xuXG5ibG9jay5saXN0ID0gcmVwbGFjZShibG9jay5saXN0KVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/OlstKl9dICopezMsfSg/OlxcXFxuK3wkKSknKVxuICAoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgKCk7XG5cbmJsb2NrLmJsb2NrcXVvdGUgPSByZXBsYWNlKGJsb2NrLmJsb2NrcXVvdGUpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuYmxvY2suX3RhZyA9ICcoPyEoPzonXG4gICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlJ1xuICArICd8dmFyfHNhbXB8a2JkfHN1YnxzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG8nXG4gICsgJ3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZylcXFxcYilcXFxcdysoPyE6L3xbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJztcblxuYmxvY2suaHRtbCA9IHJlcGxhY2UoYmxvY2suaHRtbClcbiAgKCdjb21tZW50JywgLzwhLS1bXFxzXFxTXSo/LS0+LylcbiAgKCdjbG9zZWQnLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LylcbiAgKCdjbG9zaW5nJywgLzx0YWcoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vKVxuICAoL3RhZy9nLCBibG9jay5fdGFnKVxuICAoKTtcblxuYmxvY2sucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnaHInLCBibG9jay5ocilcbiAgKCdoZWFkaW5nJywgYmxvY2suaGVhZGluZylcbiAgKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAoJ2Jsb2NrcXVvdGUnLCBibG9jay5ibG9ja3F1b3RlKVxuICAoJ3RhZycsICc8JyArIGJsb2NrLl90YWcpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IG1lcmdlKHt9LCBibG9jayk7XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGZlbmNlczogL14gKihgezMsfXx+ezMsfSlbIFxcLl0qKFxcUyspPyAqXFxuKFtcXHNcXFNdKj8pXFxzKlxcMSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogL14vLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKyhbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpL1xufSk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCcoPyEnLCAnKD8hJ1xuICAgICsgYmxvY2suZ2ZtLmZlbmNlcy5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDInKSArICd8J1xuICAgICsgYmxvY2subGlzdC5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDMnKSArICd8JylcbiAgKCk7XG5cbi8qKlxuICogR0ZNICsgVGFibGVzIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay50YWJsZXMgPSBtZXJnZSh7fSwgYmxvY2suZ2ZtLCB7XG4gIG5wdGFibGU6IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLFxuICB0YWJsZTogL14gKlxcfCguKylcXG4gKlxcfCggKlstOl0rWy18IDpdKilcXG4oKD86ICpcXHwuKig/OlxcbnwkKSkqKVxcbiovXG59KTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbnMubGlua3MgPSB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMucnVsZXMgPSBibG9jay5ub3JtYWw7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLnRhYmxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLmdmbTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgQmxvY2sgUnVsZXNcbiAqL1xuXG5MZXhlci5ydWxlcyA9IGJsb2NrO1xuXG4vKipcbiAqIFN0YXRpYyBMZXggTWV0aG9kXG4gKi9cblxuTGV4ZXIubGV4ID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xufTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzaW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKHNyYykge1xuICBzcmMgPSBzcmNcbiAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpXG4gICAgLnJlcGxhY2UoL1xcdTI0MjQvZywgJ1xcbicpO1xuXG4gIHJldHVybiB0aGlzLnRva2VuKHNyYywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIExleGluZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uKHNyYywgdG9wLCBicSkge1xuICB2YXIgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKVxuICAgICwgbmV4dFxuICAgICwgbG9vc2VcbiAgICAsIGNhcFxuICAgICwgYnVsbFxuICAgICwgYlxuICAgICwgaXRlbVxuICAgICwgc3BhY2VcbiAgICAsIGlcbiAgICAsIGw7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIG5ld2xpbmVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5uZXdsaW5lLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc3BhY2UnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eIHs0fS9nbSwgJycpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgID8gY2FwLnJlcGxhY2UoL1xcbiskLywgJycpXG4gICAgICAgICAgOiBjYXBcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZmVuY2VzIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZmVuY2VzLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIGxhbmc6IGNhcFsyXSxcbiAgICAgICAgdGV4dDogY2FwWzNdIHx8ICcnXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgbm8gbGVhZGluZyBwaXBlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5ucHRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsyXSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaHInXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJsb2NrcXVvdGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ibG9ja3F1b3RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcblxuICAgICAgLy8gUGFzcyBgdG9wYCB0byBrZWVwIHRoZSBjdXJyZW50XG4gICAgICAvLyBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgLy8gaG93IG1hcmtkb3duLnBsIHdvcmtzLlxuICAgICAgdGhpcy50b2tlbihjYXAsIHRvcCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlzdFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpc3QuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgYnVsbCA9IGNhcFsyXTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X3N0YXJ0JyxcbiAgICAgICAgb3JkZXJlZDogYnVsbC5sZW5ndGggPiAxXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG4gICAgICBjYXAgPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5pdGVtKTtcblxuICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgbCA9IGNhcC5sZW5ndGg7XG4gICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGNhcFtpXTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3QgaXRlbSdzIGJ1bGxldFxuICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuICAgICAgICBzcGFjZSA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1xcLikgKy8sICcnKTtcblxuICAgICAgICAvLyBPdXRkZW50IHdoYXRldmVyIHRoZVxuICAgICAgICAvLyBsaXN0IGl0ZW0gY29udGFpbnMuIEhhY2t5LlxuICAgICAgICBpZiAofml0ZW0uaW5kZXhPZignXFxuICcpKSB7XG4gICAgICAgICAgc3BhY2UgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgaXRlbSA9ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgID8gaXRlbS5yZXBsYWNlKG5ldyBSZWdFeHAoJ14gezEsJyArIHNwYWNlICsgJ30nLCAnZ20nKSwgJycpXG4gICAgICAgICAgICA6IGl0ZW0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5leHQgbGlzdCBpdGVtIGJlbG9uZ3MgaGVyZS5cbiAgICAgICAgLy8gQmFja3BlZGFsIGlmIGl0IGRvZXMgbm90IGJlbG9uZyBpbiB0aGlzIGxpc3QuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnRMaXN0cyAmJiBpICE9PSBsIC0gMSkge1xuICAgICAgICAgIGIgPSBibG9jay5idWxsZXQuZXhlYyhjYXBbaSArIDFdKVswXTtcbiAgICAgICAgICBpZiAoYnVsbCAhPT0gYiAmJiAhKGJ1bGwubGVuZ3RoID4gMSAmJiBiLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgICBzcmMgPSBjYXAuc2xpY2UoaSArIDEpLmpvaW4oJ1xcbicpICsgc3JjO1xuICAgICAgICAgICAgaSA9IGwgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAvLyBVc2U6IC8oXnxcXG4pKD8hIClbXlxcbl0rXFxuXFxuKD8hXFxzKiQpL1xuICAgICAgICAvLyBmb3IgZGlzY291bnQgYmVoYXZpb3IuXG4gICAgICAgIGxvb3NlID0gbmV4dCB8fCAvXFxuXFxuKD8hXFxzKiQpLy50ZXN0KGl0ZW0pO1xuICAgICAgICBpZiAoaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBuZXh0ID0gaXRlbS5jaGFyQXQoaXRlbS5sZW5ndGggLSAxKSA9PT0gJ1xcbic7XG4gICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogbG9vc2VcbiAgICAgICAgICAgID8gJ2xvb3NlX2l0ZW1fc3RhcnQnXG4gICAgICAgICAgICA6ICdsaXN0X2l0ZW1fc3RhcnQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgIHRoaXMudG9rZW4oaXRlbSwgZmFsc2UsIGJxKTtcblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtX2VuZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHRtbFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3BhcmFncmFwaCdcbiAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlZlxuICAgIGlmICgoIWJxICYmIHRvcCkgJiYgKGNhcCA9IHRoaXMucnVsZXMuZGVmLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5saW5rc1tjYXBbMV0udG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy50YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC8oPzogKlxcfCAqKT9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXVxuICAgICAgICAgIC5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJylcbiAgICAgICAgICAuc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMucGFyYWdyYXBoLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHRleHQ6IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgIDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgLy8gVG9wLWxldmVsIHNob3VsZCBuZXZlciByZWFjaCBoZXJlLlxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGlubGluZSA9IHtcbiAgZXNjYXBlOiAvXlxcXFwoW1xcXFxgKnt9XFxbXFxdKCkjK1xcLS4hXz5dKS8sXG4gIGF1dG9saW5rOiAvXjwoW14gPl0rKEB8OlxcLylbXiA+XSspPi8sXG4gIHVybDogbm9vcCxcbiAgdGFnOiAvXjwhLS1bXFxzXFxTXSo/LS0+fF48XFwvP1xcdysoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vLFxuICBsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXChocmVmXFwpLyxcbiAgcmVmbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gIG5vbGluazogL14hP1xcWygoPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXSkqKVxcXS8sXG4gIHN0cm9uZzogL15fXyhbXFxzXFxTXSs/KV9fKD8hXyl8XlxcKlxcKihbXFxzXFxTXSs/KVxcKlxcKig/IVxcKikvLFxuICBlbTogL15cXGJfKCg/OlteX118X18pKz8pX1xcYnxeXFwqKCg/OlxcKlxcKnxbXFxzXFxTXSkrPylcXCooPyFcXCopLyxcbiAgY29kZTogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLFxuICBicjogL14gezIsfVxcbig/IVxccyokKS8sXG4gIGRlbDogbm9vcCxcbiAgdGV4dDogL15bXFxzXFxTXSs/KD89W1xcXFw8IVxcW18qYF18IHsyLH1cXG58JCkvXG59O1xuXG5pbmxpbmUuX2luc2lkZSA9IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLztcbmlubGluZS5faHJlZiA9IC9cXHMqPD8oW1xcc1xcU10qPyk+Pyg/OlxccytbJ1wiXShbXFxzXFxTXSo/KVsnXCJdKT9cXHMqLztcblxuaW5saW5lLmxpbmsgPSByZXBsYWNlKGlubGluZS5saW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gICgpO1xuXG5pbmxpbmUucmVmbGluayA9IHJlcGxhY2UoaW5saW5lLnJlZmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS9cbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IHJlcGxhY2UoaW5saW5lLmVzY2FwZSkoJ10pJywgJ358XSknKSgpLFxuICB1cmw6IC9eKGh0dHBzPzpcXC9cXC9bXlxcczxdK1tePC4sOjtcIicpXFxdXFxzXSkvLFxuICBkZWw6IC9efn4oPz1cXFMpKFtcXHNcXFNdKj9cXFMpfn4vLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS50ZXh0KVxuICAgICgnXXwnLCAnfl18JylcbiAgICAoJ3wnLCAnfGh0dHBzPzovL3wnKVxuICAgICgpXG59KTtcblxuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogcmVwbGFjZShpbmxpbmUuYnIpKCd7Mix9JywgJyonKSgpLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS5nZm0udGV4dCkoJ3syLH0nLCAnKicpKClcbn0pO1xuXG4vKipcbiAqIElubGluZSBMZXhlciAmIENvbXBpbGVyXG4gKi9cblxuZnVuY3Rpb24gSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMubGlua3MgPSBsaW5rcztcbiAgdGhpcy5ydWxlcyA9IGlubGluZS5ub3JtYWw7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKCF0aGlzLmxpbmtzKSB7XG4gICAgdGhyb3cgbmV3XG4gICAgICBFcnJvcignVG9rZW5zIGFycmF5IHJlcXVpcmVzIGEgYGxpbmtzYCBwcm9wZXJ0eS4nKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuYnJlYWtzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmdmbTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgdGhpcy5ydWxlcyA9IGlubGluZS5wZWRhbnRpYztcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBJbmxpbmUgUnVsZXNcbiAqL1xuXG5JbmxpbmVMZXhlci5ydWxlcyA9IGlubGluZTtcblxuLyoqXG4gKiBTdGF0aWMgTGV4aW5nL0NvbXBpbGluZyBNZXRob2RcbiAqL1xuXG5JbmxpbmVMZXhlci5vdXRwdXQgPSBmdW5jdGlvbihzcmMsIGxpbmtzLCBvcHRpb25zKSB7XG4gIHZhciBpbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpO1xuICByZXR1cm4gaW5saW5lLm91dHB1dChzcmMpO1xufTtcblxuLyoqXG4gKiBMZXhpbmcvQ29tcGlsaW5nXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKHNyYykge1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGxpbmtcbiAgICAsIHRleHRcbiAgICAsIGhyZWZcbiAgICAsIGNhcDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gZXNjYXBlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZXNjYXBlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBjYXBbMV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhdXRvbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmF1dG9saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gY2FwWzFdLmNoYXJBdCg2KSA9PT0gJzonXG4gICAgICAgICAgPyB0aGlzLm1hbmdsZShjYXBbMV0uc3Vic3RyaW5nKDcpKVxuICAgICAgICAgIDogdGhpcy5tYW5nbGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRoaXMubWFuZ2xlKCdtYWlsdG86JykgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB1cmwgKGdmbSlcbiAgICBpZiAoIXRoaXMuaW5MaW5rICYmIChjYXAgPSB0aGlzLnJ1bGVzLnVybC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFnXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGFnLmV4ZWMoc3JjKSkge1xuICAgICAgaWYgKCF0aGlzLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKVxuICAgICAgICAgIDogZXNjYXBlKGNhcFswXSlcbiAgICAgICAgOiBjYXBbMF1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IHRoaXMubGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgIG91dCArPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICBzcmMgPSBjYXBbMF0uc3Vic3RyaW5nKDEpICsgc3JjO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCBsaW5rKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzdHJvbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5zdHJvbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuc3Ryb25nKHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGVtXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZW0uZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZW0odGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZXNwYW4oZXNjYXBlKGNhcFsyXSwgdHJ1ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYnJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ici5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5icigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmRlbCh0aGlzLm91dHB1dChjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRleHQoZXNjYXBlKHRoaXMuc21hcnR5cGFudHMoY2FwWzBdKSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBMaW5rXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbihjYXAsIGxpbmspIHtcbiAgdmFyIGhyZWYgPSBlc2NhcGUobGluay5ocmVmKVxuICAgICwgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcblxuICByZXR1cm4gY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnXG4gICAgPyB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgdGl0bGUsIHRoaXMub3V0cHV0KGNhcFsxXSkpXG4gICAgOiB0aGlzLnJlbmRlcmVyLmltYWdlKGhyZWYsIHRpdGxlLCBlc2NhcGUoY2FwWzFdKSk7XG59O1xuXG4vKipcbiAqIFNtYXJ0eXBhbnRzIFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5zbWFydHlwYW50cyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMpIHJldHVybiB0ZXh0O1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufTtcblxuLyoqXG4gKiBNYW5nbGUgTGlua3NcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUubWFuZ2xlID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5tYW5nbGUpIHJldHVybiB0ZXh0O1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGwgPSB0ZXh0Lmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIGNoO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuXG5mdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24oY29kZSwgbGFuZywgZXNjYXBlZCkge1xuICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IGNvZGUpIHtcbiAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgY29kZSA9IG91dDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWxhbmcpIHtcbiAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICArICdcXG48L2NvZGU+PC9wcmU+JztcbiAgfVxuXG4gIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIidcbiAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgKyBlc2NhcGUobGFuZywgdHJ1ZSlcbiAgICArICdcIj4nXG4gICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgKyAnXFxuPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYmxvY2txdW90ZSA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJyArIHF1b3RlICsgJzwvYmxvY2txdW90ZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbihodG1sKSB7XG4gIHJldHVybiBodG1sO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhlYWRpbmcgPSBmdW5jdGlvbih0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gIHJldHVybiAnPGgnXG4gICAgKyBsZXZlbFxuICAgICsgJyBpZD1cIidcbiAgICArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXhcbiAgICArIHJhdy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teXFx3XSsvZywgJy0nKVxuICAgICsgJ1wiPidcbiAgICArIHRleHRcbiAgICArICc8L2gnXG4gICAgKyBsZXZlbFxuICAgICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGhyLz5cXG4nIDogJzxocj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihib2R5LCBvcmRlcmVkKSB7XG4gIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICByZXR1cm4gJzwnICsgdHlwZSArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0aXRlbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnBhcmFncmFwaCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKGhlYWRlciwgYm9keSkge1xuICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgKyAnPHRoZWFkPlxcbidcbiAgICArIGhlYWRlclxuICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICsgJzx0Ym9keT5cXG4nXG4gICAgKyBib2R5XG4gICAgKyAnPC90Ym9keT5cXG4nXG4gICAgKyAnPC90YWJsZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlcm93ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVjZWxsID0gZnVuY3Rpb24oY29udGVudCwgZmxhZ3MpIHtcbiAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgdmFyIHRhZyA9IGZsYWdzLmFsaWduXG4gICAgPyAnPCcgKyB0eXBlICsgJyBzdHlsZT1cInRleHQtYWxpZ246JyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICA6ICc8JyArIHR5cGUgKyAnPic7XG4gIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG4vLyBzcGFuIGxldmVsIHJlbmRlcmVyXG5SZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGVzcGFuID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUoaHJlZikpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdzpdL2csICcnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuICB2YXIgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIHZhciBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dDtcbn07XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW4gPSBudWxsO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xufVxuXG4vKipcbiAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAqL1xuXG5QYXJzZXIucGFyc2UgPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMsIHJlbmRlcmVyKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIHJlbmRlcmVyKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShzcmMpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMb29wXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHNyYykge1xuICB0aGlzLmlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihzcmMubGlua3MsIHRoaXMub3B0aW9ucywgdGhpcy5yZW5kZXJlcik7XG4gIHRoaXMudG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgIG91dCArPSB0aGlzLnRvaygpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbiA9IHRoaXMudG9rZW5zLnBvcCgpO1xufTtcblxuLyoqXG4gKiBQcmV2aWV3IE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdIHx8IDA7XG59O1xuXG4vKipcbiAqIFBhcnNlIFRleHQgVG9rZW5zXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvZHkgPSB0aGlzLnRva2VuLnRleHQ7XG5cbiAgd2hpbGUgKHRoaXMucGVlaygpLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5saW5lLm91dHB1dChib2R5KTtcbn07XG5cbi8qKlxuICogUGFyc2UgQ3VycmVudCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhlYWRpbmcoXG4gICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpLFxuICAgICAgICB0aGlzLnRva2VuLmRlcHRoLFxuICAgICAgICB0aGlzLnRva2VuLnRleHQpO1xuICAgIH1cbiAgICBjYXNlICdjb2RlJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY29kZSh0aGlzLnRva2VuLnRleHQsXG4gICAgICAgIHRoaXMudG9rZW4ubGFuZyxcbiAgICAgICAgdGhpcy50b2tlbi5lc2NhcGVkKTtcbiAgICB9XG4gICAgY2FzZSAndGFibGUnOiB7XG4gICAgICB2YXIgaGVhZGVyID0gJydcbiAgICAgICAgLCBib2R5ID0gJydcbiAgICAgICAgLCBpXG4gICAgICAgICwgcm93XG4gICAgICAgICwgY2VsbFxuICAgICAgICAsIGZsYWdzXG4gICAgICAgICwgajtcblxuICAgICAgLy8gaGVhZGVyXG4gICAgICBjZWxsID0gJyc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5oZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmxhZ3MgPSB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfTtcbiAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi5oZWFkZXJbaV0pLFxuICAgICAgICAgIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93ID0gdGhpcy50b2tlbi5jZWxsc1tpXTtcblxuICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHJvd1tqXSksXG4gICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnYmxvY2txdW90ZV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnYmxvY2txdW90ZV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJydcbiAgICAgICAgLCBvcmRlcmVkID0gdGhpcy50b2tlbi5vcmRlcmVkO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRva2VuLnR5cGUgPT09ICd0ZXh0J1xuICAgICAgICAgID8gdGhpcy5wYXJzZVRleHQoKVxuICAgICAgICAgIDogdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xvb3NlX2l0ZW1fc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICB2YXIgaHRtbCA9ICF0aGlzLnRva2VuLnByZSAmJiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgID8gdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dClcbiAgICAgICAgOiB0aGlzLnRva2VuLnRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5odG1sKGh0bWwpO1xuICAgIH1cbiAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VUZXh0KCkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICByZXR1cm4gaHRtbFxuICAgIC5yZXBsYWNlKCFlbmNvZGUgPyAvJig/ISM/XFx3KzspL2cgOiAvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLyYoWyNcXHddKyk7L2csIGZ1bmN0aW9uKF8sIG4pIHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICB2YXIgaSA9IDFcbiAgICAsIHRhcmdldFxuICAgICwga2V5O1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogTWFya2VkXG4gKi9cblxuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgfHwgdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IG9wdC5oaWdobGlnaHRcbiAgICAgICwgdG9rZW5zXG4gICAgICAsIHBlbmRpbmdcbiAgICAgICwgaSA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICB9XG5cbiAgICBwZW5kaW5nID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBvdXQgPSBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfVxuXG4gICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG4gICAgICByZXR1cm4gZXJyXG4gICAgICAgID8gY2FsbGJhY2soZXJyKVxuICAgICAgICA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgfTtcblxuICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuXG4gICAgaWYgKCFwZW5kaW5nKSByZXR1cm4gZG9uZSgpO1xuXG4gICAgZm9yICg7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbihlcnIsIGNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgIGlmIChjb2RlID09IG51bGwgfHwgY29kZSA9PT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkodG9rZW5zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0KSBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoTGV4ZXIubGV4KHNyYywgb3B0KSwgb3B0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZC4nO1xuICAgIGlmICgob3B0IHx8IG1hcmtlZC5kZWZhdWx0cykuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+J1xuICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgKyAnPC9wcmU+JztcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBtZXJnZShtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZGVmYXVsdHMgPSB7XG4gIGdmbTogdHJ1ZSxcbiAgdGFibGVzOiB0cnVlLFxuICBicmVha3M6IGZhbHNlLFxuICBwZWRhbnRpYzogZmFsc2UsXG4gIHNhbml0aXplOiBmYWxzZSxcbiAgc2FuaXRpemVyOiBudWxsLFxuICBtYW5nbGU6IHRydWUsXG4gIHNtYXJ0TGlzdHM6IGZhbHNlLFxuICBzaWxlbnQ6IGZhbHNlLFxuICBoaWdobGlnaHQ6IG51bGwsXG4gIGxhbmdQcmVmaXg6ICdsYW5nLScsXG4gIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgaGVhZGVyUHJlZml4OiAnJyxcbiAgcmVuZGVyZXI6IG5ldyBSZW5kZXJlcixcbiAgeGh0bWw6IGZhbHNlXG59O1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcblxubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5cbm1hcmtlZC5JbmxpbmVMZXhlciA9IElubGluZUxleGVyO1xubWFya2VkLmlubGluZUxleGVyID0gSW5saW5lTGV4ZXIub3V0cHV0O1xuXG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXJrZWQ7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5tYXJrZWQgPSBtYXJrZWQ7XG59XG5cbn0pLmNhbGwoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG59KCkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbWFya2VkL2xpYi9tYXJrZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZGVmaW5lVGFnKCdzaXRlJywgJ2h0bWwnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVwcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGVwczsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RGVwcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kZXBzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnJC4kaGVhZCgpLnNldENvbnRlbnQoW1xuXHRcdFx0XHR0YWckLiR0aXRsZSgpLnNldFRleHQoXCJpbWJhXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0Q2hhcnNldChcInV0Zi04XCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0TmFtZShcInZpZXdwb3J0XCIpLnNldENvbnRlbnQoXCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLG1pbmltdW0tc2NhbGU9MVwiKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kbWV0YSgpLnNldE5hbWUoXCJEZXNjcmlwdGlvblwiKS5zZXRDb250ZW50KFwiSW1iYSBpcyBhIHJpY2ggcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgZm9yIHRoZSB3ZWIuXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0TmFtZShcImtleXdvcmRzXCIpLnNldENvbnRlbnQoXCJpbWJhIGphdmFzY3JpcHQgbGFuZ3VhZ2UganNcIikuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGxpbmsoKS5zZXRIcmVmKCdodHRwOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Tb3VyY2UrQ29kZStQcm86NDAwLDUwMCw2MDAnKS5zZXRSZWwoJ3N0eWxlc2hlZXQnKS5zZXRUeXBlKCd0ZXh0L2NzcycpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRsaW5rKCkuc2V0UmVsKFwic3R5bGVzaGVldFwiKS5zZXRIcmVmKFwiL2Nzcy9zaXRlLmNzc1wiKS5zZXRNZWRpYShcInNjcmVlblwiKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kc2NyaXB0KCkuc2V0VGV4dCgnREVQUyA9IHt9OycpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRzY3JpcHQoKS5zZXRTcmMoXCIvdmVuZG9yL2dhLmpzXCIpLmVuZCgpXG5cdFx0XHRdLDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnJC4kYm9keSgpLnNldElkKCdzaXRlJykuc2V0Q29udGVudChbXG5cdFx0XHRcdHRhZyQuJHNpdGVfbmF2KCkuc2V0SWQoJ2hlYWRlcicpLmZsYWcoJ2F3YWtlbicpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRob21lKCkuc2V0Um91dGUoJy9ob21lJykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGd1aWRlcygpLnNldFJvdXRlKCcvZ3VpZGVzJykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGRvY3MoKS5zZXRSb3V0ZSgnL2RvY3MnKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kYmxvZygpLnNldFJvdXRlKCcvYmxvZycpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRmb290ZXIoKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHR0YWckLiRocigpLmVuZCgpLFxuXHRcdFx0XHRcdHRhZyQuJGRpdigpLmZsYWcoJ2xmdCcpLnNldFRleHQoXCJJbWJhIMKpIDIwMTUtMjAxNlwiKS5lbmQoKSxcblx0XHRcdFx0XHR0YWckLiRkaXYoKS5mbGFnKCdyZ3QnKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdHRhZyQuJGEoKS5zZXRIcmVmKCdodHRwOi8vdHdpdHRlci5jb20vaW1iYWpzJykuc2V0VGV4dCgnVHdpdHRlcicpLmVuZCgpLFxuXHRcdFx0XHRcdFx0dGFnJC4kYSgpLnNldEhyZWYoJ2h0dHA6Ly9naXRodWIuY29tL3NvbWJlZS9pbWJhJykuc2V0VGV4dCgnR2l0SHViJykuZW5kKCksXG5cdFx0XHRcdFx0XHR0YWckLiRhKCkuc2V0SHJlZignaHR0cDovL2dpdGh1Yi5jb20vc29tYmVlL2ltYmEvaXNzdWVzJykuc2V0VGV4dCgnSXNzdWVzJykuZW5kKCksXG5cdFx0XHRcdFx0XHR0YWckLiRhKCkuc2V0SHJlZignaHR0cDovL2dpdHRlci5pbS9zb21iZWUvaW1iYScpLnNldFRleHQoJ0NoYXQnKS5lbmQoKVxuXHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XSwyKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2NyaXB0cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCB0MDtcblx0XHRcdHJldHVybiB0YWckLiRkaXYoKS5mbGFnKCdzY3JpcHRzJykuc2V0Q29udGVudChbXG5cdFx0XHRcdChmdW5jdGlvbih0MCkge1xuXHRcdFx0XHRcdGZvciAodmFyIG8gPSBzZWxmLmRlcHMoKSwgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGtleXMubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0XHRyZXMucHVzaCh0YWckLiRzY3JpcHQoKS5zZXRUeXBlKFwidGV4dC9qYXZhc2NyaXB0XCIpLnNldFNyYygoa2V5c1tpXSArICcuZGVwJykpLmVuZCgpKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdH0pKHQwKSxcblx0XHRcdFx0dGFnJC4kc2NyaXB0KCkuc2V0U3JjKFwiL3ZlbmRvci9obC5qc1wiKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kc2NyaXB0KCkuc2V0U3JjKFwiL2NsaWVudC5qc1wiKS5lbmQoKVxuXHRcdFx0XSwwKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBkaXJ0eSB3b3JrYXJvdW5kc1xuXHRcdFx0QVBQLnNldFNpdGUodGhpcyk7XG5cdFx0XHR0aGlzLnNldERlcHMoe1xuXHRcdFx0XHRcIi9pc3N1ZXMvYWxsLmpzb25cIjogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdEFQUC5mZXRjaERvY3VtZW50KCcvZ3VpZGVzLm1kJyk7XG5cdFx0XHR2YXIgYm9keSA9IHRoaXMuYm9keSgpO1xuXHRcdFx0Ym9keS5hcHBlbmQodGhpcy5zY3JpcHRzKCkpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmZsYWcoJ2xpZ2h0Jykuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHR0aGlzLmhlYWQoKSxcblx0XHRcdFx0Ym9keVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHRcdEFQUC5zZXRTaXRlKG51bGwpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdzaXRlLW5hdicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2dnbGVNZW51ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gcSQkKCdib2R5JykudG9nZ2xlRmxhZygnbWVudScpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDcsIHQ4LCB0OTtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFxuXHRcdFx0XHQodDAgPSB0aGlzLiRhPXRoaXMuJGEgfHwgdGFnJC4kbmF2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGEoKS5mbGFnKCdtZW51Jykuc2V0SGFuZGxlcigndGFwJywndG9nZ2xlTWVudScsdGhpcykpLnNldENvbnRlbnQoKHQxLiQkYSA9IHQxLiQkYSB8fCB0YWckLiRiKCkpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MiA9IHQwLiQkYj10MC4kJGIgfHwgdGFnJC4kYSgpLmZsYWcoJ3RhYicpLmZsYWcoJ2xvZ28nKS5zZXRIcmVmKCcvaG9tZScpKS5zZXRDb250ZW50KCh0Mi4kJGEgPSB0Mi4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdpbWJhJykuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0KHQzID0gdDAuJCRjPXQwLiQkYyB8fCB0YWckLiRhKCkuZmxhZygndGFiJykuZmxhZygnaG9tZScpLnNldEhyZWYoJy9ob21lJykpLnNldENvbnRlbnQoKHQzLiQkYSA9IHQzLiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2hvbWUnKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDQgPSB0MC4kJGQ9dDAuJCRkIHx8IHRhZyQuJGEoKS5mbGFnKCd0YWInKS5mbGFnKCdndWlkZXMnKS5zZXRIcmVmKCcvZ3VpZGVzJykpLnNldENvbnRlbnQoKHQ0LiQkYSA9IHQ0LiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2d1aWRlcycpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0NSA9IHQwLiQkZT10MC4kJGUgfHwgdGFnJC4kYSgpLmZsYWcoJ3RhYicpLmZsYWcoJ2RvY3MnKS5zZXRIcmVmKCcvZG9jcycpKS5zZXRDb250ZW50KCh0NS4kJGEgPSB0NS4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdhcGknKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDYgPSB0MC4kJGY9dDAuJCRmIHx8IHRhZyQuJGEoKS5mbGFnKCd0YWInKS5mbGFnKCdibG9nJykuc2V0SHJlZignL2Jsb2cnKSkuc2V0Q29udGVudCgodDYuJCRhID0gdDYuJCRhIHx8IHRhZyQuJGkoKSkuc2V0VGV4dCgnYmxvZycpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MC4kJGcgPSB0MC4kJGcgfHwgdGFnJC4kc3BhbigpLmZsYWcoJ2dyZWVkeScpKS5lbmQoKSxcblx0XHRcdFx0XHQodDcgPSB0MC4kJGg9dDAuJCRoIHx8IHRhZyQuJGEoKS5mbGFnKCd0d2l0dGVyJykuc2V0SHJlZignaHR0cDovL3R3aXR0ZXIuY29tL2ltYmFqcycpKS5zZXRDb250ZW50KCh0Ny4kJGEgPSB0Ny4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCd0d2l0dGVyJykuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0KHQ4ID0gdDAuJCRpPXQwLiQkaSB8fCB0YWckLiRhKCkuZmxhZygnZ2l0aHViJykuc2V0SHJlZignaHR0cHM6Ly9naXRodWIuY29tL3NvbWViZWUvaW1iYScpKS5zZXRDb250ZW50KCh0OC4kJGEgPSB0OC4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdnaXRodWInKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDkgPSB0MC4kJGo9dDAuJCRqIHx8IHRhZyQuJGEoKS5mbGFnKCdpc3N1ZXMnKS5zZXRIcmVmKCdodHRwczovL2dpdGh1Yi5jb20vc29tZWJlZS9pbWJhL2lzc3VlcycpKS5zZXRDb250ZW50KCh0OS4kJGEgPSB0OS4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdpc3N1ZXMnKS5lbmQoKSwyKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHQsMikuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2NoZWR1bGUoe2ZwczogMH0pO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9zaXRlLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ25hdm1lbnUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25yb3V0ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbWVudScpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbmF2LWxpc3QnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCduYXYtbGluaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIcmVmID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdocmVmJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKCh0MCA9IHRoaXMuJGE9dGhpcy4kYSB8fCB0YWckLiRhKCkpLnNldEhyZWYodGhpcy5ocmVmKCkpLnNldENvbnRlbnQodGhpcy5fY29udGVudCwzKS5lbmQoKSwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygndG9jJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxldmVsID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbGV2ZWwnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TGV2ZWwgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2xldmVsJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnRvZ2dsZUZsYWcoJ2NvbGxhcHNlZCcpO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9uYXYuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygncGFnZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2JvZHkgPSB0aGlzLl9ib2R5IHx8IHRhZyQuJGRpdigpLnNldFJlZignYm9keScsdGhpcykpLnNldFRleHQoXCJDb250ZW50IGhlcmVcIikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hdiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICh0aGlzLl9uYXYgPSB0aGlzLl9uYXYgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCduYXYnLHRoaXMpKS5zZXRUZXh0KFwiTmF2aWdhdGlvbiBoZXJlXCIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHR0aGlzLm5hdigpLFxuXHRcdFx0XHR0aGlzLmJvZHkoKVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zY29wZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51bnNjb3BlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gbG9nICdyZW5kZXIgcGFnZScscm91dGVcblx0XHRcdHZhciBzY29wZWQgPSB0aGlzLnJvdXRlcigpLnNjb3BlZCh0aGlzLnJvdXRlKCksdGhpcyk7XG5cdFx0XHRcblx0XHRcdGlmIChzY29wZWQgIT0gdGhpcy5fc2NvcGVkKSB7XG5cdFx0XHRcdHRoaXMuX3Njb3BlZCA9IHNjb3BlZDtcblx0XHRcdFx0dGhpcy5fc2NvcGVkID8gKHRoaXMuc2NvcGVkKCkpIDogKHRoaXMudW5zY29wZWQoKSk7XG5cdFx0XHRcdHRoaXMuZmxhZygnc2NvcGVkJyxzY29wZWQpO1xuXHRcdFx0XHR0aGlzLmZsYWcoJ3NlbGVjdGVkJyx0aGlzLnJvdXRlcigpLm1hdGNoKHRoaXMucm91dGUoKSx0aGlzKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoIShzY29wZWQgJiYgdGhpcy5yZWFkeSgpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRoaXMuYXNzZW1ibGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zY2hlZHVsZSh7ZnBzOiAxLGV2ZW50czogdHJ1ZX0pO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9wYWdlLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBSb3V0ZXIgPSByZXF1aXJlKCcuLi9yb3V0ZXInKS5Sb3V0ZXI7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaXNzdWUtZW50cnknLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCB0Miwgc2VsZiA9IHRoaXMsIHQzO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodDAgPSB0aGlzLiRhPXRoaXMuJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0KHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRhKCkuZmxhZygndGl0bGUnKSkuc2V0SHJlZigoXCIvYmxvZy9cIiArICh0aGlzLm9iamVjdCgpLm51bWJlcikgKyBcIi1cIiArIFJvdXRlci5zbHVnKHRoaXMub2JqZWN0KCkudGl0bGUpKSkuc2V0Q29udGVudCh0aGlzLm9iamVjdCgpLnRpdGxlLDMpLmVuZCgpXG5cdFx0XHRcdCwyKS5lbmQoKSxcblx0XHRcdFx0KHQyID0gdGhpcy4kYj10aGlzLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2xlZ2VuZCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcImJ5IFwiLFxuXHRcdFx0XHRcdCh0Mi4kJGEgPSB0Mi4kJGEgfHwgdGFnJC4kZ2hfdXNlcigpKS5zZXRPYmplY3QodGhpcy5vYmplY3QoKS51c2VyKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpLFxuXHRcdFx0XHRcblx0XHRcdFx0KHQzID0gc2VsZi4kYz1zZWxmLiRjIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2xhYmVscycpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdChmdW5jdGlvbih0Mykge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYub2JqZWN0KCkubGFiZWxzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDNbJyQkYScgKyBpXSA9IHQzWyckJGEnICsgaV0gfHwgdGFnJC4kZ2hfbGFiZWwoKSkuc2V0T2JqZWN0KGFyeVtpXSkuZW5kKCkpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fSkodDMpXG5cdFx0XHRcdCwzKS5lbmQoKVxuXHRcdFx0XSwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdnaC1sYWJlbCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuc2V0VGl0bGUoKHRoaXMub2JqZWN0KCkubmFtZSkpLnNldENoaWxkcmVuKHRoaXMub2JqZWN0KCkubmFtZSwzKS5zeW5jZWQoKTtcblx0XHRcdGlmIChJbWJhLkNMSUVOVCkge1xuXHRcdFx0XHR0aGlzLmNzcyh7YmFja2dyb3VuZENvbG9yOiAnIycgKyB0aGlzLm9iamVjdCgpLmNvbG9yfSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZ2gtdXNlcicsICdzcGFuJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oXG5cdFx0XHRcdCh0MCA9IHRoaXMuJGE9dGhpcy4kYSB8fCB0YWckLiRhKCkpLnNldEhyZWYoKFwiaHR0cDovL2dpdGh1Yi5jb20vXCIgKyAodGhpcy5vYmplY3QoKS5sb2dpbikpKS5zZXRDb250ZW50KHRoaXMub2JqZWN0KCkubG9naW4sMykuZW5kKClcblx0XHRcdCwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaXNzdWUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5vYmplY3QoKS5vYmplY3QoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNvbW1pdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICh0aGlzLm9iamVjdCgpICYmIHRoaXMub2JqZWN0KCkucmVhZHkoKSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnY29tbWl0IGlzc3VlJyk7XG5cdFx0XHRcdHRoaXMudW5mbGFnKCdsb2FkaW5nJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlbmRlcigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnbG9hZGluZycpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCB0Mjtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0KHQwID0gdGhpcy4kYT10aGlzLiRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGgxKCkuZmxhZygndGl0bGUnKSkuc2V0Q29udGVudCh0aGlzLmRvYygpLnRpdGxlLDMpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MiA9IHQwLiQkYj10MC4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnbGVnZW5kJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XCJXcml0dGVuIGJ5IFwiLFxuXHRcdFx0XHRcdFx0KHQyLiQkYSA9IHQyLiQkYSB8fCB0YWckLiRnaF91c2VyKCkpLnNldE9iamVjdCh0aGlzLmRvYygpLnVzZXIpLmVuZCgpLFxuXHRcdFx0XHRcdFx0KFwiIGF0IFwiICsgKHRoaXMuZG9jKCkuY3JlYXRlZF9hdCkpXG5cdFx0XHRcdFx0XSwxKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy4kYiA9IHRoaXMuJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpLmZsYWcoJ21kJykpLnNldEh0bWwoKHRoaXMuZG9jKCkubWQpKS5lbmQoKVxuXHRcdFx0XSwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvaXNzdWVzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdGZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpe1xuXHRcdHZhciBjb3VudGVyID0gYXJyYXkubGVuZ3RoLHRlbXAsaW5kZXg7XG5cdFx0XG5cdFx0Ly8gV2hpbGUgdGhlcmUgYXJlIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuXHRcdHdoaWxlIChjb3VudGVyID4gMCl7XG5cdFx0XHQvLyBQaWNrIGEgcmFuZG9tIGluZGV4XG5cdFx0XHRpbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvdW50ZXIpO1xuXHRcdFx0Y291bnRlci0tOyAvLyBEZWNyZWFzZSBjb3VudGVyIGJ5IDFcblx0XHRcdFxuXHRcdFx0Ly8gQW5kIHN3YXAgdGhlIGxhc3QgZWxlbWVudCB3aXRoIGl0XG5cdFx0XHR0ZW1wID0gYXJyYXlbY291bnRlcl07XG5cdFx0XHRhcnJheVtjb3VudGVyXSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGFycmF5W2luZGV4XSA9IHRlbXA7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gYXJyYXk7XG5cdH07XG5cdFxuXHR0YWckLmRlZmluZVRhZygncGF0dGVybicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcblx0XHRcdHZhciBwYXJ0cyA9IHt0YWdzOiBbXSxrZXl3b3JkczogW10sbWV0aG9kczogW119O1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgbGluZXMgPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgbyA9IEltYmEuVGFnLnByb3RvdHlwZSwgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0ayA9IGtleXNbaV07aXRlbXMucHVzaCgoXCI8ZW0+XCIgKyBrICsgXCI8L2VtPlwiKSk7XG5cdFx0XHRcdHBhcnRzLm1ldGhvZHMucHVzaCgoXCI8ZW0+XCIgKyBrICsgXCI8L2VtPlwiKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoSFRNTF9UQUdTKSwgbGVuXyA9IGFyeS5sZW5ndGgsIGsxOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdC8vIGZvciBvd24gayx2IG9mIEltYmEuVEFHU1xuXHRcdFx0XHQvLyBpZiB2IGFuZCB2OnByb3RvdHlwZSBpc2EgSW1iYS5UYWdcblx0XHRcdFx0azEgPSBhcnlbaV07XG5cdFx0XHRcdGl0ZW1zLnB1c2goKFwiPHU+Jmx0O1wiICsgazEgKyBcIiZndDs8L3U+XCIpKTtcblx0XHRcdFx0cGFydHMudGFncy5wdXNoKChcIjx1PiZsdDtcIiArIGsxICsgXCImZ3Q7PC91PlwiKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgd29yZHMgPSBcImRlZiBpZiBlbHNlIGVsaWYgd2hpbGUgdW50aWwgZm9yIGluIG9mIHZhciBsZXQgY2xhc3MgZXh0ZW5kIGV4cG9ydCBpbXBvcnQgdGFnIGdsb2JhbFwiO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQod29yZHMuc3BsaXQoXCIgXCIpKSwgbGVuXyA9IGFyeS5sZW5ndGgsIGsyOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdGsyID0gYXJ5W2ldO1xuXHRcdFx0XHRpdGVtcy5wdXNoKChcIjxpPlwiICsgazIgKyBcIjwvaT5cIikpO1xuXHRcdFx0XHRwYXJ0cy5rZXl3b3Jkcy5wdXNoKChcIjxpPlwiICsgazIgKyBcIjwvaT5cIikpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHNodWZmbGVkID0gc2h1ZmZsZShpdGVtcyk7XG5cdFx0XHR2YXIgYWxsID0gW10uY29uY2F0KHNodWZmbGVkKTtcblx0XHRcdHZhciBjb3VudCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGxlbiA9IDEyLCBsbiA9IDA7IGxuIDw9IGxlbjsgbG4rKykge1xuXHRcdFx0XHR2YXIgY2hhcnMgPSAwO1xuXHRcdFx0XHRsaW5lc1tsbl0gPSBbXTtcblx0XHRcdFx0d2hpbGUgKGNoYXJzIDwgMzAwKXtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IChzaHVmZmxlZC5wb3AoKSB8fCBhbGxbTWF0aC5mbG9vcihjb3VudCAqIE1hdGgucmFuZG9tKCkpXSk7XG5cdFx0XHRcdFx0aWYgKGl0ZW0pIHtcblx0XHRcdFx0XHRcdGNoYXJzICs9IGl0ZW0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bGluZXNbbG5dLnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNoYXJzID0gNDAwO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9ICc8ZGl2PicgKyBsaW5lcy5tYXAoZnVuY3Rpb24obG4pIHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2IGNsYXNzPVwibGluZVwiPicgKyBsbi5qb2luKFwiIFwiKSArICc8L2Rpdj4nO1xuXHRcdFx0fSkuam9pbignJykgKyAnPC9kaXY+Jztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdhd2FrZW5pbmcgcGF0dGVybiEhJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHEkKCcubGluZScsdGhpcykpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFyIHogPSAyMCArIGkgKiAxMDtcblx0XHRcdFx0Ly8geiA9IHBhcnNlSW50KC16ICsgTWF0aC5yYW5kb20gKiB6ICogMilcblx0XHRcdFx0YXJ5W2ldLmNzcygndHJhbnNmb3JtJywoXCJ0cmFuc2xhdGVaKFwiICsgeiArIFwicHgpXCIpKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaG9tZScsICdwYWdlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR2YXIgdG9kb3MgPSB7ZGVtbzogdHJ1ZSxhdXRvcnVuOiB0cnVlfTtcblx0XHR2YXIgY2xvY2sgPSB7ZGVtbzogdHJ1ZSxhdXRvcnVuOiB0cnVlfTtcblx0XHR2YXIgcmVtaW5kZXJzID0ge2RlbW86IHRydWUsYXV0b3J1bjogdHJ1ZX07XG5cdFx0dmFyIGhlcm8gPSB7YXV0b3J1bjogdHJ1ZX07XG5cdFx0dmFyIGNhbnZhcyA9IHtkZW1vOiB0cnVlLGF1dG9ydW46IHRydWV9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc25pcHBldHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdjb2RlW2RhdGEtc3JjXScpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNuaXBwZXRzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgc25pcHBldDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHNuaXBwZXQgPSBhcnlbaV07XG5cdFx0XHRcdHZhciBzcmMgPSBzbmlwcGV0LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoaW5nIHNuaXBwZXQgZm9yICcsc3JjXG5cdFx0XHRcdERFUFNbc3JjXSA9IHtodG1sOiBzbmlwcGV0LmlubmVySFRNTH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5hd2FrZW4uYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYXYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCB0Mjtcblx0XHRcdHJldHVybiAodDAgPSB0aGlzLl9ib2R5PXRoaXMuX2JvZHkgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdib2R5Jyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kZGl2KCkuc2V0SWQoJ2hlcm8nKS5mbGFnKCdkYXJrJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0aGlzLl9wYXR0ZXJuID0gdGhpcy5fcGF0dGVybiB8fCB0YWckLiRwYXR0ZXJuKCkuc2V0UmVmKCdwYXR0ZXJuJyx0aGlzKS5mbGFnKCdhd2FrZW4nKSkuZW5kKCksXG5cdFx0XHRcdFx0KHQxLiQkYiA9IHQxLiQkYiB8fCB0YWckLiRleGFtcGxlKCkuZmxhZygnaGVybycpLmZsYWcoJ2RhcmsnKS5zZXRTcmMoJy9ob21lL2V4YW1wbGVzL2hlcm8uaW1iYScpKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpLFxuXHRcdFx0XHRcblx0XHRcdFx0KHQyID0gdGhpcy5fY29udGVudD10aGlzLl9jb250ZW50IHx8IHRhZyQuJGRpdigpLnNldFJlZignY29udGVudCcsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0Mi4kJGEgPSB0Mi4kJGEgfHwgdGFnJC4kbWFya2VkKCkuZmxhZygnc2VjdGlvbicpLmZsYWcoJ21kJykuZmxhZygnd2VsY29tZScpLmZsYWcoJ2h1Z2UnKS5mbGFnKCdsaWdodCcpKS5zZXRUZXh0KFwiIyBSdWJ5LCBQeXRob24gYW5kIFJlYWN0IGdvdCB0b2dldGhlci4gTmluZSBtb250aHMgbGF0ZXIsIEltYmEgd2FzIGJvcm4uXFxuXFxuSW1iYSBpcyBhIG5ldyBwcm9ncmFtbWluZyBsYW5ndWFnZSBmb3IgdGhlIHdlYiB0aGF0IGNvbXBpbGVzIHRvIGhpZ2hseSBcXG5wZXJmb3JtYW50IGFuZCByZWFkYWJsZSBKYXZhU2NyaXB0LiBJdCBoYXMgbGFuZ3VhZ2UgbGV2ZWwgc3VwcG9ydCBmb3IgZGVmaW5pbmcsIFxcbmV4dGVuZGluZywgc3ViY2xhc3NpbmcsIGluc3RhbnRpYXRpbmcgYW5kIHJlbmRlcmluZyBkb20gbm9kZXMuIEZvciBhIHNlbWktY29tcGxleCBcXG5hcHBsaWNhdGlvbiBsaWtlIFRvZG9NVkMsIGl0IGlzIG1vcmUgdGhhbiBcXG5bMTAgdGltZXMgZmFzdGVyIHRoYW4gUmVhY3RdKGh0dHA6Ly9zb21lYmVlLmdpdGh1Yi5pby90b2RvbXZjLXJlbmRlci1iZW5jaG1hcmsvaW5kZXguaHRtbCkgXFxud2l0aCBsZXNzIGNvZGUsIGFuZCBhIG11Y2ggc21hbGxlciBsaWJyYXJ5Llxcblxcbi0tLVxcblxcbi0gIyMgSW1iYS5pbnNwaXJhdGlvblxcbiAgSW1iYSBicmluZ3MgdGhlIGJlc3QgZnJvbSBSdWJ5LCBQeXRob24sIGFuZCBSZWFjdCAoKyBKU1gpIHRvZ2V0aGVyIGluIGEgY2xlYW4gbGFuZ3VhZ2UgYW5kIHJ1bnRpbWUuXFxuXFxuLSAjIyBJbWJhLmludGVyb3BlcmFiaWxpdHlcXG4gIEltYmEgY29tcGlsZXMgZG93biB0byBjbGVhbiBhbmQgcmVhZGFibGUgSmF2YVNjcmlwdC4gVXNlIGFueSBKUyBsaWJyYXJ5IGluIEltYmEgYW5kIHZpY2EtdmVyc2EuXFxuXFxuLSAjIyBJbWJhLnBlcmZvcm1hbmNlXFxuICBCdWlsZCB5b3VyIGFwcGxpY2F0aW9uIHZpZXdzIHVzaW5nIEltYmEncyBuYXRpdmUgdGFncyBmb3IgdW5wcmVjZWRlbnRlZCBwZXJmb3JtYW5jZS5cXG5cIikuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkYiA9IHQyLiQkYiB8fCB0YWckLiRleGFtcGxlKCkuZmxhZygnZGFyaycpLnNldEhlYWRpbmcoXCJTaW1wbGUgcmVtaW5kZXJzXCIpLnNldFNyYygnL2hvbWUvZXhhbXBsZXMvcmVtaW5kZXJzLmltYmEnKSkuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkYyA9IHQyLiQkYyB8fCB0YWckLiRtYXJrZWQoKS5mbGFnKCdzZWN0aW9uJykuZmxhZygnbWQnKSkuc2V0VGV4dChcIiMjIFJldXNhYmxlIGNvbXBvbmVudHNcXG5cXG5BIGN1c3RvbSB0YWcgLyBjb21wb25lbnQgY2FuIG1haW50YWluIGludGVybmFsIHN0YXRlIGFuZCBjb250cm9sIGhvdyB0byByZW5kZXIgaXRzZWxmLlxcbldpdGggdGhlIHBlcmZvcm1hbmNlIG9mIERPTSByZWNvbmNpbGlhdGlvbiBpbiBJbWJhLCB5b3UgY2FuIHVzZSBvbmUtd2F5IGRlY2xhcmF0aXZlIGJpbmRpbmcsXFxuZXZlbiBmb3IgYW5pbWF0aW9ucy4gV3JpdGUgYWxsIHlvdXIgdmlld3MgaW4gYSBzdHJhaWdodC1mb3J3YXJkIGxpbmVhciBmYXNoaW9uIGFzIGlmIHlvdSBjb3VsZFxcbnJlcmVuZGVyIHlvdXIgd2hvbGUgYXBwbGljYXRpb24gb24gKipldmVyeSBzaW5nbGUqKiBkYXRhL3N0YXRlIGNoYW5nZS5cIikuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkZCA9IHQyLiQkZCB8fCB0YWckLiRleGFtcGxlKCkuZmxhZygnZGFyaycpLnNldEhlYWRpbmcoXCJXb3JsZCBjbG9ja1wiKS5zZXRTcmMoJy9ob21lL2V4YW1wbGVzL2Nsb2NrLmltYmEnKSkuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkZSA9IHQyLiQkZSB8fCB0YWckLiRtYXJrZWQoKS5mbGFnKCdzZWN0aW9uJykuZmxhZygnbWQnKSkuc2V0VGV4dChcIiMjIEV4dGVuZCBuYXRpdmUgdGFnc1xcblxcbkluIGFkZGl0aW9uIHRvIGRlZmluaW5nIGN1c3RvbSB0YWdzLCB5b3UgY2FuIGFsc28gZXh0ZW5kIG5hdGl2ZSB0YWdzLCBvciBpbmhlcml0IGZyb20gdGhlbS5cXG5CaW5kaW5nIHRvIGRvbSBldmVudHMgaXMgYXMgc2ltcGxlIGFzIGRlZmluaW5nIG1ldGhvZHMgb24geW91ciB0YWdzOyBhbGwgZXZlbnRzIHdpbGwgYmVcXG5lZmZpY2llbnRseSBkZWxlZ2F0ZWQgYW5kIGhhbmRsZWQgYnkgSW1iYS4gTGV0J3MgZGVmaW5lIGEgc2ltcGxlIHNrZXRjaHBhZC4uLlwiKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDIuJCRmID0gdDIuJCRmIHx8IHRhZyQuJGV4YW1wbGUoKS5mbGFnKCdkYXJrJykuc2V0SGVhZGluZyhcIkN1c3RvbSBjYW52YXNcIikuc2V0U3JjKCcvaG9tZS9leGFtcGxlcy9jYW52YXMuaW1iYScpKS5lbmQoKVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gPGZvb3Rlcj5cblx0XHRcdFx0Ly8gXHQ8bmF2PlxuXHRcdFx0XHQvLyBcdFx0PGEuYnV0dG9uLmh1Z2UubWFpbiBocmVmPScvaW5zdGFsbCc+IFwiSW5zdGFsbFwiXG5cdFx0XHRcdC8vIFx0XHQ8YS5idXR0b24uaHVnZSBocmVmPScvZ3VpZGVzJz4gXCJMZWFybiBtb3JlXCJcblx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XSwyKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGRlZiBhd2FrZW5cblx0XHQvLyBcdCMgYXdha2VuIHRoZSBzbmlwcGV0c1xuXHRcdC8vIFx0c2NoZWR1bGVcblx0XHQvLyBcdGZvciBlbCBpbiAlKHNuaXBwZXQpXG5cdFx0Ly8gXHRcdGVsXG5cdFx0Ly8gXHRzZWxmXG5cdFx0XG5cdFx0Ly8gZGVmIHRpY2tcblx0XHQvLyBcdGxvZyAnaG9tZS50aWNrJ1xuXHRcdC8vIFx0c2VsZlxuXHRcdFxuXHRcdC8vIGRlZiBhc3NlbWJsZVxuXHRcdC8vIFx0cmV0dXJuIHNlbGYgaWYgSW1iYS5pc0NsaWVudFxuXHRcdC8vIFx0c3VwZXJcblx0XHQvLyBcdCMgZmxhZygnc2NvcGVkJyxyb3V0ZXIuc2NvcGVkKHJvdXRlLHNlbGYpKVxuXHRcdC8vIFx0IyBmbGFnKCdzZWxlY3RlZCcscm91dGVyLm1hdGNoKHJvdXRlLHNlbGYpKVxuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvaG9tZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRyZXF1aXJlKCcuL3BhZ2UnKTtcblx0XG5cdHZhciBEb2MgPSByZXF1aXJlKCcuLi9hcHAnKS5Eb2M7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2Jsb2cnLCAncGFnZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBucjtcblx0XHRcdGlmIChuciA9IHRoaXMucm91dGVyKCkuc2NvcGVkKC9ibG9nXFwvKFxcZCspLywxKSkge1xuXHRcdFx0XHRyZXR1cm4gRG9jLmdldCgnL2lzc3Vlcy8nICsgbnIgKyAnLmpzb24nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBEb2MuZ2V0KCcvaXNzdWVzLycgKyB0aGlzLnBvc3RzKClbMF0ubnVtYmVyICsgJy5qc29uJyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wb3N0cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEFQUC5pc3N1ZXMoKS5vYmplY3QoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmF2ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHNlbGYgPSB0aGlzLCB0MTtcblx0XHRcdHJldHVybiAodDAgPSBzZWxmLl9uYXY9c2VsZi5fbmF2IHx8IHRhZyQuJG5hdm1lbnUoKS5zZXRSZWYoJ25hdicsdGhpcykpLnNldENvbnRlbnQoXG5cdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdChmdW5jdGlvbih0MSkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYucG9zdHMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQxWyckJGEnICsgaV0gPSB0MVsnJCRhJyArIGldIHx8IHRhZyQuJGlzc3VlX2VudHJ5KCkuZmxhZygnZW50cnknKSkuZmxhZygnZW50cnknKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHR9KSh0MSlcblx0XHRcdFx0LDMpLmVuZCgpXG5cdFx0XHQsMikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiAodDAgPSB0aGlzLl9ib2R5PXRoaXMuX2JvZHkgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdib2R5Jyx0aGlzKS5mbGFnKCdsaWdodCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0KHRoaXMuZG9jKCkpID8gKFxuXHRcdFx0XHRcdCh0MC4kJGEgPSB0MC4kJGEgfHwgdGFnJC4kaXNzdWUoKSkuc2V0T2JqZWN0KHRoaXMuZG9jKCkpLmVuZCgpXG5cdFx0XHRcdCkgOiB2b2lkKDApXG5cdFx0XHRdLDEpLmVuZCgpO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9ibG9nLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHJlcXVpcmUoJy4vcGFnZScpO1xuXHRcblx0ZnVuY3Rpb24gR3VpZGUocGF0aCl7XG5cdFx0dGhpcy5fcGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5fcmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLmZldGNoKCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHZhciBjYWNoZSA9IHt9O1xuXHRcblx0R3VpZGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpe1xuXHRcdHZhciAkMTtcblx0XHR2YXIgY2FjaGUgPSBBUFAuY2FjaGUoKTtcblx0XHRyZXR1cm4gY2FjaGVbKCQxID0gJ2d1aWRlLScgKyBwYXRoKV0gfHwgKGNhY2hlWyQxXSA9IG5ldyB0aGlzKHBhdGgpKTtcblx0fTtcblx0XG5cdFxuXHRcblx0R3VpZGUucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BhdGg7IH1cblx0R3VpZGUucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbih2KXsgdGhpcy5fcGF0aCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3JlYWR5O1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmIChJbWJhLlNFUlZFUikge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoIEd1aWRlIG9uIHNlcnZlcicscGF0aFxuXHRcdFx0cmV0dXJuIEFQUC5mZXRjaERvY3VtZW50KHNlbGYuX3BhdGggKyAnLm1kJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoIEd1aWRlIG9uIHNlcnZlciBkb25lJyxwYXRoXG5cdFx0XHRcdHJldHVybiBzZWxmLmxvYWQocmVzKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuX3Byb21pc2UgfHwgKHNlbGYuX3Byb21pc2UgPSBBUFAuZmV0Y2hEb2N1bWVudChzZWxmLl9wYXRoICsgJy5tZCcsZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5sb2FkKHJlcyk7XG5cdFx0fSkpO1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoZG9jKXtcblx0XHR0aGlzLl9vYmplY3QgPSBkb2M7XG5cdFx0dGhpcy5fbWV0YSA9IGRvYy5tZXRhIHx8IHt9O1xuXHRcdHRoaXMuX3JlYWR5ID0gdHJ1ZTtcblx0XHRJbWJhLmVtaXQodGhpcywncmVhZHknKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEd1aWRlLnByb3RvdHlwZS50aXRsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9vYmplY3QudGl0bGUgfHwgJ3BhdGgnO1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLnRvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9vYmplY3QgJiYgdGhpcy5fb2JqZWN0LnRvY1swXTtcblx0fTtcblx0XG5cdEd1aWRlLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX29iamVjdCAmJiB0aGlzLl9vYmplY3QuYm9keTtcblx0fTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZ3VpZGUtdG9jJywgJ3RvYycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RvYzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VG9jID0gZnVuY3Rpb24odil7IHRoaXMuX3RvYyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG9jIHx8IHRoaXMub2JqZWN0KCkudG9jKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKFwiXCIgKyAodGhpcy5vYmplY3QoKS5wYXRoKCkpICsgXCIjXCIgKyAodGhpcy50b2MoKS5zbHVnKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudG9nZ2xlRmxhZygnY29sbGFwc2VkJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCB0MSwgc2VsZiA9IHRoaXMsIHQyLCB0Mztcblx0XHRcdGlmICghdGhpcy5vYmplY3QoKS5yZWFkeSgpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcblx0XHRcdHRoaXMucmVyb3V0ZSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdlbnRyeScpLnNldExldmVsKCh0aGlzLnRvYygpLmxldmVsKSkuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHR0aGlzLnRvYygpLmNoaWxkcmVuLmxlbmd0aCAmJiB0aGlzLnRvYygpLmxldmVsIDwgMiA/IChJbWJhLnN0YXRpYyhbXG5cdFx0XHRcdFx0KHQwID0gdGhpcy4kYT10aGlzLiRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpLnNldEhhbmRsZXIoJ3RhcCcsJ3RvZ2dsZScsdGhpcykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGEoKSkuc2V0SHJlZih0aGlzLnJvdXRlKCkpLnNldENvbnRlbnQodGhpcy50b2MoKS50aXRsZSwzKS5lbmQoKVxuXHRcdFx0XHRcdCwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDIgPSBzZWxmLiRiPXNlbGYuJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdFx0KGZ1bmN0aW9uKHQyKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLnRvYygpLmNoaWxkcmVuKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHJlcy5wdXNoKCh0MlsnJCRhJyArIGldID0gdDJbJyQkYScgKyBpXSB8fCB0YWckLiRndWlkZV90b2MoKSkuc2V0VG9jKGFyeVtpXSkuc2V0T2JqZWN0KHNlbGYub2JqZWN0KCkpLmVuZCgpKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHRcdH0pKHQyKVxuXHRcdFx0XHRcdCwzKS5lbmQoKVxuXHRcdFx0XHRdLDIpKSA6IChcblx0XHRcdFx0XHQodDMgPSBzZWxmLiRjPXNlbGYuJGMgfHwgdGFnJC4kYSgpKS5zZXRIcmVmKHNlbGYucm91dGUoKSkuc2V0Q29udGVudChzZWxmLnRvYygpLnRpdGxlLDMpLmVuZCgpXG5cdFx0XHRcdClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2d1aWRlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIG9iamVjdF87XG5cdFx0XHRpZiAoIShvYmplY3RfID0gdGhpcy5vYmplY3QoKSkgJiYgb2JqZWN0Xy5yZWFkeSAgJiYgIG9iamVjdF8ucmVhZHkoKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnbWQnKS5zZXRCb2R5KCh0aGlzLm9iamVjdCgpLmJvZHkoKSkpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpe1xuXHRcdFx0aWYgKGJvZHkgIT0gdGhpcy5fYm9keSkge1xuXHRcdFx0XHR0aGlzLl9ib2R5ID0gYm9keTtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSBib2R5O1xuXHRcdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpKSB0aGlzLnJlYXdha2VuKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocSQoJy5fc25pcHBldCcsdGhpcykpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnZ3VpZGVzJywgJ3BhZ2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmF2ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX25hdj10aGlzLl9uYXYgfHwgdGFnJC4kbmF2bWVudSgpLnNldFJlZignbmF2Jyx0aGlzKSkuc2V0Q29udGVudChcblx0XHRcdFx0KHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0MS4kJGEgPSB0MS4kJGEgfHwgdGFnJC4kZ3VpZGVfdG9jKCkpLnNldE9iamVjdChHdWlkZS5nZXQoJy9ndWlkZXMnKSkuZW5kKCksXG5cdFx0XHRcdFx0KHQxLiQkYiA9IHQxLiQkYiB8fCB0YWckLiRndWlkZV90b2MoKSkuc2V0T2JqZWN0KEd1aWRlLmdldCgnL2d1aWRlcy9sYW5ndWFnZScpKS5lbmQoKVxuXHRcdFx0XHQvLyA8Z3VpZGUtdG9jW0d1aWRlLmdldCgnL2d1aWRlcy9yZW5kZXJpbmcnKV0+XG5cdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdCwyKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX2JvZHk9dGhpcy5fYm9keSB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2JvZHknLHRoaXMpLmZsYWcoJ2xpZ2h0JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodGhpcy5ndWlkZSgpKSA/ICgodDAuJCRhID0gdDAuJCRhIHx8IHRhZyQuJGd1aWRlKCkpLnNldE9iamVjdCh0aGlzLmd1aWRlKCkpLmVuZCgpKSA6IHZvaWQoMClcblx0XHRcdF0sMSkuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ucm91dGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdFxuXHRcdFx0dmFyIHNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWw7XG5cdFx0XHRcdGlmIChlbCA9IHNlbGYuZmlyc3QoJyMnICsgc2VsZi5yb3V0ZXIoKS5oYXNoKCkpKSB7XG5cdFx0XHRcdFx0ZWwuZG9tKCkuc2Nyb2xsSW50b1ZpZXcodHJ1ZSk7XG5cdFx0XHRcdFx0c2VsZi5fc2Nyb2xsRnJlZXplID0gd2luZG93LnNjcm9sbFk7XG5cdFx0XHRcdFx0cmV0dXJuIGVsO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoc2VsZi5yb3V0ZXIoKS5oYXNoKCkpIHtcblx0XHRcdFx0c2VsZi5yZW5kZXIoKTtcblx0XHRcdFx0c2Nyb2xsKCkgfHwgc2V0VGltZW91dChzY3JvbGwsMjAsZnVuY3Rpb24oKSB7ICB9KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ndWlkZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKHRoaXMucm91dGVyKCkuc2NvcGVkKCcvZ3VpZGVzJykpIHtcblx0XHRcdFx0cmV0dXJuIEd1aWRlLmdldCh0aGlzLnJvdXRlcigpLnBhdGgoKSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmIChJbWJhLmlzQ2xpZW50KCkpIHtcblx0XHRcdFx0Ly8gQGRvYyA9ICUlKGd1aWRlKVxuXHRcdFx0XHRzZWxmLnNjaGVkdWxlKHtmcHM6IDF9KTtcblx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2NoZWNrIHNjcm9sbGluZydcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5zY3JvbGxlZCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2Nyb2xsZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICghdGhpcy5oYXNGbGFnKCdzY29wZWQnKSkgeyByZXR1cm4gfTtcblx0XHRcdFxuXHRcdFx0dmFyIGl0ZW1zID0gcSQoJ1tpZF0nLHRoaXMpO1xuXHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XG5cdFx0XHQvLyBzaG91bGQgcHJvYmFibHkgY2FjaGUgdGhlc2UgcGVyaW9kaWNhbGx5XG5cdFx0XHR2YXIgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFk7XG5cdFx0XHR2YXIgd2ggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdFx0XHR2YXIgZGggPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX3Njcm9sbEZyZWV6ZSA+PSAwKSB7XG5cdFx0XHRcdHZhciBkaWZmID0gTWF0aC5hYnMoc2Nyb2xsVG9wIC0gdGhpcy5fc2Nyb2xsRnJlZXplKTtcblx0XHRcdFx0aWYgKGRpZmYgPCA1MCkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XHR0aGlzLl9zY3JvbGxGcmVlemUgPSAtMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBzY3JvbGxCb3R0b20gPSBkaCAtIChzY3JvbGxUb3AgKyB3aCk7XG5cdFx0XHRcblx0XHRcdC8vIGNvbnNvbGUubG9nIHNjcm9sbFRvcCx3aCxkaCxzY3JvbGxCb3R0b21cblx0XHRcdFxuXHRcdFx0aWYgKHNjcm9sbEJvdHRvbSA9PSAwKSB7XG5cdFx0XHRcdG1hdGNoID0gaXRlbXMubGFzdCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGl0ZW1zKSwgbGVuID0gYXJ5Lmxlbmd0aCwgaXRlbTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0aXRlbSA9IGFyeVtpXTtcblx0XHRcdFx0XHR2YXIgdCA9IChpdGVtLmRvbSgpLm9mZnNldFRvcCArIDMwICsgNjApOyAvLyBoYWNrXG5cdFx0XHRcdFx0dmFyIGRpc3QgPSBzY3JvbGxUb3AgLSB0O1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwie2l0ZW0uaWR9IHt0fSB7ZGlzdH1cIlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChkaXN0IDwgMCkge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBpdGVtO2JyZWFrO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJtYXRjaCBpcyB7bWF0Y2guaWR9XCJcblx0XHRcdFx0aWYgKHRoaXMuX2hhc2ggIT0gbWF0Y2guaWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuX2hhc2ggPSBtYXRjaC5pZCgpO1xuXHRcdFx0XHRcdHRoaXMucm91dGVyKCkuZ28oJyMnICsgdGhpcy5faGFzaCx7fSx0cnVlKTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2d1aWRlcy5pbWJhXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRmdW5jdGlvbiBwYXRoVG9BbmNob3IocGF0aCl7XG5cdFx0cmV0dXJuICdhcGktJyArIHBhdGgucmVwbGFjZSgvXFwuL2csJ18nKS5yZXBsYWNlKC9cXCMvZywnX18nKTtcblx0fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktZGVzYycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIdG1sID0gZnVuY3Rpb24gKGh0bWwpe1xuXHRcdFx0aWYgKGh0bWwgIT0gdGhpcy5faHRtbCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IHRoaXMuX2h0bWwgPSBodG1sO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1yZWYnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktaXRlbScpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1wYXRoJywgJ3NwYW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBvYmplY3RfO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHRpZiAoKHR5cGVvZiAob2JqZWN0XyA9IHRoaXMub2JqZWN0KCkpPT0nc3RyaW5nJ3x8b2JqZWN0XyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0dGhpcy5zZXRIdG1sKHRoaXMub2JqZWN0KCkucmVwbGFjZSgvXFxiKFtcXHddK3xcXC58XFwjKVxcYi9nLGZ1bmN0aW9uKG0saSkge1xuXHRcdFx0XHRcdGlmIChpID09ICcuJyB8fCBpID09ICcjJykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIChcIjxpPlwiICsgaSArIFwiPC9pPlwiKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlbMF0gPT0gaVswXS50b1VwcGVyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFwiPGIgY2xhc3M9J2NvbnN0Jz5cIiArIGkgKyBcIjwvYj5cIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiAoXCI8YiBjbGFzcz0naWQnPlwiICsgaSArIFwiPC9iPlwiKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1saW5rJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodGhpcy4kYSA9IHRoaXMuJGEgfHwgdGFnJC4kYXBpX3BhdGgoKS5mbGFnKCd2YWx1ZScpKS5zZXRPYmplY3QodGhpcy5vYmplY3QoKS52YWx1ZSkuZW5kKCksXG5cdFx0XHRcdCh0MCA9IHRoaXMuJGI9dGhpcy4kYiB8fCB0YWckLiRzcGFuKCkuZmxhZygnZGVzYycpKS5zZXRDb250ZW50KHRoaXMub2JqZWN0KCkuZGVzYywzKS5lbmQoKVxuXHRcdFx0XSwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktcmV0dXJuJywgJ2FwaS1saW5rJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLWNsYXNzJywgJ2FwaS1pdGVtJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fb2JqZWN0ID0ge3dhdGNoOiAncGFyc2UnLG5hbWU6ICdvYmplY3QnfTtcblx0XHR0YWcucHJvdG90eXBlLm9iamVjdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb2JqZWN0OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRPYmplY3QgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5vYmplY3QoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9vYmplY3QgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5wYXJzZSAmJiB0aGlzLnBhcnNlKHYsYSx0aGlzLl9fb2JqZWN0KSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLm9iamVjdCgpWycuJ10pLCBsZW4gPSBhcnkubGVuZ3RoLCBtLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdG0gPSBhcnlbaV07XG5cdFx0XHRcdGlmICghbS5kZXNjKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRyZXMucHVzaChtKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLl9zdGF0aWNzID0gcmVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMub2JqZWN0KClbJyMnXSksIGxlbiA9IGFyeS5sZW5ndGgsIG0xLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdG0xID0gYXJ5W2ldO1xuXHRcdFx0XHRpZiAoIW0xLmRlc2MpIHsgY29udGludWU7IH07XG5cdFx0XHRcdHJlcy5wdXNoKG0xKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLl9tZXRob2RzID0gcmVzO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IFtdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgc2VsZiA9IHRoaXMsIHQ1LCB0NiwgdDc7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdCh0aGlzLiRhID0gdGhpcy4kYSB8fCB0YWckLiRzcGFuKCkuZmxhZygndG9jLWFuY2hvcicpKS5zZXRJZChwYXRoVG9BbmNob3IodGhpcy5vYmplY3QoKS5uYW1lcGF0aCkpLmVuZCgpLFxuXHRcdFx0XHQodDAgPSB0aGlzLiRiPXRoaXMuJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykpLnNldENvbnRlbnQoKHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCd0aXRsZScpKS5zZXRDb250ZW50KCh0MS4kJGEgPSB0MS4kJGEgfHwgdGFnJC4kYXBpX3BhdGgoKSkuc2V0T2JqZWN0KHRoaXMub2JqZWN0KCkubmFtZXBhdGgpLmVuZCgpLDIpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy4kYyA9IHRoaXMuJGMgfHwgdGFnJC4kYXBpX2Rlc2MoKSkuc2V0SHRtbCh0aGlzLm9iamVjdCgpLmh0bWwpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy5vYmplY3QoKS5jdG9yKSA/IChcblx0XHRcdFx0XHQodDIgPSB0aGlzLiRkPXRoaXMuJGQgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpLmZsYWcoJ2N0b3InKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdCh0Mi4kJGEgPSB0Mi4kJGEgfHwgdGFnJC4kYXBpX21ldGhvZCgpKS5zZXRQYXRoKCh0aGlzLm9iamVjdCgpLm5hbWVwYXRoICsgJy5uZXcnKSkuc2V0T2JqZWN0KHRoaXMub2JqZWN0KCkuY3RvcikuZW5kKClcblx0XHRcdFx0XHQsMikuZW5kKClcblx0XHRcdFx0KSA6IHZvaWQoMCksXG5cdFx0XHRcdFxuXHRcdFx0XHQodDMgPSBzZWxmLiRlPXNlbGYuJGUgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodGhpcy5fc3RhdGljcy5sZW5ndGggPiAwKSA/IChcblx0XHRcdFx0XHRcdCh0NCA9IHQzLiQkYT10My4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnc2VjdGlvbicpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0KHQ0LiQkYSA9IHQ0LiQkYSB8fCB0YWckLiRoMigpLmZsYWcoJ2hlYWRlcicpKS5zZXRUZXh0KCdTdGF0aWMgTWV0aG9kcycpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDUgPSB0NC4kJGI9dDQuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKS5mbGFnKCdsaXN0JykpLnNldENvbnRlbnQoKGZ1bmN0aW9uKHQ1KSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuX3N0YXRpY3MpLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDVbJyQkYScgKyBpXSA9IHQ1WyckJGEnICsgaV0gfHwgdGFnJC4kYXBpX21ldGhvZCgpLmZsYWcoJ2RvYycpKS5zZXRJbmFtZShzZWxmLm9iamVjdCgpLm5hbWVwYXRoKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdFx0XHR9KSh0NSksMykuZW5kKClcblx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHQpIDogdm9pZCgwKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQoc2VsZi5fbWV0aG9kcy5sZW5ndGggPiAwKSA/IChcblx0XHRcdFx0XHRcdCh0NiA9IHQzLiQkYj10My4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnc2VjdGlvbicpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0KHQ2LiQkYSA9IHQ2LiQkYSB8fCB0YWckLiRoMigpLmZsYWcoJ2hlYWRlcicpKS5zZXRUZXh0KCdJbnN0YW5jZSBNZXRob2RzJykuZW5kKCksXG5cdFx0XHRcdFx0XHRcdCh0NyA9IHQ2LiQkYj10Ni4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpLmZsYWcoJ2xpc3QnKSkuc2V0Q29udGVudCgoZnVuY3Rpb24odDcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5fbWV0aG9kcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlcy5wdXNoKCh0N1snJCRhJyArIGldID0gdDdbJyQkYScgKyBpXSB8fCB0YWckLiRhcGlfbWV0aG9kKCkuZmxhZygnZG9jJykpLnNldEluYW1lKHNlbGYub2JqZWN0KCkuaW5hbWUpLnNldE9iamVjdChhcnlbaV0pLmVuZCgpKTtcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0XHRcdH0pKHQ3KSwzKS5lbmQoKVxuXHRcdFx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XHRcdCkgOiB2b2lkKDApXG5cdFx0XHRcdF0sMSkuZW5kKClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLXZhbHVlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIG9iamVjdF8sICQxO1xuXHRcdFx0aWYgKHRoaXMub2JqZWN0KCkudHlwZSkge1xuXHRcdFx0XHR0aGlzLmZsYWcodGhpcy5vYmplY3QoKS50eXBlKS5zZXRDaGlsZHJlbihcblx0XHRcdFx0XHR0aGlzLm9iamVjdCgpLnZhbHVlXG5cdFx0XHRcdCwzKS5zeW5jZWQoKTtcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiAob2JqZWN0XyA9IHRoaXMub2JqZWN0KCkpPT0nc3RyaW5nJ3x8b2JqZWN0XyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0dGhpcy5mbGFnKCdzdHInKS5zZXRUZXh0KHRoaXMub2JqZWN0KCkpLnN5bmNlZCgpO1xuXHRcdFx0fSBlbHNlIGlmICgodHlwZW9mICgkMSA9IHRoaXMub2JqZWN0KCkpPT0nbnVtYmVyJ3x8JDEgaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG5cdFx0XHRcdHRoaXMuZmxhZygnbnVtJykuc2V0VGV4dCh0aGlzLm9iamVjdCgpKS5zeW5jZWQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLXBhcmFtJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9iamVjdCgpLnR5cGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCB0MCwgdDE7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKHNlbGYudHlwZSgpKS5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHNlbGYudHlwZSgpID09ICdOYW1lZFBhcmFtcycgPyAoXG5cdFx0XHRcdFx0KGZ1bmN0aW9uKHNlbGYpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLm9iamVjdCgpLm5vZGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgoc2VsZlsnJGEnICsgaV0gPSBzZWxmWyckYScgKyBpXSB8fCB0YWckLiRhcGlfcGFyYW0oKSkuc2V0T2JqZWN0KGFyeVtpXSkuZW5kKCkpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fSkoc2VsZilcblx0XHRcdFx0KSA6IChJbWJhLnN0YXRpYyhbXG5cdFx0XHRcdFx0KHQwID0gc2VsZi4kYj1zZWxmLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ25hbWUnKSkuc2V0Q29udGVudChzZWxmLm9iamVjdCgpLm5hbWUsMykuZW5kKCksXG5cdFx0XHRcdFx0KHNlbGYub2JqZWN0KCkuZGVmYXVsdHMpID8gKEltYmEuc3RhdGljKFtcblx0XHRcdFx0XHRcdCh0MSA9IHNlbGYuJGM9c2VsZi4kYyB8fCB0YWckLiRpKCkpLnNldENvbnRlbnQoW3NlbGYudHlwZSgpID09ICdOYW1lZFBhcmFtJyA/ICgnOiAnKSA6ICgnID0gJyldLDEpLmVuZCgpLFxuXHRcdFx0XHRcdFx0KHNlbGYuJGQgPSBzZWxmLiRkIHx8IHRhZyQuJGFwaV92YWx1ZSgpKS5zZXRPYmplY3Qoc2VsZi5vYmplY3QoKS5kZWZhdWx0cykuZW5kKClcblx0XHRcdFx0XHRdLDIpKSA6IHZvaWQoMClcblx0XHRcdFx0XSwzKSlcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLW1ldGhvZCcsICdhcGktaXRlbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faW5hbWU7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEluYW1lID0gZnVuY3Rpb24odil7IHRoaXMuX2luYW1lID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXRoOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24odil7IHRoaXMuX3BhdGggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRhZ3MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiAodDAgPSB0aGlzLl90YWdzPXRoaXMuX3RhZ3MgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCd0YWdzJyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdCh0aGlzLm9iamVjdCgpLmRlcHJlY2F0ZWQpID8gKFxuXHRcdFx0XHRcdCh0MC4kJGEgPSB0MC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnZGVwcmVjYXRlZCcpLmZsYWcoJ3JlZCcpKS5zZXRUZXh0KCdNZXRob2QgaXMgZGVwcmVjYXRlZCcpLmVuZCgpXG5cdFx0XHRcdCkgOiB2b2lkKDApLFxuXHRcdFx0XHQodGhpcy5vYmplY3QoKS5yZXR1cm4pID8gKCh0MC4kJGIgPSB0MC4kJGIgfHwgdGFnJC4kYXBpX3JldHVybigpLnNldE5hbWUoJ3JldHVybnMnKSkuc2V0T2JqZWN0KHRoaXMub2JqZWN0KCkucmV0dXJuKS5lbmQoKSkgOiB2b2lkKDApXG5cdFx0XHRdLDEpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCAodGhpcy5pbmFtZSgpICsgJy4nICsgdGhpcy5vYmplY3QoKS5uYW1lKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2x1ZyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHBhdGhUb0FuY2hvcih0aGlzLm9iamVjdCgpLm5hbWVwYXRoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHNlbGYgPSB0aGlzLCB0MTtcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ2RlcHJlY2F0ZWQnLHRoaXMub2JqZWN0KCkuZGVwcmVjYXRlZCkuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodGhpcy4kYSA9IHRoaXMuJGEgfHwgdGFnJC4kc3BhbigpLmZsYWcoJ3RvYy1hbmNob3InKSkuc2V0SWQodGhpcy5zbHVnKCkpLmVuZCgpLFxuXHRcdFx0XHQodDAgPSBzZWxmLiRiPXNlbGYuJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0MC4kJGEgPSB0MC4kJGEgfHwgdGFnJC4kYXBpX3BhdGgoKSkuc2V0T2JqZWN0KHRoaXMucGF0aCgpKS5lbmQoKSxcblx0XHRcdFx0XHQodDEgPSB0MC4kJGI9dDAuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3BhcmFtcycpKS5zZXRDb250ZW50KChmdW5jdGlvbih0MSkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYub2JqZWN0KCkucGFyYW1zKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDFbJyQkYScgKyBpXSA9IHQxWyckJGEnICsgaV0gfHwgdGFnJC4kYXBpX3BhcmFtKCkpLnNldE9iamVjdChhcnlbaV0pLmVuZCgpKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdH0pKHQxKSwzKS5lbmQoKSxcblx0XHRcdFx0XHQodDAuJCRjID0gdDAuJCRjIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2dyb3cnKSkuZW5kKClcblx0XHRcdFx0XSwyKS5lbmQoKSxcblx0XHRcdFx0KHNlbGYuJGMgPSBzZWxmLiRjIHx8IHRhZyQuJGFwaV9kZXNjKCkuZmxhZygnbWQnKSkuc2V0SHRtbChzZWxmLm9iamVjdCgpLmh0bWwpLmVuZCgpLFxuXHRcdFx0XHRzZWxmLnRhZ3MoKVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdkb2MtbGluaycsICdhJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5zZXRIcmVmKChcIi9kb2NzI1wiICsgcGF0aFRvQW5jaG9yKHRoaXMub2JqZWN0KCkubmFtZXBhdGgpKSkuc2V0Q2hpbGRyZW4oKHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJGFwaV9wYXRoKCkpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLm5hbWVwYXRoKS5lbmQoKSwyKS5zeW5jZWQoKTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLnJlbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udGFwID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0YWcuX19zdXBlcl9fLm9udGFwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiB0aGlzLnVwKHEkKCcuX2RvY3MnLHRoaXMpKS5yZWZvY3VzKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZG9jLWdyb3VwJywgJ3RvYycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRhcCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudG9nZ2xlRmxhZygnY29sbGFwc2VkJyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdkb2NzJywgJ3BhZ2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX192ZXJzaW9uID0geydkZWZhdWx0JzogJ2N1cnJlbnQnLG5hbWU6ICd2ZXJzaW9uJ307XG5cdFx0dGFnLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92ZXJzaW9uOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWZXJzaW9uID0gZnVuY3Rpb24odil7IHRoaXMuX3ZlcnNpb24gPSB2OyByZXR1cm4gdGhpczsgfVxuXHRcdHRhZy5wcm90b3R5cGUuX3ZlcnNpb24gPSAnY3VycmVudCc7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb290cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm9vdHM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvb3RzID0gZnVuY3Rpb24odil7IHRoaXMuX3Jvb3RzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAoXCIvYXBpL1wiICsgdGhpcy52ZXJzaW9uKCkgKyBcIi5qc29uXCIpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kb2NzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9jcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvYWQoKTtcblx0XHRcdHRoaXMuc2NoZWR1bGUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2FkKCk7XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5idWlsZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmIChJbWJhLlNFUlZFUikge1xuXHRcdFx0XHQvLyByZXR1cm4gc2VsZlxuXHRcdFx0XHRBUFAuZmV0Y2hEb2N1bWVudChzZWxmLnNyYygpLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdHNlbGYuX2RvY3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcykpO1xuXHRcdFx0XHRcdHJldHVybiBzZWxmLmdlbmVyYXRlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gc2VsZjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmLl9yZXF1ZXN0IHx8IChzZWxmLl9yZXF1ZXN0ID0gQVBQLmZldGNoRG9jdW1lbnQoc2VsZi5zcmMoKSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0RE9DUyA9IHNlbGYuX2RvY3MgPSByZXM7XG5cdFx0XHRcdERPQ01BUCA9IHNlbGYuX2RvY3MuZW50aXRpZXM7XG5cdFx0XHRcdHNlbGYuZ2VuZXJhdGUoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYubG9hZGVkKCk7XG5cdFx0XHR9KSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdC8vIHJlYWxseT9cblx0XHRcdGlmIChkb2N1bWVudC5sb2NhdGlvbi5oYXNoKSB7XG5cdFx0XHRcdGlmIChlbCA9IHRoaXMuZmlyc3QoZG9jdW1lbnQubG9jYXRpb24uaGFzaCkpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnc2hvdWxkIHNjcm9sbCBoZXJlPyE/IT8hJyxlbFxuXHRcdFx0XHRcdGVsLmRvbSgpLnNjcm9sbEludG9WaWV3KCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlZm9jdXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBlbDtcblx0XHRcdGlmIChlbCA9IHRoaXMuZmlyc3QoZG9jdW1lbnQubG9jYXRpb24uaGFzaCkpIHtcblx0XHRcdFx0ZWwuZG9tKCkuc2Nyb2xsSW50b1ZpZXcoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKHBhdGgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9jcygpLmVudGl0aWVzW3BhdGhdO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5fcm9vdHMgPSBbXTtcblx0XHRcdHZhciBlbnRzID0gdGhpcy5fZG9jcy5lbnRpdGllcztcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgbyA9IHRoaXMuZG9jcygpLmVudGl0aWVzLCBpdGVtLCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG8pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHRpdGVtID0gb1trZXlzW2ldXTtpZiAoaXRlbS50eXBlID09ICdjbGFzcycgfHwga2V5c1tpXSA9PSAnSW1iYScpIHtcblx0XHRcdFx0XHRpdGVtWycuJ10gPSAoaXRlbVsnLiddIHx8IFtdKS5zb3J0KCkubWFwKGZ1bmN0aW9uKHBhdGgpIHsgcmV0dXJuIGVudHNbcGF0aF07IH0pLmZpbHRlcihmdW5jdGlvbih2KSB7IHJldHVybiB2LnR5cGUgPT0gJ21ldGhvZCcgJiYgdi5kZXNjOyB9KTtcblx0XHRcdFx0XHRpdGVtWycjJ10gPSAoaXRlbVsnIyddIHx8IFtdKS5zb3J0KCkubWFwKGZ1bmN0aW9uKHBhdGgpIHsgcmV0dXJuIGVudHNbcGF0aF07IH0pLmZpbHRlcihmdW5jdGlvbih2KSB7IHJldHVybiB2LnR5cGUgPT0gJ21ldGhvZCcgJiYgdi5kZXNjOyB9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaXRlbS5kZXNjKSB7IHRoaXMuX3Jvb3RzLnB1c2goaXRlbSkgfTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAoISh0aGlzLmRvY3MoKSkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLnJlbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgdDA7XG5cdFx0XHRyZXR1cm4gKHQwID0gc2VsZi5fYm9keT1zZWxmLl9ib2R5IHx8IHRhZyQuJGRpdigpLnNldFJlZignYm9keScsdGhpcykuZmxhZygnbGlnaHQnKSkuc2V0Q29udGVudChcblx0XHRcdFx0KGZ1bmN0aW9uKHQwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYucm9vdHMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlcy5wdXNoKCh0MFsnJCRhJyArIGldID0gdDBbJyQkYScgKyBpXSB8fCB0YWckLiRhcGlfY2xhc3MoKS5mbGFnKCdkb2MnKS5mbGFnKCdsJykpLnNldE9iamVjdChhcnlbaV0pLmVuZCgpKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdH0pKHQwKVxuXHRcdFx0LDMpLmVuZCgpO1xuXHRcdH07XG5cdFx0dGFnLnByb3RvdHlwZS5uYXYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgc2VsZiA9IHRoaXMsIHQxO1xuXHRcdFx0cmV0dXJuICh0MCA9IHNlbGYuX25hdj1zZWxmLl9uYXYgfHwgdGFnJC4kbmF2bWVudSgpLnNldFJlZignbmF2Jyx0aGlzKSkuc2V0Q29udGVudChcblx0XHRcdFx0KHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0KGZ1bmN0aW9uKHQxKSB7XG5cdFx0XHRcdFx0XHR2YXIgdDIsIHQzLCB0NCwgdDUsIHQ2O1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYucm9vdHMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIHJvb3QsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cm9vdCA9IGFyeVtpXTtcblx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQyID0gdDFbJyQkYScgKyBpXT10MVsnJCRhJyArIGldIHx8IHRhZyQuJGRvY19ncm91cCgpLmZsYWcoJ2NsYXNzJykuZmxhZygnc2VjdGlvbicpLmZsYWcoJ2NvbXBhY3QnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdFx0KHQzID0gdDIuJCRhPXQyLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCdoZWFkZXInKSkuc2V0Q29udGVudCgodDMuJCRhID0gdDMuJCRhIHx8IHRhZyQuJGRvY19saW5rKCkuZmxhZygnY2xhc3MnKSkuc2V0T2JqZWN0KHJvb3QpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHRcdCh0NCA9IHQyLiQkYj10Mi4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0XHRcdCh0NSA9IHQ0LiQkYT10NC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnc3RhdGljJykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdChmdW5jdGlvbih0NSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB0Njtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMCwgaXRlbXMgPSBpdGVyJChyb290WycuJ10pLCBsZW5fID0gaXRlbXMubGVuZ3RoLCBtZXRoLCByZXMxID0gW107IGogPCBsZW5fOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1ldGggPSBpdGVtc1tqXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghbWV0aC5kZXNjKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzMS5wdXNoKCh0NiA9IHQ1WyckJGEnICsgal09dDVbJyQkYScgKyBqXSB8fCB0YWckLiRkaXYoKS5mbGFnKCdlbnRyeScpKS5zZXRDb250ZW50KCh0Ni4kJGEgPSB0Ni4kJGEgfHwgdGFnJC4kZG9jX2xpbmsoKSkuc2V0T2JqZWN0KG1ldGgpLmVuZCgpLDIpLmVuZCgpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXMxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KSh0NSlcblx0XHRcdFx0XHRcdFx0XHRcdCwzKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0XHRcdCh0NiA9IHQ0LiQkYj10NC4kJGIgfHwgdGFnJC4kZGl2KCkuZmxhZygnaW5zdGFuY2UnKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdFx0XHRcdFx0KGZ1bmN0aW9uKHQ2KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHQ3O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBpdGVtcyA9IGl0ZXIkKHJvb3RbJyMnXSksIGxlbl8gPSBpdGVtcy5sZW5ndGgsIG1ldGgsIHJlczEgPSBbXTsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWV0aCA9IGl0ZW1zW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFtZXRoLmRlc2MpIHsgY29udGludWU7IH07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXMxLnB1c2goKHQ3ID0gdDZbJyQkYScgKyBqXT10NlsnJCRhJyArIGpdIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2VudHJ5JykpLnNldENvbnRlbnQoKHQ3LiQkYSA9IHQ3LiQkYSB8fCB0YWckLiRkb2NfbGluaygpKS5zZXRPYmplY3QobWV0aCkuZW5kKCksMikuZW5kKCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlczE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pKHQ2KVxuXHRcdFx0XHRcdFx0XHRcdFx0LDMpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XHRcdFx0XHRdLDIpLmVuZCgpKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdH0pKHQxKVxuXHRcdFx0XHQsMykuZW5kKClcblx0XHRcdCwyKS5lbmQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9kb2NzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdC8vIGV4dGVybnM7XG5cdFxuXHQvLyB2YXIgaGxqcyA9IHJlcXVpcmUgJ2hpZ2hsaWdodC5qcydcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCd0b29sJywgJ2J1dHRvbicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hY3Rpb24gPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGlvbjsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0QWN0aW9uID0gZnVuY3Rpb24odil7IHRoaXMuX2FjdGlvbiA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdzeW0nKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25jbGljayA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCdidXR0b24gY2xpY2snLGUpO1xuXHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygndG91Y2hzdGFydCcpO1xuXHRcdFx0dHJ1ZTtcblx0XHRcdHJldHVybiBlLmV2ZW50KCkucHJldmVudERlZmF1bHQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdzbmlwcGV0LWhpbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNldFRleHQoXCJJIGFtIGEgaGludCEhXCIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ292ZXJsYXlzJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcm9vdDtcblx0XHRcdGlmIChyb290ID0gdGhpcy52aWV3KCkuX3Jvb3QpIHtcblx0XHRcdFx0dmFyIGxlZnQgPSAwLHRvcCA9IDAsZWwgPSByb290LmRvbSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKGVsICYmICFlbC5jb250YWlucyh0aGlzLl9kb20pKXtcblx0XHRcdFx0XHRsZWZ0ICs9IGVsLm9mZnNldExlZnQ7XG5cdFx0XHRcdFx0dG9wICs9IGVsLm9mZnNldFRvcCAtIGVsLnNjcm9sbFRvcDtcblx0XHRcdFx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLl9kb20uc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuXHRcdFx0XHR0aGlzLl9kb20uc3R5bGUudG9wID0gdG9wICsgJ3B4Jztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2hpbnQtbGFiZWwnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TGFiZWwgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRpZiAodGV4dCAhPSB0aGlzLl9sYWJlbCkge1xuXHRcdFx0XHR0aGlzLl9sYWJlbCA9IHRleHQ7XG5cdFx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gdGV4dDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdvdmVybGF5LWhpbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndHlwZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX3JvdyA9IHt3YXRjaDogJ3Jvd0RpZFNldCcsbmFtZTogJ3Jvdyd9O1xuXHRcdHRhZy5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb3c7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvdyA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLnJvdygpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX3JvdyA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLnJvd0RpZFNldCAmJiB0aGlzLnJvd0RpZFNldCh2LGEsdGhpcy5fX3JvdykgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fY29sID0ge3dhdGNoOiAnY29sRGlkU2V0JyxuYW1lOiAnY29sJ307XG5cdFx0dGFnLnByb3RvdHlwZS5jb2wgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvbDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29sID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMuY29sKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fY29sID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuY29sRGlkU2V0ICYmIHRoaXMuY29sRGlkU2V0KHYsYSx0aGlzLl9fY29sKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19sZW4gPSB7d2F0Y2g6ICdsZW5EaWRTZXQnLG5hbWU6ICdsZW4nfTtcblx0XHR0YWcucHJvdG90eXBlLmxlbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbGVuOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMZW4gPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5sZW4oKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9sZW4gPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5sZW5EaWRTZXQgJiYgdGhpcy5sZW5EaWRTZXQodixhLHRoaXMuX19sZW4pIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb3dEaWRTZXQgPSBmdW5jdGlvbiAobmV3JCxvbGQpe1xuXHRcdFx0dmFyIHZhbCA9IChcIlwiICsgKHRoaXMub2JqZWN0KCkucm93KCkgKiB0aGlzLnZpZXcoKS5saW5lSGVpZ2h0KCkpICsgXCJweFwiKTtcblx0XHRcdHJldHVybiB0aGlzLl9kb20uc3R5bGUudG9wID0gdmFsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2xEaWRTZXQgPSBmdW5jdGlvbiAobmV3JCxvbGQpe1xuXHRcdFx0dmFyIHZhbCA9IChcIlwiICsgKHRoaXMub2JqZWN0KCkuY29sKCkgKiB0aGlzLnZpZXcoKS5jaGFyV2lkdGgoKSkgKyBcInB4XCIpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5zdHlsZS5sZWZ0ID0gdmFsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sZW5EaWRTZXQgPSBmdW5jdGlvbiAobmV3JCxvbGQpe1xuXHRcdFx0dmFyIHdpZHRoID0gKFwiXCIgKyAobmV3JCAqIHRoaXMudmlldygpLmNoYXJXaWR0aCgpKSArIFwicHhcIik7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2hpbnQgYXQnLG9iamVjdC5yb3dcblx0XHRcdHZhciByZWcgPSB0aGlzLm9iamVjdCgpLnJlZ2lvbigpO1xuXHRcdFx0XG5cdFx0XHRpZiAocmVnKSB7XG5cdFx0XHRcdHRoaXMuc2V0Um93KHRoaXMub2JqZWN0KCkucm93KCkpO1xuXHRcdFx0XHR0aGlzLnNldENvbCh0aGlzLm9iamVjdCgpLmNvbCgpKTtcblx0XHRcdFx0dGhpcy5zZXRMZW4ocmVnLnNpemUoKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCd3YXJuJykuZmxhZygnZ2xvYmFsJywoIXJlZykpLnNldFR5cGUoKHRoaXMub2JqZWN0KCkudHlwZSgpKSkuc2V0Q2hpbGRyZW4oXG5cdFx0XHRcdCh0aGlzLiRhID0gdGhpcy4kYSB8fCB0YWckLiRoaW50X2xhYmVsKCkuZmxhZygnbGFiZWwnKSkuc2V0TGFiZWwodGhpcy5vYmplY3QoKS5sYWJlbCgpKS5lbmQoKVxuXHRcdFx0LDIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2pzdmlldycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKCh0aGlzLl9jb2RlID0gdGhpcy5fY29kZSB8fCB0YWckLiRjb2RlKCkuc2V0UmVmKCdjb2RlJyx0aGlzKSkuZW5kKCksMikuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29kZSxjYil7XG5cdFx0XHQvLyBzaG91bGQgY29tcGlsZSBiYXJlXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRjb2RlID0gY29kZS5yZXBsYWNlKC9cXC9cXC9cXCMgc291cmNlTWFwcGluZyguKikkLywnJyk7XG5cdFx0XHRjb2RlID0gY29kZS5yZXBsYWNlKC9eXFwoZnVuY3Rpb25cXChcXClcXHtcXG4vLCcnKTtcblx0XHRcdGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcbj9cXH1cXClcXChcXClcXG4/JC8sJycpO1xuXHRcdFx0Ly8gY29kZSA9IGNvZGUucmVwbGFjZSgvXlxcdC9tZywnJylcblx0XHRcdHRoaXMuX2NvZGUudGV4dENvbnRlbnQgPSBjb2RlO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmZsYWcoJ2h1Z2UnLGNvZGUubGVuZ3RoID4gMTAwMCk7XG5cdFx0XHRcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhsanMuY29uZmlndXJlKHtjbGFzc1ByZWZpeDogJyd9KTtcblx0XHRcdFx0dmFyIGhsID0gaGxqcy5oaWdobGlnaHQoJ2phdmFzY3JpcHQnLGNvZGUpO1xuXHRcdFx0XHRzZWxmLl9jb2RlLnNldEh0bWwoaGwudmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gY2IgJiYgY2Ioc2VsZik7XG5cdFx0XHR9LDApO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdjb25zb2xlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVkaXRvciA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZWRpdG9yOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRFZGl0b3IgPSBmdW5jdGlvbih2KXsgdGhpcy5fZWRpdG9yID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5lbXB0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5lZGl0b3IoKSkge1xuXHRcdFx0XHR0aGlzLmVkaXRvcigpLmZsYWcoJ2NvbnNvbGUnKTtcblx0XHRcdH07XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9nZ2luZyB2YWwnLHZhbFxuXHRcdFx0XG5cdFx0XHRpZiAodmFsID09IHRoaXMpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHZhbCAmJiB2YWwuZG9tKSB7XG5cdFx0XHRcdHZhbCA9IHZhbC5kb20oKS5vdXRlckhUTUw7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0XHR2YWwgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHZhbCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5hcHBlbmQodGFnJC4kZGl2KCkuZmxhZygnanNvbicpLnNldENvbnRlbnQodmFsLDApLmVuZCgpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybjtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHQvLyB0aGlzIGlzIGJhc2ljYWxseSBsaWtlIGFuIGVkaXRvclxuXHR0YWckLmRlZmluZVRhZygnc25pcHBldCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW1iYSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faW1iYTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SW1iYSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pbWJhID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb25maWcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvbmZpZzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29uZmlnID0gZnVuY3Rpb24odil7IHRoaXMuX2NvbmZpZyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19zcmMgPSB7d2F0Y2g6ICdyZWxvYWQnLG5hbWU6ICdzcmMnfTtcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc3JjOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5zcmMoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9zcmMgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5yZWxvYWQgJiYgdGhpcy5yZWxvYWQodixhLHRoaXMuX19zcmMpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWFkaW5nID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaGVhZGluZycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIZWFkaW5nID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdoZWFkaW5nJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdsYXlvdXQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TGF5b3V0ID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdsYXlvdXQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRhYiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUYWIgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYicsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19hY3RpdmUgPSB7d2F0Y2g6ICdhY3RpdmVEaWRTZXQnLG5hbWU6ICdhY3RpdmUnfTtcblx0XHR0YWcucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5hY3RpdmUoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9hY3RpdmUgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5hY3RpdmVEaWRTZXQgJiYgdGhpcy5hY3RpdmVEaWRTZXQodixhLHRoaXMuX19hY3RpdmUpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGRvbV87XG5cdFx0XHRyZXR1cm4gKGRvbV8gPSB0aGlzLmRvbSgpKS5pZCB8fCAoZG9tXy5pZCA9IChcInNuaXBwZXRcIiArIChjb3VudGVyKyspKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFjdGl2ZURpZFNldCA9IGZ1bmN0aW9uIChib29sKXtcblx0XHRcdHJldHVybiBib29sID8gKHRoaXMuc2NoZWR1bGUoe2ZwczogNjB9KSkgOiAodGhpcy51bnNjaGVkdWxlKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbnB1dCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICh0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0IHx8IHRhZyQuJGltY2FwdG9yKCkuc2V0UmVmKCdpbnB1dCcsdGhpcykpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmlldyB8fCAodGhpcy5fdmlldyA9ICh0aGlzLl92aWV3ID0gdGhpcy5fdmlldyB8fCB0YWckLiRpbXZpZXcoKS5zZXRSZWYoJ3ZpZXcnLHRoaXMpKS5zZXRJbnB1dCh0aGlzLmlucHV0KCkpLmVuZCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdFxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1O1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHRcdGlmIChzZWxmLnNyYygpICYmIHNlbGYuc3JjKCkubWF0Y2goL1xcLmltYmEkLykpIHtcblx0XHRcdFx0XHRBUFAuZmV0Y2hEb2N1bWVudChzZWxmLnNyYygpLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdFx0dmFyIHZfO1xuXHRcdFx0XHRcdFx0cmV0dXJuIChzZWxmLnNldEltYmEodl8gPSByZXMuaHRtbCksdl8pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBwcmVyZW5kZXIgc2hlbGxcblx0XHRcdFx0c2VsZi5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdFx0KHQwID0gc2VsZi5fbWFpbj1zZWxmLl9tYWluIHx8IHRhZyQuJHNlY3Rpb24oKS5zZXRSZWYoJ21haW4nLHNlbGYpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdCh0MSA9IHNlbGYuX2hlYWRlcj1zZWxmLl9oZWFkZXIgfHwgdGFnJC4kaGVhZGVyKCkuc2V0UmVmKCdoZWFkZXInLHNlbGYpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0KHQyID0gdDEuJCRhPXQxLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCd0aXRsZScpLmZsYWcoJ3BhdGgnKSkuc2V0Q29udGVudChzZWxmLmhlYWRpbmcoKSwzKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0KHQzID0gdDEuJCRiPXQxLiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCd0b29scycpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0XHQodDMuJCRhID0gdDMuJCRhIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdyZXNldCcpLnNldFRpdGxlKCdyZXNldCcpLnNldEhhbmRsZXIoJ3RhcCcsJ3Jlc2V0JyxzZWxmKSkuc2V0VGV4dCgncmVzZXQnKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0XHQodDMuJCRiID0gdDMuJCRiIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdqcycpLnNldFRpdGxlKCdzaG93IGpzJykuc2V0SGFuZGxlcigndGFwJywndG9nZ2xlSlMnLHNlbGYpKS5zZXRUZXh0KCdzaG93IGpzJykuZW5kKCksXG5cdFx0XHRcdFx0XHRcdFx0KHQzLiQkYyA9IHQzLiQkYyB8fCB0YWckLiR0b29sKCkuZmxhZygncnVuJykuc2V0VGl0bGUoJ3J1bicpLnNldEhhbmRsZXIoJ3RhcCcsJ3J1bicsc2VsZikpLnNldFRleHQoJ3J1bicpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHRcdF0sMikuZW5kKCksXG5cdFx0XHRcdFx0XHQodDQgPSBzZWxmLl92aWV3PXNlbGYuX3ZpZXcgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCd2aWV3JyxzZWxmKSkuc2V0Q29udGVudCgodDUgPSB0NC4kJGE9dDQuJCRhIHx8IHRhZyQuJGNvZGUoKS5mbGFnKCdpbWJhY29kZScpKS5kYXRhc2V0KCdzcmMnLChzZWxmLnNyYygpKSkuc2V0Q29udGVudChzZWxmLmltYmEoKSwzKS5lbmQoKSwyKS5lbmQoKVxuXHRcdFx0XHRcdF0sMikuZW5kKCksXG5cdFx0XHRcdFx0KHNlbGYuX2luc3BlY3RvciA9IHNlbGYuX2luc3BlY3RvciB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2luc3BlY3Rvcicsc2VsZikpLmVuZCgpXG5cdFx0XHRcdF0sMikuc3luY2VkKCk7XG5cdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGFnLl9fc3VwZXJfXy5idWlsZC5hcHBseShzZWxmLGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoc2VsZi5zcmMoKSkgeyByZXR1cm4gc2VsZi5yZWxvYWQoKSB9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb25maWcgPSBmdW5jdGlvbiAoY2ZnKXtcblx0XHRcdHZhciB2Xztcblx0XHRcdGlmIChjZmcgIT0gdGhpcy5fb3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl9vcHRpb25zID0gY2ZnO1xuXHRcdFx0XHRpZiAoY2ZnLnRpdGxlKSB7ICh0aGlzLnNldEhlYWRpbmcodl8gPSBjZmcudGl0bGUpLHZfKSB9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb3B0cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NvcHRzIHx8ICh0aGlzLl9jb3B0cyA9IHtcblx0XHRcdFx0YmFyZTogZmFsc2UsXG5cdFx0XHRcdHN0YW5kYWxvbmU6IGZhbHNlLFxuXHRcdFx0XHRzb3VyY2VNYXBJbmxpbmU6IHRydWUsXG5cdFx0XHRcdGZpbGVuYW1lOiAoXCJcIiArIHRoaXMuaWQoKSArIFwiLmltYmFcIiksXG5cdFx0XHRcdHRhcmdldFBhdGg6IChcIlwiICsgdGhpcy5pZCgpICsgXCIuanNcIiksXG5cdFx0XHRcdHNvdXJjZVBhdGg6IChcIlwiICsgdGhpcy5pZCgpICsgXCIuaW1iYVwiKVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uIChrZXkpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMgPyAodGhpcy5fb3B0aW9uc1trZXldKSA6IChudWxsKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0dGhpcy5fb3B0aW9ucyA9IG87XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXIoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgY29uZmlnID0ge307XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgY29kZSA9IHEkJCgnLmltYmFjb2RlJyx0aGlzKS5kb20oKS5pbm5lckhUTUw7XG5cdFx0XHR9IGNhdGNoIChlKSB7IH07XG5cdFx0XHRcblx0XHRcdGlmIChjb2RlKSB7XG5cdFx0XHRcdGNvbmZpZy5odG1sID0gY29kZTtcblx0XHRcdFx0dGhpcy52aWV3KCkubG9hZChudWxsLHtodG1sOiBjb2RlfSk7XG5cdFx0XHRcdHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoY29kZSB8fCBvLmh0bWwpIHsgdGhpcy52aWV3KCkubG9hZChjb2RlLG8pIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLmNvZGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChjb2RlLG8sYmxrKXtcblx0XHRcdC8vIGNhY2hlIGxhdGVzdCBjb21waWxhdGlvbiAtIHJldHVybj9cblx0XHRcdGlmKGJsaz09dW5kZWZpbmVkICYmIHR5cGVvZiBvID09ICdmdW5jdGlvbicpIGJsayA9IG8sbyA9IHRoaXMuY29wdHMoKTtcblx0XHRcdGlmKG89PXVuZGVmaW5lZCkgbyA9IHRoaXMuY29wdHMoKTtcblx0XHRcdHJldHVybiBTY3JpbWJsYS53b3JrZXIoKS5jb21waWxlKGNvZGUsbyxibGspO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vdmVybGF5cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMudmlldygpLmhpbnRzKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCBoaW50LCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGhpbnQgPSBhcnlbaV07XG5cdFx0XHRcdGlmICghaGludC5hY3RpdmUoKSkgeyBjb250aW51ZTsgfTtcblx0XHRcdFx0cmVzLnB1c2goKHRoaXNbJ18nICsgJ2hpbnQnICsgaV0gPSB0aGlzWydfJyArICdoaW50JyArIGldIHx8IHRhZyQuJG92ZXJsYXlfaGludCgpKS5zZXRWaWV3KHRoaXMudmlldygpKS5zZXRPYmplY3QoaGludCkuZW5kKCkpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvZ2dsZUpTID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy50YWIoKSAhPSAnanMnKSB7XG5cdFx0XHRcdHRoaXMuc2hvd2pzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldFRhYignaW1iYScpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmlucHV0Zm9jdXMgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRWSUVXID0gdGhpczsgLy8gaGFja1xuXHRcdFx0dGhpcy5mbGFnKCdmb2N1cycpO1xuXHRcdFx0cmV0dXJuICh0aGlzLnNldEFjdGl2ZSh0cnVlKSx0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dGJsdXIgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLnVuZmxhZygnZm9jdXMnKTtcblx0XHRcdHZhciByZWwgPSBlLmV2ZW50KCkucmVsYXRlZFRhcmdldDtcblx0XHRcdGlmICghKHJlbCAmJiB0aGlzLmRvbSgpLmNvbnRhaW5zKHJlbCkpKSB7XG5cdFx0XHRcdHRoaXMudW5mbGFnKCdmb2N1cycpO1xuXHRcdFx0XHR0aGlzLnNldEFjdGl2ZShmYWxzZSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDU7XG5cdFx0XHRpZiAoSW1iYS5TRVJWRVIpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHR0aGlzLl9pbnB1dCxcblx0XHRcdFx0KHQwID0gdGhpcy5fbWFpbj10aGlzLl9tYWluIHx8IHRhZyQuJHNlY3Rpb24oKS5zZXRSZWYoJ21haW4nLHRoaXMpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodDEgPSB0aGlzLl9oZWFkZXI9dGhpcy5faGVhZGVyIHx8IHRhZyQuJGhlYWRlcigpLnNldFJlZignaGVhZGVyJyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHQodDIgPSB0MS4kJGE9dDEuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3RpdGxlJykuZmxhZygncGF0aCcpKS5zZXRDb250ZW50KHRoaXMuaGVhZGluZygpLDMpLmVuZCgpLFxuXHRcdFx0XHRcdFx0KHQzID0gdDEuJCRiPXQxLiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCd0b29scycpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0KHQzLiQkYSA9IHQzLiQkYSB8fCB0YWckLiR0b29sKCkuZmxhZygncmVzZXQnKS5zZXRUaXRsZSgncmVzZXQnKS5zZXRIYW5kbGVyKCd0YXAnLCdyZXNldCcsdGhpcykpLnNldFRleHQoJ3Jlc2V0JykuZW5kKCksXG5cdFx0XHRcdFx0XHRcdCh0My4kJGIgPSB0My4kJGIgfHwgdGFnJC4kdG9vbCgpLmZsYWcoJ2pzJykuc2V0VGl0bGUoJ3Nob3cganMnKS5zZXRIYW5kbGVyKCd0YXAnLCd0b2dnbGVKUycsdGhpcykpLnNldFRleHQoJ3Nob3cganMnKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0KHQzLiQkYyA9IHQzLiQkYyB8fCB0YWckLiR0b29sKCkuZmxhZygncnVuJykuc2V0VGl0bGUoJ3J1bicpLnNldEhhbmRsZXIoJ3RhcCcsJ3J1bicsdGhpcykpLnNldFRleHQoJ3J1bicpLmVuZCgpXG5cdFx0XHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRcdFx0XSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDQgPSB0aGlzLl9vdmVybGF5cz10aGlzLl9vdmVybGF5cyB8fCB0YWckLiRvdmVybGF5cygpLnNldFJlZignb3ZlcmxheXMnLHRoaXMpKS5zZXRWaWV3KHRoaXMudmlldygpKS5zZXRDb250ZW50KHRoaXMub3ZlcmxheXMoKSwzKS5lbmQoKSxcblx0XHRcdFx0XHQodGhpcy5fanN2aWV3ID0gdGhpcy5fanN2aWV3IHx8IHRhZyQuJGpzdmlldygpLnNldFJlZignanN2aWV3Jyx0aGlzKSkuZW5kKCksXG5cdFx0XHRcdFx0dGhpcy5fdmlldy5lbmQoKSxcblx0XHRcdFx0XHQodGhpcy5fY29uc29sZSA9IHRoaXMuX2NvbnNvbGUgfHwgdGFnJC4kY29uc29sZSgpLnNldFJlZignY29uc29sZScsdGhpcykuZmxhZygnZGFyaycpKS5zZXRFZGl0b3IodGhpcykuZW5kKClcblx0XHRcdFx0XSwxKS5lbmQoKSxcblx0XHRcdFx0KHQ1ID0gdGhpcy5faW5zcGVjdG9yPXRoaXMuX2luc3BlY3RvciB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2luc3BlY3RvcicsdGhpcykpLnNldENvbnRlbnQodGhpcy5wbGF5Z3JvdW5kKCksMykuZW5kKClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNhbmRib3ggPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAodGhpcy5fc2FuZGJveCA9IHRoaXMuX3NhbmRib3ggfHwgdGFnJC4kc2FuZGJveCgpLnNldFJlZignc2FuZGJveCcsdGhpcykuZmxhZygncGxheWdyb3VuZCcpKS5zZXRFZGl0b3IodGhpcykuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBsYXlncm91bmQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNhbmRib3goKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoIXNlbGYuX2J1aWx0KSB7IHJldHVybiB9O1xuXHRcdFx0XG5cdFx0XHRpZiAoREVQU1tzZWxmLnNyYygpXSkge1xuXHRcdFx0XHR2YXIgcmVzID0gREVQU1tzZWxmLnNyYygpXTtcblx0XHRcdFx0c2VsZi52aWV3KCkubG9hZChudWxsLHtodG1sOiByZXMuaHRtbCxmaWxlbmFtZTogc2VsZi5zcmMoKX0pO1xuXHRcdFx0XHRpZiAoc2VsZi5hdXRvcnVuKCkpIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5ydW4oKTsgfSw1MCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gZ2V0IGltYmEgZG9jdW1lbnQ/IT9cblx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCksZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdHNlbGYudmlldygpLmxvYWQocmVzLmJvZHkse2ZpbGVuYW1lOiBzZWxmLnNyYygpfSk7XG5cdFx0XHRcdGlmIChzZWxmLmF1dG9ydW4oKSkge1xuXHRcdFx0XHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5ydW4oKTsgfSw1MCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnJ1biA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMucnVuKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF1dG9ydW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25lZGl0ZWRhc3luYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5mbGFnKCdkaXJ0eScpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uc2F2ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy52aWV3KCkuaGludHMoKS5jbGVhcigpO1xuXHRcdFx0cmV0dXJuIHRoaXMucnVuKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy5fY29uc29sZS5yZXNldCgpO1xuXHRcdFx0aWYgKHRoaXMuX29wdGlvbnMuaHRtbCkge1xuXHRcdFx0XHR0aGlzLnZpZXcoKS5sb2FkKG51bGwse2h0bWw6IHRoaXMuX29wdGlvbnMuaHRtbH0pO1xuXHRcdFx0fTtcblx0XHRcdGlmIChlKSB7XG5cdFx0XHRcdGUuY2FuY2VsKCk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy51bmZsYWcoJ2RpcnR5Jyk7XG5cdFx0XHR0aGlzLnZpZXcoKS5jYXJldCgpLm5vcm1hbGl6ZSgpLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmZsYWcoJ3J1bm5pbmcnKTtcblx0XHRcdHNlbGYuY29tcGlsZShzZWxmLmNvZGUoKSxzZWxmLmNvcHRzKCksZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdHNlbGYudmlldygpLmhpbnRzKCkucmVtKGZ1bmN0aW9uKGhpbnQpIHsgcmV0dXJuIGhpbnQuZ3JvdXAoKSA9PSAncnVudGltZSc7IH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmNvZGUpIHtcblx0XHRcdFx0XHQvLyBAanN2aWV3LmxvYWQocmVzOmRhdGE6Y29kZSkgaWYgcmVzOmRhdGFcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNlbGYuX3NhbmRib3gucnVuKHJlcy5kYXRhKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY29uc29sZS5sb2coJ2Vycm9yJyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNob3dqcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIG8gPSB7YmFyZTogdHJ1ZSxzdGFuZGFsb25lOiBmYWxzZSxmaWxlbmFtZTogJ2EuaW1iYSd9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZi5jb21waWxlKHNlbGYuY29kZSgpLG8sZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdGlmIChyZXMuZGF0YSAmJiByZXMuZGF0YS5jb2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYuX2pzdmlldy5sb2FkKHJlcy5kYXRhLmNvZGUsZnVuY3Rpb24oKSB7IHZhciB2Xztcblx0XHRcdFx0XHRyZXR1cm4gKHNlbGYuc2V0VGFiKHZfID0gJ2pzJyksdl8pOyB9KTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZXMuZGF0YSAmJiByZXMuZGF0YS5lcnJvcikge1xuXHRcdFx0XHRcdHJldHVybiBjb25zb2xlLmxvZygnaGFzIGVycm9yJyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucnVuRXJyb3IgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHRvLnR5cGUgPSAnZXJyb3InO1xuXHRcdFx0by5ncm91cCA9ICdydW50aW1lJztcblx0XHRcdC8vIGNvbnNvbGUubG9nICdydW5FcnJvcicsb1xuXHRcdFx0Ly8gb25seSBzaG93IGVycm9yIGlmIHdlIGhhdmUgYSBsaW5lIGFuZCBjb2x1bW5cblx0XHRcdHRoaXMudmlldygpLmhpbnRzKCkuYWRkKG8pLmFjdGl2YXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXIoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucnVuTG9nID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0by50eXBlID0gJ2xvZyc7XG5cdFx0XHRvLmdyb3VwID0gJ3J1bnRpbWUnO1xuXHRcdFx0by5tZXNzYWdlIHx8IChvLm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShvLnBhcmFtc1swXSkpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3J1bkxvZycsb1xuXHRcdFx0XG5cdFx0XHRpZiAoby5uciAhPSBudWxsICYmICFvLmxvYykge1xuXHRcdFx0XHR2YXIgbG9ncyA9IHRoaXMudmlldygpLmZpbmQoJy5pZGVudGlmaWVyLmxvZywuaWRlbnRpZmllcltuYW1lPVwibG9nXCJdJykudG9BcnJheSgpO1xuXHRcdFx0XHR2YXIgbm9kZSA9IGxvZ3Nbby5ucl07XG5cdFx0XHRcdFxuXHRcdFx0XHRvLm5vZGUgPSBub2RlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0XHR2YXIgcmVnID0gbm9kZS5yZWdpb24oKTsgLy8gbm9kZS5uZXh0ID8gbm9kZS5uZXh0LnJlZ2lvbiA6IFxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdmb3VuZCBsb2MhIScsbm9kZSxyZWcpO1xuXHRcdFx0XHRcdC8vIGxldCBjb2wgPSB2aWV3LmJ1ZmZlci5saW5lKHJlZy5yb3cpWzpsZW5ndGhdXG5cdFx0XHRcdFx0by5sb2MgPSByZWcuZW5kQXRMaW5lKCkuY29sbGFwc2UoKTsgLy8ge2xpbmU6IHJlZy5yb3csIGNvbHVtbjogY29sfSAjICByZWcudG9KU09OICMge2xpbmU6IHJlZy5yb3csIGNvbHVtbjogMTAwfVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIG86bG9jID0gbG9nc1tvOm5yXS5yZWdpb24udG9KU09OXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy52aWV3KCkuaGludHMoKS5hZGQobykuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiB0aGlzLnJlbmRlcigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW5SZXN1bHQgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncnVuUmVzdWx0JyxvXG5cdFx0XHR0aGlzLmZsYWcoJ3JlcGwnLCEhbyk7XG5cdFx0XHR0aGlzLl9jb25zb2xlLmxvZyhvKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2V4YW1wbGUnLCAnc25pcHBldCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hdXRvcnVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdGlmICghSW1iYS5TRVJWRVIpIHtcblx0XHRJbWJhLkV2ZW50LlBST0NFU1NJTkc7XG5cdFx0XG5cdFx0XG5cdFx0XHRcblx0XHRcdHZhciBwcmV2ID0gSW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2Vzcztcblx0XHRcdFxuXHRcdFx0SW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRJbWJhLkV2ZW50LlBST0NFU1NJTkcgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcHJldi5jYWxsKHRoaXMpO1xuXHRcdFx0fTtcblx0XHRcblx0fTtcblx0XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3NhbmRib3gnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZWRpdG9yID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lZGl0b3I7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEVkaXRvciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lZGl0b3IgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnNvbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmVkaXRvcigpLl9jb25zb2xlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKG1zZyx1cmwsbGluZSxjb2wsZXJyKXtcblx0XHRcdFxuXHRcdFx0dmFyIHN0YWNrXztcblx0XHRcdGlmICh1cmwubWF0Y2goL3NuaXBwZXQoXFxkKylcXC4oaW1iYXxqcykvKSkge1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGlkID0gdXJsLnNwbGl0KCcuJykuc2hpZnQoKTtcblx0XHRcdFx0dmFyIHNuaXBwZXQgPSB0YWckd3JhcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNuaXBwZXQpIHtcblx0XHRcdFx0XHRzbmlwcGV0LnBsYXlncm91bmQoKS5vbmVycm9yKG1zZywnJyxsaW5lLGNvbCxlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAodXJsID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdC8vIHNhZmFyaT9cblx0XHRcdFx0dmFyIGV2ID0gSW1iYS5FdmVudC5QUk9DRVNTSU5HO1xuXHRcdFx0XHRjb25zb2xlLmxvZygnbGFzdCBldmVudCB0YXJnZXQnLGV2ICYmIGV2LnRhcmdldCgpKTtcblx0XHRcdFx0aWYgKGV2ICYmIGV2LnRhcmdldCgpKSB7XG5cdFx0XHRcdFx0c25pcHBldCA9IGV2LnRhcmdldCgpLmNsb3Nlc3QocSQoJy5fc25pcHBldCcsdGhpcykpO1xuXHRcdFx0XHRcdGlmIChzbmlwcGV0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc25pcHBldC5wbGF5Z3JvdW5kKCkub25lcnJvcihtc2csJycsbGluZSxjb2wsZXJyKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS5sb2coJ2NhdWdodCB0aGUgZXJyb3IgaGVyZSEhIScsYXJndW1lbnRzLHRoaXMpO1xuXHRcdFx0dmFyIGxvY3MgPSBbXTtcblx0XHRcdFxuXHRcdFx0ZXJyICYmIChzdGFja18gPSBlcnIuc3RhY2spICYmIHN0YWNrXy5yZXBsYWNlICAmJiAgc3RhY2tfLnJlcGxhY2UoLyhcXDxhbm9ueW1vdXNcXD58c25pcHBldFxcZCtcXC5pbWJhKVxcOihcXGQrKTooXFxkKykvZyxmdW5jdGlvbihtLHNvdXJjZSxsaW5lLGNvbCkge1xuXHRcdFx0XHRsb2NzLnB1c2goe2xpbmU6IHBhcnNlSW50KGxpbmUpLGNvbHVtbjogcGFyc2VJbnQoY29sKX0pO1xuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRsb2NzLnB1c2goe2xpbmU6IGxpbmUsY29sdW1uOiBjb2x9KTtcblx0XHRcdFxuXHRcdFx0aWYgKGxvY3NbMF0pIHtcblx0XHRcdFx0dmFyIG1hcCA9IHRoaXMub2JqZWN0KCkuc291cmNlbWFwO1xuXHRcdFx0XHR2YXIgY29uc3VtZXIgPSBTY3JpbWJsYS5Tb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIobWFwKTtcblx0XHRcdFx0dmFyIGxvYyA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IobG9jc1swXSk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdvcmlnaW5hbCBsb2NhdGlvbiBpcycsbG9jKTtcblx0XHRcdFx0dGhpcy5lZGl0b3IoKS5ydW5FcnJvcih7bWVzc2FnZTogbXNnLGxvYzogbG9jfSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25sb2cgPSBmdW5jdGlvbiAobnIscGFycyl7XG5cdFx0XHR0aGlzLmVkaXRvcigpLnJ1bkxvZyh7bnI6IG5yLHBhcmFtczogcGFyc30pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocSQoJy5zY2hlZHVsZWRfJyx0aGlzKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0udW5zY2hlZHVsZSgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLmVtcHR5LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJlc2VudCA9IGZ1bmN0aW9uIChyZXMpe1xuXHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRpZiAocmVzICYmIChyZXMucHJvdG90eXBlIGluc3RhbmNlb2YgSW1iYS5UYWcpKSB7XG5cdFx0XHRcdG5vZGUgPSBuZXcgcmVzKHJlcy5jcmVhdGVOb2RlKCkpO1xuXHRcdFx0fSBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBJbWJhLlRhZykge1xuXHRcdFx0XHRub2RlID0gcmVzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZChub2RlKTtcblx0XHRcdFx0bm9kZS5lbmQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNvbnNvbGUoKS5sb2cobm9kZSB8fCByZXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoc3JjKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBjb2RlID0gc3JjLmNvZGU7XG5cdFx0XHRpZiAoIWNvZGUpIHsgcmV0dXJuIHNlbGYgfTtcblx0XHRcdFxuXHRcdFx0c2VsZi5fb2JqZWN0ID0gc3JjO1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uKG1zZyx1cmwsbGluZSxjb2wsZXJyKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ2NhdWdodCBlcnJvcicsbXNnLHVybCxsaW5lLGNvbCxlcnIsdGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYub25lcnJvcihtc2csdXJsLGxpbmUsY29sLGVycik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb2RlID0gY29kZSArICdcXG4vLyMgc291cmNlVVJMPScgKyBzZWxmLmVkaXRvcigpLmlkKCkgKyAnLmltYmEnO1xuXHRcdFx0XHR2YXIgdGFnJCA9IEltYmEuVEFHUy5fX2Nsb25lKCk7XG5cdFx0XHRcdHZhciBjb25zb2xlID0gc2VsZi5jb25zb2xlKCk7XG5cdFx0XHRcdHZhciByZXMgPSBldmFsKGNvZGUpO1xuXHRcdFx0XHRzZWxmLnByZXNlbnQocmVzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5sb2coJ2ltbWVkaWF0ZSBlcnJvciBpbiBldmFsLWlubGluZScsZSk7XG5cdFx0XHRcdHNlbGYub25lcnJvcihlLm1lc3NhZ2UsJycsZS5saW5lTnIgfHwgZS5saW5lIHx8IDAsZS5jb2x1bW4sZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3Mvc25pcHBldC5pbWJhXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=