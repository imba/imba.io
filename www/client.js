/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		__webpack_require__(1);
		
		// need to use webpack for this include to work as intended
		Scrimbla = __webpack_require__(14);
		
		var App = __webpack_require__(57).App;
		APP = new App();
		APP.schedule();
		
		__webpack_require__(59);
		
		// awaken pages etc
		q$('._page').map(function(el) { return el; });
		return q$('.awaken').map(function(el) { return el; });
	
	})()

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		if (typeof Imba === 'undefined') {
			__webpack_require__(2);
			
			Imba.CLIENT = true;
			
			__webpack_require__(3);
			__webpack_require__(4);
			__webpack_require__(5);
			__webpack_require__(6);
			__webpack_require__(7);
			__webpack_require__(8);
			__webpack_require__(9);
			__webpack_require__(10);
			__webpack_require__(11);
			__webpack_require__(12);
			return __webpack_require__(13);
		} else {
			return console.warn("Imba is already loaded");
		};
	
	})()

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		// externs;
		
		if (true) {
			global = window;
		};
		
		/*
		Imba is the namespace for all runtime related utilities
		@namespace
		*/
		
		Imba = {
			VERSION: '0.14.1',
			DEBUG: false
		};
		
		var reg = /-./g;
		
		/*
		True if running in client environment.
		@return {bool}
		*/
		
		Imba.isClient = function (){
			return Imba.CLIENT === true;
		};
		
		/*
		True if running in server environment.
		@return {bool}
		*/
		
		Imba.isServer = function (){
			return (false) === true;
		};
		
		Imba.subclass = function (obj,sup){
			;
			for (var k in sup){
				if (sup.hasOwnProperty(k)) { obj[k] = sup[k] };
			};
			
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
			return obj;
		};
		
		/*
		Lightweight method for making an object iterable in imbas for/in loops.
		If the compiler cannot say for certain that a target in a for loop is an
		array, it will cache the iterable version before looping.
		
		```imba
		# this is the whole method
		def Imba.iterable o
			return o ? (o:toArray ? o.toArray : o) : []
		
		class CustomIterable
			def toArray
				[1,2,3]
		
		# will return [2,4,6]
		for x in CustomIterable.new
			x * 2
		
		```
		*/
		
		Imba.iterable = function (o){
			return o ? ((o.toArray ? (o.toArray()) : (o))) : ([]);
		};
		
		/*
		Coerces a value into a promise. If value is array it will
		call `Promise.all(value)`, or if it is not a promise it will
		wrap the value in `Promise.resolve(value)`. Used for experimental
		await syntax.
		@return {Promise}
		*/
		
		Imba.await = function (value){
			if (value instanceof Array) {
				return Promise.all(value);
			} else if (value && value.then) {
				return value;
			} else {
				return Promise.resolve(value);
			};
		};
		
		Imba.toCamelCase = function (str){
			return str.replace(reg,function(m) { return m.charAt(1).toUpperCase(); });
		};
		
		Imba.toCamelCase = function (str){
			return str.replace(reg,function(m) { return m.charAt(1).toUpperCase(); });
		};
		
		Imba.indexOf = function (a,b){
			return (b && b.indexOf) ? (b.indexOf(a)) : ([].indexOf.call(a,b));
		};
		
		Imba.prop = function (scope,name,opts){
			if (scope.defineProperty) {
				return scope.defineProperty(name,opts);
			};
			return;
		};
		
		return Imba.attr = function (scope,name,opts){
			if (scope.defineAttribute) {
				return scope.defineAttribute(name,opts);
			};
			
			var getName = Imba.toCamelCase(name);
			var setName = Imba.toCamelCase('set-' + name);
			
			scope.prototype[getName] = function() {
				return this.getAttribute(name);
			};
			
			scope.prototype[setName] = function(value) {
				this.setAttribute(name,value);
				return this;
			};
			
			return;
		};
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	(function(){
		
		
		function emit__(event,args,node){
			// var node = cbs[event]
			var prev,cb,ret;
			
			while ((prev = node) && (node = node.next)){
				if (cb = node.listener) {
					if (node.path && cb[node.path]) {
						ret = args ? (cb[node.path].apply(cb,args)) : (cb[node.path]());
					} else {
						// check if it is a method?
						ret = args ? (cb.apply(node,args)) : (cb.call(node));
					};
				};
				
				if (node.times && --node.times <= 0) {
					prev.next = node.next;
					node.listener = null;
				};
			};
			return;
		};
		
		// method for registering a listener on object
		Imba.listen = function (obj,event,listener,path){
			var $1;
			var cbs,list,tail;
			cbs = obj.__listeners__ || (obj.__listeners__ = {});
			list = cbs[($1 = event)] || (cbs[$1] = {});
			tail = list.tail || (list.tail = (list.next = {}));
			tail.listener = listener;
			tail.path = path;
			list.tail = tail.next = {};
			return tail;
		};
		
		Imba.once = function (obj,event,listener){
			var tail = Imba.listen(obj,event,listener);
			tail.times = 1;
			return tail;
		};
		
		Imba.unlisten = function (obj,event,cb,meth){
			var node,prev;
			var meta = obj.__listeners__;
			if (!meta) { return };
			
			if (node = meta[event]) {
				while ((prev = node) && (node = node.next)){
					if (node == cb || node.listener == cb) {
						prev.next = node.next;
						// check for correct path as well?
						node.listener = null;
						break;
					};
				};
			};
			return;
		};
		
		Imba.emit = function (obj,event,params){
			var cb;
			if (cb = obj.__listeners__) {
				if (cb[event]) { emit__(event,params,cb[event]) };
				if (cb.all) { emit__(event,[event,params],cb.all) }; // and event != 'all'
			};
			return;
		};
		
		return Imba.observeProperty = function (observer,key,trigger,target,prev){
			if (prev && typeof prev == 'object') {
				Imba.unlisten(prev,'all',observer,trigger);
			};
			if (target && typeof target == 'object') {
				Imba.listen(target,'all',observer,trigger);
			};
			return this;
		};
	
	})()

/***/ },
/* 4 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		
		var raf; // very simple raf polyfill
		raf || (raf = global.requestAnimationFrame);
		raf || (raf = global.webkitRequestAnimationFrame);
		raf || (raf = global.mozRequestAnimationFrame);
		raf || (raf = function(blk) { return setTimeout(blk,1000 / 60); });
		
		Imba.tick = function (d){
			if (this._scheduled) { raf(Imba.ticker()) };
			this.emit(this,'tick',[d]);
			return;
		};
		
		Imba.ticker = function (){
			var self = this;
			return self._ticker || (self._ticker = function(e) { return self.tick(e); });
		};
		
		/*
		
		Global alternative to requestAnimationFrame. Schedule a target
		to tick every frame. You can specify which method to call on the
		target (defaults to tick).
		
		*/
		
		Imba.schedule = function (target,method){
			if(method === undefined) method = 'tick';
			this.listen(this,'tick',target,method);
			// start scheduling now if this was the first one
			if (!this._scheduled) {
				this._scheduled = true;
				raf(Imba.ticker());
			};
			return this;
		};
		
		/*
		
		Unschedule a previously scheduled target
		
		*/
		
		Imba.unschedule = function (target,method){
			this.unlisten(this,'tick',target,method);
			var cbs = this.__listeners__ || (this.__listeners__ = {});
			if (!cbs.tick || !cbs.tick.next || !cbs.tick.next.listener) {
				this._scheduled = false;
			};
			return this;
		};
		
		/*
		
		Light wrapper around native setTimeout that expects the block / function
		as last argument (instead of first). It also triggers an event to Imba
		after the timeout to let schedulers update (to rerender etc) afterwards.
		
		*/
		
		Imba.setTimeout = function (delay,block){
			return setTimeout(function() {
				block();
				return Imba.emit(Imba,'timeout',[block]);
			},delay);
		};
		
		/*
		
		Light wrapper around native setInterval that expects the block / function
		as last argument (instead of first). It also triggers an event to Imba
		after every interval to let schedulers update (to rerender etc) afterwards.
		
		*/
		
		Imba.setInterval = function (interval,block){
			return setInterval(function() {
				block();
				return Imba.emit(Imba,'interval',[block]);
			},interval);
		};
		
		/*
		Clear interval with specified id
		*/
		
		Imba.clearInterval = function (interval){
			return clearInterval(interval);
		};
		
		/*
		Clear timeout with specified id
		*/
		
		Imba.clearTimeout = function (timeout){
			return clearTimeout(timeout);
		};
		
		// should add an Imba.run / setImmediate that
		// pushes listener onto the tick-queue with times - once
		
		
		/*
		
		Instances of Imba.Scheduler manages when to call `tick()` on their target,
		at a specified framerate or when certain events occur. Root-nodes in your
		applications will usually have a scheduler to make sure they rerender when
		something changes. It is also possible to make inner components use their
		own schedulers to control when they render.
		
		@iname scheduler
		
		*/
		
		Imba.Scheduler = function Scheduler(target){
			var self = this;
			self._target = target;
			self._marked = false;
			self._active = false;
			self._marker = function() { return self.mark(); };
			self._ticker = function(e) { return self.tick(e); };
			
			self._events = true;
			self._fps = 1;
			
			self._dt = 0;
			self._timestamp = 0;
			self._ticks = 0;
			self._flushes = 0;
		};
		
		/*
			Create a new Imba.Scheduler for specified target
			@return {Imba.Scheduler}
			*/
		
		/*
			Check whether the current scheduler is active or not
			@return {bool}
			*/
		
		Imba.Scheduler.prototype.active = function (){
			return this._active;
		};
		
		/*
			Delta time between the two last ticks
			@return {Number}
			*/
		
		Imba.Scheduler.prototype.dt = function (){
			return this._dt;
		};
		
		/*
			Delta time between the two last ticks
			@return {Number}
			*/
		
		Imba.Scheduler.prototype.configure = function (pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var fps = pars.fps !== undefined ? pars.fps : 1;
			var events = pars.events !== undefined ? pars.events : true;
			if (events != null) { this._events = events };
			if (fps != null) { this._fps = fps };
			return this;
		};
		
		// def reschedule
		// 	raf(@ticker)
		// 	self
		
		/*
			Mark the scheduler as dirty. This will make sure that
			the scheduler calls `target.tick` on the next frame
			@return {self}
			*/
		
		Imba.Scheduler.prototype.mark = function (){
			this._marked = true;
			return this;
		};
		
		/*
			Instantly trigger target.tick and mark scheduler as clean (not dirty/marked).
			This is called implicitly from tick, but can also be called manually if you
			really want to force a tick without waiting for the next frame.
			@return {self}
			*/
		
		Imba.Scheduler.prototype.flush = function (){
			this._marked = false;
			this._flushes++;
			this._target.tick();
			return this;
		};
		
		/*
			@fixme this expects raf to run at 60 fps 
		
			Called automatically on every frame while the scheduler is active.
			It will only call `target.tick` if the scheduler is marked dirty,
			or when according to @fps setting.
		
			If you have set up a scheduler with an fps of 1, tick will still be
			called every frame, but `target.tick` will only be called once every
			second, and it will *make sure* each `target.tick` happens in separate
			seconds according to Date. So if you have a node that renders a clock
			based on Date.now (or something similar), you can schedule it with 1fps,
			never needing to worry about two ticks happening within the same second.
			The same goes for 4fps, 10fps etc.
		
			@protected
			@return {self}
			*/
		
		Imba.Scheduler.prototype.tick = function (delta){
			this._ticks++;
			this._dt = delta;
			
			var fps = this._fps;
			
			if (fps == 60) {
				this._marked = true;
			} else if (fps == 30) {
				if (this._ticks % 2) { this._marked = true };
			} else if (fps) {
				// if it is less round - we trigger based
				// on date, for consistent rendering.
				// ie, if you want to render every second
				// it is important that no two renders
				// happen during the same second (according to Date)
				var period = ((60 / fps) / 60) * 1000;
				var beat = Math.floor(Date.now() / period);
				
				if (this._beat != beat) {
					this._beat = beat;
					this._marked = true;
				};
			};
			
			if (this._marked) this.flush();
			// reschedule if @active
			return this;
		};
		
		/*
			Start the scheduler if it is not already active.
			**While active**, the scheduler will override `target.commit`
			to do nothing. By default Imba.tag#commit calls render, so
			that rendering is cascaded through to children when rendering
			a node. When a scheduler is active (for a node), Imba disables
			this automatic rendering.
			*/
		
		Imba.Scheduler.prototype.activate = function (){
			if (!this._active) {
				this._active = true;
				// override target#commit while this is active
				this._commit = this._target.commit;
				this._target.commit = function() { return this; };
				Imba.schedule(this);
				if (this._events) { Imba.listen(Imba,'event',this,'onevent') };
				this._target && this._target.flag  &&  this._target.flag('scheduled_');
				this.tick(0); // start ticking
			};
			return this;
		};
		
		/*
			Stop the scheduler if it is active.
			*/
		
		Imba.Scheduler.prototype.deactivate = function (){
			if (this._active) {
				this._active = false;
				this._target.commit = this._commit;
				Imba.unschedule(this);
				Imba.unlisten(Imba,'event',this);
				this._target && this._target.unflag  &&  this._target.unflag('scheduled_');
			};
			return this;
		};
		
		Imba.Scheduler.prototype.track = function (){
			return this._marker;
		};
		
		Imba.Scheduler.prototype.onevent = function (event){
			var $1;
			if (this._marked) { return this };
			
			if (this._events instanceof Function) {
				if (this._events(event)) this.mark();
			} else if (this._events instanceof Array) {
				if (idx$(($1 = event) && $1.type  &&  $1.type(),this._events) >= 0) this.mark();
			} else if (this._events) {
				if (event._responder) this.mark();
			};
			return this;
		};
		return Imba.Scheduler;
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		Imba.static = function (items,nr){
			items.static = nr;
			return items;
		};
		
		/*
		This is the baseclass that all tags in imba inherit from.
		@iname node
		*/
		
		Imba.Tag = function Tag(dom){
			this.setDom(dom);
		};
		
		Imba.Tag.createNode = function (){
			throw "Not implemented";
		};
		
		Imba.Tag.build = function (){
			return new this(this.createNode());
		};
		
		
		
		Imba.Tag.prototype.object = function(v){ return this._object; }
		Imba.Tag.prototype.setObject = function(v){ this._object = v; return this; };
		
		Imba.Tag.prototype.dom = function (){
			return this._dom;
		};
		
		Imba.Tag.prototype.setDom = function (dom){
			dom._tag = this;
			this._dom = dom;
			return this;
		};
		
		/*
			Setting references for tags like
			`<div@header>` will compile to `tag('div').setRef('header',this).end()`
			By default it adds the reference as a className to the tag.
			@return {self}
			*/
		
		Imba.Tag.prototype.setRef = function (ref,ctx){
			this.flag(this._ref = ref);
			return this;
		};
		
		/*
			Method that is called by the compiled tag-chains, for
			binding events on tags to methods etc.
			`<a :tap=fn>` compiles to `tag('a').setHandler('tap',fn,this).end()`
			where this refers to the context in which the tag is created.
			@return {self}
			*/
		
		Imba.Tag.prototype.setHandler = function (event,handler,ctx){
			var key = 'on' + event;
			
			if (handler instanceof Function) {
				this[key] = handler;
			} else if (handler instanceof Array) {
				var fn = handler.shift();
				this[key] = function(e) { return ctx[fn].apply(ctx,handler.concat(e)); };
			} else {
				this[key] = function(e) { return ctx[handler](e); };
			};
			return this;
		};
		
		Imba.Tag.prototype.setId = function (id){
			this.dom().id = id;
			return this;
		};
		
		Imba.Tag.prototype.id = function (){
			return this.dom().id;
		};
		
		/*
			Adds a new attribute or changes the value of an existing attribute
			on the specified tag. If the value is null or false, the attribute
			will be removed.
			@return {self}
			*/
		
		Imba.Tag.prototype.setAttribute = function (name,value){
			// should this not return self?
			var old = this.dom().getAttribute(name);
			
			if (old == value) {
				return value;
			} else if (value != null && value !== false) {
				return this.dom().setAttribute(name,value);
			} else {
				return this.dom().removeAttribute(name);
			};
		};
		
		/*
			removes an attribute from the specified tag
			*/
		
		Imba.Tag.prototype.removeAttribute = function (name){
			return this.dom().removeAttribute(name);
		};
		
		/*
			returns the value of an attribute on the tag.
			If the given attribute does not exist, the value returned
			will either be null or "" (the empty string)
			*/
		
		Imba.Tag.prototype.getAttribute = function (name){
			return this.dom().getAttribute(name);
		};
		
		/*
			Override this to provide special wrapping etc.
			@return {self}
			*/
		
		Imba.Tag.prototype.setContent = function (content,type){
			this.setChildren(content,type);
			return this;
		};
		
		/*
			Set the children of node. type param is optional,
			and should only be used by Imba when compiling tag trees. 
			@return {self}
			*/
		
		Imba.Tag.prototype.setChildren = function (nodes,type){
			throw "Not implemented";
		};
		
		/*
			Get text of node. Uses textContent behind the scenes (not innerText)
			[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()
			@return {string} inner text of node
			*/
		
		Imba.Tag.prototype.text = function (v){
			return this._dom.textContent;
		};
		
		/*
			Set text of node. Uses textContent behind the scenes (not innerText)
			[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()
			*/
		
		Imba.Tag.prototype.setText = function (txt){
			this._empty = false;
			this._dom.textContent = txt == null ? (txt = "") : (txt);
			return this;
		};
		
		
		/*
			Method for getting and setting data-attributes. When called with zero
			arguments it will return the actual dataset for the tag.
		
				var node = <div data-name='hello'>
				# get the whole dataset
				node.dataset # {name: 'hello'}
				# get a single value
				node.dataset('name') # 'hello'
				# set a single value
				node.dataset('name','newname') # self
		
		
			*/
		
		Imba.Tag.prototype.dataset = function (key,val){
			throw "Not implemented";
		};
		
		/*
			Empty placeholder. Override to implement custom render behaviour.
			Works much like the familiar render-method in React.
			@return {self}
			*/
		
		Imba.Tag.prototype.render = function (){
			return this;
		};
		
		/*
			Called implicitly through Imba.Tag#end, upon creating a tag. All
			properties will have been set before build is called, including
			setContent.
			@return {self}
			*/
		
		Imba.Tag.prototype.build = function (){
			this.render();
			return this;
		};
		
		/*
			Called implicitly through Imba.Tag#end, for tags that are part of
			a tag tree (that are rendered several times).
			@return {self}
			*/
		
		Imba.Tag.prototype.commit = function (){
			this.render();
			return this;
		};
		
		/*
		
			Called by the tag-scheduler (if this tag is scheduled)
			By default it will call this.render. Do not override unless
			you really understand it.
		
			*/
		
		Imba.Tag.prototype.tick = function (){
			this.render();
			return this;
		};
		
		/*
			
			A very important method that you will practically never manually.
			The tag syntax of Imba compiles to a chain of setters, which always
			ends with .end. `<a.large>` compiles to `tag('a').flag('large').end()`
			
			You are highly adviced to not override its behaviour. The first time
			end is called it will mark the tag as built and call Imba.Tag#build,
			and call Imba.Tag#commit on subsequent calls.
			@return {self}
			*/
		
		Imba.Tag.prototype.end = function (){
			if (this._built) {
				this.commit();
			} else {
				this._built = true;
				this.build();
			};
			return this;
		};
		
		/*
			This is called instead of Imba.Tag#end for `<self>` tag chains.
			Defaults to noop
			@return {self}
			*/
		
		Imba.Tag.prototype.synced = function (){
			return this;
		};
		
		// called when the node is awakened in the dom - either automatically
		// upon attachment to the dom-tree, or the first time imba needs the
		// tag for a domnode that has been rendered on the server
		Imba.Tag.prototype.awaken = function (){
			return this;
		};
		
		/*
			List of flags for this node. 
			*/
		
		Imba.Tag.prototype.flags = function (){
			return this._dom.classList;
		};
		
		/*
			Add speficied flag to current node.
			If a second argument is supplied, it will be coerced into a Boolean,
			and used to indicate whether we should remove the flag instead.
			@return {self}
			*/
		
		Imba.Tag.prototype.flag = function (name,toggler){
			// it is most natural to treat a second undefined argument as a no-switch
			// so we need to check the arguments-length
			if (arguments.length == 2 && !toggler) {
				this._dom.classList.remove(name);
			} else {
				this._dom.classList.add(name);
			};
			return this;
		};
		
		/*
			Remove specified flag from node
			@return {self}
			*/
		
		Imba.Tag.prototype.unflag = function (name){
			this._dom.classList.remove(name);
			return this;
		};
		
		/*
			Toggle specified flag on node
			@return {self}
			*/
		
		Imba.Tag.prototype.toggleFlag = function (name){
			this._dom.classList.toggle(name);
			return this;
		};
		
		/*
			Check whether current node has specified flag
			@return {bool}
			*/
		
		Imba.Tag.prototype.hasFlag = function (name){
			return this._dom.classList.contains(name);
		};
		
		/*
			Get the scheduler for this node. A new scheduler will be created
			if it does not already exist.
		
			@return {Imba.Scheduler}
			*/
		
		Imba.Tag.prototype.scheduler = function (){
			return this._scheduler == null ? (this._scheduler = new Imba.Scheduler(this)) : (this._scheduler);
		};
		
		/*
		
			Shorthand to start scheduling a node. The method will basically
			proxy the arguments through to scheduler.configure, and then
			activate the scheduler.
			
			@return {self}
			*/
		
		Imba.Tag.prototype.schedule = function (options){
			if(options === undefined) options = {};
			this.scheduler().configure(options).activate();
			return this;
		};
		
		/*
			Shorthand for deactivating scheduler (if tag has one).
			@deprecated
			*/
		
		Imba.Tag.prototype.unschedule = function (){
			if (this._scheduler) { this.scheduler().deactivate() };
			return this;
		};
		
		
		/*
			Get the parent of current node
			@return {Imba.Tag} 
			*/
		
		Imba.Tag.prototype.parent = function (){
			return tag$wrap(this.dom().parentNode);
		};
		
		/*
			Shorthand for console.log on elements
			@return {self}
			*/
		
		Imba.Tag.prototype.log = function (){
			var $0 = arguments, i = $0.length;
			var args = new Array(i>0 ? i : 0);
			while(i>0) args[i-1] = $0[--i];
			args.unshift(console);
			Function.prototype.call.apply(console.log,args);
			return this;
		};
		
		
		Imba.Tag.prototype.initialize = Imba.Tag;
		
		HTML_TAGS = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");
		HTML_TAGS_UNSAFE = "article aside header section".split(" ");
		SVG_TAGS = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
		
		
		function extender(obj,sup){
			for (var i = 0, keys = Object.keys(sup), l = keys.length; i < l; i++){
				obj[($1 = keys[i])] == null ? (obj[$1] = sup[keys[i]]) : (obj[$1]);
			};
			
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
			if (sup.inherit) { sup.inherit(obj) };
			return obj;
		};
		
		function Tag(){
			return function(dom) {
				this.setDom(dom);
				return this;
			};
		};
		
		function TagSpawner(type){
			return function() { return type.build(); };
		};
		
		Imba.Tags = function Tags(){
			this;
		};
		
		Imba.Tags.prototype.__clone = function (ns){
			var clone = Object.create(this);
			clone._parent = this;
			return clone;
		};
		
		Imba.Tags.prototype.defineNamespace = function (name){
			var clone = Object.create(this);
			clone._parent = this;
			clone._ns = name;
			this[name.toUpperCase()] = clone;
			return clone;
		};
		
		Imba.Tags.prototype.baseType = function (name){
			return idx$(name,HTML_TAGS) >= 0 ? ('htmlelement') : ('div');
		};
		
		Imba.Tags.prototype.defineTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			supr || (supr = this.baseType(name));
			var supertype = this[supr];
			var tagtype = Tag();
			var norm = name.replace(/\-/g,'_');
			
			
			tagtype._name = name;
			extender(tagtype,supertype);
			
			if (name[0] == '#') {
				this[name] = tagtype;
				Imba.SINGLETONS[name.slice(1)] = tagtype;
			} else {
				this[name] = tagtype;
				this['$' + norm] = TagSpawner(tagtype);
			};
			
			if (body) {
				if (body.length == 2) {
					// create clone
					if (!tagtype.hasOwnProperty('TAGS')) {
						tagtype.TAGS = (supertype.TAGS || this).__clone();
					};
				};
				
				body.call(tagtype,tagtype,tagtype.TAGS || this);
			};
			
			return tagtype;
		};
		
		Imba.Tags.prototype.defineSingleton = function (name,supr,body){
			return this.defineTag(name,supr,body);
		};
		
		Imba.Tags.prototype.extendTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			var klass = ((typeof name=='string'||name instanceof String) ? (this[name]) : (name));
			// allow for private tags here as well?
			if (body) { body && body.call(klass,klass,klass.prototype) };
			return klass;
		};
		
		
		Imba.TAGS = new Imba.Tags();
		Imba.TAGS.element = Imba.Tag;
		
		var svg = Imba.TAGS.defineNamespace('svg');
		
		svg.baseType = function (name){
			return 'svgelement';
		};
		
		
		Imba.SINGLETONS = {};
		
		
		Imba.defineTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			return Imba.TAGS.defineTag(name,supr,body);
		};
		
		Imba.defineSingletonTag = function (id,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = 'div';
			if(supr==undefined) supr = 'div';
			return Imba.TAGS.defineTag(this.name(),supr,body);
		};
		
		Imba.extendTag = function (name,body){
			return Imba.TAGS.extendTag(name,body);
		};
		
		Imba.tag = function (name){
			var typ = Imba.TAGS[name];
			if (!typ) { throw new Error(("tag " + name + " is not defined")) };
			return new typ(typ.createNode());
		};
		
		Imba.tagWithId = function (name,id){
			var typ = Imba.TAGS[name];
			if (!typ) { throw new Error(("tag " + name + " is not defined")) };
			var dom = typ.createNode();
			dom.id = id;
			return new typ(dom);
		};
		
		// TODO: Can we move these out and into dom.imba in a clean way?
		// These methods depends on Imba.document.getElementById
		
		Imba.getTagSingleton = function (id){
			var klass;
			var dom,node;
			
			if (klass = Imba.SINGLETONS[id]) {
				if (klass && klass.Instance) { return klass.Instance };
				
				// no instance - check for element
				if (dom = Imba.document().getElementById(id)) {
					// we have a live instance - when finding it through a selector we should awake it, no?
					// console.log('creating the singleton from existing node in dom?',id,type)
					node = klass.Instance = new klass(dom);
					node.awaken(dom); // should only awaken
					return node;
				};
				
				dom = klass.createNode();
				dom.id = id;
				node = klass.Instance = new klass(dom);
				node.end().awaken(dom);
				return node;
			} else if (dom = Imba.document().getElementById(id)) {
				return Imba.getTagForDom(dom);
			};
		};
		
		var svgSupport = typeof SVGElement !== 'undefined';
		
		Imba.getTagForDom = function (dom){
			var m;
			if (!dom) { return null };
			if (dom._dom) { return dom }; // could use inheritance instead
			if (dom._tag) { return dom._tag };
			if (!dom.nodeName) { return null };
			
			var ns = null;
			var id = dom.id;
			var type = dom.nodeName.toLowerCase();
			var tags = Imba.TAGS;
			var native$ = type;
			var cls = dom.className;
			
			if (id && Imba.SINGLETONS[id]) {
				// FIXME control that it is the same singleton?
				// might collide -- not good?
				return Imba.getTagSingleton(id);
			};
			// look for id - singleton
			
			// need better test here
			if (svgSupport && (dom instanceof SVGElement)) {
				ns = "svg";
				cls = dom.className.baseVal;
				tags = tags.SVG;
			};
			
			var spawner;
			
			if (cls) {
				// there can be several matches here - should choose the last
				// should fall back to less specific later? - otherwise things may fail
				// TODO rework this
				if (m = cls.match(/\b_([a-z\-]+)\b(?!\s*_[a-z\-]+)/)) {
					type = m[1]; // .replace(/-/g,'_')
				};
				
				if (m = cls.match(/\b([A-Z\-]+)_\b/)) {
					ns = m[1];
				};
			};
			
			
			spawner = tags[type] || tags[native$];
			return spawner ? (new spawner(dom).awaken(dom)) : (null);
		};
		
		tag$ = Imba.TAGS;
		t$ = Imba.tag;
		tc$ = Imba.tagWithFlags;
		ti$ = Imba.tagWithId;
		tic$ = Imba.tagWithIdAndFlags;
		id$ = Imba.getTagSingleton;
		return tag$wrap = Imba.getTagForDom;
		
	
	})()

/***/ },
/* 6 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		Imba.document = function (){
			return window.document;
		};
		
		/*
		Returns the body element wrapped in an Imba.Tag
		*/
		
		Imba.root = function (){
			return tag$wrap(Imba.document().body);
		};
		
		tag$.defineTag('htmlelement', 'element', function(tag){
			
			/*
				Called when a tag type is being subclassed.
				*/
			
			tag.inherit = function (child){
				child.prototype._empty = true;
				child._protoDom = null;
				
				if (this._nodeType) {
					child._nodeType = this._nodeType;
					
					var className = "_" + child._name.replace(/_/g,'-');
					if (child._name[0] != '#') { return child._classes = this._classes.concat(className) };
				} else {
					child._nodeType = child._name;
					return child._classes = [];
				};
			};
			
			tag.buildNode = function (){
				var dom = Imba.document().createElement(this._nodeType);
				var cls = this._classes.join(" ");
				if (cls) { dom.className = cls };
				return dom;
			};
			
			tag.createNode = function (){
				var proto = (this._protoDom || (this._protoDom = this.buildNode()));
				return proto.cloneNode(false);
			};
			
			tag.dom = function (){
				return this._protoDom || (this._protoDom = this.buildNode());
			};
			
			
			
			tag.prototype.id = function(v){ return this.getAttribute('id'); }
			tag.prototype.setId = function(v){ this.setAttribute('id',v); return this; };
			
			
			tag.prototype.tabindex = function(v){ return this.getAttribute('tabindex'); }
			tag.prototype.setTabindex = function(v){ this.setAttribute('tabindex',v); return this; };
			
			
			tag.prototype.title = function(v){ return this.getAttribute('title'); }
			tag.prototype.setTitle = function(v){ this.setAttribute('title',v); return this; };
			
			
			tag.prototype.role = function(v){ return this.getAttribute('role'); }
			tag.prototype.setRole = function(v){ this.setAttribute('role',v); return this; };
			
			tag.prototype.width = function (){
				return this._dom.offsetWidth;
			};
			
			tag.prototype.height = function (){
				return this._dom.offsetHeight;
			};
			
			tag.prototype.setChildren = function (nodes,type){
				this._empty ? (this.append(nodes)) : (this.empty().append(nodes));
				this._children = null;
				return this;
			};
			
			/*
				Set inner html of node
				*/
			
			tag.prototype.setHtml = function (html){
				this._dom.innerHTML = html;
				return this;
			};
			
			/*
				Get inner html of node
				*/
			
			tag.prototype.html = function (){
				return this._dom.innerHTML;
			};
			
			/*
				Remove all content inside node
				*/
			
			tag.prototype.empty = function (){
				while (this._dom.firstChild){
					this._dom.removeChild(this._dom.firstChild);
				};
				this._children = null;
				this._empty = true;
				return this;
			};
			
			/*
				Remove specified child from current node.
				*/
			
			tag.prototype.remove = function (child){
				var par = this.dom();
				var el = child && child.dom();
				if (el && el.parentNode == par) { par.removeChild(el) };
				return this;
			};
			
			tag.prototype.emit = function (name,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var data = pars.data !== undefined ? pars.data : null;
				var bubble = pars.bubble !== undefined ? pars.bubble : true;
				Imba.Events.trigger(name,this,{data: data,bubble: bubble});
				return this;
			};
			
			tag.prototype.css = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.css(keys[i],key[keys[i]]);
					};
				} else if (val == null) {
					this.dom().style.removeProperty(key);
				} else if (val == undefined) {
					return this.dom().style[key];
				} else {
					if ((typeof val=='number'||val instanceof Number) && key.match(/width|height|left|right|top|bottom/)) {
						val = val + "px";
					};
					this.dom().style[key] = val;
				};
				return this;
			};
			
			tag.prototype.dataset = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.dataset(keys[i],key[keys[i]]);
					};
					return this;
				};
				
				if (arguments.length == 2) {
					this.setAttribute(("data-" + key),val);
					return this;
				};
				
				if (key) {
					return this.getAttribute(("data-" + key));
				};
				
				var dataset = this.dom().dataset;
				
				if (!dataset) {
					dataset = {};
					for (var i1 = 0, ary = iter$(this.dom().attributes), len = ary.length, atr; i1 < len; i1++) {
						atr = ary[i1];
						if (atr.name.substr(0,5) == 'data-') {
							dataset[Imba.toCamelCase(atr.name.slice(5))] = atr.value;
						};
					};
				};
				
				return dataset;
			};
			
			/*
				Get descendants of current node, optionally matching selector
				@return {Imba.Selector}
				*/
			
			tag.prototype.find = function (sel){
				return new Imba.Selector(sel,this);
			};
			
			/*
				Get the first matching child of node
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.first = function (sel){
				return sel ? (this.find(sel).first()) : (tag$wrap(this.dom().firstElementChild));
			};
			
			/*
				Get the last matching child of node
			
					node.last # returns the last child of node
					node.last %span # returns the last span inside node
					node.last do |el| el.text == 'Hi' # return last node with text Hi
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.last = function (sel){
				return sel ? (this.find(sel).last()) : (tag$wrap(this.dom().lastElementChild));
			};
			
			/*
				Get the child at index
				*/
			
			tag.prototype.child = function (i){
				return tag$wrap(this.dom().children[i || 0]);
			};
			
			tag.prototype.children = function (sel){
				var nodes = new Imba.Selector(null,this,this._dom.children);
				return sel ? (nodes.filter(sel)) : (nodes);
			};
			
			tag.prototype.orphanize = function (){
				var par;
				if (par = this.dom().parentNode) { par.removeChild(this._dom) };
				return this;
			};
			
			tag.prototype.matches = function (sel){
				var fn;
				if (sel instanceof Function) {
					return sel(this);
				};
				
				if (sel.query) { sel = sel.query() };
				if (fn = (this._dom.webkitMatchesSelector || this._dom.matches)) { return fn.call(this._dom,sel) };
				// TODO support other browsers etc?
			};
			
			/*
				Get the first element matching supplied selector / filter
				traversing upwards, but including the node itself.
				@return {Imba.Tag}
				*/
			
			tag.prototype.closest = function (sel){
				if (!sel) { return this.parent() }; // should return self?!
				var node = this;
				if (sel.query) { sel = sel.query() };
				
				while (node){
					if (node.matches(sel)) { return node };
					node = node.parent();
				};
				return null;
			};
			
			/*
				Get the closest ancestor of node that matches
				specified selector / matcher.
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.up = function (sel){
				if (!sel) { return this.parent() };
				return this.parent() && this.parent().closest(sel);
			};
			
			tag.prototype.path = function (sel){
				var node = this;
				var nodes = [];
				if (sel && sel.query) { sel = sel.query() };
				
				while (node){
					if (!sel || node.matches(sel)) { nodes.push(node) };
					node = node.parent();
				};
				return nodes;
			};
			
			tag.prototype.parents = function (sel){
				var par = this.parent();
				return par ? (par.path(sel)) : ([]);
			};
			
			
			
			tag.prototype.siblings = function (sel){
				var par, self = this;
				if (!(par = this.parent())) { return [] }; // FIXME
				var ary = this.dom().parentNode.children;
				var nodes = new Imba.Selector(null,this,ary);
				return nodes.filter(function(n) { return n != self && (!sel || n.matches(sel)); });
			};
			
			/*
				Get the immediately following sibling of node.
				*/
			
			tag.prototype.next = function (sel){
				if (sel) {
					var el = this;
					while (el = el.next()){
						if (el.matches(sel)) { return el };
					};
					return null;
				};
				return tag$wrap(this.dom().nextElementSibling);
			};
			
			/*
				Get the immediately preceeding sibling of node.
				*/
			
			tag.prototype.prev = function (sel){
				if (sel) {
					var el = this;
					while (el = el.prev()){
						if (el.matches(sel)) { return el };
					};
					return null;
				};
				return tag$wrap(this.dom().previousElementSibling);
			};
			
			tag.prototype.contains = function (node){
				return this.dom().contains(node && node._dom || node);
			};
			
			tag.prototype.index = function (){
				var i = 0;
				var el = this.dom();
				while (el.previousSibling){
					el = el.previousSibling;
					i++;
				};
				return i;
			};
			
			
			/*
				
				@deprecated
				*/
			
			tag.prototype.insert = function (node,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var before = pars.before !== undefined ? pars.before : null;
				var after = pars.after !== undefined ? pars.after : null;
				if (after) { before = after.next() };
				if (node instanceof Array) {
					node = (tag$.$fragment().setContent(node,0).end());
				};
				if (before) {
					this.dom().insertBefore(node.dom(),before.dom());
				} else {
					this.append(node);
				};
				return this;
			};
			
			/*
				Focus on current node
				@return {self}
				*/
			
			tag.prototype.focus = function (){
				this.dom().focus();
				return this;
			};
			
			/*
				Remove focus from current node
				@return {self}
				*/
			
			tag.prototype.blur = function (){
				this.dom().blur();
				return this;
			};
			
			tag.prototype.template = function (){
				return null;
			};
			
			/*
				@todo Should support multiple arguments like append
			
				The .prepend method inserts the specified content as the first
				child of the target node. If the content is already a child of 
				node it will be moved to the start.
				
			    	node.prepend <div.top> # prepend node
			    	node.prepend "some text" # prepend text
			    	node.prepend [<ul>,<ul>] # prepend array
			
				*/
			
			tag.prototype.prepend = function (item){
				var first = this._dom.childNodes[0];
				first ? (this.insertBefore(item,first)) : (this.appendChild(item));
				return this;
			};
			
			/*
				The .append method inserts the specified content as the last child
				of the target node. If the content is already a child of node it
				will be moved to the end.
				
				# example
				    var root = <div.root>
				    var item = <div.item> "This is an item"
				    root.append item # appends item to the end of root
			
				    root.prepend "some text" # append text
				    root.prepend [<ul>,<ul>] # append array
				*/
			
			tag.prototype.append = function (item){
				// possible to append blank
				// possible to simplify on server?
				if (!item) { return this };
				
				if (item instanceof Array) {
					for (var i = 0, ary = iter$(item), len = ary.length, member; i < len; i++) {
						member = ary[i];
						member && this.append(member);
					};
				} else if ((typeof item=='string'||item instanceof String) || (typeof item=='number'||item instanceof Number)) {
					var node = Imba.document().createTextNode(item);
					this._dom.appendChild(node);
					if (this._empty) { this._empty = false };
				} else {
					this._dom.appendChild(item._dom || item);
					if (this._empty) { this._empty = false };
				};
				
				return this;
			};
			
			/*
				Insert a node into the current node (self), before another.
				The relative node must be a child of current node. 
				*/
			
			tag.prototype.insertBefore = function (node,rel){
				if ((typeof node=='string'||node instanceof String)) { node = Imba.document().createTextNode(node) };
				if (node && rel) { this.dom().insertBefore((node._dom || node),(rel._dom || rel)) };
				return this;
			};
			
			/*
				Append a single item (node or string) to the current node.
				If supplied item is a string it will automatically. This is used
				by Imba internally, but will practically never be used explicitly.
				*/
			
			tag.prototype.appendChild = function (node){
				if ((typeof node=='string'||node instanceof String)) { node = Imba.document().createTextNode(node) };
				if (node) { this.dom().appendChild(node._dom || node) };
				return this;
			};
			
			/*
				Remove a single child from the current node.
				Used by Imba internally.
				*/
			
			tag.prototype.removeChild = function (node){
				if (node) { this.dom().removeChild(node._dom || node) };
				return this;
			};
			
			tag.prototype.toString = function (){
				return this._dom.toString(); // really?
			};
			
			/*
				@deprecated
				*/
			
			tag.prototype.classes = function (){
				console.log('Imba.Tag#classes is deprecated');
				return this._dom.classList;
			};
		});
		
		return tag$.defineTag('svgelement', 'htmlelement');
	
	})()

/***/ },
/* 7 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// Extending Imba.Tag#css to work without prefixes by inspecting
		// the properties of a CSSStyleDeclaration and creating a map
		
		// var prefixes = ['-webkit-','-ms-','-moz-','-o-','-blink-']
		// var props = ['transform','transition','animation']
		
		var styles = window.getComputedStyle(document.documentElement,'');
		
		Imba.CSSKeyMap = {};
		
		for (var i = 0, ary = iter$(styles), len = ary.length, prefixed; i < len; i++) {
			prefixed = ary[i];
			var unprefixed = prefixed.replace(/^-(webkit|ms|moz|o|blink)-/,'');
			var camelCase = unprefixed.replace(/-(\w)/g,function(m,a) { return a.toUpperCase(); });
			
			// if there exists an unprefixed version -- always use this
			if (prefixed != unprefixed) {
				if (styles.hasOwnProperty(unprefixed)) { continue; };
			};
			
			// register the prefixes
			Imba.CSSKeyMap[unprefixed] = Imba.CSSKeyMap[camelCase] = prefixed;
		};
		
		return tag$.extendTag('htmlelement', function(tag){
			
			// override the original css method
			tag.prototype.css = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.css(keys[i],key[keys[i]]);
					};
					return this;
				};
				
				key = Imba.CSSKeyMap[key] || key;
				
				if (val == null) {
					this.dom().style.removeProperty(key);
				} else if (val == undefined) {
					return this.dom().style[key];
				} else {
					if ((typeof val=='number'||val instanceof Number) && key.match(/width|height|left|right|top|bottom/)) {
						val = val + "px";
					};
					this.dom().style[key] = val;
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 8 */
/***/ function(module, exports) {

	(function(){
		
		// predefine all supported html tags
		tag$.defineTag('fragment', 'htmlelement', function(tag){
			
			tag.createNode = function (){
				return Imba.document().createDocumentFragment();
			};
		});
		
		tag$.defineTag('a', function(tag){
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
		});
		
		tag$.defineTag('abbr');
		tag$.defineTag('address');
		tag$.defineTag('area');
		tag$.defineTag('article');
		tag$.defineTag('aside');
		tag$.defineTag('audio');
		tag$.defineTag('b');
		tag$.defineTag('base');
		tag$.defineTag('bdi');
		tag$.defineTag('bdo');
		tag$.defineTag('big');
		tag$.defineTag('blockquote');
		tag$.defineTag('body');
		tag$.defineTag('br');
		
		tag$.defineTag('button', function(tag){
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
		});
		
		tag$.defineTag('canvas', function(tag){
			tag.prototype.setWidth = function (val){
				if (this.width() != val) { this.dom().width = val };
				return this;
			};
			
			tag.prototype.setHeight = function (val){
				if (this.height() != val) { this.dom().height = val };
				return this;
			};
			
			tag.prototype.width = function (){
				return this.dom().width;
			};
			
			tag.prototype.height = function (){
				return this.dom().height;
			};
			
			tag.prototype.context = function (type){
				if(type === undefined) type = '2d';
				return this.dom().getContext(type);
			};
		});
		
		tag$.defineTag('caption');
		tag$.defineTag('cite');
		tag$.defineTag('code');
		tag$.defineTag('col');
		tag$.defineTag('colgroup');
		tag$.defineTag('data');
		tag$.defineTag('datalist');
		tag$.defineTag('dd');
		tag$.defineTag('del');
		tag$.defineTag('details');
		tag$.defineTag('dfn');
		tag$.defineTag('div');
		tag$.defineTag('dl');
		tag$.defineTag('dt');
		tag$.defineTag('em');
		tag$.defineTag('embed');
		tag$.defineTag('fieldset');
		tag$.defineTag('figcaption');
		tag$.defineTag('figure');
		tag$.defineTag('footer');
		
		tag$.defineTag('form', function(tag){
			
			
			tag.prototype.method = function(v){ return this.getAttribute('method'); }
			tag.prototype.setMethod = function(v){ this.setAttribute('method',v); return this; };
			
			
			tag.prototype.action = function(v){ return this.getAttribute('action'); }
			tag.prototype.setAction = function(v){ this.setAttribute('action',v); return this; };
		});
		
		tag$.defineTag('h1');
		tag$.defineTag('h2');
		tag$.defineTag('h3');
		tag$.defineTag('h4');
		tag$.defineTag('h5');
		tag$.defineTag('h6');
		tag$.defineTag('head');
		tag$.defineTag('header');
		tag$.defineTag('hr');
		tag$.defineTag('html');
		tag$.defineTag('i');
		
		tag$.defineTag('iframe', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
		});
		
		tag$.defineTag('img', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
		});
		
		tag$.defineTag('input', function(tag){
			// can use attr instead
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
			
			tag.prototype.setPlaceholder = function (v){
				if (v != this.dom().placeholder) { this.dom().placeholder = v };
				return this;
			};
			
			tag.prototype.placeholder = function (){
				return this.dom().placeholder;
			};
			
			tag.prototype.checked = function (){
				return this.dom().checked;
			};
			
			tag.prototype.setChecked = function (bool){
				if (bool != this.dom().checked) { this.dom().checked = bool };
				return this;
			};
		});
		
		tag$.defineTag('ins');
		tag$.defineTag('kbd');
		tag$.defineTag('keygen');
		tag$.defineTag('label');
		tag$.defineTag('legend');
		tag$.defineTag('li');
		
		tag$.defineTag('link', function(tag){
			
			
			tag.prototype.rel = function(v){ return this.getAttribute('rel'); }
			tag.prototype.setRel = function(v){ this.setAttribute('rel',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
			
			
			tag.prototype.media = function(v){ return this.getAttribute('media'); }
			tag.prototype.setMedia = function(v){ this.setAttribute('media',v); return this; };
		});
		
		tag$.defineTag('main');
		tag$.defineTag('map');
		tag$.defineTag('mark');
		tag$.defineTag('menu');
		tag$.defineTag('menuitem');
		
		tag$.defineTag('meta', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.content = function(v){ return this.getAttribute('content'); }
			tag.prototype.setContent = function(v){ this.setAttribute('content',v); return this; };
			
			
			tag.prototype.charset = function(v){ return this.getAttribute('charset'); }
			tag.prototype.setCharset = function(v){ this.setAttribute('charset',v); return this; };
		});
		
		tag$.defineTag('meter');
		tag$.defineTag('nav');
		tag$.defineTag('noscript');
		tag$.defineTag('object');
		tag$.defineTag('ol');
		tag$.defineTag('optgroup');
		
		tag$.defineTag('option', function(tag){
			
			
			tag.prototype.value = function(v){ return this.getAttribute('value'); }
			tag.prototype.setValue = function(v){ this.setAttribute('value',v); return this; };
		});
		
		tag$.defineTag('output');
		tag$.defineTag('p');
		tag$.defineTag('param');
		tag$.defineTag('pre');
		tag$.defineTag('progress');
		tag$.defineTag('q');
		tag$.defineTag('rp');
		tag$.defineTag('rt');
		tag$.defineTag('ruby');
		tag$.defineTag('s');
		tag$.defineTag('samp');
		
		tag$.defineTag('script', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
		});
		
		tag$.defineTag('section');
		
		tag$.defineTag('select', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.multiple = function(v){ return this.getAttribute('multiple'); }
			tag.prototype.setMultiple = function(v){ this.setAttribute('multiple',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
		});
		
		
		tag$.defineTag('small');
		tag$.defineTag('source');
		tag$.defineTag('span');
		tag$.defineTag('strong');
		tag$.defineTag('style');
		tag$.defineTag('sub');
		tag$.defineTag('summary');
		tag$.defineTag('sup');
		tag$.defineTag('table');
		tag$.defineTag('tbody');
		tag$.defineTag('td');
		
		tag$.defineTag('textarea', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.rows = function(v){ return this.getAttribute('rows'); }
			tag.prototype.setRows = function(v){ this.setAttribute('rows',v); return this; };
			
			
			tag.prototype.cols = function(v){ return this.getAttribute('cols'); }
			tag.prototype.setCols = function(v){ this.setAttribute('cols',v); return this; };
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
			
			tag.prototype.setPlaceholder = function (v){
				if (v != this.dom().placeholder) { this.dom().placeholder = v };
				return this;
			};
			
			tag.prototype.placeholder = function (){
				return this.dom().placeholder;
			};
		});
		
		tag$.defineTag('tfoot');
		tag$.defineTag('th');
		tag$.defineTag('thead');
		tag$.defineTag('time');
		tag$.defineTag('title');
		tag$.defineTag('tr');
		tag$.defineTag('track');
		tag$.defineTag('u');
		tag$.defineTag('ul');
		tag$.defineTag('video');
		return tag$.defineTag('wbr');
	
	})()

/***/ },
/* 9 */
/***/ function(module, exports) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		
		tag$.SVG.defineTag('svgelement', function(tag){
			
			tag.namespaceURI = function (){
				return "http://www.w3.org/2000/svg";
			};
			
			var types = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
			
			tag.buildNode = function (){
				var dom = Imba.document().createElementNS(this.namespaceURI(),this._nodeType);
				var cls = this._classes.join(" ");
				if (cls) { dom.className.baseVal = cls };
				return dom;
			};
			
			tag.inherit = function (child){
				child._protoDom = null;
				
				if (idx$(child._name,types) >= 0) {
					child._nodeType = child._name;
					return child._classes = [];
				} else {
					child._nodeType = this._nodeType;
					var className = "_" + child._name.replace(/_/g,'-');
					return child._classes = this._classes.concat(className);
				};
			};
			
			
			Imba.attr(tag,'x');
			Imba.attr(tag,'y');
			
			Imba.attr(tag,'width');
			Imba.attr(tag,'height');
			
			Imba.attr(tag,'stroke');
			Imba.attr(tag,'stroke-width');
		});
		
		tag$.SVG.defineTag('svg', function(tag){
			Imba.attr(tag,'viewbox');
		});
		
		tag$.SVG.defineTag('rect');
		
		tag$.SVG.defineTag('circle', function(tag){
			Imba.attr(tag,'cx');
			Imba.attr(tag,'cy');
			Imba.attr(tag,'r');
		});
		
		tag$.SVG.defineTag('ellipse', function(tag){
			Imba.attr(tag,'cx');
			Imba.attr(tag,'cy');
			Imba.attr(tag,'rx');
			Imba.attr(tag,'ry');
		});
		
		tag$.SVG.defineTag('path', function(tag){
			Imba.attr(tag,'d');
			Imba.attr(tag,'pathLength');
		});
		
		return tag$.SVG.defineTag('line', function(tag){
			Imba.attr(tag,'x1');
			Imba.attr(tag,'x2');
			Imba.attr(tag,'y1');
			Imba.attr(tag,'y2');
		});
	
	})()

/***/ },
/* 10 */
/***/ function(module, exports) {

	(function(){
		if (!document.documentElement.classList) {
			tag$.extendTag('htmlelement', function(tag){
				
				tag.prototype.hasFlag = function (ref){
					return new RegExp('(^|\\s)' + ref + '(\\s|$)').test(this._dom.className);
				};
				
				tag.prototype.addFlag = function (ref){
					if (this.hasFlag(ref)) { return this };
					this._dom.className += (this._dom.className ? (' ') : ('')) + ref;
					return this;
				};
				
				tag.prototype.unflag = function (ref){
					if (!this.hasFlag(ref)) { return this };
					var regex = new RegExp('(^|\\s)*' + ref + '(\\s|$)*','g');
					this._dom.className = this._dom.className.replace(regex,'');
					return this;
				};
				
				tag.prototype.toggleFlag = function (ref){
					return this.hasFlag(ref) ? (this.unflag(ref)) : (this.flag(ref));
				};
				
				tag.prototype.flag = function (ref,bool){
					if (arguments.length == 2 && !!bool === false) {
						return this.unflag(ref);
					};
					return this.addFlag(ref);
				};
			});
			
			return true;
		};
	
	})()

/***/ },
/* 11 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var doc = document;
		var win = window;
		
		var hasTouchEvents = window && window.ontouchstart !== undefined;
		
		Imba.Pointer = function Pointer(){
			this.setButton(-1);
			this.setEvent({x: 0,y: 0,type: 'uninitialized'});
			return this;
		};
		
		
		
		Imba.Pointer.prototype.phase = function(v){ return this._phase; }
		Imba.Pointer.prototype.setPhase = function(v){ this._phase = v; return this; };
		
		
		Imba.Pointer.prototype.prevEvent = function(v){ return this._prevEvent; }
		Imba.Pointer.prototype.setPrevEvent = function(v){ this._prevEvent = v; return this; };
		
		
		Imba.Pointer.prototype.button = function(v){ return this._button; }
		Imba.Pointer.prototype.setButton = function(v){ this._button = v; return this; };
		
		
		Imba.Pointer.prototype.event = function(v){ return this._event; }
		Imba.Pointer.prototype.setEvent = function(v){ this._event = v; return this; };
		
		
		Imba.Pointer.prototype.dirty = function(v){ return this._dirty; }
		Imba.Pointer.prototype.setDirty = function(v){ this._dirty = v; return this; };
		
		
		Imba.Pointer.prototype.events = function(v){ return this._events; }
		Imba.Pointer.prototype.setEvents = function(v){ this._events = v; return this; };
		
		
		Imba.Pointer.prototype.touch = function(v){ return this._touch; }
		Imba.Pointer.prototype.setTouch = function(v){ this._touch = v; return this; };
		
		Imba.Pointer.prototype.update = function (e){
			this.setEvent(e);
			this.setDirty(true);
			return this;
		};
		
		// this is just for regular mouse now
		Imba.Pointer.prototype.process = function (){
			var e1 = this.event();
			
			if (this.dirty()) {
				this.setPrevEvent(e1);
				this.setDirty(false);
				
				// button should only change on mousedown etc
				if (e1.type == 'mousedown') {
					this.setButton(e1.button);
					
					// do not create touch for right click
					if (this.button() == 2 || (this.touch() && this.button() != 0)) {
						return;
					};
					
					// cancel the previous touch
					if (this.touch()) { this.touch().cancel() };
					this.setTouch(new Imba.Touch(e1,this));
					this.touch().mousedown(e1,e1);
				} else if (e1.type == 'mousemove') {
					if (this.touch()) { this.touch().mousemove(e1,e1) };
				} else if (e1.type == 'mouseup') {
					this.setButton(-1);
					
					if (this.touch() && this.touch().button() == e1.button) {
						this.touch().mouseup(e1,e1);
						this.setTouch(null);
					};
					// trigger pointerup
				};
			} else {
				if (this.touch()) { this.touch().idle() };
			};
			return this;
		};
		
		Imba.Pointer.prototype.cleanup = function (){
			return Imba.POINTERS;
		};
		
		Imba.Pointer.prototype.x = function (){
			return this.event().x;
		};
		Imba.Pointer.prototype.y = function (){
			return this.event().y;
		};
		
		// deprecated -- should remove
		Imba.Pointer.update = function (){
			// console.log('update touch')
			for (var i = 0, ary = iter$(Imba.POINTERS), len = ary.length; i < len; i++) {
				ary[i].process();
			};
			// need to be able to prevent the default behaviour of touch, no?
			win.requestAnimationFrame(Imba.Pointer.update);
			return this;
		};
		
		var lastNativeTouchTimeStamp = 0;
		var lastNativeTouchTimeout = 50;
		
		// Imba.Touch
		// Began	A finger touched the screen.
		// Moved	A finger moved on the screen.
		// Stationary	A finger is touching the screen but hasn't moved.
		// Ended	A finger was lifted from the screen. This is the final phase of a touch.
		// Canceled The system cancelled tracking for the touch.
		
		/*
		Consolidates mouse and touch events. Touch objects persist across a touch,
		from touchstart until end/cancel. When a touch starts, it will traverse
		down from the innermost target, until it finds a node that responds to
		ontouchstart. Unless the touch is explicitly redirected, the touch will
		call ontouchmove and ontouchend / ontouchcancel on the responder when appropriate.
		
			tag draggable
				# called when a touch starts
				def ontouchstart touch
					flag 'dragging'
					self
				
				# called when touch moves - same touch object
				def ontouchmove touch
					# move the node with touch
					css top: touch.dy, left: touch.dx
				
				# called when touch ends
				def ontouchend touch
					unflag 'dragging'
		
		@iname touch
		*/
		
		Imba.Touch = function Touch(event,pointer){
			// @native  = false
			this.setEvent(event);
			this.setData({});
			this.setActive(true);
			this._button = event && event.button || 0;
			this._suppress = false; // deprecated
			this._captured = false;
			this.setBubble(false);
			pointer = pointer;
			this.setUpdates(0);
			return this;
		};
		
		var touches = [];
		var count = 0;
		var identifiers = {};
		
		Imba.Touch.count = function (){
			return count;
		};
		
		Imba.Touch.lookup = function (item){
			return item && (item.__touch__ || identifiers[item.identifier]);
		};
		
		Imba.Touch.release = function (item,touch){
			var v_, $1;
			(((v_ = identifiers[item.identifier]),delete identifiers[item.identifier], v_));
			((($1 = item.__touch__),delete item.__touch__, $1));
			return;
		};
		
		Imba.Touch.ontouchstart = function (e){
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (this.lookup(t)) { continue; };
				var touch = identifiers[t.identifier] = new this(e); // (e)
				t.__touch__ = touch;
				touches.push(touch);
				count++;
				touch.touchstart(e,t);
			};
			return this;
		};
		
		Imba.Touch.ontouchmove = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchmove(e,t);
				};
			};
			
			return this;
		};
		
		Imba.Touch.ontouchend = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchend(e,t);
					this.release(t,touch);
					count--;
				};
			};
			
			// e.preventDefault
			// not always supported!
			// touches = touches.filter(||)
			return this;
		};
		
		Imba.Touch.ontouchcancel = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchcancel(e,t);
					this.release(t,touch);
					count--;
				};
			};
			return this;
		};
		
		Imba.Touch.onmousedown = function (e){
			return this;
		};
		
		Imba.Touch.onmousemove = function (e){
			return this;
		};
		
		Imba.Touch.onmouseup = function (e){
			return this;
		};
		
		
		
		
		Imba.Touch.prototype.phase = function(v){ return this._phase; }
		Imba.Touch.prototype.setPhase = function(v){ this._phase = v; return this; };
		
		
		Imba.Touch.prototype.active = function(v){ return this._active; }
		Imba.Touch.prototype.setActive = function(v){ this._active = v; return this; };
		
		
		Imba.Touch.prototype.event = function(v){ return this._event; }
		Imba.Touch.prototype.setEvent = function(v){ this._event = v; return this; };
		
		
		Imba.Touch.prototype.pointer = function(v){ return this._pointer; }
		Imba.Touch.prototype.setPointer = function(v){ this._pointer = v; return this; };
		
		
		Imba.Touch.prototype.target = function(v){ return this._target; }
		Imba.Touch.prototype.setTarget = function(v){ this._target = v; return this; };
		
		
		Imba.Touch.prototype.handler = function(v){ return this._handler; }
		Imba.Touch.prototype.setHandler = function(v){ this._handler = v; return this; };
		
		
		Imba.Touch.prototype.updates = function(v){ return this._updates; }
		Imba.Touch.prototype.setUpdates = function(v){ this._updates = v; return this; };
		
		
		Imba.Touch.prototype.suppress = function(v){ return this._suppress; }
		Imba.Touch.prototype.setSuppress = function(v){ this._suppress = v; return this; };
		
		
		Imba.Touch.prototype.data = function(v){ return this._data; }
		Imba.Touch.prototype.setData = function(v){ this._data = v; return this; };
		
		Imba.Touch.prototype.__bubble = {chainable: true,name: 'bubble'};
		Imba.Touch.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }
		Imba.Touch.prototype.setBubble = function(v){ this._bubble = v; return this; };
		
		
		
		Imba.Touch.prototype.gestures = function(v){ return this._gestures; }
		Imba.Touch.prototype.setGestures = function(v){ this._gestures = v; return this; };
		
		/*
			
		
			@internal
			@constructor
			*/
		
		Imba.Touch.prototype.capture = function (){
			this._captured = true;
			this._event && this._event.preventDefault();
			return this;
		};
		
		Imba.Touch.prototype.isCaptured = function (){
			return !!this._captured;
		};
		
		/*
			Extend the touch with a plugin / gesture. 
			All events (touchstart,move etc) for the touch
			will be triggered on the plugins in the order they
			are added.
			*/
		
		Imba.Touch.prototype.extend = function (plugin){
			// console.log "added gesture!!!"
			this._gestures || (this._gestures = []);
			this._gestures.push(plugin);
			return this;
		};
		
		/*
			Redirect touch to specified target. ontouchstart will always be
			called on the new target.
			@return {Number}
			*/
		
		Imba.Touch.prototype.redirect = function (target){
			this._redirect = target;
			return this;
		};
		
		/*
			Suppress the default behaviour. Will call preventDefault for
			all native events that are part of the touch.
			*/
		
		Imba.Touch.prototype.suppress = function (){
			// collision with the suppress property
			this._active = false;
			return this;
		};
		
		Imba.Touch.prototype.setSuppress = function (value){
			console.warn('Imba.Touch#suppress= is deprecated');
			this._supress = value;
			return this;
		};
		
		Imba.Touch.prototype.touchstart = function (e,t){
			this._event = e;
			this._touch = t;
			this._button = 0;
			this._x = t.clientX;
			this._y = t.clientY;
			this.began();
			if (e && this.isCaptured()) { e.preventDefault() };
			return this;
		};
		
		Imba.Touch.prototype.touchmove = function (e,t){
			this._event = e;
			this._x = t.clientX;
			this._y = t.clientY;
			this.update();
			if (e && this.isCaptured()) { e.preventDefault() };
			return this;
		};
		
		Imba.Touch.prototype.touchend = function (e,t){
			this._event = e;
			this._x = t.clientX;
			this._y = t.clientY;
			this.ended();
			
			lastNativeTouchTimeStamp = e.timeStamp;
			
			if (this._maxdr < 20) {
				var tap = new Imba.Event(e);
				tap.setType('tap');
				tap.process();
				if (tap._responder) { e.preventDefault() };
			};
			
			if (e && this.isCaptured()) {
				e.preventDefault();
			};
			
			return this;
		};
		
		Imba.Touch.prototype.touchcancel = function (e,t){
			return this.cancel();
		};
		
		Imba.Touch.prototype.mousedown = function (e,t){
			var self = this;
			self._event = e;
			self._button = e.button;
			self._x = t.clientX;
			self._y = t.clientY;
			self.began();
			
			self._mousemove = function(e) { return self.mousemove(e,e); };
			doc.addEventListener('mousemove',self._mousemove,true);
			return self;
		};
		
		Imba.Touch.prototype.mousemove = function (e,t){
			this._x = t.clientX;
			this._y = t.clientY;
			this._event = e;
			if (this.isCaptured()) { e.preventDefault() };
			this.update();
			this.move();
			return this;
		};
		
		Imba.Touch.prototype.mouseup = function (e,t){
			this._x = t.clientX;
			this._y = t.clientY;
			this.ended();
			doc.removeEventListener('mousemove',this._mousemove,true);
			this._mousemove = null;
			return this;
		};
		
		Imba.Touch.prototype.idle = function (){
			return this.update();
		};
		
		Imba.Touch.prototype.began = function (){
			this._maxdr = this._dr = 0;
			this._x0 = this._x;
			this._y0 = this._y;
			
			var dom = this.event().target;
			var node = null;
			
			this._sourceTarget = dom && tag$wrap(dom);
			
			while (dom){
				node = tag$wrap(dom);
				if (node && node.ontouchstart) {
					this._bubble = false;
					this.setTarget(node);
					this.target().ontouchstart(this);
					if (!this._bubble) { break; };
				};
				dom = dom.parentNode;
			};
			
			this._updates++;
			return this;
		};
		
		Imba.Touch.prototype.update = function (){
			var target_;
			if (!this._active) { return this };
			
			var dr = Math.sqrt(this.dx() * this.dx() + this.dy() * this.dy());
			if (dr > this._dr) { this._maxdr = dr };
			this._dr = dr;
			
			// catching a touch-redirect?!?
			if (this._redirect) {
				if (this._target && this._target.ontouchcancel) {
					this._target.ontouchcancel(this);
				};
				this.setTarget(this._redirect);
				this._redirect = null;
				if (this.target().ontouchstart) { this.target().ontouchstart(this) };
			};
			
			
			this._updates++;
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length; i < len; i++) {
					ary[i].ontouchupdate(this);
				};
			};
			
			(target_ = this.target()) && target_.ontouchupdate  &&  target_.ontouchupdate(this);
			return this;
		};
		
		Imba.Touch.prototype.move = function (){
			var target_;
			if (!this._active) { return this };
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length, g; i < len; i++) {
					g = ary[i];
					if (g.ontouchmove) { g.ontouchmove(this,this._event) };
				};
			};
			
			(target_ = this.target()) && target_.ontouchmove  &&  target_.ontouchmove(this,this._event);
			return this;
		};
		
		Imba.Touch.prototype.ended = function (){
			var target_;
			if (!this._active) { return this };
			
			this._updates++;
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length; i < len; i++) {
					ary[i].ontouchend(this);
				};
			};
			
			(target_ = this.target()) && target_.ontouchend  &&  target_.ontouchend(this);
			
			return this;
		};
		
		Imba.Touch.prototype.cancel = function (){
			if (!this._cancelled) {
				this._cancelled = true;
				this.cancelled();
				if (this._mousemove) { doc.removeEventListener('mousemove',this._mousemove,true) };
			};
			return this;
		};
		
		Imba.Touch.prototype.cancelled = function (){
			var target_;
			if (!this._active) { return this };
			
			this._cancelled = true;
			this._updates++;
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length, g; i < len; i++) {
					g = ary[i];
					if (g.ontouchcancel) { g.ontouchcancel(this) };
				};
			};
			
			(target_ = this.target()) && target_.ontouchcancel  &&  target_.ontouchcancel(this);
			return this;
		};
		
		/*
			The absolute distance the touch has moved from starting position 
			@return {Number}
			*/
		
		Imba.Touch.prototype.dr = function (){
			return this._dr;
		};
		
		/*
			The distance the touch has moved horizontally
			@return {Number}
			*/
		
		Imba.Touch.prototype.dx = function (){
			return this._x - this._x0;
		};
		
		/*
			The distance the touch has moved vertically
			@return {Number}
			*/
		
		Imba.Touch.prototype.dy = function (){
			return this._y - this._y0;
		};
		
		/*
			Initial horizontal position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.x0 = function (){
			return this._x0;
		};
		
		/*
			Initial vertical position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.y0 = function (){
			return this._y0;
		};
		
		/*
			Horizontal position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.x = function (){
			return this._x;
		};
		
		/*
			Vertical position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.y = function (){
			return this._y;
		};
		
		/*
			Horizontal position of touch relative to target
			@return {Number}
			*/
		
		Imba.Touch.prototype.tx = function (){
			this._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());
			return this._x - this._targetBox.left;
		};
		
		/*
			Vertical position of touch relative to target
			@return {Number}
			*/
		
		Imba.Touch.prototype.ty = function (){
			this._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());
			return this._y - this._targetBox.top;
		};
		
		/*
			Button pressed in this touch. Native touches defaults to left-click (0)
			@return {Number}
			*/
		
		Imba.Touch.prototype.button = function (){
			return this._button;
		}; // @pointer ? @pointer.button : 0
		
		Imba.Touch.prototype.sourceTarget = function (){
			return this._sourceTarget;
		};
		
		
		Imba.TouchGesture = function TouchGesture(){ };
		
		
		Imba.TouchGesture.prototype.__active = {'default': false,name: 'active'};
		Imba.TouchGesture.prototype.active = function(v){ return this._active; }
		Imba.TouchGesture.prototype.setActive = function(v){ this._active = v; return this; }
		Imba.TouchGesture.prototype._active = false;
		
		Imba.TouchGesture.prototype.ontouchstart = function (e){
			return this;
		};
		
		Imba.TouchGesture.prototype.ontouchupdate = function (e){
			return this;
		};
		
		Imba.TouchGesture.prototype.ontouchend = function (e){
			return this;
		};
		
		
		// A Touch-event is created on mousedown (always)
		// and while it exists, mousemove and mouseup will
		// be delegated to this active event.
		Imba.POINTER = new Imba.Pointer();
		Imba.POINTERS = [Imba.POINTER];
		
		
		// regular event stuff
		Imba.KEYMAP = {
			"8": 'backspace',
			"9": 'tab',
			"13": 'enter',
			"16": 'shift',
			"17": 'ctrl',
			"18": 'alt',
			"19": 'break',
			"20": 'caps',
			"27": 'esc',
			"32": 'space',
			"35": 'end',
			"36": 'home',
			"37": 'larr',
			"38": 'uarr',
			"39": 'rarr',
			"40": 'darr',
			"45": 'insert',
			"46": 'delete',
			"107": 'plus',
			"106": 'mult',
			"91": 'meta'
		};
		
		Imba.CHARMAP = {
			"%": 'modulo',
			"*": 'multiply',
			"+": 'add',
			"-": 'sub',
			"/": 'divide',
			".": 'dot'
		};
		
		/*
		Imba handles all events in the dom through a single manager,
		listening at the root of your document. If Imba finds a tag
		that listens to a certain event, the event will be wrapped 
		in an `Imba.Event`, which normalizes some of the quirks and 
		browser differences.
		
		@iname event
		*/
		
		Imba.Event = function Event(e){
			this.setEvent(e);
			this.setBubble(true);
		};
		
		/* reference to the native event */
		
		
		
		Imba.Event.prototype.event = function(v){ return this._event; }
		Imba.Event.prototype.setEvent = function(v){ this._event = v; return this; };
		
		/* reference to the native event */
		
		
		
		Imba.Event.prototype.prefix = function(v){ return this._prefix; }
		Imba.Event.prototype.setPrefix = function(v){ this._prefix = v; return this; };
		
		
		
		Imba.Event.prototype.data = function(v){ return this._data; }
		Imba.Event.prototype.setData = function(v){ this._data = v; return this; };
		
		/*
			should remove this alltogether?
			@deprecated
			*/
		
		
		
		Imba.Event.prototype.source = function(v){ return this._source; }
		Imba.Event.prototype.setSource = function(v){ this._source = v; return this; };
		
		/* A {Boolean} indicating whether the event bubbles up or not */
		
		
		Imba.Event.prototype.__bubble = {type: Boolean,chainable: true,name: 'bubble'};
		Imba.Event.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }
		Imba.Event.prototype.setBubble = function(v){ this._bubble = v; return this; };
		
		Imba.Event.wrap = function (e){
			return new this(e);
		};
		
		Imba.Event.prototype.setType = function (type){
			this._type = type;
			return this;
		};
		
		/*
			@return {String} The name of the event (case-insensitive)
			*/
		
		Imba.Event.prototype.type = function (){
			return this._type || this.event().type;
		};
		
		Imba.Event.prototype.name = function (){
			return this._name || (this._name = this.type().toLowerCase().replace(/\:/g,''));
		};
		
		// mimc getset
		Imba.Event.prototype.bubble = function (v){
			if (v != undefined) {
				this.setBubble(v);
				return this;
			};
			return this._bubble;
		};
		
		/*
			Prevents further propagation of the current event.
			@return {self}
			*/
		
		Imba.Event.prototype.halt = function (){
			this.setBubble(false);
			return this;
		};
		
		/*
			Cancel the event (if cancelable). In the case of native events it
			will call `preventDefault` on the wrapped event object.
			@return {self}
			*/
		
		Imba.Event.prototype.cancel = function (){
			if (this.event().preventDefault) { this.event().preventDefault() };
			this._cancel = true;
			return this;
		};
		
		/*
			Indicates whether or not event.cancel has been called.
		
			@return {Boolean}
			*/
		
		Imba.Event.prototype.isPrevented = function (){
			return this.event() && this.event().defaultPrevented || this._cancel;
		};
		
		/*
			A reference to the initial target of the event.
			*/
		
		Imba.Event.prototype.target = function (){
			return tag$wrap(this.event()._target || this.event().target);
		};
		
		/*
			A reference to the object responding to the event.
			*/
		
		Imba.Event.prototype.responder = function (){
			return this._responder;
		};
		
		/*
			Redirect the event to new target
			*/
		
		Imba.Event.prototype.redirect = function (node){
			this._redirect = node;
			return this;
		};
		
		/*
			Get the normalized character for KeyboardEvent/TextEvent
			@return {String}
			*/
		
		Imba.Event.prototype.keychar = function (){
			if (this.event() instanceof TextEvent) {
				return this.event().data;
			};
			
			if (this.event() instanceof KeyboardEvent) {
				var ki = this.event().keyIdentifier;
				var sym = Imba.KEYMAP[this.event().keyCode];
				
				// p 'keysym!',ki,sym
				
				if (!sym && ki.substr(0,2) == "U+") {
					sym = String.fromCharCode(parseInt(ki.substr(2),16));
				};
				return sym;
			};
			
			return null;
		};
		
		/*
			@deprecated
			*/
		
		Imba.Event.prototype.keycombo = function (){
			var sym;
			if (!(sym = this.keychar())) { return };
			sym = Imba.CHARMAP[sym] || sym;
			var combo = [],e = this.event();
			if (e.ctrlKey) { combo.push('ctrl') };
			if (e.shiftKey) { combo.push('shift') };
			if (e.altKey) { combo.push('alt') };
			if (e.metaKey) { combo.push('cmd') };
			combo.push(sym);
			return combo.join("_").toLowerCase();
		};
		
		
		Imba.Event.prototype.process = function (){
			var node;
			var meth = ("on" + (this._prefix || '') + this.name());
			var args = null;
			var domtarget = this.event()._target || this.event().target;
			// var node = <{domtarget:_responder or domtarget}>
			// need to clean up and document this behaviour
			
			var domnode = domtarget._responder || domtarget;
			// @todo need to stop infinite redirect-rules here
			
			var $1;while (domnode){
				this._redirect = null;
				if (node = tag$wrap(domnode)) { // not only tag 
					
					if ((typeof node[($1 = meth)]=='string'||node[$1] instanceof String)) {
						// should remember the receiver of the event
						meth = node[meth];
						continue; // should not continue?
					};
					
					if (node[meth] instanceof Array) {
						args = node[meth].concat(node);
						meth = args.shift();
						continue; // should not continue?
					};
					
					if (node[meth] instanceof Function) {
						this._responder || (this._responder = node);
						// should autostop bubble here?
						args ? (node[meth].apply(node,args)) : (node[meth](this,this.data()));
					};
				};
				
				// add node.nextEventResponder as a separate method here?
				if (!(this.bubble() && (domnode = (this._redirect || (node ? (node.parent()) : (domnode.parentNode)))))) {
					break;
				};
			};
			
			this.processed();
			return this;
		};
		
		
		Imba.Event.prototype.processed = function (){
			Imba.emit(Imba,'event',[this]);
			return this;
		};
		
		/*
			Return the x/left coordinate of the mouse / pointer for this event
			@return {Number} x coordinate of mouse / pointer for event
			*/
		
		Imba.Event.prototype.x = function (){
			return this.event().x;
		};
		
		/*
			Return the y/top coordinate of the mouse / pointer for this event
			@return {Number} y coordinate of mouse / pointer for event
			*/
		
		Imba.Event.prototype.y = function (){
			return this.event().y;
		};
		
		/*
			Returns a Number representing a system and implementation
			dependent numeric code identifying the unmodified value of the
			pressed key; this is usually the same as keyCode.
		
			For mouse-events, the returned value indicates which button was
			pressed on the mouse to trigger the event.
		
			@return {Number}
			*/
		
		Imba.Event.prototype.which = function (){
			return this.event().which;
		};
		
		
		/*
		
		Manager for listening to and delegating events in Imba. A single instance
		is always created by Imba (as `Imba.Events`), which handles and delegates all
		events at the very root of the document. Imba does not capture all events
		by default, so if you want to make sure exotic or custom DOMEvents are delegated
		in Imba you will need to register them in `Imba.Events.register(myCustomEventName)`
		
		@iname manager
		
		*/
		
		Imba.EventManager = function EventManager(node,pars){
			var self = this;
			if(!pars||pars.constructor !== Object) pars = {};
			var events = pars.events !== undefined ? pars.events : [];
			self.setRoot(node);
			self.setCount(0);
			self.setListeners([]);
			self.setDelegators({});
			self.setDelegator(function(e) {
				// console.log "delegating event?! {e}"
				self.delegate(e);
				return true;
			});
			
			for (var i = 0, ary = iter$(events), len = ary.length; i < len; i++) {
				self.register(ary[i]);
			};
			
			return self;
		};
		
		
		
		Imba.EventManager.prototype.root = function(v){ return this._root; }
		Imba.EventManager.prototype.setRoot = function(v){ this._root = v; return this; };
		
		
		Imba.EventManager.prototype.count = function(v){ return this._count; }
		Imba.EventManager.prototype.setCount = function(v){ this._count = v; return this; };
		
		Imba.EventManager.prototype.__enabled = {'default': false,watch: 'enabledDidSet',name: 'enabled'};
		Imba.EventManager.prototype.enabled = function(v){ return this._enabled; }
		Imba.EventManager.prototype.setEnabled = function(v){
			var a = this.enabled();
			if(v != a) { this._enabled = v; }
			if(v != a) { this.enabledDidSet && this.enabledDidSet(v,a,this.__enabled) }
			return this;
		}
		Imba.EventManager.prototype._enabled = false;
		
		
		Imba.EventManager.prototype.listeners = function(v){ return this._listeners; }
		Imba.EventManager.prototype.setListeners = function(v){ this._listeners = v; return this; };
		
		
		Imba.EventManager.prototype.delegators = function(v){ return this._delegators; }
		Imba.EventManager.prototype.setDelegators = function(v){ this._delegators = v; return this; };
		
		
		Imba.EventManager.prototype.delegator = function(v){ return this._delegator; }
		Imba.EventManager.prototype.setDelegator = function(v){ this._delegator = v; return this; };
		
		Imba.EventManager.prototype.enabledDidSet = function (bool){
			bool ? (this.onenable()) : (this.ondisable());
			return this;
		};
		
		/*
		
			Tell the current EventManager to intercept and handle event of a certain name.
			By default, Imba.Events will register interceptors for: *keydown*, *keyup*, 
			*keypress*, *textInput*, *input*, *change*, *submit*, *focusin*, *focusout*, 
			*blur*, *contextmenu*, *dblclick*, *mousewheel*, *wheel*
		
			*/
		
		Imba.EventManager.prototype.register = function (name,handler){
			if(handler === undefined) handler = true;
			if (name instanceof Array) {
				for (var i = 0, ary = iter$(name), len = ary.length; i < len; i++) {
					this.register(ary[i],handler);
				};
				return this;
			};
			
			if (this.delegators()[name]) { return this };
			// console.log("register for event {name}")
			var fn = this.delegators()[name] = handler instanceof Function ? (handler) : (this.delegator());
			if (this.enabled()) { return this.root().addEventListener(name,fn,true) };
		};
		
		Imba.EventManager.prototype.listen = function (name,handler,capture){
			if(capture === undefined) capture = true;
			this.listeners().push([name,handler,capture]);
			if (this.enabled()) { this.root().addEventListener(name,handler,capture) };
			return this;
		};
		
		Imba.EventManager.prototype.delegate = function (e){
			this.setCount(this.count() + 1);
			var event = Imba.Event.wrap(e);
			event.process();
			return this;
		};
		
		Imba.EventManager.prototype.create = function (type,target,pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var data = pars.data !== undefined ? pars.data : null;
			var source = pars.source !== undefined ? pars.source : null;
			var event = Imba.Event.wrap({type: type,target: target});
			if (data) { (event.setData(data),data) };
			if (source) { (event.setSource(source),source) };
			return event;
		};
		
		// use create instead?
		Imba.EventManager.prototype.trigger = function (){
			return this.create.apply(this,arguments).process();
		};
		
		Imba.EventManager.prototype.onenable = function (){
			for (var o = this.delegators(), i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				this.root().addEventListener(keys[i],o[keys[i]],true);
			};
			
			for (var j = 0, ary = iter$(this.listeners()), len = ary.length, item; j < len; j++) {
				item = ary[j];
				this.root().addEventListener(item[0],item[1],item[2]);
			};
			return this;
		};
		
		Imba.EventManager.prototype.ondisable = function (){
			for (var o = this.delegators(), i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				this.root().removeEventListener(keys[i],o[keys[i]],true);
			};
			
			for (var j = 0, ary = iter$(this.listeners()), len = ary.length, item; j < len; j++) {
				item = ary[j];
				this.root().removeEventListener(item[0],item[1],item[2]);
			};
			return this;
		};
		
		
		ED = Imba.Events = new Imba.EventManager(document,{events: [
			'keydown','keyup','keypress','textInput','input','change','submit',
			'focusin','focusout','blur','contextmenu','dblclick',
			'mousewheel','wheel'
		]});
		
		// should set these up inside the Imba.Events object itself
		// so that we can have different EventManager for different roots
		
		if (hasTouchEvents) {
			Imba.Events.listen('touchstart',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchstart(e);
			});
			
			Imba.Events.listen('touchmove',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchmove(e);
			});
			
			Imba.Events.listen('touchend',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchend(e);
			});
			
			Imba.Events.listen('touchcancel',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchcancel(e);
			});
		};
		
		Imba.Events.register('click',function(e) {
			// Only for main mousebutton, no?
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				var tap = new Imba.Event(e);
				tap.setType('tap');
				tap.process();
				if (tap._responder) {
					return e.preventDefault();
				};
			};
			// delegate the real click event
			return Imba.Events.delegate(e);
		});
		
		Imba.Events.listen('mousedown',function(e) {
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				if (Imba.POINTER) { return Imba.POINTER.update(e).process() };
			};
		});
		
		// Imba.Events.listen(:mousemove) do |e|
		// 	# console.log 'mousemove',e:timeStamp
		// 	if (e:timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout
		// 		Imba.POINTER.update(e).process if Imba.POINTER # .process if touch # should not happen? We process through 
		
		Imba.Events.listen('mouseup',function(e) {
			// console.log 'mouseup',e:timeStamp
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				if (Imba.POINTER) { return Imba.POINTER.update(e).process() };
			};
		});
		
		
		Imba.Events.register(['mousedown','mouseup']);
		return (Imba.Events.setEnabled(true),true);
	
	})()

/***/ },
/* 12 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var ImbaTag = Imba.TAGS.element;
		
		function removeNested(root,node,caret){
			// if node/nodes isa String
			// 	we need to use the caret to remove elements
			// 	for now we will simply not support this
			if (node instanceof ImbaTag) {
				root.removeChild(node);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					removeNested(root,ary[i],caret);
				};
			} else {
				// what if this is not null?!?!?
				// take a chance and remove a text-elementng
				var next = caret ? (caret.nextSibling) : (root._dom.firstChild);
				if ((next instanceof Text) && next.textContent == node) {
					root.removeChild(next);
				} else {
					throw 'cannot remove string';
				};
			};
			
			return caret;
		};
		
		function appendNested(root,node){
			if (node instanceof ImbaTag) {
				root.appendChild(node);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					appendNested(root,ary[i]);
				};
			} else if (node != null && node !== false) {
				root.appendChild(Imba.document().createTextNode(node));
			};
			
			return;
		};
		
		
		// insert nodes before a certain node
		// does not need to return any tail, as before
		// will still be correct there
		// before must be an actual domnode
		function insertNestedBefore(root,node,before){
			if (node instanceof ImbaTag) {
				root.insertBefore(node,before);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					insertNestedBefore(root,ary[i],before);
				};
			} else if (node != null && node !== false) {
				root.insertBefore(Imba.document().createTextNode(node),before);
			};
			
			return before;
		};
		
		// after must be an actual domnode
		function insertNestedAfter(root,node,after){
			var before = after ? (after.nextSibling) : (root._dom.firstChild);
			
			if (before) {
				insertNestedBefore(root,node,before);
				return before.previousSibling;
			} else {
				appendNested(root,node);
				return root._dom.lastChild;
			};
		};
		
		function reconcileCollectionChanges(root,new$,old,caret){
			
			var newLen = new$.length;
			var lastNew = new$[newLen - 1];
			
			// This re-order algorithm is based on the following principle:
			// 
			// We build a "chain" which shows which items are already sorted.
			// If we're going from [1, 2, 3] -> [2, 1, 3], the tree looks like:
			//
			// 	3 ->  0 (idx)
			// 	2 -> -1 (idx)
			// 	1 -> -1 (idx)
			//
			// This tells us that we have two chains of ordered items:
			// 
			// 	(1, 3) and (2)
			// 
			// The optimal re-ordering then becomes two keep the longest chain intact,
			// and move all the other items.
			
			var newPosition = [];
			
			// The tree/graph itself
			var prevChain = [];
			// The length of the chain
			var lengthChain = [];
			
			// Keep track of the longest chain
			var maxChainLength = 0;
			var maxChainEnd = 0;
			
			for (var idx = 0, ary = iter$(old), len = ary.length, node; idx < len; idx++) {
				node = ary[idx];
				var newPos = new$.indexOf(node);
				newPosition.push(newPos);
				
				if (newPos == -1) {
					root.removeChild(node);
					prevChain.push(-1);
					lengthChain.push(-1);
					continue;
				};
				
				var prevIdx = newPosition.length - 2;
				
				// Build the chain:
				while (prevIdx >= 0){
					if (newPosition[prevIdx] == -1) {
						prevIdx--;
					} else if (newPos > newPosition[prevIdx]) {
						// Yay, we're bigger than the previous!
						break;
					} else {
						// Nope, let's walk back the chain
						prevIdx = prevChain[prevIdx];
					};
				};
				
				prevChain.push(prevIdx);
				
				var currLength = (prevIdx == -1) ? (0) : (lengthChain[prevIdx] + 1);
				
				if (currLength > maxChainLength) {
					maxChainLength = currLength;
					maxChainEnd = idx;
				};
				
				lengthChain.push(currLength);
			};
			
			var stickyNodes = [];
			
			// Now we can walk the longest chain backwards and mark them as "sticky",
			// which implies that they should not be moved
			var cursor = newPosition.length - 1;
			while (cursor >= 0){
				if (cursor == maxChainEnd && newPosition[cursor] != -1) {
					stickyNodes[newPosition[cursor]] = true;
					maxChainEnd = prevChain[maxChainEnd];
				};
				
				cursor -= 1;
			};
			
			// And let's iterate forward, but only move non-sticky nodes
			for (var idx1 = 0, ary = iter$(new$), len = ary.length; idx1 < len; idx1++) {
				if (!stickyNodes[idx1]) {
					var after = new$[idx1 - 1];
					insertNestedAfter(root,ary[idx1],(after && after._dom) || caret);
				};
			};
			
			// should trust that the last item in new list is the caret
			return lastNew && lastNew._dom || caret;
		};
		
		
		// expects a flat non-sparse array of nodes in both new and old, always
		function reconcileCollection(root,new$,old,caret){
			var k = new$.length;
			var i = k;
			var last = new$[k - 1];
			
			
			if (k == old.length && new$[0] === old[0]) {
				// running through to compare
				while (i--){
					if (new$[i] !== old[i]) { break; };
				};
			};
			
			if (i == -1) {
				return last && last._dom || caret;
			} else {
				return reconcileCollectionChanges(root,new$,old,caret);
			};
		};
		
		// the general reconciler that respects conditions etc
		// caret is the current node we want to insert things after
		function reconcileNested(root,new$,old,caret){
			
			// if new == null or new === false or new === true
			// 	if new === old
			// 		return caret
			// 	if old && new != old
			// 		removeNested(root,old,caret) if old
			// 
			// 	return caret
			
			// var skipnew = new == null or new === false or new === true
			var newIsNull = new$ == null || new$ === false;
			var oldIsNull = old == null || old === false;
			
			
			if (new$ === old) {
				// remember that the caret must be an actual dom element
				// we should instead move the actual caret? - trust
				if (newIsNull) {
					return caret;
				} else if (new$ && new$._dom) {
					return new$._dom;
				} else {
					return caret ? (caret.nextSibling) : (root._dom.firstChild);
				};
			} else if (new$ instanceof Array) {
				if (old instanceof Array) {
					if (new$.static || old.static) {
						// if the static is not nested - we could get a hint from compiler
						// and just skip it
						if (new$.static == old.static) {
							for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
								// this is where we could do the triple equal directly
								caret = reconcileNested(root,ary[i],old[i],caret);
							};
							return caret;
						} else {
							removeNested(root,old,caret);
						};
						
						// if they are not the same we continue through to the default
					} else {
						return reconcileCollection(root,new$,old,caret);
					};
				} else if (old instanceof ImbaTag) {
					root.removeChild(old);
				} else if (!oldIsNull) {
					// old was a string-like object?
					root.removeChild(caret ? (caret.nextSibling) : (root._dom.firstChild));
				};
				
				return insertNestedAfter(root,new$,caret);
				// remove old
			} else if (new$ instanceof ImbaTag) {
				if (!oldIsNull) { removeNested(root,old,caret) };
				insertNestedAfter(root,new$,caret);
				return new$;
			} else if (newIsNull) {
				if (!oldIsNull) { removeNested(root,old,caret) };
				return caret;
			} else {
				// if old did not exist we need to add a new directly
				var nextNode;
				// if old was array or imbatag we need to remove it and then add
				if (old instanceof Array) {
					removeNested(root,old,caret);
				} else if (old instanceof ImbaTag) {
					root.removeChild(old);
				} else if (!oldIsNull) {
					// ...
					nextNode = caret ? (caret.nextSibling) : (root._dom.firstChild);
					if ((nextNode instanceof Text) && nextNode.textContent != new$) {
						nextNode.textContent = new$;
						return nextNode;
					};
				};
				
				// now add the textnode
				return insertNestedAfter(root,new$,caret);
			};
		};
		
		
		return tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.setChildren = function (new$,typ){
				var old = this._children;
				// var isArray = nodes isa Array
				if (new$ === old) {
					return this;
				};
				
				if (!old) {
					this.empty();
					appendNested(this,new$);
				} else if (typ == 2) {
					return this;
				} else if (typ == 1) {
					// here we _know _that it is an array with the same shape
					// every time
					var caret = null;
					for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
						// prev = old[i]
						caret = reconcileNested(this,ary[i],old[i],caret);
					};
				} else if (typ == 3) {
					// this is possibly fully dynamic. It often is
					// but the old or new could be static while the other is not
					// this is not handled now
					// what if it was previously a static array? edgecase - but must work
					if (new$ instanceof ImbaTag) {
						this.empty();
						this.appendChild(new$);
					} else if (new$ instanceof Array) {
						if (old instanceof Array) {
							// is this not the same as setting staticChildren now but with the
							reconcileCollection(this,new$,old,null);
						} else {
							this.empty();
							appendNested(this,new$);
						};
					} else {
						this.setText(new$);
						return this;
					};
				} else if ((new$ instanceof Array) && (old instanceof Array)) {
					reconcileCollection(this,new$,old,null);
				} else {
					this.empty();
					appendNested(this,new$);
				};
				
				this._children = new$;
				return this;
			};
			
			
			// only ever called with array as argument
			tag.prototype.setStaticChildren = function (new$){
				var old = this._children;
				
				var caret = null;
				for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
					// prev = old[i]
					caret = reconcileNested(this,ary[i],old[i],caret);
				};
				
				this._children = new$;
				return this;
			};
			
			tag.prototype.content = function (){
				return this._content || this.children().toArray();
			};
			
			tag.prototype.setText = function (text){
				if (text != this._children) {
					this._children = text;
					this.dom().textContent = text == null || text === false ? ('') : (text);
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 13 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		/*
		The special syntax for selectors in Imba creates Imba.Selector
		instances.
		*/
		
		Imba.Selector = function Selector(sel,scope,nodes){
			
			this._query = sel instanceof Imba.Selector ? (sel.query()) : (sel);
			this._context = scope;
			
			if (nodes) {
				for (var i = 0, ary = iter$(nodes), len = ary.length, res = []; i < len; i++) {
					res.push(tag$wrap(ary[i]));
				};
				this._nodes = res;
			};
			
			this._lazy = !nodes;
			return this;
		};
		
		Imba.Selector.one = function (sel,scope){
			var el = (scope || Imba.document()).querySelector(sel);
			return el && tag$wrap(el) || null;
		};
		
		Imba.Selector.all = function (sel,scope){
			return new Imba.Selector(sel,scope);
		};
		
		
		
		Imba.Selector.prototype.query = function(v){ return this._query; }
		Imba.Selector.prototype.setQuery = function(v){ this._query = v; return this; };
		
		Imba.Selector.prototype.reload = function (){
			this._nodes = null;
			return this;
		};
		
		Imba.Selector.prototype.scope = function (){
			var ctx;
			if (this._scope) { return this._scope };
			if (!(ctx = this._context)) { return Imba.document() };
			return this._scope = ctx.toScope ? (ctx.toScope()) : (ctx);
		};
		
		/*
			@returns {Imba.Tag} first node matching this selector
			*/
		
		Imba.Selector.prototype.first = function (){
			if (this._lazy) { return tag$wrap(this._first || (this._first = this.scope().querySelector(this.query()))) } else {
				return this.nodes()[0];
			};
		};
		
		/*
			@returns {Imba.Tag} last node matching this selector
			*/
		
		Imba.Selector.prototype.last = function (){
			return this.nodes()[this._nodes.length - 1];
		};
		
		/*
			@returns [Imba.Tag] all nodes matching this selector
			*/
		
		Imba.Selector.prototype.nodes = function (){
			if (this._nodes) { return this._nodes };
			var items = this.scope().querySelectorAll(this.query());
			for (var i = 0, ary = iter$(items), len = ary.length, res = []; i < len; i++) {
				res.push(tag$wrap(ary[i]));
			};
			this._nodes = res;
			this._lazy = false;
			return this._nodes;
		};
		
		/*
			The number of nodes matching this selector
			*/
		
		Imba.Selector.prototype.count = function (){
			return this.nodes().length;
		};
		
		Imba.Selector.prototype.len = function (){
			return this.nodes().length;
		};
		
		/*
			@todo Add support for block or selector?
			*/
		
		Imba.Selector.prototype.some = function (){
			return this.count() >= 1;
		};
		
		/*
			Get node at index
			*/
		
		Imba.Selector.prototype.at = function (idx){
			return this.nodes()[idx];
		};
		
		/*
			Loop through nodes
			*/
		
		Imba.Selector.prototype.forEach = function (block){
			this.nodes().forEach(block);
			return this;
		};
		
		/*
			Map nodes
			*/
		
		Imba.Selector.prototype.map = function (block){
			return this.nodes().map(block);
		};
		
		/*
			Returns a plain array containing nodes. Implicitly called
			when iterating over a selector in Imba `(node for node in $(selector))`
			*/
		
		Imba.Selector.prototype.toArray = function (){
			return this.nodes();
		};
		
		// Get the first element that matches the selector, 
		// beginning at the current element and progressing up through the DOM tree
		Imba.Selector.prototype.closest = function (sel){
			// seems strange that we alter this selector?
			this._nodes = this.map(function(node) { return node.closest(sel); });
			return this;
		};
		
		// Get the siblings of each element in the set of matched elements, 
		// optionally filtered by a selector.
		// TODO remove duplicates?
		Imba.Selector.prototype.siblings = function (sel){
			this._nodes = this.map(function(node) { return node.siblings(sel); });
			return this;
		};
		
		// Get the descendants of each element in the current set of matched 
		// elements, filtered by a selector.
		Imba.Selector.prototype.find = function (sel){
			this._nodes = this.__query__(sel.query(),this.nodes());
			return this;
		};
		
		Imba.Selector.prototype.reject = function (blk){
			return this.filter(blk,false);
		};
		
		/*
			Filter the nodes in selector by a function or other selector
			*/
		
		Imba.Selector.prototype.filter = function (blk,bool){
			if(bool === undefined) bool = true;
			var fn = (blk instanceof Function) && blk || function(n) { return n.matches(blk); };
			var ary = this.nodes().filter(function(n) { return fn(n) == bool; });
			// if we want to return a new selector for this, we should do that for
			// others as well
			return new Imba.Selector("",this._scope,ary);
		};
		
		Imba.Selector.prototype.__query__ = function (query,contexts){
			var nodes = [];
			var i = 0;
			var l = contexts.length;
			
			while (i < l){
				nodes.push.apply(nodes,contexts[i++].querySelectorAll(query));
			};
			return nodes;
		};
		
		Imba.Selector.prototype.__matches__ = function (){
			return true;
		};
		
		/*
			Add specified flag to all nodes in selector
			*/
		
		Imba.Selector.prototype.flag = function (flag){
			return this.forEach(function(n) { return n.flag(flag); });
		};
		
		/*
			Remove specified flag from all nodes in selector
			*/
		
		Imba.Selector.prototype.unflag = function (flag){
			return this.forEach(function(n) { return n.unflag(flag); });
		};
		
		
		// def Imba.querySelectorAll
		q$ = function(sel,scope) { return new Imba.Selector(sel,scope); };
		
		// def Imba.Selector.one
		q$$ = function(sel,scope) {
			var el = (scope || Imba.document()).querySelector(sel);
			return el && tag$wrap(el) || null;
		};
		
		
		// extending tags with query-methods
		// must be a better way to reopen classes
		return tag$.extendTag('element', function(tag){
			tag.prototype.querySelectorAll = function (q){
				return this._dom.querySelectorAll(q);
			};
			tag.prototype.querySelector = function (q){
				return this._dom.querySelector(q);
			};
			
			// should be moved to Imba.Tag instead?
			// or we should implement all of them here
			tag.prototype.find = function (sel){
				return new Imba.Selector(sel,this);
			};
		});
		
	
	})()

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var util;
		IMDEBUG = true;
		
		// wtf er alt dette?
		IM = {};
		IM.NEWLINE = '\n';
		IM.CHAR = 0;
		IM.WORD_START = 1;
		IM.WORD_END = 2;
		IM.PUNCTUATION_START = 3;
		IM.PUNCTUATION_END = 4;
		IM.SUB_WORD_START = 5;
		IM.SUB_WORD_END = 6;
		IM.LINE_START = 7;
		IM.LINE_END = 8;
		IM.EMPTY_LINE = 9;
		
		IM.FS = __webpack_require__(15);
		
		var SourceMap = __webpack_require__(16);
		
		// if global:require
		var Region = __webpack_require__(27).Region;
		
		__webpack_require__(28);
		
		__webpack_require__(35);
		__webpack_require__(36);
		__webpack_require__(37);
		
		__webpack_require__(38);
		__webpack_require__(39);
		__webpack_require__(45);
		
		var Highlighter = __webpack_require__(29).Highlighter;
		var ImbacWorker = __webpack_require__(46).ImbacWorker;
		
		IM.worker = function (){
			return this._worker || (this._worker = new ImbacWorker());
		};
		
		module.exports.util = util = __webpack_require__(34);
		// nodes
		__webpack_require__(47);
		
		
		function worker(){
			return IM.worker();
		}; exports.worker = worker;
		
		module.exports.SourceMap = SourceMap;
		module.exports.Region = Region;
		return module.exports.Highlighter = Highlighter;
	
	})()

/***/ },
/* 15 */
/***/ function(module, exports) {

	(function(){
		// externs;
		function save(path,content,encoding,cb){
			if(cb==undefined && typeof encoding == 'function') cb = encoding,encoding = 'utf-8';
			if(encoding==undefined) encoding = 'utf-8';
			console.log('save',path,content,encoding);
			
			return xr.post(path,{body: content}).then(function() {
				console.log('responded');
				return cb && cb(arguments);
			});
		}; exports.save = save;
		
		function readFileAsync(path,encoding,cb){
			if(cb==undefined && typeof encoding == 'function') cb = encoding,encoding = 'utf-8';
			if(encoding==undefined) encoding = 'utf-8';
			console.log('save',path,encoding);
			
			return xr.get(path).then(function(res) {
				console.log('responded',res);
				cb && cb(arguments);
				return res;
			});
		}; exports.readFileAsync = readFileAsync;; return readFileAsync;
	
	})()

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(17).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(23).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(26).SourceNode;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var base64VLQ = __webpack_require__(18);
	  var util = __webpack_require__(20);
	  var ArraySet = __webpack_require__(21).ArraySet;
	  var MappingList = __webpack_require__(22).MappingList;
	
	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. You may pass an object with the following
	   * properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: A root for all relative URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    if (!aArgs) {
	      aArgs = {};
	    }
	    this._file = util.getArg(aArgs, 'file', null);
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = new MappingList();
	    this._sourcesContents = null;
	  }
	
	  SourceMapGenerator.prototype._version = 3;
	
	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap =
	    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	      var sourceRoot = aSourceMapConsumer.sourceRoot;
	      var generator = new SourceMapGenerator({
	        file: aSourceMapConsumer.file,
	        sourceRoot: sourceRoot
	      });
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        var newMapping = {
	          generated: {
	            line: mapping.generatedLine,
	            column: mapping.generatedColumn
	          }
	        };
	
	        if (mapping.source != null) {
	          newMapping.source = mapping.source;
	          if (sourceRoot != null) {
	            newMapping.source = util.relative(sourceRoot, newMapping.source);
	          }
	
	          newMapping.original = {
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          };
	
	          if (mapping.name != null) {
	            newMapping.name = mapping.name;
	          }
	        }
	
	        generator.addMapping(newMapping);
	      });
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          generator.setSourceContent(sourceFile, content);
	        }
	      });
	      return generator;
	    };
	
	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping =
	    function SourceMapGenerator_addMapping(aArgs) {
	      var generated = util.getArg(aArgs, 'generated');
	      var original = util.getArg(aArgs, 'original', null);
	      var source = util.getArg(aArgs, 'source', null);
	      var name = util.getArg(aArgs, 'name', null);
	
	      if (!this._skipValidation) {
	        this._validateMapping(generated, original, source, name);
	      }
	
	      if (source != null && !this._sources.has(source)) {
	        this._sources.add(source);
	      }
	
	      if (name != null && !this._names.has(name)) {
	        this._names.add(name);
	      }
	
	      this._mappings.add({
	        generatedLine: generated.line,
	        generatedColumn: generated.column,
	        originalLine: original != null && original.line,
	        originalColumn: original != null && original.column,
	        source: source,
	        name: name
	      });
	    };
	
	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent =
	    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	      var source = aSourceFile;
	      if (this._sourceRoot != null) {
	        source = util.relative(this._sourceRoot, source);
	      }
	
	      if (aSourceContent != null) {
	        // Add the source content to the _sourcesContents map.
	        // Create a new _sourcesContents map if the property is null.
	        if (!this._sourcesContents) {
	          this._sourcesContents = {};
	        }
	        this._sourcesContents[util.toSetString(source)] = aSourceContent;
	      } else if (this._sourcesContents) {
	        // Remove the source file from the _sourcesContents map.
	        // If the _sourcesContents map is empty, set the property to null.
	        delete this._sourcesContents[util.toSetString(source)];
	        if (Object.keys(this._sourcesContents).length === 0) {
	          this._sourcesContents = null;
	        }
	      }
	    };
	
	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   * @param aSourceMapPath Optional. The dirname of the path to the source map
	   *        to be applied. If relative, it is relative to the SourceMapConsumer.
	   *        This parameter is needed when the two source maps aren't in the same
	   *        directory, and the source map to be applied contains relative source
	   *        paths. If so, those relative source paths need to be rewritten
	   *        relative to the SourceMapGenerator.
	   */
	  SourceMapGenerator.prototype.applySourceMap =
	    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	      var sourceFile = aSourceFile;
	      // If aSourceFile is omitted, we will use the file property of the SourceMap
	      if (aSourceFile == null) {
	        if (aSourceMapConsumer.file == null) {
	          throw new Error(
	            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	            'or the source map\'s "file" property. Both were omitted.'
	          );
	        }
	        sourceFile = aSourceMapConsumer.file;
	      }
	      var sourceRoot = this._sourceRoot;
	      // Make "sourceFile" relative if an absolute Url is passed.
	      if (sourceRoot != null) {
	        sourceFile = util.relative(sourceRoot, sourceFile);
	      }
	      // Applying the SourceMap can add and remove items from the sources and
	      // the names array.
	      var newSources = new ArraySet();
	      var newNames = new ArraySet();
	
	      // Find mappings for the "sourceFile"
	      this._mappings.unsortedForEach(function (mapping) {
	        if (mapping.source === sourceFile && mapping.originalLine != null) {
	          // Check if it can be mapped by the source map, then update the mapping.
	          var original = aSourceMapConsumer.originalPositionFor({
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          });
	          if (original.source != null) {
	            // Copy mapping
	            mapping.source = original.source;
	            if (aSourceMapPath != null) {
	              mapping.source = util.join(aSourceMapPath, mapping.source)
	            }
	            if (sourceRoot != null) {
	              mapping.source = util.relative(sourceRoot, mapping.source);
	            }
	            mapping.originalLine = original.line;
	            mapping.originalColumn = original.column;
	            if (original.name != null) {
	              mapping.name = original.name;
	            }
	          }
	        }
	
	        var source = mapping.source;
	        if (source != null && !newSources.has(source)) {
	          newSources.add(source);
	        }
	
	        var name = mapping.name;
	        if (name != null && !newNames.has(name)) {
	          newNames.add(name);
	        }
	
	      }, this);
	      this._sources = newSources;
	      this._names = newNames;
	
	      // Copy sourcesContents of applied map.
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aSourceMapPath != null) {
	            sourceFile = util.join(aSourceMapPath, sourceFile);
	          }
	          if (sourceRoot != null) {
	            sourceFile = util.relative(sourceRoot, sourceFile);
	          }
	          this.setSourceContent(sourceFile, content);
	        }
	      }, this);
	    };
	
	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping =
	    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                                aName) {
	      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	          && aGenerated.line > 0 && aGenerated.column >= 0
	          && !aOriginal && !aSource && !aName) {
	        // Case 1.
	        return;
	      }
	      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	               && aGenerated.line > 0 && aGenerated.column >= 0
	               && aOriginal.line > 0 && aOriginal.column >= 0
	               && aSource) {
	        // Cases 2 and 3.
	        return;
	      }
	      else {
	        throw new Error('Invalid mapping: ' + JSON.stringify({
	          generated: aGenerated,
	          source: aSource,
	          original: aOriginal,
	          name: aName
	        }));
	      }
	    };
	
	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings =
	    function SourceMapGenerator_serializeMappings() {
	      var previousGeneratedColumn = 0;
	      var previousGeneratedLine = 1;
	      var previousOriginalColumn = 0;
	      var previousOriginalLine = 0;
	      var previousName = 0;
	      var previousSource = 0;
	      var result = '';
	      var mapping;
	      var nameIdx;
	      var sourceIdx;
	
	      var mappings = this._mappings.toArray();
	      for (var i = 0, len = mappings.length; i < len; i++) {
	        mapping = mappings[i];
	
	        if (mapping.generatedLine !== previousGeneratedLine) {
	          previousGeneratedColumn = 0;
	          while (mapping.generatedLine !== previousGeneratedLine) {
	            result += ';';
	            previousGeneratedLine++;
	          }
	        }
	        else {
	          if (i > 0) {
	            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	              continue;
	            }
	            result += ',';
	          }
	        }
	
	        result += base64VLQ.encode(mapping.generatedColumn
	                                   - previousGeneratedColumn);
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (mapping.source != null) {
	          sourceIdx = this._sources.indexOf(mapping.source);
	          result += base64VLQ.encode(sourceIdx - previousSource);
	          previousSource = sourceIdx;
	
	          // lines are stored 0-based in SourceMap spec version 3
	          result += base64VLQ.encode(mapping.originalLine - 1
	                                     - previousOriginalLine);
	          previousOriginalLine = mapping.originalLine - 1;
	
	          result += base64VLQ.encode(mapping.originalColumn
	                                     - previousOriginalColumn);
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (mapping.name != null) {
	            nameIdx = this._names.indexOf(mapping.name);
	            result += base64VLQ.encode(nameIdx - previousName);
	            previousName = nameIdx;
	          }
	        }
	      }
	
	      return result;
	    };
	
	  SourceMapGenerator.prototype._generateSourcesContent =
	    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	      return aSources.map(function (source) {
	        if (!this._sourcesContents) {
	          return null;
	        }
	        if (aSourceRoot != null) {
	          source = util.relative(aSourceRoot, source);
	        }
	        var key = util.toSetString(source);
	        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
	                                                    key)
	          ? this._sourcesContents[key]
	          : null;
	      }, this);
	    };
	
	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON =
	    function SourceMapGenerator_toJSON() {
	      var map = {
	        version: this._version,
	        sources: this._sources.toArray(),
	        names: this._names.toArray(),
	        mappings: this._serializeMappings()
	      };
	      if (this._file != null) {
	        map.file = this._file;
	      }
	      if (this._sourceRoot != null) {
	        map.sourceRoot = this._sourceRoot;
	      }
	      if (this._sourcesContents) {
	        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	      }
	
	      return map;
	    };
	
	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString =
	    function SourceMapGenerator_toString() {
	      return JSON.stringify(this.toJSON());
	    };
	
	  exports.SourceMapGenerator = SourceMapGenerator;
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	{
	  var base64 = __webpack_require__(19);
	
	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011
	
	  var VLQ_BASE_SHIFT = 5;
	
	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0
	      ? ((-aValue) << 1) + 1
	      : (aValue << 1) + 0;
	  }
	
	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative
	      ? -shifted
	      : shifted;
	  }
	
	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  exports.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;
	
	    var vlq = toVLQSigned(aValue);
	
	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);
	
	    return encoded;
	  };
	
	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string via the out parameter.
	   */
	  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;
	
	    do {
	      if (aIndex >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	
	      digit = base64.decode(aStr.charCodeAt(aIndex++));
	      if (digit === -1) {
	        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	      }
	
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);
	
	    aOutParam.value = fromVLQSigned(result);
	    aOutParam.rest = aIndex;
	  };
	}


/***/ },
/* 19 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  exports.encode = function (number) {
	    if (0 <= number && number < intToCharMap.length) {
	      return intToCharMap[number];
	    }
	    throw new TypeError("Must be between 0 and 63: " + number);
	  };
	
	  /**
	   * Decode a single base 64 character code digit to an integer. Returns -1 on
	   * failure.
	   */
	  exports.decode = function (charCode) {
	    var bigA = 65;     // 'A'
	    var bigZ = 90;     // 'Z'
	
	    var littleA = 97;  // 'a'
	    var littleZ = 122; // 'z'
	
	    var zero = 48;     // '0'
	    var nine = 57;     // '9'
	
	    var plus = 43;     // '+'
	    var slash = 47;    // '/'
	
	    var littleOffset = 26;
	    var numberOffset = 52;
	
	    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	    if (bigA <= charCode && charCode <= bigZ) {
	      return (charCode - bigA);
	    }
	
	    // 26 - 51: abcdefghijklmnopqrstuvwxyz
	    if (littleA <= charCode && charCode <= littleZ) {
	      return (charCode - littleA + littleOffset);
	    }
	
	    // 52 - 61: 0123456789
	    if (zero <= charCode && charCode <= nine) {
	      return (charCode - zero + numberOffset);
	    }
	
	    // 62: +
	    if (charCode == plus) {
	      return 62;
	    }
	
	    // 63: /
	    if (charCode == slash) {
	      return 63;
	    }
	
	    // Invalid base64 digit.
	    return -1;
	  };
	}


/***/ },
/* 20 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }
	  exports.getArg = getArg;
	
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;
	
	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);
	    if (!match) {
	      return null;
	    }
	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }
	  exports.urlParse = urlParse;
	
	  function urlGenerate(aParsedUrl) {
	    var url = '';
	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }
	    url += '//';
	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }
	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }
	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port
	    }
	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }
	    return url;
	  }
	  exports.urlGenerate = urlGenerate;
	
	  /**
	   * Normalizes a path, or the path portion of a URL:
	   *
	   * - Replaces consequtive slashes with one slash.
	   * - Removes unnecessary '.' parts.
	   * - Removes unnecessary '<dir>/..' parts.
	   *
	   * Based on code in the Node.js 'path' core module.
	   *
	   * @param aPath The path or url to normalize.
	   */
	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);
	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }
	      path = url.path;
	    }
	    var isAbsolute = exports.isAbsolute(path);
	
	    var parts = path.split(/\/+/);
	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];
	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          // The first part is blank if the path is absolute. Trying to go
	          // above the root is a no-op. Therefore we can remove all '..' parts
	          // directly after the root.
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }
	    path = parts.join('/');
	
	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }
	
	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }
	    return path;
	  }
	  exports.normalize = normalize;
	
	  /**
	   * Joins two paths/URLs.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be joined with the root.
	   *
	   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	   *   first.
	   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	   *   is updated with the result and aRoot is returned. Otherwise the result
	   *   is returned.
	   *   - If aPath is absolute, the result is aPath.
	   *   - Otherwise the two paths are joined with a slash.
	   * - Joining for example 'http://' and 'www.example.com' is also supported.
	   */
	  function join(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	    if (aPath === "") {
	      aPath = ".";
	    }
	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);
	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    }
	
	    // `join(foo, '//www.example.org')`
	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }
	      return urlGenerate(aPathUrl);
	    }
	
	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }
	
	    // `join('http://', 'www.example.com')`
	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }
	
	    var joined = aPath.charAt(0) === '/'
	      ? aPath
	      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }
	    return joined;
	  }
	  exports.join = join;
	
	  exports.isAbsolute = function (aPath) {
	    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	  };
	
	  /**
	   * Make a path relative to a URL or another path.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be made relative to aRoot.
	   */
	  function relative(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	
	    aRoot = aRoot.replace(/\/$/, '');
	
	    // It is possible for the path to be above the root. In this case, simply
	    // checking whether the root is a prefix of the path won't work. Instead, we
	    // need to remove components from the root one by one, until either we find
	    // a prefix that fits, or we run out of components to remove.
	    var level = 0;
	    while (aPath.indexOf(aRoot + '/') !== 0) {
	      var index = aRoot.lastIndexOf("/");
	      if (index < 0) {
	        return aPath;
	      }
	
	      // If the only part of the root that is left is the scheme (i.e. http://,
	      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	      // have exhausted all components, so the path is not relative to the root.
	      aRoot = aRoot.slice(0, index);
	      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	        return aPath;
	      }
	
	      ++level;
	    }
	
	    // Make sure we add a "../" for each component we removed from the root.
	    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	  }
	  exports.relative = relative;
	
	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */
	  function toSetString(aStr) {
	    return '$' + aStr;
	  }
	  exports.toSetString = toSetString;
	
	  function fromSetString(aStr) {
	    return aStr.substr(1);
	  }
	  exports.fromSetString = fromSetString;
	
	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */
	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0 || onlyCompareOriginal) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  }
	  exports.compareByOriginalPositions = compareByOriginalPositions;
	
	  /**
	   * Comparator between two mappings with deflated source and name indices where
	   * the generated positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */
	  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0 || onlyCompareGenerated) {
	      return cmp;
	    }
	
	    cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  }
	  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	  function strcmp(aStr1, aStr2) {
	    if (aStr1 === aStr2) {
	      return 0;
	    }
	
	    if (aStr1 > aStr2) {
	      return 1;
	    }
	
	    return -1;
	  }
	
	  /**
	   * Comparator between two mappings with inflated source and name strings where
	   * the generated positions are compared.
	   */
	  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return strcmp(mappingA.name, mappingB.name);
	  }
	  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	
	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = {};
	  }
	
	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };
	
	  /**
	   * Return how many unique items are in this ArraySet. If duplicates have been
	   * added, than those do not count towards the size.
	   *
	   * @returns Number
	   */
	  ArraySet.prototype.size = function ArraySet_size() {
	    return Object.getOwnPropertyNames(this._set).length;
	  };
	
	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var sStr = util.toSetString(aStr);
	    var isDuplicate = this._set.hasOwnProperty(sStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      this._set[sStr] = idx;
	    }
	  };
	
	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    var sStr = util.toSetString(aStr);
	    return this._set.hasOwnProperty(sStr);
	  };
	
	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    var sStr = util.toSetString(aStr);
	    if (this._set.hasOwnProperty(sStr)) {
	      return this._set[sStr];
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };
	
	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };
	
	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };
	
	  exports.ArraySet = ArraySet;
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	
	  /**
	   * Determine whether mappingB is after mappingA with respect to generated
	   * position.
	   */
	  function generatedPositionAfter(mappingA, mappingB) {
	    // Optimized for most common case
	    var lineA = mappingA.generatedLine;
	    var lineB = mappingB.generatedLine;
	    var columnA = mappingA.generatedColumn;
	    var columnB = mappingB.generatedColumn;
	    return lineB > lineA || lineB == lineA && columnB >= columnA ||
	           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	  }
	
	  /**
	   * A data structure to provide a sorted view of accumulated mappings in a
	   * performance conscious manner. It trades a neglibable overhead in general
	   * case for a large speedup in case of mappings being added in order.
	   */
	  function MappingList() {
	    this._array = [];
	    this._sorted = true;
	    // Serves as infimum
	    this._last = {generatedLine: -1, generatedColumn: 0};
	  }
	
	  /**
	   * Iterate through internal items. This method takes the same arguments that
	   * `Array.prototype.forEach` takes.
	   *
	   * NOTE: The order of the mappings is NOT guaranteed.
	   */
	  MappingList.prototype.unsortedForEach =
	    function MappingList_forEach(aCallback, aThisArg) {
	      this._array.forEach(aCallback, aThisArg);
	    };
	
	  /**
	   * Add the given source mapping.
	   *
	   * @param Object aMapping
	   */
	  MappingList.prototype.add = function MappingList_add(aMapping) {
	    if (generatedPositionAfter(this._last, aMapping)) {
	      this._last = aMapping;
	      this._array.push(aMapping);
	    } else {
	      this._sorted = false;
	      this._array.push(aMapping);
	    }
	  };
	
	  /**
	   * Returns the flat, sorted array of mappings. The mappings are sorted by
	   * generated position.
	   *
	   * WARNING: This method returns internal data without copying, for
	   * performance. The return value must NOT be mutated, and should be treated as
	   * an immutable borrow. If you want to take ownership, you must make your own
	   * copy.
	   */
	  MappingList.prototype.toArray = function MappingList_toArray() {
	    if (!this._sorted) {
	      this._array.sort(util.compareByGeneratedPositionsInflated);
	      this._sorted = true;
	    }
	    return this._array;
	  };
	
	  exports.MappingList = MappingList;
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	  var binarySearch = __webpack_require__(24);
	  var ArraySet = __webpack_require__(21).ArraySet;
	  var base64VLQ = __webpack_require__(18);
	  var quickSort = __webpack_require__(25).quickSort;
	
	  function SourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    return sourceMap.sections != null
	      ? new IndexedSourceMapConsumer(sourceMap)
	      : new BasicSourceMapConsumer(sourceMap);
	  }
	
	  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	  }
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;
	
	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.
	
	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    get: function () {
	      if (!this.__generatedMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__generatedMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    get: function () {
	      if (!this.__originalMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__originalMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype._charIsMappingSeparator =
	    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	      var c = aStr.charAt(index);
	      return c === ";" || c === ",";
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      throw new Error("Subclasses must implement _parseMappings");
	    };
	
	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping =
	    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	      var context = aContext || null;
	      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	      var mappings;
	      switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	      }
	
	      var sourceRoot = this.sourceRoot;
	      mappings.map(function (mapping) {
	        var source = mapping.source === null ? null : this._sources.at(mapping.source);
	        if (source != null && sourceRoot != null) {
	          source = util.join(sourceRoot, source);
	        }
	        return {
	          source: source,
	          generatedLine: mapping.generatedLine,
	          generatedColumn: mapping.generatedColumn,
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: mapping.name === null ? null : this._names.at(mapping.name)
	        };
	      }, this).forEach(aCallback, context);
	    };
	
	  /**
	   * Returns all generated line and column information for the original source,
	   * line, and column provided. If no column is provided, returns all mappings
	   * corresponding to a either the line we are searching for or the next
	   * closest line that has any mappings. Otherwise, returns all mappings
	   * corresponding to the given line and either the column we are searching for
	   * or the next closest column that has any offsets.
	   *
	   * The only argument is an object with the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: Optional. the column number in the original source.
	   *
	   * and an array of objects is returned, each with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  SourceMapConsumer.prototype.allGeneratedPositionsFor =
	    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	      var line = util.getArg(aArgs, 'line');
	
	      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	      // returns the index of the closest mapping less than the needle. By
	      // setting needle.originalColumn to 0, we thus find the last mapping for
	      // the given line, provided such a mapping exists.
	      var needle = {
	        source: util.getArg(aArgs, 'source'),
	        originalLine: line,
	        originalColumn: util.getArg(aArgs, 'column', 0)
	      };
	
	      if (this.sourceRoot != null) {
	        needle.source = util.relative(this.sourceRoot, needle.source);
	      }
	      if (!this._sources.has(needle.source)) {
	        return [];
	      }
	      needle.source = this._sources.indexOf(needle.source);
	
	      var mappings = [];
	
	      var index = this._findMapping(needle,
	                                    this._originalMappings,
	                                    "originalLine",
	                                    "originalColumn",
	                                    util.compareByOriginalPositions,
	                                    binarySearch.LEAST_UPPER_BOUND);
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (aArgs.column === undefined) {
	          var originalLine = mapping.originalLine;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we found. Since
	          // mappings are sorted, this is guaranteed to find all mappings for
	          // the line we found.
	          while (mapping && mapping.originalLine === originalLine) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        } else {
	          var originalColumn = mapping.originalColumn;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we were searching for.
	          // Since mappings are sorted, this is guaranteed to find all mappings for
	          // the line we are searching for.
	          while (mapping &&
	                 mapping.originalLine === line &&
	                 mapping.originalColumn == originalColumn) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        }
	      }
	
	      return mappings;
	    };
	
	  exports.SourceMapConsumer = SourceMapConsumer;
	
	  /**
	   * A BasicSourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The only parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: Optional. The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function BasicSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);
	
	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    sources = sources
	      // Some source maps produce relative source paths like "./foo.js" instead of
	      // "foo.js".  Normalize these first so that future comparisons will succeed.
	      // See bugzil.la/1090768.
	      .map(util.normalize)
	      // Always ensure that absolute sources are internally stored relative to
	      // the source root, if the source root is absolute. Not doing this would
	      // be particularly problematic when the source root is a prefix of the
	      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	      .map(function (source) {
	        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	          ? util.relative(sourceRoot, source)
	          : source;
	      });
	
	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names, true);
	    this._sources = ArraySet.fromArray(sources, true);
	
	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this.file = file;
	  }
	
	  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	  /**
	   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @returns BasicSourceMapConsumer
	   */
	  BasicSourceMapConsumer.fromSourceMap =
	    function SourceMapConsumer_fromSourceMap(aSourceMap) {
	      var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	      smc.sourceRoot = aSourceMap._sourceRoot;
	      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                              smc.sourceRoot);
	      smc.file = aSourceMap._file;
	
	      // Because we are modifying the entries (by converting string sources and
	      // names to indices into the sources and names ArraySets), we have to make
	      // a copy of the entry or else bad things happen. Shared mutable state
	      // strikes again! See github issue #191.
	
	      var generatedMappings = aSourceMap._mappings.toArray().slice();
	      var destGeneratedMappings = smc.__generatedMappings = [];
	      var destOriginalMappings = smc.__originalMappings = [];
	
	      for (var i = 0, length = generatedMappings.length; i < length; i++) {
	        var srcMapping = generatedMappings[i];
	        var destMapping = new Mapping;
	        destMapping.generatedLine = srcMapping.generatedLine;
	        destMapping.generatedColumn = srcMapping.generatedColumn;
	
	        if (srcMapping.source) {
	          destMapping.source = sources.indexOf(srcMapping.source);
	          destMapping.originalLine = srcMapping.originalLine;
	          destMapping.originalColumn = srcMapping.originalColumn;
	
	          if (srcMapping.name) {
	            destMapping.name = names.indexOf(srcMapping.name);
	          }
	
	          destOriginalMappings.push(destMapping);
	        }
	
	        destGeneratedMappings.push(destMapping);
	      }
	
	      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	      return smc;
	    };
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  BasicSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._sources.toArray().map(function (s) {
	        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	      }, this);
	    }
	  });
	
	  /**
	   * Provide the JIT with a nice shape / hidden class.
	   */
	  function Mapping() {
	    this.generatedLine = 0;
	    this.generatedColumn = 0;
	    this.source = null;
	    this.originalLine = null;
	    this.originalColumn = null;
	    this.name = null;
	  }
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  BasicSourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      var generatedLine = 1;
	      var previousGeneratedColumn = 0;
	      var previousOriginalLine = 0;
	      var previousOriginalColumn = 0;
	      var previousSource = 0;
	      var previousName = 0;
	      var length = aStr.length;
	      var index = 0;
	      var cachedSegments = {};
	      var temp = {};
	      var originalMappings = [];
	      var generatedMappings = [];
	      var mapping, str, segment, end, value;
	
	      while (index < length) {
	        if (aStr.charAt(index) === ';') {
	          generatedLine++;
	          index++;
	          previousGeneratedColumn = 0;
	        }
	        else if (aStr.charAt(index) === ',') {
	          index++;
	        }
	        else {
	          mapping = new Mapping();
	          mapping.generatedLine = generatedLine;
	
	          // Because each offset is encoded relative to the previous one,
	          // many segments often have the same encoding. We can exploit this
	          // fact by caching the parsed variable length fields of each segment,
	          // allowing us to avoid a second parse if we encounter the same
	          // segment again.
	          for (end = index; end < length; end++) {
	            if (this._charIsMappingSeparator(aStr, end)) {
	              break;
	            }
	          }
	          str = aStr.slice(index, end);
	
	          segment = cachedSegments[str];
	          if (segment) {
	            index += str.length;
	          } else {
	            segment = [];
	            while (index < end) {
	              base64VLQ.decode(aStr, index, temp);
	              value = temp.value;
	              index = temp.rest;
	              segment.push(value);
	            }
	
	            if (segment.length === 2) {
	              throw new Error('Found a source, but no line and column');
	            }
	
	            if (segment.length === 3) {
	              throw new Error('Found a source and line, but no column');
	            }
	
	            cachedSegments[str] = segment;
	          }
	
	          // Generated column.
	          mapping.generatedColumn = previousGeneratedColumn + segment[0];
	          previousGeneratedColumn = mapping.generatedColumn;
	
	          if (segment.length > 1) {
	            // Original source.
	            mapping.source = previousSource + segment[1];
	            previousSource += segment[1];
	
	            // Original line.
	            mapping.originalLine = previousOriginalLine + segment[2];
	            previousOriginalLine = mapping.originalLine;
	            // Lines are stored 0-based
	            mapping.originalLine += 1;
	
	            // Original column.
	            mapping.originalColumn = previousOriginalColumn + segment[3];
	            previousOriginalColumn = mapping.originalColumn;
	
	            if (segment.length > 4) {
	              // Original name.
	              mapping.name = previousName + segment[4];
	              previousName += segment[4];
	            }
	          }
	
	          generatedMappings.push(mapping);
	          if (typeof mapping.originalLine === 'number') {
	            originalMappings.push(mapping);
	          }
	        }
	      }
	
	      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	      this.__generatedMappings = generatedMappings;
	
	      quickSort(originalMappings, util.compareByOriginalPositions);
	      this.__originalMappings = originalMappings;
	    };
	
	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  BasicSourceMapConsumer.prototype._findMapping =
	    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                           aColumnName, aComparator, aBias) {
	      // To return the position we are searching for, we must first find the
	      // mapping for the given position and then return the opposite position it
	      // points to. Because the mappings are sorted, we can use binary search to
	      // find the best mapping.
	
	      if (aNeedle[aLineName] <= 0) {
	        throw new TypeError('Line must be greater than or equal to 1, got '
	                            + aNeedle[aLineName]);
	      }
	      if (aNeedle[aColumnName] < 0) {
	        throw new TypeError('Column must be greater than or equal to 0, got '
	                            + aNeedle[aColumnName]);
	      }
	
	      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	    };
	
	  /**
	   * Compute the last column for each generated mapping. The last column is
	   * inclusive.
	   */
	  BasicSourceMapConsumer.prototype.computeColumnSpans =
	    function SourceMapConsumer_computeColumnSpans() {
	      for (var index = 0; index < this._generatedMappings.length; ++index) {
	        var mapping = this._generatedMappings[index];
	
	        // Mappings do not contain a field for the last generated columnt. We
	        // can come up with an optimistic estimate, however, by assuming that
	        // mappings are contiguous (i.e. given two consecutive mappings, the
	        // first mapping ends where the second one starts).
	        if (index + 1 < this._generatedMappings.length) {
	          var nextMapping = this._generatedMappings[index + 1];
	
	          if (mapping.generatedLine === nextMapping.generatedLine) {
	            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	            continue;
	          }
	        }
	
	        // The last mapping for each line spans the entire line.
	        mapping.lastGeneratedColumn = Infinity;
	      }
	    };
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  BasicSourceMapConsumer.prototype.originalPositionFor =
	    function SourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._generatedMappings,
	        "generatedLine",
	        "generatedColumn",
	        util.compareByGeneratedPositionsDeflated,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._generatedMappings[index];
	
	        if (mapping.generatedLine === needle.generatedLine) {
	          var source = util.getArg(mapping, 'source', null);
	          if (source !== null) {
	            source = this._sources.at(source);
	            if (this.sourceRoot != null) {
	              source = util.join(this.sourceRoot, source);
	            }
	          }
	          var name = util.getArg(mapping, 'name', null);
	          if (name !== null) {
	            name = this._names.at(name);
	          }
	          return {
	            source: source,
	            line: util.getArg(mapping, 'originalLine', null),
	            column: util.getArg(mapping, 'originalColumn', null),
	            name: name
	          };
	        }
	      }
	
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function BasicSourceMapConsumer_hasContentsOfAllSources() {
	      if (!this.sourcesContent) {
	        return false;
	      }
	      return this.sourcesContent.length >= this._sources.size() &&
	        !this.sourcesContent.some(function (sc) { return sc == null; });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  BasicSourceMapConsumer.prototype.sourceContentFor =
	    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      if (!this.sourcesContent) {
	        return null;
	      }
	
	      if (this.sourceRoot != null) {
	        aSource = util.relative(this.sourceRoot, aSource);
	      }
	
	      if (this._sources.has(aSource)) {
	        return this.sourcesContent[this._sources.indexOf(aSource)];
	      }
	
	      var url;
	      if (this.sourceRoot != null
	          && (url = util.urlParse(this.sourceRoot))) {
	        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	        // many users. We can help them out when they expect file:// URIs to
	        // behave like it would if they were running a local HTTP server. See
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	        if (url.scheme == "file"
	            && this._sources.has(fileUriAbsPath)) {
	          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	        }
	
	        if ((!url.path || url.path == "/")
	            && this._sources.has("/" + aSource)) {
	          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	        }
	      }
	
	      // This function is used recursively from
	      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	      // don't want to throw if we can't find the source - we just want to
	      // return null, so we provide a flag to exit gracefully.
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  BasicSourceMapConsumer.prototype.generatedPositionFor =
	    function SourceMapConsumer_generatedPositionFor(aArgs) {
	      var source = util.getArg(aArgs, 'source');
	      if (this.sourceRoot != null) {
	        source = util.relative(this.sourceRoot, source);
	      }
	      if (!this._sources.has(source)) {
	        return {
	          line: null,
	          column: null,
	          lastColumn: null
	        };
	      }
	      source = this._sources.indexOf(source);
	
	      var needle = {
	        source: source,
	        originalLine: util.getArg(aArgs, 'line'),
	        originalColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._originalMappings,
	        "originalLine",
	        "originalColumn",
	        util.compareByOriginalPositions,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (mapping.source === needle.source) {
	          return {
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          };
	        }
	      }
	
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    };
	
	  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	  /**
	   * An IndexedSourceMapConsumer instance represents a parsed source map which
	   * we can query for information. It differs from BasicSourceMapConsumer in
	   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	   * input.
	   *
	   * The only parameter is a raw source map (either as a JSON string, or already
	   * parsed to an object). According to the spec for indexed source maps, they
	   * have the following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - file: Optional. The generated file this source map is associated with.
	   *   - sections: A list of section definitions.
	   *
	   * Each value under the "sections" field has two fields:
	   *   - offset: The offset into the original specified at which this section
	   *       begins to apply, defined as an object with a "line" and "column"
	   *       field.
	   *   - map: A source map definition. This source map could also be indexed,
	   *       but doesn't have to be.
	   *
	   * Instead of the "map" field, it's also possible to have a "url" field
	   * specifying a URL to retrieve a source map from, but that's currently
	   * unsupported.
	   *
	   * Here's an example source map, taken from the source map spec[0], but
	   * modified to omit a section which uses the "url" field.
	   *
	   *  {
	   *    version : 3,
	   *    file: "app.js",
	   *    sections: [{
	   *      offset: {line:100, column:10},
	   *      map: {
	   *        version : 3,
	   *        file: "section.js",
	   *        sources: ["foo.js", "bar.js"],
	   *        names: ["src", "maps", "are", "fun"],
	   *        mappings: "AAAA,E;;ABCDE;"
	   *      }
	   *    }],
	   *  }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	   */
	  function IndexedSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sections = util.getArg(sourceMap, 'sections');
	
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	
	    var lastOffset = {
	      line: -1,
	      column: 0
	    };
	    this._sections = sections.map(function (s) {
	      if (s.url) {
	        // The url field will require support for asynchronicity.
	        // See https://github.com/mozilla/source-map/issues/16
	        throw new Error('Support for url field in sections not implemented.');
	      }
	      var offset = util.getArg(s, 'offset');
	      var offsetLine = util.getArg(offset, 'line');
	      var offsetColumn = util.getArg(offset, 'column');
	
	      if (offsetLine < lastOffset.line ||
	          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	        throw new Error('Section offsets must be ordered and non-overlapping.');
	      }
	      lastOffset = offset;
	
	      return {
	        generatedOffset: {
	          // The offset fields are 0-based, but we use 1-based indices when
	          // encoding/decoding from VLQ.
	          generatedLine: offsetLine + 1,
	          generatedColumn: offsetColumn + 1
	        },
	        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	      }
	    });
	  }
	
	  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  IndexedSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      var sources = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	          sources.push(this._sections[i].consumer.sources[j]);
	        }
	      }
	      return sources;
	    }
	  });
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  IndexedSourceMapConsumer.prototype.originalPositionFor =
	    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      // Find the section containing the generated position we're trying to map
	      // to an original position.
	      var sectionIndex = binarySearch.search(needle, this._sections,
	        function(needle, section) {
	          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	          if (cmp) {
	            return cmp;
	          }
	
	          return (needle.generatedColumn -
	                  section.generatedOffset.generatedColumn);
	        });
	      var section = this._sections[sectionIndex];
	
	      if (!section) {
	        return {
	          source: null,
	          line: null,
	          column: null,
	          name: null
	        };
	      }
	
	      return section.consumer.originalPositionFor({
	        line: needle.generatedLine -
	          (section.generatedOffset.generatedLine - 1),
	        column: needle.generatedColumn -
	          (section.generatedOffset.generatedLine === needle.generatedLine
	           ? section.generatedOffset.generatedColumn - 1
	           : 0),
	        bias: aArgs.bias
	      });
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	      return this._sections.every(function (s) {
	        return s.consumer.hasContentsOfAllSources();
	      });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  IndexedSourceMapConsumer.prototype.sourceContentFor =
	    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        var content = section.consumer.sourceContentFor(aSource, true);
	        if (content) {
	          return content;
	        }
	      }
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  IndexedSourceMapConsumer.prototype.generatedPositionFor =
	    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        // Only consider this section if the requested source is in the list of
	        // sources of the consumer.
	        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	          continue;
	        }
	        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	        if (generatedPosition) {
	          var ret = {
	            line: generatedPosition.line +
	              (section.generatedOffset.generatedLine - 1),
	            column: generatedPosition.column +
	              (section.generatedOffset.generatedLine === generatedPosition.line
	               ? section.generatedOffset.generatedColumn - 1
	               : 0)
	          };
	          return ret;
	        }
	      }
	
	      return {
	        line: null,
	        column: null
	      };
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  IndexedSourceMapConsumer.prototype._parseMappings =
	    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      this.__generatedMappings = [];
	      this.__originalMappings = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	        var sectionMappings = section.consumer._generatedMappings;
	        for (var j = 0; j < sectionMappings.length; j++) {
	          var mapping = sectionMappings[j];
	
	          var source = section.consumer._sources.at(mapping.source);
	          if (section.consumer.sourceRoot !== null) {
	            source = util.join(section.consumer.sourceRoot, source);
	          }
	          this._sources.add(source);
	          source = this._sources.indexOf(source);
	
	          var name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	
	          // The mappings coming from the consumer for the section have
	          // generated positions relative to the start of the section, so we
	          // need to offset them to be relative to the start of the concatenated
	          // generated file.
	          var adjustedMapping = {
	            source: source,
	            generatedLine: mapping.generatedLine +
	              (section.generatedOffset.generatedLine - 1),
	            generatedColumn: mapping.generatedColumn +
	              (section.generatedOffset.generatedLine === mapping.generatedLine
	              ? section.generatedOffset.generatedColumn - 1
	              : 0),
	            originalLine: mapping.originalLine,
	            originalColumn: mapping.originalColumn,
	            name: name
	          };
	
	          this.__generatedMappings.push(adjustedMapping);
	          if (typeof adjustedMapping.originalLine === 'number') {
	            this.__originalMappings.push(adjustedMapping);
	          }
	        }
	      }
	
	      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	      quickSort(this.__originalMappings, util.compareByOriginalPositions);
	    };
	
	  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	}


/***/ },
/* 24 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  exports.GREATEST_LOWER_BOUND = 1;
	  exports.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Recursive implementation of binary search.
	   *
	   * @param aLow Indices here and lower do not contain the needle.
	   * @param aHigh Indices here and higher do not contain the needle.
	   * @param aNeedle The element being searched for.
	   * @param aHaystack The non-empty array being searched.
	   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   */
	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	    // This function terminates when one of the following is true:
	    //
	    //   1. We find the exact element we are looking for.
	    //
	    //   2. We did not find the exact element, but we can return the index of
	    //      the next-closest element.
	    //
	    //   3. We did not find the exact element, and there is no next-closest
	    //      element than the one we are searching for, so we return -1.
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);
	    if (cmp === 0) {
	      // Found the element we are looking for.
	      return mid;
	    }
	    else if (cmp > 0) {
	      // Our needle is greater than aHaystack[mid].
	      if (aHigh - mid > 1) {
	        // The element is in the upper half.
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // The exact needle element was not found in this haystack. Determine if
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return aHigh < aHaystack.length ? aHigh : -1;
	      } else {
	        return mid;
	      }
	    }
	    else {
	      // Our needle is less than aHaystack[mid].
	      if (mid - aLow > 1) {
	        // The element is in the lower half.
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return mid;
	      } else {
	        return aLow < 0 ? -1 : aLow;
	      }
	    }
	  }
	
	  /**
	   * This is an implementation of binary search which will always try and return
	   * the index of the closest element if there is no exact hit. This is because
	   * mappings between original and generated line/col pairs are single points,
	   * and there is an implicit region between each of them, so a miss just means
	   * that you aren't on the very start of a region.
	   *
	   * @param aNeedle The element you are looking for.
	   * @param aHaystack The array that is being searched.
	   * @param aCompare A function which takes the needle and an element in the
	   *     array and returns -1, 0, or 1 depending on whether the needle is less
	   *     than, equal to, or greater than the element, respectively.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	   */
	  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	    if (aHaystack.length === 0) {
	      return -1;
	    }
	
	    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	    if (index < 0) {
	      return -1;
	    }
	
	    // We have found either the exact element, or the next-closest element than
	    // the one we are searching for. However, there may be more than one such
	    // element. Make sure we always return the smallest of these.
	    while (index - 1 >= 0) {
	      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	        break;
	      }
	      --index;
	    }
	
	    return index;
	  };
	}


/***/ },
/* 25 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  // It turns out that some (most?) JavaScript engines don't self-host
	  // `Array.prototype.sort`. This makes sense because C++ will likely remain
	  // faster than JS when doing raw CPU-intensive sorting. However, when using a
	  // custom comparator function, calling back and forth between the VM's C++ and
	  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
	  // worse generated code for the comparator function than would be optimal. In
	  // fact, when sorting with a comparator, these costs outweigh the benefits of
	  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	  // a ~3500ms mean speed-up in `bench/bench.html`.
	
	  /**
	   * Swap the elements indexed by `x` and `y` in the array `ary`.
	   *
	   * @param {Array} ary
	   *        The array.
	   * @param {Number} x
	   *        The index of the first item.
	   * @param {Number} y
	   *        The index of the second item.
	   */
	  function swap(ary, x, y) {
	    var temp = ary[x];
	    ary[x] = ary[y];
	    ary[y] = temp;
	  }
	
	  /**
	   * Returns a random integer within the range `low .. high` inclusive.
	   *
	   * @param {Number} low
	   *        The lower bound on the range.
	   * @param {Number} high
	   *        The upper bound on the range.
	   */
	  function randomIntInRange(low, high) {
	    return Math.round(low + (Math.random() * (high - low)));
	  }
	
	  /**
	   * The Quick Sort algorithm.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   * @param {Number} p
	   *        Start index of the array
	   * @param {Number} r
	   *        End index of the array
	   */
	  function doQuickSort(ary, comparator, p, r) {
	    // If our lower bound is less than our upper bound, we (1) partition the
	    // array into two pieces and (2) recurse on each half. If it is not, this is
	    // the empty array and our base case.
	
	    if (p < r) {
	      // (1) Partitioning.
	      //
	      // The partitioning chooses a pivot between `p` and `r` and moves all
	      // elements that are less than or equal to the pivot to the before it, and
	      // all the elements that are greater than it after it. The effect is that
	      // once partition is done, the pivot is in the exact place it will be when
	      // the array is put in sorted order, and it will not need to be moved
	      // again. This runs in O(n) time.
	
	      // Always choose a random pivot so that an input array which is reverse
	      // sorted does not cause O(n^2) running time.
	      var pivotIndex = randomIntInRange(p, r);
	      var i = p - 1;
	
	      swap(ary, pivotIndex, r);
	      var pivot = ary[r];
	
	      // Immediately after `j` is incremented in this loop, the following hold
	      // true:
	      //
	      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	      //
	      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	      for (var j = p; j < r; j++) {
	        if (comparator(ary[j], pivot) <= 0) {
	          i += 1;
	          swap(ary, i, j);
	        }
	      }
	
	      swap(ary, i + 1, j);
	      var q = i + 1;
	
	      // (2) Recurse on each half.
	
	      doQuickSort(ary, comparator, p, q - 1);
	      doQuickSort(ary, comparator, q + 1, r);
	    }
	  }
	
	  /**
	   * Sort the given array in-place with the given comparator function.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   */
	  exports.quickSort = function (ary, comparator) {
	    doQuickSort(ary, comparator, 0, ary.length - 1);
	  };
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var SourceMapGenerator = __webpack_require__(17).SourceMapGenerator;
	  var util = __webpack_require__(20);
	
	  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	  // operating systems these days (capturing the result).
	  var REGEX_NEWLINE = /(\r?\n)/;
	
	  // Newline character code for charCodeAt() comparisons
	  var NEWLINE_CODE = 10;
	
	  // Private symbol for identifying `SourceNode`s when multiple versions of
	  // the source-map library are loaded. This MUST NOT CHANGE across
	  // versions!
	  var isSourceNode = "$$$isSourceNode$$$";
	
	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine == null ? null : aLine;
	    this.column = aColumn == null ? null : aColumn;
	    this.source = aSource == null ? null : aSource;
	    this.name = aName == null ? null : aName;
	    this[isSourceNode] = true;
	    if (aChunks != null) this.add(aChunks);
	  }
	
	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   * @param aRelativePath Optional. The path that relative sources in the
	   *        SourceMapConsumer should be relative to.
	   */
	  SourceNode.fromStringWithSourceMap =
	    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	      // The SourceNode we want to fill with the generated code
	      // and the SourceMap
	      var node = new SourceNode();
	
	      // All even indices of this array are one line of the generated code,
	      // while all odd indices are the newlines between two adjacent lines
	      // (since `REGEX_NEWLINE` captures its match).
	      // Processed fragments are removed from this array, by calling `shiftNextLine`.
	      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	      var shiftNextLine = function() {
	        var lineContents = remainingLines.shift();
	        // The last line of a file might not have a newline.
	        var newLine = remainingLines.shift() || "";
	        return lineContents + newLine;
	      };
	
	      // We need to remember the position of "remainingLines"
	      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	      // The generate SourceNodes we need a code range.
	      // To extract it current and last mapping is used.
	      // Here we store the last mapping.
	      var lastMapping = null;
	
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        if (lastMapping !== null) {
	          // We add the code from "lastMapping" to "mapping":
	          // First check if there is a new line in between.
	          if (lastGeneratedLine < mapping.generatedLine) {
	            // Associate first line with "lastMapping"
	            addMappingWithCode(lastMapping, shiftNextLine());
	            lastGeneratedLine++;
	            lastGeneratedColumn = 0;
	            // The remaining code is added without mapping
	          } else {
	            // There is no new line in between.
	            // Associate the code between "lastGeneratedColumn" and
	            // "mapping.generatedColumn" with "lastMapping"
	            var nextLine = remainingLines[0];
	            var code = nextLine.substr(0, mapping.generatedColumn -
	                                          lastGeneratedColumn);
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                                lastGeneratedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	            addMappingWithCode(lastMapping, code);
	            // No more remaining code, continue
	            lastMapping = mapping;
	            return;
	          }
	        }
	        // We add the generated code until the first mapping
	        // to the SourceNode without any mapping.
	        // Each line is added as separate string.
	        while (lastGeneratedLine < mapping.generatedLine) {
	          node.add(shiftNextLine());
	          lastGeneratedLine++;
	        }
	        if (lastGeneratedColumn < mapping.generatedColumn) {
	          var nextLine = remainingLines[0];
	          node.add(nextLine.substr(0, mapping.generatedColumn));
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	        }
	        lastMapping = mapping;
	      }, this);
	      // We have processed all mappings.
	      if (remainingLines.length > 0) {
	        if (lastMapping) {
	          // Associate the remaining code in the current line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	        }
	        // and add the remaining lines without any mapping
	        node.add(remainingLines.join(""));
	      }
	
	      // Copy sourcesContent into SourceNode
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aRelativePath != null) {
	            sourceFile = util.join(aRelativePath, sourceFile);
	          }
	          node.setSourceContent(sourceFile, content);
	        }
	      });
	
	      return node;
	
	      function addMappingWithCode(mapping, code) {
	        if (mapping === null || mapping.source === undefined) {
	          node.add(code);
	        } else {
	          var source = aRelativePath
	            ? util.join(aRelativePath, mapping.source)
	            : mapping.source;
	          node.add(new SourceNode(mapping.originalLine,
	                                  mapping.originalColumn,
	                                  source,
	                                  code,
	                                  mapping.name));
	        }
	      }
	    };
	
	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length-1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk[isSourceNode]) {
	        chunk.walk(aFn);
	      }
	      else {
	        if (chunk !== '') {
	          aFn(chunk, { source: this.source,
	                       line: this.line,
	                       column: this.column,
	                       name: this.name });
	        }
	      }
	    }
	  };
	
	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len-1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };
	
	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild[isSourceNode]) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    }
	    else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    }
	    else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };
	
	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent =
	    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	    };
	
	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents =
	    function SourceNode_walkSourceContents(aFn) {
	      for (var i = 0, len = this.children.length; i < len; i++) {
	        if (this.children[i][isSourceNode]) {
	          this.children[i].walkSourceContents(aFn);
	        }
	      }
	
	      var sources = Object.keys(this.sourceContents);
	      for (var i = 0, len = sources.length; i < len; i++) {
	        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	      }
	    };
	
	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };
	
	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null
	          && original.line !== null
	          && original.column !== null) {
	        if(lastOriginalSource !== original.source
	           || lastOriginalLine !== original.line
	           || lastOriginalColumn !== original.column
	           || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      for (var idx = 0, length = chunk.length; idx < length; idx++) {
	        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	          generated.line++;
	          generated.column = 0;
	          // Mappings end at eol
	          if (idx + 1 === length) {
	            lastOriginalSource = null;
	            sourceMappingActive = false;
	          } else if (sourceMappingActive) {
	            map.addMapping({
	              source: original.source,
	              original: {
	                line: original.line,
	                column: original.column
	              },
	              generated: {
	                line: generated.line,
	                column: generated.column
	              },
	              name: original.name
	            });
	          }
	        } else {
	          generated.column++;
	        }
	      }
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });
	
	    return { code: generated.code, map: map };
	  };
	
	  exports.SourceNode = SourceNode;
	}


/***/ },
/* 27 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		
		function Region(a,b,root,view){
			this._a = a;
			this._b = b;
			this._root = root;
			this._view = view;
			return this;
		};
		
		exports.Region = Region; // export class 
		
		
		Region.prototype.a = function(v){ return this._a; }
		Region.prototype.setA = function(v){ this._a = v; return this; };
		
		
		Region.prototype.b = function(v){ return this._b; }
		Region.prototype.setB = function(v){ this._b = v; return this; };
		
		
		Region.prototype.view = function(v){ return this._view; }
		Region.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Region.prototype.root = function(v){ return this._root; }
		Region.prototype.setRoot = function(v){ this._root = v; return this; };
		
		// remove root from region
		
		Region.normalize = function (val,view){
			var line_;
			if (val instanceof Region) { return val };
			if (val instanceof Array) { return new Region(val[0],val[1],null,view) };
			if ((typeof val=='number'||val instanceof Number)) { return new Region(val,val,null,view) };
			
			if ((val instanceof Object) && (typeof (line_ = val.line)=='number'||line_ instanceof Number)) {
				var lines = view._buffer.lines();
				var loc = 0;
				for (var i = 0, ary = iter$(lines), len = ary.length; i < len; i++) {
					if (i < (val.line - 1)) {
						loc += ary[i].length + 1;
					} else {
						break;
					};
				};
				
				loc += (val.column || 0);
				return new Region(loc,loc,null,view);
			};
		};
		
		
		Region.prototype.start = function (){
			return Math.min(this._a,this._b);
		};
		
		Region.prototype.end = function (){
			return Math.max(this._a,this._b);
		};
		
		Region.prototype.clone = function (ad,bd){
			if(ad === undefined) ad = 0;
			if(bd === undefined) bd = 0;
			return new Region(this._a + ad,this._b + bd,this._root,this._view);
		};
		
		Region.prototype.contains = function (rel){
			if (rel instanceof Region) {
				return this.start() <= rel.start() && this.end() >= rel.end();
			} else if ((typeof rel=='number'||rel instanceof Number)) {
				return this.start() <= rel && this.end() >= rel;
			};
		};
		
		Region.prototype.adjust = function (rel,add){
			if(add === undefined) add = true;
			if (rel.end() < this.start()) {
				add ? (this.move(rel.size())) : (this.move(-rel.size()));
			};
			return this;
		};
		
		Region.prototype.intersects = function (rel){
			// is this decent?
			rel = Region.normalize(rel);
			var a = Math.max(this.start(),rel.start());
			var b = Math.min(this.end(),rel.end());
			return b >= a;
		};
		
		Region.prototype.relativeTo = function (rel){
			// could use move instead
			return new Region(this._a - rel.start(),this._b - rel.start(),this._root,this._view);
		};
		
		Region.prototype.intersection = function (region){
			return this;
		};
		
		Region.prototype.equals = function (region){
			return this.start() == region.start() && this.end() == region.end();
		};
		
		Region.prototype.same = function (region){
			return region && region.a() == this.a() && region.b() == this.b();
		};
		
		Region.prototype.size = function (){
			return this.end() - this.start();
		};
		
		Region.prototype.move = function (num){
			if(num === undefined) num = 1;
			this._a += num;
			this._b += num;
			return this;
		};
		
		Region.prototype.collapsed = function (){
			return this.size() == 0;
		};
		
		Region.prototype.reverse = function (){
			var a = this._a,b = this._b;
			this._a = b;
			this._b = a;
			return this;
		};
		
		Region.prototype.reversed = function (){
			return this._a > this._b;
		};
		
		Region.prototype.normalize = function (){
			var a = this.start();
			var b = this.end();
			this._a = a;
			this._b = b;
			return this;
		};
		
		Region.prototype.collapse = function (forward){
			if(forward === undefined) forward = true;
			if (forward) {
				this._a = this._b = this.end();
				// @a = @b
			} else {
				this._b = this._a;
				this._a = this._b = this.start();
			};
			return this;
		};
		
		// expand to closest /n
		Region.prototype.expand = function (atStart,atEnd){
			if (this.b() < this.a()) {
				this._b += atStart;
				this._a += atEnd;
			} else {
				this._a += atStart;
				this._b += atEnd;
			};
			return this;
		};
		
		Region.prototype.text = function (){
			return this.view().substr(this);
		};
		
		Region.prototype.toString = function (){
			return ("[" + (this._a) + "," + (this._b) + "]");
		};
		
		Region.prototype.insert = function (node){
			return this;
		};
		
		Region.prototype.nodes = function (includeEnds){
			if(includeEnds === undefined) includeEnds = true;
			return this.view().nodesInRegion(this,includeEnds);
		};
		
		Region.prototype.prevNode = function (query){
			var nodes = this.nodes(false);
			var node = nodes.lft;
			if ((query instanceof Imba.Selector) || (typeof query=='string'||query instanceof String)) {
				var $1;while (node){
					if (node.matches(query)) { return node };
					node = ($1 = node) && $1.isLast  &&  $1.isLast() ? (node.parent()) : (null);
				};
				return null;
			};
			return node;
		};
		
		Region.prototype.nextNode = function (query){
			var nodes = this.nodes(false);
			var node = nodes.rgt;
			if ((query instanceof Imba.Selector) || (typeof query=='string'||query instanceof String)) {
				var $1;while (node){
					if (node.matches(query)) { return node };
					node = ($1 = node) && $1.isFirst  &&  $1.isFirst() ? (node.parent()) : (null);
				};
				return null;
			};
			return node;
		};
		
		Region.prototype.scope = function (query){
			var nodes = this.nodes(false);
			var node;
			if (nodes.lft) {
				node = nodes.lft.up(query);
			} else if (nodes.rgt) {
				node || (node = nodes.rgt.up(query));
			} else if (nodes[0]) {
				node || (node = nodes[0].node.closest(query));
			};
			return node;
		};
		
		Region.prototype.buffer = function (){
			return this._root.code();
		};
		
		Region.prototype.startAtLine = function (){
			this.normalize();
			var buffer = this.buffer();
			var a = this.start();
			
			if (buffer[a] == '\n' && this.size() == 0) {
				a--; // if we are at the end of a line
			};
			
			while (a >= 0 && buffer[a] != '\n'){
				a--;
			};
			this._a = a;
			return this;
		};
		
		Region.prototype.endAtLine = function (){
			this.normalize();
			var buffer = this.buffer();
			var b = (this.end() - 1);
			while (b >= 0 && buffer[b] && buffer[b] != '\n'){
				b++;
			};
			this._b = b;
			return this;
		};
		
		Region.prototype.cell = function (){
			return this.view()._buffer.locToCell(this.a());
		};
		
		Region.prototype.row = function (){
			return this.cell()[0];
		};
		
		Region.prototype.col = function (){
			return this.cell()[1];
		};
		
		Region.prototype.peekbehind = function (len){
			if(len === undefined) len = 1;
			return len == 1 ? (this.buffer()[this.start() - 1]) : (this.buffer().substring(this.start() - len,this.start()));
		};
		
		Region.prototype.peekahead = function (len){
			if(len === undefined) len = 1;
			return len == 1 ? (this.buffer()[this.end()]) : (this.buffer().substr(this.end(),len));
		};
		
		Region.prototype.indent = function (){
			return this.clone().startAtLine().text().match(/^\n?(\t*)/)[1];
		};
		
		Region.prototype.peek = function (before,after){
			if(before === undefined) before = 0;
			if(after === undefined) after = 0;
			return this.clone(before,after).text();
		};
		
		Region.prototype.lloc = function (){
			return {startLine: 0,startCol: 2};
		};
		
		Region.prototype.toJSON = function (){
			return [this.a(),this.b()];
		};
		return Region;
	
	})()

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		
		var KEYWORDS = 'var if elif else for while def in isa while until switch when then return class tag let do and or prop attr in prop'.split(' ');
		var OPS = '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ?'.split(' ');
		
		var WHITESPACE = /^[ \t\n]+$/;
		
		IM.HL = {
			newline: "<b class='_imnewline'>\n</b>",
			space: function(m) { return ("<b class='_imspace'>" + m + "</b>"); },
			tab: function(m) { return new Array(m.length + 1).join("<b class='_imtab'>\t</b>"); }
		};
		
		
		var Region = __webpack_require__(27).Region;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		var MATCHERS = {
			keyword: function(v) { return KEYWORDS.indexOf(v) >= 0; },
			self: /^(this|self)$/,
			const: function(v) { return (/^[A-Z][\w\_]*$/).test(v); },
			ivar: function(v) { return (/^@[\w\_]+$/).test(v); },
			bool: function(v) { return (/^(true|yes|false|no|null|undefined)$/).test(v); },
			identifier: /^[\$a-z_][\w\_\$]*(\-[\$\w\_]+)*$/,
			float: /^\d+\.\d+$/,
			int: /^\d+$/,
			comment: /^\#([ \t][^\n]*)?$/
		};
		
		var MODES = {
			all: Object.keys(MATCHERS)
		};
		
		
			
			String.prototype.repeat = function (num){
				return new Array(num + 1).join(this);
			};
			
			String.prototype.ins = function (str,region){
				var text = this.toString();
				if (region == 'append') {
					return text + str;
				} else if (region == 'prepend') {
					return "" + str + text;
				} else if (region instanceof Region) {
					return text.substr(0,region.start()) + str + text.slice(region.end());
				};
			};
		
		
		function isWhitespace(str){
			return WHITESPACE.test(str);
		}; exports.isWhitespace = isWhitespace;
		
		IM.num = function (val){
			return tag$.$imnum().flag('number').setText(val).end();
		};
		
		IM.tab = function (){
			return tag$.$imtab().setText('\t').end();
		};
		
		IM.newline = function (){
			return tag$.$imnewline().setText('\n').end();
		};
		
		IM.op = function (val){
			return tag$.$imop().flag('op').setText(val).end();
		};
		
		
		IM.tok = function (val){
			if (val && val._dom) { return val };
			if (val.match(WHITESPACE)) { return IM.parseWhitespace(val) };
			if (OPS.indexOf(val) >= 0) { return IM.op(val) }; // should use token directly
			// return IM.num(val) if val.match(/^\d+(\.\d+)?$/) # should use token directly
			return tag$.$imtok().setText(val).end();
		};
		
		IM.raw = function (val,ctx){
			return tag$.$imraw().setRaw(val).end();
		};
		
		IM.isWhitespace = function (val){
			return WHITESPACE.test(val);
		};
		
		IM.isOp = function (val){
			return OPS.indexOf(val) >= 0;
		};
		
		IM.parseWhitespace = function (text,rich){
			if(rich === undefined) rich = true;
			var hl = IM.HL;
			
			text = text.replace(/(\n|[ ]+|[\t]+)/g,function(m,l) {
				if (l == '\n') {
					return hl.newline || '\n';
				} else if (l[0] == ' ') {
					return hl.space instanceof Function ? (hl.space(l)) : (l);
				} else if (l[0] == '\t') {
					return hl.tab instanceof Function ? (hl.tab(l)) : (l);
				};
			});
			
			if (rich && text.indexOf('<') >= 0) {
				return tag$.$imfragment().setContent(text,0).end();
			};
			
			return text;
		};
		
		IM.identify = function (val,mode){
			if(mode === undefined) mode = 'all';
			var rules = MODES[mode];
			var res;
			for (var i = 0, ary = iter$(rules), len = ary.length, name; i < len; i++) {
				name = ary[i];
				var rule = MATCHERS[name];
				
				if (rule instanceof Function) {
					res = rule(val,mode);
				} else if (rule instanceof RegExp) {
					res = rule.test(val);
				};
				
				if (res) {
					return res === true ? (name) : (res);
				};
			};
			
			return null;
		};
		
		IM.parse = function (code,context){
			// decide if full?
			// console.log "parse code {code:length} {code.substr(0,20)}"
			if (typeof code != 'string') { return code };
			
			if (WHITESPACE.test(code)) {
				return IM.parseWhitespace(code,false);
			};
			
			var ws = code.match(/^([ \t]*)([^]*?)([ \t]*)$/) || ['','',code,''];
			var hl;
			
			if (ws[1] || ws[3]) {
				code = ws[2];
			};
			
			var id = IM.identify(code);
			
			if (id) {
				var typ = 'span';
				var cls = Highlighter.Mapping[id] || id; // this is the issue, no?
				
				if (cls instanceof Array) {
					typ = cls[0];
					cls = cls[1];
				};
				
				if (!cls.match(/\b_[\w]/)) { cls = '_imtok ' + cls };
				// console.log 'parsed as type',id,cls
				hl = '<' + typ + ' class="' + cls + '">' + code + '</' + typ + '>';
			};
			
			if (!hl) {
				hl = Highlighter.highlight(code);
			};
			
			if (ws) {
				hl = IM.parseWhitespace(ws[1],false) + hl + IM.parseWhitespace(ws[3],false);
			};
			if (hl) {
				return hl;
			} else {
				return code;
			};
		};
		
		
		return IM.textNodes = function (root,mark){
			// console.time('textNodes2')
			if(mark === undefined) mark = false;
			root = root._dom || root;
			var el;
			var nodes = [];
			var pos = 0;
			var walk = document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);
			
			while (el = walk.nextNode()){
				if (mark) {
					var len = el.length;
					el._loc = pos;
					pos += len;
				};
				nodes.push(el);
			};
			return nodes;
		};
	
	})()

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		// var imbac = global.Imbac
		var Lexer = __webpack_require__(30).Lexer;
		
		var util = __webpack_require__(34);
		
		var NODETYPE = 'b';
		var KEYWORDS = [
			'null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','isa','case','nil'
		];
		
		var classes = {
			'+': '_imop op add math',
			'++': '_imop op incr math',
			'--': '_imop op decr math',
			'-': '_imop op sub math',
			'=': '_imop op eq',
			'/': '_imop op div math',
			'*': '_imop op mult math',
			'?': '_imop op ternary',
			',': '_imop op comma',
			':': '_imop op colon',
			'.': '_imop op dot',
			'.:': '_imop op cdot',
			'!': '_imop op unary',
			'?.': '_imop op qdot',
			'[': '_imopen sb sbl',
			']': '_imclose sb sbr',
			'(': '_imopen rb rbl',
			')': '_imclose rb rbr',
			'{': '_imopen cb cbl',
			'}': '_imclose cb cbr',
			'#': '_imop op hash',
			'call_start': '_imopen call rb rbl',
			'call_end': '_imclose call rb rbr',
			'tag_start': '_imopen tag_open',
			'tag_end': '_imclose tag_close',
			
			'true': '_imbool true',
			'yes': '_imbool true',
			'false': '_imbool false',
			'no': '_imbool false',
			
			'{{': '_imopen',
			'}}': '_imclose',
			
			'"': 'doublequote',
			"'": 'singlequote',
			
			'regex': '_imregex regex',
			'identifier': '_imtok _imidentifier identifier',
			
			'compound_assign': 'op assign compound',
			'str': '_imstr string',
			'num': '_imnum number',
			'string': '_imstr string',
			'number': '_imnum number',
			'math': '_imop op math',
			'unary': '_imop op unary',
			'forin': 'keyword in',
			'forof': 'keyword of',
			'own': 'keyword own',
			'compare': '_imop op compare',
			'herecomment': '_herecomment',
			'relation': 'keyword relation',
			'export': 'keyword export',
			'global': 'keyword global',
			'extern': 'keyword global',
			'extend': 'keyword extend',
			'require': 'keyword require',
			'from': 'keyword from',
			'logic': 'keyword logic',
			'post_if': 'keyword if post_if',
			'post_for': 'keyword for post_for',
			'prop': 'keyword prop',
			'attr': 'keyword attr',
			
			'selector_start': '_imopen _imselopen selector_start',
			'selector_end': '_imclose _imselclose selector_end',
			'index_start': '_imopen index_start',
			'index_end': '_imclose index_end',
			'block_param_start': '_imopen',
			'block_param_end': '_imclose',
			
			'string_start': '_imstrstart string_start',
			'string_end': '_imstrend string_end',
			'neostring': '_imtok _imneostring'
		};
		
		var INTERPOLATING = '_imistring';
		
		var OPEN = {
			'tag_start': '_imtagnode tagnode',
			'call_start': '_imparens call',
			'selector_start': '_imsel selector',
			'string_start': '_imistring',
			'index_start': 'index',
			'block_param_start': '_impair _imblockparams',
			// 'indent': '_indent'
			'(': '_imparens paren',
			'{{': '_imiexpr',
			'{': '_imcurly curly',
			'[': '_imsquare square',
			'("': '_imistring'
		};
		
		
		
		var CLOSE = {
			'tag_end': 'tag',
			'call_end': '_imparens call',
			'string_end': '_imistring',
			'selector_end': 'sel',
			'index_end': 'index',
			'block_param_end': '_impair _imblockparams',
			'}}': '_imiexpr',
			')': 'paren',
			']': 'square',
			'}': 'curly',
			'")': 'string'
		};
		
		var OPS = '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ?'.split(' ');
		
		var hlo = {
			newline: "<b class='_imnewline'>\n</b>",
			space: function(m) { return ("<b class='_imspace'>" + m + "</b>"); },
			tab: function(m) { return new Array(m.length + 1).join("<b class='_imtab'>\t</b>"); }
		};
		
		function Stack(){
			this._stack = [];
			return this;
		};
		
		Stack.prototype.push = function (val){
			this._stack.push(val);
			this._current = val;
			return this;
		};
		
		Stack.prototype.pop = function (){
			var len = this._stack.pop();
			this._current = this._stack[len - 1];
			return this;
		};
		
		Stack.prototype.toString = function (){
			return this._current;
		};
		
		function Token(type,value,line,loc,len){
			this._type = type;
			this._value = value;
			this._meta = null;
			this._line = line || 0;
			this._col = -1;
			this._loc = loc || 0;
			this._len = len || 0;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.loc = function (){
			return this._loc;
		};
		
		Token.prototype.len = function (){
			return this._len;
		};
		
		
		
		function Highlighter(code,tokens,ast,o){
			var hl_;
			if(o === undefined) o = {};
			this._code = code;
			this._tokens = tokens;
			this._ast = ast;
			
			o.render || (o.render = {});
			o.hl || (o.hl = {});
			(hl_ = o.hl).newline || (hl_.newline = '<b class="_n">\n</b>');
			this._options = o;
			
			this._options.nextVarCounter || (this._options.nextVarCounter = 0);
			this._varRefs = {};
			
			if (o.mode == 'full' && !ast) {
				this._ast = Imbac.parse(this._tokens,{});
			};
			
			return this;
		};
		
		exports.Highlighter = Highlighter; // export class 
		Highlighter.Mapping = classes;
		
		Highlighter.logger = function (){
			return VIEW.logger();
		};
		
		Highlighter.tokenize = function (code,o){
			// console.log 'tokenize using local lexer'
			if(o === undefined) o = {};
			if (global.Imbac) {
				return Imbac.tokenize(code,o);
			};
			
			this._lexer || (this._lexer = new Lexer());
			this._lexer.reset();
			return this._lexer.tokenize(code,o);
		};
		
		Highlighter.reclassify = function (domnode,type,token,newCode,oldCode){
			
			type = type.toLowerCase();
			// console.log 'reclassify node as type',domnode,type,token
			var cls = IM.Types[type] || Imba.TAGS[("im" + type)] || IM.Types.token;
			
			var node = tag$wrap(domnode);
			
			if (node instanceof cls) {
				return node.reuse(token,newCode,oldCode);
			};
			
			if (cls) {
				node = new cls(domnode).setup(token,newCode,oldCode);
			};
			
			return node;
		};
		
		
		Highlighter.nestTokens = function (tokens,offset){
			var pairing = {
				'TAG_START': 'TAG_END',
				'SELECTOR_START': 'SELECTOR_END',
				'CALL_START': 'CALL_END',
				'INDEX_START': 'INDEX_END',
				'STRING_START': 'STRING_END',
				'BLOCK_PARAM_START': 'BLOCK_PARAM_END',
				'{{': '}}',
				'{': '}',
				'[': ']',
				'(': ')'
			};
			
			var naming = {
				'TAG_START': 'tagnode',
				'SELECTOR_START': 'selector',
				'STRING_START': 'istring',
				'CALL_START': 'parens',
				'INDEX_START': 'square',
				'BLOCK_PARAM_START': 'blockparams',
				'{{': 'iexpr',
				'{': 'curly',
				'[': 'square',
				'(': 'parens'
			};
			
			var idx = 0;
			
			var root = {
				_loc: 0,
				_offset: 0,
				_children: []
			};
			
			var stack = [root];
			var ends = [];
			var offset = 0;
			
			var loc,val,typ,ctx,tok;
			
			while (tok = tokens[idx++]){
				loc = tok._loc;
				val = tok._value;
				typ = tok._type;
				
				// normalizing because we dont rewrite tokens (should start with that)
				if (typ == 'IDENTIFIER' && (val == 'prop' || val == 'attr')) { typ = tok._type = 'KEYWORD' }; // not always
				if (typ == 'INDEX_START') { typ = tok._type = '[' };
				if (typ == 'INDEX_END') { typ = tok._type = ']' };
				if (typ == 'CALL_START') { typ = tok._type = '(' };
				if (typ == 'CALL_END') { typ = tok._type = ')' };
				
				ctx = stack[stack.length - 1];
				
				loc -= ctx._offset;
				// offset relative to context
				var closer = pairing[typ];
				
				if (closer) {
					var group = new Token(naming[typ],'',-1,loc);
					group._offset = ctx._offset + loc;
					offset += loc;
					group._children = [];
					ends.push(closer);
					stack.push(group);
					ctx._children.push(group);
					ctx = group;
				};
				
				tok._loc -= ctx._offset;
				
				// update length at all times
				if (tok._len >= 1) {
					ctx._children.push(tok);
					ctx._len = tok._loc + tok._len;
				};
				
				if (ends[ends.length - 1] == typ) {
					ends.pop();
					ctx._len = tok._loc + tok._len;
					stack.pop();
					// offset -= ctx.@offset
				};
			};
			
			// console.log 'children here',root.@children
			return root._children;
		};
		
		Highlighter.normalizeTokens = function (code,tokens,offset){
			if(offset === undefined) offset = 0;
			var idx = 0;
			var caret = 0;
			var new$ = [];
			var tok,next,typ,val;
			var loc = 0;
			
			var stack = new Stack();
			
			var ws = function() {
				var newtok = null;
				
				while (loc > caret){
					var chr = code[caret];
					if (chr == '\t') {
						newtok = new Token('tab',chr,-1,caret,1);
					} else if (chr == '\n') {
						newtok = new Token('newline',chr,-1,caret,1);
					} else if (chr == ';') {
						newtok = new Token('semicolon',chr,-1,caret,1);
					} else if (chr == ' ') {
						if (newtok && newtok._type == 'whitespace') {
							newtok._value += ' ';
							newtok._len += 1;
							caret++;
							continue;
						};
						newtok = new Token('whitespace',chr,-1,caret,1);
					} else if (chr == '#') {
						var startloc = caret;
						var comment = '';
						while (caret < loc && code[caret] != '\n'){
							comment += code[caret];
							caret++;
						};
						new$.push(new Token('comment',comment,-1,startloc,comment.length));
						continue;
					} else {
						newtok = null;
					};
					
					caret++;
					if (newtok) { new$.push(newtok) };
				};
				return;
			};
			
			var skip = ['TERMINATOR','INDENT','OUTDENT',' ',' \t'];
			
			while (tok = tokens[idx++]){
				next = tokens[idx];
				loc = tok._loc;
				val = tok._value;
				typ = tok._type;
				
				if (typ == '#' && next && next._type == 'IDENTIFIER') {
					next._type = 'IDREF';
				};
				
				if (typ == '(' && val == '("') {
					stack.push(val);
				};
				
				if (skip.indexOf(typ) >= 0) { continue; };
				
				if (loc > caret) { ws() };
				caret = tok._loc + tok._len;
				new$.push(tok);
			};
			
			// move to the end to possibly parse more whitespace
			loc = code.length;
			ws();
			// now nest the tokens
			new$ = this.nestTokens(new$);
			return new$;
		};
		
		Highlighter.whitespaceToTokens = function (str){
			var tok;
			var tokens = [];
			var caret = 0;
			var len = str.length;
			
			while (len > caret){
				var loc = caret;
				var chr = str[caret++];
				if (chr == '\t') {
					tokens.push(tok = new Token('tab',chr,-1,loc,1));
				} else if (chr == '\n') {
					tokens.push(tok = new Token('newline',chr,-1,loc,1));
				} else if (chr == ' ') {
					if (tok && tok._type == 'whitespace') {
						tok._value += ' ';
						tok._len += 1;
						continue;
					};
					tokens.push(tok = new Token('whitespace',chr,-1,loc,1));
				};
			};
			
			return tokens;
		};
		
		Highlighter.reparse = function (o){
			
			var $1;
			if (o instanceof Element) {
				var el = tag$wrap(o);
				if (el) { ($1 = el) && $1.mutated  &&  $1.mutated() };
				return;
			};
			
			var nodes = o.nodes;
			var code = o.code;
			var tokens = o.tokens;
			// should use a global logger-instance
			this.logger().groupCollapsed('reparse %s',JSON.stringify(code));
			
			if (util.isWhitespace(code) && !tokens) {
				console.log('using whitespaceToTokens');
				tokens = this.whitespaceToTokens(code);
			};
			// logger.log nodes.slice
			// big hack - adding a space at the end to close up selectors
			// should rather drop inline and let the parser pair up loose ends?
			if (!tokens) {
				tokens = this.tokenize(code + ' ',{inline: true,silent: true,rewrite: false});
				tokens = this.normalizeTokens(code,tokens);
				this.logger().log(tokens.slice());
			};
			
			this.logger().log(nodes.slice());
			this.applyTokens(code,tokens,nodes,o.nested,o.parent);
			this.logger().groupEnd();
			return;
		};
		
		Highlighter.applyTokens = function (code,tokens,nodes,nested,parent){
			// what about len and loc for inner nodes? Should this be set already?
			
			var self = this;
			var node;
			var prevNode;
			
			var addNode = function(nodes,index,after) {
				self.logger().log('addNode',index);
				var el = document.createElement(NODETYPE);
				
				if (after) {
					if (after.nextSibling) {
						after.parentNode.insertBefore(el,after.nextSibling);
					} else if (after.parentNode) {
						after.parentNode.appendChild(el);
					};
				} else if (parent) {
					parent.appendChild(el);
				};
				
				nodes.splice(index,0,el);
				return el;
			};
			
			var removeNode = function(nodes,index) {
				self.logger().log('removeNode',index);
				var el = nodes[index];
				if (el && el.parentNode) {
					el.parentNode.removeChild(el);
				};
				return nodes.splice(index,1);
			};
			
			// loop through to set the locations of the nodes
			var nloc = 0;
			for (var i = 0, ary = iter$(nodes), len = ary.length, node1; i < len; i++) {
				node1 = ary[i];
				node1._loc = nloc;
				nloc += (node1._len = node1.textContent.length);
			};
			
			for (var i = 0, ary = iter$(tokens), len = ary.length, tok; i < len; i++) {
				tok = ary[i];
				node = nodes[i];
				var tloc = tok._loc;
				nloc = node && node._loc;
				
				while (node && node._len == 0){
					self.logger().log('remove node because it is empty',node);
					removeNode(nodes,i);
					node = nodes[i];
				};
				
				if (!node) {
					// need to insert new node here - 
					node = addNode(nodes,i,prevNode);
				} else if (nloc > tloc) {
					node = addNode(nodes,i,prevNode);
				} else if (tloc > nloc) {
					removeNode(nodes,i);
					node = nodes[i];
				};
				
				// need to insert new node here - 
				if (!node) { node = addNode(nodes,i,prevNode) };
				
				if (tok._type == 'STRING' && tok._value.match(/\{3}/)) {
					if (nested) {
						nested.pop(); // this is the node
						prevNode = node;
						continue;
					};
					
					// want to make sure it is a placeholder for the right thing
				};
				
				var cval = code.substr(tloc,tok._len);
				var cprev = node.textContent;
				var element = self.reclassify(node,tok._type,tok,cval,cprev);
				
				if (tok._children) {
					var cnodes = node.children;
					if (cnodes.length && cnodes.length == node.childNodes.length) {
						self.logger().log('reuse the cnodes(!)',cnodes);
						// otherwise we should remove the textNodes?
						// convert to array
						cnodes = Array.prototype.slice.call(cnodes);
					} else {
						self.logger().log('wrong length');
						for (var j = 0, items = iter$(node.childNodes), len_ = items.length; j < len_; j++) {
							self.logger().log(items[j]);
						};
						// see if previous value is the same?!
						node.innerHTML = '';
						cnodes = [];
					};
					
					// let o =
					// 	code: cval
					// 	nodes: cnodes
					// 	tokens: tok.@children # already parsed
					// 	nested: nested
					// 	parent: node
					
					self.applyTokens(cval,tok._children,cnodes,nested,node);
				} else if (cprev != cval) {
					node.textContent = cval; // tok.@value
					element.reparsed(cval,cprev);
				};
				
				prevNode = node;
				// tok.@len
			};
			
			// loop through tokens? not sure it works due to the issues with whitespace?
			
			// remove excess original nodes
			while (nodes.length > tokens.length){
				node = nodes.pop();
				if (node.parentNode) { node.parentNode.removeChild(node) };
				// node.orphanize
			};
			return self;
		};
		
		// should later be able to rehighlight the text / nodes directly instead
		// probably more efficient
		Highlighter.highlight = function (code,o){
			// first try to parse etc?
			// could highlight single words as well
			if(o === undefined) o = {};
			o.hl || (o.hl = hlo);
			var tokens = o.tokens || null;
			
			if (!tokens) {
				try {
					// sure we dont want to rewrite anything now?
					if (true) { console.time('tokenize') };
					if (o.mode == 'full') {
						tokens = this.tokenize(code,{});
					} else {
						tokens = this.tokenize(code,{inline: true,silent: true,rewrite: false});
					};
					if (true) { console.timeEnd('tokenize') };
				} catch (e) {
					if (e._options) { tokens = e._options.tokens };
				};
			};
			
			var hl = new this(code,tokens,null,o);
			return hl.process();
		};
		
		
		
		Highlighter.prototype.options = function(v){ return this._options; }
		Highlighter.prototype.setOptions = function(v){ this._options = v; return this; };
		
		Highlighter.prototype.varRef = function (variable){
			var $1;
			var i = this._options.nested;
			var pfx = i ? ('i') : ('');
			return this._varRefs[($1 = variable._ref)] || (this._varRefs[$1] = (pfx + this._options.nextVarCounter++));
		};
		
		Highlighter.prototype.parseWhitespace = function (text){
			// parsing comments
			var self = this;
			var hl = this._options.hl;
			var comments = [];
			
			text = text.replace(/(\#)([^\n]*)/g,function(m,s,q) {
				if (self._options.render.comment) {
					m = self._options.render.comment('comment',m);
				};
				var nr = comments.push(("<" + NODETYPE + " class='_im _imcomment'>" + m + "</" + NODETYPE + ">"));
				return ("$" + (nr - 1) + "$");
			});
			
			text = text.replace(/(\n|[ ]+|[\t]+)/g,function(m,l) {
				if (l == '\n') {
					return hl.newline || '\n';
				} else if (l[0] == ' ') {
					return hl.space instanceof Function ? (hl.space(l)) : (l);
				} else if (l[0] == '\t') {
					return hl.tab instanceof Function ? (hl.tab(l)) : (l);
				};
			});
			
			if (comments.length) {
				text = text.replace(/\$(\d+)\$/g,function(m,nr) {
					return comments[parseInt(nr)];
				});
			};
			return text;
		};
		
		Highlighter.prototype.process = function (){
			var tok;
			var o = this.options();
			
			var str = this._code;
			var pos = this._tokens.length;
			
			var stack = [];
			var depth = 0;
			var context = null;
			
			var push = function(ctx) {
				stack.push(ctx);
				depth = stack.length;
				return context = stack[depth - 1];
			};
			
			var pop = function(ctx) {
				stack.pop();
				depth = stack.length;
				return context = stack[depth - 1];
			};
			
			if (this._ast && this._ast.analyze) {
				try {
					this._ast.analyze({});
				} catch (e) {
					null;
				};
			};
			
			var res = "";
			pos = 0;
			var caret = 0;
			
			var open,close;
			
			while (tok = this._tokens[pos++]){
				var next = this._tokens[pos];
				
				if (close) {
					if (!(o.inner && depth == 1)) { res += ("</" + NODETYPE + ">") };
					close = null;
					pop();
				};
				
				var typ = tok._type.toLowerCase();
				var loc = tok._loc;
				var val = tok._value;
				var len = tok._len; // or tok.@value:length
				var meta = tok._meta;
				var attrs = '';
				
				if (loc > caret) {
					var add = str.substring(caret,loc);
					if (context != INTERPOLATING) { add = this.parseWhitespace(add) };
					res += add;
					caret = loc;
				};
				
				close = CLOSE[typ];
				
				if (open = OPEN[typ]) {
					// open = OPEN[val] || open
					push(open);
					if (!(o.inner && depth == 1)) { res += ("<" + NODETYPE + " class='" + open + "'>") };
				};
				
				if (len == 0 || typ == 'terminator' || typ == 'indent' || typ == 'outdent') {
					continue;
				};
				
				if (tok._col == -1 && tok._loc <= 0) {
					continue;
				};
				
				var node = NODETYPE;
				var content = str.substr(loc,len);
				// temporary workaround until we redefine require as an identifier
				if (typ == 'const' && content == 'require') {
					typ = 'require';
				};
				
				
				var cls = classes[typ] || typ;
				
				if (cls instanceof Array) {
					node = cls[0];
					cls = cls[1];
				};
				
				cls = cls.split(" ");
				
				if (KEYWORDS.indexOf(typ) >= 0) {
					cls.unshift('keyword');
				};
				
				caret = loc + len;
				
				if (typ == 'identifier') {
					if (content[0] == '#') {
						cls.push('idref');
					};
					
					if (meta) {
						if (meta.type == 'ACCESS') { cls.push('access') };
					};
					
					if (content == 'log') {
						cls.push('log');
					};
				};
				
				if (tok._variable) {
					
					cls.push('lvar');
					var ref = this.varRef(tok._variable);
					attrs += (" eref='v" + ref + "'");
					// cls.push("ref-"+ref)
				};
				
				if (typ == 'herecomment') {
					var end = ("<" + NODETYPE + ">###</" + NODETYPE + ">");
					content = end + content.slice(3,-3) + end;
				};
				
				if (typ == 'string') {
					if (content.match(/^['"]?\.?\.\//)) { cls.push('pathname') };
				};
				
				var clstr = cls.join(" ");
				if (!clstr.match(/\b\_/)) { clstr = '_imtok ' + clstr };
				res += ("<" + node + " class='" + clstr + "'") + attrs + ">" + content + ("</" + node + ">");
			};
			
			// close after?
			if (close) {
				res += ("</" + NODETYPE + ">");
				close = null;
			};
			
			if (caret < str.length - 1) {
				add = str.slice(caret);
				if (context != INTERPOLATING) { add = this.parseWhitespace(add) };
				res += add;
			};
			
			if (this._tokens.length == 0) {
				res = this._code;
			};
			
			return res;
		};
		return Highlighter;
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		var ALL_KEYWORDS;
		
		var T = __webpack_require__(31);
		var Token = T.Token;
		
		var rw = __webpack_require__(32);
		var Rewriter = rw.Rewriter;
		var INVERSES = rw.INVERSES;
		
		var K = 0;
		
		var ERR = __webpack_require__(33);
		
		// Constants
		// ---------
		
		// Keywords that Imba shares in common with JavaScript.
		var JS_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return'
		];
		
		// new can be used as a keyword in imba, since object initing is done through
		// MyObject.new. new is a very useful varname.
		
		// We want to treat return like any regular call for now
		// Must be careful to throw the exceptions in AST, since the parser
		// wont
		
		// Imba-only keywords. var should move to JS_Keywords
		// some words (like tokid) should be context-specific
		var IMBA_KEYWORDS = [
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import'
		];
		
		var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];
		
		var IMBA_ALIAS_MAP = {
			'and': '&&',
			'or': '||',
			'is': '==',
			'isnt': '!=',
			'not': '!',
			'yes': 'true',
			'no': 'false',
			'isa': 'instanceof',
			'case': 'switch',
			'nil': 'null'
		};
		
		var IMBA_ALIASES = Object.keys(IMBA_ALIAS_MAP);
		IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);
		
		// FixedArray for performance
		// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
		module.exports.ALL_KEYWORDS = ALL_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil'
		];
		
		// The list of keywords that are reserved by JavaScript, but not used, or are
		// used by Imba internally. We throw an error when these are encountered,
		// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
		var RESERVED = ['case','default','function','void','with','const','enum','native'];
		var STRICT_RESERVED = ['case','function','void','const'];
		
		// The superset of both JavaScript keywords and reserved words, none of which may
		// be used as identifiers or properties.
		var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);
		
		var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
		// removed ~=|~| |&(?![&=])
		
		// Token matching regexes.
		// added hyphens to identifiers now - to test
		var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;
		
		var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;
		
		var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;
		
		var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
		var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;
		
		var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;
		
		var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
		var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
		var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;
		
		var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
		var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		
		var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\/\\\:][\w\x7f-\uffff]+)*)|==|\<=\>|\[\]|\[\]\=|\*|[\\/,\\])/;
		
		
		var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
		
		var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;
		
		var OPERATOR = /^(?:[-=]=>|===|->|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;
		
		// FIXME splat should only be allowed when the previous thing is spaced or inside call?
		
		var WHITESPACE = /^[^\n\S]+/;
		
		var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
		// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
		var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;
		
		var CODE = /^[-=]=>/;
		
		var MULTI_DENT = /^(?:\n[^\n\S]*)+/;
		
		var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;
		
		var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;
		
		// Regex-matching-regexes.
		var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;
		
		var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;
		
		var HEREGEX_OMIT = /\s+(?:#.*)?/g;
		
		// Token cleaning regexes.
		var MULTILINER = /\n/g;
		
		var HEREDOC_INDENT = /\n+([^\n\S]*)/g;
		
		var HEREDOC_ILLEGAL = /\*\//;
		
		// expensive?
		var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
		
		var TRAILING_SPACES = /\s+$/;
		
		var CONST_IDENTIFIER = /^[A-Z]/;
		
		var ARGVAR = /^\$\d$/;
		
		// Compound assignment tokens.
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];
		
		// Unary tokens.
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		
		// Logical tokens.
		var LOGIC = ['&&','||','&','|','^'];
		
		// Bit-shifting tokens.
		var SHIFT = ['<<','>>','>>>'];
		
		// Comparison tokens.
		var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];
		
		// Overideable methods
		var OP_METHODS = ['<=>','<<','..'];
		
		// Mathematical tokens.
		var MATH = ['*','/','%','','',''];
		
		// Relational tokens that are negatable with `not` prefix.
		var RELATION = ['IN','OF','INSTANCEOF','ISA'];
		
		// Boolean tokens.
		var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];
		
		// Our list is shorter, due to sans-parentheses method calls.
		var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];
		
		// If the previous token is not spaced, there are more preceding tokens that
		// force a division parse:
		var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];
		
		// Tokens which could legitimately be invoked or indexed. An opening
		// parentheses or bracket following these tokens will be recorded as the start
		// of a function invocation or indexing operation.
		// really?!
		
		var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];
		
		// } should not be callable anymore!!! '}', '::',
		var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];
		// var INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS','}' # are booleans indexable? really?
		// optimize for FixedArray
		var INDEXABLE = [
			'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
			'NUMBER','BOOL','TAG_SELECTOR','IDREF','ARGUMENTS','}','TAG_TYPE'
		];
		
		var GLOBAL_IDENTIFIERS = ['global','exports','require'];
		
		// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
		// occurs at the start of a line. We disambiguate these from trailing whens to
		// avoid an ambiguity in the grammar.
		var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];
		
		
		function LexerError(message,file,line){
			this.message = message;
			this.file = file;
			this.line = line;
			return this;
		};
		subclass$(LexerError,SyntaxError);
		exports.LexerError = LexerError; // export class 
		
		
		
		function last(array,back){
			if(back === undefined) back = 0;
			return array[array.length - back - 1];
		};
		
		function count(str,substr){
			return str.split(substr).length - 1;
		};
		
		function repeatString(str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		var tT = T.typ;
		var tV = T.val;
		var tTs = T.setTyp;
		var tVs = T.setVal;
		
		// The Lexer class reads a stream of Imba and divvies it up into tokidged
		// tokens. Some potential ambiguity in the grammar has been avoided by
		// pushing some extra smarts into the Lexer.
		
		// Based on the original lexer.coffee from CoffeeScript
		function Lexer(){
			this.reset();
			this;
		};
		
		exports.Lexer = Lexer; // export class 
		Lexer.prototype.reset = function (){
			this._code = null;
			this._chunk = null; // The remainder of the source code.
			this._opts = null;
			
			this._indent = 0; // The current indentation level.
			this._indebt = 0; // The over-indentation at the current level.
			this._outdebt = 0; // The under-outdentation at the current level.
			
			this._indents = []; // The stack of all current indentation levels.
			this._ends = []; // The stack for pairing up tokens.
			this._contexts = []; // suplements @ends
			this._scopes = [];
			this._nextScope = null; // the scope to add on the next indent
			// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
			// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
			
			this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
			this._seenFor = false;
			this._loc = 0;
			this._locOffset = 0;
			
			this._end = null;
			this._char = null;
			this._bridge = null;
			this._last = null;
			this._lastTyp = '';
			this._lastVal = null;
			return this;
		};
		
		Lexer.prototype.jisonBridge = function (jison){
			return this._bridge = {
				lex: T.lex,
				setInput: function(tokens) {
					this.tokens = tokens;
					return this.pos = 0;
				},
				
				upcomingInput: function() { return ""; }
			};
		};
		
		
		Lexer.prototype.tokenize = function (code,o){
			
			if(o === undefined) o = {};
			if (code.length == 0) {
				return [];
			};
			
			if (!o.inline) {
				if (WHITESPACE.test(code)) {
					code = ("\n" + code);
					if (code.match(/^\s*$/g)) { return [] };
				};
				
				code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
			};
			
			this._last = null;
			this._lastTyp = null;
			this._lastVal = null;
			
			this._code = code;
			this._opts = o;
			this._locOffset = o.loc || 0;
			// add a reference to the options object
			o._tokens = this._tokens;
			// what about col here?
			
			// @indent  = 0 # The current indentation level.
			// @indebt  = 0 # The over-indentation at the current level.
			// @outdebt = 0 # The under-outdentation at the current level.
			// @indents = [] # The stack of all current indentation levels.
			// @ends    = [] # The stack for pairing up tokens.
			// @tokens  = [] # Stream of parsed tokens in the form `['TYPE', value, line]`.
			// @char = nil
			
			if (o.profile) { console.time("tokenize:lexer") };
			this.parse(code);
			if (!o.inline) this.closeIndentation();
			if (!o.silent && this._ends.length) {
				this.error(("missing " + (this._ends.pop())));
			};
			
			if (o.profile) { console.timeEnd("tokenize:lexer") };
			if (o.rewrite == false || o.norewrite) { return this._tokens };
			return new Rewriter().rewrite(this._tokens,o);
		};
		
		Lexer.prototype.parse = function (code){
			var i = 0;
			var pi = 0;
			
			while (this._chunk = code.slice(i)){
				this._loc = this._locOffset + i;
				pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
				i += pi;
			};
			
			return;
		};
		
		Lexer.prototype.basicContext = function (){
			return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
		};
		
		Lexer.prototype.moveCaret = function (i){
			return this._loc += i;
		};
		
		Lexer.prototype.context = function (){
			return this._ends[this._ends.length - 1];
		};
		
		Lexer.prototype.inContext = function (key){
			var o = this._contexts[this._contexts.length - 1];
			return o && o[key];
		};
		
		Lexer.prototype.pushEnd = function (val){
			// console.log "pushing end",val
			this._ends.push(val);
			this._contexts.push(null);
			this._end = val;
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.popEnd = function (val){
			this._ends.pop();
			this._contexts.pop();
			this._end = this._ends[this._ends.length - 1];
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.refreshScope = function (){
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
		};
		
		
		
		Lexer.prototype.queueScope = function (val){
			// console.log("pushing scope {val} - {@indents} {@indents:length}")
			// @scopes.push(val) # no no
			this._scopes[this._indents.length] = val;
			return this;
		};
		
		Lexer.prototype.popScope = function (val){
			this._scopes.pop();
			return this;
		};
		
		Lexer.prototype.getScope = function (){
			return this._scopes[this._indents.length - 1];
		};
		
		Lexer.prototype.scope = function (sym,opts){
			var len = this._ends.push(this._end = sym);
			this._contexts.push(opts || null);
			return sym;
		};
		
		
		Lexer.prototype.closeSelector = function (){
			if (this._end == '%') {
				this.token('SELECTOR_END','%',0);
				return this.pair('%');
			};
		};
		
		
		Lexer.prototype.openDef = function (){
			return this.pushEnd('DEF');
		};
		
		
		Lexer.prototype.closeDef = function (){
			if (this.context() == 'DEF') {
				var prev = last(this._tokens);
				// console.log "close def {prev}"
				// console.log('closeDef with last>',prev)
				if (tT(prev) == 'DEF_FRAGMENT') {
					true;
				} else if (tT(prev) == 'TERMINATOR') {
					// console.log "here?!??"
					var n = this._tokens.pop();
					// console.log n
					this.token('DEF_BODY','DEF_BODY',0);
					// token('TERMINATOR', '',0) unless n.@value.indexOf('//') >= 0
					this._tokens.push(n);
				} else {
					this.token('DEF_BODY','DEF_BODY',0);
				};
				
				this.pair('DEF');
			};
			return;
		};
		
		Lexer.prototype.tagContextToken = function (){
			var match;
			if (this._chunk[0] == '#') {
				// console.log('found id # in tagContextToken')
				this.token('#','#',1);
				return 1;
			};
			
			if (match = TAG_ATTR.exec(this._chunk)) {
				// console.log 'TAG_SDDSATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			return 0;
		};
		
		Lexer.prototype.tagDefContextToken = function (){
			// console.log "tagContextToken"
			var match;
			if (match = TAG_TYPE.exec(this._chunk)) {
				this.token('TAG_TYPE',match[0],match[0].length);
				return match[0].length;
			};
			
			if (match = TAG_ID.exec(this._chunk)) {
				var input = match[0];
				this.token('TAG_ID',input,input.length);
				return input.length;
			};
			
			return 0;
		};
		
		
		Lexer.prototype.tagToken = function (){
			var match, ary;
			if (!(match = TAG.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
			
			if (type == '<') {
				this.token('TAG_START','<',1);
				this.pushEnd(INVERSES.TAG_START);
				
				if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
					// special case should probably be handled in AST
					if (match[0] != 'self') {
						this.token('TAG_TYPE',match[0],match[0].length,1);
						return input.length + match[0].length;
					};
				};
				
				if (identifier) {
					if (identifier.substr(0,1) == '{') {
						return type.length;
					} else {
						this.token('TAG_NAME',input.substr(1),0);
					};
				};
			};
			
			return input.length;
		};
		
		
		Lexer.prototype.selectorToken = function (){
			var ary, string;
			var match;
			
			// special handling if we are in this context
			if (this._end == '%') {
				var chr = this._chunk.charAt(0);
				var open = this.inContext('open');
				
				// should add for +, ~ etc
				// should maybe rather look for the correct type of character?
				
				if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
					// console.log "close this selector directly"
					this.token('SELECTOR_END','%',0);
					this.pair('%');
					return 0;
				};
				
				if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
					// spaces between? -- include the whole
					this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
					return match[0].length;
				} else if (match = SELECTOR_PART.exec(this._chunk)) {
					var type = match[1];
					var id = match[2];
					
					switch (type) {
						case '.':
							tokid = 'SELECTOR_CLASS';break;
						
						case '#':
							tokid = 'SELECTOR_ID';break;
						
						case ':':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						case '::':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						default:
						
							var tokid = 'SELECTOR_TAG';
					
					};
					
					this.token(tokid,match[2],match[0].length);
					return match[0].length;
				} else if (chr == '[') {
					this.token('[','[',1);
					this.pushEnd(']');
					if (match = SELECTOR_ATTR.exec(this._chunk)) {
						// fuck this length shit
						var idoffset = match[0].indexOf(match[1]);
						var opoffset = match[0].indexOf(match[2]);
						this.token('IDENTIFIER',match[1],match[1].length,idoffset);
						this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
						return match[0].length;
					};
					return 1;
				} else if (chr == '|') {
					var tok = this._tokens[this._tokens.length - 1];
					tTs(tok,'SELECTOR_NS');
					// tok[0] = 'SELECTOR_NS' # FIX
					return 1;
				} else if (chr == ',') {
					this.token('SELECTOR_GROUP',',',1);
					return 1;
				} else if (chr == '*') {
					this.token('UNIVERSAL_SELECTOR','*',1);
					return 1;
				} else if (chr == ')') {
					this.pair('%');
					this.token('SELECTOR_END',')',1);
					return 1;
				} else if (idx$(chr,[')','}',']','']) >= 0) {
					this.pair('%');
					return 0;
				};
			};
			
			if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
			
			// this is a closed selector
			if (kind == '(') {
				// token '(','('
				this.token('SELECTOR_START',id,id.length + 1);
				// self.pushEnd(')') # are we so sure about this?
				this.pushEnd('%');
				
				// @ends.push ')'
				// @ends.push '%'
				return id.length + 1;
			} else if (id == '%') {
				// we are already scoped in on a selector
				if (this.context() == '%') { return 1 };
				this.token('SELECTOR_START',id,id.length);
				// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
				
				this.scope('%',{open: true});
				// @ends.push '%'
				// make sure a terminator breaks out
				return id.length;
			} else {
				return 0;
			};
			
			if ((id == '%' || id == '$') && ['%','$','@','(','['].indexOf(chr) >= 0) {
				var idx = 2;
				
				
				// VERY temporary way of solving this
				if ((chr == '%' || chr == '$' || chr == '@')) {
					id += chr;
					idx = 3;
					chr = this._chunk.charAt(2);
				};
				
				
				if (chr == '(') {
					if (!(string = this.balancedSelector(this._chunk,')'))) { return 0 };
					if (0 < string.indexOf('{',1)) {
						this.token('SELECTOR',id);
						// is this even used anymore? If so - we need to fix it
						this.interpolateString(string.slice(idx,-1));
						return string.length;
					} else {
						this.token('SELECTOR',id);
						this.token('(','(');
						this.token('STRING','"' + string.slice(idx,-1) + '"');
						this.token(')',')');
						return string.length;
					};
				} else if (chr == '[') {
					this.token('SELECTOR',id);
					return 1;
					// token '[','['
					// @ends.push ''
				};
			} else {
				return 0;
			};
		};
		
		// is this really needed? Should be possible to
		// parse the identifiers and = etc i jison?
		// what is special about methodNameToken? really?
		Lexer.prototype.methodNameToken = function (){
			// we can optimize this by after a def simply
			// fetching all the way after the def until a space or (
			// and then add this to the def-token itself (as with fragment)
			if (this._chunk.charAt(0) == ' ') { return 0 };
			
			var match;
			
			if (this._end == ')') {
				var outerctx = this._ends[this._ends.length - 2];
				// weird assumption, no?
				// console.log 'context is inside!!!'
				if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
					this.token('TAG_ATTR_SET',match[1]);
					return match[0].length;
				};
			};
			
			if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			// var prev = last @tokens
			var length = match[0].length;
			
			var id = match[0];
			var ltyp = this._lastTyp;
			var typ = 'IDENTIFIER';
			var pre = id.charAt(0);
			var space = false;
			
			var m4 = match[4]; // might be out of bounds? should rather check charAt
			// drop match 4??
			
			// should this not quit here in practically all cases?
			if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!' || m4 == '?') || match[5])) {
				return 0;
			};
			
			// again, why?
			if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
				return 0;
			};
			
			if (id == 'new') {
				typ = 'NEW';
			};
			
			if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
				return 0;
			};
			
			if (id == '|') {
				// hacky way to implement this
				// with new lexer we'll use { ... } instead, and assume object-context,
				// then go back and correct when we see the context is invalid
				if (ltyp == '(' || ltyp == 'CALL_START') {
					this.token('DO','DO',0);
					this.pushEnd('|');
					// @ends.push '|'
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (ltyp == 'DO' || ltyp == '{') {
					// @ends.push '|'
					this.pushEnd('|');
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (this._ends[this._ends.length - 1] == '|') {
					this.token('BLOCK_PARAM_END','|',1);
					this.pair('|');
					return length;
				} else {
					return 0;
				};
			};
			
			// whaat?
			// console.log("method identifier",id)
			if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
				return 0;
			};
			
			if (OP_METHODS.indexOf(id) >= 0) {
				space = true;
			};
			
			// not even anything we should use?!?
			if (pre == '@') {
				typ = 'IVAR';
			} else if (pre == '$') {
				true;
				// typ = 'GVAR'
			} else if (pre == '#') {
				typ = 'TAGID';
			} else if (CONST_IDENTIFIER.test(pre) || id == 'require' || id == 'global' || id == 'exports') {
				// really? seems very strange
				// console.log('global!!',typ,id)
				typ = 'CONST';
			};
			
			// what is this really for?
			if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING','IDREF'].indexOf(ltyp) >= 0) {
				this.token('.','.',0);
			};
			
			this.token(typ,id,length);
			
			if (space) {
				this._last.spaced = true;
			};
			
			return length;
		};
		
		
		Lexer.prototype.inTag = function (){
			var len = this._ends.length;
			if (len > 0) {
				var ctx0 = this._ends[len - 1];
				var ctx1 = len > 1 ? (this._ends[len - 2]) : (ctx0);
				return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			};
			return false;
		};
		
		Lexer.prototype.isKeyword = function (id){
			if ((id == 'attr' || id == 'prop')) {
				var scop = this.getScope();
				var incls = scop == 'CLASS' || scop == 'TAG';
				// var scopes = @indents.map(|ind,i| @scopes[i] or 'NONE')
				// console.log "id is prop: {scopes.join(" -> ")} | {@indents.join(" -> ")}"
				if (incls) { return true };
			};
			
			return ALL_KEYWORDS.indexOf(id) >= 0;
		};
		
		// Matches identifying literals: variables, keywords, method names, etc.
		// Check to ensure that JavaScript reserved words aren't being used as
		// identifiers. Because Imba reserves a handful of keywords that are
		// allowed in JavaScript, we're careful not to tokid them as keywords when
		// referenced as property names here, so you can still do `jQuery.is()` even
		// though `is` means `===` otherwise.
		Lexer.prototype.identifierToken = function (){
			var ary;
			var match;
			
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			var innerctx = ctx0;
			var typ;
			var reserved = false;
			
			var addLoc = false;
			var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			
			// console.log ctx1,ctx0
			
			if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
				// console.log 'TAG_ATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			
			// see if this is a plain object-key
			// way too much logic going on here?
			// the ast should normalize whether keys
			// are accessable as keys or strings etc
			if (match = OBJECT_KEY.exec(this._chunk)) {
				var id = match[1];
				typ = 'IDENTIFIER';
				
				// FIXME loc of key includes colon
				// moveCaret(id:length)
				// console.log "ok"
				if (true) {
					// console.log "got here? {match}"
					this.token(typ,id,id.length);
					this.moveCaret(id.length);
					this.token(':',':',match[3].length);
					this.moveCaret(-id.length);
					// moveCaret(match[3]:length)
					return match[0].length;
				};
				
				// moveCaret(match[2]:length)
				// return 0
				console.log(match[3].length);
				this.token(typ,id,match[0].length);
				this.token(':',':',1);
				return match[0].length;
			};
			
			if (!(match = IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			
			var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
			var idlen = id.length;
			
			// What is the logic here?
			if (id == 'own' && this.lastTokenType() == 'FOR') {
				this.token('OWN',id,id.length);
				return id.length;
			};
			
			var prev = last(this._tokens);
			var lastTyp = this._lastTyp;
			
			// should we force this to be an identifier even if it is a reserved word?
			// this should only happen for when part of object etc
			// will prev ever be @???
			var forcedIdentifier;
			
			// again
			forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
			
			
			// temp hack! need to solve for other keywords etc as well
			// problem appears with ternary conditions.
			
			// well -- it should still be an indentifier if in object?
			// forcedIdentifier = no if id in ['undefined','break']
			
			if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
			
			// if we are not at the top level? -- hacky
			if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
				forcedIdentifier = true;
			};
			
			var isKeyword = false;
			
			// console.log "match",match
			// console.log "typ is {typ}"
			// little reason to check for this right here? but I guess it is only a simple check
			if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
				// console.log "TYP $"
				if (id == '$0') {
					typ = 'ARGUMENTS';
				} else {
					typ = 'ARGVAR';
					id = id.substr(1);
				};
			} else if (typ == '@') {
				typ = 'IVAR';
				
				// id:reserved = yes if colon
			} else if (typ == '#') {
				// we are trying to move to generic tokens,
				// so we are starting to splitting up the symbols and the items
				// we'll see if that works
				typ = 'IDENTIFIER';
				this.token('#','#');
				id = id.substr(1);
			} else if (typ == '@@') {
				typ = 'CVAR';
			} else if (typ == '$' && !colon) {
				typ = 'IDENTIFIER';
				// typ = 'GVAR'
			} else if (CONST_IDENTIFIER.test(id) || id == 'require' || id == 'global' || id == 'exports') {
				// thous should really be handled by the ast instead
				typ = 'CONST';
			} else if (id == 'elif') {
				this.token('ELSE','elif',id.length);
				this.token('IF','if');
				return id.length;
			} else {
				typ = 'IDENTIFIER';
			};
			
			
			
			// this catches all 
			if (!forcedIdentifier && (isKeyword = this.isKeyword(id))) {
				// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
				typ = id.toUpperCase();
				addLoc = true;
				
				// clumsy - but testing performance
				if (typ == 'YES') {
					typ = 'TRUE';
				} else if (typ == 'NO') {
					typ = 'FALSE';
				} else if (typ == 'NIL') {
					typ = 'NULL';
				} else if (typ == 'VAR') {
					if (this._lastVal == 'export') {
						tTs(prev,'EXPORT');
					};
				} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
					true;
				} else if (typ == 'TAG') {
					this.pushEnd('TAG');
					// @ends.push('TAG')
				} else if (typ == 'DEF') {
					// should probably shift context and optimize this
					this.openDef();
				} else if (typ == 'DO') {
					if (this.context() == 'DEF') this.closeDef();
				} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
					typ = 'LEADING_WHEN';
				} else if (typ == 'FOR') {
					this._seenFor = true;
				} else if (typ == 'UNLESS') {
					typ = 'IF'; // WARN
				} else if (UNARY.indexOf(typ) >= 0) {
					typ = 'UNARY';
				} else if (RELATION.indexOf(typ) >= 0) {
					if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
						typ = 'FOR' + typ; // ?
						this._seenFor = false;
					} else {
						typ = 'RELATION';
						if (String(this.value()) == '!') {
							this._tokens.pop(); // is fucked up??!
							// WARN we need to keep the loc, no?
							id = '!' + id;
						};
					};
				};
			};
			
			if (id == 'super') {
				typ = 'SUPER';
			};
			
			// do we really want to check this here
			if (!forcedIdentifier) {
				// should already have dealt with this
				
				if (isKeyword && IMBA_ALIASES.indexOf(id) >= 0) { id = IMBA_ALIAS_MAP[id] };
				// these really should not go here?!?
				switch (id) {
					case '!':
						typ = 'UNARY';break;
					
					case '==':
					case '!=':
					case '===':
					case '!==':
						typ = 'COMPARE';break;
					
					case '&&':
					case '||':
						typ = 'LOGIC';break;
					
					case 'break':
					case 'continue':
					case 'debugger':
					case 'arguments':
						typ = id.toUpperCase();break;
				
				};
			};
			
			// prev = last @tokens
			var len = input.length;
			
			// should be strict about the order, check this manually instead
			if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
				this.queueScope(typ);
				
				var i = this._tokens.length;
				
				while (i){
					prev = this._tokens[--i];
					var ctrl = "" + tV(prev);
					// console.log("ctrl is {ctrl}")
					// need to coerce to string because of stupid CS ===
					// console.log("prev is",prev[0],prev[1])
					if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
						tTs(prev,ctrl.toUpperCase());
						// prev[0] = ctrl.toUpperCase # FIX
					} else {
						break;
					};
				};
			} else if (typ == 'IF') {
				this.queueScope(typ);
			} else if (typ == 'IMPORT') {
				// could manually parse the whole ting here?
				this.pushEnd('IMPORT');
				// @ends.push 'IMPORT'
			} else if (id == 'from' && ctx0 == 'IMPORT') {
				typ = 'FROM';
				this.pair('IMPORT');
			} else if (id == 'as' && ctx0 == 'IMPORT') {
				typ = 'AS';
				this.pair('IMPORT');
			};
			
			if (typ == 'IDENTIFIER') {
				// see if previous was catch -- belongs in rewriter?
				if (lastTyp == 'CATCH') {
					typ = 'CATCH_VAR';
				};
			};
			
			if (colon) {
				this.token(typ,id,idlen);
				this.moveCaret(idlen);
				// console.log "add colon?"
				this.token(':',':',colon.length);
				this.moveCaret(-idlen);
			} else {
				this.token(typ,id,idlen);
			};
			
			return len;
		};
		
		// Matches numbers, including decimals, hex, and exponential notation.
		// Be careful not to interfere with ranges-in-progress.
		Lexer.prototype.numberToken = function (){
			var binaryLiteral;
			var match,number,lexedLength;
			
			if (!(match = NUMBER.exec(this._chunk))) { return 0 };
			
			number = match[0];
			lexedLength = number.length;
			
			if (binaryLiteral = /0b([01]+)/.exec(number)) {
				
				number = "" + parseInt(binaryLiteral[1],2);
			};
			
			var prev = last(this._tokens);
			
			if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
				// console.log "got here"
				this.token(".",".");
				number = number.substr(1);
			};
			
			
			this.token('NUMBER',number,lexedLength);
			return lexedLength;
		};
		
		Lexer.prototype.symbolToken = function (){
			var match,symbol,prev;
			
			if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
			symbol = match[0].substr(1);
			prev = last(this._tokens);
			
			// is this a property-access?
			// should invert this -- only allow when prev IS .. 
			
			// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
			
			// FIX
			if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR']) == -1) {
				this.token('.:',':',1);
				var sym = symbol.split(/[\:\\\/]/)[0]; // really?
				// token 'SYMBOL', "'#{symbol}'"
				this.token('IDENTIFIER',sym,sym.length,1);
				return (sym.length + 1);
			} else {
				// token 'SYMBOL', "'#{symbol}'"
				this.token('SYMBOL',symbol,match[0].length);
				return match[0].length;
			};
		};
		
		Lexer.prototype.escapeStr = function (str,heredoc,q){
			str = str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
			if (q) {
				var r = RegExp(("\\\\[" + q + "]"),"g");
				str = str.replace(r,q);
				str = str.replace(RegExp(("" + q),"g"),'\\$&');
			};
			return str;
			
			// str = str.replace(MULTILINER, '\\n')
			// str = str.replace(/\t/g, '\\t')
		};
		// Matches strings, including multi-line strings. Ensures that quotation marks
		// are balanced within the string's contents, and within nested interpolations.
		Lexer.prototype.stringToken = function (){
			var match,string;
			
			switch (this._chunk.charAt(0)) {
				case "'":
					if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
					string = match[0];
					this.token('STRING',this.escapeStr(string),string.length);
					// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
					break;
				
				case '"':
					if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
					// what about tripe quoted strings?
					
					if (string.indexOf('{') >= 0) {
						var len = string.length;
						// if this has no interpolation?
						// we are now messing with locations - beware
						this.token('STRING_START',string.charAt(0),1);
						this.interpolateString(string.slice(1,-1));
						this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
					} else {
						len = string.length;
						// string = string.replace(MULTILINER, '\\\n')
						this.token('STRING',this.escapeStr(string),len);
					};
					break;
				
				default:
				
					return 0;
			
			};
			
			this.moveHead(string);
			return string.length;
		};
		
		// Matches heredocs, adjusting indentation to the correct level, as heredocs
		// preserve whitespace, but ignore indentation to the left.
		Lexer.prototype.heredocToken = function (){
			var match,heredoc,quote,doc;
			
			if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
			
			heredoc = match[0];
			quote = heredoc.charAt(0);
			doc = this.sanitizeHeredoc(match[2],{quote: quote,indent: null});
			// console.log "found heredoc {match[0]:length} {doc:length}"
			
			if (quote == '"' && doc.indexOf('{') >= 0) {
				var open = match[1];
				// console.log doc.substr(0,3),match[1]
				this.token('STRING_START',open,open.length);
				this.interpolateString(doc,{heredoc: true,offset: open.length,quote: quote});
				this.token('STRING_END',open,open.length,heredoc.length - open.length);
			} else {
				this.token('STRING',this.makeString(doc,quote,true),0);
			};
			
			this.moveHead(heredoc);
			return heredoc.length;
		};
		
		// Matches and consumes comments.
		Lexer.prototype.commentToken = function (){
			var match,length,comment,indent,prev;
			
			var typ = 'HERECOMMENT';
			
			if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
				// console.log "match inline comment"
				length = match[0].length;
				indent = match[1];
				comment = match[2];
				
				prev = last(this._tokens);
				var pt = prev && tT(prev);
				var note = '//' + comment.substr(1);
				
				if (this._last && this._last.spaced) {
					note = ' ' + note;
					// console.log "the previous node was SPACED"
				};
				// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
				
				if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !pt) {
					// console.log "skip comment"
					// token 'INLINECOMMENT', comment.substr(2)
					// console.log "adding as terminator"
					this.token('TERMINATOR',note,length); // + '\n'
				} else {
					// console.log "add comment ({note})"
					if (pt == 'TERMINATOR') {
						tVs(prev,tV(prev) + note);
						// prev[1] += note
					} else if (pt == 'INDENT') {
						// console.log "adding comment to INDENT: {note}" # why not add directly here?
						this.addLinebreaks(1,note);
					} else {
						// console.log "comment here"
						// should we ever get here?
						this.token(typ,comment.substr(2),length); // are we sure?
					};
				};
				
				return length; // disable now while compiling
			};
			
			// should use exec?
			if (!(match = COMMENT.exec(this._chunk))) { return 0 };
			
			comment = match[0];
			var here = match[1];
			
			if (here) {
				this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
				this.token('TERMINATOR','\n');
			} else {
				this.token('HERECOMMENT',comment,comment.length);
				this.token('TERMINATOR','\n'); // auto? really?
			};
			
			this.moveHead(comment);
			return comment.length;
		};
		
		// Matches JavaScript interpolated directly into the source via backticks.
		Lexer.prototype.jsToken = function (){
			var match,script;
			
			if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
			this.token('JS',(script = match[0]).slice(1,-1));
			return script.length;
		};
		
		// Matches regular expression literals. Lexing regular expressions is difficult
		// to distinguish from division, so we borrow some basic heuristics from
		// JavaScript and Ruby.
		Lexer.prototype.regexToken = function (){
			var ary;
			var match,length,prev;
			
			if (this._chunk.charAt(0) != '/') { return 0 };
			if (match = HEREGEX.exec(this._chunk)) {
				length = this.heregexToken(match);
				this.moveHead(match[0]);
				return length;
			};
			
			prev = last(this._tokens);
			// FIX
			if (prev && (idx$(tT(prev),(prev.spaced ? (
				NOT_REGEX
			) : (
				NOT_SPACED_REGEX
			))) >= 0)) { return 0 };
			if (!(match = REGEX.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
			
			// FIXME
			// if regex[..1] is '/*'
			//	error 'regular expressions cannot begin with `*`'
			
			if (regex == '//') {
				regex = '/(?:)/';
			};
			
			this.token('REGEX',("" + regex + flags),m.length);
			return m.length;
		};
		
		// Matches multiline extended regular expressions.
		// The escaping should rather happen in AST - possibly as an additional flag?
		Lexer.prototype.heregexToken = function (match){
			var ary;
			var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
			
			if (0 > body.indexOf('#{')) {
				
				var re = body.replace(HEREGEX_OMIT,'').replace(/\//g,'\\/');
				
				if (re.match(/^\*/)) {
					this.error('regular expressions cannot begin with `*`');
				};
				
				this.token('REGEX',("/" + (re || '(?:)') + "/" + flags),heregex.length);
				return heregex.length;
			};
			
			// use more basic regex type
			
			this.token('CONST','RegExp');
			this._tokens.push(T.token('CALL_START','(',0));
			var tokens = [];
			
			for (var i = 0, items = iter$(this.interpolateString(body,{regex: true})), len = items.length, pair; i < len; i++) {
				
				pair = items[i];
				var tok = tT(pair); // FIX
				var value = tV(pair); // FIX
				
				if (tok == 'TOKENS') {
					// FIXME what is this?
					tokens.push.apply(tokens,value);
				} else {
					if (!value) {
						console.log("what??");
					};
					
					if (!(value = value.replace(HEREGEX_OMIT,''))) { continue; };
					
					value = value.replace(/\\/g,'\\\\');
					tokens.push(T.token('STRING',this.makeString(value,'"',true),0)); // FIX
				};
				
				tokens.push(T.token('+','+',0)); // FIX
			};
			
			tokens.pop();
			
			// FIX
			if (!(tokens[0] && tT(tokens[0]) == 'STRING')) {
				// FIX
				this._tokens.push(T.token('STRING','""'),T.token('+','+'));
			};
			
			this._tokens.push.apply(this._tokens,tokens); // what is this?
			// FIX
			
			if (flags) {
				this._tokens.push(T.token(',',',',0));
				this._tokens.push(T.token('STRING','"' + flags + '"',0));
			};
			
			this.token(')',')',0);
			
			return heregex.length;
		};
		
		// Matches newlines, indents, and outdents, and determines which is which.
		// If we can detect that the current line is continued onto the the next line,
		// then the newline is suppressed:
		//
		//     elements
		//       .each( ... )
		//       .map( ... )
		//
		// Keeps track of the level of indentation, because a single outdent token
		// can close multiple indents, so we need to know how far in we happen to be.
		Lexer.prototype.lineToken = function (){
			var match;
			
			if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
			// should it not pair by itself token('SELECTOR_END','%',0)
			// if @end == '%'
			// 	console.log "pairing selector in lineToken {@chunk.substr(0,10)}"
			// 	# should not need to add anything here?
			// 	pair('%')
			
			var indent = match[0];
			// var brCount = count indent, '\n'
			var brCount = this.moveHead(indent);
			this._seenFor = false;
			// reset column as well?
			
			var prev = last(this._tokens,1);
			var size = indent.length - 1 - indent.lastIndexOf('\n');
			var noNewlines = this.unfinished();
			
			// console.log "noNewlines",noNewlines
			// console.log "lineToken -- ",@chunk.substr(0,10),"--"
			if ((/^\n#\s/).test(this._chunk)) {
				this.addLinebreaks(1);
				return 0;
			};
			
			if (size - this._indebt == this._indent) {
				if (noNewlines) {
					this.suppressNewlines();
				} else {
					this.newlineToken(brCount);
				};
				return indent.length;
			};
			
			if (size > this._indent) {
				if (noNewlines) {
					this._indebt = size - this._indent;
					this.suppressNewlines();
					return indent.length;
				};
				
				if (this.inTag()) {
					// console.log "indent inside tokid?!?"
					// @indebt = size - @indent
					// suppressNewlines()
					return indent.length;
				};
				
				
				var diff = size - this._indent + this._outdebt;
				this.closeDef();
				
				var immediate = last(this._tokens);
				
				if (immediate && tT(immediate) == 'TERMINATOR') {
					tTs(immediate,'INDENT');
					immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
					
					// should rather add to meta somehow?!?
					// tVs(immediate,tV(immediate) + '%|%') # crazy
				} else {
					this.token('INDENT',"" + diff,0);
				};
				
				// console.log "indenting", prev, last(@tokens,1)
				// if prev and prev[0] == 'TERMINATOR'
				//   console.log "terminator before indent??"
				
				// check for comments as well ?
				
				this._indents.push(diff);
				this.pushEnd('OUTDENT');
				// @ends.push 'OUTDENT'
				this._outdebt = this._indebt = 0;
				this.addLinebreaks(brCount);
			} else {
				this._indebt = 0;
				this.outdentToken(this._indent - size,noNewlines,brCount);
				this.addLinebreaks(brCount - 1);
				// console.log "outdent",noNewlines,tokid()
			};
			
			this._indent = size;
			return indent.length;
		};
		
		// Record an outdent token or multiple tokens, if we happen to be moving back
		// inwards past several recorded indents.
		Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
			// here we should also take care to pop / reset the scope-body
			// or context-type for indentation 
			var dent = 0;
			while (moveOut > 0){
				var len = this._indents.length - 1;
				if (this._indents[len] == undefined) {
					moveOut = 0;
				} else if (this._indents[len] == this._outdebt) {
					moveOut -= this._outdebt;
					this._outdebt = 0;
				} else if (this._indents[len] < this._outdebt) {
					this._outdebt -= this._indents[len];
					moveOut -= this._indents[len];
				} else {
					dent = this._indents.pop() - this._outdebt;
					moveOut -= dent;
					this._outdebt = 0;
					
					if (!noNewlines) { this.addLinebreaks(1) };
					
					this.pair('OUTDENT');
					this.token('OUTDENT',"" + dent,0);
				};
			};
			
			if (dent) { this._outdebt -= moveOut };
			
			while (this.lastTokenValue() == ';'){
				this._tokens.pop();
			};
			
			if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
			
			// capping scopes so they dont hang around 
			this._scopes.length = this._indents.length;
			
			var ctx = this.context();
			if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
			this.closeDef();
			return this;
		};
		
		// Matches and consumes non-meaningful whitespace. tokid the previous token
		// as being "spaced", because there are some cases where it makes a difference.
		Lexer.prototype.whitespaceToken = function (){
			var match,nline,prev;
			if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
			prev = last(this._tokens);
			
			// FIX - why oh why?
			if (prev) {
				if (match) {
					prev.spaced = true;
					return match[0].length;
				} else {
					prev.newLine = true;
					return 0;
				};
			};
		};
		
		Lexer.prototype.addNewline = function (){
			return this.token('TERMINATOR','\n');
		};
		
		Lexer.prototype.moveHead = function (str){
			var br = count(str,'\n');
			return br;
		};
		
		
		Lexer.prototype.addLinebreaks = function (count,raw){
			var br;
			
			if (!raw && count == 0) { return this }; // no terminators?
			
			var prev = this._last;
			
			if (!raw) {
				if (count == 1) {
					br = '\n';
				} else if (count == 2) {
					br = '\n\n';
				} else if (count == 3) {
					br = '\n\n\n';
				} else {
					br = repeatString('\n',count);
				};
			};
			// FIX
			if (prev) {
				var t = prev._type; // @lastTyp
				var v = tV(prev);
				
				// we really want to add this
				if (t == 'INDENT') {
					// TODO we want to add to the indent
					// console.log "add the comment to the indent -- pre? {raw} {br}"
					
					var meta = prev._meta || (prev._meta = {pre: '',post: ''});
					meta.post += (raw || br);
					// tVs(v + (raw or br))
					return this;
				} else if (t == 'TERMINATOR') {
					// console.log "already exists terminator {br} {raw}"
					tVs(prev,v + (raw || br));
					return this;
				};
			};
			
			this.token('TERMINATOR',br,0);
			return;
		};
		
		// Generate a newline token. Consecutive newlines get merged together.
		Lexer.prototype.newlineToken = function (lines){
			// console.log "newlineToken"
			while (this.lastTokenValue() == ';'){
				console.log("pop token",this._tokens[this._tokens.length - 1]);
				this._tokens.pop();
			};
			
			this.addLinebreaks(lines);
			
			var ctx = this.context();
			// WARN now import cannot go over multiple lines
			if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
			this.closeDef(); // close def -- really?
			return this;
		};
		
		// Use a `\` at a line-ending to suppress the newline.
		// The slash is removed here once its job is done.
		Lexer.prototype.suppressNewlines = function (){
			if (this.value() == '\\') { this._tokens.pop() };
			return this;
		};
		
		// We treat all other single characters as a token. E.g.: `( ) , . !`
		// Multi-character operators are also literal tokens, so that Jison can assign
		// the proper order of operations. There are some symbols that we tokid specially
		// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
		// parentheses that indicate a method call from regular parentheses, and so on.
		Lexer.prototype.literalToken = function (){
			var match,value;
			if (match = OPERATOR.exec(this._chunk)) {
				value = match[0];
				if (CODE.test(value)) this.tagParameters();
			} else {
				value = this._chunk.charAt(0);
			};
			
			var end1 = this._ends[this._ends.length - 1];
			var end2 = this._ends[this._ends.length - 2];
			
			var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
			
			var tokid = value;
			var prev = last(this._tokens);
			var pt = prev && tT(prev);
			var pv = prev && tV(prev);
			var length = value.length;
			
			// is this needed?
			if (value == '=' && prev) {
				
				if (pv == '||' || pv == '&&') { // in ['||', '&&']
					tTs(prev,'COMPOUND_ASSIGN');
					tVs(prev,pv + '=');
					// prev[0] = 'COMPOUND_ASSIGN'
					// prev[1] += '='
					return value.length;
				};
			};
			
			if (value == ';') {
				this._seenFor = false;
				tokid = 'TERMINATOR';
			} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
				// console.log 'spaced before ( in tokid'
				// FIXME - should rather add a special token like TAG_PARAMS_START
				this.token(',',',');
			} else if (value == '->' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '/>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && this.context() == 'DEF') {
				// console.log('picked up >!!')
				tokid = 'DEF_FRAGMENT';
				
				// elif value is 'TERMINATOR' and end1 is '%' 
				// 	closeSelector()
			} else if (value == 'TERMINATOR' && end1 == 'DEF') {
				this.closeDef();
			} else if (value == '&' && this.context() == 'DEF') {
				// console.log("okay!")
				tokid = 'BLOCK_ARG';
				// change the next identifier instead?
			} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
				tokid = "SPLAT";
			} else if (value == '') {
				tokid = 'SQRT';
			} else if (value == '') {
				tokid = 'FUNC';
			} else if (idx$(value,MATH) >= 0) {
				tokid = 'MATH';
			} else if (idx$(value,COMPARE) >= 0) {
				tokid = 'COMPARE';
			} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
				tokid = 'COMPOUND_ASSIGN';
			} else if (idx$(value,UNARY) >= 0) {
				tokid = 'UNARY';
			} else if (idx$(value,SHIFT) >= 0) {
				tokid = 'SHIFT';
			} else if (idx$(value,LOGIC) >= 0) {
				tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
			} else if (prev && !prev.spaced) {
				// need a better way to do these
				if (value == '(' && end1 == '%') {
					tokid = 'TAG_ATTRS_START';
				} else if (value == '(' && idx$(pt,CALLABLE) >= 0) {
					// not using this ???
					// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
					tokid = 'CALL_START';
				} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
					tokid = 'INDEX_START';
					if (pt == '?') { tTs(prev,'INDEX_SOAK') };
					// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
				};
			};
			
			switch (value) {
				case '(':
				case '{':
				case '[':
					this.pushEnd(INVERSES[value]);break;
				
				case ')':
				case '}':
				case ']':
					this.pair(value);break;
			
			};
			
			// hacky rule to try to allow for tuple-assignments in blocks
			// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
			//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
			//   console.log("found comma")
			
			this.token(tokid,value,value.length);
			return value.length;
		};
		
		// Token Manipulators
		// ------------------
		
		// Sanitize a heredoc or herecomment by
		// erasing all external indentation on the left-hand side.
		Lexer.prototype.sanitizeHeredoc = function (doc,options){
			var match;
			var indent = options.indent;
			var herecomment = options.herecomment;
			
			if (herecomment) {
				if (HEREDOC_ILLEGAL.test(doc)) {
					this.error("block comment cannot contain '*/' starting");
				};
				if (doc.indexOf('\n') <= 0) { return doc };
			} else {
				var length_;while (match = HEREDOC_INDENT.exec(doc)){
					var attempt = match[1];
					if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
						indent = attempt;
					};
				};
			};
			
			if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
			if (!herecomment) { doc = doc.replace(/^\n/,'') };
			return doc;
		};
		
		// A source of ambiguity in our grammar used to be parameter lists in function
		// definitions versus argument lists in function calls. Walk backwards, tokidging
		// parameters specially in order to make things easier for the parser.
		Lexer.prototype.tagParameters = function (){
			var tok;
			if (this.lastTokenType() != ')') { return this };
			var stack = [];
			var tokens = this._tokens;
			var i = tokens.length;
			
			tTs(tokens[--i],'PARAM_END');
			
			while (tok = tokens[--i]){
				var t = tT(tok);
				switch (t) {
					case ')':
						stack.push(tok);
						break;
					
					case '(':
					case 'CALL_START':
						if (stack.length) {
							stack.pop();
						} else if (t == '(') {
							tTs(tok,'PARAM_START');
							return this;
						} else {
							return this;
						};
						break;
				
				};
			};
			
			return this;
		};
		
		// Close up all remaining open blocks at the end of the file.
		Lexer.prototype.closeIndentation = function (){
			// ctx = context
			// pair(ctx) if ctx in ['%','DEF']
			this.closeDef();
			this.closeSelector();
			return this.outdentToken(this._indent,false,0);
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedString = function (str,end){
			var match,letter,prev;
			
			// console.log 'balancing string!', str, end
			var stack = [end];
			var i = 0;
			
			// could it not happen here?
			while (i < (str.length - 1)){
				i++;
				letter = str.charAt(i);
				switch (letter) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							var v = str.slice(0,i + 1);
							return v;
						};
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				
				if (end == '}' && (letter == '"' || letter == "'")) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
					i += match[0].length - 1;
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == '"' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter;
			};
			
			if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
		};
		
		// Expand variables and expressions inside double-quoted strings using
		// Ruby-like notation for substitution of arbitrary expressions.
		//
		//     "Hello #{name.capitalize()}."
		//
		// If it encounters an interpolation, this method will recursively create a
		// new Lexer, tokenize the interpolated contents, and merge them into the
		// token stream.
		Lexer.prototype.interpolateString = function (str,options){
			// console.log "interpolate string"
			if(options === undefined) options = {};
			var heredoc = options.heredoc;
			var quote = options.quote;
			var regex = options.regex;
			var prefix = options.prefix;
			
			var startLoc = this._loc;
			var tokens = [];
			var pi = 0;
			var i = -1;
			var locOffset = options.offset || 1;
			var strlen = str.length;
			var letter;
			var expr;
			
			var isInterpolated = false;
			// out of bounds
			while (letter = str.charAt(i += 1)){
				if (letter == '\\') {
					i += 1;
					continue;
				};
				
				if (!(str.charAt(i) == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
					continue;
				};
				
				isInterpolated = true;
				
				// these have no real sense of location or anything?
				if (pi < i) {
					// this is the prefix-string - before any item
					var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
					// tok.@loc = @loc + pi
					// tok.@len = i - pi + 2
					tokens.push(tok);
				};
				
				tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
				
				var inner = expr.slice(1,-1);
				// console.log 'inner is',inner
				// remove leading spaces 
				// need to keep track of how much whitespace we dropped from the start
				inner = inner.replace(/^[^\n\S]+/,'');
				
				if (inner.length) {
					// we need to remember the loc we start at
					// console.log('interpolate from loc',@loc,i)
					// really? why not just add to the stack??
					// what about the added 
					// should share with the selector no?
					// console.log "tokenize inner parts of string",inner
					var spaces = 0;
					var offset = this._loc + i + (expr.length - inner.length) - 1;
					// why create a whole new lexer? Should rather reuse one
					// much better to simply move into interpolation mode where
					// we continue parsing until we meet unpaired }
					var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
					// console.log nested.pop
					
					if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
						nested.shift();
					};
					
					if (nested.length) {
						tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
					};
				};
				
				// should rather add the amount by which our lexer has moved?
				i += expr.length - 1;
				tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
				pi = i + 1;
			};
			
			// adding the last part of the string here
			if (i >= pi && pi < str.length) {
				// set the length as well - or?
				// the string after?
				// console.log 'push neostring'
				tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
			};
			
			// console.log tokens:length
			if (regex) { return tokens };
			
			if (!tokens.length) { return this.token('NEOSTRING','""') };
			
			for (var j = 0, len = tokens.length; j < len; j++) {
				this._tokens.push(tokens[j]);
			};
			
			return tokens;
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedSelector = function (str,end){
			var prev;
			var letter;
			var stack = [end];
			// FIXME
			for (var len = str.length, i = 1; i < len; i++) {
				switch (letter = str.charAt(i)) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							return str.slice(0,i + 1);
						};
						
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				if (end == '}' && letter == [')']) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == ')' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter; // what, why?
			};
			
			return this.error(("missing " + (stack.pop()) + ", starting"));
		};
		
		// Pairs up a closing token, ensuring that all listed pairs of tokens are
		// correctly balanced throughout the course of the token stream.
		Lexer.prototype.pair = function (tok){
			var wanted = last(this._ends);
			if (tok != wanted) {
				if ('OUTDENT' != wanted) { this.error(("unmatched " + tok)) };
				var size = last(this._indents);
				this._indent -= size;
				this.outdentToken(size,true,0);
				return this.pair(tok);
			};
			return this.popEnd();
		};
		
		
		// Helpers
		// -------
		
		// Add a token to the results, taking note of the line number.
		Lexer.prototype.token = function (id,value,len,offset){
			this._lastTyp = id;
			this._lastVal = value;
			var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
			this._tokens.push(tok);
			return;
		};
		
		Lexer.prototype.lastTokenType = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (tT(token)) : ('NONE');
		};
		
		Lexer.prototype.lastTokenValue = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (token._value) : ('');
		};
		
		// Peek at a tokid in the current token stream.
		Lexer.prototype.tokid = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tTs(tok,val) };
				return tT(tok);
				// tok.@type = tokid if tokid # why?
				// tok.@type
			} else {
				return null;
			};
		};
		
		// Peek at a value in the current token stream.
		Lexer.prototype.value = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tVs(tok,val) };
				return tV(tok);
				// tok.@value = val if val # why?
				// tok.@value
			} else {
				return null;
			};
		};
		
		
		// Are we in the midst of an unfinished expression?
		Lexer.prototype.unfinished = function (){
			if (LINE_CONTINUER.test(this._chunk)) { return true };
			return UNFINISHED.indexOf(this._lastTyp) >= 0;
		};
		
		// var tokens = ['\\','.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'THROW', 'EXTENDS']
		
		// Converts newlines for string literals.
		Lexer.prototype.escapeLines = function (str,heredoc){
			return str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
		};
		
		// Constructs a string token by escaping quotes and newlines.
		Lexer.prototype.makeString = function (body,quote,heredoc){
			if (!body) { return quote + quote };
			body = body.replace(/\\([\s\S])/g,function(match,contents) {
				return (contents == '\n' || contents == quote) ? (contents) : (match);
			});
			// Does not work now
			body = body.replace(RegExp(("" + quote),"g"),'\\$&');
			return quote + this.escapeLines(body,heredoc) + quote;
		};
		
		// Throws a syntax error on the current `@line`.
		Lexer.prototype.error = function (message,len){
			if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
			
			if (len) {
				message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
			};
			
			var err = new SyntaxError(message);
			err.line = this._line;
			// err:columnNumber
			err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
			err.region = [this._loc,this._loc + (len || 0)];
			throw err;
		};
		return Lexer;
	
	})()

/***/ },
/* 31 */
/***/ function(module, exports) {

	(function(){
		var TOK, LBRACKET, RBRACKET, LPAREN, RPAREN, INDENT, OUTDENT;
		
		
		module.exports.TOK = TOK = {};
		var TTERMINATOR = TOK.TERMINATOR = 1;
		var TIDENTIFIER = TOK.IDENTIFIER = 2;
		TIDENTIFIER = TOK.IVAR = 2;
		var CONST = TOK.CONST = 3;
		var VAR = TOK.VAR = 4;
		var IF = TOK.IF = 5;
		var ELSE = TOK.ELSE = 6;
		var DEF = TOK.DEF = 7;
		
		
		
		function Token(type,value,loc,len){
			this._type = type;
			this._value = value;
			this._loc = loc != null ? (loc) : (-1);
			this._len = len || 0;
			this._meta = null;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.traverse = function (){
			return;
		};
		
		Token.prototype.c = function (){
			return "" + this._value;
		};
		
		Token.prototype.toString = function (){
			return this._value;
		};
		
		Token.prototype.charAt = function (i){
			return this._value.charAt(i);
		};
		
		Token.prototype.slice = function (i){
			return this._value.slice(i);
		};
		
		Token.prototype.region = function (){
			return [this._loc,this._loc + (this._len || this._value.length)];
		};
		
		Token.prototype.sourceMapMarker = function (){
			return this._loc == -1 ? (':') : (("%$" + (this._loc) + "$%"));
			// @col == -1 ? '' : "%%{@line}${@col}%%"
		};
		
		
		function lex(){
			var token = this.tokens[this.pos++];
			var ttag;
			
			if (token) {
				ttag = token._type;
				this.yytext = token;
			} else {
				ttag = '';
			};
			
			return ttag;
		}; exports.lex = lex;
		
		
		// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
		function token(typ,val){
			return new Token(typ,val,-1,0);
		}; exports.token = token;
		
		function typ(tok){
			return tok._type;
		}; exports.typ = typ;
		function val(tok){
			return tok._value;
		}; exports.val = val; // tok[offset + 1]
		function line(tok){
			return tok._line;
		}; exports.line = line; // tok[offset + 2]
		function loc(tok){
			return tok._loc;
		}; exports.loc = loc; // tok[offset + 2]
		
		function setTyp(tok,v){
			return tok._type = v;
		}; exports.setTyp = setTyp;
		function setVal(tok,v){
			return tok._value = v;
		}; exports.setVal = setVal;
		function setLine(tok,v){
			return tok._line = v;
		}; exports.setLine = setLine;
		function setLoc(tok,v){
			return tok._loc = v;
		}; exports.setLoc = setLoc;
		
		
		module.exports.LBRACKET = LBRACKET = new Token('{','{',0,0,0);
		module.exports.RBRACKET = RBRACKET = new Token('}','}',0,0,0);
		
		module.exports.LPAREN = LPAREN = new Token('(','(',0,0,0);
		module.exports.RPAREN = RPAREN = new Token(')',')',0,0,0);
		
		LBRACKET.generated = true;
		RBRACKET.generated = true;
		LPAREN.generated = true;
		RPAREN.generated = true;
		
		module.exports.INDENT = INDENT = new Token('INDENT','2',0,0,0);
		return module.exports.OUTDENT = OUTDENT = new Token('OUTDENT','2',0,0,0);
	
	})()

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var INVERSES, LINEBREAKS;
		
		// The Imba language has a good deal of optional syntax, implicit syntax,
		// and shorthand syntax. This can greatly complicate a grammar and bloat
		// the resulting parse table. Instead of making the parser handle it all, we take
		// a series of passes over the token stream, using this **Rewriter** to convert
		// shorthand into the unambiguous long form, add implicit indentation and
		// parentheses, and generally clean things up.
		
		var T = __webpack_require__(31);
		var Token = T.Token;
		
		// Based on the original rewriter.coffee from CoffeeScript
		function Rewriter(){ };
		
		exports.Rewriter = Rewriter; // export class 
		Rewriter.prototype.tokens = function (){
			return this._tokens;
		};
		
		// Helpful snippet for debugging:
		//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
		// Rewrite the token stream in multiple passes, one logical filter at
		// a time. This could certainly be changed into a single pass through the
		// stream, with a big ol' efficient switch, but it's much nicer to work with
		// like this. The order of these passes matters -- indentation must be
		// corrected before implicit parentheses can be wrapped around blocks of code.
		Rewriter.prototype.rewrite = function (tokens,opts){
			var token;
			if(opts === undefined) opts = {};
			this._tokens = tokens;
			this._options = opts;
			
			// console.log "tokens in: " + tokens:length
			if (opts.profile) { console.time("tokenize:rewrite") };
			
			var i = 0;
			// flag empty methods
			while (token = tokens[i]){
				var next = tokens[i + 1];
				if (token._type == 'DEF_BODY' && next && next._type == 'TERMINATOR') {
					token._type = 'DEF_EMPTY';
				};
				i++;
			};
			
			this.step("ensureFirstLine");
			this.step("removeLeadingNewlines");
			this.step("removeMidExpressionNewlines");
			this.step("tagDefArguments");
			this.step("closeOpenCalls");
			this.step("closeOpenIndexes");
			this.step("closeOpenTags");
			this.step("closeOpenTagAttrLists");
			this.step("addImplicitIndentation");
			this.step("tagPostfixConditionals");
			this.step("addImplicitBraces");
			this.step("addImplicitParentheses");
			
			if (opts.profile) { console.timeEnd("tokenize:rewrite") };
			// console.log "tokens out: " + @tokens:length
			return this._tokens;
		};
		
		Rewriter.prototype.step = function (fn){
			if (this._options.profile) {
				console.log(("---- starting " + fn + " ---- "));
				console.time(fn);
			};
			
			this[fn]();
			
			if (this._options.profile) {
				console.timeEnd(fn);
				console.log("\n\n");
			};
			return;
		};
		
		// Rewrite the token stream, looking one token ahead and behind.
		// Allow the return value of the block to tell us how many tokens to move
		// forwards (or backwards) in the stream, to make sure we don't miss anything
		// as tokens are inserted and removed, and the stream changes length under
		// our feet.
		Rewriter.prototype.scanTokens = function (block){
			var token;
			var tokens = this._tokens;
			
			var i = 0;
			while (token = tokens[i]){
				i += block.call(this,token,i,tokens);
			};
			
			return true;
		};
		
		Rewriter.prototype.detectEnd = function (i,condition,action){
			var tokens = this._tokens;
			var levels = 0;
			var starts = [];
			var token;
			var t,v;
			
			while (token = tokens[i]){
				if (levels == 0 && condition.call(this,token,i,starts)) {
					return action.call(this,token,i);
				};
				if (!token || levels < 0) {
					return action.call(this,token,i - 1);
				};
				
				t = T.typ(token);
				
				if (EXPRESSION_START.indexOf(t) >= 0) {
					if (levels == 0) { starts.push(i) };
					levels += 1;
				} else if (EXPRESSION_END.indexOf(t) >= 0) {
					levels -= 1;
				};
				i += 1;
			};
			return i - 1;
		};
		
		Rewriter.prototype.ensureFirstLine = function (){
			var tok = this._tokens[0];
			
			if (T.typ(tok) == 'TERMINATOR') {
				// console.log "adding bodystart"
				this._tokens = [T.token('BODYSTART','BODYSTART')].concat(this._tokens);
				// T.setTyp(tok,'HEADER')
			};
			return;
		};
		
		// Leading newlines would introduce an ambiguity in the grammar, so we
		// dispatch them here.
		Rewriter.prototype.removeLeadingNewlines = function (){
			var at = 0;
			
			for (var i = 0, ary = iter$(this._tokens), len = ary.length; i < len; i++) {
				if (T.typ(ary[i]) != 'TERMINATOR') {
					at = i;break;
				};
			};
			
			if (at) { this._tokens.splice(0,at) };
			
			return;
		};
		
		// Some blocks occur in the middle of expressions -- when we're expecting
		// this, remove their trailing newlines.
		Rewriter.prototype.removeMidExpressionNewlines = function (){
			var self = this;
			return self.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
				var next = self.tokenType(i + 1);
				
				if (!(T.typ(token) == 'TERMINATOR' && EXPRESSION_CLOSE.indexOf(next) >= 0)) { return 1 };
				if (next == 'OUTDENT') { return 1 };
				tokens.splice(i,1);
				return 0;
			});
		};
		
		
		Rewriter.prototype.tagDefArguments = function (){
			return true;
		};
		
		// The lexer has tagged the opening parenthesis of a method call. Match it with
		// its paired close. We have the mis-nested outdent case included here for
		// calls that close on the same line, just before their outdent.
		Rewriter.prototype.closeOpenCalls = function (){
			var self = this;
			var condition = function(token,i) {
				var t = T.typ(token);
				return (t == ')' || t == 'CALL_END') || t == 'OUTDENT' && self.tokenType(i - 1) == ')';
			};
			
			var action = function(token,i) {
				var t = T.typ(token);
				var tok = self._tokens[t == 'OUTDENT' ? (i - 1) : (i)];
				return T.setTyp(tok,'CALL_END');
			};
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'CALL_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close.
		Rewriter.prototype.closeOpenIndexes = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[']','INDEX_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'INDEX_END'); };
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		
		Rewriter.prototype.closeOpenTagAttrLists = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[')','TAG_ATTRS_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_ATTRS_END'); }; // 'TAG_ATTRS_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_ATTRS_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close. Should be done in lexer directly
		Rewriter.prototype.closeOpenTags = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['>','TAG_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_END'); }; // token[0] = 'TAG_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		Rewriter.prototype.addImplicitCommas = function (){
			return;
		};
		
		Rewriter.prototype.addImplicitBlockCalls = function (){
			var token;
			var i = 1;
			var tokens = this._tokens;
			
			while (token = tokens[i]){
				var t = token._type;
				var v = token._value;
				// hmm
				if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
					tokens.splice(i + 1,0,T.token('CALL_END',')'));
					tokens.splice(i + 1,0,T.token('CALL_START','('));
					i++;
				};
				i++;
			};
			
			return;
		};
		
		// Object literals may be written with implicit braces, for simple cases.
		// Insert the missing braces here, so that the parser doesn't have to.
		Rewriter.prototype.addImplicitBraces = function (){
			var self = this;
			var stack = [];
			var start = null;
			var startIndent = 0;
			var startIdx = null;
			
			var noBraceTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			var noBraceContext = ['IF','TERNARY','FOR'];
			
			var noBrace = false;
			
			var scope = function() {
				return stack[stack.length - 1] || [];
			};
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var open = function(token,i) {
				return self._tokens.splice(i,0,T.LBRACKET);
			};
			
			var close = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var stackToken = function(a,b) {
				return [a,b];
			};
			
			return self.scanTokens(function(token,i,tokens) {
				var type = T.typ(token);
				var v = T.val(token);
				var ctx = stack[stack.length - 1] || [];
				var idx;
				
				if (noBraceContext.indexOf(type) >= 0) {
					// console.log "found noBraceTag {type}"
					stack.push(stackToken(type,i));
					return 1;
				};
				
				if (v == '?') {
					// console.log('TERNARY OPERATOR!')
					stack.push(stackToken('TERNARY',i));
					return 1;
				};
				
				// no need to test for this here as well as in
				if (EXPRESSION_START.indexOf(type) >= 0) {
					if (type == 'INDENT' && noBraceContext.indexOf(ctx[0]) >= 0) {
						stack.pop();
					};
					
					// console.log('expression start',type,ctx[0])
					if (type == 'INDENT' && self.tokenType(i - 1) == '{') {
						// stack ?!? no token
						stack.push(stackToken('{',i)); // should not autogenerate another?
					} else {
						stack.push(stackToken(type,i));
					};
					return 1;
				};
				
				if (EXPRESSION_END.indexOf(type) >= 0) {
					// console.log "EXPRESSION_END at {type} - stack is {ctx[0]}"
					if (ctx[0] == 'TERNARY') { // FIX?
						stack.pop();
					};
					
					start = stack.pop();
					if (!start) {
						console.log("NO STACK!!");
					};
					start[2] = i;
					
					// seems like the stack should use tokens, no?)
					if (start[0] == '{' && start.generated) { //  # type != '}' # and start:generated
						close(token,i);
						return 1;
					};
					
					return 1;
				};
				
				// is this correct? same for if/class etc?
				if (ctx[0] == 'TERNARY' && (type == 'TERMINATOR' || type == 'OUTDENT')) {
					stack.pop();
					return 1;
				};
				
				if (noBraceContext.indexOf(ctx[0]) >= 0 && type == 'INDENT') {
					console.log("popping noBraceContext");
					stack.pop();
					return 1;
				};
				
				
				if (type == ',') {
					// automatically add an ending here if inside:generated scope?
					// it is important that this is:generated(!)
					if (ctx[0] == '{' && ctx.generated) {
						tokens.splice(i,0,T.RBRACKET);
						stack.pop();
						return 2;
					} else {
						return 1;
					};
					true;
				};
				
				// found a type
				if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
					// could just check if the end was right before this?
					
					if (start && start[2] == i - 1) {
						// console.log('this expression was just ending before colon!')
						idx = start[1] - 1; // these are the stackTokens
					} else {
						// console.log "rewrite here? #{i}"
						idx = i - 2; // if start then start[1] - 1 else i - 2
						// idx = idx - 1 if tokenType(idx) is 'TERMINATOR'
					};
					
					while (self.tokenType(idx - 1) == 'HERECOMMENT'){
						idx -= 2;
					};
					
					var t0 = tokens[idx - 1];
					
					if (t0 && T.typ(t0) == '}' && t0.generated) {
						tokens.splice(idx - 1,1);
						var s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
						tokens.splice(idx - 2,1);
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else {
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						open(token,idx + 1);
						return 2;
					};
				};
				
				// we probably need to run through autocall first?!
				
				if (type == 'DO') { // and ctx:generated
					var prev = T.typ(tokens[i - 1]); // [0]
					if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
						
						var tok = T.token(',',',');
						tok.generated = true;
						tokens.splice(i,0,tok);
						
						if (ctx.generated) {
							close(token,i);
							stack.pop();
							return 2;
						};
					};
				};
				
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'DEF_BODY') && ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
				
				return 1;
			});
		};
		
		// Methods may be optionally called without parentheses, for simple cases.
		// Insert the implicit parentheses here, so that the parser doesn't have to
		// deal with them.
		// Practically everything will now be callable this way (every identifier)
		Rewriter.prototype.addImplicitParentheses = function (){
			
			var self = this, token;
			var noCallTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.token('CALL_END',')'));
			};
			
			// console.log "adding implicit parenthesis" # ,self:scanTokens
			var tokens = self._tokens;
			
			var noCall = false;
			var seenFor = false;
			var endCallAtTerminator = false;
			
			var i = 0;
			while (token = tokens[i]){
				
				// to handle cases like:
				// if a(do yes).test
				// 	yes
				// we need to keep a stack for balanced pairs
				// until then you must explicitly end the call like
				// if a(do yes).test()
				// 	yes
				
				var type = token._type;
				
				var prev = tokens[i - 1];
				var current = tokens[i];
				var next = tokens[i + 1];
				
				var pt = prev && prev._type;
				var nt = next && next._type;
				
				// if pt == 'WHEN'
				// Never make these tags implicitly call
				// should we not just remove these from IMPLICIT_FUNC?
				if ((pt == ')' || pt == ']') && type == 'INDENT') {
					noCall = true;
				};
				
				if (noCallTag.indexOf(pt) >= 0) {
					// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
					endCallAtTerminator = true;
					noCall = true;
					if (pt == 'FOR') { seenFor = true };
				};
				
				
				var callObject = false;
				var callIndent = false;
				
				// [prev, current, next] = tokens[i - 1 .. i + 1]
				
				// check for comments
				// console.log "detect end??"
				if (!noCall && type == 'INDENT' && next) {
					var prevImpFunc = pt && IMPLICIT_FUNC.indexOf(pt) >= 0;
					var nextImpCall = nt && IMPLICIT_CALL.indexOf(nt) >= 0;
					callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
					callIndent = nextImpCall && prevImpFunc;
				};
				
				var seenSingle = false;
				var seenControl = false;
				// Hmm ?
				
				// this is not correct if this is inside a block,no?
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'INDENT')) {
					endCallAtTerminator = false;
					noCall = false;
				};
				
				if (type == '?' && prev && !prev.spaced) { token.call = true };
				
				// where does fromThem come from?
				if (token.fromThen) {
					i += 1;continue;
				};
				// here we deal with :spaced and :newLine
				if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC.indexOf(pt) >= 0) && (IMPLICIT_CALL.indexOf(type) >= 0 || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
					i += 1;continue;
				};
				
				
				tokens.splice(i,0,T.token('CALL_START','('));
				// console.log "added ( {prev}"
				var cond = function(token,i) {
					var type = T.typ(token);
					if (!seenSingle && token.fromThen) { return true };
					var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
					if (ifelse || type == 'CATCH') { seenSingle = true };
					if (ifelse || type == 'SWITCH' || type == 'TRY') { seenControl = true };
					var prev = self.tokenType(i - 1);
					
					if ((type == '.' || type == '?.' || type == '::') && prev == 'OUTDENT') { return true };
					if (endCallAtTerminator && (type == 'INDENT' || type == 'TERMINATOR')) { return true };
					if ((type == 'WHEN' || type == 'BY') && !seenFor) {
						// console.log "dont close implicit call outside for"
						return false;
					};
					
					var post = tokens[i + 1];
					var postTyp = post && T.typ(post);
					// WTF
					return !token.generated && prev != ',' && (IMPLICIT_END.indexOf(type) >= 0 || (type == 'INDENT' && !seenControl) || (type == 'DOS' && prev != '=')) && (type != 'INDENT' || (self.tokenType(i - 2) != 'CLASS' && IMPLICIT_BLOCK.indexOf(prev) == -1 && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL.indexOf(postTyp) >= 0))));
				};
				
				// The action for detecting when the call should end
				// console.log "detect end??"
				self.detectEnd(i + 1,cond,action);
				if (T.typ(prev) == '?') { T.setTyp(prev,'FUNC_EXIST') };
				i += 2;
				// need to reset after a match
				endCallAtTerminator = false;
				noCall = false;
				seenFor = false;
			};
			
			
			return;
		};
		
		// Because our grammar is LALR(1), it can't handle some single-line
		// expressions that lack ending delimiters. The **Rewriter** adds the implicit
		// blocks, so it doesn't need to. ')' can close a single-line block,
		// but we need to make sure it's balanced.
		Rewriter.prototype.addImplicitIndentation = function (){
			
			
			var self = this, token;
			var i = 0;
			var tokens = self._tokens;
			while (token = tokens[i]){
				var type = T.typ(token);
				var next = self.tokenType(i + 1);
				
				// why are we removing terminators after then? should be able to handle
				if (type == 'TERMINATOR' && next == 'THEN') {
					tokens.splice(i,1);
					continue;
				};
				
				if (type == 'CATCH' && idx$(self.tokenType(i + 2),['OUTDENT','TERMINATOR','FINALLY']) >= 0) {
					tokens.splice.apply(tokens,[].concat([i + 2,0], [].slice.call(self.indentation(token))));
					i += 4;continue;
				};
				
				if (SINGLE_LINERS.indexOf(type) >= 0 && (next != 'INDENT' && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
					
					var starter = type;
					
					var indent = T.token('INDENT','2');
					var outdent = T.OUTDENT;
					// var indent, outdent = indentation(token)
					if (starter == 'THEN') { indent.fromThen = true }; // setting special values for these -- cannot really reuse?
					indent.generated = true;
					// outdent:generated = true
					tokens.splice(i + 1,0,indent);
					
					var condition = function(token,i) {
						var t = T.typ(token);
						return T.val(token) != ';' && SINGLE_CLOSERS.indexOf(t) >= 0 && !(t == 'ELSE' && starter != 'IF' && starter != 'THEN');
					};
					
					var action = function(token,i) {
						var idx = self.tokenType(i - 1) == ',' ? (i - 1) : (i);
						return tokens.splice(idx,0,outdent);
					};
					
					self.detectEnd(i + 2,condition,action);
					if (type == 'THEN') { tokens.splice(i,1) };
				};
				
				i++;
			};
			
			return;
		};
		
		// Tag postfix conditionals as such, so that we can parse them with a
		// different precedence.
		Rewriter.prototype.tagPostfixConditionals = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['TERMINATOR','INDENT']) >= 0; };
			
			return self.scanTokens(function(token,i) {
				var typ = T.typ(token);
				if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
				var original = token;
				self.detectEnd(i + 1,condition,function(token,i) {
					if (T.typ(token) != 'INDENT') { return T.setTyp(original,'POST_' + T.typ(original)) };
				});
				return 1;
			});
		};
		
		// Generate the indentation tokens, based on another token on the same line.
		Rewriter.prototype.indentation = function (token){
			return [T.token('INDENT','2'),T.token('OUTDENT','2')];
		};
		
		// Look up a type by token index.
		Rewriter.prototype.type = function (i){
			// if i < 0 then return null
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// if tok then tok[0] else null
		};
		
		Rewriter.prototype.tokenType = function (i){
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// return tok and tok[0]
		};
		
		// Constants
		// ---------
		
		// List of the token pairs that must be balanced.
		var BALANCED_PAIRS = [
			['(',')'],
			['[',']'],
			['{','}'],
			['{{','}}'],
			['INDENT','OUTDENT'],
			['CALL_START','CALL_END'],
			['PARAM_START','PARAM_END'],
			['INDEX_START','INDEX_END'],
			['TAG_START','TAG_END'],
			['TAG_PARAM_START','TAG_PARAM_END'],
			['TAG_ATTRS_START','TAG_ATTRS_END'],
			['BLOCK_PARAM_START','BLOCK_PARAM_END']
		];
		
		// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
		// look things up from either end.
		module.exports.INVERSES = INVERSES = {};
		
		// The tokens that signal the start/end of a balanced pair.
		// var EXPRESSION_START = []
		// var EXPRESSION_END   = []
		
		for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
			pair = ary[i];
			var left = pair[0];
			var rite = pair[1];
			INVERSES[rite] = left;
			INVERSES[left] = rite;
		};
		
		var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','TAG_PARAM_START','BLOCK_PARAM_START','STRING_START','{{','TAG_START'];
		var EXPRESSION_END = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','TAG_PARAM_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END'];
		
		var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];
		
		// Tokens that indicate the close of a clause of an expression.
		var EXPRESSION_CLOSE = ['CATCH','WHEN','ELSE','FINALLY'].concat(EXPRESSION_END);
		
		// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
		var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
		'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];
		
		// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
		var IMPLICIT_CALL = [
			'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
			'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
			'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
			'FOR','STRING_START','CONTINUE','BREAK'
		]; // '->', '=>', why does it not work with symbol?
		
		var IMPLICIT_INDENT_CALL = [
			'FOR'
		];
		// is not do an implicit call??
		
		var IMPLICIT_UNSPACED_CALL = ['+','-'];
		
		// Tokens indicating that the implicit call must enclose a block of expressions.
		var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 
		
		var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		var LOGIC = ['&&','||','&','|','^'];
		
		// optimize for fixed arrays
		var NO_IMPLICIT_BLOCK_CALL = [
			'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
			'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
		]; // .concat(COMPOUND_ASSIGN)
		
		
		// console.log NO_IMPLICIT_BLOCK_CALL:length
		// NO_IMPLICIT_BLOCK_CALL
		// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']
		
		var IMPLICIT_COMMA = ['DO'];
		
		// Tokens that always mark the end of an implicit call for single-liners.
		var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];
		
		// Single-line flavors of block expressions that have unclosed endings.
		// The grammar can't disambiguate them, so we insert the implicit indentation.
		var SINGLE_LINERS = ['ELSE','TRY','FINALLY','THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR']; // '->', '=>', really?
		var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
		
		// Tokens that end a line.
		return LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT'];
	
	})()

/***/ },
/* 33 */
/***/ function(module, exports) {

	(function(){
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		// create separate error-types with all the logic
		
		function ImbaParseError(e,o){
			this.error = e;
			this.message = e.message;
			this.filename = e.filename;
			this.line = e.line;
			this._options = o || {};
			this;
		};
		
		subclass$(ImbaParseError,Error);
		exports.ImbaParseError = ImbaParseError; // export class 
		ImbaParseError.wrap = function (err){
			// what about the stacktrace?
			return new ImbaParseError(err);
		};
		
		ImbaParseError.prototype.set = function (opts){
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(opts), l = keys.length; i < l; i++){
				this._options[keys[i]] = opts[keys[i]];
			};
			return this;
		};
		
		ImbaParseError.prototype.start = function (){
			var o = this._options;
			var idx = o.pos - 1;
			var tok = o.tokens && o.tokens[idx];
			while (tok && tok._loc == -1){
				tok = o.tokens[--idx];
			};
			return tok;
		};
		
		ImbaParseError.prototype.desc = function (){
			var o = this._options;
			var msg = this.message;
			if (o.token && o.token._loc == -1) {
				return 'Syntax Error';
			} else {
				return msg;
			};
		};
		
		ImbaParseError.prototype.loc = function (){
			var start_;
			return (start_ = this.start()) && start_.region  &&  start_.region();
		};
		
		ImbaParseError.prototype.toJSON = function (){
			var o = this._options;
			var tok = this.start();
			// var tok = o:tokens and o:tokens[o:pos - 1]
			// var loc = tok and [tok.@loc,tok.@loc + (tok.@len or tok.@value:length)] or [0,0]
			// , col: tok.@col, line: tok.@line
			// get the token itself?
			return {warn: true,message: this.desc(),loc: this.loc()};
		};
		return ImbaParseError;
	
	})()

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var Region = __webpack_require__(27).Region;
		
		
		function isWhitespace(str){
			return (/^[\n\t\ ]+$/).test(str);
		}; exports.isWhitespace = isWhitespace;
		
		function commonAncestor(a,b){
			if (a instanceof Array) {
				var arr = a.slice();
				return arr.reduce(function(prev,curr,i) {
					return commonAncestor(prev,curr);
				},arr.shift());
			};
			
			if (!a || !b) { return (a || b) };
			
			a = a._dom || a;
			b = b._dom || b;
			
			while (!a.contains(b)){
				a = a.parentNode;
			};
			while (!b.contains(a)){
				b = b.parentNode;
			};
			
			return tag$wrap(a);
		}; exports.commonAncestor = commonAncestor;
		
		
		var pairs = {
			'"': '"',
			"'": "'",
			'(': ')',
			'<': '>',
			'[': ']',
			'{': '}'
		};
		
		function wrapText(text,open,close){
			close || (close = pairs[open]);
			if (open == "'") { text = text.replace(/\'/g,"\\'") };
			return (open || '') + text + (close || '');
		}; exports.wrapText = wrapText;
		
		
		function stringIsBalanced(str){
			var opens = '[{("\'';
			var closes = ']})"\'';
			var stack = [];
			var i = 0;
			var s,end;
			
			while (s = str[i++]){
				var oid = opens.indexOf(s);
				
				if (s == end) {
					stack.pop();
					end = stack[stack.length - 1];
				} else if (oid >= 0) {
					stack.push(end = closes[oid]);
				};
			};
			
			return stack.length == 0 ? (true) : (false);
		}; exports.stringIsBalanced = stringIsBalanced;
		
		function colToLoc(line,col,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var ci = 0;
			var rci = 0; // real column
			var char$;
			
			if (col == 0) { return 0 };
			
			while (char$ = line[ci++]){
				if (char$ == '\t') {
					var rest = tabsize - rci % tabsize;
					rci += rest;
				} else {
					rci += 1;
				};
				
				if (rci >= col) {
					return ci;
				};
			};
			
			return line.length;
		}; exports.colToLoc = colToLoc;
		
		function colToViewCol(line,col,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var ci = 0;
			var rci = 0; // real column
			var char$;
			
			if (col == 0) { return 0 };
			
			while (char$ = line[ci++]){
				if (char$ == '\t') {
					var rest = tabsize - rci % tabsize;
					if (rest > 3 && col <= rci + 2) { break; };
					rci += rest;
				} else {
					rci += 1;
				};
				
				if (col <= rci) { break; };
			};
			return rci;
		}; exports.colToViewCol = colToViewCol;
		
		function colsForLine(line,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var col = 0;
			var idx = 0;
			var char$;
			while (char$ = line[idx++]){
				if (char$ == '\t') {
					var rest = tabsize - col % tabsize;
					col += rest;
				} else {
					col += 1;
				};
			};
			return col;
		}; exports.colsForLine = colsForLine;
		
		function rowcol(buf,loc,tabsize){
			if(tabsize === undefined) tabsize = 4;
			buf = buf.toString();
			var pos = loc;
			var col = 0;
			var line = 0;
			var char$;
			
			// go back to start of line
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					break;
				};
				pos--;
			};
			
			// get column for slice
			while ((pos < loc) && (char$ = buf[pos])){
				if (char$ == '\t') {
					var rest = tabsize - (col % tabsize);
					col += rest;
				} else {
					col += 1;
				};
				pos++;
			};
			
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					line++;
				};
				pos--;
			};
			
			return [line,col];
		}; exports.rowcol = rowcol;
		
		function increaseIndent(str){
			var reg = /^(\s*(.*\=\s*)?(export |global |extend )?(class|def|tag|unless|if|else|elif|switch|try|catch|finally|for|while|until|do))/;
			var other = /\b(do)\b/;
			return reg.test(str) || other.test(str);
		}; exports.increaseIndent = increaseIndent;
		
		
		function repeatString(str,count){
			return new Array(count + 1).join(str);
		}; exports.repeatString = repeatString;
		
		
		function patchString(orig,str,mode){
			var region;
			var text = orig.toString();
			
			if (mode == 'append') {
				return text + str;
			} else if (mode == 'prepend') {
				return "" + str + text;
			} else {
				if (region = Region.normalize(mode)) {
					// let region = Region.normalize()
					return text.substr(0,region.start()) + str + text.slice(region.end());
				};
			};
		}; exports.patchString = patchString;; return patchString;
		
		
	
	})()

/***/ },
/* 35 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		function HistoryState(data){
			if(data === undefined) data = {};
			this._timestamp = new Date();
			this._data = data;
			this;
		};
		
		
		
		HistoryState.prototype.data = function(v){ return this._data; }
		HistoryState.prototype.setData = function(v){ this._data = v; return this; };
		
		
		HistoryState.prototype.timestamp = function(v){ return this._timestamp; }
		HistoryState.prototype.setTimestamp = function(v){ this._timestamp = v; return this; };
		
		HistoryState.prototype.apply = function (view){
			return this;
		};
		
		HistoryState.prototype.update = function (data){
			this._data = data;
			this._timestamp = new Date();
			return this;
		};
		
		
		function FullHistoryState(){ return HistoryState.apply(this,arguments) };
		
		subclass$(FullHistoryState,HistoryState);
		FullHistoryState.prototype.apply = function (view){
			view.loadState(this._data);
			return this;
		};
		
		function DiffHistoryState(){ return HistoryState.apply(this,arguments) };
		
		subclass$(DiffHistoryState,HistoryState);
		
		
		var types = {};
		
		function Command(params){
			this._params = params;
		};
		
		
		
		Command.prototype.prev = function(v){ return this._prev; }
		Command.prototype.setPrev = function(v){ this._prev = v; return this; };
		
		
		Command.prototype.next = function(v){ return this._next; }
		Command.prototype.setNext = function(v){ this._next = v; return this; };
		
		
		Command.prototype.frame = function(v){ return this._frame; }
		Command.prototype.setFrame = function(v){ this._frame = v; return this; };
		
		Command.sym = function (sym){
			var $0 = arguments, i = $0.length;
			var pars = new Array(i>1 ? i-1 : 0);
			while(i>1) pars[--i - 1] = $0[i];
			this.prototype._symbol = sym;
			this.prototype._signature = pars;
			types[sym] = this;
			return this;
		};
		
		Command.load = function (o){
			var typ = types[o[0]];
			var frame = o[1];
			var cmd = typ.build(o[2]);
			cmd.setFrame(frame);
			return cmd;
		};
		
		Command.build = function (params){
			return new this(params);
		};
		
		Command.prototype.data = function (){
			return this._data;
		};
		
		Command.prototype.params = function (){
			return this._params;
		};
		
		Command.prototype.undo = function (view){
			return this.prev();
		};
		
		Command.prototype.redo = function (view){
			return this;
		};
		
		Command.prototype.enter = function (view){
			return this;
		};
		
		Command.prototype.remove = function (){
			var v_;
			if (this.prev()) { (this.prev().setNext(v_ = this.next()),v_) };
			if (this.next()) { (this.next().setPrev(v_ = this.prev()),v_) };
			return this;
		};
		
		Command.prototype.toJSON = function (){
			return [this._symbol,this._frame || 0,this.params() || []];
		};
		
		function Mark(){ return Command.apply(this,arguments) };
		
		subclass$(Mark,Command);
		Mark.sym('M','value');
		
		
		function Snapshot(params){
			this._code = params[0];
		};
		
		subclass$(Snapshot,Mark);
		Snapshot.sym('S','code');
		
		Snapshot.prototype.params = function (){
			return [this._code];
		};
		
		Snapshot.prototype.redo = function (view){
			console.log('load',this._code);
			view.load(this._code);
			// must repair? what about annotations?
			return this;
		};
		
		function Selection(params){
			this._old = params[0];
			this._new = params[1];
		};
		
		subclass$(Selection,Command);
		Selection.sym('|','old','new');
		
		Selection.load = function (val){
			return new this(val);
		};
		
		Selection.prototype.params = function (){
			return [this._old,this._new];
		};
		
		Selection.prototype.redo = function (view){
			view.caret().set(JSON.parse(this._new));
			return this;
		};
		
		Selection.prototype.enter = function (view){
			this.redo(view);
			return this;
		};
		
		Selection.prototype.undo = function (view){
			// we need to know about the previous selection for this?
			// can either store both - or traverse backwards to the previous
			// command like this
			var old = JSON.parse(this._old);
			console.log('move selection back to old',old,this.data());
			view.caret().set(old);
			return this.prev();
		};
		
		
		function Insert(pars){
			this._point = pars[0];
			this._str = pars[1];
		};
		
		subclass$(Insert,Command);
		Insert.sym('+','point','str');
		
		Insert.prototype.params = function (){
			return [this._point,this._str];
		};
		
		Insert.prototype.redo = function (view){
			console.log('redo Insert');
			return view.insert(this._point,this._str);
		};
		
		Insert.prototype.undo = function (view){
			console.log('undo Insert');
			view.erase([this._point,this._point + this._str.length]);
			return this.prev();
		};
		
		function Erase(params){
			this._region = params[0];
			this._str = params[1];
		};
		
		subclass$(Erase,Command);
		Erase.sym('-','region','str');
		
		Erase.prototype.params = function (){
			return [this._region,this._str];
		};
		
		Erase.prototype.redo = function (view){
			console.log('redo Erase');
			return view.erase(this._region);
		};
		
		Erase.prototype.undo = function (view){
			// if we dont know the text to 
			console.log('undo Erase');
			view.insert(this._region.start(),this._str);
			return this.prev();
		};
		
		
		function History(view){
			this._mode = 'normal';
			this._view = view;
			this._enabled = true;
			this._active = false;
			this.setCurrent(this._seed = new Mark());
			this;
		};
		
		exports.History = History; // export class 
		
		
		History.prototype.mode = function(v){ return this._mode; }
		History.prototype.setMode = function(v){ this._mode = v; return this; };
		
		
		History.prototype.view = function(v){ return this._view; }
		History.prototype.setView = function(v){ this._view = v; return this; };
		
		
		History.prototype.enabled = function(v){ return this._enabled; }
		History.prototype.setEnabled = function(v){ this._enabled = v; return this; };
		
		
		History.prototype.current = function(v){ return this._current; }
		History.prototype.setCurrent = function(v){ this._current = v; return this; };
		
		
		History.prototype.seed = function(v){ return this._seed; }
		History.prototype.setSeed = function(v){ this._seed = v; return this; };
		
		
		History.prototype.tail = function(v){ return this._tail; }
		History.prototype.setTail = function(v){ this._tail = v; return this; }; // is this behind or in the very front?
		
		History.prototype.add = function (item,move,frame){
			if(move === undefined) move = true;
			if(frame === undefined) frame = this.view().frames();
			item.setFrame(frame);
			
			if (this.current()) {
				// if current has a next event
				// this should be detached here?
				item.setPrev(this.current());
				this.current().setNext(item);
			};
			
			if (move) { (this.setCurrent(item),item) };
			return this;
		};
		
		History.prototype.next = function (){
			var current_;
			return (current_ = this.current()) && current_.next  &&  current_.next();
		};
		
		History.prototype.prev = function (){
			var current_;
			return (current_ = this.current()) && current_.prev  &&  current_.prev();
		};
		
		History.prototype.update = function (o){
			return this;
		};
		
		History.prototype.move = function (dir){
			if(dir === undefined) dir = 1;
			return this;
		};
		
		History.prototype.redo = function (){
			var self = this;
			self.apply(function() {
				var res = [];while (self.next()){
					self.next().redo(self.view(),self);
					self.setCurrent(self.next());
					if (self.current() instanceof Mark) { break; };
				};return res;
			});
			return self;
		};
		
		History.prototype.undo = function (){
			var self = this;
			self.apply(function() {
				// should be possible to undo 
				var res = [], v_, current_;while (self.current()){
					if (self.prev()) { (self.setCurrent(v_ = self.current().undo(self.view(),self)),v_) };
					(current_ = self.current()) && current_.enter  &&  current_.enter(self.view(),self);
					if (self.current() instanceof Mark) { break; };
				};return res;
			});
			
			return self;
		};
		
		History.prototype.apply = function (cb){
			this._active = true;
			cb && cb();
			this._active = false;
			return this;
		};
		
		History.prototype.batch = function (cb){
			return this;
		};
		
		History.prototype.enter = function (state){
			state.apply(this.view());
			return this;
		};
		
		History.prototype.onerase = function (reg,str,edit){
			if (this._active) { return this };
			return this.add(new Erase([reg,str]));
		};
		
		History.prototype.oninsert = function (loc,str,edit){
			if (this._active) { return this };
			return this.add(new Insert([loc,str]));
		};
		
		History.prototype.oncaret = function (old,new$){
			if (this._active) { return this };
			return this.add(new Selection([old,new$]));
		};
		
		History.prototype.onload = function (code){
			if (this._active) { return this };
			var mark = new Snapshot([code]);
			return this.add(mark);
		};
		
		History.prototype.mark = function (value){
			if (this._active) { return this };
			var mark = new Mark([value]);
			return this.add(mark);
		};
		
		History.prototype.tick = function (){
			
			var self = this;
			if (self._mode == 'play') {
				// console.log 'plyaing'
				var frame = self.view().frames() - self._offset;
				// console.log 'history.tick will play',frame,next,current
				self.apply(function() {
					var res = [], v_;while (self.next() && self.next().frame() <= frame){
						// console.log 'history.tick play',frame,next,current
						// console.log 'replay frame!'
						self.next().redo(self.view(),self);
						res.push(((self.setCurrent(v_ = self.next()),v_)));
					};return res;
				});
				
				if (!(self.next())) {
					self.setMode('live');
				};
			};
			return self;
		};
		
		History.prototype.play = function (){
			// should probably happen in a different manager
			var self = this;
			var snap = self.seed();
			while (!(!snap || (snap instanceof Snapshot))){
				snap = snap.next();
			};
			
			self._offset = self.view().frames() - snap.frame();
			console.log("playing from seed",snap,self._offset);
			// console.log 'found snapshot?!? -- offset frame',@offset
			self.apply(function() { var v_;
			return (self.setCurrent(v_ = snap.redo(self.view(),self)),v_); });
			self.setMode('play');
			return self;
		};
		
		History.prototype.toJSON = function (){
			var data = [];
			var step = this._seed;
			
			while (step){
				data.push(step.toJSON());
				step = step.next();
			};
			
			return {commands: data};
		};
		
		History.prototype.load = function (data){
			var step = this.seed();
			for (var i = 0, ary = iter$(data.commands), len = ary.length; i < len; i++) {
				var item = Command.load(ary[i]);
				item.setPrev(step);
				step.setNext(item);
				step = item;
				// console.log 'load item',item
			};
			// console.log 'loaded'
			return this;
		};
		return History;
		
		
	
	})()

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		function Logger(view){
			this._enabled = true;
			this._view = view;
			this;
		};
		
		exports.Logger = Logger; // export class 
		
		
		Logger.prototype.enabled = function(v){ return this._enabled; }
		Logger.prototype.setEnabled = function(v){ this._enabled = v; return this; };
		
		
		Logger.prototype.view = function(v){ return this._view; }
		Logger.prototype.setView = function(v){ this._view = v; return this; };
		
		Logger.prototype.log = function (){
			if (this._enabled || (1)) { console.log.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.warn = function (){
			if (this._enabled || (1)) { console.log.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.group = function (name){
			if (this._enabled || (1)) { console.group.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.groupCollapsed = function (){
			if (this._enabled || (1)) { console.groupCollapsed.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.groupEnd = function (){
			if (this._enabled || (1)) { console.groupEnd() };
			return this;
		};
		return Logger;
		
		
	
	})()

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		var self = this;
		var util = __webpack_require__(34);
		
		var specialKeys = {
			8: "backspace",
			9: "tab",
			10: "return",
			13: "return",
			16: "shift",
			17: "ctrl",
			18: "alt",
			19: "pause",
			20: "capslock",
			27: "esc",
			32: "space",
			33: "pageup",
			34: "pagedown",
			35: "end",
			36: "home",
			37: "left",
			38: "up",
			39: "right",
			40: "down",
			45: "insert",
			46: "del",
			59: ";",
			61: "=",
			96: "0",
			97: "1",
			98: "2",
			99: "3",
			100: "4",
			101: "5",
			102: "6",
			103: "7",
			104: "8",
			105: "9",
			106: "*",
			107: "+",
			109: "-",
			110: ".",
			111: "/",
			112: "f1",
			113: "f2",
			114: "f3",
			115: "f4",
			116: "f5",
			117: "f6",
			118: "f7",
			119: "f8",
			120: "f9",
			121: "f10",
			122: "f11",
			123: "f12",
			144: "numlock",
			145: "scroll",
			173: "-",
			186: ";",
			187: "=",
			188: ",",
			189: "-",
			190: ".",
			191: "/",
			192: "`",
			219: "[",
			220: "\\",
			221: "]",
			222: "'"
		};
		
		var shiftNums = {
			"`": "~",
			"1": "!",
			"2": "@",
			"3": "#",
			"4": "$",
			"5": "%",
			"6": "^",
			"7": "&",
			"8": "*",
			"9": "(",
			"0": ")",
			"-": "_",
			"=": "+",
			";": ": ",
			"'": '"',
			",": "<",
			".": ">",
			"/": "?",
			"\\": "|"
		};
		
		function trigger(key,o){
			if (o instanceof Function) {
				o = {command: o};
			};
			o.trigger = key;
			return o;
		};
		
		function combo(keys,o){
			if (o instanceof Function) { o = {command: o} };
			o.keys = keys;
			return o;
		};
		
		IM.KeyBindings = [
			
			combo(['super+z'],function(sel) { return sel.view().history().undo(); }),
			combo(["super+shift+z"],function(sel) { return sel.view().history().redo(); }),
			combo(["alt+super+p"],function(sel) { return sel.view().history().play(); }),
			// combo ["alt+shift+r"] do |sel| sel.view.history.play
			
			combo(["super+s"],{command: "save"}),
			combo(["super+b"],{command: "run"}),
			combo(["alt+super+s"],{command: "saveSession"}),
			combo(["alt+shift+l"],{command: "reparse"}),
			combo(["alt+shift+k"],{command: "reparseExtent"}),
			
			combo(["super+a"],function(sel) { return sel.selectAll(); }),
			
			
			combo(['tab'],{context: function(sel) { return sel.text().indexOf('\n') >= 0; },
			command: function(sel) {
				sel.expandToLines();
				var region = sel.region();
				var nodes = sel.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline')) {
						console.log('found tab in selection',match);
						if (match.mode != 'start') {
							return match.node.indent();
						};
					};
				});
				return sel.dirty();
			}}),
			
			
			
			combo(["shift+tab"],{context: function(sel) { return sel.text().indexOf('\n') >= 0; },
			command: function(sel) {
				sel.expandToLines();
				var region = sel.region();
				var nodes = sel.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						return match.node.undent();
					};
				});
				return sel.dirty();
			}}),
			
			combo(["shift+tab"],{context: function(e) {
				return true; // String(e.view.selection).indexOf('\n') >= 0
			},
			command: function(sel) {
				console.log('try undent');
				return true;
			}}),
			
			combo(["alt+shift+return"],function(sel) { return console.log('prettify'); }),
			
			combo(["backspace"],{context: function(e) {
				console.log('deleteLeftRight backspace?!?',e.region(),e.region().peek(-1,1));
				return idx$(e.region().peek(-1,1),['[]','{}','<>','()','""',"''"]) >= 0;
			},
			
			command: function(sel) {
				console.log('moving!!');
				sel.expand(-1,1);
				return sel.erase();
			}}),
			
			combo(["backspace"],{context: function(sel,o) {
				var reg = sel.region();
				if (reg.size() == 0) {
					if (o.node = reg.prevNode('._impair,._imstr')) {
						return true;
					};
				};
			},
			
			command: function(sel,o) { var v_;
			return (sel.setRegion(v_ = o.node.region().clone().reverse()),v_); }}),
			
			combo(["backspace"],{context: function(sel,o) {
				if (sel.text() && !util.stringIsBalanced(sel.text())) {
					return true;
				};
			},
			command: function(sel,o) { return true; }}),
			
			combo(["backspace"],function(sel) { return sel.erase(); }),
			combo(["shift+backspace"],function(sel) { return sel.erase(); }),
			combo(["alt+backspace"],function(sel) { return sel.erase(IM.WORD_START); }),
			combo(["super+backspace"],function(sel) { return sel.erase(IM.LINE_START); }),
			
			combo(["return",'shift+return','super+return'],function(sel) {
				var ind = sel.indent();
				if (util.increaseIndent(sel.head().peekbehind())) { ind += '\t' };
				
				// should not happen in string
				if (idx$(sel.region().peek(-1,1),['[]','{}','()']) >= 0) {
					sel.insert('\n\t' + ind);
					sel.view().insert(sel.head().loc(),'\n' + ind);
				} else {
					sel.insert('\n' + ind);
				};
				
				return true;
			}),
			
			
			combo(['space','shift+space'],function(sel) {
				if (sel.region().peek(-1,1) == '<>') {
					sel.move(1).erase();
				};
				
				return sel.insert(' ');
			}),
			
			combo(['tab'],function(sel) { return sel.insert('\t'); }),
			
			
			combo(['super+up'],function(sel) {
				sel.collapse().head().set(0,0).normalize();
				return sel.dirty();
			}),
			
			combo(['super+down'],function(sel) {
				sel.collapse().head().set(100000,0).normalize();
				return sel.dirty();
			}),
			
			combo(['super+u'],function(sel,o) {
				console.log(sel.target(),"found ut!!!");
				return console.log(sel.target().bubble('unwrap',{}));
			}),
			
			combo(['alt+super+r'],function() { return window.location.reload(); })
		];
		
		IM.Triggers = [
			
			trigger('|',{context: function(sel) { return sel.region().peek(-1,1) == '||'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger('[',function(sel) { return sel.insert('[$0]'); }),
			trigger('|',function(sel) { return sel.insert('|$0|'); }),
			trigger('(',function(sel) { return sel.insert('($0)'); }),
			trigger('{',function(sel) { return sel.insert('{$0}'); }),
			
			trigger('<',{context: function(sel) { return !sel.peekbehind(/(\b(tag|if|class) |\d\s*$)/); },
			command: function(sel) { return sel.insert('<$0>'); }}),
			
			trigger('"',{context: function(sel,o) {
				if (sel.region().peek(-1,0) == '\\' && (o.node = sel.region().scope(q$('._imstr',self)))) {
					return true;
				};
			},
			command: function(sel) { return sel.insert('"'); }}),
			
			trigger("'",{context: function(sel,o) { return sel.region().peek(-1,1) == "''"; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger("'",{context: function(sel,o) { return o.node = sel.region().scope(q$('._imstr',self)); },
			command: function(sel) { return sel.insert("\\'"); }}),
			
			trigger('"',function(sel) { return sel.insert('"$0"'); }),
			trigger("'",function(sel) { return sel.insert("'$0'"); }),
			
			trigger(']',{context: function(sel) { return sel.region().peek(0,1) == ']'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger('}',{context: function(sel) { return sel.region().peek(0,1) == '}'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger(')',{context: function(sel) { return sel.region().peek(0,1) == ')'; },
			command: function(sel) { return sel.move(1); }})
		];
		
		function ShortcutManager(view,bindings){
			this._view = view;
			this._bindings = bindings || IM.KeyBindings;
			this;
		};
		
		global.ShortcutManager = ShortcutManager; // global class 
		ShortcutManager.prototype.view = function (){
			return this._view;
		};
		
		ShortcutManager.prototype.keysForEvent = function (e){
			var combo = [];
			var special = specialKeys[e.which];
			var chr = special || String.fromCharCode(e.which);
			
			chr = chr.toLowerCase(); // unless e:shiftKey
			
			if (e.ctrlKey && special != 'ctrl') { combo.push('ctrl') };
			if (e.altKey && special != 'alt') { combo.push('alt') };
			if (e.metaKey && !e.ctrlKey && special !== 'meta') { combo.push('super') };
			if (e.shiftKey && special != 'shift') { combo.push('shift') };
			if (combo.indexOf(chr) < 0) { combo.push(chr) };
			
			return combo.join('+');
		};
		
		ShortcutManager.prototype.commandsForKeys = function (combo){
			return this._bindings.filter(function(binding) { return binding.keys == combo; });
		};
		
		ShortcutManager.prototype.getShortcut = function (e){
			var combo = this.keysForEvent(e.event());
			console.log(combo);
			
			for (var i = 0, ary = iter$(this._bindings), len = ary.length, cmd; i < len; i++) {
				cmd = ary[i];
				if (cmd.keys.indexOf(combo) >= 0) {
					var o = {};
					// console.log 'found shortcut',combo,cmd:keys
					if (!cmd.context || cmd.context.call(this.view(),this.view().caret(),o,e,this.view())) {
						cmd.data = o;
						return cmd;
					};
				};
			};
			
			return null;
		};
		
		ShortcutManager.prototype.getTrigger = function (view,text){
			for (var i = 0, ary = iter$(IM.Triggers), len = ary.length, cmd; i < len; i++) {
				cmd = ary[i];
				if (cmd.trigger == text) {
					var res = cmd.context ? (cmd.context.call(view,view.caret(),view,text)) : (true);
					if (res) { return cmd };
				};
			};
			return null;
		};
		return ShortcutManager;
		
		
		
		
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 38 */
/***/ function(module, exports) {

	(function(){
		return tag$.defineTag('imcaptor', 'input', function(tag){
			
			tag.prototype.select = function (){
				if (!this.dom().value) {
					this.dom().value = 'x';
				};
				this.dom().select();
				return this;
			};
			
			tag.prototype.build = function (){
				var self = this;
				tag.__super__.build.apply(self,arguments);
				self.dom().onfocus = function(e) {
					console.log('dom onfocus!!!!');
					var event = Imba.Event.wrap({type: 'inputfocus',target: self.dom()});
					return event.process();
				};
				
				self.dom().onblur = function(e) {
					console.log('dom onblur!!!!',e);
					var event = Imba.Event.wrap({type: 'inputblur',target: self.dom(),relatedTarget: e.relatedTarget});
					return event.process();
					// Imba.Events.trigger('inputblur',dom)
				};
				
				return self;
			};
		});
	
	})()

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// disabling logs for now
		// console:log = do true
		// externs;
		
		var OPEN = ['"',"'",'(','[','{','<'];
		var CLOSE = ['"',"'",')',']','}','>'];
		
		if (Imba.Events) {
			Imba.Events.register(['copy','paste','cut','beforecut','beforepaste','beforecopy','keypress']);
		};
		
		var Logger = __webpack_require__(36).Logger;
		var History = __webpack_require__(35).History;
		var Buffer = __webpack_require__(40).Buffer;
		var Observer = __webpack_require__(41).Observer;
		
		var Region = __webpack_require__(27).Region;
		var hints$ = __webpack_require__(42), Hints = hints$.Hints, Hint = hints$.Hint;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		var util = __webpack_require__(34);
		
		__webpack_require__(43);
		
		__webpack_require__(44);
		
		tag$.defineTag('imdims', function(tag){
			
			tag.prototype.ch = function (){
				// uncache
				if (this._ow != this.dom().offsetWidth) {
					this._ow = this.dom().offsetWidth;
					this._ch = null;
				};
				
				return this._ch || (this._ch = this.dom().getBoundingClientRect().width);
			};
		});
		
		tag$.defineTag('imviewbody');
		
		tag$.defineTag('imview', function(tag){
			
			
			
			tag.prototype.filename = function(v){ return this._filename; }
			tag.prototype.setFilename = function(v){ this._filename = v; return this; };
			
			
			
			tag.prototype.observer = function(v){ return this._observer; }
			tag.prototype.setObserver = function(v){ this._observer = v; return this; };
			
			
			tag.prototype.history = function(v){ return this._history; }
			tag.prototype.setHistory = function(v){ this._history = v; return this; };
			
			
			tag.prototype.hints = function(v){ return this._hints; }
			tag.prototype.setHints = function(v){ this._hints = v; return this; };
			
			
			tag.prototype.logger = function(v){ return this._logger; }
			tag.prototype.setLogger = function(v){ this._logger = v; return this; };
			
			
			tag.prototype.shortcuts = function(v){ return this._shortcuts; }
			tag.prototype.setShortcuts = function(v){ this._shortcuts = v; return this; };
			
			tag.prototype.__focusNode = {watch: 'focusNodeDidSet',name: 'focusNode'};
			tag.prototype.focusNode = function(v){ return this._focusNode; }
			tag.prototype.setFocusNode = function(v){
				var a = this.focusNode();
				if(v != a) { this._focusNode = v; }
				if(v != a) { this.focusNodeDidSet && this.focusNodeDidSet(v,a,this.__focusNode) }
				return this;
			};
			
			
			tag.prototype.caret = function(v){ return this._caret; }
			tag.prototype.setCaret = function(v){ this._caret = v; return this; };
			
			
			tag.prototype.frames = function(v){ return this._frames; }
			tag.prototype.setFrames = function(v){ this._frames = v; return this; };
			
			
			tag.prototype.readonly = function(v){ return this._readonly; }
			tag.prototype.setReadonly = function(v){ this._readonly = v; return this; };
			
			tag.prototype.highlighter = function (){
				return Highlighter;
			};
			
			tag.prototype.lineHeight = function (){
				return this._dims.dom().offsetHeight;
			};
			
			tag.prototype.charWidth = function (){
				return this._dims.ch();
			};
			
			tag.prototype.isReadOnly = function (){
				return this.history().mode() == 'play';
			};
			
			tag.prototype.tabSize = function (){
				return 4;
			};
			
			tag.prototype.build = function (){
				// console.log 'build imview'
				VIEW = this;
				this.setTabindex(0);
				
				this._readonly = false;
				this._logger = new Logger(this);
				this._frames = 0;
				this._changes = 0;
				
				this._hints = new Hints(this);
				this._buffer = new Buffer(this);
				this._history = new History(this);
				this._shortcuts = new ShortcutManager(this);
				this.render();
				this._observer = new Observer(this);
				this.caret().setRegion(new Region(0,0,this.root(),this));
				
				// bind to mousemove of dom?
				
				this.dom().addEventListener('mouseover',function(e) { return Imba.Events.delegate(e); });
				this.dom().addEventListener('mouseout',function(e) { return Imba.Events.delegate(e); });
				return this;
			};
			
			tag.prototype.onmouseover = function (e){
				return e.halt();
			};
			
			tag.prototype.onmouseout = function (e){
				return e.halt();
			};
			
			tag.prototype.setInput = function (input){
				
				if (input != this._input) {
					this._input = input;
					// console.log 'set input!!!',@input
					this._input.dom()._responder = this.dom();
				};
				return this;
			};
			
			tag.prototype.input = function (){
				return this._input || this._caret.input();
			};
			
			// called every frame - looking for changed nodes to deal with
			// to deal with mutations.
			tag.prototype.tick = function (){
				this._frames++;
				this.history().tick();
				this.render();
				if (this._dirty) this.repair();
				return this;
			};
			
			tag.prototype.commit = function (){
				return this.tick();
			};
			
			tag.prototype.log = function (){
				var logger_;
				(logger_ = this.logger()).log.apply(logger_,arguments);
				return this;
			};
			
			tag.prototype.edited = function (){
				var self = this;
				self._changes++;
				self._dirty = true;
				self._buffer.refresh();
				
				self.view().hints().rem(function(hint) {
					return hint.group() == 'runtime';
				});
				
				self.hints().cleanup();
				
				self.delay('didchange',50,function() {
					return Imba.Events.trigger('edited:async',self,{data: self});
				});
				
				// we can improve how/when we choose to annotate.
				// currently we do it after every edit - but it should
				// really only be needed when we have changed identifiers.
				// should also only reannotate the closest known scope,
				// but this comes later with refactoring from whole files
				// to scopes.
				self.delay('annotate',500,function() { return self.annotate(); });
				self.delay('recompile',-1); // cancel recompilation
				return self;
			};
			
			tag.prototype.dirty = function (){
				return this;
			};
			
			tag.prototype.activate = function (){
				this.flag('active');
				return this;
			};
			
			tag.prototype.deactivate = function (){
				this.unflag('active');
				return this;
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$imviewbody().setRef('body',this)).setContent([
					(this._dims = this._dims || tag$.$imdims().setRef('dims',this)).setText("x").end(),
					(this._caret = this._caret || tag$.$imcaret().setRef('caret',this)).setView(this).end(),
					(this._root = this._root || tag$.$imroot().setRef('root',this).flag('imba')).setView(this).end()
				],2).end();
			};
			
			tag.prototype.header = function (){
				return null;
			};
			
			tag.prototype.footer = function (){
				return null;
			};
			
			tag.prototype.overlays = function (){
				return (this._overlays = this._overlays || tag$.$scrimbla_overlays().setRef('overlays',this)).setView(this).end();
			};
			
			tag.prototype.render = function (){
				return this.flag('readonly',this.isReadOnly()).setChildren([
					this.header(),
					this.body(),
					this.footer()
				],1).synced();
			};
			
			tag.prototype.view = function (){
				return this;
			};
			
			tag.prototype.sel = function (){
				return this.caret();
			};
			
			tag.prototype.root = function (){
				return this._root;
			};
			
			tag.prototype.buffer = function (){
				return this._buffer;
				// root.code
			};
			
			tag.prototype.size = function (){
				return this.root().size();
			};
			
			tag.prototype.load = function (code,o){
				var parsed;
				if(o === undefined) o = {};
				this.setFilename(o.filename);
				// console.log 'loading file with filename',o:filename
				// observer.pause do
				if (o.html) {
					this.root().dom().innerHTML = o.html;
					this._buffer.refresh();
					this.history().onload(this.code());
				} else {
					// should use our new parser
					if (parsed = this.parse(code)) {
						if (parsed.highlighted) {
							this.root().dom().innerHTML = parsed.highlighted;
						} else {
							this.root().dom().textContent = code;
						};
					};
					this._buffer.refresh();
					this.history().onload(code);
					this.annotate();
				};
				return this;
			};
			
			tag.prototype.parse = function (code){
				// here we can parse the full code
				return {highlighted: IM.parse(code)};
			};
			
			tag.prototype.refocus = function (){
				if (document.activeElement != this.input().dom()) { this.input().focus() };
				return this;
			};
			
			tag.prototype.oninputfocus = function (e){
				console.log('oninputfocus!!');
				VIEW = this; // hack
				return this.flag('focus');
			};
			
			tag.prototype.oninputblur = function (e){
				return this.unflag('focus');
			};
			
			tag.prototype.onfocusin = function (e){
				VIEW = this; // hack
				this.flag('focus');
				console.log('focus',e);
				return this;
			};
			
			tag.prototype.onfocusout = function (e){
				this.unflag('focus');
				console.log('unfocus',e);
				return this;
			};
			
			tag.prototype.oninput = function (e){
				return this;
			};
			
			tag.prototype.ontextinput = function (e){
				return this;
			};
			
			tag.prototype.execAction = function (action,keydown){
				var command_;
				if (action.command instanceof Function) {
					return action.command.call(this,this.caret(),action.data || {event: keydown},this);
				} else if ((typeof (command_ = action.command)=='string'||command_ instanceof String)) {
					this.log('command is string',action.command);
					var ev = Imba.Events.trigger(action.command,this,{data: action});
					this.log(ev);
					return this;
				};
			};
			
			tag.prototype.tryCommand = function (cmd,target,params){
				if(params === undefined) params = [];
				if (cmd.context) {
					var guard = cmd.context.apply(target || this,params);
					if (!guard) { return false };
				};
				
				if (cmd.command instanceof Function) {
					return cmd.command.apply(target || this,params);
				};
			};
			
			
			
			tag.prototype.onkeydown = function (e){
				var arr;
				VIEW = this; // hack
				e.halt();
				// var combo = e.keycombo
				var combo = this.shortcuts().keysForEvent(e.event());
				var action = this.shortcuts().getShortcut(e);
				var ins = null;
				
				var shift = (/\bshift\b/).test(combo);
				var alt = (/\balt\b/).test(combo);
				var sup = (/\bsuper\b/).test(combo);
				
				// log 'imview keydown',combo
				
				if (action) {
					// console.log 'action here?!',action
					if (this.execAction(action,e)) { e.cancel() };
					return;
				};
				
				// move these into commands as well
				// thisshould move this into commands instead
				if (arr = combo.match(/\b(left|right|up|down)/)) {
					this.hints().activate();
					
					var isCollapsed = this.caret().isCollapsed();
					var ends = this.caret().ends();
					
					shift ? (this.caret().decollapse()) : (this.caret().collapse());
					
					if (arr[0] == 'down') {
						this.caret().moveDown();
						return e.cancel();
					} else if (arr[0] == 'up') {
						this.caret().moveUp();
						return e.cancel();
					};
					
					var mode = IM.CHARACTERS;
					var dir = 0;
					
					if (arr[0] == 'left') {
						dir = -1;
					};
					
					if (arr[0] == 'right') {
						dir = 1;
					};
					
					if (alt) {
						mode = dir > 0 ? (IM.WORD_END) : (IM.WORD_START);
					} else if (sup) {
						mode = dir > 0 ? (IM.LINE_END) : (IM.LINE_START);
					} else if (!shift && !isCollapsed) {
						this.caret().head().set(dir > 0 ? (ends[1]) : (ends[0]));
						this.caret().dirty(); // should not need to call this all the time
						return e.cancel();
					};
					
					this.caret().move(dir,mode);
					
					return e.cancel();
				};
				
				if (e.event().which == 229) {
					return e.halt();
				};
				
				if (combo.match(/^super\+(c|v|x)$/)) {
					// console.log 'matching combo for copy paste'
					e.halt();
					this._awaitCombo = true;
					this.refocus();
					return;
				};
				
				if (ins != null) {
					e.halt().cancel();
					this.caret().insert(ins);
					return this;
				};
				
				return this;
			};
			
			tag.prototype.onkeypress = function (e){
				if (this._awaitCombo) {
					this._awaitCombo = false;
					return e.halt();
				};
				
				e.halt();
				var text = String.fromCharCode(e.event().charCode);
				e._text = text;
				e.cancel();
				this.ontype(e);
				return this;
			};
			
			tag.prototype.ontextinput = function (e){
				e.halt().cancel();
				e._text = e.event().data;
				this.ontype(e);
				return this;
			};
			
			tag.prototype.onkeyup = function (e){
				e.halt();
				return this;
			};
			
			tag.prototype.oninput = function (e){
				e.halt();
				return this;
			};
			
			tag.prototype.ontype = function (e){
				try {
					var ins = e._text;
					// log 'ontype',e,ins
					
					var spans = this.view().nodesInRegion(this.caret().region(),false,true);
					var target = spans[0];
					var cmd;
					
					if (spans.length == 1) {
						// log 'single node for nodesInRegion',target:node
						if (cmd = target.node[("trigger-" + ins)]) {
							// log "found combo for this!??!",cmd
							if (this.tryCommand(cmd,this.caret(),[target.node,target])) {
								return this;
							};
						};
					};
					
					cmd = this.shortcuts().getTrigger(this,ins);
					
					if (cmd && (cmd.command instanceof Function)) {
						// log 'found command!!',cmd
						// should rather run tryCommand?!?
						return cmd.command(this.caret(),this,ins,e);
					} else {
						if (ins) { return this.caret().insert(ins) };
					};
				} catch (e) {
					return this.log('error from ontype');
				};
			};
			
			tag.prototype.onbackspace = function (e){
				e.cancel().halt();
				this.caret().erase();
				return;
			};
			
			tag.prototype.onbeforecopy = function (e){
				if (true) { console.log('onbeforecopy',e) };
				this.input().select();
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				return e.halt();
			};
			
			tag.prototype.oncopy = function (e){
				if (true) { console.log('oncopy',e,this.caret().text()) };
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				e.halt().cancel();
				this.refocus();
				return;
			};
			
			tag.prototype.oncut = function (e){
				if (true) {
					console.log('oncut',e);
				};
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				e.halt().cancel();
				return this.caret().erase();
			};
			
			tag.prototype.onbeforepaste = function (e){
				return console.log('onbeforepaste',e);
			};
			
			tag.prototype.onpaste = function (e){
				console.log('onpaste',e);
				var data = e.event().clipboardData;
				var text = data.getData('text/plain');
				e.halt().cancel();
				this.caret().insert(text);
				this.refocus();
				return this.repair();
				// edit text: data
			};
			
			tag.prototype.refresh = function (){
				// focusNode = sel.node # only if it is inside the scope?
				// caret.region = sel.region
				this.caret().render();
				return this;
			};
			
			tag.prototype.exec = function (o){
				var fn = o.command;
				var args = o.args || [];
				var ev = new Imba.Event({type: 'command',target: this.dom(),data: o});
				ev.setData(o);
				ev.process();
				
				return;
			};
			
			tag.prototype.ontouchstart = function (touch){
				var ary;
				this._rect = this._body.dom().getBoundingClientRect();
				
				if (touch.button() != 0) { return };
				
				if (touch._touch) {
					// is it not redirected?
					return touch.redirect({});
				};
				
				var e = touch.event();
				e.preventDefault();
				// see if shift is down? should change behaviour
				var shift = e.shiftKey;
				// log 'ontouchstart',touch,touch.x,touch.y,e,touch.button
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				
				if (shift) {
					this.caret().selectable();
				} else {
					this.caret().collapse();
				};
				
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				// console.log 'touch start refocus?'
				this.refocus();
				return this;
			};
			
			tag.prototype.xyToRowCol = function (x,y){
				var col = Math.max(Math.round(x / this.charWidth()),0);
				var row = Math.max(Math.ceil(y / this.lineHeight()),1);
				return [row - 1,col];
			};
			
			tag.prototype.rcForTouch = function (touch){
				var x = Math.max(touch.x() - this._rect.left,0);
				var y = Math.max(touch.y() - this._rect.top,0);
				return this.xyToRowCol(x,y);
			};
			
			tag.prototype.ontouchupdate = function (touch){
				var ary;
				if (touch.button() != 0) { return };
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				this.caret().selectable();
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				return this;
			};
			
			tag.prototype.ontouchend = function (touch){
				var ary;
				if (touch.button() != 0) { return };
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				return this;
			};
			
			tag.prototype.erase = function (reg,edit){
				reg = Region.normalize(reg,this);
				
				var text = reg.text();
				this.history().onerase(reg,text,edit);
				
				var spans = this.nodesInRegion(reg,false,true);
				// gropu the nodes
				this.observer().pause(function() {
					if (spans.length > 1) {
						spans[1].node.setPrev(tag$.$iminsert().flag('dirty').end());
					} else if (spans[0] && spans[0].mode == 'all') {
						console.log('removing single node?!');
						var before = spans[0].node.prev();
						
						spans[0].node.setPrev(tag$.$iminsert().flag('dirty').end());
					};
					
					for (var i = 0, ary = iter$(spans), len = ary.length, sel, res = []; i < len; i++) {
						// buffer need to updated during this?
						sel = ary[i];
						res.push(sel.node.erase(sel.region,sel.mode,edit));
					};
					return res;
				});
				
				// delay('annotate',500) do annotate
				return this.erased(reg);
			};
			
			tag.prototype.inserted = function (loc,str){
				console.log('inserted',loc,str);
				var reg = new Region(loc,loc + str.length,null,this);
				for (var i = 0, ary = iter$(this.hints()), len = ary.length; i < len; i++) {
					ary[i].adjust(reg,true);
				};
				// hints.cleanup
				this.edited();
				if (util.isWhitespace(str)) this.repair();
				return this;
			};
			
			tag.prototype.erased = function (reg){
				for (var i = 0, ary = iter$(this.hints()), len = ary.length; i < len; i++) {
					ary[i].adjust(reg,false);
				};
				this.edited();
				return this.repair(); // repair synchronously
			};
			
			tag.prototype.insert = function (point,str,edit){
				if (point instanceof Region) {
					if (point.size() > 0) {
						this.logger().warn('uncollapsed region in insert is not allowed');
					};
					point = point.start();
				};
				
				this.log('insert',point,str);
				// should maybe create this as a command - and then make it happen?
				
				this.history().oninsert(point,str,edit);
				
				// log 'insert in view'
				var spans = this.nodesInRegion(Region.normalize(point,this),false);
				var mid = spans[0];
				var target = mid || spans.prev || spans.next;
				var lft = spans.lft,rgt = spans.rgt;
				var node;
				var reg;
				
				// log spans,mid,lft,rgt
				this.log('before and after',lft,rgt,str);
				
				if (mid) {
					this.log('insert mid',mid.node);
					mid.node.insert(mid.region,str,edit,mid);
				} else {
					
					while (rgt){
						if (rgt.canPrepend(str)) {
							this.log('prepend',rgt,str);
							rgt.insert('prepend',str,edit);
							return this.inserted(point,str);
						} else if (rgt.isFirst()) {
							rgt = rgt.parent();
							continue;
						};
						
						break;
					};
					
					// find the closest parent
					while (lft){
						if (lft.canAppend(str)) {
							this.log('append',lft,str);
							lft.insert('append',str,edit);
							return this.inserted(point,str);
						} else if (lft.isLast()) {
							lft = lft.parent();
							continue;
						};
						
						break;
					};
					
					node = tag$.$iminsert().end();
					
					if (lft) {
						lft.setNext(node);
					} else if (rgt) {
						rgt.setPrev(node);
					} else {
						// must be empty
						this.root().dom().appendChild(node.dom());
					};
					
					node.insert('append',str,edit);
				};
				
				return this.inserted(point,str);
			};
			
			tag.prototype.onmutations = function (){
				return this;
			};
			
			tag.prototype.repair = function (){
				this._dirty = false;
				var els = this.dom().getElementsByClassName('dirty');
				
				if (els.length) {
					// logger.log "{els:length} dirty nodes to repair"
					
					for (var muts = [], i = 0, ary = iter$(els), len = ary.length; i < len; i++) {
						muts.push(tag$wrap(ary[i]));
					};
					
					for (var i = 0, ary = iter$(muts), len = ary.length, mut; i < len; i++) {
						mut = ary[i];
						mut.unflag('dirty');
						mut.mutated(muts);
					};
				};
				return this;
			};
			
			tag.prototype.code = function (){
				return this._root.dom().textContent;
			};
			
			tag.prototype.focusNodeDidSet = function (new$,old){
				if (!this.root().contains(new$)) { return };
				
				var path = [];
				
				while (new$ && new$ != this.root()){
					path.push(new$);
					new$ = new$.parent();
				};
				
				q$('.focus_',this).map(function(n) {
					if (path.indexOf(n) < 0) { return n.unflag('focus_') };
				});
				
				for (var i = 0, len = path.length; i < len; i++) {
					path[i].flag('focus_');
				};
				return this;
			};
			
			
			tag.prototype.recompile = function (){
				// should happen in a separate thread - and be delayed
				console.log('recompile');
				var res;
				
				try {
					res = Imbac.compile(this.code(),{bare: true});
				} catch (e) { };
				
				if (res) {
					this.compiled(res);
				};
				return this;
			};
			
			tag.prototype.reparse = function (){
				this.log('reparse');
				this.root().rehighlight({inner: true});
				return this;
			};
			
			tag.prototype.compiled = function (res){
				return this;
			};
			
			tag.prototype.onrunerror = function (e){
				console.log('onrunerror',e);
				return this;
			};
			
			tag.prototype.addError = function (msg,loc){
				var node;
				var reg = Region.normalize(loc,this);
				console.log('found warnings',reg,msg,loc);
				if (node = this.nodeAtRegion(reg)) {
					this.log('node at region is?!',node);
					msg = msg.split(/error at (\[[\d\:]*\])\:\s*/).pop();
					node.flag('err');
					node.setAttribute('error',msg);
				};
				this.delay('annotate',-1);
				return this;
			};
			
			
			
			tag.prototype.annotate = function (){
				// console.log 'annotate'
				
				var self = this;
				var state = self.root().codeState();
				var code = state.code;
				
				var apply = function(meta) {
					var vars = [];
					for (var i = 0, ary = iter$(meta.scopes), len = ary.length; i < len; i++) {
						for (var j = 0, items = iter$(ary[i].vars), len_ = items.length; j < len_; j++) {
							vars.push(items[j]);
						};
					};
					
					var warnings = meta.warnings || [];
					var oldWarnings = self.hints().filter(function(hint) { return hint.group() == 'analysis'; });
					
					if (oldWarnings) {
						// could intelligently keep them instead
						self.hints().rem(oldWarnings);
					};
					
					for (var i = 0, ary = iter$(warnings), len = ary.length, warn; i < len; i++) {
						warn = ary[i];
						warn.type || (warn.type = 'error');
						warn.group = 'analysis';
						self.hints().add(warn).activate();
					};
					
					if (warnings.length) { return self };
					
					var nodes = IM.textNodes(self.root().dom(),true);
					// what about removing old warnings?
					
					var map = {};
					for (var i = 0, ary = iter$(nodes), len = ary.length, node; i < len; i++) {
						node = ary[i];
						map[node._loc] = node;
					};
					
					// get textNodes with mapping(!)
					for (var i1 = 0, len = vars.length; i1 < len; i1++) {
						for (var k = 0, ary = iter$(vars[i1].refs), len_ = ary.length, ref; k < len_; k++) {
							ref = ary[k];
							var a = ref.loc[0];
							var b = ref.loc[1];
							var eref = ("v" + i1);
							
							if (map[a]) {
								var dom = map[a].parentNode;
								var oldRef = dom.getAttribute('eref');
								// console.log 'setting the ref for node?',dom,dom.@tag
								tag$wrap(dom).setEref(eref);
								// if dom.@tag
								// 	dom.@tag.eref = eref
								// else
								// 	dom.setAttribute('eref',eref) unless oldRef == eref
								// 	dom:classList.add('lvar')
							};
						};
					};
					
					return;
				};
				
				try {
					
					console.time('analyze');
					IM.worker().analyze(code,{bare: true},function(res) {
						console.log('result from worker analyze');
						console.timeEnd('analyze');
						
						if (res.data) {
							console.time('annotate');
							apply(res.data);
							return console.timeEnd('annotate');
						};
					});
				} catch (e) {
					self.log('error from annotate',e);
				};
				
				return self;
			};
			
			tag.prototype.oncommand = function (e,c){
				if (this[c.command] instanceof Function) {
					this[c.command].call(this,c.args || []);
					e.halt();
				};
				return this;
			};
			
			tag.prototype.dumpState = function (o){
				if(o === undefined) o = {};
				return {
					html: this.root().dom().innerHTML,
					code: this.root().code(),
					selection: this.caret().region(),
					timestamp: new Date()
				};
			};
			
			tag.prototype.loadState = function (o){
				var self = this;
				if(o === undefined) o = {};
				self.observer().pause(function() {
					var v_;
					if (o.html) {
						self.root().dom().innerHTML = o.html;
					} else if (o.code) {
						self.load(o.code);
					};
					if (o.selection) {
						return (self.caret().setRegion(v_ = o.selection),v_);
					};
				});
				return self;
			};
			
			tag.prototype.loadSession = function (session){
				this.history().load(session);
				this.history().play();
				return this;
			};
			
			tag.prototype.textNodes = function (rel){
				if(rel === undefined) rel = this.root();
				return IM.textNodes(rel);
			};
			
			// Should be separate from the viewcode?
			tag.prototype.regionForNode = function (node,rel){
				if(rel === undefined) rel = this.root();
				var el = node._dom || node;
				var len = el.textContent.length;
				var rng = document.createRange();
				rng.setStart(rel._dom || rel,0);
				rng.setEnd(node._dom || node,0);
				var pre = rng.toString();
				return new Region(pre.length,pre.length + len,rel,this);
			};
			
			// Should merge with nodesInRegion
			tag.prototype.nodeAtRegion = function (region,exact){
				if(exact === undefined) exact = false;
				console.time('nodeAtRegion');
				var rel = this.root();
				var a = region.a();
				var b = region.b();
				
				var nodes = this.textNodes(rel);
				// move into region instead?
				var pos = 0;
				var match = null;
				var adist,bdist,str,len;
				
				for (var i = 0, ary = iter$(nodes), len_ = ary.length, node; i < len_; i++) {
					// console.log 'looking through nodes'
					node = ary[i];
					adist = a - pos;
					bdist = b - pos;
					str = node.textContent;
					len = str.length;
					
					if (adist >= 0 && adist < len) {
						// console.log 'found starting point?',node,str,adist
						match = node;
						break;
						// return tag(node:parentNode)
					};
					
					if (bdist >= 0 && bdist < len) {
						// console.log 'found ending point',node,str,bdist
						// range.setEnd(node,bdist)
						break;
					};
					
					
					pos += len;
				};
				
				var el = tag$wrap(match.parentNode);
				// we want to match the one that is full length
				if (exact && len < region.size()) {
					while (el){
						// be careful
						var elreg = el.region();
						if (region.equals(elreg)) { return el };
						el = el.parent();
					};
				};
				
				console.timeEnd('nodeAtRegion');
				return match ? (tag$wrap(match.parentNode)) : (null);
			};
			
			tag.prototype.nodesForEntity = function (ref){
				return q$('[eref="'+("" + ref)+'"]',this);
			};
			
			// does not need to belong to view directly
			tag.prototype.nodesInRegion = function (region,includeEnds,generalize){
				if(includeEnds === undefined) includeEnds = true;
				if(generalize === undefined) generalize = false;
				console.time('nodesInRegion');
				region = Region.normalize(region,this).normalize();
				var a = region.start();
				var b = region.end();
				
				// can be optimized by supplying the regions
				var nodes = IM.textNodes(region.root() || this.root());
				var matches = [];
				var match;
				var el;
				// move into region instead?
				matches.includeEnds = includeEnds;
				matches.region = region;
				
				var pos = 0;
				var ends = [];
				
				for (var i1 = 0, ary = iter$(nodes), len_ = ary.length, node; i1 < len_; i1++) {
					// console.log 'looking through nodes'
					node = ary[i1];
					var adist = a - pos;
					var bdist = b - pos;
					var str = node.textContent;
					var len = str.length;
					
					if ((pos + len) >= a && pos <= b) {
						el = tag$wrap(node.parentNode);
						var start = Math.max(0,a - pos);
						var end = Math.min(len,Math.max(b - pos,0));
						var par;
						
						match = {
							node: el,
							startOffset: start,
							endOffset: end,
							region: new Region(start,end,el,this),
							size: len
						};
						// log "node at {pos} + {len} - looking in range {a} - {b}"
						var mode = 'all';
						
						if (start == len) {
							mode = 'end';
						} else if (end == 0) {
							mode = 'start';
						} else if (start == 0 && end == len) {
							par = el.dom().parentNode;
							var isOpener = par != this._root.dom() && el.dom() == par.firstChild;
							var isCloser = par != this._root.dom() && el.dom() == par.lastChild;
							
							if (isOpener) {
								match.opens = el.parent();
								ends.push(match);
							};
							
							if (isCloser) {
								end = ends[ends.length - 1];
								if (end && end.opens == el.parent()) {
									end.closer = match;
									match.opener = end;
									ends.pop();
								};
								
								match.closes = el.parent();
							};
							
							mode = 'all';
						} else {
							mode = 'partial';
						};
						
						match.mode = mode;
						matches.push(match);
					};
					
					pos += len;
					if (pos > b) { break; };
				};
				
				var first = matches[0];
				var last = matches[matches.length - 1];
				
				if (first && first.mode == 'end') {
					matches.prev = first;
					matches.lft = first.node;
					
					// if first:node isa IM.Types:close
					// 	matches:lft = first:node.parent
					
					if (!includeEnds) { matches.shift() };
				};
				
				if (last && last.mode == 'start') {
					matches.next = last;
					matches.rgt = last.node;
					
					// if last:node isa IM.Types:open
					// 	matches:rgt = last:node.parent
					
					if (!includeEnds) { matches.pop() };
				};
				
				
				// normalize the nodes in groups
				if (generalize) {
					// console.log 'generalize!',matches
					var i = 0;
					var m;
					while (m = matches[i]){
						if (m.closer) {
							var idx = matches.indexOf(m.closer);
							len = m.opens.size();
							var new$ = {
								mode: 'all',
								region: new Region(0,len,m.opens,this),
								startOffset: 0,
								endOffset: len,
								node: m.opens
							};
							var rem = matches.splice(i,idx - i + 1,new$);
							new$.children = rem;
							// console.log 'slice away the items'
						};
						i++;
					};
				};
				
				console.timeEnd('nodesInRegion');
				return matches;
			};
			
			// should move to Buffer class
			tag.prototype.linecount = function (){
				return this.buffer().linecount();
				// buffer.split('\n')[:length]
			};
			
			// Returns the contents of the region as a string.
			// Returns the character to the right of the point.
			tag.prototype.substr = function (region,len){
				return this.buffer().substr(region,len);
			};
			
			// move into Buffer
			tag.prototype.linestr = function (nr){
				return this.buffer().line(nr);
				// if nr isa Number
				// 	buffer.split('\n')[nr] or ''
			};
			
			tag.prototype.expandRegionTo = function (region,match,forward){
				if(forward === undefined) forward = true;
				var buf = this.buffer().toString();
				var pos = region.start();
				var end = region.end();
				
				if (forward) {
					while (buf[end + 1] != match){
						end++;
					};
				} else {
					while (buf[pos - 1] != match){
						pos--;
					};
				};
				
				return new Region(pos,end,this);
			};
		});
		
		
		return VIEW = null;
	
	})()

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var Region = __webpack_require__(27).Region;
		
		function Buffer(view){
			this._view = view;
			this._buffer = '';
			this._cache = {};
			this;
		};
		
		exports.Buffer = Buffer; // export class 
		
		
		Buffer.prototype.view = function(v){ return this._view; }
		Buffer.prototype.setView = function(v){ this._view = v; return this; };
		
		Buffer.prototype.set = function (buffer){
			if (buffer == this._buffer) {
				return this;
			};
			
			this._buffer = buffer;
			this._cache = {};
			this._lines = null;
			return this;
		};
		
		Buffer.prototype.refresh = function (){
			return this.set(this.view().root().code());
		};
		
		Buffer.prototype.lines = function (){
			return this._lines || (this._lines = (true) && (
				this._buffer.split('\n')
			));
		};
		
		Buffer.prototype.split = function (){
			return this._buffer.split.apply(this._buffer,arguments);
		};
		
		Buffer.prototype.linecount = function (){
			return this.lines().length;
		};
		
		Buffer.prototype.line = function (nr){
			if ((typeof nr=='number'||nr instanceof Number)) {
				return this.lines()[nr] || '';
			} else {
				return '';
			};
		};
		
		Buffer.prototype.len = function (){
			return this._buffer.length;
		};
		
		// location to 
		Buffer.prototype.locToRc = function (){
			return this;
		};
		
		Buffer.prototype.location = function (){
			return this;
		};
		
		Buffer.prototype.locToRow = function (loc){
			var ln = 0;
			var len = 0;
			for (var i = 0, ary = iter$(this.lines()), len_ = ary.length; i < len_; i++) {
				len += ary[i].length + 1;
				if (loc < len) { return i };
			};
			return this.lines().length;
		};
		
		Buffer.prototype.locToCell = function (loc){
			if (this._cache[loc]) {
				return this._cache[loc];
			};
			
			var pos = loc;
			var col = 0;
			var row = 0;
			var char$;
			
			var buf = this._buffer;
			var tabsize = this._view.tabSize();
			
			// go back to start of line
			// goes through the whole
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					break;
				};
				pos--;
			};
			
			// get column for slice
			while ((pos < loc) && (char$ = buf[pos])){
				if (char$ == '\t') {
					var rest = tabsize - (col % tabsize);
					col += rest;
				} else {
					col += 1;
				};
				pos++;
			};
			
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					row++;
				};
				pos--;
			};
			
			return this._cache[loc] = [row,col];
		};
		
		Buffer.prototype.substr = function (region,len){
			if (region instanceof Region) {
				return this._buffer.substr(region.start(),region.size());
			} else if ((typeof region=='number'||region instanceof Number)) {
				return this._buffer.substr(region,len || 1);
			} else {
				throw 'must be region or number';
			};
		};
		
		Buffer.prototype.toString = function (){
			return this._buffer || '';
		};
		return Buffer;
	
	})()

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var util = __webpack_require__(34);
		
		function Observer(view,cfg){
			var self = this;
			self._active = false;
			self._view = view;
			self._config = cfg || {attributes: false,childList: true,characterData: true,subtree: true};
			self._observer = new MutationObserver(function(muts) { return self.onmutations(muts); });
			self;
		};
		
		exports.Observer = Observer; // export class 
		
		
		Observer.prototype.view = function(v){ return this._view; }
		Observer.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Observer.prototype.config = function(v){ return this._config; }
		Observer.prototype.setConfig = function(v){ this._config = v; return this; };
		
		
		Observer.prototype.active = function(v){ return this._active; }
		Observer.prototype.setActive = function(v){ this._active = v; return this; };
		
		Observer.prototype.resume = function (){
			if (!this._active) {
				this._observer.observe(this.view().root().dom(),this.config());
				this._active = true;
			};
			return this;
		};
		
		Observer.prototype.pause = function (blk){
			var wasActive = this._active;
			this._active = false;
			if (wasActive) { this._observer.disconnect() };
			
			if (blk instanceof Function) {
				blk();
				if (wasActive) this.resume();
			};
			
			return this;
		};
		
		Observer.prototype.paused = function (){
			return !this._active;
		};
		
		Observer.prototype.onmutations = function (mutations){
			var el;
			this.view().logger().group('mutations');
			
			var deep = false;
			var nodes = [];
			for (var i = 0, ary = iter$(mutations), len = ary.length, mut; i < len; i++) {
				mut = ary[i];
				this.view().log('mutation',mut);
				var type = mut.type;
				var target = mut.previousSibling || mut.target;
				
				if (type == 'characterData') {
					this.view().log(("updated code to " + (target.textContent)));
					target = target.parentNode;
				} else if (type == 'childList') {
					deep = true;
					var add = mut.addedNodes;
					if (add.length == 1 && (add[0] instanceof Element)) {
						target = add[0];
					};
				};
				
				this.view().log(target,tag$wrap(target));
				// var added = mut:addedNodes
				// for node in mut:addedNodes
				// if target and target:parentNode # and target.@tag
				if (el = tag$wrap(target)) {
					this.view().log('add target?!');
					if (nodes.indexOf(el) < 0) { nodes.push(el) };
				};
				
				// if we have added a node instead
			};
			
			// mutations are not registered on node-level but on extent
			// not really how this should happen
			
			var common = util.commonAncestor(nodes);
			
			this.view().log('common container for mutations is',common,nodes);
			
			var extent;
			
			if (nodes.length == 1) {
				this.view().log('a single node was mutated',nodes[0]);
				nodes[0].mutated({deep: deep,mutations: mutations});
			} else {
				// collect extents for all nodes?
				// rather make a region expand 
				for (var i = 0, len = nodes.length, node; i < len; i++) {
					node = nodes[i];
					if (extent && extent.contains(node.dom())) { // :nodes.indexOf(node.dom) >= 0
						this.view().log('this node is already part of the extent',node.dom());
					} else {
						extent = node.dirtyExtent();
					};
					// node?.mutated
				};
				
				if (extent) {
					// console.log 'found extent(!)',extent
					this.pause(function() { return true; });
				};
			};
			
			this.view().logger().groupEnd();
			this.view().onmutations({nodes: nodes,mutations: mutations,extent: extent});
			return this;
		};
		return Observer;
		
	
	})()

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Region = __webpack_require__(27).Region;
		
		var labels = {
			"Unexpected 'TAG_END'": 'Tag closed unexpectedly',
			"Unexpected 'TERMINATOR'": 'Unexpected ',
			"Unexpected 'POST_IF'": 'Missing body in <b>IF</b>'
		};
		
		var rules = [
			[/Uncaught Error: tag (\w+) is not defined/,"tag <b>$1</b> does not exist"]
		];
		
		function Hint(opts,view){
			this._view = view;
			this._data = opts;
			this._active = false;
			this._region = opts.loc ? (Region.normalize(opts.loc,view)) : (null);
			// try to find the node immediately
			this._node = opts.node || this.node();
			this;
		};
		
		exports.Hint = Hint; // export class 
		Hint.build = function (o,view){
			return new this(o,view);
		};
		
		
		
		Hint.prototype.view = function(v){ return this._view; }
		Hint.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Hint.prototype.region = function(v){ return this._region; }
		Hint.prototype.setRegion = function(v){ this._region = v; return this; };
		
		
		Hint.prototype.active = function(v){ return this._active; }
		Hint.prototype.setActive = function(v){ this._active = v; return this; };
		
		Hint.prototype.getAttribute = function (key){
			return this._data[key];
		};
		
		Hint.prototype.setAttribute = function (key,val){
			this._data[key] = val;
			return this;
		};
		
		Hint.prototype.type = function (){
			return this._data.type || 'error';
		};
		
		Hint.prototype.group = function (){
			return this._data.group;
		};
		
		Hint.prototype.ref = function (){
			return this._data.ref;
		};
		
		Hint.prototype.node = function (){
			return this._node || (this._node = this._region && this.view().nodeAtRegion(this._region));
		};
		
		Hint.prototype.row = function (){
			return this.region().row();
		};
		
		Hint.prototype.col = function (){
			return this.region().col();
		};
		
		Hint.prototype.label = function (){
			var lbl;
			return this._label || (this._label = (true) && (
				lbl = this._data.label || this._data.message || 'Hint',
				lbl = lbl.split(/error at (\[[\d\:]*\])\:\s*/).pop(),
				lbl = labels[lbl] || lbl
			));
		};
		
		
		Hint.prototype.activate = function (){
			var node_;
			if (!this._active) {
				// node?.setAttribute('hint',ref)
				this._active = true;
				(node_ = this.node()) && node_.setHint  &&  node_.setHint(this);
			};
			return this;
		};
		
		Hint.prototype.deactivate = function (){
			console.log('deactivate hint!!');
			this.setActive(false);
			return this;
			// cleanup
			// remove
		};
		
		Hint.prototype.prune = function (){
			return this.view().hints().prune(this);
		};
		
		// should make this hint ready to be removed
		Hint.prototype.cleanup = function (){
			if (this._node) {
				if (this._node.hint() == this) { this._node.setHint(null) };
			};
			return this;
		};
		
		Hint.prototype.remove = function (){
			this.view().hints().rem(this);
			return this;
		};
		
		Hint.prototype.changed = function (){
			// console.log 'deactivate on changed!'
			// @deactivate = yes
			this.prune();
			return this;
		};
		
		Hint.prototype.adjust = function (reg,ins){
			if(ins === undefined) ins = true;
			if (this.region().intersects(reg)) {
				// deactivate
				this.prune();
				// @deactivate = yes
			};
			
			this.region().adjust(reg,ins);
			return this;
		};
		
		function Hints(view){
			this._prune = [];
			this._array = [];
			this._map = {};
			this._view = view;
		};
		
		exports.Hints = Hints; // export class 
		var nr = 0;
		
		Hints.prototype.toArray = function (){
			return this._array;
		};
		
		Hints.prototype.get = function (ref){
			return this._map[ref];
		};
		
		Hints.prototype.activate = function (){
			for (var i = 0, ary = iter$(this._array), len = ary.length; i < len; i++) {
				ary[i].activate();
			};
			return this;
		};
		
		// this should take care of deallocating the hint no?
		Hints.prototype.rem = function (hint){
			if (hint instanceof Function) {
				hint = this._array.filter(hint);
			};
			
			if (hint instanceof Array) {
				for (var i = 0, ary = iter$(hint), len = ary.length; i < len; i++) {
					this.rem(ary[i]);
				};
				return hint;
			};
			
			if ((typeof hint=='string'||hint instanceof String)) {
				return this.rem(this.get(hint));
			};
			
			if (this._array.indexOf(hint) >= 0) {
				hint.cleanup();
				this._array.splice(this._array.indexOf(hint),1);
			};
			
			return hint;
		};
		
		Hints.prototype.prune = function (hint){
			if (this._prune.indexOf(hint) < 0) { this._prune.push(hint) };
			return this;
		};
		
		Hints.prototype.clear = function (){
			var arr = this._array;
			this._array = [];
			
			for (var i = 0, ary = iter$(arr), len = ary.length; i < len; i++) {
				ary[i].deactivate();
			};
			return this;
		};
		
		Hints.prototype.cleanup = function (){
			
			var self = this;
			self._array.map(function(item) {
				if (self._prune.indexOf(item) >= 0) {
					item.deactivate();
					return self.rem(item);
				};
			});
			self._prune = [];
			return self;
		};
		
		
		Hints.prototype.filter = function (cb){
			return this._array.filter(cb);
		};
		
		Hints.prototype.add = function (o){
			var ref = o.ref = ("hint" + (nr++));
			if (!((o instanceof Hint))) { o = Hint.build(o,this._view) };
			this._map[ref] = o;
			this._array.push(o);
			return o;
		};
		return Hints;
	
	})()

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var util = __webpack_require__(34);
		var Region = __webpack_require__(27).Region;
		
		function RowCol(row,col,caret){
			if(row === undefined) row = 0;
			if(col === undefined) col = 0;
			if(caret === undefined) caret = null;
			this._row = row;
			this._col = col;
			this._caret = caret;
			this;
		};
		
		
		
		RowCol.prototype.row = function(v){ return this._row; }
		RowCol.prototype.setRow = function(v){ this._row = v; return this; };
		
		
		RowCol.prototype.col = function(v){ return this._col; }
		RowCol.prototype.setCol = function(v){ this._col = v; return this; };
		
		
		RowCol.prototype.caret = function(v){ return this._caret; }
		RowCol.prototype.setCaret = function(v){ this._caret = v; return this; };
		
		RowCol.prototype.view = function (){
			return this.caret().view();
		};
		
		RowCol.prototype.normalize = function (){
			this._col = this.realCol();
			return this;
		};
		
		RowCol.prototype.set = function (row,col){
			var ary;
			if (row instanceof RowCol) {
				col = row.col();
				row = row.row();
				
				// return set(row.row,row.col)
			};
			
			if (row instanceof Region) {
				var ary = iter$(util.rowcol(this.view()._buffer,row.start()));row = ary[0];col = ary[1];
			};
			
			var lc = this.view()._buffer.linecount();
			
			if (row >= lc) {
				row = lc - 1;
				col = 1000;
			};
			
			this._row = row;
			this._col = col;
			return this;
		};
		
		
		RowCol.prototype.move = function (offset){
			this.normalize();
			
			var col = this.realCol() + offset;
			var llen = this.linelen();
			
			var lloc = this.lineloc();
			// find the real offset in characters (not columns)
			
			
			// if offset < 0
			// 	# normalize?
			// 	@col = Math.min(@col,llen)
			
			if (col < 0) {
				if (this._row > 0) {
					this.moveUp();
					this._col = this.linelen();
				} else {
					this._row = 0;
					this._col = 0;
				};
				return this;
			} else if (col > llen) {
				if (this._row >= (this.view()._buffer.linecount() - 1)) {
					return this;
				};
				
				this.moveDown();
				var rest = Math.max(0,col - llen - 1);
				var moves = util.colsForLine(this.linestr().substr(0,rest));
				this._col = moves;
				return this;
			};
			
			// this should work
			this._col = util.colsForLine(this.linestr().substr(0,lloc + offset));
			// @col += offset
			return this;
		};
		
		RowCol.prototype.moveUp = function (len){
			this._row = Math.max(0,this._row - 1);
			return this;
		};
		
		RowCol.prototype.moveDown = function (len){
			console.log('moveDown');
			var lc = this.view()._buffer.linecount(); // split('\n')[:length]
			this._row = this._row + 1;
			if (this._row >= lc) {
				console.log('out of bounds');
				this.setLoc(this.view()._buffer.len());
			};
			return this;
		};
		
		RowCol.prototype.clone = function (){
			return new RowCol(this.row(),this.col(),this.caret());
		};
		
		RowCol.prototype.linelen = function (){
			return util.colsForLine(this.linestr());
		};
		
		RowCol.prototype.lineloc = function (){
			return util.colToLoc(this.linestr(),this.realCol());
		};
		
		RowCol.prototype.realCol = function (){
			var rc = util.colToViewCol(this.linestr(),this._col);
			return rc;
		};
		
		RowCol.prototype.linestr = function (){
			return this.view().linestr(this.row());
		};
		
		RowCol.prototype.peekbehind = function (){
			var str = this.linestr();
			return str.substr(0,util.colToLoc(str,this.realCol()));
		};
		
		RowCol.prototype.peekahead = function (){
			var str = this.linestr();
			return str.slice(util.colToLoc(str,this.realCol()));
		};
		
		RowCol.prototype.setLoc = function (loc){
			var ary;
			var ary = iter$(util.rowcol(this.view()._buffer,loc));var row = ary[0],col = ary[1];
			this.set(row,col);
			return this;
		};
		
		RowCol.prototype.loc = function (){
			// should cache(!)
			var lines = this.view()._buffer.lines();
			// var lines = view.buffer.split('\n')
			var loc = 0;
			for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
				line = ary[i];
				var ln = line.length;
				if (i < this._row) {
					loc += ln + 1; // include newline
				} else if (i == this._row) {
					var viewcol = util.colToViewCol(line,this._col);
					var offset = util.colToLoc(line,viewcol);
					loc += Math.min(ln,offset);
				};
			};
			return loc;
		};
		
		RowCol.prototype.tab = function (){
			// wrong - need to round instead?
			
			var lft = this.col() % 4;
			this.setCol(this.col() + (4 - lft)); // Math.floor(col / 4) * 4 + 4
			console.log('marker tab',lft,this.col(),this.realCol());
			return this;
		};
		
		RowCol.prototype.untab = function (){
			console.log('untab',this.col());
			var rest = 4 - this.col() % 4;
			this.setCol(Math.ceil(this.col() / 4) * 4 - 4);
			return this;
		};
		
		RowCol.prototype.alter = function (mode,dir){
			var $1, $2, $3, $4, $5, $6;
			var nodes = this.caret().view().nodesInRegion(this.loc(),false);
			var node = nodes[0];
			var mid = node && node.node;
			var lft = nodes.prev && nodes.prev.node;
			var rgt = nodes.next && nodes.next.node;
			var part;
			
			// log 'move',offset,mode,nodes
			if (mode == IM.WORD_START) {
				var el = mid || lft;
				if (($1 = lft) && $1.matches  &&  $1.matches(q$('._imclose',this))) {
					this.setLoc(lft.parent().region().start());
				} else if (($2 = lft) && $2.matches  &&  $2.matches(q$('._imstr',this))) {
					this.setLoc(lft.region().start());
				} else {
					var loc = this.loc();
					// let buf = view.buffer
					// console.log 'peekbehind',peekbehind,loc,str
					var str = this.peekbehind().split('').reverse().join('');
					loc -= str.match(/^([\s\t\.]*.+?|)(\b|$)/)[1].length;
					this.setLoc(loc);
				};
			} else if (mode == IM.WORD_END) {
				el = mid || rgt;
				if (($3 = rgt) && $3.matches  &&  $3.matches(q$('._imopen',this))) {
					this.setLoc(rgt.parent().region().end());
				} else if (($4 = rgt) && $4.matches  &&  $4.matches(q$('._imstr',this))) {
					this.setLoc(rgt.region().end());
				} else {
					var loc1 = this.loc();
					// let buf = view.buffer
					
					
					// console.log 'peekahead',peekahead,loc
					loc1 += this.peekahead().match(/^([\s\.]*.+?|)(\b|$)/)[1].length;
					// loc++ until buf[loc].match(/[\n\]/)
					this.setLoc(loc1);
				};
			} else if (mode == IM.LINE_END) {
				this.set(this.row(),1000);
			} else if (mode == IM.LINE_START) {
				// FIXME tabs-for-spaces
				var tabs = this.linestr().match(/^\t*/)[0].length;
				var newcol = tabs * this.view().tabSize();
				this.setCol(this.col() > newcol ? (newcol) : (0));
			} else {
				if (dir < 0 && ($5 = lft) && $5.matches  &&  $5.matches('._imtab')) {
					// head.col = head.col - 4
					// caret.view.log 'right is tab',lft.region
					this.setLoc(lft.region().start());
					// head.untab
				} else if (dir > 0 && ($6 = rgt) && $6.matches  &&  $6.matches('._imtab')) {
					
					// use tab instead
					this.tab();
					// head.col = head.col + 4
				} else {
					// ...
					this.move(dir);
				};
			};
			
			return this;
		};
		
		tag$.defineTag('imcarethead');
		
		// should move into Marker (like Atom)
		return tag$.defineTag('imcaret', function(tag){
			
			
			
			tag.prototype.region = function(v){ return this._region; }
			tag.prototype.setRegion = function(v){ this._region = v; return this; };
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			
			tag.prototype.lines = function(v){ return this._lines; }
			tag.prototype.setLines = function(v){ this._lines = v; return this; };
			
			
			tag.prototype.ranges = function(v){ return this._ranges; }
			tag.prototype.setRanges = function(v){ this._ranges = v; return this; };
			
			tag.prototype.__mode = {watch: 'modeDidSet',name: 'mode'};
			tag.prototype.mode = function(v){ return this._mode; }
			tag.prototype.setMode = function(v){
				var a = this.mode();
				if(v != a) { this._mode = v; }
				if(v != a) { this.modeDidSet && this.modeDidSet(v,a,this.__mode) }
				return this;
			};
			
			tag.prototype.__col = {'default': 0,watch: 'dirty',name: 'col'};
			tag.prototype.col = function(v){ return this._col; }
			tag.prototype.setCol = function(v){
				var a = this.col();
				if(v != a) { this._col = v; }
				if(v != a) { this.dirty && this.dirty(v,a,this.__col) }
				return this;
			}
			tag.prototype._col = 0; // the real column of the caret
			
			tag.prototype.__row = {'default': 0,watch: 'dirty',name: 'row'};
			tag.prototype.row = function(v){ return this._row; }
			tag.prototype.setRow = function(v){
				var a = this.row();
				if(v != a) { this._row = v; }
				if(v != a) { this.dirty && this.dirty(v,a,this.__row) }
				return this;
			}
			tag.prototype._row = 0;
			
			
			tag.prototype.input = function(v){ return this._input; }
			tag.prototype.setInput = function(v){ this._input = v; return this; };
			
			
			
			tag.prototype.tail = function(v){ return this._tail; }
			tag.prototype.setTail = function(v){ this._tail = v; return this; }; // rowcol
			
			
			tag.prototype.head = function(v){ return this._head; }
			tag.prototype.setHead = function(v){ this._head = v; return this; };
			
			
			tag.prototype.hash = function(v){ return this._hash; }
			tag.prototype.setHash = function(v){ this._hash = v; return this; };
			
			tag.prototype.expand = function (lft,rgt){
				var ary;
				if(lft === undefined) lft = 0;
				if(rgt === undefined) rgt = 0;
				this.log('imcaret expand',lft,rgt);
				this.decollapse();
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				a.move(lft);
				b.move(rgt);
				return this;
			};
			
			tag.prototype.toArray = function (){
				if (this.isCollapsed()) {
					return [this.head().row(),this.head().col()];
				} else {
					return [this.head().row(),this.head().col(),this.tail().row(),this.tail().col()];
				};
			};
			
			tag.prototype.toHash = function (){
				return '[' + this.toArray().join(',') + ']';
			};
			
			tag.prototype.set = function (val){
				if (val instanceof IM.Types.Tok) {
					return this.set(val.region());
				};
				
				if (val instanceof Region) {
					return (this.setRegion(val),val);
				};
				
				if (val instanceof Array) {
					this.head().setRow(val[0]);
					this.head().setCol(val[1]);
					
					if (val.length == 4) {
						this.decollapse();
						this.tail().setRow(val[2]);
						this.tail().setCol(val[3]);
					} else {
						this.setTail(this.head());
					};
				};
				this.dirty();
				return this;
			};
			
			tag.prototype.expandToLines = function (){
				var ary;
				this.selectable();
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				a.setCol(0);
				b.setCol(1000);
				return this.dirty();
			};
			
			tag.prototype.selectAll = function (){
				this.decollapse();
				this.tail().setLoc(0);
				this.head().setLoc(this.view()._buffer.len()); // :length
				this.dirty();
				return this;
			};
			
			tag.prototype.selectable = function (){
				this.decollapse();
				return this;
			};
			
			tag.prototype.decollapse = function (){
				var v_;
				if (this.tail() == this.head()) { (this.setTail(v_ = this.head().clone()),v_) };
				return this;
			};
			
			tag.prototype.collapse = function (){
				this.setTail(this.head());
				this.dirty();
				return this;
			};
			
			tag.prototype.collapseToStart = function (){
				if (this.isReversed()) {
					this.setTail(this.head());
				} else {
					this.setHead(this.tail());
				};
				this.dirty();
				return this;
			};
			
			tag.prototype.orientation = function (){
				return this.isReversed() ? ('reversed') : ('normal');
			};
			
			tag.prototype.isCollapsed = function (){
				return this.tail() == this.head();
			};
			
			tag.prototype.isReversed = function (){
				return this.head().row() < this.tail().row() || (this.tail().row() == this.head().row() && this.head().col() < this.tail().col());
			};
			
			tag.prototype.indent = function (){
				var str = this.head().linestr();
				var ind = str.match(/^(\t*)/)[0];
				return ind;
			};
			
			tag.prototype.peekbehind = function (val){
				var str = this.ends()[0].peekbehind();
				if (val instanceof RegExp) { return str.match(val) };
				return str;
			};
			
			tag.prototype.move = function (offset,mode){
				if(offset === undefined) offset = 1;
				if(mode === undefined) mode = 0;
				this.head().alter(mode,offset);
				return this.dirty();
			};
			
			// what if we 
			tag.prototype.moveDown = function (len){
				if(len === undefined) len = 1;
				this.head().moveDown();
				return this.dirty();
			};
			
			tag.prototype.moveUp = function (len){
				if(len === undefined) len = 1;
				this.head().moveUp();
				return this.dirty();
			};
			
			tag.prototype.ends = function (){
				return this.isReversed() ? ([this.head(),this.tail()]) : ([this.tail(),this.head()]);
			};
			
			tag.prototype.text = function (){
				return this.region().text();
			};
			
			tag.prototype.region = function (){
				// get the actual region based on head and tail
				// getting the code might be expensive if done
				// too many times -- but easy to cache
				// send this to util instead
				var ary;
				var code = this.view().code();
				var lines = code.split('\n');
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				
				var start = 0;
				var end = 0;
				var ln = 0;
				
				var ar = a.row(),ac = a.col(),br = b.row(),bc = b.col();
				var char$;
				
				for (var i = 0, items = iter$(lines), len = items.length, line; i < len; i++) {
					line = items[i];
					ln = line.length;
					if (i < ar) {
						start += ln + 1; // include newline
					} else if (i == ar) {
						var offset = util.colToLoc(line,ac);
						start += Math.min(ln,offset);
					};
					
					if (i < br) {
						end += ln + 1; // include newline
					} else if (i == br) {
						offset = util.colToLoc(line,bc);
						end += Math.min(ln,offset);
					} else {
						break;
					};
				};
				
				return new Region(start,end,this.view().root(),this.view());
			};
			
			tag.prototype.setRegion = function (reg){
				var buf = this.view().code();
				var a = util.rowcol(buf,reg.a());
				var b = util.rowcol(buf,reg.b());
				
				this.setHead(new RowCol(b[0],b[1],this));
				
				if (reg.size() == 0) {
					this.setTail(this.head());
				} else {
					this.setTail(new RowCol(a[0],a[1],this));
				};
				return this.dirty();
			};
			
			tag.prototype.nodes = function (reg){
				if(reg === undefined) reg = this.region();
				return this.view().nodesInRegion(reg,this.isCollapsed());
			};
			
			// should rather move this to region itself
			tag.prototype.target = function (reg){
				if(reg === undefined) reg = this.region();
				var nodes = this.nodes(reg);
				if (nodes.length > 2) {
					return util.commonAncestor(nodes.map(function(n) { return n.node; }));
				};
				return nodes[0].node;
			};
			
			tag.prototype.insert = function (text,edit){
				
				var sub = '';
				this.view().history().mark('action');
				
				if (!(this.isCollapsed())) {
					var reg = this.region();
					sub = reg.text();
					this.view().erase(reg);
					this.collapseToStart();
				};
				
				var move = 0;
				var sel;
				
				// need a different syntax for $0 -- can be in regular pasted code
				// should have a separate command for insertSnippet probably.
				if (text.indexOf('$0') >= 0) {
					sel = this.region().clone(0,sub.length).move(text.indexOf('$0'));
					text = text.replace('$0',sub);
				};
				
				edit || (edit = {size: text.length});
				
				this.head().normalize();
				var res = this.view().insert(this.region().start(),text,edit);
				this.view().log('inserted -- now move',edit.size);
				
				if (sel) {
					this.setRegion(sel);
				} else {
					// move locations
					this.head().setLoc(this.head().loc() + edit.size);
					// head.move(edit:size)
				};
				
				this.dirty();
				
				return this;
			};
			
			
			tag.prototype.erase = function (mode){
				this.view().history().mark('action');
				
				if (this.isCollapsed()) {
					this.log('isCollapsed',mode);
					this.decollapse();
					this.head().alter(mode,-1); // 
					
					// dirty
					// return erase # call again now
				};
				console.log('erasing region',this.region());
				this.view().erase(this.region());
				// log 'now collapse region to start',region
				this.collapseToStart();
				// log region
				return this;
				
				var target = this.target(this.reg());
				this.setRegion(this.reg());
				
				return this.view().edit(
					{text: '',
					target: target,
					region: this.reg(),
					caret: this.reg().clone().collapse(false)}
				);
			};
			
			tag.prototype.dirty = function (){
				var $1, $2;
				this._timestamp = new Date();
				// var hash = toArray.join("")
				
				if (this._hash != this.toHash()) {
					// the realCol values could have changed though?
					this.view().history().oncaret(this._hash,this.toHash(),this);
					this._hash = this.toHash();
					// console.log 'caret has actually changed',@hash
				};
				
				var rev = this.isReversed();
				var a = this.tail();
				var b = this.head();
				
				if (rev) { $1 = b,$2 = a,a = $1,b = $2 };
				
				var lc = b.row() - a.row();
				var row = a.row();
				
				var ac = a.realCol(); // Math.min( a.col, util.colsForLine(view.linestr(a.row) ) )
				var bc = b.realCol(); // Math.min( b.col, util.colsForLine(view.linestr(b.row) ) )
				var hc,tc;
				
				if (this.isReversed()) {
					hc = ac;
					tc = bc;
				} else {
					hc = bc;
					tc = ac;
				};
				
				// log 'dirty',region,a.row,a.col,b.row,b.col,hc,tc,head,tail,rev
				
				this.css({transform: ("translate(0px," + (a.row() * 100) + "%)")});
				// convert the row and column to a region (should go both ways)
				this._caret.css({transform: ("translate(" + hc + "ch," + ((this.head().row() - row) * 100) + "%)")});
				this._start.css({marginLeft: ("" + ac + "ch"),width: "auto"});
				this._end.css({width: ("" + bc + "ch")});
				
				if (this.isCollapsed()) {
					this.setMode('collapsed');
				} else if (lc == 0) {
					this.setMode('single');
					this._start.css({width: (bc - ac) + "ch"});
				} else {
					this._mid.setText(lc > 1 ? (('\n').repeat(lc - 1)) : (''));
					this.setMode('multi');
				};
				return this;
			};
			
			tag.prototype.render = function (){
				var elapsed = (new Date() - this._timestamp);
				var flip = Math.round(elapsed / 500) % 2;
				
				if (flip != this._flip) {
					this._caret.flag('blink',flip);
					this._flip = flip;
				};
				
				return this;
			};
			
			tag.prototype.build = function (){
				var v_, t0;
				this.setTail((this.setHead(v_ = new RowCol(0,0,this)),v_));
				
				return this.setChildren([
					// <imcaptor@input value='x'>
					(this.$a = this.$a || tag$.$span().flag('dim')).setText('x').end(),
					(this._caret = this._caret || tag$.$imcarethead().setRef('caret',this)).end(),
					(t0 = this._lines=this._lines || tag$.$div().setRef('lines',this)).setContent([
						(this._start = this._start || tag$.$div().setRef('start',this)).setText(" ").end(),
						(this._mid = this._mid || tag$.$div().setRef('mid',this)).end(),
						(this._end = this._end || tag$.$div().setRef('end',this)).setText(" ").end()
					],2).end()
				],2).synced();
			};
			
			tag.prototype.normalize = function (){
				this.head().normalize();
				return this;
			};
			
			tag.prototype.modeDidSet = function (new$,old){
				this.unflag(old);
				return this.flag(new$);
			};
		});
	
	})()

/***/ },
/* 44 */
/***/ function(module, exports) {

	(function(){
		
		tag$.defineTag('scrimbla-overlay', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				return this.setChildren(JSON.stringify(this.object()),3).synced();
			};
		});
		
		return tag$.defineTag('scrimbla-overlays', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.add = function (type,data){
				if(data === undefined) data = {};
				console.log('add overlay!');
				this.append(tag$.$scrimbla_overlay().setView(this.view()).setObject(data).end());
				return this;
			};
			
			tag.prototype.reposition = function (){
				return this;
			};
		});
	
	})()

/***/ },
/* 45 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('imeditor', function(tag){
			
			tag.prototype.build = function (){
				this.render();
				return this;
			};
			
			tag.prototype.render = function (){
				return this.setChildren(
					(this._view = this._view || tag$.$imview().setRef('view',this)).end()
				,2).synced();
			};
			
			tag.prototype.view = function (){
				return this._view;
			};
			
			tag.prototype.activate = function (){
				this.view().activate();
				return this;
			};
			
			tag.prototype.deactivate = function (){
				this.view().deactivate();
				return this;
			};
			
			tag.prototype.load = function (code,opts){
				this.view().load(code,opts);
				return this;
			};
			
			tag.prototype.fs = function (){
				return IM.FS;
			};
			
			tag.prototype.oncommand = function (e,c){
				if (this[c.command] instanceof Function) {
					this[c.command].call(this,c.args || []);
					e.halt();
				};
				return this;
			};
			
			tag.prototype.onsavesession = function (){
				console.log("imeditor.saveSession",this);
				var path = this.view().filename().replace(/\.imba$/,'.imbasession');
				var body = JSON.stringify(this.view().history());
				
				return IM.FS.save(path,body,function() {
					return console.log('returned from saving!',path);
				});
			};
		});
	
	})()

/***/ },
/* 46 */
/***/ function(module, exports) {

	(function(){
		
		/*
		Bridge for communicating with the Imba compiler in a worker
		*/
		
		function ImbacWorker(path){
			if(path === undefined) path = "/vendor/imba/imbac.worker.min.js";
			this._path = path;
			this._callbacks = [];
			this;
		};
		
		exports.ImbacWorker = ImbacWorker; // export class 
		ImbacWorker.prototype.worker = function (){
			var self = this, process1;
			return self._worker || (self._worker = (true) && (
				process1 = new Worker(self._path),
				process1.onmessage = function(e) { return self.onmessage(e); },
				process1
			));
		};
		
		ImbacWorker.prototype.onmessage = function (e){
			var fn;
			if (fn = this._callbacks.shift()) {
				return fn(e.data,e);
			};
		};
		
		ImbacWorker.prototype.compile = function (code,o,cb){
			this._callbacks.push(cb);
			this.worker().postMessage(['compile',code,o]);
			return this;
		};
		
		ImbacWorker.prototype.analyze = function (code,o,cb){
			this._callbacks.push(cb);
			this.worker().postMessage(['analyze',code,o]);
			return this;
		};
		return ImbacWorker;
	
	})()

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		__webpack_require__(48);
		__webpack_require__(49);
		__webpack_require__(50);
		__webpack_require__(51);
		__webpack_require__(52);
		__webpack_require__(53);
		__webpack_require__(54);
		__webpack_require__(55);
		return __webpack_require__(56);
	
	})()

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Highlighter = __webpack_require__(29).Highlighter;
		var util = __webpack_require__(34);
		
		// dangerous to extend all htmlelement tags globally
		tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.bubble = function (name,data){
				// log "bubble event",name,data
				var ev = Imba.Events.trigger(name,this,{data: data,bubble: true});
				return ev;
			};
			
			tag.prototype.delay = function (name,time,blk){
				this._timeouts || (this._timeouts = {});
				clearTimeout(this._timeouts[name]);
				if (time != -1) { this._timeouts[name] = setTimeout(blk,time) };
				return this;
			};
			
			tag.prototype.setNext = function (el){
				if (el instanceof IMFragment) {
					el = Array.prototype.slice.call(el.dom().childNodes);
				};
				
				if (el instanceof Array) {
					for (var i = 0, ary = iter$(el.reverse()), len = ary.length; i < len; i++) {
						this.setNext(ary[i]);
					};
					return this;
				};
				
				var curr = this.dom().nextSibling;
				if ((typeof el=='string'||el instanceof String)) {
					el = document.createTextNode(el);
				};
				
				if (curr) {
					this.parent().insertBefore(el,curr);
				} else {
					this.parent().appendChild(el);
				};
				
				return el;
			};
			
			tag.prototype.setPrev = function (el){
				if (el instanceof IMFragment) {
					el = Array.prototype.slice.call(el.dom().childNodes);
					// el = [].concat(el.dom:childNodes)
				};
				
				if (el instanceof Array) {
					for (var i = 0, ary = iter$(el), len = ary.length; i < len; i++) {
						this.setPrev(ary[i]);
					};
					return this;
				};
				
				var curr = this.dom().prevSibling;
				if ((typeof el=='string'||el instanceof String)) {
					el = document.createTextNode(el);
				};
				this.parent().insertBefore(el,this);
				// parent.insert(el, before: self)
				return el;
			};
			
			tag.prototype.nextNode = function (){
				return this.dom().nextSibling;
			};
			
			tag.prototype.prevNode = function (){
				return this.dom().prevSibling;
			};
		});
		
		IM.Types = {};
		
		tag$.defineTag('im', 'b', function(tag){
			
			tag.key = function (key,handler){
				this.prototype[("handle" + key)] = handler;
				return this;
			};
			
			tag.native = function (typ){
				this._nativeType = typ;
				return this;
			};
			
			tag.type = function (typ){
				IM.Types[typ] = this;
				this._type = typ;
				this.prototype._type = typ;
				// @domFlags.push(typ) if @domFlags
				return this;
			};
			
			tag.type('Tok');
			
			tag.alias = function (typ){
				IM.Types[typ] = this;
				return this;
			};
			
			tag.trigger = function (match,cmd){
				if (cmd instanceof Function) {
					cmd = {command: cmd};
				};
				
				cmd.trigger = match;
				return this.prototype[("trigger-" + match)] = cmd;
			};
			
			tag.prototype.setHint = function (hint){
				if (hint && hint != this._hint) {
					this.setAttribute('hint',hint.ref());
					this.setAttribute("hint-type",hint.type());
				} else {
					this.removeAttribute('hint');
					this.removeAttribute('hint-type');
				};
				return this._hint = hint;
			};
			
			tag.prototype.hint = function (){
				// strange no?		
				return this._hint || this.view().hints().get(this.getAttribute('hint'));
			};
			
			// go over to using this 
			tag.prototype.walkTextNodes = function (mark){
				if(mark === undefined) mark = false;
				this.setRoot(this.dom());
				var el;
				var nodes = [];
				var pos = 0;
				var walk = document.createTreeWalker(this.root(),NodeFilter.SHOW_TEXT,null,false);
				
				while (el = walk.nextNode()){
					if (mark) {
						var len = el.length;
						el._loc = pos;
						pos += len;
					};
					nodes.push(el);
				};
				
				return nodes;
			};
			
			
			tag.prototype.util = function (){
				return util;
			};
			
			tag.prototype.select = function (){
				return this.view().caret().set(this.region());
			};
			
			tag.prototype.canPrepend = function (text){
				return false;
			};
			
			tag.prototype.canAppend = function (text){
				return false;
			};
			
			tag.prototype.log = function (){
				var logger_;
				(logger_ = this.view().logger()).log.apply(logger_,arguments);
				return this;
			};
			
			tag.prototype.toString = function (){
				return this.dom().outerHTML;
			};
			
			tag.prototype.spaced = function (){
				if (this.dom().nextSibling instanceof Text) {
					return (/[\t ]/).test(this.dom().nextSibling.textContent[0]);
				};
				return false;
			};
			
			tag.prototype.unspaced = function (){
				return !(this.spaced());
			};
			
			tag.prototype.nextImmediate = function (){
				// could be text as well?
				return this.dom().nextSibling instanceof Text ? (null) : (this.next());
			};
			
			tag.prototype.prevImmediate = function (){
				// could be text as well?
				return this.dom().previousSibling instanceof Text ? (null) : (this.prev());
			};
			
			tag.prototype.repair = function (){
				return this;
			};
			
			tag.prototype.text = function (){
				return this.dom().textContent;
			};
			
			tag.prototype.setText = function (text){
				this.dom().textContent = text;
				return this;
			};
			
			tag.prototype.code = function (){
				return this.dom().textContent;
			};
			
			tag.prototype.setCode = function (code,silent){
				var hint_;
				if(silent === undefined) silent = false;
				var prev = this.code();
				
				if (this._dom.firstChild == this._dom.lastChild && (this._dom.firstChild instanceof Text)) {
					// still set if it has not changed?
					this._dom.firstChild.textContent = code;
				} else {
					this._dom.textContent = code;
				};
				
				if (code != prev) {
					(hint_ = this.hint()) && hint_.changed  &&  hint_.changed();
					if (!silent) { this.onchanged(code,prev) };
				};
				return this;
			};
			
			tag.prototype.onchanged = function (code,prev){
				return this.flag('dirty');
			};
			
			tag.prototype.size = function (){
				return this.code().length;
			};
			
			tag.prototype.view = function (){
				var parent_;
				return this._view || ((parent_ = this.parent()) && parent_.view  &&  parent_.view()) || VIEW;
			};
			
			tag.prototype.sel = function (){
				return this.view().caret();
			};
			
			tag.prototype.region = function (){
				return this.view().regionForNode(this);
			};
			
			tag.prototype.loc = function (){
				return this.region().loc();
			};
			
			tag.prototype.load = function (){
				return this;
			};
			
			tag.prototype.decreaseIndent = function (pre,state){
				return false;
			};
			
			tag.prototype.increaseIndent = function (pre,state){
				var reg = /^(\s*(.*\=\s*)?(class|def|tag|unless|if|else|elif|switch|try|catch|finally|for|while|until|do))/;
				return reg.test(pre);
			};
			
			tag.prototype.erase = function (region,mode){
				if (mode == 'all') {
					this.orphanize();
				} else {
					this.setCode(util.patchString(this.code(),'',region)); // code.ins('',region)
				};
				return this;
			};
			
			tag.prototype.insert = function (region,str,edit,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var mode = pars.mode !== undefined ? pars.mode : null;
				this.setCode(util.patchString(this.code(),str,region));
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				return this;
			};
			
			tag.prototype.oncommand = function (e,cmd){
				var name = cmd.command;
				var fn = this[name];
				this.log('run oncommand',name,cmd);
				
				if (fn instanceof Function) {
					fn.call(this,e,cmd);
				};
				return this;
			};
			
			tag.prototype.indentBlock = function (e){
				this.log('im.indentBlock',arguments,this);
				return this;
			};
			
			tag.prototype.clone = function (val){
				return IM.tok(val).classify();
			};
			
			tag.prototype.validate = function (code){
				return false;
			};
			
			tag.prototype.isFirst = function (){
				var par = this.parent();
				return (par instanceof IM.Types.Tok) && par.dom().firstChild == this.dom();
			};
			
			tag.prototype.isLast = function (){
				var par = this.parent();
				return (par instanceof IM.Types.Tok) && par.dom().lastChild == this.dom();
			};
			
			tag.prototype.isValid = function (code){
				if(code === undefined) code = this.text();
				return this.validate(code);
			};
			
			tag.prototype.markInvalid = function (){
				this.flag('invalid');
				return this;
			};
			
			tag.prototype.markValid = function (){
				this.unflag('invalid');
				return this;
			};
			
			tag.prototype.isInvalid = function (){
				return this.hasFlag('invalid');
			};
			
			tag.prototype.classify = function (){
				return this;
			};
			
			// unwrap / remove this node from parent
			tag.prototype.unwrap = function (){
				var el = this.dom();
				var par = el.parentNode;
				
				while (el.firstChild){
					par.insertBefore(el.firstChild,el);
				};
				return this;
			};
			
			tag.prototype.replaceWith = function (other){
				this.setPrev(other);
				return this.orphanize();
			};
			
			tag.prototype.scope = function (){
				return this.closest(q$('._indent',this));
			};
			
			tag.prototype.mutated = function (muts){
				// remove node if it is orphanized
				var self = this;
				if (self.code() == '') {
					self.log('remove whole node');
					// should possibly
					return self.orphanize();
				} else {
					self.log('mutated -- reparse');
					return self.view().observer().pause(function() {
						return self.view().highlighter().reparse(self.dirtyExtent());
					});
				};
			};
			
			
			tag.prototype.reclassify = function (type){
				// reclassify should happen through the highlighter
				// log 'reclassify node as type',type
				var cls = IM.Types[type] || Imba.TAGS[("im" + type)];
				
				if (cls) {
					// log 'found class to reclassify as',cls,self:constructor
					if (cls == this.constructor) {
						return this;
					};
					
					// log 'found class to reclassify as',cls
					var node = new cls(this.dom()).setup();
					return node;
				};
				return this;
			};
			
			tag.prototype.reparsed = function (){
				return this;
			};
			
			tag.prototype.baseClasses = function (){
				var cls = this.constructor.dom().className;
				if (this._type) { cls += ' ' + this._type };
				return cls;
			};
			
			tag.prototype.setup = function (){
				this._dom.className = this.baseClasses();
				return this;
			};
			
			tag.prototype.reuse = function (){
				return this.setup.apply(this,arguments);
			};
			
			tag.prototype.isAtomic = function (){
				return false;
			};
			
			// find the nodes / region that should be reparsed if this element has changed
			// this is currently quote 
			
			tag.prototype.dirtyExtent = function (){
				// 3log "get dirty extent for",dom
				var self = this, sel, sel1, sel2, $1;
				if (sel = self.up(q$('.selector',self))) {
					return sel.dirtyExtent();
				} else if (sel1 = self.up(q$('._imtagnode',self))) {
					return sel1.dirtyExtent();
				} else if (sel2 = self.up(q$('._imistring',self))) {
					return sel2.dirtyExtent();
				};
				
				if (self.isAtomic()) { // hmm
					return {
						nodes: [self.dom()],
						code: self.code(),
						contains: function(el) { return self.dom().contains(el._dom || el); }
					};
				};
				
				var start = self.dom();
				var end = self.dom();
				
				var prev,next;
				var nodes = [self.dom()];
				var opener,closer;
				
				while (prev = start.previousSibling){
					if (prev instanceof Text) {
						break;
					} else if (prev.matches('._imnewline,._imtab')) { // ,._imopen,._imclose
						break;
					};
					
					if (prev.matches('._imopen')) {
						opener = prev;
					};
					
					start = prev;
					nodes.unshift(start);
				};
				
				while (next = end.nextSibling){
					if (next instanceof Text) {
						break;
					} else if (next.matches('._imnewline')) { // ._imopen,._imclose
						break;
					};
					
					if (next.matches('._imclose')) {
						closer = next;
					};
					
					end = next;
					nodes.push(end);
				};
				
				// see if we include an open or close-tag
				
				var result = {
					nodes: nodes,
					code: "",
					target: self.dom(),
					nested: [],
					contains: function(node) { return this.nodes.indexOf(node) >= 0; }
				};
				
				if (opener || closer) {
					// log "includes opener and / or closer",opener,closer
					var par = tag$wrap((opener || closer).parentNode);
					if (($1 = par) && $1.isAtomic  &&  $1.isAtomic()) {
						// log 'return the parent dirty extent',par
						return par.dirtyExtent();
					};
					
					for (var nodes = [], i = 0, ary = iter$((opener || closer).parentNode.children), len_ = ary.length; i < len_; i++) {
						nodes.push(ary[i]);
					};
				};
				
				var loc = 0;
				
				// should use the tags directly
				for (var i = 0, ary = iter$(nodes), len_ = ary.length, node; i < len_; i++) {
					node = ary[i];
					var rich = tag$wrap(node);
					var text = node.textContent;
					var len = text.length;
					
					if (false) {
						text = "''";
						len = 5;
						self.log("added node as nested reference",rich.dom());
						// this is fucked up
						// this really does mess up the rich nodes here(?!)
						result.nested.push(rich);
					};
					
					result.code += text;
					loc += len;
				};
				
				result.nodes = nodes;
				return result;
			};
			
			tag.prototype.reparseExtent = function (e){
				var self = this;
				return self.view().observer().pause(function() {
					var dirty = self.dirtyExtent();
					if (e) { e.handled() };
					return Highlighter.reparse(dirty);
				});
			};
		});
		
		
		// piece of unparsed code
		tag$.defineTag('imraw', 'im', function(tag){
			tag.type('raw');
			tag.alias('@');
			
			tag.prototype.setRaw = function (raw){
				this._raw = raw;
				this._dom.textContent = raw;
				return this;
			};
			
			tag.prototype.onedit = function (e){
				this.setCode(e.patch(this));
				return e.handled();
			};
		});
		
		tag$.defineTag('imfragment', 'imraw', function(tag){
			tag.type('fragment');
			
			tag.prototype.setContent = function (content){
				if (typeof content == 'string') {
					this.dom().innerHTML = content;
				} else {
					tag.__super__.setContent.apply(this,arguments);
				};
				return this;
			};
			
			tag.prototype.repair = function (){
				this.unwrap();
				this.orphanize();
				return this;
			};
		});
		
		IMFragment = Imba.TAGS.imfragment;
		
		tag$.defineTag('imopen', 'im', function(tag){
			
			// @nodeType = 's'
			tag.type('open');
			
			tag.alias('[');
			tag.alias('(');
			tag.alias('{');
			tag.alias('{{');
			tag.alias('index_start');
			tag.alias('block_param_start');
		});
		
		tag$.defineTag('imclose', 'im', function(tag){
			
			tag.type('close');
			// @nodeType = 's'
			
			tag.alias(']');
			tag.alias(')');
			tag.alias('}');
			tag.alias('}}');
			tag.alias('index_end');
			tag.alias('block_param_end');
		});
		
		tag$.defineTag('imrparen', 'imclose', function(tag){
			tag.type('rparen');
			tag.alias(')');
		});
		
		tag$.defineTag('imtagopen', 'imopen', function(tag){
			tag.type('tag_start');
		});
		
		tag$.defineTag('imtagclose', 'imclose', function(tag){
			tag.type('tag_end');
		});
		
		tag$.defineTag('imselopen', 'imopen', function(tag){
			tag.type('selector_start');
		});
		
		tag$.defineTag('imselclose', 'imclose', function(tag){
			tag.type('selector_end');
		});
		
		tag$.defineTag('imquote', 'im');
		
		tag$.defineTag('imsinglequote', 'imquote', function(tag){
			tag.type("'");
		});
		
		tag$.defineTag('imdoublequote', 'imquote', function(tag){
			tag.type('"');
		});
		
		tag$.defineTag('imstrstart', 'imopen', function(tag){
			tag.type('string_start');
		});
		
		return tag$.defineTag('imstrend', 'imclose', function(tag){
			tag.type('string_end');
		});
	
	})()

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		var Region = __webpack_require__(27).Region;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		
		var keywords = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil','extend','export','own'
		];
		
		// this is really the general token
		tag$.defineTag('imtok', 'im', function(tag){
			tag.alias('token');
			
			
			tag.prototype.__eref = {watch: 'erefDidSet',name: 'eref'};
			tag.prototype.eref = function(v){ return this.getAttribute('eref'); }
			tag.prototype.setEref = function(v){
				var a = this.eref();
				if(v != a) { this.setAttribute('eref',v); }
				if(v != a) { this.erefDidSet && this.erefDidSet(v,a,this.__eref) }
				return this;
			};
			
			tag.prototype.erefDidSet = function (new$,old){
				// experimental
				// console.log 'erefDidSet',new,old
				if (!(new$ && old)) { this.flag('lvar',!(!(new$))) };
				return this;
			};
			
			tag.prototype.isVarRef = function (){
				return this.hasFlag('lvar');
			};
			
			tag.prototype.clearVarRef = function (){
				this.setEref(null);
				return this;
			};
			
			tag.prototype.clone = function (val){
				return IM.tok(val);
			};
			
			tag.prototype.setText = function (text){
				tag.__super__.setText.call(this,text);
				this.classify();
				
				var typ = IM.identify(text);
				
				if (typ) {
					this.log('reclassifying imtok immediately');
					this.setCode(text);
					return this.reclassify(typ);
				};
				
				// return raw token if not classified?
				return this._typ ? (this) : (tag$.$imraw().setRaw(text).end());
			};
			
			tag.prototype.canPrepend = function (text){
				return true;
			};
			
			tag.prototype.canAppend = function (text){
				return true;
			};
			
			tag.prototype.classify = function (map){
				map || (map = IM.identify(this.code()));
				if (map) {
					if (!map.match(/\b_[\w]/)) { map = '_imtok ' + map };
					this.dom().className = map;
					this._typ = map;
				} else {
					this._typ = null;
				};
				return this;
			};
			
			tag.prototype.validate = function (code){
				return false;
			};
			
			tag.prototype.repair = function (){
				this.log('repair');
				this.classify();
				return this;
			};
			
			tag.prototype.split = function (region){
				region = Region.normalize(region);
				var lft = this.code().substring(0,region.start());
				var rgt = this.code().slice(region.end());
				
				this.setCode(lft);
				this.setNext(IM.tok(rgt));
				return this;
			};
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				var dirty = this.dirtyExtent();
				this.view().observer().pause(function() { return Highlighter.reparse(dirty); });
				return this;
			};
			
			tag.prototype.reuse = function (tok,new$,old){
				if (new$ == old) { return this };
				return tag.__super__.reuse.apply(this,arguments);
			};
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && this.validate(this.code())) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
			
			tag.prototype.ondblclick = function (e){
				e.halt();
				return this.select();
			};
			
			tag.prototype.onmouseover = function (e){
				e.halt();
				
				if (this.eref()) {
					return this.view().nodesForEntity(this.eref()).map(function(el) { return el.flag('hl'); });
				};
			};
			
			tag.prototype.onmouseout = function (e){
				e.halt();
				if (this.eref()) {
					return this.view().nodesForEntity(this.eref()).map(function(el) { return el.unflag('hl'); });
				};
			};
		});
		
		
		tag$.defineTag('imidentifier', 'imtok', function(tag){
			tag.type('identifier');
			
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			tag.prototype.validate = function (code){
				// regex for identifier
				return (/^[a-z](-?[\wA-Za-z_\-\x7f-\uffff\$]+)*$/).test(code) && keywords.indexOf(code) == -1;
			};
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'identifier setup',baseClasses
				var v_;
				if (tok && tok._value) { (this.setName(v_ = tok._value),v_) };
				this._dom.className = this.baseClasses();
				return this;
			};
			
			tag.prototype.mutated = function (){
				// console.log 'imidentifier mutated'
				this.setName(this.code());
				if (this.isVarRef()) {
					this.clearVarRef();
				};
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imtagtype', 'imtok', function(tag){
			tag.type('tag_type');
		});
		
		tag$.defineTag('imtagid', 'imtok', function(tag){
			tag.type('tag_id');
			tag.alias('idref');
		});
		
		tag$.defineTag('imconst', 'imtok', function(tag){
			tag.type('const');
			
			tag.prototype.validate = function (code){
				return (/^[A-Z](-?[\wA-Za-z_\-\x7f-\uffff\$]+)*$/).test(code);
			};
			
			// def onchanged code, prev
			// 	# console.log 'imconst onchanged',code,prev
			// 	flag('dirty') unless validate(code)
		});
		
		
		tag$.defineTag('imivar', 'imtok', function(tag){
			tag.type('ivar');
		});
		
		tag$.defineTag('imcvar', 'imtok', function(tag){
			tag.type('cvar');
		});
		
		tag$.defineTag('imkeyword', 'imtok', function(tag){
			tag.type('keyword');
			tag.alias('new');
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'setup imkeyword',tok, new, old
				var cls = this.baseClasses();
				if (tok && tok._value) { cls += ' ' + tok._value };
				this._dom.className = cls;
				return this;
			};
		});
		
		keywords.map(function(keyword) { return IM.Types[keyword] = IM.Types.keyword; });
		
		IM.Types.forin = IM.Types.keyword;
		IM.Types.forof = IM.Types.keyword;
		IM.Types.post_if = IM.Types.keyword;
		IM.Types.post_unless = IM.Types.keyword;
		IM.Types.post_for = IM.Types.keyword;
		IM.Types.post_while = IM.Types.keyword;
		
		tag$.defineTag('imnum', 'imtok', function(tag){
			tag.type('number');
			
			tag.prototype.validate = function (code){
				return (/^\d+(\.\d+)?$/).test(code);
			};
			
			tag.prototype.reuse = function (){
				return this;
			};
		});
		
		tag$.defineTag('imint', 'imnum', function(tag){
			tag.type('int');
		});
		
		tag$.defineTag('imfloat', 'imnum', function(tag){
			tag.type('float');
		});
		
		tag$.defineTag('imbool', 'imtok', function(tag){
			tag.type('bool');
			tag.alias('true');
			tag.alias('false');
		});
		
		// this should be more advanced - no
		tag$.defineTag('imstr', 'imtok', function(tag){
			tag.type('string');
			
			tag.prototype.quote = function (){
				return this.code()[0];
			};
			
			tag.prototype.setQuote = function (quote){
				this.setCode(quote + this.code().slice(1,-1) + quote);
				return this;
			};
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'setup string',tok, new, old
				this._dom.className = this.baseClasses();
				this.setCode(new$);
				return this;
			};
			
			tag.prototype.onunwrap = function (e){
				var v_;
				this.log('imstring onunwrap!!!',e);
				e.halt();
				// look at prev and next as well?
				// should do this through the view
				return (this.setCode(v_ = this.code().slice(1,-1)),v_);
			};
			
			tag.prototype.ondblclick = function (e){
				e.halt();
				return this.select();
			};
			
			tag.prototype.validate = function (code){
				if (code[0] == '"') {
					return (/^\"([^"\{]*)\"$/).test(code);
				} else if (code[0] == "'") {
					return (/^\'([^'\{]*)\'$/).test(code);
				};
			};
			
			tag.trigger('"',function(token,o) {
				if (token.quote() == '"') {
					this.insert('\\"');
					return true;
				} else if (token.quote() == "'" && o.mode == 'all') {
					token.setQuote('"');
					return this;
				};
			});
			
			tag.trigger("'",function(token,o) {
				var v_;
				if (token.quote() == '"') {
					return (token.setQuote(v_ = "'"),v_);
				} else if (token.quote() == "'" && o.mode == 'all') {
					return this.insert("\\'");
				};
			});
		});
		
		
		
		tag$.defineTag('imneostring', 'imtok', function(tag){
			tag.type('neostring');
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && !this.code().match(/[\{\"\']/)) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imsym', 'imtok', function(tag){
			tag.type('symbol');
		});
		
		return tag$.defineTag('imtagattr', 'imtok', function(tag){
			tag.type('tag_attr');
		});
	
	})()

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var Highlighter = __webpack_require__(29).Highlighter;
		var util = __webpack_require__(34);
		
		tag$.defineTag('imblock', 'im', function(tag){
			
			tag.prototype.deleteLeftRight = function (e){
				this.log('imblock deleteLeftRight',e.region().peek(-1,1));
				
				if (e.region().peek(-1,1) == this.code()) {
					this.orphanize();
					return e.handled();
				};
				
				return this;
			};
			
			tag.prototype.indentBlock = function (e){
				var self = this;
				e.handled();
				
				self.view().caret().expandToLines();
				var region = self.view().caret().region();
				var nodes = self.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline')) {
						self.log('found tab in selection',match);
						if (match.mode != 'start') {
							return match.node.indent();
						};
					};
				});
				
				self.view().caret().dirty();
				return self;
			};
			
			tag.prototype.undent = function (e){
				this.log('imblock.undent',arguments);
				var nodes = e.view().nodesInRegion(e.region().clone().startAtLine());
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						return match.node.undent();
						// e.caret.expand(0,-1)
					};
				});
				this.view().caret().expandToLines();
				return e.handled();
			};
			
			tag.prototype.pairable = function (str,e){
				return true;
			};
			
			tag.prototype.wrap = function (node){
				this.setChildren([node]);
				return this;
			};
			
			tag.prototype.repair = function (){
				// log "repair block"
				q$('._imraw',this).map(function(raw) { return raw.repair(); });
				return this;
			};
			
			tag.prototype.rehighlight = function (){
				// var reg = view.sel.region
				var self = this;
				var state = self.codeState();
				var hl = IM.parse(state.code);
				// could send this through load instead
				// what about annotations here?
				throw 'dont rehighlight';
				
				if (hl) {
					self.view().observer().pause(function() {
						self.dom().innerHTML = hl + '\n';
						return state.invalids.map(function(inv) {
							// we could go local instead
							var node;
							if (node = self.view().nodeAtRegion(inv.region,true)) {
								self.log('found node at invalid position',node);
								return node.replaceWith(inv.node);
							};
						});
					});
				};
				return self;
			};
			
			// bad naming
			tag.prototype.codeState = function (){
				var self = this;
				var real = self.code();
				var valid = real;
				var invalids = q$('.invalid',self);
				var ownreg = self.region();
				var selreg = self.view().sel().region();
				
				var remember = invalids.map(function(inv) {
					// multilevel nesting?
					var region = inv.region();
					var relreg = region.relativeTo(ownreg);
					self.log('invalid region',ownreg,'self',region,relreg);
					valid = valid.ins(inv.placeholder(),relreg);
					return {region: region,placeholder: inv.placeholder(),raw: inv.code(),node: inv,root: self,relRegion: relreg};
				});
				
				return {
					region: ownreg,
					marker: (selreg.intersects(ownreg) ? (selreg) : (null)),
					raw: real,
					code: valid,
					invalids: remember
				};
			};
		});
		
		
		tag$.defineTag('iminterpolated', 'imblock');
		
		tag$.defineTag('indent', 'imblock', function(tag){
			
			tag.prototype.variables = function (){
				var map = {};
				var vars = [];
				q$('._lvar',this).map(function(lvar) {
					var name = lvar.text();
					if (!map[name]) {
						map[name] = true;
						return vars.push(name);
					};
				});
				return vars;
			};
		});
		
		tag$.defineTag('impair', 'imblock', function(tag){
			tag.type('pair');
			
			tag.pair = function (open,close){
				this.prototype._open = open;
				this.prototype._close = close;
				return this;
			};
			
			tag.prototype.open = function (){
				return this._open || '';
			};
			tag.prototype.close = function (){
				return this._close || '';
			};
			
			tag.prototype.build = function (){
				this.gen();
				return this;
			};
			
			tag.prototype.setContent = function (content){
				throw 'should not get here';
				this.dom().innerHTML = this.open() + IM.parse(content) + this.close();
				return this;
			};
			
			tag.prototype.isEmpty = function (){
				return this.code().replace(/[\s\t \n]/,'') == (this.open() + this.close());
			};
			
			tag.prototype.isPaired = function (){
				var code = this.code();
				return code[0] == this.open() && code[code.length - 1] == this.close();
			};
			
			tag.prototype.isOpened = function (){
				return this.code()[0] == this.open();
			};
			
			tag.prototype.isClosed = function (){
				return this.code()[this.code().length - 1] == this.close();
			};
			
			tag.prototype.unwrap = function (){
				if (this.isEmpty()) {
					this.log('remove the whole thing');
					this.orphanize();
				} else {
					var el;
					var par = this.parent();
					while (el = this._dom.firstChild){
						par.dom().insertBefore(el,this._dom);
					};
					// remove self as well
				};
				return this;
			};
			
			tag.prototype.onunwrap = function (e){
				this.log('impair onunwrap!!!',e);
				return e.halt();
			};
			
			tag.prototype.gen = function (){
				this.setChildren([
					tag$.$imopen().setContent(this.open(),0).end(),
					tag$.$imclose().setContent(this.close(),0).end()
				]);
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				e.setCaret(this.region().collapse(false).move(1));
				return this;
			};
			
			tag.prototype.select = function (){
				return this;
			};
			
			tag.prototype.onlinebreak = function (e){
				var pre = e.linestr('pre');
				var indent = e.indent();
				var new$ = this.text().ins('',e.relRegion());
				
				// this is a special case - no?
				if (new$ == (this.open() + this.close())) {
					var prefix = '\n' + indent + '\t';
					var post = '\n' + indent;
					this.onwhitespace(e,prefix + post);
					e.caret().collapse(false).move(-post.length);
					return e.handled();
				};
				
				// need to first consider the splitting, no?
				if (this.increaseIndent(pre)) { indent += '\t' };
				if (this.decreaseIndent(pre)) { indent = indent.slice(1) };
				this.onwhitespace(e,'\n' + indent);
				return e.handled();
			};
			
			tag.prototype.repair = function (){
				this.log('repair imtag');
				if (!(this.isPaired())) { this.revalidate(true) };
				return this;
			};
			
			tag.prototype.mutated = function (){
				this.log('impair mutated');
				return this.revalidate();
			};
			
			tag.prototype.defaultValidationMode = function (){
				return 'tokenize';
			};
			
			tag.prototype.rehighlight = function (){
				return this;
			};
			
			tag.prototype.revalidate = function (mode,write){
				// tricky motherfucker -- mostly useful for validations
				// I suppose we can do this a simpler way -- by turning
				// off observers -- temporarily replacing inner code etc
				
				// when a block checks validity it should probably
				// substitute inner invalid parts - so that the block
				// thing is still valid
				var self = this, hl;
				if(mode === undefined) mode = self.defaultValidationMode();
				if(write === undefined) write = false;
				var wasInvalid = self.hasFlag('invalid');
				var oldState = self.hasFlag('invalid');
				var state = self.codeState();
				var code = state.code;
				
				if (!(self.isPaired())) {
					return self.markInvalid();
				};
				
				console.log('will revalidate with code',code);
				console.time('revalidate');
				
				try {
					if (mode == 'compile') {
						self._output = Imbac.compile(code,{bare: true});
						self._tokens = self._output.options._tokens;
					} else {
						self._tokens = Imbac.tokenize(code,{bare: true});
					};
					self.markValid();
				} catch (e) {
					self._tokens = null;
					self.markInvalid();
				};
				
				console.timeEnd('revalidate');
				
				if (wasInvalid && self._tokens) {
					// need to fix inner for root
					if (hl = Highlighter.highlight(code,{tokens: self._tokens,inner: true})) {
						// this should be refactored out into a separate method
						// possibly do loadState / dumpState
						self.view().observer().pause(function() {
							self.dom().innerHTML = hl;
							state.invalids.map(function(inv) {
								var node;
								if (node = self.view().nodeAtRegion(inv.region,true)) {
									return node.replaceWith(inv.node);
								};
							});
							if (state.marker) { return self.view().sel().set(state.marker) };
						});
					};
				};
				
				return self;
			};
			
			tag.prototype.placeholder = function (){
				return this.open() + (' ').repeat(this.size() - 2) + this.close();
			};
			
			tag.prototype.isAtomic = function (){
				return true;
			};
			
			tag.prototype.mutated = function (){
				this.log('muated imcurly');
				this.view().highlighter().reparse(this.dirtyExtent());
				return this;
			};
		});
		
		tag$.defineTag('imcurly', 'impair', function(tag){
			tag.type('curly');
			tag.pair('{','}');
		});
		
		tag$.defineTag('imsquare', 'impair', function(tag){
			tag.type('square');
			tag.pair('[',']');
			
			tag.prototype.prettify = function (e){
				var self = this;
				self.log('prettify!');
				e.handled();
				var ind = e.region().indent();
				self.log('with indentation',ind,ind.length);
				
				self.view().observer().pause(function() {
					for (var i = 0, ary = iter$(self.children()), len = ary.length, child, res = []; i < len; i++) {
						child = ary[i];
						res.push(child.matches('.comma,._imopen') ? (
							child.setNext('\n' + ind + '\t')
						) : ((child.matches('._imclose')) && (
							child.setPrev('\n' + ind)
						)));
					};
					return res;
				});
				
				return true;
			};
		});
		
		tag$.defineTag('imparens', 'impair', function(tag){
			tag.type('parens');
			tag.pair('(',')');
			
			tag.prototype.onunwrap = function (e){
				this.log('impair onunwrap!!!',e);
				e.halt();
				// look at prev and next as well?
				// should do this through the view
				this.setCode(' ' + this.code().slice(1,-1));
				return this.view().repair();
			};
		});
		
		tag$.defineTag('imistring', 'impair', function(tag){
			tag.type('istring');
			tag.pair('"','"');
		});
		
		tag$.defineTag('imiexpr', 'impair', function(tag){
			tag.type('iexpr');
			tag.pair('{','}');
		});
		
		tag$.defineTag('imblockparams', 'impair', function(tag){
			tag.type('blockparams');
			tag.pair('|','|');
		});
		
		return tag$.defineTag('imtagnode', 'impair', function(tag){
			tag.type('tagnode');
			tag.pair('<','>');
			
			tag.prototype.pairable = function (str,e){
				return idx$(str,['{','[','(','"',"'"]) >= 0;
			};
			
			tag.prototype.placeholder = function (){
				return this.open() + ('x').repeat(this.size() - 2) + this.close();
			};
			
			tag.prototype.defaultValidationMode = function (){
				return 'compile';
			};
		});
	
	})()

/***/ },
/* 51 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('imroot', 'imblock', function(tag){
			
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag._nodeType = 'code';
			// def self.dom
			//	@dom ||= document.createElement('code')
			
			tag.prototype.tryUndent = function (e){
				var self = this;
				self.log('tryUndent');
				var nodes = e.view().nodesInRegion(e.region().clone().startAtLine());
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						match.node.undent();
						return self.view().caret().move(-1);
						// e.caret.move(-1)
						// e.caret.expand(0,-1)
					};
				});
				
				// e.moveCaret = 0
				e.handled();
				return self;
			};
			
			tag.prototype.build = function (){
				tag.__super__.build.apply(this,arguments);
				
				this.dom().addEventListener('');
				return this;
			};
			
			tag.prototype.commit = function (){
				return this;
			};
			
			tag.prototype.setNext = function (node){
				this.appendChild(node);
				return node;
			};
			
			tag.prototype.setPrev = function (node){
				var first = this.dom().firstChild;
				first ? (this.insertBefore(node,first)) : (this.appendChild(node));
				return node;
			};
			
			tag.prototype.onlinebreak = function (e){
				var pre = e.linestr('pre');
				var indent = e.indent();
				var new$ = this.text().ins('',e.relRegion());
				// need to first consider the splitting, no?
				if (this.increaseIndent(pre)) { indent += '\t' };
				if (this.decreaseIndent(pre)) { indent = indent.slice(1) };
				this.onwhitespace(e,'\n' + indent);
				return e.handled();
			};
			
			tag.prototype.mutated = function (){
				this.log('imroot mutated');
				return this;
			};
			
			tag.prototype.dirtyExtent = function (){
				var self = this;
				self.log('imroot dirtyExtent');
				// super
				var nodes = self.children().map(function(n) { return n.dom(); });
				
				return {
					code: self.code(),
					nodes: nodes,
					parent: self.dom(),
					contains: function(el) { return self.dom().contains(el._dom || el); }
				};
			};
		});
	
	})()

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		// externs;
		
		var util = __webpack_require__(34);
		
		var SINGLE_STR = /^'[^']*'$/;
		var DOUBLE_STR = /^"[^"\{]*"$/;
		var COMMENT = /^\#[ \t][^\n]*$/;
		
		DOUBLE_STR = /^"([^\\"\{]|\\\\|\\")*"$/;
		
		tag$.defineTag('imlit', 'im', function(tag){
			
			tag.prototype.validate = function (code){
				return false;
			};
		});
		
		return tag$.defineTag('imregex', 'imlit', function(tag){
			
			tag.type('regex');
			
			tag.prototype.validate = function (value){
				return true;
			};
			
			tag.prototype.pairing = function (chr){
				return this;
			};
			
			tag.prototype.revalidate = function (){
				var reg = this.code();
				try {
					var obj = eval(reg);
				} catch (e) { };
				this.log('regex is',reg,obj);
				this.flag('invalid',!obj);
				return this;
			};
			
			tag.prototype.mutated = function (){
				this.log('regex mutated');
				return this.revalidate();
			};
			
			tag.prototype.placeholder = function (){
				return '/' + 'R'.repeat(this.size() - 2) + '/';
			};
			
			tag.prototype.isAtomic = function (){
				return true;
			};
		});
		
	
	})()

/***/ },
/* 53 */
/***/ function(module, exports) {

	(function(){
		
		// should rather reconcile into token - or something like it
		var names = {
			'.': 'dot',
			'=': 'eq',
			'?': 'q',
			'!': 'unary',
			':': 'colon',
			',': 'comma',
			'#': 'hash',
			'*': 'mult',
			'>>': 'bitshift'
		};
		
		tag$.defineTag('imop', 'im', function(tag){
			
			tag.type('op');
			tag.alias('relation');
			tag.alias('compare');
			tag.alias('compound_assign');
			tag.alias('assign');
			tag.alias('block_arg');
			tag.alias('splat');
			tag.alias('logic');
			tag.alias('math');
			tag.alias('shift');
			tag.alias('unary');
			
			tag.prototype.validate = function (code){
				return IM.isOp(code);
			};
			
			tag.prototype.baseClasses = function (){
				return tag.__super__.baseClasses.apply(this,arguments) + ' ' + (names[this.code()] || '');
			};
			
			tag.prototype.setup = function (token){
				var val = token && token._value || this.code();
				this.dom().className = ("_im _imop op " + (names[val] || ''));
				return this;
			};
			
			// should merge with a more generic version for token in general
			// same goes for text etc
			tag.prototype.insert = function (){
				tag.__super__.insert.apply(this,arguments);
				
				if (this.code() == '//') {
					this.log('is a regex!!');
					return this.reclassify('regex');
				};
			};
		});
		
		// link regular ops to op-node
		return '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ? &= ||= &&= ?. ?: , ! .. ... .: >> << #'.split(' ').map(function(op) {
			return IM.Types[op] = IM.Types.op;
		});
		
		
		// IM.Types:logic = IM.Types:op
		// IM.Types:compare = IM.Types:op
		// IM.Types:math = IM.Types:op
		// IM.Types:shift = IM.Types:op
		
	
	})()

/***/ },
/* 54 */
/***/ function(module, exports) {

	(function(){
		
		// this should be more advanced than this, no?
		tag$.defineTag('imsel', 'imtok', function(tag){
			tag.type('selector');
			
			tag.prototype.isAtomic = function (){
				return true;
			};
			
			tag.prototype.reparsed = function (code,old){
				this.log("imsel reparsed",code,old);
				return this;
			};
		});
		
		tag$.defineTag('imseltag', 'imtok', function(tag){
			tag.type('selector_tag');
		});
		
		tag$.defineTag('imselclass', 'imtok', function(tag){
			tag.type('selector_class');
		});
		
		tag$.defineTag('imselcomb', 'imtok', function(tag){
			tag.type('selector_combinator');
		});
		
		tag$.defineTag('imselattrop', 'imtok', function(tag){
			tag.type('selector_attr_op');
		});
		
		return tag$.defineTag('imselattrop', 'imtok', function(tag){
			tag.type('selector_attr_op');
		});
	
	})()

/***/ },
/* 55 */
/***/ function(module, exports) {

	(function(){
		tag$.defineTag('iminsert', 'im', function(tag){
			
			tag.prototype.canAppend = function (){
				return true;
			};
			
			tag.prototype.canPrepend = function (){
				return true;
			};
			
			tag.prototype.insert = function (reg,ins){
				console.log('insert code into iminsert!!',ins,reg);
				
				if (ins instanceof IM.Types.fragment) {
					ins = ins.code();
				} else if (ins instanceof IM.Types.raw) {
					ins = ins._raw;
				} else if ((typeof ins=='string'||ins instanceof String)) {
					ins = (this.code() || "").ins(ins,reg);
				};
				
				this.setCode(ins);
				return this;
			};
			
			tag.prototype.isWhitespace = function (){
				return this.code().match(/^[\n\t\ ]+$/);
			};
			
			tag.prototype.mutated = function (){
				this.log('iminsert mutated');
				
				var dirty = this.dirtyExtent();
				this.view().highlighter().reparse(dirty);
				return this;
			};
		});
		
		tag$.defineTag('imwhitespace', 'im', function(tag){
			
			tag.prototype.canPrepend = function (str){
				return this.validate(str + this.code());
			};
			
			tag.prototype.canAppend = function (str){
				return this.validate(this.code() + str);
			};
			
			tag.prototype.validate = function (){
				return false;
			};
		});
		
		tag$.defineTag('imnewline', 'imwhitespace', function(tag){
			
			tag.type('newline');
			tag.alias('\n');
			
			tag.prototype.canPrepend = function (str){
				if (str.match(/^[\n\t\ ]+$/)) {
					// should not really be able to prepend here
					// it shold rather insert a new newline in
					// an iminsert, and that should be able to
					// decide that no reparse is needed
					return true;
				};
				return false;
			};
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return val == '\n';
			};
			
			tag.prototype.indent = function (){
				this.view().insert(this.region().end(),'\t');
				return this;
			};
			
			tag.prototype.undent = function (){
				this.log('undent newline');
				var reg = this.region().clone().collapse(true).clone(0,1);
				if (reg.text() == '\t') {
					this.log('can undent!!');
					this.view().erase(reg);
				};
				
				// view.observer.pause do
				//	next.orphanize if next?.matches('._imtab')
				return this;
			};
			
			tag.prototype.mutated = function (){
				// log 'imnewline mutated!!'
				// remove node if it is orphanized
				if (this.code() == '') {
					this.log('remove whole node');
					return this.orphanize();
				} else {
					this.log('reparse newline');
					return this.view().highlighter().reparse({nodes: [this.dom()],code: this.code()});
				};
			};
		});
		
		
		
		tag$.defineTag('imspace', 'imwhitespace', function(tag){
			
			tag.type('whitespace');
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return (/^[ ]+$/).test(val);
			};
			
			// this should be the default for all nodes, no?
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && this.validate(this.code())) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imsemicolon', 'imwhitespace', function(tag){
			tag.type('semicolon');
			tag.alias(';');
		});
		
		tag$.defineTag('imtab', 'imwhitespace', function(tag){
			
			tag.type('tab');
			tag.alias('\t');
			
			tag.prototype.onedit = function (e){
				if (e.isSurrounded()) {
					this.log('delete tab?!?');
					if (e.text()) { // otherwise we really are done
						e.redirect(this.prev() || this.next() || this.parent());
					} else {
						e.handled();
					};
					
					e.region().collapse(false);
					this.orphanize();
					return;
				};
			};
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return val == '\t';
			};
		});
		
		tag$.defineTag('imcomment', 'im', function(tag){
			
			tag.type('comment');
			
			tag.prototype.validate = function (code){
				return COMMENT.test(code);
			};
			
			tag.prototype.mutated = function (){
				this.log('imcomment mutated');
				return tag.__super__.mutated.apply(this,arguments);
			};
			
			tag.prototype.repair = function (){
				this;
				this.log('repair comment');
				var region = this.region().endAtLine();
				var full = region.text(); // should not include the last line?
				var nodes = region.nodes(false);
				this.log('whole region should be',region,full,nodes);
				this.log('all nodes',nodes);
				
				// VERY temporary
				if (nodes.length > 1) {
					this.setCode(full);
					while (nodes.length > 1){
						var el = nodes.pop();
						el.node.orphanize();
					};
				};
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				return this.repair();
			};
			
			tag.prototype.canPrepend = function (text){
				return false;
			};
			
			tag.prototype.canAppend = function (text){
				if (!text.match(/[\n]/)) { return true };
			};
		});
		
		
		// allow inserting additional tabs directly here?
		
		return tag$.defineTag('eof');
	
	})()

/***/ },
/* 56 */
/***/ function(module, exports) {

	(function(){
		
		
		tag$.defineTag('imwarn', 'im', function(tag){
			
			
			
			tag.prototype.message = function(v){ return this.getAttribute('message'); }
			tag.prototype.setMessage = function(v){ this.setAttribute('message',v); return this; };
			
			tag.prototype.build = function (){
				this.log('built error with error',this.object());
				return this;
			};
		});
		
		return tag$.defineTag('imerr', 'imwarn');
	
	})()

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var Router = __webpack_require__(58).Router;
		
		function App(){
			this.setCache({});
			this.setDeps({});
			this.reset();
			this.tick();
			this;
		};
		
		exports.App = App; // export class 
		
		
		App.prototype.req = function(v){ return this._req; }
		App.prototype.setReq = function(v){ this._req = v; return this; };
		
		
		App.prototype.res = function(v){ return this._res; }
		App.prototype.setRes = function(v){ this._res = v; return this; };
		
		
		App.prototype.deps = function(v){ return this._deps; }
		App.prototype.setDeps = function(v){ this._deps = v; return this; };
		
		
		App.prototype.site = function(v){ return this._site; }
		App.prototype.setSite = function(v){ this._site = v; return this; };
		
		
		App.prototype.cache = function(v){ return this._cache; }
		App.prototype.setCache = function(v){ this._cache = v; return this; };
		
		
		App.prototype.issues = function(v){ return this._issues; }
		App.prototype.setIssues = function(v){ this._issues = v; return this; };
		
		App.prototype.reset = function (){
			this.setCache({});
			return this;
		};
		
		App.prototype.router = function (){
			return this._router || (this._router = new Router(this));
		};
		
		App.prototype.path = function (){
			return  false ? (this.req().path) : (this._path);
		};
		
		App.prototype.hash = function (){
			return '';
		};
		
		App.prototype.hash = function (){
			return  false ? ('') : (document.location.hash.substr(1));
		};
		
		App.prototype.tick = function (){
			if (true) {
				this._path = document.location.pathname;
			};
			
			return this;
		};
		
		App.prototype.schedule = function (){
			Imba.schedule(this);
			return this;
		};
		
		App.prototype.unschedule = function (){
			Imba.unschedule(this);
			return this;
		};
		
		App.prototype.fetchDocument = function (src,cb){
			
			var deps_, $1, $3, $2;
			if (false) {
				console.log('fetch document',src);
				
				var fs = require('fs');
				var path = require('path');
				
				var filepath = ("" + __dirname + "/../docs/" + src).replace(/\/\//g,'/');
				
				var res = this.deps()[src];
				
				if (!res) {
					var body = fs.readFileSync(filepath,'utf-8');
					
					if (src.match(/\.md$/)) {
						res = this.Markdown.render(body);
					} else if (src.match(/\.json$/)) {
						res = JSON.parse(body);
					} else if (src.match(/\.imba$/)) {
						var html = this.Highlighter.highlight(body,{mode: 'full'});
						res = {body: body,html: html};
					};
				};
				
				(deps_ = this.deps())[($1 = src)] || (deps_[$1] = res);
				
				if (this.site()) {
					($3 = this.site().deps())[($2 = src)] || ($3[$2] = res);
				};
				cb && cb(res);
			} else {
				if (DEPS[src]) {
					cb && cb(DEPS[src]);
					return {then: function(v) { return v(res); }}; // fake promise hack
				};
				
				var xhr = new XMLHttpRequest();
				xhr.addEventListener('load',function(res) {
					DEPS[src] = JSON.parse(xhr.responseText);
					return cb && cb(DEPS[src]);
					// XHR = xhr
					// console.log 'response here',xhr:responseText
				});
				xhr.open("GET",src);
				xhr.send();
			};
			
			return this;
		};
		
		App.prototype.issues = function (){
			return this._issues || (this._issues = Doc.get('/issues/all.json'));
		};
		
		function Doc(path){
			this._path = path;
			this._ready = false;
			this.fetch();
			this;
		};
		
		exports.Doc = Doc; // export class 
		var cache = {};
		
		Doc.get = function (path){
			var $1;
			var cache = APP.cache();
			return cache[($1 = 'doc-' + path)] || (cache[$1] = new this(path));
		};
		
		
		
		Doc.prototype.path = function(v){ return this._path; }
		Doc.prototype.setPath = function(v){ this._path = v; return this; };
		
		
		Doc.prototype.object = function(v){ return this._object; }
		Doc.prototype.setObject = function(v){ this._object = v; return this; };
		
		Doc.prototype.ready = function (){
			return this._ready;
		};
		
		Doc.prototype.fetch = function (){
			var self = this;
			if (false) {
				// console.log 'fetch Guide on server',path
				return APP.fetchDocument(self._path,function(res) {
					// console.log 'fetch Guide on server done',path
					return self.load(res);
				});
			};
			
			return self._promise || (self._promise = APP.fetchDocument(self._path,function(res) {
				return self.load(res);
			}));
		};
		
		Doc.prototype.load = function (doc){
			this._object = doc;
			this._meta = doc.meta || {};
			this._ready = true;
			Imba.emit(this,'ready');
			return this;
		};
		
		Doc.prototype.title = function (){
			return this._object.title || 'path';
		};
		
		Doc.prototype.toc = function (){
			return this._object && this._object.toc[0];
		};
		
		Doc.prototype.body = function (){
			return this._object && this._object.body;
		};
		return Doc;
	
	})()

/***/ },
/* 58 */
/***/ function(module, exports) {

	(function(){
		// externs;
		
		function Router(app){
			var self = this;
			self._app = app;
			
			if (Imba.isClient()) {
				window.onpopstate = function(e) {
					self.refresh();
					console.log('popstate');
					return Imba.setTimeout(0,function() { return true; });
				};
			};
			self;
		};
		
		exports.Router = Router; // export class 
		
		
		Router.prototype.path = function(v){ return this._path; }
		Router.prototype.setPath = function(v){ this._path = v; return this; };
		
		Router.slug = function (str){
			str = str.replace(/^\s+|\s+$/g,'').toLowerCase(); // trim
			// remove accents, swap  for n, etc
			var from = "/_,:;";
			var to = "aaaaaeeeeiiiioooouuuunc------";
			
			// for (var i=0, l=from.length ; i<l ; i++)
			// 	str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
			
			str = str.replace(/[^a-z0-9 -]/g,''); // remove invalid chars
			str = str.replace(/\s+/g,'-'); // collapse whitespace and replace by -
			str = str.replace(/-+/g,'-'); // collapse dashes
			
			return str;
		};
		
		Router.prototype.refresh = function (){
			return this;
		};
		
		Router.prototype.path = function (){
			return this._app.path();
		};
		
		Router.prototype.hash = function (){
			return this._app.hash();
		};
		
		Router.prototype.ext = function (){
			var path = this.path();
			var m = path.match(/\.([^\/]+)$/);
			return m && m[1] || '';
		};
		
		Router.prototype.go = function (href,state,replace){
			if(state === undefined) state = {};
			if(replace === undefined) replace = false;
			if (href == '/install') {
				// redirects here
				href = '/guides#toc-getting-started-installation';
			};
			
			if (replace) {
				history.replaceState(state,null,href);
			} else {
				history.pushState(state,null,href);
			};
			
			if (!href.match(/\#/)) {
				window.scrollTo(0,0);
			};
			
			return this;
		};
		
		Router.prototype.scoped = function (reg,part){
			var path = this.path() + '#' + this.hash();
			if ((typeof reg=='string'||reg instanceof String)) {
				var nxt = path[reg.length];
				return path.substr(0,reg.length) == reg && (!nxt || nxt == '-' || nxt == '/' || nxt == '#' || nxt == '?' || nxt == '_');
			} else if (reg instanceof RegExp) {
				var m = path.match(reg);
				return part && m ? (m[part]) : (m);
			} else {
				return false;
			};
		};
		
		Router.prototype.match = function (reg,part){
			var path = this.path() + '#' + this.hash();
			
			if ((typeof reg=='string'||reg instanceof String)) {
				return path == reg;
			} else if (reg instanceof RegExp) {
				var m = path.match(reg);
				return part && m ? (m[part]) : (m);
			} else {
				return false;
			};
		};
		return Router;
		
	
	})()

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		__webpack_require__(60);
		__webpack_require__(61);
		
		__webpack_require__(63);
		__webpack_require__(64);
		__webpack_require__(65);
		__webpack_require__(71);
		__webpack_require__(66);
		__webpack_require__(67);
		__webpack_require__(68);
		__webpack_require__(69);
		return __webpack_require__(70);
	
	})()

/***/ },
/* 60 */
/***/ function(module, exports) {

	(function(){
		tag$.extendTag('element', function(tag){
			
			
			tag.prototype.route = function(v){ return this.getAttribute('route'); }
			tag.prototype.setRoute = function(v){ this.setAttribute('route',v); return this; };
			
			// def html= html
			// 	@dom:innerHTML = html
			// 	self
			
			tag.prototype.setHtml = function (html){
				if (html != this._html) {
					this.dom().innerHTML = this._html = html;
				};
				return this;
			};
			
			tag.prototype.go = function (route){
				return this;
			};
			
			tag.prototype.router = function (){
				return APP.router();
			};
			
			tag.prototype.reroute = function (){
				this.flag('scoped',this.router().scoped(this.route(),this));
				return this.flag('selected',this.router().match(this.route(),this));
			};
			
			tag.prototype.setTransform = function (value){
				this.css('transform',value);
				return this;
			};
			
			tag.prototype.transform = function (){
				return this.css('transform');
			};
		});
		
		tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.setHtml = function (html){
				if (html != this._html) {
					this.dom().innerHTML = this._html = html;
				};
				return this;
			};
		});
		
		tag$.extendTag('script', function(tag){
			
			tag.prototype.setChildren = function (value){
				this._children = value;
				this.dom().innerHTML = value;
				return this;
			};
		});
		
		tag$.extendTag('canvas', function(tag){
			
			tag.prototype.dpr = function (){
				return this._dpr || (this._dpr = window.devicePixelRatio || 1);
			};
			
			tag.prototype.setWidth = function (width){
				if (width != this._width) {
					this.dom().width = width * this.dpr();
					this.css({width: width});
					this._width = width;
				};
				return this;
			};
			
			tag.prototype.setHeight = function (height){
				if (height != this._height) {
					this.dom().height = height * this.dpr();
					this.css({height: height});
					this._height = height;
				};
				return this;
			};
		});
		
		return tag$.extendTag('a', function(tag){
			
			tag.prototype.route = function (){
				return this._route || this.href();
			};
			
			tag.prototype.ontap = function (e){
				if (e.event().metaKey || e.event().altKey) {
					e._responder = null;
					return e.halt();
				};
				
				if (this.href()[0] == '#' || this.href()[0] == '/') {
					e.cancel().halt();
					this.router().go(this.href(),{});
					Imba.Events.trigger('route',this);
				} else {
					e._responder = null;
					return e.halt();
				};
				return this;
			};
			
			tag.prototype.render = function (){
				return this.reroute();
			};
		});
	
	})()

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// for markdown rendering
		tag$.defineTag('md', function(tag){
			
			
			tag.prototype.__src = {watch: 'reload',name: 'src'};
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){
				var a = this.src();
				if(v != a) { this.setAttribute('src',v); }
				if(v != a) { this.reload && this.reload(v,a,this.__src) }
				return this;
			};
			
			tag.prototype.__html = {watch: 'htmlDidSet',name: 'html'};
			tag.prototype.html = function(v){ return this._html; }
			tag.prototype.setHtml = function(v){
				var a = this.html();
				if(v != a) { this._html = v; }
				if(v != a) { this.htmlDidSet && this.htmlDidSet(v,a,this.__html) }
				return this;
			};
			
			
			tag.prototype.doc = function(v){ return this._doc; }
			tag.prototype.setDoc = function(v){ this._doc = v; return this; };
			
			tag.prototype.body = function (){
				return this;
			};
			
			tag.prototype.setup = function (){
				return this;
			};
			
			tag.prototype.ghsrc = function (){
				return ("https://github.com/somebee/imba.io/blob/master/docs" + this.src());
			};
			
			tag.prototype.htmlDidSet = function (html){
				this.body().dom().innerHTML = html;
				this.setup();
				return this;
			};
			
			tag.prototype.render = function (){
				var self = this;
				if (false) {
					APP.fetchDocument(self.src() + '.md',function(doc) {
						return self.assemble(doc);
					});
				} else if (self._snippets) {
					for (var i = 0, ary = iter$(self._snippets), len = ary.length; i < len; i++) {
						ary[i].end(); // simulate real rendering here?
					};
				};
				return self;
			};
			
			// not on frontpage?!
			tag.prototype.assemble = function (doc){
				return this.flag('md').setHtml(doc.body).synced();
			};
			
			tag.prototype.build = function (){
				tag.__super__.build.apply(this,arguments);
				if (Imba.isClient() && this.src()) { return this.reload() };
			};
			
			tag.prototype.awaken = function (){
				// log "awakened md from client(!)"
				this._snippets = q$('._snippet',this).toArray();
				return this;
			};
			
			tag.prototype.preload = function (html){
				this._dom.innerHTML = html;
				this._snippets = q$('._snippet',this).toArray();
				return this;
			};
			
			tag.prototype.reload = function (){
				var self = this;
				if (Imba.isClient()) {
					// console.log 'reloading markdown'
					self._snippets = [];
					APP.fetchDocument(self.src() + '.md',function(res) {
						// console.log 'returned from markdown here?!',res
						self.assemble((self.setDoc(res),res));
						self._snippets = q$('._snippet',self).toArray();
						self.parent().dom().scrollTop = 0;
						return self;
					});
				};
				return self;
			};
		});
		
		// define renderer
		var marked = __webpack_require__(62);
		var mdr = new (marked.Renderer)();
		
		mdr.heading = function (text,lvl){
			return ("<h" + lvl + ">" + text + "</h" + lvl + ">");
		};
		
		return tag$.defineTag('marked', function(tag){
			
			tag.prototype.renderer = function (){
				return this;
			};
			
			tag.prototype.setText = function (text){
				return this.setContent(text,0);
			};
			
			tag.prototype.setContent = function (val,typ){
				if (val != this._content) {
					this._content = val;
					this.dom().innerHTML = marked(val,{renderer: mdr});
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * marked - a markdown parser
	 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/chjj/marked
	 */
	
	;(function() {
	
	/**
	 * Block-Level Grammar
	 */
	
	var block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: noop,
	  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
	  nptable: noop,
	  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
	  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
	  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
	  table: noop,
	  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
	  text: /^[^\n]+/
	};
	
	block.bullet = /(?:[*+-]|\d+\.)/;
	block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
	block.item = replace(block.item, 'gm')
	  (/bull/g, block.bullet)
	  ();
	
	block.list = replace(block.list)
	  (/bull/g, block.bullet)
	  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
	  ('def', '\\n+(?=' + block.def.source + ')')
	  ();
	
	block.blockquote = replace(block.blockquote)
	  ('def', block.def)
	  ();
	
	block._tag = '(?!(?:'
	  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
	  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
	  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
	
	block.html = replace(block.html)
	  ('comment', /<!--[\s\S]*?-->/)
	  ('closed', /<(tag)[\s\S]+?<\/\1>/)
	  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
	  (/tag/g, block._tag)
	  ();
	
	block.paragraph = replace(block.paragraph)
	  ('hr', block.hr)
	  ('heading', block.heading)
	  ('lheading', block.lheading)
	  ('blockquote', block.blockquote)
	  ('tag', '<' + block._tag)
	  ('def', block.def)
	  ();
	
	/**
	 * Normal Block Grammar
	 */
	
	block.normal = merge({}, block);
	
	/**
	 * GFM Block Grammar
	 */
	
	block.gfm = merge({}, block.normal, {
	  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
	  paragraph: /^/,
	  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
	});
	
	block.gfm.paragraph = replace(block.paragraph)
	  ('(?!', '(?!'
	    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
	    + block.list.source.replace('\\1', '\\3') + '|')
	  ();
	
	/**
	 * GFM + Tables Block Grammar
	 */
	
	block.tables = merge({}, block.gfm, {
	  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
	  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
	});
	
	/**
	 * Block Lexer
	 */
	
	function Lexer(options) {
	  this.tokens = [];
	  this.tokens.links = {};
	  this.options = options || marked.defaults;
	  this.rules = block.normal;
	
	  if (this.options.gfm) {
	    if (this.options.tables) {
	      this.rules = block.tables;
	    } else {
	      this.rules = block.gfm;
	    }
	  }
	}
	
	/**
	 * Expose Block Rules
	 */
	
	Lexer.rules = block;
	
	/**
	 * Static Lex Method
	 */
	
	Lexer.lex = function(src, options) {
	  var lexer = new Lexer(options);
	  return lexer.lex(src);
	};
	
	/**
	 * Preprocessing
	 */
	
	Lexer.prototype.lex = function(src) {
	  src = src
	    .replace(/\r\n|\r/g, '\n')
	    .replace(/\t/g, '    ')
	    .replace(/\u00a0/g, ' ')
	    .replace(/\u2424/g, '\n');
	
	  return this.token(src, true);
	};
	
	/**
	 * Lexing
	 */
	
	Lexer.prototype.token = function(src, top, bq) {
	  var src = src.replace(/^ +$/gm, '')
	    , next
	    , loose
	    , cap
	    , bull
	    , b
	    , item
	    , space
	    , i
	    , l;
	
	  while (src) {
	    // newline
	    if (cap = this.rules.newline.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[0].length > 1) {
	        this.tokens.push({
	          type: 'space'
	        });
	      }
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      cap = cap[0].replace(/^ {4}/gm, '');
	      this.tokens.push({
	        type: 'code',
	        text: !this.options.pedantic
	          ? cap.replace(/\n+$/, '')
	          : cap
	      });
	      continue;
	    }
	
	    // fences (gfm)
	    if (cap = this.rules.fences.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'code',
	        lang: cap[2],
	        text: cap[3] || ''
	      });
	      continue;
	    }
	
	    // heading
	    if (cap = this.rules.heading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[1].length,
	        text: cap[2]
	      });
	      continue;
	    }
	
	    // table no leading pipe (gfm)
	    if (top && (cap = this.rules.nptable.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i].split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // lheading
	    if (cap = this.rules.lheading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[2] === '=' ? 1 : 2,
	        text: cap[1]
	      });
	      continue;
	    }
	
	    // hr
	    if (cap = this.rules.hr.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'hr'
	      });
	      continue;
	    }
	
	    // blockquote
	    if (cap = this.rules.blockquote.exec(src)) {
	      src = src.substring(cap[0].length);
	
	      this.tokens.push({
	        type: 'blockquote_start'
	      });
	
	      cap = cap[0].replace(/^ *> ?/gm, '');
	
	      // Pass `top` to keep the current
	      // "toplevel" state. This is exactly
	      // how markdown.pl works.
	      this.token(cap, top, true);
	
	      this.tokens.push({
	        type: 'blockquote_end'
	      });
	
	      continue;
	    }
	
	    // list
	    if (cap = this.rules.list.exec(src)) {
	      src = src.substring(cap[0].length);
	      bull = cap[2];
	
	      this.tokens.push({
	        type: 'list_start',
	        ordered: bull.length > 1
	      });
	
	      // Get each top-level item.
	      cap = cap[0].match(this.rules.item);
	
	      next = false;
	      l = cap.length;
	      i = 0;
	
	      for (; i < l; i++) {
	        item = cap[i];
	
	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+\.) +/, '');
	
	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }
	
	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (this.options.smartLists && i !== l - 1) {
	          b = block.bullet.exec(cap[i + 1])[0];
	          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
	            src = cap.slice(i + 1).join('\n') + src;
	            i = l - 1;
	          }
	        }
	
	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) loose = next;
	        }
	
	        this.tokens.push({
	          type: loose
	            ? 'loose_item_start'
	            : 'list_item_start'
	        });
	
	        // Recurse.
	        this.token(item, false, bq);
	
	        this.tokens.push({
	          type: 'list_item_end'
	        });
	      }
	
	      this.tokens.push({
	        type: 'list_end'
	      });
	
	      continue;
	    }
	
	    // html
	    if (cap = this.rules.html.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: this.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        pre: !this.options.sanitizer
	          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	        text: cap[0]
	      });
	      continue;
	    }
	
	    // def
	    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.links[cap[1].toLowerCase()] = {
	        href: cap[2],
	        title: cap[3]
	      };
	      continue;
	    }
	
	    // table (gfm)
	    if (top && (cap = this.rules.table.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i]
	          .replace(/^ *\| *| *\| *$/g, '')
	          .split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // top-level paragraph
	    if (top && (cap = this.rules.paragraph.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'paragraph',
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      });
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      // Top-level should never reach here.
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'text',
	        text: cap[0]
	      });
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return this.tokens;
	};
	
	/**
	 * Inline-Level Grammar
	 */
	
	var inline = {
	  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
	  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
	  url: noop,
	  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
	  link: /^!?\[(inside)\]\(href\)/,
	  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
	  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
	  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
	  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
	  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
	  br: /^ {2,}\n(?!\s*$)/,
	  del: noop,
	  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
	};
	
	inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
	inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
	
	inline.link = replace(inline.link)
	  ('inside', inline._inside)
	  ('href', inline._href)
	  ();
	
	inline.reflink = replace(inline.reflink)
	  ('inside', inline._inside)
	  ();
	
	/**
	 * Normal Inline Grammar
	 */
	
	inline.normal = merge({}, inline);
	
	/**
	 * Pedantic Inline Grammar
	 */
	
	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
	});
	
	/**
	 * GFM Inline Grammar
	 */
	
	inline.gfm = merge({}, inline.normal, {
	  escape: replace(inline.escape)('])', '~|])')(),
	  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
	  del: /^~~(?=\S)([\s\S]*?\S)~~/,
	  text: replace(inline.text)
	    (']|', '~]|')
	    ('|', '|https?://|')
	    ()
	});
	
	/**
	 * GFM + Line Breaks Inline Grammar
	 */
	
	inline.breaks = merge({}, inline.gfm, {
	  br: replace(inline.br)('{2,}', '*')(),
	  text: replace(inline.gfm.text)('{2,}', '*')()
	});
	
	/**
	 * Inline Lexer & Compiler
	 */
	
	function InlineLexer(links, options) {
	  this.options = options || marked.defaults;
	  this.links = links;
	  this.rules = inline.normal;
	  this.renderer = this.options.renderer || new Renderer;
	  this.renderer.options = this.options;
	
	  if (!this.links) {
	    throw new
	      Error('Tokens array requires a `links` property.');
	  }
	
	  if (this.options.gfm) {
	    if (this.options.breaks) {
	      this.rules = inline.breaks;
	    } else {
	      this.rules = inline.gfm;
	    }
	  } else if (this.options.pedantic) {
	    this.rules = inline.pedantic;
	  }
	}
	
	/**
	 * Expose Inline Rules
	 */
	
	InlineLexer.rules = inline;
	
	/**
	 * Static Lexing/Compiling Method
	 */
	
	InlineLexer.output = function(src, links, options) {
	  var inline = new InlineLexer(links, options);
	  return inline.output(src);
	};
	
	/**
	 * Lexing/Compiling
	 */
	
	InlineLexer.prototype.output = function(src) {
	  var out = ''
	    , link
	    , text
	    , href
	    , cap;
	
	  while (src) {
	    // escape
	    if (cap = this.rules.escape.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += cap[1];
	      continue;
	    }
	
	    // autolink
	    if (cap = this.rules.autolink.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = cap[1].charAt(6) === ':'
	          ? this.mangle(cap[1].substring(7))
	          : this.mangle(cap[1]);
	        href = this.mangle('mailto:') + text;
	      } else {
	        text = escape(cap[1]);
	        href = text;
	      }
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // url (gfm)
	    if (!this.inLink && (cap = this.rules.url.exec(src))) {
	      src = src.substring(cap[0].length);
	      text = escape(cap[1]);
	      href = text;
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // tag
	    if (cap = this.rules.tag.exec(src)) {
	      if (!this.inLink && /^<a /i.test(cap[0])) {
	        this.inLink = true;
	      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	        this.inLink = false;
	      }
	      src = src.substring(cap[0].length);
	      out += this.options.sanitize
	        ? this.options.sanitizer
	          ? this.options.sanitizer(cap[0])
	          : escape(cap[0])
	        : cap[0]
	      continue;
	    }
	
	    // link
	    if (cap = this.rules.link.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.inLink = true;
	      out += this.outputLink(cap, {
	        href: cap[2],
	        title: cap[3]
	      });
	      this.inLink = false;
	      continue;
	    }
	
	    // reflink, nolink
	    if ((cap = this.rules.reflink.exec(src))
	        || (cap = this.rules.nolink.exec(src))) {
	      src = src.substring(cap[0].length);
	      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = this.links[link.toLowerCase()];
	      if (!link || !link.href) {
	        out += cap[0].charAt(0);
	        src = cap[0].substring(1) + src;
	        continue;
	      }
	      this.inLink = true;
	      out += this.outputLink(cap, link);
	      this.inLink = false;
	      continue;
	    }
	
	    // strong
	    if (cap = this.rules.strong.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.strong(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // em
	    if (cap = this.rules.em.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.em(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.codespan(escape(cap[2], true));
	      continue;
	    }
	
	    // br
	    if (cap = this.rules.br.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.br();
	      continue;
	    }
	
	    // del (gfm)
	    if (cap = this.rules.del.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.del(this.output(cap[1]));
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.text(escape(this.smartypants(cap[0])));
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return out;
	};
	
	/**
	 * Compile Link
	 */
	
	InlineLexer.prototype.outputLink = function(cap, link) {
	  var href = escape(link.href)
	    , title = link.title ? escape(link.title) : null;
	
	  return cap[0].charAt(0) !== '!'
	    ? this.renderer.link(href, title, this.output(cap[1]))
	    : this.renderer.image(href, title, escape(cap[1]));
	};
	
	/**
	 * Smartypants Transformations
	 */
	
	InlineLexer.prototype.smartypants = function(text) {
	  if (!this.options.smartypants) return text;
	  return text
	    // em-dashes
	    .replace(/---/g, '\u2014')
	    // en-dashes
	    .replace(/--/g, '\u2013')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	};
	
	/**
	 * Mangle Links
	 */
	
	InlineLexer.prototype.mangle = function(text) {
	  if (!this.options.mangle) return text;
	  var out = ''
	    , l = text.length
	    , i = 0
	    , ch;
	
	  for (; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }
	
	  return out;
	};
	
	/**
	 * Renderer
	 */
	
	function Renderer(options) {
	  this.options = options || {};
	}
	
	Renderer.prototype.code = function(code, lang, escaped) {
	  if (this.options.highlight) {
	    var out = this.options.highlight(code, lang);
	    if (out != null && out !== code) {
	      escaped = true;
	      code = out;
	    }
	  }
	
	  if (!lang) {
	    return '<pre><code>'
	      + (escaped ? code : escape(code, true))
	      + '\n</code></pre>';
	  }
	
	  return '<pre><code class="'
	    + this.options.langPrefix
	    + escape(lang, true)
	    + '">'
	    + (escaped ? code : escape(code, true))
	    + '\n</code></pre>\n';
	};
	
	Renderer.prototype.blockquote = function(quote) {
	  return '<blockquote>\n' + quote + '</blockquote>\n';
	};
	
	Renderer.prototype.html = function(html) {
	  return html;
	};
	
	Renderer.prototype.heading = function(text, level, raw) {
	  return '<h'
	    + level
	    + ' id="'
	    + this.options.headerPrefix
	    + raw.toLowerCase().replace(/[^\w]+/g, '-')
	    + '">'
	    + text
	    + '</h'
	    + level
	    + '>\n';
	};
	
	Renderer.prototype.hr = function() {
	  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	};
	
	Renderer.prototype.list = function(body, ordered) {
	  var type = ordered ? 'ol' : 'ul';
	  return '<' + type + '>\n' + body + '</' + type + '>\n';
	};
	
	Renderer.prototype.listitem = function(text) {
	  return '<li>' + text + '</li>\n';
	};
	
	Renderer.prototype.paragraph = function(text) {
	  return '<p>' + text + '</p>\n';
	};
	
	Renderer.prototype.table = function(header, body) {
	  return '<table>\n'
	    + '<thead>\n'
	    + header
	    + '</thead>\n'
	    + '<tbody>\n'
	    + body
	    + '</tbody>\n'
	    + '</table>\n';
	};
	
	Renderer.prototype.tablerow = function(content) {
	  return '<tr>\n' + content + '</tr>\n';
	};
	
	Renderer.prototype.tablecell = function(content, flags) {
	  var type = flags.header ? 'th' : 'td';
	  var tag = flags.align
	    ? '<' + type + ' style="text-align:' + flags.align + '">'
	    : '<' + type + '>';
	  return tag + content + '</' + type + '>\n';
	};
	
	// span level renderer
	Renderer.prototype.strong = function(text) {
	  return '<strong>' + text + '</strong>';
	};
	
	Renderer.prototype.em = function(text) {
	  return '<em>' + text + '</em>';
	};
	
	Renderer.prototype.codespan = function(text) {
	  return '<code>' + text + '</code>';
	};
	
	Renderer.prototype.br = function() {
	  return this.options.xhtml ? '<br/>' : '<br>';
	};
	
	Renderer.prototype.del = function(text) {
	  return '<del>' + text + '</del>';
	};
	
	Renderer.prototype.link = function(href, title, text) {
	  if (this.options.sanitize) {
	    try {
	      var prot = decodeURIComponent(unescape(href))
	        .replace(/[^\w:]/g, '')
	        .toLowerCase();
	    } catch (e) {
	      return '';
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
	      return '';
	    }
	  }
	  var out = '<a href="' + href + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += '>' + text + '</a>';
	  return out;
	};
	
	Renderer.prototype.image = function(href, title, text) {
	  var out = '<img src="' + href + '" alt="' + text + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += this.options.xhtml ? '/>' : '>';
	  return out;
	};
	
	Renderer.prototype.text = function(text) {
	  return text;
	};
	
	/**
	 * Parsing & Compiling
	 */
	
	function Parser(options) {
	  this.tokens = [];
	  this.token = null;
	  this.options = options || marked.defaults;
	  this.options.renderer = this.options.renderer || new Renderer;
	  this.renderer = this.options.renderer;
	  this.renderer.options = this.options;
	}
	
	/**
	 * Static Parse Method
	 */
	
	Parser.parse = function(src, options, renderer) {
	  var parser = new Parser(options, renderer);
	  return parser.parse(src);
	};
	
	/**
	 * Parse Loop
	 */
	
	Parser.prototype.parse = function(src) {
	  this.inline = new InlineLexer(src.links, this.options, this.renderer);
	  this.tokens = src.reverse();
	
	  var out = '';
	  while (this.next()) {
	    out += this.tok();
	  }
	
	  return out;
	};
	
	/**
	 * Next Token
	 */
	
	Parser.prototype.next = function() {
	  return this.token = this.tokens.pop();
	};
	
	/**
	 * Preview Next Token
	 */
	
	Parser.prototype.peek = function() {
	  return this.tokens[this.tokens.length - 1] || 0;
	};
	
	/**
	 * Parse Text Tokens
	 */
	
	Parser.prototype.parseText = function() {
	  var body = this.token.text;
	
	  while (this.peek().type === 'text') {
	    body += '\n' + this.next().text;
	  }
	
	  return this.inline.output(body);
	};
	
	/**
	 * Parse Current Token
	 */
	
	Parser.prototype.tok = function() {
	  switch (this.token.type) {
	    case 'space': {
	      return '';
	    }
	    case 'hr': {
	      return this.renderer.hr();
	    }
	    case 'heading': {
	      return this.renderer.heading(
	        this.inline.output(this.token.text),
	        this.token.depth,
	        this.token.text);
	    }
	    case 'code': {
	      return this.renderer.code(this.token.text,
	        this.token.lang,
	        this.token.escaped);
	    }
	    case 'table': {
	      var header = ''
	        , body = ''
	        , i
	        , row
	        , cell
	        , flags
	        , j;
	
	      // header
	      cell = '';
	      for (i = 0; i < this.token.header.length; i++) {
	        flags = { header: true, align: this.token.align[i] };
	        cell += this.renderer.tablecell(
	          this.inline.output(this.token.header[i]),
	          { header: true, align: this.token.align[i] }
	        );
	      }
	      header += this.renderer.tablerow(cell);
	
	      for (i = 0; i < this.token.cells.length; i++) {
	        row = this.token.cells[i];
	
	        cell = '';
	        for (j = 0; j < row.length; j++) {
	          cell += this.renderer.tablecell(
	            this.inline.output(row[j]),
	            { header: false, align: this.token.align[j] }
	          );
	        }
	
	        body += this.renderer.tablerow(cell);
	      }
	      return this.renderer.table(header, body);
	    }
	    case 'blockquote_start': {
	      var body = '';
	
	      while (this.next().type !== 'blockquote_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.blockquote(body);
	    }
	    case 'list_start': {
	      var body = ''
	        , ordered = this.token.ordered;
	
	      while (this.next().type !== 'list_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.list(body, ordered);
	    }
	    case 'list_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.token.type === 'text'
	          ? this.parseText()
	          : this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'loose_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'html': {
	      var html = !this.token.pre && !this.options.pedantic
	        ? this.inline.output(this.token.text)
	        : this.token.text;
	      return this.renderer.html(html);
	    }
	    case 'paragraph': {
	      return this.renderer.paragraph(this.inline.output(this.token.text));
	    }
	    case 'text': {
	      return this.renderer.paragraph(this.parseText());
	    }
	  }
	};
	
	/**
	 * Helpers
	 */
	
	function escape(html, encode) {
	  return html
	    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#39;');
	}
	
	function unescape(html) {
	  return html.replace(/&([#\w]+);/g, function(_, n) {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}
	
	function replace(regex, opt) {
	  regex = regex.source;
	  opt = opt || '';
	  return function self(name, val) {
	    if (!name) return new RegExp(regex, opt);
	    val = val.source || val;
	    val = val.replace(/(^|[^\[])\^/g, '$1');
	    regex = regex.replace(name, val);
	    return self;
	  };
	}
	
	function noop() {}
	noop.exec = noop;
	
	function merge(obj) {
	  var i = 1
	    , target
	    , key;
	
	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }
	
	  return obj;
	}
	
	
	/**
	 * Marked
	 */
	
	function marked(src, opt, callback) {
	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }
	
	    opt = merge({}, marked.defaults, opt || {});
	
	    var highlight = opt.highlight
	      , tokens
	      , pending
	      , i = 0;
	
	    try {
	      tokens = Lexer.lex(src, opt)
	    } catch (e) {
	      return callback(e);
	    }
	
	    pending = tokens.length;
	
	    var done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }
	
	      var out;
	
	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }
	
	      opt.highlight = highlight;
	
	      return err
	        ? callback(err)
	        : callback(null, out);
	    };
	
	    if (!highlight || highlight.length < 3) {
	      return done();
	    }
	
	    delete opt.highlight;
	
	    if (!pending) return done();
	
	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) return done(err);
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }
	
	    return;
	  }
	  try {
	    if (opt) opt = merge({}, marked.defaults, opt);
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/chjj/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occured:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}
	
	/**
	 * Options
	 */
	
	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  return marked;
	};
	
	marked.defaults = {
	  gfm: true,
	  tables: true,
	  breaks: false,
	  pedantic: false,
	  sanitize: false,
	  sanitizer: null,
	  mangle: true,
	  smartLists: false,
	  silent: false,
	  highlight: null,
	  langPrefix: 'lang-',
	  smartypants: false,
	  headerPrefix: '',
	  renderer: new Renderer,
	  xhtml: false
	};
	
	/**
	 * Expose
	 */
	
	marked.Parser = Parser;
	marked.parser = Parser.parse;
	
	marked.Renderer = Renderer;
	
	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;
	
	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;
	
	marked.parse = marked;
	
	if (true) {
	  module.exports = marked;
	} else if (typeof define === 'function' && define.amd) {
	  define(function() { return marked; });
	} else {
	  this.marked = marked;
	}
	
	}).call(function() {
	  return this || ( true ? window : global);
	}());


/***/ },
/* 63 */
/***/ function(module, exports) {

	(function(){
		tag$.defineTag('site', 'html', function(tag){
			
			
			
			tag.prototype.deps = function(v){ return this._deps; }
			tag.prototype.setDeps = function(v){ this._deps = v; return this; };
			
			tag.prototype.head = function (){
				return tag$.$head().setContent([
					tag$.$title().setText("imba").end(),
					tag$.$meta().setCharset("utf-8").end(),
					tag$.$meta().setName("viewport").setContent("width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1").end(),
					tag$.$meta().setName("Description").setContent("Imba is a rich programming language for the web.").end(),
					tag$.$meta().setName("keywords").setContent("imba javascript language js").end(),
					tag$.$link().setHref('http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600').setRel('stylesheet').setType('text/css').end(),
					tag$.$link().setRel("stylesheet").setHref("/css/site.css").setMedia("screen").end(),
					tag$.$script().setText('DEPS = {};').end(),
					tag$.$script().setSrc("/vendor/ga.js").end()
				],2).end();
			};
			
			tag.prototype.body = function (){
				return tag$.$body().setId('site').setContent([
					tag$.$site_nav().setId('header').flag('awaken').end(),
					tag$.$home().setRoute('/home').end(),
					tag$.$guides().setRoute('/guides').end(),
					tag$.$docs().setRoute('/docs').end(),
					tag$.$blog().setRoute('/blog').end()
				],2).end();
			};
			
			tag.prototype.scripts = function (){
				var self = this, t0;
				return tag$.$div().flag('scripts').setContent([
					(function(t0) {
						for (var o = self.deps(), i = 0, keys = Object.keys(o), l = keys.length, res = []; i < l; i++){
							res.push(tag$.$script().setType("text/javascript").setSrc((keys[i] + '.dep')).end());
						};
						return res;
					})(t0),
					tag$.$script().setSrc("/vendor/hl.js").end(),
					tag$.$script().setSrc("/client.js").end()
				],0).end();
			};
			
			tag.prototype.render = function (){
				// dirty workarounds
				APP.setSite(this);
				this.setDeps({
					"/issues/all.json": true
				});
				
				APP.fetchDocument('/guides.md');
				APP.fetchDocument('/blog.json');
				var body = this.body();
				body.append(this.scripts());
				
				this.flag('light').setChildren([
					this.head(),
					body
				],1).synced();
				APP.setSite(null);
				return this;
			};
		});
		
		
		return tag$.defineTag('site-nav', function(tag){
			
			tag.prototype.toggleMenu = function (){
				return q$$('body').toggleFlag('menu');
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, t5, t6, t7;
				return this.setChildren(
					(t0 = this.$a=this.$a || tag$.$nav().flag('content')).setContent([
						(t1 = t0.$$a=t0.$$a || tag$.$a().flag('menu').setHandler('tap','toggleMenu',this)).setContent((t1.$$a = t1.$$a || tag$.$b()).end(),2).end(),
						(t2 = t0.$$b=t0.$$b || tag$.$a().flag('tab').flag('logo').setHref('/home')).setContent((t2.$$a = t2.$$a || tag$.$i()).setText('imba').end(),2).end(),
						(t0.$$c = t0.$$c || tag$.$span().flag('greedy')).end(),
						(t3 = t0.$$d=t0.$$d || tag$.$a().flag('tab').flag('home').setHref('/home')).setContent((t3.$$a = t3.$$a || tag$.$i()).setText('home').end(),2).end(),
						(t4 = t0.$$e=t0.$$e || tag$.$a().flag('tab').flag('guides').setHref('/guides')).setContent((t4.$$a = t4.$$a || tag$.$i()).setText('guides').end(),2).end(),
						(t5 = t0.$$f=t0.$$f || tag$.$a().flag('tab').flag('docs').setHref('/docs')).setContent((t5.$$a = t5.$$a || tag$.$i()).setText('docs').end(),2).end(),
						(t6 = t0.$$g=t0.$$g || tag$.$a().flag('tab').flag('blog').setHref('/blog')).setContent((t6.$$a = t6.$$a || tag$.$i()).setText('blog').end(),2).end(),
						
						(t7 = t0.$$h=t0.$$h || tag$.$a().flag('github').setHref('https://github.com/somebee/imba')).setContent((t7.$$a = t7.$$a || tag$.$i()).setText('github').end(),2).end()
					],2).end()
				,2).synced();
			};
			
			tag.prototype.awaken = function (){
				return this.schedule({fps: 0});
			};
		});
	
	})()

/***/ },
/* 64 */
/***/ function(module, exports) {

	(function(){
		
		
		tag$.defineTag('navmenu', function(tag){
			
			tag.prototype.onroute = function (e){
				document.body.classList.remove('menu');
				return this;
			};
		});
		
		tag$.defineTag('nav-list');
		
		tag$.defineTag('nav-link', function(tag){
			
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren((t0 = this.$a=this.$a || tag$.$a()).setHref(this.href()).setContent(this._content,3).end(),2).synced();
			};
		});
		
		return tag$.defineTag('toc', function(tag){
			
			tag.prototype.toggle = function (){
				return this.toggleFlag('collapsed');
			};
		});
	
	})()

/***/ },
/* 65 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('page', function(tag){
			tag.prototype.body = function (){
				return (this._body = this._body || tag$.$div().setRef('body',this)).setText("Content here").end();
			};
			
			tag.prototype.nav = function (){
				return (this._nav = this._nav || tag$.$div().setRef('nav',this)).setText("Navigation here").end();
			};
			
			tag.prototype.assemble = function (){
				return this.setChildren([
					this.nav(),
					this.body()
				],1).synced();
			};
			
			tag.prototype.ready = function (){
				return true;
			};
			
			tag.prototype.render = function (){
				// log 'render page',route
				var scoped = this.router().scoped(this.route(),this);
				this.flag('scoped',scoped);
				this.flag('selected',this.router().match(this.route(),this));
				
				if (!(scoped && this.ready())) { return this };
				return this.assemble();
			};
			
			tag.prototype.awaken = function (){
				return this.schedule({fps: 1});
			};
		});
	
	})()

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function shuffle(array){
			var counter = array.length,temp,index;
			
			// While there are elements in the array
			while (counter > 0){
				// Pick a random index
				index = Math.floor(Math.random() * counter);
				counter--; // Decrease counter by 1
				
				// And swap the last element with it
				temp = array[counter];
				array[counter] = array[index];
				array[index] = temp;
			};
			
			return array;
		};
		
		tag$.defineTag('pattern', function(tag){
			
			tag.prototype.build = function (){
				if (false) { return this };
				
				var parts = {tags: [],keywords: [],methods: []};
				var items = [];
				var lines = [];
				
				for (var o = Imba.Tag.prototype, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
					k = keys[i];items.push(("<em>" + k + "</em>"));
					parts.methods.push(("<em>" + k + "</em>"));
				};
				
				for (var i = 0, ary = iter$(HTML_TAGS), len_ = ary.length, k1; i < len_; i++) {
					// for own k,v of Imba.TAGS
					// if v and v:prototype isa Imba.Tag
					k1 = ary[i];
					items.push(("<u>&lt;" + k1 + "&gt;</u>"));
					parts.tags.push(("<u>&lt;" + k1 + "&gt;</u>"));
				};
				
				var words = "def if else elif while until for in of var let class extend export import tag global";
				
				for (var i = 0, ary = iter$(words.split(" ")), len_ = ary.length, k2; i < len_; i++) {
					k2 = ary[i];
					items.push(("<i>" + k2 + "</i>"));
					parts.keywords.push(("<i>" + k2 + "</i>"));
				};
				
				var shuffled = shuffle(items);
				var all = [].concat(shuffled);
				var count = items.length - 1;
				
				for (var len = 12, ln = 0; ln <= len; ln++) {
					var chars = 0;
					lines[ln] = [];
					while (chars < 300){
						var item = (shuffled.pop() || all[Math.floor(count * Math.random())]);
						if (item) {
							chars += item.length;
							lines[ln].push(item);
						} else {
							chars = 400;
						};
					};
				};
				
				this.dom().innerHTML = '<div>' + lines.map(function(ln) {
					return '<div class="line">' + ln.join(" ") + '</div>';
				}).join('') + '</div>';
				return this;
			};
			
			tag.prototype.awaken = function (){
				this.log('awakening pattern!!');
				return this;
				
				for (var i = 0, ary = iter$(q$('.line',this)), len = ary.length; i < len; i++) {
					var z = 20 + i * 10;
					// z = parseInt(-z + Math.random * z * 2)
					ary[i].css('transform',("translateZ(" + z + "px)"));
				};
				return this;
			};
		});
		
		return tag$.defineTag('home', 'page', function(tag){
			
			var todos = {demo: true,autorun: true};
			var clock = {demo: true,autorun: true};
			var reminders = {demo: true,autorun: true};
			var hero = {autorun: true};
			var canvas = {demo: true,autorun: true};
			
			tag.prototype.awaken = function (){
				var snippets = document.querySelectorAll('code[data-src]');
				for (var i = 0, ary = iter$(snippets), len = ary.length, snippet; i < len; i++) {
					snippet = ary[i];
					var src = snippet.getAttribute('data-src');
					// console.log 'fetching snippet for ',src
					DEPS[src] = {html: snippet.innerHTML};
				};
				
				return tag.__super__.awaken.apply(this,arguments);
			};
			
			tag.prototype.nav = function (){
				return null;
			};
			
			tag.prototype.body = function (){
				var t0, t1, t2, t3, t4;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this)).setContent([
					(t1 = t0.$$a=t0.$$a || tag$.$div().setId('hero').flag('dark')).setContent([
						(this._pattern = this._pattern || tag$.$pattern().setRef('pattern',this).flag('awaken')).end(),
						(t1.$$b = t1.$$b || tag$.$example().flag('hero').flag('dark').setSrc('/home/examples/hero.imba')).end()
					],2).end(),
					
					(t2 = this._content=this._content || tag$.$div().setRef('content',this)).setContent([
						(t2.$$a = t2.$$a || tag$.$marked().flag('section').flag('md').flag('welcome').flag('huge').flag('light')).setText("# Ruby, Python and React got together. Nine months later, Imba was born.\n\nImba is a new programming language for the web that compiles to highly \nperformant and readable JavaScript. It has language level support for defining, \nextending, subclassing, instantiating and rendering dom nodes. For a semi-complex \napplication like TodoMVC, it is more than \n[10 times faster than React](http://somebee.github.io/todomvc-render-benchmark/index.html) \nwith less code, and a much smaller library.\n\n---\n\n- ## Imba.inspiration\n  Imba brings the best from Ruby, Python, and React (+ JSX) together in a clean language and runtime.\n\n- ## Imba.interoperability\n  Imba compiles down to clean and readable JavaScript. Use any JS library in Imba and vica-versa.\n\n- ## Imba.performance\n  Build your application views using Imba's native tags for unprecedented performance.\n").end(),
						
						(t2.$$b = t2.$$b || tag$.$example().flag('dark').setHeading("Simple reminders").setSrc('/home/examples/reminders.imba')).end(),
						
						(t2.$$c = t2.$$c || tag$.$marked().flag('section').flag('md')).setText("## Reusable components\n\nA custom tag / component can maintain internal state and control how to render itself.\nWith the performance of DOM reconciliation in Imba, you can use one-way declarative binding,\neven for animations. Write all your views in a straight-forward linear fashion as if you could\nrerender your whole application on **every single** data/state change.").end(),
						
						(t2.$$d = t2.$$d || tag$.$example().flag('dark').setHeading("World clock").setSrc('/home/examples/clock.imba')).end(),
						
						(t2.$$e = t2.$$e || tag$.$marked().flag('section').flag('md')).setText("## Extend native tags\n\nIn addition to defining custom tags, you can also extend native tags, or inherit from them.\nBinding to dom events is as simple as defining methods on your tags; all events will be\nefficiently delegated and handled by Imba. Let's define a simple sketchpad...").end(),
						
						(t2.$$f = t2.$$f || tag$.$example().flag('dark').setHeading("Custom canvas").setSrc('/home/examples/canvas.imba')).end(),
						
						(t3 = t2.$$g=t2.$$g || tag$.$footer()).setContent(
							(t4 = t3.$$a=t3.$$a || tag$.$nav()).setContent([
								(t4.$$a = t4.$$a || tag$.$a().flag('button').flag('huge').flag('main').setHref('/install')).setText("Install").end(),
								(t4.$$b = t4.$$b || tag$.$a().flag('button').flag('huge').setHref('/guides')).setText("Learn more").end()
							],2).end()
						,2).end()
					],2).end()
				],2).end();
			};
			
			// def awaken
			// 	# awaken the snippets
			// 	schedule
			// 	for el in %(snippet)
			// 		el
			// 	self
			
			// def tick
			// 	log 'home.tick'
			// 	self
			
			// def assemble
			// 	return self if Imba.isClient
			// 	super
			// 	# flag('scoped',router.scoped(route,self))
			// 	# flag('selected',router.match(route,self))
		});
	
	})()

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		__webpack_require__(65);
		
		var Doc = __webpack_require__(57).Doc;
		
		tag$.defineTag('blog', 'page', function(tag){
			
			tag.prototype.doc = function (){
				var nr;
				if (nr = this.router().scoped(/blog\/(\d+)/,1)) {
					return Doc.get('/issues/' + nr + '.json');
				};
			};
			
			tag.prototype.meta = function (){
				return Doc.get('/blog.json');
			};
			
			tag.prototype.nav = function (){
				var t0, self = this, t1;
				return (t0 = self._nav=self._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent(
						(function(t1) {
							for (var i = 0, ary = iter$(APP.issues().object()), len = ary.length, res = []; i < len; i++) {
								res.push((t1['$$a' + i] = t1['$$a' + i] || tag$.$issue_li()).setObject(ary[i]).end());
							};
							return res;
						})(t1)
					,3).end()
				,2).end();
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this).flag('light')).setContent([
					(this.doc()) ? (
						(t0.$$a = t0.$$a || tag$.$issue()).setObject(this.doc()).end()
					) : void(0)
				],1).end();
			};
		});
		
		return tag$.defineTag('blogpost', function(tag){
			
			tag.prototype.render = function (){
				var object_;
				if (!(object_ = this.object()) && object_.ready  &&  object_.ready()) { return this };
				return this.flag('md').setBody((this.object().body())).synced();
			};
			
			tag.prototype.setBody = function (body){
				if (body != this._body) {
					this._body = body;
					this.dom().innerHTML = body;
					if (Imba.isClient()) this.reawaken();
				};
				return this;
			};
			
			tag.prototype.reawaken = function (){
				for (var i = 0, ary = iter$(q$('._snippet',this)), len = ary.length; i < len; i++) {
					ary[i];
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		__webpack_require__(65);
		
		function Guide(path){
			this._path = path;
			this._ready = false;
			this.fetch();
			this;
		};
		
		var cache = {};
		
		Guide.get = function (path){
			var $1;
			var cache = APP.cache();
			return cache[($1 = 'guide-' + path)] || (cache[$1] = new this(path));
		};
		
		
		
		Guide.prototype.path = function(v){ return this._path; }
		Guide.prototype.setPath = function(v){ this._path = v; return this; };
		
		Guide.prototype.ready = function (){
			return this._ready;
		};
		
		Guide.prototype.fetch = function (){
			var self = this;
			if (false) {
				// console.log 'fetch Guide on server',path
				return APP.fetchDocument(self._path + '.md',function(res) {
					// console.log 'fetch Guide on server done',path
					return self.load(res);
				});
			};
			
			return self._promise || (self._promise = APP.fetchDocument(self._path + '.md',function(res) {
				return self.load(res);
			}));
		};
		
		Guide.prototype.load = function (doc){
			this._object = doc;
			this._meta = doc.meta || {};
			this._ready = true;
			Imba.emit(this,'ready');
			return this;
		};
		
		Guide.prototype.title = function (){
			return this._object.title || 'path';
		};
		
		Guide.prototype.toc = function (){
			return this._object && this._object.toc[0];
		};
		
		Guide.prototype.body = function (){
			return this._object && this._object.body;
		};
		
		
		tag$.defineTag('guide-toc', 'toc', function(tag){
			
			
			
			tag.prototype.toc = function(v){ return this._toc; }
			tag.prototype.setToc = function(v){ this._toc = v; return this; };
			
			
			tag.prototype.level = function(v){ return this.getAttribute('level'); }
			tag.prototype.setLevel = function(v){ this.setAttribute('level',v); return this; };
			
			
			tag.prototype.route = function(v){ return this.getAttribute('route'); }
			tag.prototype.setRoute = function(v){ this.setAttribute('route',v); return this; };
			
			tag.prototype.toc = function (){
				return this._toc || this.object().toc();
			};
			
			tag.prototype.route = function (){
				return ("" + (this.object().path()) + "#" + (this.toc().slug));
			};
			
			tag.prototype.toggle = function (){
				return this.toggleFlag('collapsed');
			};
			
			tag.prototype.render = function (){
				var t0, t1, self = this, t2, t3;
				if (!this.object().ready()) { return this };
				
				this.reroute();
				
				return this.flag('entry').setLevel((this.toc().level)).setChildren([
					this.toc().children.length && this.toc().level < 2 ? (Imba.static([
						(t0 = this.$a=this.$a || tag$.$div().flag('header').setHandler('tap','toggle',this)).setContent(
							(t1 = t0.$$a=t0.$$a || tag$.$a()).setHref(this.route()).setContent(this.toc().title,3).end()
						,2).end(),
						(t2 = self.$b=self.$b || tag$.$div().flag('content')).setContent(
							(function(t2) {
								for (var i = 0, ary = iter$(self.toc().children), len = ary.length, res = []; i < len; i++) {
									res.push((t2['$$a' + i] = t2['$$a' + i] || tag$.$guide_toc()).setToc(ary[i]).setObject(self.object()).end());
								};
								return res;
							})(t2)
						,3).end()
					],2)) : (
						(t3 = self.$c=self.$c || tag$.$a()).setHref(self.route()).setContent(self.toc().title,3).end()
					)
				],1).synced();
			};
		});
		
		
		tag$.defineTag('guide', function(tag){
			
			tag.prototype.render = function (){
				var object_;
				if (!(object_ = this.object()) && object_.ready  &&  object_.ready()) { return this };
				return this.flag('md').setBody((this.object().body())).synced();
			};
			
			tag.prototype.setBody = function (body){
				if (body != this._body) {
					this._body = body;
					this.dom().innerHTML = body;
					if (Imba.isClient()) this.reawaken();
				};
				return this;
			};
			
			tag.prototype.reawaken = function (){
				for (var i = 0, ary = iter$(q$('._snippet',this)), len = ary.length; i < len; i++) {
					ary[i];
				};
				return this;
			};
		});
		
		
		return tag$.defineTag('guides', 'page', function(tag){
			
			tag.prototype.nav = function (){
				var t0, t1;
				return (t0 = this._nav=this._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent([
						(t1.$$a = t1.$$a || tag$.$guide_toc()).setObject(Guide.get('/guides')).end(),
						(t1.$$b = t1.$$b || tag$.$guide_toc()).setObject(Guide.get('/guides/language')).end()
					// <guide-toc[Guide.get('/guides/tips')]>
					],2).end()
				,2).end();
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this).flag('light')).setContent([
					(this.guide()) ? ((t0.$$a = t0.$$a || tag$.$guide()).setObject(this.guide()).end()) : void(0)
				// <guide@doc.md.l src="{router.path}">
				],1).end();
			};
			
			tag.prototype.onroute = function (e){
				// log 'onroute guides',router.hash
				var self = this;
				e.halt();
				
				var scroll = function() {
					var el;
					if (el = self.first('#' + self.router().hash())) {
						el.dom().scrollIntoView(true);
						self._scrollFreeze = window.scrollY;
						return el;
					};
					return false;
				};
				
				if (self.router().hash()) {
					self.render();
					scroll() || setTimeout(scroll,20,function() {  });
				};
				
				
				return self;
			};
			
			tag.prototype.guide = function (){
				if (this.router().scoped('/guides')) {
					return Guide.get(this.router().path());
				};
			};
			
			
			tag.prototype.awaken = function (){
				var self = this;
				if (Imba.isClient()) {
					// @doc = %%(guide)
					self.schedule({fps: 1});
					window.addEventListener('scroll',function() {
						// console.log 'check scrolling'
						return self.scrolled();
					});
				};
				return self;
			};
			
			tag.prototype.scrolled = function (){
				if (!this.hasFlag('scoped')) { return };
				
				var items = q$('[id]',this);
				var match;
				
				// should probably cache these periodically
				var scrollTop = window.scrollY;
				var wh = window.innerHeight;
				var dh = document.body.scrollHeight;
				
				if (this._scrollFreeze >= 0) {
					var diff = Math.abs(scrollTop - this._scrollFreeze);
					if (diff < 50) { return this };
					this._scrollFreeze = -1;
				};
				
				var scrollBottom = dh - (scrollTop + wh);
				
				// console.log scrollTop,wh,dh,scrollBottom
				
				if (scrollBottom == 0) {
					match = items.last();
				} else {
					for (var i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
						item = ary[i];
						var t = (item.dom().offsetTop + 30 + 60); // hack
						var dist = scrollTop - t;
						// console.log "{item.id} {t} {dist}"
						
						if (dist < 0) {
							match = item;break;
						};
					};
				};
				
				if (match) {
					// console.log "match is {match.id}"
					if (this._hash != match.id()) {
						this._hash = match.id();
						this.router().go('#' + this._hash,{},true);
						this.render();
					};
				};
				return this;
			};
			
			tag.prototype.tick = function (){
				this.render();
				return this;
			};
		});
	
	})()

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function pathToAnchor(path){
			return 'api-' + path.replace(/\./g,'_').replace(/\#/g,'__');
		};
		
		tag$.defineTag('api-desc', function(tag){
			
			tag.prototype.setHtml = function (html){
				if (html != this._html) {
					this.dom().innerHTML = this._html = html;
				};
				return this;
			};
		});
		
		tag$.defineTag('api-ref', function(tag){
			
			tag.prototype.render = function (){
				return this.synced();
			};
		});
		
		tag$.defineTag('api-item');
		
		tag$.defineTag('api-path', 'span', function(tag){
			
			tag.prototype.build = function (){
				var object_;
				var items = [];
				if ((typeof (object_ = this.object())=='string'||object_ instanceof String)) {
					this.setHtml(this.object().replace(/\b([\w]+|\.|\#)\b/g,function(m,i) {
						if (i == '.' || i == '#') {
							return ("<i>" + i + "</i>");
						} else if (i[0] == i[0].toUpperCase()) {
							return ("<b class='const'>" + i + "</b>");
						} else {
							return ("<b class='id'>" + i + "</b>");
						};
					}));
				};
				return this;
			};
		});
		
		
		tag$.defineTag('api-link', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren([
					(this.$a = this.$a || tag$.$api_path().flag('value')).setObject(this.object().value).end(),
					(t0 = this.$b=this.$b || tag$.$span().flag('desc')).setContent(this.object().desc,3).end()
				],2).synced();
			};
		});
		
		tag$.defineTag('api-return', 'api-link');
		
		tag$.defineTag('api-class', 'api-item', function(tag){
			
			
			tag.prototype.__object = {watch: 'parse',name: 'object'};
			tag.prototype.object = function(v){ return this._object; }
			tag.prototype.setObject = function(v){
				var a = this.object();
				if(v != a) { this._object = v; }
				if(v != a) { this.parse && this.parse(v,a,this.__object) }
				return this;
			};
			
			tag.prototype.parse = function (){
				for (var i = 0, ary = iter$(this.object()['.']), len = ary.length, m, res = []; i < len; i++) {
					m = ary[i];
					if (!m.desc) { continue; };
					res.push(m);
				};
				this._statics = res;
				for (var i = 0, ary = iter$(this.object()['#']), len = ary.length, m1, res = []; i < len; i++) {
					m1 = ary[i];
					if (!m1.desc) { continue; };
					res.push(m1);
				};
				this._methods = res;
				this._properties = [];
				return this;
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, self = this, t5, t6, t7;
				return this.setChildren([
					(this.$a = this.$a || tag$.$span().flag('toc-anchor')).setId(pathToAnchor(this.object().namepath)).end(),
					(t0 = this.$b=this.$b || tag$.$div().flag('header')).setContent((t1 = t0.$$a=t0.$$a || tag$.$div().flag('title')).setContent((t1.$$a = t1.$$a || tag$.$api_path()).setObject(this.object().namepath).end(),2).end(),2).end(),
					(this.$c = this.$c || tag$.$api_desc()).setHtml(this.object().html).end(),
					(this.object().ctor) ? (
						(t2 = this.$d=this.$d || tag$.$div().flag('content').flag('ctor')).setContent(
							(t2.$$a = t2.$$a || tag$.$api_method()).setPath((this.object().namepath + '.new')).setObject(this.object().ctor).end()
						,2).end()
					) : void(0),
					
					(t3 = self.$e=self.$e || tag$.$div().flag('content')).setContent([
						(this._statics.length > 0) ? (
							(t4 = t3.$$a=t3.$$a || tag$.$div().flag('section')).setContent([
								(t4.$$a = t4.$$a || tag$.$h2().flag('header')).setText('Static Methods').end(),
								(t5 = t4.$$b=t4.$$b || tag$.$div().flag('content').flag('list')).setContent((function(t5) {
									for (var i = 0, ary = iter$(self._statics), len = ary.length, res = []; i < len; i++) {
										res.push((t5['$$a' + i] = t5['$$a' + i] || tag$.$api_method().flag('doc')).setIname(self.object().namepath).setObject(ary[i]).end());
									};
									return res;
								})(t5),3).end()
							],2).end()
						) : void(0),
						
						(self._methods.length > 0) ? (
							(t6 = t3.$$b=t3.$$b || tag$.$div().flag('section')).setContent([
								(t6.$$a = t6.$$a || tag$.$h2().flag('header')).setText('Instance Methods').end(),
								(t7 = t6.$$b=t6.$$b || tag$.$div().flag('content').flag('list')).setContent((function(t7) {
									for (var i = 0, ary = iter$(self._methods), len = ary.length, res = []; i < len; i++) {
										res.push((t7['$$a' + i] = t7['$$a' + i] || tag$.$api_method().flag('doc')).setIname(self.object().iname).setObject(ary[i]).end());
									};
									return res;
								})(t7),3).end()
							],2).end()
						) : void(0)
					],1).end()
				],1).synced();
			};
		});
		
		tag$.defineTag('api-value', function(tag){
			
			tag.prototype.render = function (){
				var object_, $1;
				if (this.object().type) {
					this.flag(this.object().type).setChildren(
						this.object().value
					,3).synced();
				} else if ((typeof (object_ = this.object())=='string'||object_ instanceof String)) {
					this.flag('str').setText(this.object()).synced();
				} else if ((typeof ($1 = this.object())=='number'||$1 instanceof Number)) {
					this.flag('num').setText(this.object()).synced();
				};
				return this;
			};
		});
		
		
		tag$.defineTag('api-param', function(tag){
			
			tag.prototype.type = function (){
				return this.object().type;
			};
			
			tag.prototype.render = function (){
				var self = this, t0, t1;
				return this.flag(self.type()).setChildren([
					self.type() == 'NamedParams' ? (
						(function(self) {
							for (var i = 0, ary = iter$(self.object().nodes), len = ary.length, res = []; i < len; i++) {
								res.push((self['$a' + i] = self['$a' + i] || tag$.$api_param()).setObject(ary[i]).end());
							};
							return res;
						})(self)
					) : (Imba.static([
						(t0 = self.$b=self.$b || tag$.$div().flag('name')).setContent(self.object().name,3).end(),
						(self.object().defaults) ? (Imba.static([
							(t1 = self.$c=self.$c || tag$.$i()).setContent([self.type() == 'NamedParam' ? (': ') : (' = ')],1).end(),
							(self.$d = self.$d || tag$.$api_value()).setObject(self.object().defaults).end()
						],2)) : void(0)
					],3))
				],1).synced();
			};
		});
		
		tag$.defineTag('api-method', 'api-item', function(tag){
			
			
			
			tag.prototype.iname = function(v){ return this._iname; }
			tag.prototype.setIname = function(v){ this._iname = v; return this; };
			
			
			tag.prototype.path = function(v){ return this._path; }
			tag.prototype.setPath = function(v){ this._path = v; return this; };
			
			tag.prototype.tags = function (){
				var t0;
				return (t0 = this._tags=this._tags || tag$.$div().setRef('tags',this)).setContent([
					(this.object().deprecated) ? (
						(t0.$$a = t0.$$a || tag$.$div().flag('deprecated').flag('red')).setText('Method is deprecated').end()
					) : void(0),
					(this.object().return) ? ((t0.$$b = t0.$$b || tag$.$api_return().setName('returns')).setObject(this.object().return).end()) : void(0)
				],1).end();
			};
			
			tag.prototype.path = function (){
				return this._path || (this.iname() + '.' + this.object().name);
			};
			
			tag.prototype.slug = function (){
				return pathToAnchor(this.object().namepath);
			};
			
			tag.prototype.render = function (){
				var t0, self = this, t1;
				return this.flag('deprecated',this.object().deprecated).setChildren([
					(this.$a = this.$a || tag$.$span().flag('toc-anchor')).setId(this.slug()).end(),
					(t0 = self.$b=self.$b || tag$.$div().flag('header')).setContent([
						(t0.$$a = t0.$$a || tag$.$api_path()).setObject(this.path()).end(),
						(t1 = t0.$$b=t0.$$b || tag$.$div().flag('params')).setContent((function(t1) {
							for (var i = 0, ary = iter$(self.object().params), len = ary.length, res = []; i < len; i++) {
								res.push((t1['$$a' + i] = t1['$$a' + i] || tag$.$api_param()).setObject(ary[i]).end());
							};
							return res;
						})(t1),3).end(),
						(t0.$$c = t0.$$c || tag$.$div().flag('grow')).end()
					],2).end(),
					(self.$c = self.$c || tag$.$api_desc().flag('md')).setHtml(self.object().html).end(),
					self.tags()
				],1).synced();
			};
		});
		
		tag$.defineTag('doc-link', 'a', function(tag){
			
			tag.prototype.render = function (){
				this.setHref(("/docs#" + pathToAnchor(this.object().namepath))).setChildren((this.$a = this.$a || tag$.$api_path()).setObject(this.object().namepath).end(),2).synced();
				return tag.__super__.render.apply(this,arguments);
			};
			
			tag.prototype.ontap = function (){
				tag.__super__.ontap.apply(this,arguments);
				return this.up(q$('._docs',this)).refocus();
			};
		});
		
		tag$.defineTag('doc-group', 'toc', function(tag){
			
			tag.prototype.ontap = function (){
				return this.toggleFlag('collapsed');
			};
		});
		
		
		return tag$.defineTag('docs', 'page', function(tag){
			
			
			tag.prototype.__version = {'default': '0.14.1',name: 'version'};
			tag.prototype.version = function(v){ return this._version; }
			tag.prototype.setVersion = function(v){ this._version = v; return this; }
			tag.prototype._version = '0.14.1';
			
			
			tag.prototype.roots = function(v){ return this._roots; }
			tag.prototype.setRoots = function(v){ this._roots = v; return this; };
			
			tag.prototype.src = function (){
				return ("/api/" + this.version() + ".json");
			};
			
			tag.prototype.docs = function (){
				return this._docs;
			};
			
			tag.prototype.awaken = function (){
				this.load();
				this.schedule();
				return this;
			};
			
			tag.prototype.build = function (){
				this.load();
				return tag.__super__.build.apply(this,arguments);
			};
			
			tag.prototype.load = function (){
				var self = this;
				if (false) {
					// return self
					APP.fetchDocument(self.src(),function(res) {
						self._docs = JSON.parse(JSON.stringify(res));
						return self.generate();
					});
					return self;
				};
				
				return self._request || (self._request = APP.fetchDocument(self.src(),function(res) {
					DOCS = self._docs = res;
					DOCMAP = self._docs.entities;
					self.generate();
					return self.loaded();
				}));
			};
			
			tag.prototype.loaded = function (){
				var el;
				this.render();
				// really?
				if (document.location.hash) {
					if (el = this.first(document.location.hash)) {
						// console.log 'should scroll here?!?!?!',el
						el.dom().scrollIntoView();
					};
				};
				return this;
			};
			
			tag.prototype.refocus = function (){
				var el;
				if (el = this.first(document.location.hash)) {
					el.dom().scrollIntoView();
				};
				return this;
			};
			
			tag.prototype.lookup = function (path){
				return this.docs().entities[path];
			};
			
			tag.prototype.generate = function (){
				this._roots = [];
				var ents = this._docs.entities;
				
				for (var o = this.docs().entities, item, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
					item = o[keys[i]];if (item.type == 'class' || keys[i] == 'Imba') {
						item['.'] = (item['.'] || []).sort().map(function(path) { return ents[path]; }).filter(function(v) { return v.type == 'method' && v.desc; });
						item['#'] = (item['#'] || []).sort().map(function(path) { return ents[path]; }).filter(function(v) { return v.type == 'method' && v.desc; });
						
						if (item.desc) { this._roots.push(item) };
					};
				};
				return this;
			};
			
			tag.prototype.render = function (){
				if (!(this.docs())) { return this };
				return tag.__super__.render.apply(this,arguments);
			};
			
			tag.prototype.body = function (){
				var self = this, t0;
				return (t0 = self._body=self._body || tag$.$div().setRef('body',this).flag('light')).setContent(
					(function(t0) {
						for (var i = 0, ary = iter$(self.roots()), len = ary.length, res = []; i < len; i++) {
							res.push((t0['$$a' + i] = t0['$$a' + i] || tag$.$api_class().flag('doc').flag('l')).setObject(ary[i]).end());
						};
						return res;
					})(t0)
				,3).end();
			};
			tag.prototype.nav = function (){
				var t0, self = this, t1;
				return (t0 = self._nav=self._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent(
						(function(t1) {
							var t2, t3, t4, t5, t6;
							for (var i = 0, ary = iter$(self.roots()), len = ary.length, root, res = []; i < len; i++) {
								root = ary[i];
								res.push((t2 = t1['$$a' + i]=t1['$$a' + i] || tag$.$doc_group().flag('class').flag('section').flag('compact')).setContent([
									(t3 = t2.$$a=t2.$$a || tag$.$div().flag('header')).setContent((t3.$$a = t3.$$a || tag$.$doc_link().flag('class')).setObject(root).end(),2).end(),
									(t4 = t2.$$b=t2.$$b || tag$.$div().flag('content')).setContent([
										(t5 = t4.$$a=t4.$$a || tag$.$div().flag('static')).setContent(
											(function(t5) {
												var t6;
												for (var j = 0, items = iter$(root['.']), len_ = items.length, meth, res1 = []; j < len_; j++) {
													meth = items[j];
													if (!meth.desc) { continue; };
													res1.push((t6 = t5['$$a' + j]=t5['$$a' + j] || tag$.$div().flag('entry')).setContent((t6.$$a = t6.$$a || tag$.$doc_link()).setObject(meth).end(),2).end());
												};
												return res1;
											})(t5)
										,3).end(),
										(t6 = t4.$$b=t4.$$b || tag$.$div().flag('instance')).setContent(
											(function(t6) {
												var t7;
												for (var j = 0, items = iter$(root['#']), len_ = items.length, meth, res1 = []; j < len_; j++) {
													meth = items[j];
													if (!meth.desc) { continue; };
													res1.push((t7 = t6['$$a' + j]=t6['$$a' + j] || tag$.$div().flag('entry')).setContent((t7.$$a = t7.$$a || tag$.$doc_link()).setObject(meth).end(),2).end());
												};
												return res1;
											})(t6)
										,3).end()
									],2).end()
								],2).end());
							};
							return res;
						})(t1)
					,3).end()
				,2).end();
			};
		});
		
		
	
	})()

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// externs;
		
		// var hljs = require 'highlight.js'
		
		tag$.defineTag('tool', 'button', function(tag){
			
			
			tag.prototype.action = function(v){ return this._action; }
			tag.prototype.setAction = function(v){ this._action = v; return this; };
			
			tag.prototype.render = function (){
				return this.flag('sym').synced();
			};
			
			tag.prototype.onclick = function (e){
				this.log('button click',e);
				return e.halt();
			};
			
			tag.prototype.ontouchstart = function (e){
				this.log('touchstart');
				true;
				return e.event().preventDefault();
			};
		});
		
		tag$.defineTag('snippet-hint', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				return this.setText("I am a hint!!").synced();
			};
		});
		
		tag$.defineTag('overlays', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				var root;
				if (root = this.view()._root) {
					var left = 0,top = 0,el = root.dom();
					
					while (el && !el.contains(this._dom)){
						left += el.offsetLeft;
						top += el.offsetTop - el.scrollTop;
						el = el.parentNode;
					};
					
					this._dom.style.left = left + 'px';
					this._dom.style.top = top + 'px';
				};
				
				return this;
			};
		});
		
		tag$.defineTag('hint-label', function(tag){
			
			tag.prototype.setLabel = function (text){
				if (text != this._label) {
					this._label = text;
					this.dom().innerHTML = text;
				};
				return this;
			};
		});
		
		tag$.defineTag('overlay-hint', function(tag){
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.__row = {watch: 'rowDidSet',name: 'row'};
			tag.prototype.row = function(v){ return this._row; }
			tag.prototype.setRow = function(v){
				var a = this.row();
				if(v != a) { this._row = v; }
				if(v != a) { this.rowDidSet && this.rowDidSet(v,a,this.__row) }
				return this;
			};
			
			tag.prototype.__col = {watch: 'colDidSet',name: 'col'};
			tag.prototype.col = function(v){ return this._col; }
			tag.prototype.setCol = function(v){
				var a = this.col();
				if(v != a) { this._col = v; }
				if(v != a) { this.colDidSet && this.colDidSet(v,a,this.__col) }
				return this;
			};
			
			tag.prototype.__len = {watch: 'lenDidSet',name: 'len'};
			tag.prototype.len = function(v){ return this._len; }
			tag.prototype.setLen = function(v){
				var a = this.len();
				if(v != a) { this._len = v; }
				if(v != a) { this.lenDidSet && this.lenDidSet(v,a,this.__len) }
				return this;
			};
			
			tag.prototype.rowDidSet = function (new$,old){
				var val = ("" + (this.object().row() * this.view().lineHeight()) + "px");
				return this._dom.style.top = val;
			};
			
			tag.prototype.colDidSet = function (new$,old){
				var val = ("" + (this.object().col() * this.view().charWidth()) + "px");
				return this._dom.style.left = val;
			};
			
			tag.prototype.lenDidSet = function (new$,old){
				var width = ("" + (new$ * this.view().charWidth()) + "px");
				return this._dom.style.width = width;
			};
			
			tag.prototype.render = function (){
				// console.log 'hint at',object.row
				var reg = this.object().region();
				
				if (reg) {
					this.setRow(this.object().row());
					this.setCol(this.object().col());
					this.setLen(reg.size());
				};
				
				return this.flag('warn').flag('global',(!reg)).setType((this.object().type())).setChildren(
					(this.$a = this.$a || tag$.$hint_label().flag('label')).setLabel(this.object().label()).end()
				,2).synced();
			};
		});
		
		tag$.defineTag('jsview', function(tag){
			
			tag.prototype.render = function (){
				return this.setChildren((this._code = this._code || tag$.$code().setRef('code',this)).end(),2).synced();
			};
			
			tag.prototype.load = function (code,cb){
				// should compile bare
				var self = this;
				code = code.replace(/\/\/\# sourceMapping(.*)$/,'');
				code = code.replace(/^\(function\(\)\{\n/,'');
				code = code.replace(/\n?\}\)\(\)\n?$/,'');
				// code = code.replace(/^\t/mg,'')
				this._code.textContent = code;
				
				this.flag('huge',code.length > 1000);
				
				setTimeout(function() {
					hljs.configure({classPrefix: ''});
					var hl = hljs.highlight('javascript',code);
					self._code.setHtml(hl.value);
					return cb && cb(self);
				},0);
				
				return self;
			};
		});
		
		tag$.defineTag('console', function(tag){
			
			
			tag.prototype.editor = function(v){ return this._editor; }
			tag.prototype.setEditor = function(v){ this._editor = v; return this; };
			
			tag.prototype.reset = function (){
				this.empty();
				return this;
			};
			
			tag.prototype.log = function (val){
				console.log.apply(console,arguments);
				
				if (this.editor()) {
					this.editor().flag('console');
				};
				// console.log 'logging val',val
				
				if (val == this) {
					return;
				};
				
				if (val && val.dom) {
					val = val.dom().outerHTML;
				} else if (val instanceof Object) {
					val = JSON.stringify(val);
				};
				
				if (val != undefined) {
					this.append(tag$.$div().flag('json').setContent(val,0).end());
				};
				
				return;
			};
		});
		
		
		// this is basically like an editor
		tag$.defineTag('snippet', function(tag){
			
			var counter = 0;
			
			
			
			tag.prototype.imba = function(v){ return this._imba; }
			tag.prototype.setImba = function(v){ this._imba = v; return this; };
			
			
			tag.prototype.config = function(v){ return this._config; }
			tag.prototype.setConfig = function(v){ this._config = v; return this; };
			
			tag.prototype.__src = {watch: 'reload',name: 'src'};
			tag.prototype.src = function(v){ return this._src; }
			tag.prototype.setSrc = function(v){
				var a = this.src();
				if(v != a) { this._src = v; }
				if(v != a) { this.reload && this.reload(v,a,this.__src) }
				return this;
			};
			
			
			
			tag.prototype.heading = function(v){ return this.getAttribute('heading'); }
			tag.prototype.setHeading = function(v){ this.setAttribute('heading',v); return this; };
			
			
			tag.prototype.layout = function(v){ return this.getAttribute('layout'); }
			tag.prototype.setLayout = function(v){ this.setAttribute('layout',v); return this; };
			
			
			tag.prototype.tab = function(v){ return this.getAttribute('tab'); }
			tag.prototype.setTab = function(v){ this.setAttribute('tab',v); return this; };
			
			
			tag.prototype.__active = {watch: 'activeDidSet',name: 'active'};
			tag.prototype.active = function(v){ return this._active; }
			tag.prototype.setActive = function(v){
				var a = this.active();
				if(v != a) { this._active = v; }
				if(v != a) { this.activeDidSet && this.activeDidSet(v,a,this.__active) }
				return this;
			};
			
			tag.prototype.id = function (){
				var dom_;
				return (dom_ = this.dom()).id || (dom_.id = ("snippet" + (counter++)));
			};
			
			tag.prototype.activeDidSet = function (bool){
				return bool ? (this.schedule({fps: 60})) : (this.unschedule());
			};
			
			tag.prototype.input = function (){
				return (this._input = this._input || tag$.$imcaptor().setRef('input',this)).end();
			};
			
			tag.prototype.view = function (){
				return this._view || (this._view = (this._view = this._view || tag$.$imview().setRef('view',this)).setInput(this.input()).end());
			};
			
			tag.prototype.build = function (){
				
				var self = this, t0, t1, t2, t3, t4, t5;
				if (false) {
					if (self.src() && self.src().match(/\.imba$/)) {
						APP.fetchDocument(self.src(),function(res) {
							var v_;
							return (self.setImba(v_ = res.html),v_);
						});
					};
					// prerender shell
					self.setChildren([
						(t0 = self._main=self._main || tag$.$section().setRef('main',self)).setContent([
							(t1 = self._header=self._header || tag$.$header().setRef('header',self)).setContent([
								(t2 = t1.$$a=t1.$$a || tag$.$div().flag('title').flag('path')).setContent(self.heading(),3).end(),
								(t3 = t1.$$b=t1.$$b || tag$.$div().flag('tools')).setContent([
									(t3.$$a = t3.$$a || tag$.$tool().flag('reset').setTitle('reset').setHandler('tap','reset',self)).setText('reset').end(),
									(t3.$$b = t3.$$b || tag$.$tool().flag('js').setTitle('show js').setHandler('tap','toggleJS',self)).setText('show js').end(),
									(t3.$$c = t3.$$c || tag$.$tool().flag('run').setTitle('run').setHandler('tap','run',self)).setText('run').end()
								],2).end()
							],2).end(),
							(t4 = self._view=self._view || tag$.$div().setRef('view',self)).setContent((t5 = t4.$$a=t4.$$a || tag$.$code().flag('imbacode')).dataset('src',(self.src())).setContent(self.imba(),3).end(),2).end()
						],2).end(),
						(self._inspector = self._inspector || tag$.$div().setRef('inspector',self)).end()
					],2).synced();
					return self;
				};
				
				tag.__super__.build.apply(self,arguments);
				if (self.src()) { return self.reload() };
			};
			
			tag.prototype.setConfig = function (cfg){
				var v_;
				if (cfg != this._options) {
					this._options = cfg;
					if (cfg.title) { (this.setHeading(v_ = cfg.title),v_) };
				};
				return this;
			};
			
			tag.prototype.copts = function (){
				return this._copts || (this._copts = {
					bare: false,
					standalone: false,
					sourceMapInline: true,
					filename: ("" + this.id() + ".imba"),
					targetPath: ("" + this.id() + ".js"),
					sourcePath: ("" + this.id() + ".imba")
				});
			};
			
			tag.prototype.option = function (key){
				return this._options ? (this._options[key]) : (null);
			};
			
			tag.prototype.configure = function (o){
				this._options = o;
				return this.render();
			};
			
			tag.prototype.awaken = function (){
				var config = {};
				try {
					var code = q$$('.imbacode',this).dom().innerHTML;
				} catch (e) { };
				
				if (code) {
					config.html = code;
					this.view().load(null,{html: code});
					this.configure(config);
				};
				
				return this;
			};
			
			tag.prototype.load = function (code,o){
				if(o === undefined) o = {};
				if (code || o.html) { this.view().load(code,o) };
				return this;
			};
			
			tag.prototype.code = function (){
				return this.view().code();
			};
			
			tag.prototype.compile = function (code,o,blk){
				// cache latest compilation - return?
				if(blk==undefined && typeof o == 'function') blk = o,o = this.copts();
				if(o==undefined) o = this.copts();
				return Scrimbla.worker().compile(code,o,blk);
			};
			
			tag.prototype.overlays = function (){
				for (var i = 0, ary = iter$(this.view().hints()), len = ary.length, hint, res = []; i < len; i++) {
					hint = ary[i];
					if (!hint.active()) { continue; };
					res.push((this['_' + 'hint' + i] = this['_' + 'hint' + i] || tag$.$overlay_hint()).setView(this.view()).setObject(hint).end());
				};
				return res;
			};
			
			tag.prototype.toggleJS = function (){
				if (this.tab() != 'js') {
					this.showjs();
				} else {
					this.setTab('imba');
				};
				return this;
			};
			
			tag.prototype.oninputfocus = function (e){
				VIEW = this; // hack
				this.flag('focus');
				return (this.setActive(true),true);
			};
			
			tag.prototype.oninputblur = function (e){
				this.unflag('focus');
				var rel = e.event().relatedTarget;
				if (!(rel && this.dom().contains(rel))) {
					this.unflag('focus');
					this.setActive(false);
				};
				return this;
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, t5;
				if (false) { return this };
				
				return this.setChildren([
					this._input,
					(t0 = this._main=this._main || tag$.$section().setRef('main',this)).setContent([
						(t1 = this._header=this._header || tag$.$header().setRef('header',this)).setContent([
							(t2 = t1.$$a=t1.$$a || tag$.$div().flag('title').flag('path')).setContent(this.heading(),3).end(),
							(t3 = t1.$$b=t1.$$b || tag$.$div().flag('tools')).setContent([
								(t3.$$a = t3.$$a || tag$.$tool().flag('reset').setTitle('reset').setHandler('tap','reset',this)).setText('reset').end(),
								(t3.$$b = t3.$$b || tag$.$tool().flag('js').setTitle('show js').setHandler('tap','toggleJS',this)).setText('show js').end(),
								(t3.$$c = t3.$$c || tag$.$tool().flag('run').setTitle('run').setHandler('tap','run',this)).setText('run').end()
							],2).end()
						],2).end(),
						(t4 = this._overlays=this._overlays || tag$.$overlays().setRef('overlays',this)).setView(this.view()).setContent(this.overlays(),3).end(),
						(this._jsview = this._jsview || tag$.$jsview().setRef('jsview',this)).end(),
						this._view.end(),
						(this._console = this._console || tag$.$console().setRef('console',this).flag('dark')).setEditor(this).end()
					],1).end(),
					(t5 = this._inspector=this._inspector || tag$.$div().setRef('inspector',this)).setContent(this.playground(),3).end()
				],1).synced();
			};
			
			tag.prototype.sandbox = function (){
				return (this._sandbox = this._sandbox || tag$.$sandbox().setRef('sandbox',this).flag('playground')).setEditor(this).end();
			};
			
			tag.prototype.playground = function (){
				return this.sandbox();
			};
			
			tag.prototype.reload = function (){
				var self = this;
				if (!self._built) { return };
				
				if (DEPS[self.src()]) {
					var res = DEPS[self.src()];
					self.view().load(null,{html: res.html,filename: self.src()});
					if (self.autorun()) {
						setTimeout(function() { return self.run(); },50);
					};
					return self;
				};
				
				// get imba document?!?
				APP.fetchDocument(self.src(),function(res) {
					self.view().load(res.body,{filename: self.src()});
					if (self.autorun()) {
						return setTimeout(function() { return self.run(); },50);
					};
				});
				return self;
			};
			
			tag.prototype.onrun = function (){
				return this.run();
			};
			
			tag.prototype.autorun = function (){
				return false;
			};
			
			tag.prototype.oneditedasync = function (){
				this.flag('dirty');
				return this;
			};
			
			tag.prototype.onsave = function (){
				this.view().hints().clear();
				return this.run();
			};
			
			tag.prototype.reset = function (e){
				this._console.reset();
				if (this._options.html) {
					this.view().load(null,{html: this._options.html});
				};
				if (e) {
					e.cancel();
				};
				this.unflag('dirty');
				this.view().caret().normalize().dirty();
				return this;
			};
			
			tag.prototype.run = function (){
				var self = this;
				self.flag('running');
				self.compile(self.code(),self.copts(),function(res) {
					self.view().hints().rem(function(hint) { return hint.group() == 'runtime'; });
					
					if (res.data && res.data.code) {
						// @jsview.load(res:data:code) if res:data
						try {
							return self._sandbox.run(res.data);
						} catch (e) {
							return console.log('error');
						};
					};
				});
				return self;
			};
			
			tag.prototype.showjs = function (){
				var self = this;
				var o = {bare: true,standalone: false,filename: 'a.imba'};
				
				return self.compile(self.code(),o,function(res) {
					if (res.data && res.data.code) {
						return self._jsview.load(res.data.code,function() { var v_;
						return (self.setTab(v_ = 'js'),v_); });
					} else if (res.data && res.data.error) {
						return console.log('has error');
					};
				});
			};
			
			tag.prototype.runError = function (o){
				o.type = 'error';
				o.group = 'runtime';
				// console.log 'runError',o
				// only show error if we have a line and column
				return this.view().hints().add(o).activate();
			};
			
			tag.prototype.runLog = function (o){
				o.type = 'log';
				o.group = 'runtime';
				o.message || (o.message = JSON.stringify(o.params[0]));
				// console.log 'runLog',o
				
				if (o.nr != null && !o.loc) {
					var logs = this.view().find('.identifier.log,.identifier[name="log"]').toArray();
					var node = logs[o.nr];
					
					o.node = node;
					
					if (node) {
						var reg = node.region(); // node.next ? node.next.region : 
						console.log('found loc!!',node,reg);
						// let col = view.buffer.line(reg.row)[:length]
						o.loc = reg.endAtLine().collapse(); // {line: reg.row, column: col} #  reg.toJSON # {line: reg.row, column: 100}
						
						// o:loc = logs[o:nr].region.toJSON
					};
				};
				return this.view().hints().add(o).activate();
			};
			
			tag.prototype.runResult = function (o){
				// console.log 'runResult',o
				this.flag('repl',!!o);
				this._console.log(o);
				return this;
			};
		});
		
		tag$.defineTag('example', 'snippet', function(tag){
			
			tag.prototype.autorun = function (){
				return true;
			};
		});
		
		if (true) {
			Imba.Event.PROCESSING;
			
			
				
				var prev = Imba.Event.prototype.process;
				
				Imba.Event.prototype.process = function (){
					Imba.Event.PROCESSING = this;
					return prev.call(this);
				};
			
		};
		
		
		return tag$.defineTag('sandbox', function(tag){
			
			
			
			tag.prototype.editor = function(v){ return this._editor; }
			tag.prototype.setEditor = function(v){ this._editor = v; return this; };
			
			tag.prototype.render = function (){
				return this;
			};
			
			tag.prototype.console = function (){
				return this.editor()._console;
			};
			
			tag.prototype.onerror = function (msg,url,line,col,err){
				
				var stack_;
				if (url.match(/snippet(\d+)\.(imba|js)/)) {
					
					var id = url.split('.').shift();
					var snippet = tag$wrap(document.getElementById(id));
					
					if (snippet) {
						snippet.playground().onerror(msg,'',line,col,err);
						return;
					};
				} else if (url == 'undefined') {
					// safari?
					var ev = Imba.Event.PROCESSING;
					console.log('last event target',ev && ev.target());
					if (ev && ev.target()) {
						snippet = ev.target().closest(q$('._snippet',this));
						if (snippet) {
							return snippet.playground().onerror(msg,'',line,col,err);
						};
					};
				};
				
				console.log('caught the error here!!!',arguments,this);
				var locs = [];
				
				err && (stack_ = err.stack) && stack_.replace  &&  stack_.replace(/(\<anonymous\>|snippet\d+\.imba)\:(\d+):(\d+)/g,function(m,source,line,col) {
					locs.push({line: parseInt(line),column: parseInt(col)});
					return "";
				});
				
				locs.push({line: line,column: col});
				
				if (locs[0]) {
					var map = this.object().sourcemap;
					var consumer = Scrimbla.SourceMap.SourceMapConsumer(map);
					var loc = consumer.originalPositionFor(locs[0]);
					console.log('original location is',loc);
					this.editor().runError({message: msg,loc: loc});
				};
				
				return true;
			};
			
			tag.prototype.onlog = function (nr,pars){
				this.editor().runLog({nr: nr,params: pars});
				return this;
			};
			
			tag.prototype.empty = function (){
				for (var i = 0, ary = iter$(q$('.scheduled_',this)), len = ary.length; i < len; i++) {
					ary[i].unschedule();
				};
				return tag.__super__.empty.apply(this,arguments);
			};
			
			tag.prototype.present = function (res){
				var node;
				if (res && (res.prototype instanceof Imba.Tag)) {
					node = new res(res.createNode());
				} else if (res instanceof Imba.Tag) {
					node = res;
				};
				
				if (node) {
					this.empty().append(node);
					node.end();
				};
				
				return this.console().log(node || res);
			};
			
			tag.prototype.run = function (src){
				var self = this;
				var code = src.code;
				if (!code) { return self };
				
				self._object = src;
				
				try {
					window.onerror = function(msg,url,line,col,err) {
						console.log('caught error',msg,url,line,col,err,this);
						return self.onerror(msg,url,line,col,err);
					};
					
					code = code + '\n//# sourceURL=' + self.editor().id() + '.imba';
					var tag$ = Imba.TAGS.__clone();
					var console = self.console();
					var res = eval(code);
					self.present(res);
				} catch (e) {
					self.log('immediate error in eval-inline',e);
					self.onerror(e.message,'',e.lineNr || e.line || 0,e.column,e);
				};
				
				return self;
			};
		});
	
	})()

/***/ },
/* 71 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		tag$.defineTag('issue-li', function(tag){
			
			tag.prototype.render = function (){
				var t0, t1, t2, self = this, t3;
				return this.setChildren([
					(t0 = this.$a=this.$a || tag$.$div().flag('header')).setContent(
						(t1 = t0.$$a=t0.$$a || tag$.$a().flag('title')).setHref(("/blog/" + (this.object().number))).setContent(this.object().title,3).end()
					,2).end(),
					(t2 = this.$b=this.$b || tag$.$div().flag('legend')).setContent([
						"Written by ",
						(t2.$$a = t2.$$a || tag$.$gh_user()).setObject(this.object().user).end()
					],2).end(),
					
					(t3 = self.$c=self.$c || tag$.$div().flag('labels')).setContent(
						(function(t3) {
							for (var i = 0, ary = iter$(self.object().labels), len = ary.length, res = []; i < len; i++) {
								res.push((t3['$$a' + i] = t3['$$a' + i] || tag$.$gh_label()).setObject(ary[i]).end());
							};
							return res;
						})(t3)
					,3).end()
				],2).synced();
			};
		});
		
		tag$.defineTag('gh-label', function(tag){
			
			tag.prototype.render = function (){
				this.setTitle((this.object().name)).setChildren(this.object().name,3).synced();
				if (Imba.CLIENT) {
					this.css({backgroundColor: '#' + this.object().color});
				};
				return this;
			};
		});
		
		tag$.defineTag('gh-user', 'span', function(tag){
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren(
					(t0 = this.$a=this.$a || tag$.$a()).setHref(("http://github.com/" + (this.object().login))).setContent(this.object().login,3).end()
				,2).synced();
			};
		});
		
		return tag$.defineTag('issue', function(tag){
			
			tag.prototype.doc = function (){
				return this.object().object();
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2;
				return this.setChildren([
					(t0 = this.$a=this.$a || tag$.$div().flag('header')).setContent([
						(t1 = t0.$$a=t0.$$a || tag$.$h1().flag('title')).setContent(this.doc().title,3).end(),
						(t2 = t0.$$b=t0.$$b || tag$.$div().flag('legend')).setContent([
							"Written by ",
							(t2.$$a = t2.$$a || tag$.$gh_user()).setObject(this.doc().user).end(),
							(" at " + (this.doc().created_at))
						],1).end()
					],2).end(),
					(this.$b = this.$b || tag$.$div().flag('content').flag('md')).setHtml((this.doc().md)).end()
				],2).synced();
			};
		});
	
	})()

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzQzMjg0NGZhZTc2ZWZiM2RmMzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvaW1iYS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9jb3JlLmV2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9zY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvdGFnLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9kb20uY2xpZW50LmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5odG1sLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5zdmcuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvZG9tLmxlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9kb20uZXZlbnRzLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5zdGF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9pbmRleC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9mcy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9yZWdpb24uaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2hlbHBlcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlnaGxpZ2h0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9pbWJhL3NyYy9jb21waWxlci9sZXhlci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L2ltYmEvc3JjL2NvbXBpbGVyL3Rva2VuLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vaW1iYS9zcmMvY29tcGlsZXIvcmV3cml0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9pbWJhL3NyYy9jb21waWxlci9lcnJvcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvdXRpbC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9oaXN0b3J5LmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL2xvZ2dlci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9zaG9ydGN1dHMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL3ZpZXdzL2NhcHRvci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvdmlldy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9idWZmZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvb2JzZXJ2ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGludHMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvY2FyZXQuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL3ZpZXdzL292ZXJsYXlzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9lZGl0b3IuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvd29ya2VyLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9pbmRleC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvYmFzZS5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvdG9rZW4uaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Jsb2NrLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9yb290LmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9saXRlcmFscy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvb3BlcmF0b3JzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9zZWxlY3Rvci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvd2hpdGVzcGFjZS5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvYW5ub3RhdGlvbnMuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JvdXRlci5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9pbmRleC5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9iYXNlLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL21hcmtkb3duLmltYmEiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZWQvbGliL21hcmtlZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3Mvc2l0ZS5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9uYXYuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvcGFnZS5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9ob21lLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2Jsb2cuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvZ3VpZGVzLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2RvY3MuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3Mvc25pcHBldC5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9pc3N1ZXMuaW1iYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWdDLFdBQVcsRUFBRTtBQUM3Qyx5Q0FBd0MsV0FBVyxFQUFF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O0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBVyxTO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZ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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTRDLFNBQVM7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMzWUEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNELHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVJQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCLG1CQUFrQjs7QUFFbEIsc0JBQXFCO0FBQ3JCLHVCQUFzQjs7QUFFdEIsbUJBQWtCO0FBQ2xCLG1CQUFrQjs7QUFFbEIsbUJBQWtCO0FBQ2xCLG9CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25FQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaFhBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdkdBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDL0VBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qix3Q0FBd0M7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxtQkFBbUIsRUFBRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xIQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTCxhQUFZO0FBQ1o7O0FBRUE7QUFDQTs7Ozs7OztBQ3ZaQTtBQUNBLG9CQUFtQiwrQ0FBK0M7OztBQUdsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBeUI7OztBQUd6QixtQ0FBa0MsZ0JBQWdCO0FBQ2xELHNDQUFxQyxhQUFhLGFBQWE7OztBQUcvRCxtQ0FBa0MsZ0JBQWdCO0FBQ2xELHNDQUFxQyxhQUFhLGFBQWE7OztBQUcvRCxzQ0FBcUMsbUJBQW1CO0FBQ3hELHlDQUF3QyxnQkFBZ0IsYUFBYTs7O0FBR3JFLHNDQUFxQyxtQkFBbUI7QUFDeEQseUNBQXdDLGdCQUFnQixhQUFhOztBQUVyRTs7QUFFQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCLDhCQUE2QjtBQUM3Qix1REFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1YsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDViwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEc7Ozs7OztBQ3hTRDtBQUNBLG9CQUFtQiwrQ0FBK0M7OztBQUdsRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBc0IsOENBQThDLEVBQUU7QUFDdEUscUJBQW9CLGlFQUFpRTtBQUNyRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QixpQ0FBaUMsRUFBRTtBQUMzRDtBQUNBLHVCQUFzQixtQ0FBbUMsRUFBRTtBQUMzRCxzQkFBcUIsK0JBQStCLEVBQUU7QUFDdEQsc0JBQXFCLHlEQUF5RCxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHlCQUF3QjtBQUN4QiwrQkFBOEI7QUFDOUIsK0JBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUE4QixZQUFZLEVBQUUsa0JBQWtCO0FBQzlELGlDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDNU1EO0FBQ0Esb0JBQW1CLCtDQUErQzs7QUFFbEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTCxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBc0IsOENBQThDLEVBQUU7QUFDdEUscUJBQW9CLGlFQUFpRTtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNEI7QUFDNUIscUJBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBLG9DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNLE1BQU07QUFDWixNQUFLLEtBQUs7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFpRSwrQkFBK0I7QUFDaEcsK0JBQThCO0FBQzlCLDZCQUE0QjtBQUM1Qiw4QkFBNkI7QUFDN0IsNEJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUssbUJBQW1CO0FBQ3hCO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFnQyxVQUFVOztBQUUxQyxzQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLHlDQUF5QztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQThELFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7O0FBRWYsc0RBQXFELEVBQUU7QUFDdkQ7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsMEVBQXlFLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSiw2QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esb0NBQW1DO0FBQ25DLE1BQUs7QUFDTCxtQ0FBa0MseUNBQXlDO0FBQzNFO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUk7QUFDSixzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQSw4Q0FBNkMsc0JBQXNCO0FBQ25FLGlEQUFnRCxtQkFBbUIsYUFBYTs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEIsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUF5QztBQUN6Qzs7QUFFQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxHOzs7Ozs7O0FDbjBCRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUIsSUFBSTtBQUM3QjtBQUNBLDJEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQSx1R0FBc0csSUFBSTs7QUFFMUc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUhBQWtILElBQUk7O0FBRXRILHFCQUFvQixFQUFFLGFBQWEsRUFBRSxRQUFRLElBQUk7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUsscUNBQXFDO0FBQzFDO0FBQ0EsOEZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7Ozs7QUFJakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUEsb0JBQW1CO0FBQ25CLG9CQUFtQjtBQUNuQixxQkFBb0I7O0FBRXBCLHNCQUFxQjtBQUNyQixtQkFBa0I7QUFDbEIsdUJBQXNCO0FBQ3RCO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUEscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUosK0JBQThCLFdBQVc7QUFDekM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEIsMkNBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBLGtDQUFpQyxJQUFJLElBQUksU0FBUyxFQUFFLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QywwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCOztBQUUvQjtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQSx1Q0FBc0M7O0FBRXRDO0FBQ0EsdUNBQXNDOztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUE4QztBQUM5QywwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTs7QUFFQSxvQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOERBQTZEO0FBQzdELDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJLG9DQUFvQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWlGO0FBQ2pGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLG9CQUFvQixJQUFJLHNCQUFzQjtBQUM5RSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFnRTs7O0FBR2hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBZ0MsNEJBQTRCOztBQUU1RDtBQUNBLHlEQUF3RDtBQUN4RDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTBCLElBQUk7QUFDOUI7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSixnQkFBZTtBQUNmLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0Esb0JBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEM7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvREFBbUQ7QUFDbkQ7QUFDQSwwQ0FBeUM7QUFDekMsMkJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBLElBQUc7QUFDSCwyQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBMkQ7QUFDM0Q7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSx3Q0FBdUMsMEJBQTBCO0FBQ2pFLGtDQUFpQyxnQkFBZ0IsRUFBRSxXQUFXOztBQUU5RCxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLCtDQUErQztBQUM5RTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixLQUFLLFdBQVcsT0FBTyxLQUFLLE9BQU8sRUFBRSxlQUFlOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QyxLQUFJO0FBQ0osbUNBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGlEQUFnRCxLQUFLO0FBQ3JEO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBOEM7QUFDOUM7QUFDQTs7QUFFQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQSw4Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQsNERBQTREO0FBQ25IO0FBQ0EsSUFBRztBQUNIO0FBQ0Esa0NBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0ZBQStFO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkLDRDQUEyQztBQUMzQywwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCOztBQUV6QiwyQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhEQUE2RCxZQUFZLDZCQUE2QixTQUFTOztBQUUvRztBQUNBLHVCQUFzQjtBQUN0Qix5QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEscURBQW9ELFVBQVU7O0FBRTlEO0FBQ0Esc0VBQXFFO0FBQ3JFOztBQUVBLG9DQUFtQztBQUNuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLG1EQUFrRCxvQkFBb0I7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRDQUEyQyw0QkFBNEI7O0FBRXZFO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTs7QUFFYixxQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQSwrREFBOEQ7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE2RjtBQUM3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLDRCQUEyQixlQUFlOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQsSUFBSSxFQUFFLEdBQUc7O0FBRXBFLDZDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLGdEQUErQyxHQUFHLEVBQUUsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxJQUFHLDhEQUE4RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUcsMEdBQTBHO0FBQzdHO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNILG9CQUFtQjtBQUNuQixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQSxXQUFVO0FBQ1Y7QUFDQSxzQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQyxJQUFHO0FBQ0gsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWU7QUFDZixzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFnQjtBQUNoQjtBQUNBLEtBQUksbUJBQW1CO0FBQ3ZCO0FBQ0EsS0FBSSxtQkFBbUIsaUJBQWlCO0FBQ3hDLHdCQUF1QjtBQUN2QixLQUFJLG9DQUFvQztBQUN4Qyx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNEIsSUFBSTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsb0RBQW9EO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNEIsSUFBSTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYzs7QUFFZCx3QkFBdUI7O0FBRXZCLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0EsS0FBSSxtQkFBbUIsaUJBQWlCO0FBQ3hDLHdCQUF1QjtBQUN2QixLQUFJLG9DQUFvQztBQUN4Qyx3QkFBdUI7QUFDdkI7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsOENBQThDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDaG9FRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsTUFBTSxFQUFFLEtBQUs7QUFDeEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRyxtQkFBbUI7QUFDdEI7QUFDQTtBQUNBLElBQUcscUJBQXFCO0FBQ3hCO0FBQ0E7QUFDQSxJQUFHLG1CQUFtQjs7QUFFdEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7OztBQUdILG1EQUFrRCxJQUFJO0FBQ3RELG1EQUFrRCxJQUFJOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBQyxHOzs7Ozs7QUNoSUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLCtDQUErQztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjs7QUFFckIsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1EO0FBQ25EOztBQUVBLGlGQUFnRjtBQUNoRiw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBLElBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLGtEQUFrRDtBQUN2RixtQ0FBa0Msb0NBQW9DOztBQUV0RTtBQUNBLHdDQUF1QztBQUN2QztBQUNBLElBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLHNDQUFxQyxzREFBc0Q7QUFDM0YsbUNBQWtDLHdDQUF3QyxHQUFHOztBQUU3RTtBQUNBLDRDQUEyQztBQUMzQztBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQyxnREFBZ0Q7QUFDckYsbUNBQWtDLGtDQUFrQyxHQUFHOztBQUV2RTtBQUNBLHNDQUFxQztBQUNyQztBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXVEO0FBQ3ZEO0FBQ0EsOEJBQTZCLE1BQU07QUFDbkMsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXVDLEtBQUssYUFBYSxPQUFPO0FBQ2hFLCtCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0IsdUJBQXVCLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QixNQUFLO0FBQ0wsc0NBQXFDLEVBQUU7QUFDdkMsa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE2QjtBQUM3QjtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxNQUFLLGlFQUFpRTtBQUN0RTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBc0I7QUFDdEIscUNBQW9DO0FBQ3BDLG1EQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQyxHQUFHLEdBQUcsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHO0FBQzFEO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7OztBQUdBO0FBQ0EsNkJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBLHlDQUF3QztBQUN4QztBQUNBLHFDQUFvQztBQUNwQyx1REFBc0Q7QUFDdEQ7O0FBRUEsOEVBQTZFO0FBQzdFLDZFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1U0FBc1M7QUFDdFM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLHdEQUF3RDs7QUFFN0Y7QUFDQTtBQUNBLHlDQUF3QztBQUN4QztBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLElBQUk7QUFDVCxPQUFNLEtBQUs7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBcUUsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW1DLDRHQUE0RztBQUMvSSxrQ0FBaUMsaUdBQWlHOztBQUVsSTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBeUIsa0NBQWtDOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQSxxQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFnRztBQUNoRzs7QUFFQTtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDdnZCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0M7QUFDdEMsNkRBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUEsRUFBQyxHOzs7Ozs7QUMxRUQ7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSSxLQUFLO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBLElBQUc7OztBQUdIO0FBQ0Esa0JBQWlCO0FBQ2pCLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7O0FBRUEsa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7O0FBRUEsa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsT0FBTztBQUM1QztBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLG9DQUFvQzs7OztBQUl2QyxFQUFDLEc7Ozs7OztBQ3RNRDtBQUNBLG9CQUFtQiwrQ0FBK0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsNENBQTJDLG1CQUFtQjtBQUM5RCwrQ0FBOEMsZ0JBQWdCLGFBQWE7OztBQUczRSxpREFBZ0Qsd0JBQXdCO0FBQ3hFLG9EQUFtRCxxQkFBcUIsYUFBYTs7QUFFckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkI7O0FBRTdCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQSx1Q0FBc0MsbUJBQW1CO0FBQ3pELDBDQUF5QyxnQkFBZ0IsYUFBYTs7O0FBR3RFLHVDQUFzQyxtQkFBbUI7QUFDekQsMENBQXlDLGdCQUFnQixhQUFhOzs7QUFHdEUsd0NBQXVDLG9CQUFvQjtBQUMzRCwyQ0FBMEMsaUJBQWlCLGFBQWE7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLHFCQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7O0FBRWpCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCOzs7QUFHM0IsdUNBQXNDLG1CQUFtQjtBQUN6RCwwQ0FBeUMsZ0JBQWdCLGFBQWE7OztBQUd0RSx1Q0FBc0MsbUJBQW1CO0FBQ3pELDBDQUF5QyxnQkFBZ0IsYUFBYTs7O0FBR3RFLDBDQUF5QyxzQkFBc0I7QUFDL0QsNkNBQTRDLG1CQUFtQixhQUFhOzs7QUFHNUUsMENBQXlDLHNCQUFzQjtBQUMvRCw2Q0FBNEMsbUJBQW1CLGFBQWE7OztBQUc1RSx1Q0FBc0MsbUJBQW1CO0FBQ3pELDBDQUF5QyxnQkFBZ0IsYUFBYTs7O0FBR3RFLHVDQUFzQyxtQkFBbUI7QUFDekQsMENBQXlDLGdCQUFnQixhQUFhLEdBQUc7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSwwQ0FBeUMsT0FBTztBQUNoRCxNQUFLO0FBQ0wsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUIsdUJBQXNCO0FBQ3RCO0FBQ0EsMENBQXlDLE9BQU87QUFDaEQsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QixpRUFBZ0UsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsZ0VBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxFQUFDLEc7Ozs7OztBQ3piRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUF5Qjs7O0FBR3pCLHlDQUF3QyxzQkFBc0I7QUFDOUQsNENBQTJDLG1CQUFtQixhQUFhOzs7QUFHM0Usc0NBQXFDLG1CQUFtQjtBQUN4RCx5Q0FBd0MsZ0JBQWdCLGFBQWE7O0FBRXJFO0FBQ0EsOEJBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSw4QkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLDhCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0EsOEJBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSw4QkFBK0I7QUFDL0I7QUFDQTtBQUNBOzs7O0FBSUEsRUFBQyxHOzs7Ozs7QUM5Q0Q7QUFDQSxvQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUE4QixNQUFNLFdBQVc7QUFDL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFtQyxvQ0FBb0MsRUFBRTtBQUN6RSwwQ0FBeUMsb0NBQW9DLEVBQUU7QUFDL0Usd0NBQXVDLG9DQUFvQyxFQUFFO0FBQzdFOztBQUVBLHNCQUFxQixnQkFBZ0I7QUFDckMsc0JBQXFCLGVBQWU7QUFDcEMsMEJBQXlCLHVCQUF1QjtBQUNoRCwwQkFBeUIsbUJBQW1CO0FBQzVDLDBCQUF5Qix5QkFBeUI7O0FBRWxELG9DQUFtQyx3QkFBd0IsRUFBRTs7O0FBRzdELGtCQUFpQix3QkFBd0Isc0NBQXNDLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJOzs7O0FBSUosd0JBQXVCLHdCQUF3QixzQ0FBc0MsRUFBRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7O0FBRUosd0JBQXVCO0FBQ3ZCLGdCQUFlO0FBQ2YsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUosNkNBQTRDLGdDQUFnQyxFQUFFOztBQUU5RSx3QkFBdUI7QUFDdkI7QUFDQSwrQ0FBOEM7QUFDOUMsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUosd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUgsNkJBQTRCO0FBQzVCLHFFQUFvRSxHQUFHOztBQUV2RSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILDZCQUE0QixhQUFhLEdBQUc7O0FBRTVDLHNDQUFxQyxvQkFBb0IsRUFBRTtBQUMzRCw0Q0FBMkMsb0JBQW9CLEVBQUU7QUFDakUsMENBQXlDLGlDQUFpQyxFQUFFO0FBQzVFLDRDQUEyQyxpQ0FBaUMsRUFBRTs7QUFFOUU7QUFDQTtBQUNBLHVEQUFzRDs7QUFFdEQ7QUFDQSw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVILGdDQUErQix5QkFBeUIsRUFBRTs7O0FBRzFEO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELElBQUc7O0FBRUgscUNBQW9DLGlDQUFpQyxFQUFFO0FBQ3ZFOztBQUVBOztBQUVBLGdCQUFlLHdCQUF3Qix3Q0FBd0MsRUFBRTtBQUNqRiwyQkFBMEIsb0JBQW9CLEdBQUc7O0FBRWpELDhCQUE2QiwyQkFBMkIsRUFBRTtBQUMxRCw4QkFBNkIsMkJBQTJCLEVBQUU7QUFDMUQsOEJBQTZCLDJCQUEyQixFQUFFO0FBQzFELGFBQVksaUJBQWlCLHFCQUFxQixHQUFHLEdBQUcsRUFBRTs7QUFFMUQsZ0JBQWUsd0JBQXdCLHNEQUFzRCxFQUFFO0FBQy9GLDJCQUEwQiwyQkFBMkIsR0FBRzs7QUFFeEQsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsMkJBQTBCLHdCQUF3QixHQUFHOztBQUVyRCxnQkFBZSwwQkFBMEIsd0NBQXdDLEVBQUU7QUFDbkYsMkJBQTBCLG9CQUFvQixHQUFHOztBQUVqRCxnQkFBZSwwQkFBMEIsd0RBQXdELEVBQUU7QUFDbkcsMkJBQTBCLDBCQUEwQixHQUFHOztBQUV2RCw4QkFBNkIsMkJBQTJCLEVBQUU7QUFDMUQsOEJBQTZCLDJCQUEyQixFQUFFOztBQUUxRCxnQkFBZSx3QkFBd0Isc0NBQXNDLEVBQUU7QUFDL0UsMkJBQTBCLG9CQUFvQixHQUFHOztBQUVqRCxhQUFZLEdBQUcsd0JBQXdCLG9DQUFvQyxFQUFFLEVBQUU7QUFDL0UsMkJBQTBCLG9CQUFvQixHQUFHOztBQUVqRCxnQkFBZSx3QkFBd0Isc0NBQXNDLEVBQUU7QUFDL0UsMkJBQTBCLG9CQUFvQixHQUFHO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEI7O0FBRTFCLHdDQUF1QztBQUN2QyxzQ0FBcUM7QUFDckMsdURBQXNEO0FBQ3RELDBDQUF5QztBQUN6QyxnQ0FBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQSxtREFBa0QsOEJBQThCLEVBQUU7QUFDbEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNFQUFxRSxTQUFTO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBa0UsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUEsRUFBQyxHOzs7Ozs7O0FDcFdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWlDLG9FQUFvRTtBQUNyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUYsRUFBQyxHOzs7Ozs7QUMvQkQ7QUFDQSxvQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBK0I7QUFDL0IsaUNBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7OztBQUlBLHdDQUF1Qyx1QkFBdUI7QUFDOUQsMkNBQTBDLG9CQUFvQixhQUFhOzs7O0FBSTNFLHdDQUF1Qyx1QkFBdUI7QUFDOUQsMkNBQTBDLG9CQUFvQixhQUFhOzs7QUFHM0UsdUNBQXNDLHNCQUFzQjtBQUM1RCwwQ0FBeUMsbUJBQW1CLGFBQWE7OztBQUd6RSxxQ0FBb0Msb0JBQW9CO0FBQ3hELHdDQUF1QyxpQkFBaUIsYUFBYTs7O0FBR3JFLHNDQUFxQyxxQkFBcUI7QUFDMUQseUNBQXdDLGtCQUFrQixhQUFhOzs7QUFHdkUseUNBQXdDLHdCQUF3QjtBQUNoRSw0Q0FBMkMscUJBQXFCLGFBQWE7O0FBRTdFLGdDQUErQjtBQUMvQix5Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQSxnQkFBZSxxQkFBcUI7QUFDcEMsZ0JBQWU7QUFDZjtBQUNBOzs7QUFHQSxxQ0FBb0Msb0JBQW9CO0FBQ3hELHdDQUF1QyxpQkFBaUIsYUFBYTs7O0FBR3JFLHNDQUFxQyxxQkFBcUI7QUFDMUQseUNBQXdDLGtCQUFrQixhQUFhOzs7QUFHdkUsd0NBQXVDLHVCQUF1QjtBQUM5RCwyQ0FBMEMsb0JBQW9CLGFBQWE7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXdELGdDQUFnQyxFQUFFO0FBQzFGLHdEQUF1RCxnQ0FBZ0MsRUFBRTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0EscURBQW9ELFdBQVc7QUFDL0QsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsd0JBQXdCLEVBQUU7QUFDbkUsK0JBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRUFBaUUsZUFBZTtBQUNoRixLQUFJO0FBQ0o7QUFDQSx1REFBc0QsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxnQkFBZTtBQUNmO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QiwyQ0FBMkM7QUFDdkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE2QjtBQUM3Qiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsMkNBQTJDO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7OztBQUdGLEVBQUMsRzs7Ozs7O0FDdkREOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsRUFBQyxHOzs7Ozs7QUNuRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUYsRUFBQyxHOzs7Ozs7QUNwQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLEVBQUU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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bEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFGQUFvRixTQUFTO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsRUFBQyxHIiwiZmlsZSI6Ii4vd3d3L2NsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgYzQzMjg0NGZhZTc2ZWZiM2RmMzhcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0cmVxdWlyZSgnaW1iYS9saWIvaW1iYS9icm93c2VyJyk7XG5cdFxuXHQvLyBuZWVkIHRvIHVzZSB3ZWJwYWNrIGZvciB0aGlzIGluY2x1ZGUgdG8gd29yayBhcyBpbnRlbmRlZFxuXHRTY3JpbWJsYSA9IHJlcXVpcmUoJ3NjcmltYmxhL3NyYy9pbmRleCcpO1xuXHRcblx0dmFyIEFwcCA9IHJlcXVpcmUoJy4vYXBwJykuQXBwO1xuXHRBUFAgPSBuZXcgQXBwKCk7XG5cdEFQUC5zY2hlZHVsZSgpO1xuXHRcblx0cmVxdWlyZSgnLi92aWV3cycpO1xuXHRcblx0Ly8gYXdha2VuIHBhZ2VzIGV0Y1xuXHRxJCgnLl9wYWdlJykubWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbDsgfSk7XG5cdHJldHVybiBxJCgnLmF3YWtlbicpLm1hcChmdW5jdGlvbihlbCkgeyByZXR1cm4gZWw7IH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jbGllbnQuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0aWYgKHR5cGVvZiBJbWJhID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJlcXVpcmUoJy4vaW1iYScpO1xuXHRcdFxuXHRcdEltYmEuQ0xJRU5UID0gdHJ1ZTtcblx0XHRcblx0XHRyZXF1aXJlKCcuL2NvcmUuZXZlbnRzJyk7XG5cdFx0cmVxdWlyZSgnLi9zY2hlZHVsZXInKTtcblx0XHRyZXF1aXJlKCcuL3RhZycpO1xuXHRcdHJlcXVpcmUoJy4vZG9tJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uY2xpZW50Jyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uaHRtbCcpO1xuXHRcdHJlcXVpcmUoJy4vZG9tLnN2ZycpO1xuXHRcdHJlcXVpcmUoJy4vZG9tLmxlZ2FjeScpO1xuXHRcdHJlcXVpcmUoJy4vZG9tLmV2ZW50cycpO1xuXHRcdHJlcXVpcmUoJy4vZG9tLnN0YXRpYycpO1xuXHRcdHJldHVybiByZXF1aXJlKCcuL3NlbGVjdG9yJyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGNvbnNvbGUud2FybihcIkltYmEgaXMgYWxyZWFkeSBsb2FkZWRcIik7XG5cdH07XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHQvLyBleHRlcm5zO1xuXHRcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0Z2xvYmFsID0gd2luZG93O1xuXHR9O1xuXHRcblx0Lypcblx0SW1iYSBpcyB0aGUgbmFtZXNwYWNlIGZvciBhbGwgcnVudGltZSByZWxhdGVkIHV0aWxpdGllc1xuXHRAbmFtZXNwYWNlXG5cdCovXG5cdFxuXHRJbWJhID0ge1xuXHRcdFZFUlNJT046ICcwLjE0LjEnLFxuXHRcdERFQlVHOiBmYWxzZVxuXHR9O1xuXHRcblx0dmFyIHJlZyA9IC8tLi9nO1xuXHRcblx0Lypcblx0VHJ1ZSBpZiBydW5uaW5nIGluIGNsaWVudCBlbnZpcm9ubWVudC5cblx0QHJldHVybiB7Ym9vbH1cblx0Ki9cblx0XG5cdEltYmEuaXNDbGllbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gSW1iYS5DTElFTlQgPT09IHRydWU7XG5cdH07XG5cdFxuXHQvKlxuXHRUcnVlIGlmIHJ1bm5pbmcgaW4gc2VydmVyIGVudmlyb25tZW50LlxuXHRAcmV0dXJuIHtib29sfVxuXHQqL1xuXHRcblx0SW1iYS5pc1NlcnZlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBJbWJhLlNFUlZFUiA9PT0gdHJ1ZTtcblx0fTtcblx0XG5cdEltYmEuc3ViY2xhc3MgPSBmdW5jdGlvbiAob2JqLHN1cCl7XG5cdFx0O1xuXHRcdGZvciAodmFyIGsgaW4gc3VwKXtcblx0XHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIHsgb2JqW2tdID0gc3VwW2tdIH07XG5cdFx0fTtcblx0XHRcblx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xuXHRcdG9iai5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmo7XG5cdFx0cmV0dXJuIG9iajtcblx0fTtcblx0XG5cdC8qXG5cdExpZ2h0d2VpZ2h0IG1ldGhvZCBmb3IgbWFraW5nIGFuIG9iamVjdCBpdGVyYWJsZSBpbiBpbWJhcyBmb3IvaW4gbG9vcHMuXG5cdElmIHRoZSBjb21waWxlciBjYW5ub3Qgc2F5IGZvciBjZXJ0YWluIHRoYXQgYSB0YXJnZXQgaW4gYSBmb3IgbG9vcCBpcyBhblxuXHRhcnJheSwgaXQgd2lsbCBjYWNoZSB0aGUgaXRlcmFibGUgdmVyc2lvbiBiZWZvcmUgbG9vcGluZy5cblx0XG5cdGBgYGltYmFcblx0IyB0aGlzIGlzIHRoZSB3aG9sZSBtZXRob2Rcblx0ZGVmIEltYmEuaXRlcmFibGUgb1xuXHRcdHJldHVybiBvID8gKG86dG9BcnJheSA/IG8udG9BcnJheSA6IG8pIDogW11cblx0XG5cdGNsYXNzIEN1c3RvbUl0ZXJhYmxlXG5cdFx0ZGVmIHRvQXJyYXlcblx0XHRcdFsxLDIsM11cblx0XG5cdCMgd2lsbCByZXR1cm4gWzIsNCw2XVxuXHRmb3IgeCBpbiBDdXN0b21JdGVyYWJsZS5uZXdcblx0XHR4ICogMlxuXHRcblx0YGBgXG5cdCovXG5cdFxuXHRJbWJhLml0ZXJhYmxlID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiBvID8gKChvLnRvQXJyYXkgPyAoby50b0FycmF5KCkpIDogKG8pKSkgOiAoW10pO1xuXHR9O1xuXHRcblx0Lypcblx0Q29lcmNlcyBhIHZhbHVlIGludG8gYSBwcm9taXNlLiBJZiB2YWx1ZSBpcyBhcnJheSBpdCB3aWxsXG5cdGNhbGwgYFByb21pc2UuYWxsKHZhbHVlKWAsIG9yIGlmIGl0IGlzIG5vdCBhIHByb21pc2UgaXQgd2lsbFxuXHR3cmFwIHRoZSB2YWx1ZSBpbiBgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKWAuIFVzZWQgZm9yIGV4cGVyaW1lbnRhbFxuXHRhd2FpdCBzeW50YXguXG5cdEByZXR1cm4ge1Byb21pc2V9XG5cdCovXG5cdFxuXHRJbWJhLmF3YWl0ID0gZnVuY3Rpb24gKHZhbHVlKXtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLnRoZW4pIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdEltYmEudG9DYW1lbENhc2UgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UocmVnLGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0uY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7IH0pO1xuXHR9O1xuXHRcblx0SW1iYS50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHJldHVybiBzdHIucmVwbGFjZShyZWcsZnVuY3Rpb24obSkgeyByZXR1cm4gbS5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTsgfSk7XG5cdH07XG5cdFxuXHRJbWJhLmluZGV4T2YgPSBmdW5jdGlvbiAoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IChiLmluZGV4T2YoYSkpIDogKFtdLmluZGV4T2YuY2FsbChhLGIpKTtcblx0fTtcblx0XG5cdEltYmEucHJvcCA9IGZ1bmN0aW9uIChzY29wZSxuYW1lLG9wdHMpe1xuXHRcdGlmIChzY29wZS5kZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0cmV0dXJuIHNjb3BlLmRlZmluZVByb3BlcnR5KG5hbWUsb3B0cyk7XG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRyZXR1cm4gSW1iYS5hdHRyID0gZnVuY3Rpb24gKHNjb3BlLG5hbWUsb3B0cyl7XG5cdFx0aWYgKHNjb3BlLmRlZmluZUF0dHJpYnV0ZSkge1xuXHRcdFx0cmV0dXJuIHNjb3BlLmRlZmluZUF0dHJpYnV0ZShuYW1lLG9wdHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGdldE5hbWUgPSBJbWJhLnRvQ2FtZWxDYXNlKG5hbWUpO1xuXHRcdHZhciBzZXROYW1lID0gSW1iYS50b0NhbWVsQ2FzZSgnc2V0LScgKyBuYW1lKTtcblx0XHRcblx0XHRzY29wZS5wcm90b3R5cGVbZ2V0TmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcblx0XHR9O1xuXHRcdFxuXHRcdHNjb3BlLnByb3RvdHlwZVtzZXROYW1lXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShuYW1lLHZhbHVlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2ltYmEuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdFxuXHRmdW5jdGlvbiBlbWl0X18oZXZlbnQsYXJncyxub2RlKXtcblx0XHQvLyB2YXIgbm9kZSA9IGNic1tldmVudF1cblx0XHR2YXIgcHJldixjYixyZXQ7XG5cdFx0XG5cdFx0d2hpbGUgKChwcmV2ID0gbm9kZSkgJiYgKG5vZGUgPSBub2RlLm5leHQpKXtcblx0XHRcdGlmIChjYiA9IG5vZGUubGlzdGVuZXIpIHtcblx0XHRcdFx0aWYgKG5vZGUucGF0aCAmJiBjYltub2RlLnBhdGhdKSB7XG5cdFx0XHRcdFx0cmV0ID0gYXJncyA/IChjYltub2RlLnBhdGhdLmFwcGx5KGNiLGFyZ3MpKSA6IChjYltub2RlLnBhdGhdKCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIGl0IGlzIGEgbWV0aG9kP1xuXHRcdFx0XHRcdHJldCA9IGFyZ3MgPyAoY2IuYXBwbHkobm9kZSxhcmdzKSkgOiAoY2IuY2FsbChub2RlKSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobm9kZS50aW1lcyAmJiAtLW5vZGUudGltZXMgPD0gMCkge1xuXHRcdFx0XHRwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG5cdFx0XHRcdG5vZGUubGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIG1ldGhvZCBmb3IgcmVnaXN0ZXJpbmcgYSBsaXN0ZW5lciBvbiBvYmplY3Rcblx0SW1iYS5saXN0ZW4gPSBmdW5jdGlvbiAob2JqLGV2ZW50LGxpc3RlbmVyLHBhdGgpe1xuXHRcdHZhciAkMTtcblx0XHR2YXIgY2JzLGxpc3QsdGFpbDtcblx0XHRjYnMgPSBvYmouX19saXN0ZW5lcnNfXyB8fCAob2JqLl9fbGlzdGVuZXJzX18gPSB7fSk7XG5cdFx0bGlzdCA9IGNic1soJDEgPSBldmVudCldIHx8IChjYnNbJDFdID0ge30pO1xuXHRcdHRhaWwgPSBsaXN0LnRhaWwgfHwgKGxpc3QudGFpbCA9IChsaXN0Lm5leHQgPSB7fSkpO1xuXHRcdHRhaWwubGlzdGVuZXIgPSBsaXN0ZW5lcjtcblx0XHR0YWlsLnBhdGggPSBwYXRoO1xuXHRcdGxpc3QudGFpbCA9IHRhaWwubmV4dCA9IHt9O1xuXHRcdHJldHVybiB0YWlsO1xuXHR9O1xuXHRcblx0SW1iYS5vbmNlID0gZnVuY3Rpb24gKG9iaixldmVudCxsaXN0ZW5lcil7XG5cdFx0dmFyIHRhaWwgPSBJbWJhLmxpc3RlbihvYmosZXZlbnQsbGlzdGVuZXIpO1xuXHRcdHRhaWwudGltZXMgPSAxO1xuXHRcdHJldHVybiB0YWlsO1xuXHR9O1xuXHRcblx0SW1iYS51bmxpc3RlbiA9IGZ1bmN0aW9uIChvYmosZXZlbnQsY2IsbWV0aCl7XG5cdFx0dmFyIG5vZGUscHJldjtcblx0XHR2YXIgbWV0YSA9IG9iai5fX2xpc3RlbmVyc19fO1xuXHRcdGlmICghbWV0YSkgeyByZXR1cm4gfTtcblx0XHRcblx0XHRpZiAobm9kZSA9IG1ldGFbZXZlbnRdKSB7XG5cdFx0XHR3aGlsZSAoKHByZXYgPSBub2RlKSAmJiAobm9kZSA9IG5vZGUubmV4dCkpe1xuXHRcdFx0XHRpZiAobm9kZSA9PSBjYiB8fCBub2RlLmxpc3RlbmVyID09IGNiKSB7XG5cdFx0XHRcdFx0cHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBjb3JyZWN0IHBhdGggYXMgd2VsbD9cblx0XHRcdFx0XHRub2RlLmxpc3RlbmVyID0gbnVsbDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRJbWJhLmVtaXQgPSBmdW5jdGlvbiAob2JqLGV2ZW50LHBhcmFtcyl7XG5cdFx0dmFyIGNiO1xuXHRcdGlmIChjYiA9IG9iai5fX2xpc3RlbmVyc19fKSB7XG5cdFx0XHRpZiAoY2JbZXZlbnRdKSB7IGVtaXRfXyhldmVudCxwYXJhbXMsY2JbZXZlbnRdKSB9O1xuXHRcdFx0aWYgKGNiLmFsbCkgeyBlbWl0X18oZXZlbnQsW2V2ZW50LHBhcmFtc10sY2IuYWxsKSB9OyAvLyBhbmQgZXZlbnQgIT0gJ2FsbCdcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdHJldHVybiBJbWJhLm9ic2VydmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYnNlcnZlcixrZXksdHJpZ2dlcix0YXJnZXQscHJldil7XG5cdFx0aWYgKHByZXYgJiYgdHlwZW9mIHByZXYgPT0gJ29iamVjdCcpIHtcblx0XHRcdEltYmEudW5saXN0ZW4ocHJldiwnYWxsJyxvYnNlcnZlcix0cmlnZ2VyKTtcblx0XHR9O1xuXHRcdGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PSAnb2JqZWN0Jykge1xuXHRcdFx0SW1iYS5saXN0ZW4odGFyZ2V0LCdhbGwnLG9ic2VydmVyLHRyaWdnZXIpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvY29yZS5ldmVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRcblx0dmFyIHJhZjsgLy8gdmVyeSBzaW1wbGUgcmFmIHBvbHlmaWxsXG5cdHJhZiB8fCAocmFmID0gZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSk7XG5cdHJhZiB8fCAocmFmID0gZ2xvYmFsLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSk7XG5cdHJhZiB8fCAocmFmID0gZ2xvYmFsLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSk7XG5cdHJhZiB8fCAocmFmID0gZnVuY3Rpb24oYmxrKSB7IHJldHVybiBzZXRUaW1lb3V0KGJsaywxMDAwIC8gNjApOyB9KTtcblx0XG5cdEltYmEudGljayA9IGZ1bmN0aW9uIChkKXtcblx0XHRpZiAodGhpcy5fc2NoZWR1bGVkKSB7IHJhZihJbWJhLnRpY2tlcigpKSB9O1xuXHRcdHRoaXMuZW1pdCh0aGlzLCd0aWNrJyxbZF0pO1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdEltYmEudGlja2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHJldHVybiBzZWxmLl90aWNrZXIgfHwgKHNlbGYuX3RpY2tlciA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHNlbGYudGljayhlKTsgfSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0R2xvYmFsIGFsdGVybmF0aXZlIHRvIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gU2NoZWR1bGUgYSB0YXJnZXRcblx0dG8gdGljayBldmVyeSBmcmFtZS4gWW91IGNhbiBzcGVjaWZ5IHdoaWNoIG1ldGhvZCB0byBjYWxsIG9uIHRoZVxuXHR0YXJnZXQgKGRlZmF1bHRzIHRvIHRpY2spLlxuXHRcblx0Ki9cblx0XG5cdEltYmEuc2NoZWR1bGUgPSBmdW5jdGlvbiAodGFyZ2V0LG1ldGhvZCl7XG5cdFx0aWYobWV0aG9kID09PSB1bmRlZmluZWQpIG1ldGhvZCA9ICd0aWNrJztcblx0XHR0aGlzLmxpc3Rlbih0aGlzLCd0aWNrJyx0YXJnZXQsbWV0aG9kKTtcblx0XHQvLyBzdGFydCBzY2hlZHVsaW5nIG5vdyBpZiB0aGlzIHdhcyB0aGUgZmlyc3Qgb25lXG5cdFx0aWYgKCF0aGlzLl9zY2hlZHVsZWQpIHtcblx0XHRcdHRoaXMuX3NjaGVkdWxlZCA9IHRydWU7XG5cdFx0XHRyYWYoSW1iYS50aWNrZXIoKSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFxuXHRVbnNjaGVkdWxlIGEgcHJldmlvdXNseSBzY2hlZHVsZWQgdGFyZ2V0XG5cdFxuXHQqL1xuXHRcblx0SW1iYS51bnNjaGVkdWxlID0gZnVuY3Rpb24gKHRhcmdldCxtZXRob2Qpe1xuXHRcdHRoaXMudW5saXN0ZW4odGhpcywndGljaycsdGFyZ2V0LG1ldGhvZCk7XG5cdFx0dmFyIGNicyA9IHRoaXMuX19saXN0ZW5lcnNfXyB8fCAodGhpcy5fX2xpc3RlbmVyc19fID0ge30pO1xuXHRcdGlmICghY2JzLnRpY2sgfHwgIWNicy50aWNrLm5leHQgfHwgIWNicy50aWNrLm5leHQubGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0TGlnaHQgd3JhcHBlciBhcm91bmQgbmF0aXZlIHNldFRpbWVvdXQgdGhhdCBleHBlY3RzIHRoZSBibG9jayAvIGZ1bmN0aW9uXG5cdGFzIGxhc3QgYXJndW1lbnQgKGluc3RlYWQgb2YgZmlyc3QpLiBJdCBhbHNvIHRyaWdnZXJzIGFuIGV2ZW50IHRvIEltYmFcblx0YWZ0ZXIgdGhlIHRpbWVvdXQgdG8gbGV0IHNjaGVkdWxlcnMgdXBkYXRlICh0byByZXJlbmRlciBldGMpIGFmdGVyd2FyZHMuXG5cdFxuXHQqL1xuXHRcblx0SW1iYS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGRlbGF5LGJsb2NrKXtcblx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdGJsb2NrKCk7XG5cdFx0XHRyZXR1cm4gSW1iYS5lbWl0KEltYmEsJ3RpbWVvdXQnLFtibG9ja10pO1xuXHRcdH0sZGVsYXkpO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdExpZ2h0IHdyYXBwZXIgYXJvdW5kIG5hdGl2ZSBzZXRJbnRlcnZhbCB0aGF0IGV4cGVjdHMgdGhlIGJsb2NrIC8gZnVuY3Rpb25cblx0YXMgbGFzdCBhcmd1bWVudCAoaW5zdGVhZCBvZiBmaXJzdCkuIEl0IGFsc28gdHJpZ2dlcnMgYW4gZXZlbnQgdG8gSW1iYVxuXHRhZnRlciBldmVyeSBpbnRlcnZhbCB0byBsZXQgc2NoZWR1bGVycyB1cGRhdGUgKHRvIHJlcmVuZGVyIGV0YykgYWZ0ZXJ3YXJkcy5cblx0XG5cdCovXG5cdFxuXHRJbWJhLnNldEludGVydmFsID0gZnVuY3Rpb24gKGludGVydmFsLGJsb2NrKXtcblx0XHRyZXR1cm4gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRibG9jaygpO1xuXHRcdFx0cmV0dXJuIEltYmEuZW1pdChJbWJhLCdpbnRlcnZhbCcsW2Jsb2NrXSk7XG5cdFx0fSxpbnRlcnZhbCk7XG5cdH07XG5cdFxuXHQvKlxuXHRDbGVhciBpbnRlcnZhbCB3aXRoIHNwZWNpZmllZCBpZFxuXHQqL1xuXHRcblx0SW1iYS5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKGludGVydmFsKXtcblx0XHRyZXR1cm4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdH07XG5cdFxuXHQvKlxuXHRDbGVhciB0aW1lb3V0IHdpdGggc3BlY2lmaWVkIGlkXG5cdCovXG5cdFxuXHRJbWJhLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICh0aW1lb3V0KXtcblx0XHRyZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHR9O1xuXHRcblx0Ly8gc2hvdWxkIGFkZCBhbiBJbWJhLnJ1biAvIHNldEltbWVkaWF0ZSB0aGF0XG5cdC8vIHB1c2hlcyBsaXN0ZW5lciBvbnRvIHRoZSB0aWNrLXF1ZXVlIHdpdGggdGltZXMgLSBvbmNlXG5cdFxuXHRcblx0Lypcblx0XG5cdEluc3RhbmNlcyBvZiBJbWJhLlNjaGVkdWxlciBtYW5hZ2VzIHdoZW4gdG8gY2FsbCBgdGljaygpYCBvbiB0aGVpciB0YXJnZXQsXG5cdGF0IGEgc3BlY2lmaWVkIGZyYW1lcmF0ZSBvciB3aGVuIGNlcnRhaW4gZXZlbnRzIG9jY3VyLiBSb290LW5vZGVzIGluIHlvdXJcblx0YXBwbGljYXRpb25zIHdpbGwgdXN1YWxseSBoYXZlIGEgc2NoZWR1bGVyIHRvIG1ha2Ugc3VyZSB0aGV5IHJlcmVuZGVyIHdoZW5cblx0c29tZXRoaW5nIGNoYW5nZXMuIEl0IGlzIGFsc28gcG9zc2libGUgdG8gbWFrZSBpbm5lciBjb21wb25lbnRzIHVzZSB0aGVpclxuXHRvd24gc2NoZWR1bGVycyB0byBjb250cm9sIHdoZW4gdGhleSByZW5kZXIuXG5cdFxuXHRAaW5hbWUgc2NoZWR1bGVyXG5cdFxuXHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIgPSBmdW5jdGlvbiBTY2hlZHVsZXIodGFyZ2V0KXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHNlbGYuX21hcmtlZCA9IGZhbHNlO1xuXHRcdHNlbGYuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdHNlbGYuX21hcmtlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5tYXJrKCk7IH07XG5cdFx0c2VsZi5fdGlja2VyID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi50aWNrKGUpOyB9O1xuXHRcdFxuXHRcdHNlbGYuX2V2ZW50cyA9IHRydWU7XG5cdFx0c2VsZi5fZnBzID0gMTtcblx0XHRcblx0XHRzZWxmLl9kdCA9IDA7XG5cdFx0c2VsZi5fdGltZXN0YW1wID0gMDtcblx0XHRzZWxmLl90aWNrcyA9IDA7XG5cdFx0c2VsZi5fZmx1c2hlcyA9IDA7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENyZWF0ZSBhIG5ldyBJbWJhLlNjaGVkdWxlciBmb3Igc3BlY2lmaWVkIHRhcmdldFxuXHRcdEByZXR1cm4ge0ltYmEuU2NoZWR1bGVyfVxuXHRcdCovXG5cdFxuXHQvKlxuXHRcdENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NoZWR1bGVyIGlzIGFjdGl2ZSBvciBub3Rcblx0XHRAcmV0dXJuIHtib29sfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZTtcblx0fTtcblx0XG5cdC8qXG5cdFx0RGVsdGEgdGltZSBiZXR3ZWVuIHRoZSB0d28gbGFzdCB0aWNrc1xuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLmR0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2R0O1xuXHR9O1xuXHRcblx0Lypcblx0XHREZWx0YSB0aW1lIGJldHdlZW4gdGhlIHR3byBsYXN0IHRpY2tzXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHBhcnMpe1xuXHRcdGlmKCFwYXJzfHxwYXJzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHBhcnMgPSB7fTtcblx0XHR2YXIgZnBzID0gcGFycy5mcHMgIT09IHVuZGVmaW5lZCA/IHBhcnMuZnBzIDogMTtcblx0XHR2YXIgZXZlbnRzID0gcGFycy5ldmVudHMgIT09IHVuZGVmaW5lZCA/IHBhcnMuZXZlbnRzIDogdHJ1ZTtcblx0XHRpZiAoZXZlbnRzICE9IG51bGwpIHsgdGhpcy5fZXZlbnRzID0gZXZlbnRzIH07XG5cdFx0aWYgKGZwcyAhPSBudWxsKSB7IHRoaXMuX2ZwcyA9IGZwcyB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gZGVmIHJlc2NoZWR1bGVcblx0Ly8gXHRyYWYoQHRpY2tlcilcblx0Ly8gXHRzZWxmXG5cdFxuXHQvKlxuXHRcdE1hcmsgdGhlIHNjaGVkdWxlciBhcyBkaXJ0eS4gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGF0XG5cdFx0dGhlIHNjaGVkdWxlciBjYWxscyBgdGFyZ2V0LnRpY2tgIG9uIHRoZSBuZXh0IGZyYW1lXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9tYXJrZWQgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRJbnN0YW50bHkgdHJpZ2dlciB0YXJnZXQudGljayBhbmQgbWFyayBzY2hlZHVsZXIgYXMgY2xlYW4gKG5vdCBkaXJ0eS9tYXJrZWQpLlxuXHRcdFRoaXMgaXMgY2FsbGVkIGltcGxpY2l0bHkgZnJvbSB0aWNrLCBidXQgY2FuIGFsc28gYmUgY2FsbGVkIG1hbnVhbGx5IGlmIHlvdVxuXHRcdHJlYWxseSB3YW50IHRvIGZvcmNlIGEgdGljayB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBuZXh0IGZyYW1lLlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX21hcmtlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2ZsdXNoZXMrKztcblx0XHR0aGlzLl90YXJnZXQudGljaygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRAZml4bWUgdGhpcyBleHBlY3RzIHJhZiB0byBydW4gYXQgNjAgZnBzIFxuXHRcblx0XHRDYWxsZWQgYXV0b21hdGljYWxseSBvbiBldmVyeSBmcmFtZSB3aGlsZSB0aGUgc2NoZWR1bGVyIGlzIGFjdGl2ZS5cblx0XHRJdCB3aWxsIG9ubHkgY2FsbCBgdGFyZ2V0LnRpY2tgIGlmIHRoZSBzY2hlZHVsZXIgaXMgbWFya2VkIGRpcnR5LFxuXHRcdG9yIHdoZW4gYWNjb3JkaW5nIHRvIEBmcHMgc2V0dGluZy5cblx0XG5cdFx0SWYgeW91IGhhdmUgc2V0IHVwIGEgc2NoZWR1bGVyIHdpdGggYW4gZnBzIG9mIDEsIHRpY2sgd2lsbCBzdGlsbCBiZVxuXHRcdGNhbGxlZCBldmVyeSBmcmFtZSwgYnV0IGB0YXJnZXQudGlja2Agd2lsbCBvbmx5IGJlIGNhbGxlZCBvbmNlIGV2ZXJ5XG5cdFx0c2Vjb25kLCBhbmQgaXQgd2lsbCAqbWFrZSBzdXJlKiBlYWNoIGB0YXJnZXQudGlja2AgaGFwcGVucyBpbiBzZXBhcmF0ZVxuXHRcdHNlY29uZHMgYWNjb3JkaW5nIHRvIERhdGUuIFNvIGlmIHlvdSBoYXZlIGEgbm9kZSB0aGF0IHJlbmRlcnMgYSBjbG9ja1xuXHRcdGJhc2VkIG9uIERhdGUubm93IChvciBzb21ldGhpbmcgc2ltaWxhciksIHlvdSBjYW4gc2NoZWR1bGUgaXQgd2l0aCAxZnBzLFxuXHRcdG5ldmVyIG5lZWRpbmcgdG8gd29ycnkgYWJvdXQgdHdvIHRpY2tzIGhhcHBlbmluZyB3aXRoaW4gdGhlIHNhbWUgc2Vjb25kLlxuXHRcdFRoZSBzYW1lIGdvZXMgZm9yIDRmcHMsIDEwZnBzIGV0Yy5cblx0XG5cdFx0QHByb3RlY3RlZFxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKGRlbHRhKXtcblx0XHR0aGlzLl90aWNrcysrO1xuXHRcdHRoaXMuX2R0ID0gZGVsdGE7XG5cdFx0XG5cdFx0dmFyIGZwcyA9IHRoaXMuX2Zwcztcblx0XHRcblx0XHRpZiAoZnBzID09IDYwKSB7XG5cdFx0XHR0aGlzLl9tYXJrZWQgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoZnBzID09IDMwKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlja3MgJSAyKSB7IHRoaXMuX21hcmtlZCA9IHRydWUgfTtcblx0XHR9IGVsc2UgaWYgKGZwcykge1xuXHRcdFx0Ly8gaWYgaXQgaXMgbGVzcyByb3VuZCAtIHdlIHRyaWdnZXIgYmFzZWRcblx0XHRcdC8vIG9uIGRhdGUsIGZvciBjb25zaXN0ZW50IHJlbmRlcmluZy5cblx0XHRcdC8vIGllLCBpZiB5b3Ugd2FudCB0byByZW5kZXIgZXZlcnkgc2Vjb25kXG5cdFx0XHQvLyBpdCBpcyBpbXBvcnRhbnQgdGhhdCBubyB0d28gcmVuZGVyc1xuXHRcdFx0Ly8gaGFwcGVuIGR1cmluZyB0aGUgc2FtZSBzZWNvbmQgKGFjY29yZGluZyB0byBEYXRlKVxuXHRcdFx0dmFyIHBlcmlvZCA9ICgoNjAgLyBmcHMpIC8gNjApICogMTAwMDtcblx0XHRcdHZhciBiZWF0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gcGVyaW9kKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX2JlYXQgIT0gYmVhdCkge1xuXHRcdFx0XHR0aGlzLl9iZWF0ID0gYmVhdDtcblx0XHRcdFx0dGhpcy5fbWFya2VkID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5fbWFya2VkKSB0aGlzLmZsdXNoKCk7XG5cdFx0Ly8gcmVzY2hlZHVsZSBpZiBAYWN0aXZlXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFN0YXJ0IHRoZSBzY2hlZHVsZXIgaWYgaXQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuXHRcdCoqV2hpbGUgYWN0aXZlKiosIHRoZSBzY2hlZHVsZXIgd2lsbCBvdmVycmlkZSBgdGFyZ2V0LmNvbW1pdGBcblx0XHR0byBkbyBub3RoaW5nLiBCeSBkZWZhdWx0IEltYmEudGFnI2NvbW1pdCBjYWxscyByZW5kZXIsIHNvXG5cdFx0dGhhdCByZW5kZXJpbmcgaXMgY2FzY2FkZWQgdGhyb3VnaCB0byBjaGlsZHJlbiB3aGVuIHJlbmRlcmluZ1xuXHRcdGEgbm9kZS4gV2hlbiBhIHNjaGVkdWxlciBpcyBhY3RpdmUgKGZvciBhIG5vZGUpLCBJbWJhIGRpc2FibGVzXG5cdFx0dGhpcyBhdXRvbWF0aWMgcmVuZGVyaW5nLlxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkge1xuXHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTtcblx0XHRcdC8vIG92ZXJyaWRlIHRhcmdldCNjb21taXQgd2hpbGUgdGhpcyBpcyBhY3RpdmVcblx0XHRcdHRoaXMuX2NvbW1pdCA9IHRoaXMuX3RhcmdldC5jb21taXQ7XG5cdFx0XHR0aGlzLl90YXJnZXQuY29tbWl0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuXHRcdFx0SW1iYS5zY2hlZHVsZSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLl9ldmVudHMpIHsgSW1iYS5saXN0ZW4oSW1iYSwnZXZlbnQnLHRoaXMsJ29uZXZlbnQnKSB9O1xuXHRcdFx0dGhpcy5fdGFyZ2V0ICYmIHRoaXMuX3RhcmdldC5mbGFnICAmJiAgdGhpcy5fdGFyZ2V0LmZsYWcoJ3NjaGVkdWxlZF8nKTtcblx0XHRcdHRoaXMudGljaygwKTsgLy8gc3RhcnQgdGlja2luZ1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFN0b3AgdGhlIHNjaGVkdWxlciBpZiBpdCBpcyBhY3RpdmUuXG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZSkge1xuXHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXQuY29tbWl0ID0gdGhpcy5fY29tbWl0O1xuXHRcdFx0SW1iYS51bnNjaGVkdWxlKHRoaXMpO1xuXHRcdFx0SW1iYS51bmxpc3RlbihJbWJhLCdldmVudCcsdGhpcyk7XG5cdFx0XHR0aGlzLl90YXJnZXQgJiYgdGhpcy5fdGFyZ2V0LnVuZmxhZyAgJiYgIHRoaXMuX3RhcmdldC51bmZsYWcoJ3NjaGVkdWxlZF8nKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX21hcmtlcjtcblx0fTtcblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KXtcblx0XHR2YXIgJDE7XG5cdFx0aWYgKHRoaXMuX21hcmtlZCkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9ldmVudHMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0aWYgKHRoaXMuX2V2ZW50cyhldmVudCkpIHRoaXMubWFyaygpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGlmIChpZHgkKCgkMSA9IGV2ZW50KSAmJiAkMS50eXBlICAmJiAgJDEudHlwZSgpLHRoaXMuX2V2ZW50cykgPj0gMCkgdGhpcy5tYXJrKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9ldmVudHMpIHtcblx0XHRcdGlmIChldmVudC5fcmVzcG9uZGVyKSB0aGlzLm1hcmsoKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRyZXR1cm4gSW1iYS5TY2hlZHVsZXI7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvc2NoZWR1bGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0SW1iYS5zdGF0aWMgPSBmdW5jdGlvbiAoaXRlbXMsbnIpe1xuXHRcdGl0ZW1zLnN0YXRpYyA9IG5yO1xuXHRcdHJldHVybiBpdGVtcztcblx0fTtcblx0XG5cdC8qXG5cdFRoaXMgaXMgdGhlIGJhc2VjbGFzcyB0aGF0IGFsbCB0YWdzIGluIGltYmEgaW5oZXJpdCBmcm9tLlxuXHRAaW5hbWUgbm9kZVxuXHQqL1xuXHRcblx0SW1iYS5UYWcgPSBmdW5jdGlvbiBUYWcoZG9tKXtcblx0XHR0aGlzLnNldERvbShkb20pO1xuXHR9O1xuXHRcblx0SW1iYS5UYWcuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRocm93IFwiTm90IGltcGxlbWVudGVkXCI7XG5cdH07XG5cdFxuXHRJbWJhLlRhZy5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBuZXcgdGhpcyh0aGlzLmNyZWF0ZU5vZGUoKSk7XG5cdH07XG5cdFxuXHRcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5vYmplY3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29iamVjdDsgfVxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0T2JqZWN0ID0gZnVuY3Rpb24odil7IHRoaXMuX29iamVjdCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmRvbSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kb207XG5cdH07XG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0RG9tID0gZnVuY3Rpb24gKGRvbSl7XG5cdFx0ZG9tLl90YWcgPSB0aGlzO1xuXHRcdHRoaXMuX2RvbSA9IGRvbTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U2V0dGluZyByZWZlcmVuY2VzIGZvciB0YWdzIGxpa2Vcblx0XHRgPGRpdkBoZWFkZXI+YCB3aWxsIGNvbXBpbGUgdG8gYHRhZygnZGl2Jykuc2V0UmVmKCdoZWFkZXInLHRoaXMpLmVuZCgpYFxuXHRcdEJ5IGRlZmF1bHQgaXQgYWRkcyB0aGUgcmVmZXJlbmNlIGFzIGEgY2xhc3NOYW1lIHRvIHRoZSB0YWcuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNldFJlZiA9IGZ1bmN0aW9uIChyZWYsY3R4KXtcblx0XHR0aGlzLmZsYWcodGhpcy5fcmVmID0gcmVmKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0TWV0aG9kIHRoYXQgaXMgY2FsbGVkIGJ5IHRoZSBjb21waWxlZCB0YWctY2hhaW5zLCBmb3Jcblx0XHRiaW5kaW5nIGV2ZW50cyBvbiB0YWdzIHRvIG1ldGhvZHMgZXRjLlxuXHRcdGA8YSA6dGFwPWZuPmAgY29tcGlsZXMgdG8gYHRhZygnYScpLnNldEhhbmRsZXIoJ3RhcCcsZm4sdGhpcykuZW5kKClgXG5cdFx0d2hlcmUgdGhpcyByZWZlcnMgdG8gdGhlIGNvbnRleHQgaW4gd2hpY2ggdGhlIHRhZyBpcyBjcmVhdGVkLlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50LGhhbmRsZXIsY3R4KXtcblx0XHR2YXIga2V5ID0gJ29uJyArIGV2ZW50O1xuXHRcdFxuXHRcdGlmIChoYW5kbGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHRoaXNba2V5XSA9IGhhbmRsZXI7XG5cdFx0fSBlbHNlIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHZhciBmbiA9IGhhbmRsZXIuc2hpZnQoKTtcblx0XHRcdHRoaXNba2V5XSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGN0eFtmbl0uYXBwbHkoY3R4LGhhbmRsZXIuY29uY2F0KGUpKTsgfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpc1trZXldID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gY3R4W2hhbmRsZXJdKGUpOyB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbiAoaWQpe1xuXHRcdHRoaXMuZG9tKCkuaWQgPSBpZDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmRvbSgpLmlkO1xuXHR9O1xuXHRcblx0Lypcblx0XHRBZGRzIGEgbmV3IGF0dHJpYnV0ZSBvciBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhbiBleGlzdGluZyBhdHRyaWJ1dGVcblx0XHRvbiB0aGUgc3BlY2lmaWVkIHRhZy4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgZmFsc2UsIHRoZSBhdHRyaWJ1dGVcblx0XHR3aWxsIGJlIHJlbW92ZWQuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLHZhbHVlKXtcblx0XHQvLyBzaG91bGQgdGhpcyBub3QgcmV0dXJuIHNlbGY/XG5cdFx0dmFyIG9sZCA9IHRoaXMuZG9tKCkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXHRcdFxuXHRcdGlmIChvbGQgPT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5zZXRBdHRyaWJ1dGUobmFtZSx2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0Lypcblx0XHRyZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBzcGVjaWZpZWQgdGFnXG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0cmV0dXJuIHRoaXMuZG9tKCkucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRyZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gdGhlIHRhZy5cblx0XHRJZiB0aGUgZ2l2ZW4gYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LCB0aGUgdmFsdWUgcmV0dXJuZWRcblx0XHR3aWxsIGVpdGhlciBiZSBudWxsIG9yIFwiXCIgKHRoZSBlbXB0eSBzdHJpbmcpXG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0cmV0dXJuIHRoaXMuZG9tKCkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRPdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgc3BlY2lhbCB3cmFwcGluZyBldGMuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCx0eXBlKXtcblx0XHR0aGlzLnNldENoaWxkcmVuKGNvbnRlbnQsdHlwZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFNldCB0aGUgY2hpbGRyZW4gb2Ygbm9kZS4gdHlwZSBwYXJhbSBpcyBvcHRpb25hbCxcblx0XHRhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSBJbWJhIHdoZW4gY29tcGlsaW5nIHRhZyB0cmVlcy4gXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNldENoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGVzLHR5cGUpe1xuXHRcdHRocm93IFwiTm90IGltcGxlbWVudGVkXCI7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEdldCB0ZXh0IG9mIG5vZGUuIFVzZXMgdGV4dENvbnRlbnQgYmVoaW5kIHRoZSBzY2VuZXMgKG5vdCBpbm5lclRleHQpXG5cdFx0W2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL3RleHRDb250ZW50XSgpXG5cdFx0QHJldHVybiB7c3RyaW5nfSBpbm5lciB0ZXh0IG9mIG5vZGVcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodil7XG5cdFx0cmV0dXJuIHRoaXMuX2RvbS50ZXh0Q29udGVudDtcblx0fTtcblx0XG5cdC8qXG5cdFx0U2V0IHRleHQgb2Ygbm9kZS4gVXNlcyB0ZXh0Q29udGVudCBiZWhpbmQgdGhlIHNjZW5lcyAobm90IGlubmVyVGV4dClcblx0XHRbaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvdGV4dENvbnRlbnRdKClcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodHh0KXtcblx0XHR0aGlzLl9lbXB0eSA9IGZhbHNlO1xuXHRcdHRoaXMuX2RvbS50ZXh0Q29udGVudCA9IHR4dCA9PSBudWxsID8gKHR4dCA9IFwiXCIpIDogKHR4dCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Lypcblx0XHRNZXRob2QgZm9yIGdldHRpbmcgYW5kIHNldHRpbmcgZGF0YS1hdHRyaWJ1dGVzLiBXaGVuIGNhbGxlZCB3aXRoIHplcm9cblx0XHRhcmd1bWVudHMgaXQgd2lsbCByZXR1cm4gdGhlIGFjdHVhbCBkYXRhc2V0IGZvciB0aGUgdGFnLlxuXHRcblx0XHRcdHZhciBub2RlID0gPGRpdiBkYXRhLW5hbWU9J2hlbGxvJz5cblx0XHRcdCMgZ2V0IHRoZSB3aG9sZSBkYXRhc2V0XG5cdFx0XHRub2RlLmRhdGFzZXQgIyB7bmFtZTogJ2hlbGxvJ31cblx0XHRcdCMgZ2V0IGEgc2luZ2xlIHZhbHVlXG5cdFx0XHRub2RlLmRhdGFzZXQoJ25hbWUnKSAjICdoZWxsbydcblx0XHRcdCMgc2V0IGEgc2luZ2xlIHZhbHVlXG5cdFx0XHRub2RlLmRhdGFzZXQoJ25hbWUnLCduZXduYW1lJykgIyBzZWxmXG5cdFxuXHRcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmRhdGFzZXQgPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0dGhyb3cgXCJOb3QgaW1wbGVtZW50ZWRcIjtcblx0fTtcblx0XG5cdC8qXG5cdFx0RW1wdHkgcGxhY2Vob2xkZXIuIE92ZXJyaWRlIHRvIGltcGxlbWVudCBjdXN0b20gcmVuZGVyIGJlaGF2aW91ci5cblx0XHRXb3JrcyBtdWNoIGxpa2UgdGhlIGZhbWlsaWFyIHJlbmRlci1tZXRob2QgaW4gUmVhY3QuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRDYWxsZWQgaW1wbGljaXRseSB0aHJvdWdoIEltYmEuVGFnI2VuZCwgdXBvbiBjcmVhdGluZyBhIHRhZy4gQWxsXG5cdFx0cHJvcGVydGllcyB3aWxsIGhhdmUgYmVlbiBzZXQgYmVmb3JlIGJ1aWxkIGlzIGNhbGxlZCwgaW5jbHVkaW5nXG5cdFx0c2V0Q29udGVudC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRDYWxsZWQgaW1wbGljaXRseSB0aHJvdWdoIEltYmEuVGFnI2VuZCwgZm9yIHRhZ3MgdGhhdCBhcmUgcGFydCBvZlxuXHRcdGEgdGFnIHRyZWUgKHRoYXQgYXJlIHJlbmRlcmVkIHNldmVyYWwgdGltZXMpLlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdFx0Q2FsbGVkIGJ5IHRoZSB0YWctc2NoZWR1bGVyIChpZiB0aGlzIHRhZyBpcyBzY2hlZHVsZWQpXG5cdFx0QnkgZGVmYXVsdCBpdCB3aWxsIGNhbGwgdGhpcy5yZW5kZXIuIERvIG5vdCBvdmVycmlkZSB1bmxlc3Ncblx0XHR5b3UgcmVhbGx5IHVuZGVyc3RhbmQgaXQuXG5cdFxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFxuXHRcdEEgdmVyeSBpbXBvcnRhbnQgbWV0aG9kIHRoYXQgeW91IHdpbGwgcHJhY3RpY2FsbHkgbmV2ZXIgbWFudWFsbHkuXG5cdFx0VGhlIHRhZyBzeW50YXggb2YgSW1iYSBjb21waWxlcyB0byBhIGNoYWluIG9mIHNldHRlcnMsIHdoaWNoIGFsd2F5c1xuXHRcdGVuZHMgd2l0aCAuZW5kLiBgPGEubGFyZ2U+YCBjb21waWxlcyB0byBgdGFnKCdhJykuZmxhZygnbGFyZ2UnKS5lbmQoKWBcblx0XHRcblx0XHRZb3UgYXJlIGhpZ2hseSBhZHZpY2VkIHRvIG5vdCBvdmVycmlkZSBpdHMgYmVoYXZpb3VyLiBUaGUgZmlyc3QgdGltZVxuXHRcdGVuZCBpcyBjYWxsZWQgaXQgd2lsbCBtYXJrIHRoZSB0YWcgYXMgYnVpbHQgYW5kIGNhbGwgSW1iYS5UYWcjYnVpbGQsXG5cdFx0YW5kIGNhbGwgSW1iYS5UYWcjY29tbWl0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9idWlsdCkge1xuXHRcdFx0dGhpcy5jb21taXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYnVpbHQgPSB0cnVlO1xuXHRcdFx0dGhpcy5idWlsZCgpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFRoaXMgaXMgY2FsbGVkIGluc3RlYWQgb2YgSW1iYS5UYWcjZW5kIGZvciBgPHNlbGY+YCB0YWcgY2hhaW5zLlxuXHRcdERlZmF1bHRzIHRvIG5vb3Bcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc3luY2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyBhd2FrZW5lZCBpbiB0aGUgZG9tIC0gZWl0aGVyIGF1dG9tYXRpY2FsbHlcblx0Ly8gdXBvbiBhdHRhY2htZW50IHRvIHRoZSBkb20tdHJlZSwgb3IgdGhlIGZpcnN0IHRpbWUgaW1iYSBuZWVkcyB0aGVcblx0Ly8gdGFnIGZvciBhIGRvbW5vZGUgdGhhdCBoYXMgYmVlbiByZW5kZXJlZCBvbiB0aGUgc2VydmVyXG5cdEltYmEuVGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0TGlzdCBvZiBmbGFncyBmb3IgdGhpcyBub2RlLiBcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmZsYWdzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RvbS5jbGFzc0xpc3Q7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEFkZCBzcGVmaWNpZWQgZmxhZyB0byBjdXJyZW50IG5vZGUuXG5cdFx0SWYgYSBzZWNvbmQgYXJndW1lbnQgaXMgc3VwcGxpZWQsIGl0IHdpbGwgYmUgY29lcmNlZCBpbnRvIGEgQm9vbGVhbixcblx0XHRhbmQgdXNlZCB0byBpbmRpY2F0ZSB3aGV0aGVyIHdlIHNob3VsZCByZW1vdmUgdGhlIGZsYWcgaW5zdGVhZC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZmxhZyA9IGZ1bmN0aW9uIChuYW1lLHRvZ2dsZXIpe1xuXHRcdC8vIGl0IGlzIG1vc3QgbmF0dXJhbCB0byB0cmVhdCBhIHNlY29uZCB1bmRlZmluZWQgYXJndW1lbnQgYXMgYSBuby1zd2l0Y2hcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBhcmd1bWVudHMtbGVuZ3RoXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMiAmJiAhdG9nZ2xlcikge1xuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RvbS5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJlbW92ZSBzcGVjaWZpZWQgZmxhZyBmcm9tIG5vZGVcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUudW5mbGFnID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHRoaXMuX2RvbS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRUb2dnbGUgc3BlY2lmaWVkIGZsYWcgb24gbm9kZVxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS50b2dnbGVGbGFnID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHRoaXMuX2RvbS5jbGFzc0xpc3QudG9nZ2xlKG5hbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRDaGVjayB3aGV0aGVyIGN1cnJlbnQgbm9kZSBoYXMgc3BlY2lmaWVkIGZsYWdcblx0XHRAcmV0dXJuIHtib29sfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuaGFzRmxhZyA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5fZG9tLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcblx0fTtcblx0XG5cdC8qXG5cdFx0R2V0IHRoZSBzY2hlZHVsZXIgZm9yIHRoaXMgbm9kZS4gQSBuZXcgc2NoZWR1bGVyIHdpbGwgYmUgY3JlYXRlZFxuXHRcdGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG5cdFxuXHRcdEByZXR1cm4ge0ltYmEuU2NoZWR1bGVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2NoZWR1bGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlciA9PSBudWxsID8gKHRoaXMuX3NjaGVkdWxlciA9IG5ldyBJbWJhLlNjaGVkdWxlcih0aGlzKSkgOiAodGhpcy5fc2NoZWR1bGVyKTtcblx0fTtcblx0XG5cdC8qXG5cdFxuXHRcdFNob3J0aGFuZCB0byBzdGFydCBzY2hlZHVsaW5nIGEgbm9kZS4gVGhlIG1ldGhvZCB3aWxsIGJhc2ljYWxseVxuXHRcdHByb3h5IHRoZSBhcmd1bWVudHMgdGhyb3VnaCB0byBzY2hlZHVsZXIuY29uZmlndXJlLCBhbmQgdGhlblxuXHRcdGFjdGl2YXRlIHRoZSBzY2hlZHVsZXIuXG5cdFx0XG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpe1xuXHRcdGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuXHRcdHRoaXMuc2NoZWR1bGVyKCkuY29uZmlndXJlKG9wdGlvbnMpLmFjdGl2YXRlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFNob3J0aGFuZCBmb3IgZGVhY3RpdmF0aW5nIHNjaGVkdWxlciAoaWYgdGFnIGhhcyBvbmUpLlxuXHRcdEBkZXByZWNhdGVkXG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS51bnNjaGVkdWxlID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX3NjaGVkdWxlcikgeyB0aGlzLnNjaGVkdWxlcigpLmRlYWN0aXZhdGUoKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdC8qXG5cdFx0R2V0IHRoZSBwYXJlbnQgb2YgY3VycmVudCBub2RlXG5cdFx0QHJldHVybiB7SW1iYS5UYWd9IFxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRhZyR3cmFwKHRoaXMuZG9tKCkucGFyZW50Tm9kZSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFNob3J0aGFuZCBmb3IgY29uc29sZS5sb2cgb24gZWxlbWVudHNcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyICQwID0gYXJndW1lbnRzLCBpID0gJDAubGVuZ3RoO1xuXHRcdHZhciBhcmdzID0gbmV3IEFycmF5KGk+MCA/IGkgOiAwKTtcblx0XHR3aGlsZShpPjApIGFyZ3NbaS0xXSA9ICQwWy0taV07XG5cdFx0YXJncy51bnNoaWZ0KGNvbnNvbGUpO1xuXHRcdEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmFwcGx5KGNvbnNvbGUubG9nLGFyZ3MpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5pbml0aWFsaXplID0gSW1iYS5UYWc7XG5cdFxuXHRIVE1MX1RBR1MgPSBcImEgYWJiciBhZGRyZXNzIGFyZWEgYXJ0aWNsZSBhc2lkZSBhdWRpbyBiIGJhc2UgYmRpIGJkbyBiaWcgYmxvY2txdW90ZSBib2R5IGJyIGJ1dHRvbiBjYW52YXMgY2FwdGlvbiBjaXRlIGNvZGUgY29sIGNvbGdyb3VwIGRhdGEgZGF0YWxpc3QgZGQgZGVsIGRldGFpbHMgZGZuIGRpdiBkbCBkdCBlbSBlbWJlZCBmaWVsZHNldCBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNSBoNiBoZWFkIGhlYWRlciBociBodG1sIGkgaWZyYW1lIGltZyBpbnB1dCBpbnMga2JkIGtleWdlbiBsYWJlbCBsZWdlbmQgbGkgbGluayBtYWluIG1hcCBtYXJrIG1lbnUgbWVudWl0ZW0gbWV0YSBtZXRlciBuYXYgbm9zY3JpcHQgb2JqZWN0IG9sIG9wdGdyb3VwIG9wdGlvbiBvdXRwdXQgcCBwYXJhbSBwcmUgcHJvZ3Jlc3MgcSBycCBydCBydWJ5IHMgc2FtcCBzY3JpcHQgc2VjdGlvbiBzZWxlY3Qgc21hbGwgc291cmNlIHNwYW4gc3Ryb25nIHN0eWxlIHN1YiBzdW1tYXJ5IHN1cCB0YWJsZSB0Ym9keSB0ZCB0ZXh0YXJlYSB0Zm9vdCB0aCB0aGVhZCB0aW1lIHRpdGxlIHRyIHRyYWNrIHUgdWwgdmFyIHZpZGVvIHdiclwiLnNwbGl0KFwiIFwiKTtcblx0SFRNTF9UQUdTX1VOU0FGRSA9IFwiYXJ0aWNsZSBhc2lkZSBoZWFkZXIgc2VjdGlvblwiLnNwbGl0KFwiIFwiKTtcblx0U1ZHX1RBR1MgPSBcImNpcmNsZSBkZWZzIGVsbGlwc2UgZyBsaW5lIGxpbmVhckdyYWRpZW50IG1hc2sgcGF0aCBwYXR0ZXJuIHBvbHlnb24gcG9seWxpbmUgcmFkaWFsR3JhZGllbnQgcmVjdCBzdG9wIHN2ZyB0ZXh0IHRzcGFuXCIuc3BsaXQoXCIgXCIpO1xuXHRcblx0XG5cdGZ1bmN0aW9uIGV4dGVuZGVyKG9iaixzdXApe1xuXHRcdGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoc3VwKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdG9ialsoJDEgPSBrZXlzW2ldKV0gPT0gbnVsbCA/IChvYmpbJDFdID0gc3VwW2tleXNbaV1dKSA6IChvYmpbJDFdKTtcblx0XHR9O1xuXHRcdFxuXHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0XHRpZiAoc3VwLmluaGVyaXQpIHsgc3VwLmluaGVyaXQob2JqKSB9O1xuXHRcdHJldHVybiBvYmo7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBUYWcoKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZG9tKSB7XG5cdFx0XHR0aGlzLnNldERvbShkb20pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFRhZ1NwYXduZXIodHlwZSl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHlwZS5idWlsZCgpOyB9O1xuXHR9O1xuXHRcblx0SW1iYS5UYWdzID0gZnVuY3Rpb24gVGFncygpe1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLl9fY2xvbmUgPSBmdW5jdGlvbiAobnMpe1xuXHRcdHZhciBjbG9uZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG5cdFx0Y2xvbmUuX3BhcmVudCA9IHRoaXM7XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9O1xuXHRcblx0SW1iYS5UYWdzLnByb3RvdHlwZS5kZWZpbmVOYW1lc3BhY2UgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0dmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcblx0XHRjbG9uZS5fcGFyZW50ID0gdGhpcztcblx0XHRjbG9uZS5fbnMgPSBuYW1lO1xuXHRcdHRoaXNbbmFtZS50b1VwcGVyQ2FzZSgpXSA9IGNsb25lO1xuXHRcdHJldHVybiBjbG9uZTtcblx0fTtcblx0XG5cdEltYmEuVGFncy5wcm90b3R5cGUuYmFzZVR5cGUgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0cmV0dXJuIGlkeCQobmFtZSxIVE1MX1RBR1MpID49IDAgPyAoJ2h0bWxlbGVtZW50JykgOiAoJ2RpdicpO1xuXHR9O1xuXHRcblx0SW1iYS5UYWdzLnByb3RvdHlwZS5kZWZpbmVUYWcgPSBmdW5jdGlvbiAobmFtZSxzdXByLGJvZHkpe1xuXHRcdGlmKGJvZHk9PXVuZGVmaW5lZCAmJiB0eXBlb2Ygc3VwciA9PSAnZnVuY3Rpb24nKSBib2R5ID0gc3VwcixzdXByID0gJyc7XG5cdFx0aWYoc3Vwcj09dW5kZWZpbmVkKSBzdXByID0gJyc7XG5cdFx0c3VwciB8fCAoc3VwciA9IHRoaXMuYmFzZVR5cGUobmFtZSkpO1xuXHRcdHZhciBzdXBlcnR5cGUgPSB0aGlzW3N1cHJdO1xuXHRcdHZhciB0YWd0eXBlID0gVGFnKCk7XG5cdFx0dmFyIG5vcm0gPSBuYW1lLnJlcGxhY2UoL1xcLS9nLCdfJyk7XG5cdFx0XG5cdFx0XG5cdFx0dGFndHlwZS5fbmFtZSA9IG5hbWU7XG5cdFx0ZXh0ZW5kZXIodGFndHlwZSxzdXBlcnR5cGUpO1xuXHRcdFxuXHRcdGlmIChuYW1lWzBdID09ICcjJykge1xuXHRcdFx0dGhpc1tuYW1lXSA9IHRhZ3R5cGU7XG5cdFx0XHRJbWJhLlNJTkdMRVRPTlNbbmFtZS5zbGljZSgxKV0gPSB0YWd0eXBlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW25hbWVdID0gdGFndHlwZTtcblx0XHRcdHRoaXNbJyQnICsgbm9ybV0gPSBUYWdTcGF3bmVyKHRhZ3R5cGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGJvZHkpIHtcblx0XHRcdGlmIChib2R5Lmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdC8vIGNyZWF0ZSBjbG9uZVxuXHRcdFx0XHRpZiAoIXRhZ3R5cGUuaGFzT3duUHJvcGVydHkoJ1RBR1MnKSkge1xuXHRcdFx0XHRcdHRhZ3R5cGUuVEFHUyA9IChzdXBlcnR5cGUuVEFHUyB8fCB0aGlzKS5fX2Nsb25lKCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRib2R5LmNhbGwodGFndHlwZSx0YWd0eXBlLHRhZ3R5cGUuVEFHUyB8fCB0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0YWd0eXBlO1xuXHR9O1xuXHRcblx0SW1iYS5UYWdzLnByb3RvdHlwZS5kZWZpbmVTaW5nbGV0b24gPSBmdW5jdGlvbiAobmFtZSxzdXByLGJvZHkpe1xuXHRcdHJldHVybiB0aGlzLmRlZmluZVRhZyhuYW1lLHN1cHIsYm9keSk7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmV4dGVuZFRhZyA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0aWYoYm9keT09dW5kZWZpbmVkICYmIHR5cGVvZiBzdXByID09ICdmdW5jdGlvbicpIGJvZHkgPSBzdXByLHN1cHIgPSAnJztcblx0XHRpZihzdXByPT11bmRlZmluZWQpIHN1cHIgPSAnJztcblx0XHR2YXIga2xhc3MgPSAoKHR5cGVvZiBuYW1lPT0nc3RyaW5nJ3x8bmFtZSBpbnN0YW5jZW9mIFN0cmluZykgPyAodGhpc1tuYW1lXSkgOiAobmFtZSkpO1xuXHRcdC8vIGFsbG93IGZvciBwcml2YXRlIHRhZ3MgaGVyZSBhcyB3ZWxsP1xuXHRcdGlmIChib2R5KSB7IGJvZHkgJiYgYm9keS5jYWxsKGtsYXNzLGtsYXNzLGtsYXNzLnByb3RvdHlwZSkgfTtcblx0XHRyZXR1cm4ga2xhc3M7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5UQUdTID0gbmV3IEltYmEuVGFncygpO1xuXHRJbWJhLlRBR1MuZWxlbWVudCA9IEltYmEuVGFnO1xuXHRcblx0dmFyIHN2ZyA9IEltYmEuVEFHUy5kZWZpbmVOYW1lc3BhY2UoJ3N2ZycpO1xuXHRcblx0c3ZnLmJhc2VUeXBlID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHJldHVybiAnc3ZnZWxlbWVudCc7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5TSU5HTEVUT05TID0ge307XG5cdFxuXHRcblx0SW1iYS5kZWZpbmVUYWcgPSBmdW5jdGlvbiAobmFtZSxzdXByLGJvZHkpe1xuXHRcdGlmKGJvZHk9PXVuZGVmaW5lZCAmJiB0eXBlb2Ygc3VwciA9PSAnZnVuY3Rpb24nKSBib2R5ID0gc3VwcixzdXByID0gJyc7XG5cdFx0aWYoc3Vwcj09dW5kZWZpbmVkKSBzdXByID0gJyc7XG5cdFx0cmV0dXJuIEltYmEuVEFHUy5kZWZpbmVUYWcobmFtZSxzdXByLGJvZHkpO1xuXHR9O1xuXHRcblx0SW1iYS5kZWZpbmVTaW5nbGV0b25UYWcgPSBmdW5jdGlvbiAoaWQsc3Vwcixib2R5KXtcblx0XHRpZihib2R5PT11bmRlZmluZWQgJiYgdHlwZW9mIHN1cHIgPT0gJ2Z1bmN0aW9uJykgYm9keSA9IHN1cHIsc3VwciA9ICdkaXYnO1xuXHRcdGlmKHN1cHI9PXVuZGVmaW5lZCkgc3VwciA9ICdkaXYnO1xuXHRcdHJldHVybiBJbWJhLlRBR1MuZGVmaW5lVGFnKHRoaXMubmFtZSgpLHN1cHIsYm9keSk7XG5cdH07XG5cdFxuXHRJbWJhLmV4dGVuZFRhZyA9IGZ1bmN0aW9uIChuYW1lLGJvZHkpe1xuXHRcdHJldHVybiBJbWJhLlRBR1MuZXh0ZW5kVGFnKG5hbWUsYm9keSk7XG5cdH07XG5cdFxuXHRJbWJhLnRhZyA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHR2YXIgdHlwID0gSW1iYS5UQUdTW25hbWVdO1xuXHRcdGlmICghdHlwKSB7IHRocm93IG5ldyBFcnJvcigoXCJ0YWcgXCIgKyBuYW1lICsgXCIgaXMgbm90IGRlZmluZWRcIikpIH07XG5cdFx0cmV0dXJuIG5ldyB0eXAodHlwLmNyZWF0ZU5vZGUoKSk7XG5cdH07XG5cdFxuXHRJbWJhLnRhZ1dpdGhJZCA9IGZ1bmN0aW9uIChuYW1lLGlkKXtcblx0XHR2YXIgdHlwID0gSW1iYS5UQUdTW25hbWVdO1xuXHRcdGlmICghdHlwKSB7IHRocm93IG5ldyBFcnJvcigoXCJ0YWcgXCIgKyBuYW1lICsgXCIgaXMgbm90IGRlZmluZWRcIikpIH07XG5cdFx0dmFyIGRvbSA9IHR5cC5jcmVhdGVOb2RlKCk7XG5cdFx0ZG9tLmlkID0gaWQ7XG5cdFx0cmV0dXJuIG5ldyB0eXAoZG9tKTtcblx0fTtcblx0XG5cdC8vIFRPRE86IENhbiB3ZSBtb3ZlIHRoZXNlIG91dCBhbmQgaW50byBkb20uaW1iYSBpbiBhIGNsZWFuIHdheT9cblx0Ly8gVGhlc2UgbWV0aG9kcyBkZXBlbmRzIG9uIEltYmEuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWRcblx0XG5cdEltYmEuZ2V0VGFnU2luZ2xldG9uID0gZnVuY3Rpb24gKGlkKXtcblx0XHR2YXIga2xhc3M7XG5cdFx0dmFyIGRvbSxub2RlO1xuXHRcdFxuXHRcdGlmIChrbGFzcyA9IEltYmEuU0lOR0xFVE9OU1tpZF0pIHtcblx0XHRcdGlmIChrbGFzcyAmJiBrbGFzcy5JbnN0YW5jZSkgeyByZXR1cm4ga2xhc3MuSW5zdGFuY2UgfTtcblx0XHRcdFxuXHRcdFx0Ly8gbm8gaW5zdGFuY2UgLSBjaGVjayBmb3IgZWxlbWVudFxuXHRcdFx0aWYgKGRvbSA9IEltYmEuZG9jdW1lbnQoKS5nZXRFbGVtZW50QnlJZChpZCkpIHtcblx0XHRcdFx0Ly8gd2UgaGF2ZSBhIGxpdmUgaW5zdGFuY2UgLSB3aGVuIGZpbmRpbmcgaXQgdGhyb3VnaCBhIHNlbGVjdG9yIHdlIHNob3VsZCBhd2FrZSBpdCwgbm8/XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdjcmVhdGluZyB0aGUgc2luZ2xldG9uIGZyb20gZXhpc3Rpbmcgbm9kZSBpbiBkb20/JyxpZCx0eXBlKVxuXHRcdFx0XHRub2RlID0ga2xhc3MuSW5zdGFuY2UgPSBuZXcga2xhc3MoZG9tKTtcblx0XHRcdFx0bm9kZS5hd2FrZW4oZG9tKTsgLy8gc2hvdWxkIG9ubHkgYXdha2VuXG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0ZG9tID0ga2xhc3MuY3JlYXRlTm9kZSgpO1xuXHRcdFx0ZG9tLmlkID0gaWQ7XG5cdFx0XHRub2RlID0ga2xhc3MuSW5zdGFuY2UgPSBuZXcga2xhc3MoZG9tKTtcblx0XHRcdG5vZGUuZW5kKCkuYXdha2VuKGRvbSk7XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9IGVsc2UgaWYgKGRvbSA9IEltYmEuZG9jdW1lbnQoKS5nZXRFbGVtZW50QnlJZChpZCkpIHtcblx0XHRcdHJldHVybiBJbWJhLmdldFRhZ0ZvckRvbShkb20pO1xuXHRcdH07XG5cdH07XG5cdFxuXHR2YXIgc3ZnU3VwcG9ydCA9IHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblx0XG5cdEltYmEuZ2V0VGFnRm9yRG9tID0gZnVuY3Rpb24gKGRvbSl7XG5cdFx0dmFyIG07XG5cdFx0aWYgKCFkb20pIHsgcmV0dXJuIG51bGwgfTtcblx0XHRpZiAoZG9tLl9kb20pIHsgcmV0dXJuIGRvbSB9OyAvLyBjb3VsZCB1c2UgaW5oZXJpdGFuY2UgaW5zdGVhZFxuXHRcdGlmIChkb20uX3RhZykgeyByZXR1cm4gZG9tLl90YWcgfTtcblx0XHRpZiAoIWRvbS5ub2RlTmFtZSkgeyByZXR1cm4gbnVsbCB9O1xuXHRcdFxuXHRcdHZhciBucyA9IG51bGw7XG5cdFx0dmFyIGlkID0gZG9tLmlkO1xuXHRcdHZhciB0eXBlID0gZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0dmFyIHRhZ3MgPSBJbWJhLlRBR1M7XG5cdFx0dmFyIG5hdGl2ZSQgPSB0eXBlO1xuXHRcdHZhciBjbHMgPSBkb20uY2xhc3NOYW1lO1xuXHRcdFxuXHRcdGlmIChpZCAmJiBJbWJhLlNJTkdMRVRPTlNbaWRdKSB7XG5cdFx0XHQvLyBGSVhNRSBjb250cm9sIHRoYXQgaXQgaXMgdGhlIHNhbWUgc2luZ2xldG9uP1xuXHRcdFx0Ly8gbWlnaHQgY29sbGlkZSAtLSBub3QgZ29vZD9cblx0XHRcdHJldHVybiBJbWJhLmdldFRhZ1NpbmdsZXRvbihpZCk7XG5cdFx0fTtcblx0XHQvLyBsb29rIGZvciBpZCAtIHNpbmdsZXRvblxuXHRcdFxuXHRcdC8vIG5lZWQgYmV0dGVyIHRlc3QgaGVyZVxuXHRcdGlmIChzdmdTdXBwb3J0ICYmIChkb20gaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkge1xuXHRcdFx0bnMgPSBcInN2Z1wiO1xuXHRcdFx0Y2xzID0gZG9tLmNsYXNzTmFtZS5iYXNlVmFsO1xuXHRcdFx0dGFncyA9IHRhZ3MuU1ZHO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHNwYXduZXI7XG5cdFx0XG5cdFx0aWYgKGNscykge1xuXHRcdFx0Ly8gdGhlcmUgY2FuIGJlIHNldmVyYWwgbWF0Y2hlcyBoZXJlIC0gc2hvdWxkIGNob29zZSB0aGUgbGFzdFxuXHRcdFx0Ly8gc2hvdWxkIGZhbGwgYmFjayB0byBsZXNzIHNwZWNpZmljIGxhdGVyPyAtIG90aGVyd2lzZSB0aGluZ3MgbWF5IGZhaWxcblx0XHRcdC8vIFRPRE8gcmV3b3JrIHRoaXNcblx0XHRcdGlmIChtID0gY2xzLm1hdGNoKC9cXGJfKFthLXpcXC1dKylcXGIoPyFcXHMqX1thLXpcXC1dKykvKSkge1xuXHRcdFx0XHR0eXBlID0gbVsxXTsgLy8gLnJlcGxhY2UoLy0vZywnXycpXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobSA9IGNscy5tYXRjaCgvXFxiKFtBLVpcXC1dKylfXFxiLykpIHtcblx0XHRcdFx0bnMgPSBtWzFdO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHNwYXduZXIgPSB0YWdzW3R5cGVdIHx8IHRhZ3NbbmF0aXZlJF07XG5cdFx0cmV0dXJuIHNwYXduZXIgPyAobmV3IHNwYXduZXIoZG9tKS5hd2FrZW4oZG9tKSkgOiAobnVsbCk7XG5cdH07XG5cdFxuXHR0YWckID0gSW1iYS5UQUdTO1xuXHR0JCA9IEltYmEudGFnO1xuXHR0YyQgPSBJbWJhLnRhZ1dpdGhGbGFncztcblx0dGkkID0gSW1iYS50YWdXaXRoSWQ7XG5cdHRpYyQgPSBJbWJhLnRhZ1dpdGhJZEFuZEZsYWdzO1xuXHRpZCQgPSBJbWJhLmdldFRhZ1NpbmdsZXRvbjtcblx0cmV0dXJuIHRhZyR3cmFwID0gSW1iYS5nZXRUYWdGb3JEb207XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL3RhZy5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0SW1iYS5kb2N1bWVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XG5cdH07XG5cdFxuXHQvKlxuXHRSZXR1cm5zIHRoZSBib2R5IGVsZW1lbnQgd3JhcHBlZCBpbiBhbiBJbWJhLlRhZ1xuXHQqL1xuXHRcblx0SW1iYS5yb290ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRhZyR3cmFwKEltYmEuZG9jdW1lbnQoKS5ib2R5KTtcblx0fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdodG1sZWxlbWVudCcsICdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHQvKlxuXHRcdFx0Q2FsbGVkIHdoZW4gYSB0YWcgdHlwZSBpcyBiZWluZyBzdWJjbGFzc2VkLlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcuaW5oZXJpdCA9IGZ1bmN0aW9uIChjaGlsZCl7XG5cdFx0XHRjaGlsZC5wcm90b3R5cGUuX2VtcHR5ID0gdHJ1ZTtcblx0XHRcdGNoaWxkLl9wcm90b0RvbSA9IG51bGw7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9ub2RlVHlwZSkge1xuXHRcdFx0XHRjaGlsZC5fbm9kZVR5cGUgPSB0aGlzLl9ub2RlVHlwZTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBjbGFzc05hbWUgPSBcIl9cIiArIGNoaWxkLl9uYW1lLnJlcGxhY2UoL18vZywnLScpO1xuXHRcdFx0XHRpZiAoY2hpbGQuX25hbWVbMF0gIT0gJyMnKSB7IHJldHVybiBjaGlsZC5fY2xhc3NlcyA9IHRoaXMuX2NsYXNzZXMuY29uY2F0KGNsYXNzTmFtZSkgfTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoaWxkLl9ub2RlVHlwZSA9IGNoaWxkLl9uYW1lO1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQuX2NsYXNzZXMgPSBbXTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcuYnVpbGROb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZG9tID0gSW1iYS5kb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQodGhpcy5fbm9kZVR5cGUpO1xuXHRcdFx0dmFyIGNscyA9IHRoaXMuX2NsYXNzZXMuam9pbihcIiBcIik7XG5cdFx0XHRpZiAoY2xzKSB7IGRvbS5jbGFzc05hbWUgPSBjbHMgfTtcblx0XHRcdHJldHVybiBkb207XG5cdFx0fTtcblx0XHRcblx0XHR0YWcuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHByb3RvID0gKHRoaXMuX3Byb3RvRG9tIHx8ICh0aGlzLl9wcm90b0RvbSA9IHRoaXMuYnVpbGROb2RlKCkpKTtcblx0XHRcdHJldHVybiBwcm90by5jbG9uZU5vZGUoZmFsc2UpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLmRvbSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Byb3RvRG9tIHx8ICh0aGlzLl9wcm90b0RvbSA9IHRoaXMuYnVpbGROb2RlKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdpZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGFiaW5kZXggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUYWJpbmRleCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRpdGxlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndGl0bGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RpdGxlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb2xlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm9sZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSb2xlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyb2xlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5vZmZzZXRXaWR0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLm9mZnNldEhlaWdodDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZXMsdHlwZSl7XG5cdFx0XHR0aGlzLl9lbXB0eSA/ICh0aGlzLmFwcGVuZChub2RlcykpIDogKHRoaXMuZW1wdHkoKS5hcHBlbmQobm9kZXMpKTtcblx0XHRcdHRoaXMuX2NoaWxkcmVuID0gbnVsbDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdFNldCBpbm5lciBodG1sIG9mIG5vZGVcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIdG1sID0gZnVuY3Rpb24gKGh0bWwpe1xuXHRcdFx0dGhpcy5fZG9tLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgaW5uZXIgaHRtbCBvZiBub2RlXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5pbm5lckhUTUw7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0UmVtb3ZlIGFsbCBjb250ZW50IGluc2lkZSBub2RlXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHdoaWxlICh0aGlzLl9kb20uZmlyc3RDaGlsZCl7XG5cdFx0XHRcdHRoaXMuX2RvbS5yZW1vdmVDaGlsZCh0aGlzLl9kb20uZmlyc3RDaGlsZCk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4gPSBudWxsO1xuXHRcdFx0dGhpcy5fZW1wdHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0UmVtb3ZlIHNwZWNpZmllZCBjaGlsZCBmcm9tIGN1cnJlbnQgbm9kZS5cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoY2hpbGQpe1xuXHRcdFx0dmFyIHBhciA9IHRoaXMuZG9tKCk7XG5cdFx0XHR2YXIgZWwgPSBjaGlsZCAmJiBjaGlsZC5kb20oKTtcblx0XHRcdGlmIChlbCAmJiBlbC5wYXJlbnROb2RlID09IHBhcikgeyBwYXIucmVtb3ZlQ2hpbGQoZWwpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChuYW1lLHBhcnMpe1xuXHRcdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdFx0dmFyIGRhdGEgPSBwYXJzLmRhdGEgIT09IHVuZGVmaW5lZCA/IHBhcnMuZGF0YSA6IG51bGw7XG5cdFx0XHR2YXIgYnViYmxlID0gcGFycy5idWJibGUgIT09IHVuZGVmaW5lZCA/IHBhcnMuYnViYmxlIDogdHJ1ZTtcblx0XHRcdEltYmEuRXZlbnRzLnRyaWdnZXIobmFtZSx0aGlzLHtkYXRhOiBkYXRhLGJ1YmJsZTogYnViYmxlfSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKGtleSx2YWwpe1xuXHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGtleSksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dGhpcy5jc3Moa2V5c1tpXSxrZXlba2V5c1tpXV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICh2YWwgPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbCA9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuc3R5bGVba2V5XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgodHlwZW9mIHZhbD09J251bWJlcid8fHZhbCBpbnN0YW5jZW9mIE51bWJlcikgJiYga2V5Lm1hdGNoKC93aWR0aHxoZWlnaHR8bGVmdHxyaWdodHx0b3B8Ym90dG9tLykpIHtcblx0XHRcdFx0XHR2YWwgPSB2YWwgKyBcInB4XCI7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuZG9tKCkuc3R5bGVba2V5XSA9IHZhbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGF0YXNldCA9IGZ1bmN0aW9uIChrZXksdmFsKXtcblx0XHRcdGlmIChrZXkgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhrZXkpLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHRcdHRoaXMuZGF0YXNldChrZXlzW2ldLGtleVtrZXlzW2ldXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgoXCJkYXRhLVwiICsga2V5KSx2YWwpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKChcImRhdGEtXCIgKyBrZXkpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5kb20oKS5kYXRhc2V0O1xuXHRcdFx0XG5cdFx0XHRpZiAoIWRhdGFzZXQpIHtcblx0XHRcdFx0ZGF0YXNldCA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBpMSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuZG9tKCkuYXR0cmlidXRlcyksIGxlbiA9IGFyeS5sZW5ndGgsIGF0cjsgaTEgPCBsZW47IGkxKyspIHtcblx0XHRcdFx0XHRhdHIgPSBhcnlbaTFdO1xuXHRcdFx0XHRcdGlmIChhdHIubmFtZS5zdWJzdHIoMCw1KSA9PSAnZGF0YS0nKSB7XG5cdFx0XHRcdFx0XHRkYXRhc2V0W0ltYmEudG9DYW1lbENhc2UoYXRyLm5hbWUuc2xpY2UoNSkpXSA9IGF0ci52YWx1ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGRhdGFzZXQ7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IGRlc2NlbmRhbnRzIG9mIGN1cnJlbnQgbm9kZSwgb3B0aW9uYWxseSBtYXRjaGluZyBzZWxlY3RvclxuXHRcdFx0QHJldHVybiB7SW1iYS5TZWxlY3Rvcn1cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRyZXR1cm4gbmV3IEltYmEuU2VsZWN0b3Ioc2VsLHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgY2hpbGQgb2Ygbm9kZVxuXHRcdFxuXHRcdFx0QHJldHVybiB7SW1iYS5UYWd9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHJldHVybiBzZWwgPyAodGhpcy5maW5kKHNlbCkuZmlyc3QoKSkgOiAodGFnJHdyYXAodGhpcy5kb20oKS5maXJzdEVsZW1lbnRDaGlsZCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCB0aGUgbGFzdCBtYXRjaGluZyBjaGlsZCBvZiBub2RlXG5cdFx0XG5cdFx0XHRcdG5vZGUubGFzdCAjIHJldHVybnMgdGhlIGxhc3QgY2hpbGQgb2Ygbm9kZVxuXHRcdFx0XHRub2RlLmxhc3QgJXNwYW4gIyByZXR1cm5zIHRoZSBsYXN0IHNwYW4gaW5zaWRlIG5vZGVcblx0XHRcdFx0bm9kZS5sYXN0IGRvIHxlbHwgZWwudGV4dCA9PSAnSGknICMgcmV0dXJuIGxhc3Qgbm9kZSB3aXRoIHRleHQgSGlcblx0XHRcblx0XHRcdEByZXR1cm4ge0ltYmEuVGFnfVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHJldHVybiBzZWwgPyAodGhpcy5maW5kKHNlbCkubGFzdCgpKSA6ICh0YWckd3JhcCh0aGlzLmRvbSgpLmxhc3RFbGVtZW50Q2hpbGQpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGNoaWxkIGF0IGluZGV4XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbiAoaSl7XG5cdFx0XHRyZXR1cm4gdGFnJHdyYXAodGhpcy5kb20oKS5jaGlsZHJlbltpIHx8IDBdKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHZhciBub2RlcyA9IG5ldyBJbWJhLlNlbGVjdG9yKG51bGwsdGhpcyx0aGlzLl9kb20uY2hpbGRyZW4pO1xuXHRcdFx0cmV0dXJuIHNlbCA/IChub2Rlcy5maWx0ZXIoc2VsKSkgOiAobm9kZXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vcnBoYW5pemUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBwYXI7XG5cdFx0XHRpZiAocGFyID0gdGhpcy5kb20oKS5wYXJlbnROb2RlKSB7IHBhci5yZW1vdmVDaGlsZCh0aGlzLl9kb20pIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0dmFyIGZuO1xuXHRcdFx0aWYgKHNlbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBzZWwodGhpcyk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoc2VsLnF1ZXJ5KSB7IHNlbCA9IHNlbC5xdWVyeSgpIH07XG5cdFx0XHRpZiAoZm4gPSAodGhpcy5fZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCB0aGlzLl9kb20ubWF0Y2hlcykpIHsgcmV0dXJuIGZuLmNhbGwodGhpcy5fZG9tLHNlbCkgfTtcblx0XHRcdC8vIFRPRE8gc3VwcG9ydCBvdGhlciBicm93c2VycyBldGM/XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBmaXJzdCBlbGVtZW50IG1hdGNoaW5nIHN1cHBsaWVkIHNlbGVjdG9yIC8gZmlsdGVyXG5cdFx0XHR0cmF2ZXJzaW5nIHVwd2FyZHMsIGJ1dCBpbmNsdWRpbmcgdGhlIG5vZGUgaXRzZWxmLlxuXHRcdFx0QHJldHVybiB7SW1iYS5UYWd9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xvc2VzdCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0aWYgKCFzZWwpIHsgcmV0dXJuIHRoaXMucGFyZW50KCkgfTsgLy8gc2hvdWxkIHJldHVybiBzZWxmPyFcblx0XHRcdHZhciBub2RlID0gdGhpcztcblx0XHRcdGlmIChzZWwucXVlcnkpIHsgc2VsID0gc2VsLnF1ZXJ5KCkgfTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKG5vZGUpe1xuXHRcdFx0XHRpZiAobm9kZS5tYXRjaGVzKHNlbCkpIHsgcmV0dXJuIG5vZGUgfTtcblx0XHRcdFx0bm9kZSA9IG5vZGUucGFyZW50KCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIG5vZGUgdGhhdCBtYXRjaGVzXG5cdFx0XHRzcGVjaWZpZWQgc2VsZWN0b3IgLyBtYXRjaGVyLlxuXHRcdFxuXHRcdFx0QHJldHVybiB7SW1iYS5UYWd9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudXAgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdGlmICghc2VsKSB7IHJldHVybiB0aGlzLnBhcmVudCgpIH07XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmNsb3Nlc3Qoc2VsKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0dmFyIG5vZGUgPSB0aGlzO1xuXHRcdFx0dmFyIG5vZGVzID0gW107XG5cdFx0XHRpZiAoc2VsICYmIHNlbC5xdWVyeSkgeyBzZWwgPSBzZWwucXVlcnkoKSB9O1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAobm9kZSl7XG5cdFx0XHRcdGlmICghc2VsIHx8IG5vZGUubWF0Y2hlcyhzZWwpKSB7IG5vZGVzLnB1c2gobm9kZSkgfTtcblx0XHRcdFx0bm9kZSA9IG5vZGUucGFyZW50KCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIG5vZGVzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHR2YXIgcGFyID0gdGhpcy5wYXJlbnQoKTtcblx0XHRcdHJldHVybiBwYXIgPyAocGFyLnBhdGgoc2VsKSkgOiAoW10pO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zaWJsaW5ncyA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0dmFyIHBhciwgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoIShwYXIgPSB0aGlzLnBhcmVudCgpKSkgeyByZXR1cm4gW10gfTsgLy8gRklYTUVcblx0XHRcdHZhciBhcnkgPSB0aGlzLmRvbSgpLnBhcmVudE5vZGUuY2hpbGRyZW47XG5cdFx0XHR2YXIgbm9kZXMgPSBuZXcgSW1iYS5TZWxlY3RvcihudWxsLHRoaXMsYXJ5KTtcblx0XHRcdHJldHVybiBub2Rlcy5maWx0ZXIoZnVuY3Rpb24obikgeyByZXR1cm4gbiAhPSBzZWxmICYmICghc2VsIHx8IG4ubWF0Y2hlcyhzZWwpKTsgfSk7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgc2libGluZyBvZiBub2RlLlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdGlmIChzZWwpIHtcblx0XHRcdFx0dmFyIGVsID0gdGhpcztcblx0XHRcdFx0d2hpbGUgKGVsID0gZWwubmV4dCgpKXtcblx0XHRcdFx0XHRpZiAoZWwubWF0Y2hlcyhzZWwpKSB7IHJldHVybiBlbCB9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGFnJHdyYXAodGhpcy5kb20oKS5uZXh0RWxlbWVudFNpYmxpbmcpO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCB0aGUgaW1tZWRpYXRlbHkgcHJlY2VlZGluZyBzaWJsaW5nIG9mIG5vZGUuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0aWYgKHNlbCkge1xuXHRcdFx0XHR2YXIgZWwgPSB0aGlzO1xuXHRcdFx0XHR3aGlsZSAoZWwgPSBlbC5wcmV2KCkpe1xuXHRcdFx0XHRcdGlmIChlbC5tYXRjaGVzKHNlbCkpIHsgcmV0dXJuIGVsIH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0YWckd3JhcCh0aGlzLmRvbSgpLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLmNvbnRhaW5zKG5vZGUgJiYgbm9kZS5fZG9tIHx8IG5vZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0dmFyIGVsID0gdGhpcy5kb20oKTtcblx0XHRcdHdoaWxlIChlbC5wcmV2aW91c1NpYmxpbmcpe1xuXHRcdFx0XHRlbCA9IGVsLnByZXZpb3VzU2libGluZztcblx0XHRcdFx0aSsrO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0Lypcblx0XHRcdFxuXHRcdFx0QGRlcHJlY2F0ZWRcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobm9kZSxwYXJzKXtcblx0XHRcdGlmKCFwYXJzfHxwYXJzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHBhcnMgPSB7fTtcblx0XHRcdHZhciBiZWZvcmUgPSBwYXJzLmJlZm9yZSAhPT0gdW5kZWZpbmVkID8gcGFycy5iZWZvcmUgOiBudWxsO1xuXHRcdFx0dmFyIGFmdGVyID0gcGFycy5hZnRlciAhPT0gdW5kZWZpbmVkID8gcGFycy5hZnRlciA6IG51bGw7XG5cdFx0XHRpZiAoYWZ0ZXIpIHsgYmVmb3JlID0gYWZ0ZXIubmV4dCgpIH07XG5cdFx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdG5vZGUgPSAodGFnJC4kZnJhZ21lbnQoKS5zZXRDb250ZW50KG5vZGUsMCkuZW5kKCkpO1xuXHRcdFx0fTtcblx0XHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdFx0dGhpcy5kb20oKS5pbnNlcnRCZWZvcmUobm9kZS5kb20oKSxiZWZvcmUuZG9tKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hcHBlbmQobm9kZSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0Rm9jdXMgb24gY3VycmVudCBub2RlXG5cdFx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmRvbSgpLmZvY3VzKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgZm9jdXMgZnJvbSBjdXJyZW50IG5vZGVcblx0XHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5kb20oKS5ibHVyKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGVtcGxhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEB0b2RvIFNob3VsZCBzdXBwb3J0IG11bHRpcGxlIGFyZ3VtZW50cyBsaWtlIGFwcGVuZFxuXHRcdFxuXHRcdFx0VGhlIC5wcmVwZW5kIG1ldGhvZCBpbnNlcnRzIHRoZSBzcGVjaWZpZWQgY29udGVudCBhcyB0aGUgZmlyc3Rcblx0XHRcdGNoaWxkIG9mIHRoZSB0YXJnZXQgbm9kZS4gSWYgdGhlIGNvbnRlbnQgaXMgYWxyZWFkeSBhIGNoaWxkIG9mIFxuXHRcdFx0bm9kZSBpdCB3aWxsIGJlIG1vdmVkIHRvIHRoZSBzdGFydC5cblx0XHRcdFxuXHRcdCAgICBcdG5vZGUucHJlcGVuZCA8ZGl2LnRvcD4gIyBwcmVwZW5kIG5vZGVcblx0XHQgICAgXHRub2RlLnByZXBlbmQgXCJzb21lIHRleHRcIiAjIHByZXBlbmQgdGV4dFxuXHRcdCAgICBcdG5vZGUucHJlcGVuZCBbPHVsPiw8dWw+XSAjIHByZXBlbmQgYXJyYXlcblx0XHRcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKGl0ZW0pe1xuXHRcdFx0dmFyIGZpcnN0ID0gdGhpcy5fZG9tLmNoaWxkTm9kZXNbMF07XG5cdFx0XHRmaXJzdCA/ICh0aGlzLmluc2VydEJlZm9yZShpdGVtLGZpcnN0KSkgOiAodGhpcy5hcHBlbmRDaGlsZChpdGVtKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRUaGUgLmFwcGVuZCBtZXRob2QgaW5zZXJ0cyB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYXMgdGhlIGxhc3QgY2hpbGRcblx0XHRcdG9mIHRoZSB0YXJnZXQgbm9kZS4gSWYgdGhlIGNvbnRlbnQgaXMgYWxyZWFkeSBhIGNoaWxkIG9mIG5vZGUgaXRcblx0XHRcdHdpbGwgYmUgbW92ZWQgdG8gdGhlIGVuZC5cblx0XHRcdFxuXHRcdFx0IyBleGFtcGxlXG5cdFx0XHQgICAgdmFyIHJvb3QgPSA8ZGl2LnJvb3Q+XG5cdFx0XHQgICAgdmFyIGl0ZW0gPSA8ZGl2Lml0ZW0+IFwiVGhpcyBpcyBhbiBpdGVtXCJcblx0XHRcdCAgICByb290LmFwcGVuZCBpdGVtICMgYXBwZW5kcyBpdGVtIHRvIHRoZSBlbmQgb2Ygcm9vdFxuXHRcdFxuXHRcdFx0ICAgIHJvb3QucHJlcGVuZCBcInNvbWUgdGV4dFwiICMgYXBwZW5kIHRleHRcblx0XHRcdCAgICByb290LnByZXBlbmQgWzx1bD4sPHVsPl0gIyBhcHBlbmQgYXJyYXlcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoaXRlbSl7XG5cdFx0XHQvLyBwb3NzaWJsZSB0byBhcHBlbmQgYmxhbmtcblx0XHRcdC8vIHBvc3NpYmxlIHRvIHNpbXBsaWZ5IG9uIHNlcnZlcj9cblx0XHRcdGlmICghaXRlbSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XG5cdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChpdGVtKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbWVtYmVyOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRtZW1iZXIgPSBhcnlbaV07XG5cdFx0XHRcdFx0bWVtYmVyICYmIHRoaXMuYXBwZW5kKG1lbWJlcik7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgaXRlbT09J3N0cmluZyd8fGl0ZW0gaW5zdGFuY2VvZiBTdHJpbmcpIHx8ICh0eXBlb2YgaXRlbT09J251bWJlcid8fGl0ZW0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG5cdFx0XHRcdHZhciBub2RlID0gSW1iYS5kb2N1bWVudCgpLmNyZWF0ZVRleHROb2RlKGl0ZW0pO1xuXHRcdFx0XHR0aGlzLl9kb20uYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHRcdGlmICh0aGlzLl9lbXB0eSkgeyB0aGlzLl9lbXB0eSA9IGZhbHNlIH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9kb20uYXBwZW5kQ2hpbGQoaXRlbS5fZG9tIHx8IGl0ZW0pO1xuXHRcdFx0XHRpZiAodGhpcy5fZW1wdHkpIHsgdGhpcy5fZW1wdHkgPSBmYWxzZSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0SW5zZXJ0IGEgbm9kZSBpbnRvIHRoZSBjdXJyZW50IG5vZGUgKHNlbGYpLCBiZWZvcmUgYW5vdGhlci5cblx0XHRcdFRoZSByZWxhdGl2ZSBub2RlIG11c3QgYmUgYSBjaGlsZCBvZiBjdXJyZW50IG5vZGUuIFxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChub2RlLHJlbCl7XG5cdFx0XHRpZiAoKHR5cGVvZiBub2RlPT0nc3RyaW5nJ3x8bm9kZSBpbnN0YW5jZW9mIFN0cmluZykpIHsgbm9kZSA9IEltYmEuZG9jdW1lbnQoKS5jcmVhdGVUZXh0Tm9kZShub2RlKSB9O1xuXHRcdFx0aWYgKG5vZGUgJiYgcmVsKSB7IHRoaXMuZG9tKCkuaW5zZXJ0QmVmb3JlKChub2RlLl9kb20gfHwgbm9kZSksKHJlbC5fZG9tIHx8IHJlbCkpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRBcHBlbmQgYSBzaW5nbGUgaXRlbSAobm9kZSBvciBzdHJpbmcpIHRvIHRoZSBjdXJyZW50IG5vZGUuXG5cdFx0XHRJZiBzdXBwbGllZCBpdGVtIGlzIGEgc3RyaW5nIGl0IHdpbGwgYXV0b21hdGljYWxseS4gVGhpcyBpcyB1c2VkXG5cdFx0XHRieSBJbWJhIGludGVybmFsbHksIGJ1dCB3aWxsIHByYWN0aWNhbGx5IG5ldmVyIGJlIHVzZWQgZXhwbGljaXRseS5cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRcdGlmICgodHlwZW9mIG5vZGU9PSdzdHJpbmcnfHxub2RlIGluc3RhbmNlb2YgU3RyaW5nKSkgeyBub2RlID0gSW1iYS5kb2N1bWVudCgpLmNyZWF0ZVRleHROb2RlKG5vZGUpIH07XG5cdFx0XHRpZiAobm9kZSkgeyB0aGlzLmRvbSgpLmFwcGVuZENoaWxkKG5vZGUuX2RvbSB8fCBub2RlKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0UmVtb3ZlIGEgc2luZ2xlIGNoaWxkIGZyb20gdGhlIGN1cnJlbnQgbm9kZS5cblx0XHRcdFVzZWQgYnkgSW1iYSBpbnRlcm5hbGx5LlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0aWYgKG5vZGUpIHsgdGhpcy5kb20oKS5yZW1vdmVDaGlsZChub2RlLl9kb20gfHwgbm9kZSkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS50b1N0cmluZygpOyAvLyByZWFsbHk/XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0QGRlcHJlY2F0ZWRcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbGFzc2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRjb25zb2xlLmxvZygnSW1iYS5UYWcjY2xhc3NlcyBpcyBkZXByZWNhdGVkJyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLmNsYXNzTGlzdDtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnc3ZnZWxlbWVudCcsICdodG1sZWxlbWVudCcpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBFeHRlbmRpbmcgSW1iYS5UYWcjY3NzIHRvIHdvcmsgd2l0aG91dCBwcmVmaXhlcyBieSBpbnNwZWN0aW5nXG5cdC8vIHRoZSBwcm9wZXJ0aWVzIG9mIGEgQ1NTU3R5bGVEZWNsYXJhdGlvbiBhbmQgY3JlYXRpbmcgYSBtYXBcblx0XG5cdC8vIHZhciBwcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCctbXMtJywnLW1vei0nLCctby0nLCctYmxpbmstJ11cblx0Ly8gdmFyIHByb3BzID0gWyd0cmFuc2Zvcm0nLCd0cmFuc2l0aW9uJywnYW5pbWF0aW9uJ11cblx0XG5cdHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsJycpO1xuXHRcblx0SW1iYS5DU1NLZXlNYXAgPSB7fTtcblx0XG5cdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzdHlsZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBwcmVmaXhlZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cHJlZml4ZWQgPSBhcnlbaV07XG5cdFx0dmFyIHVucHJlZml4ZWQgPSBwcmVmaXhlZC5yZXBsYWNlKC9eLSh3ZWJraXR8bXN8bW96fG98YmxpbmspLS8sJycpO1xuXHRcdHZhciBjYW1lbENhc2UgPSB1bnByZWZpeGVkLnJlcGxhY2UoLy0oXFx3KS9nLGZ1bmN0aW9uKG0sYSkgeyByZXR1cm4gYS50b1VwcGVyQ2FzZSgpOyB9KTtcblx0XHRcblx0XHQvLyBpZiB0aGVyZSBleGlzdHMgYW4gdW5wcmVmaXhlZCB2ZXJzaW9uIC0tIGFsd2F5cyB1c2UgdGhpc1xuXHRcdGlmIChwcmVmaXhlZCAhPSB1bnByZWZpeGVkKSB7XG5cdFx0XHRpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHVucHJlZml4ZWQpKSB7IGNvbnRpbnVlOyB9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcmVnaXN0ZXIgdGhlIHByZWZpeGVzXG5cdFx0SW1iYS5DU1NLZXlNYXBbdW5wcmVmaXhlZF0gPSBJbWJhLkNTU0tleU1hcFtjYW1lbENhc2VdID0gcHJlZml4ZWQ7XG5cdH07XG5cdFxuXHRyZXR1cm4gdGFnJC5leHRlbmRUYWcoJ2h0bWxlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHQvLyBvdmVycmlkZSB0aGUgb3JpZ2luYWwgY3NzIG1ldGhvZFxuXHRcdHRhZy5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKGtleSx2YWwpe1xuXHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGtleSksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dGhpcy5jc3Moa2V5c1tpXSxrZXlba2V5c1tpXV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGtleSA9IEltYmEuQ1NTS2V5TWFwW2tleV0gfHwga2V5O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5kb20oKS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwgPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnN0eWxlW2tleV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoKHR5cGVvZiB2YWw9PSdudW1iZXInfHx2YWwgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGtleS5tYXRjaCgvd2lkdGh8aGVpZ2h0fGxlZnR8cmlnaHR8dG9wfGJvdHRvbS8pKSB7XG5cdFx0XHRcdFx0dmFsID0gdmFsICsgXCJweFwiO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmRvbSgpLnN0eWxlW2tleV0gPSB2YWw7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLmNsaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0Ly8gcHJlZGVmaW5lIGFsbCBzdXBwb3J0ZWQgaHRtbCB0YWdzXG5cdHRhZyQuZGVmaW5lVGFnKCdmcmFnbWVudCcsICdodG1sZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBJbWJhLmRvY3VtZW50KCkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2EnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaHJlZiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHJlZiA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnaHJlZicsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhYmJyJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdhZGRyZXNzJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdhcmVhJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdhcnRpY2xlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdhc2lkZScpO1xuXHR0YWckLmRlZmluZVRhZygnYXVkaW8nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2InKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2Jhc2UnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2JkaScpO1xuXHR0YWckLmRlZmluZVRhZygnYmRvJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdiaWcnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2Jsb2NrcXVvdGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2JvZHknKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2JyJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYnV0dG9uJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF1dG9mb2N1cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndHlwZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnY2FudmFzJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0XHRpZiAodGhpcy53aWR0aCgpICE9IHZhbCkgeyB0aGlzLmRvbSgpLndpZHRoID0gdmFsIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0XHRpZiAodGhpcy5oZWlnaHQoKSAhPSB2YWwpIHsgdGhpcy5kb20oKS5oZWlnaHQgPSB2YWwgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkud2lkdGg7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuaGVpZ2h0O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24gKHR5cGUpe1xuXHRcdFx0aWYodHlwZSA9PT0gdW5kZWZpbmVkKSB0eXBlID0gJzJkJztcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLmdldENvbnRleHQodHlwZSk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnY2FwdGlvbicpO1xuXHR0YWckLmRlZmluZVRhZygnY2l0ZScpO1xuXHR0YWckLmRlZmluZVRhZygnY29kZScpO1xuXHR0YWckLmRlZmluZVRhZygnY29sJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdjb2xncm91cCcpO1xuXHR0YWckLmRlZmluZVRhZygnZGF0YScpO1xuXHR0YWckLmRlZmluZVRhZygnZGF0YWxpc3QnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RkJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkZWwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RldGFpbHMnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RmbicpO1xuXHR0YWckLmRlZmluZVRhZygnZGl2Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkbCcpO1xuXHR0YWckLmRlZmluZVRhZygnZHQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2VtJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdlbWJlZCcpO1xuXHR0YWckLmRlZmluZVRhZygnZmllbGRzZXQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2ZpZ2NhcHRpb24nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2ZpZ3VyZScpO1xuXHR0YWckLmRlZmluZVRhZygnZm9vdGVyJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZm9ybScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdtZXRob2QnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TWV0aG9kID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdtZXRob2QnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFjdGlvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGlvbicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBY3Rpb24gPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FjdGlvbicsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdoMScpO1xuXHR0YWckLmRlZmluZVRhZygnaDInKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2gzJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoNCcpO1xuXHR0YWckLmRlZmluZVRhZygnaDUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2g2Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoZWFkJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoZWFkZXInKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2hyJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdodG1sJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdpJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaWZyYW1lJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NyYycsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWcnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2lucHV0JywgZnVuY3Rpb24odGFnKXtcblx0XHQvLyBjYW4gdXNlIGF0dHIgaW5zdGVhZFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndHlwZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgncmVxdWlyZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpc2FibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0QXV0b2ZvY3VzID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS52YWx1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodil7XG5cdFx0XHRpZiAodiAhPSB0aGlzLmRvbSgpLnZhbHVlKSB7IHRoaXMuZG9tKCkudmFsdWUgPSB2IH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAodil7XG5cdFx0XHRpZiAodiAhPSB0aGlzLmRvbSgpLnBsYWNlaG9sZGVyKSB7IHRoaXMuZG9tKCkucGxhY2Vob2xkZXIgPSB2IH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnBsYWNlaG9sZGVyO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jaGVja2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5jaGVja2VkO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGVja2VkID0gZnVuY3Rpb24gKGJvb2wpe1xuXHRcdFx0aWYgKGJvb2wgIT0gdGhpcy5kb20oKS5jaGVja2VkKSB7IHRoaXMuZG9tKCkuY2hlY2tlZCA9IGJvb2wgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2lucycpO1xuXHR0YWckLmRlZmluZVRhZygna2JkJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdrZXlnZW4nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2xhYmVsJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdsZWdlbmQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2xpJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbGluaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyZWwnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmVsID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyZWwnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhyZWYgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdocmVmJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhyZWYgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1lZGlhID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbWVkaWEnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TWVkaWEgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ21lZGlhJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ21haW4nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ21hcCcpO1xuXHR0YWckLmRlZmluZVRhZygnbWFyaycpO1xuXHR0YWckLmRlZmluZVRhZygnbWVudScpO1xuXHR0YWckLmRlZmluZVRhZygnbWVudWl0ZW0nKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdtZXRhJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoYXJzZXQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdjaGFyc2V0Jyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldENoYXJzZXQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NoYXJzZXQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbWV0ZXInKTtcblx0dGFnJC5kZWZpbmVUYWcoJ25hdicpO1xuXHR0YWckLmRlZmluZVRhZygnbm9zY3JpcHQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ29iamVjdCcpO1xuXHR0YWckLmRlZmluZVRhZygnb2wnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ29wdGdyb3VwJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnb3B0aW9uJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ291dHB1dCcpO1xuXHR0YWckLmRlZmluZVRhZygncCcpO1xuXHR0YWckLmRlZmluZVRhZygncGFyYW0nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3ByZScpO1xuXHR0YWckLmRlZmluZVRhZygncHJvZ3Jlc3MnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3EnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3JwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdydCcpO1xuXHR0YWckLmRlZmluZVRhZygncnVieScpO1xuXHR0YWckLmRlZmluZVRhZygncycpO1xuXHR0YWckLmRlZmluZVRhZygnc2FtcCcpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3NjcmlwdCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzcmMnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc2VjdGlvbicpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3NlbGVjdCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdWx0aXBsZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ211bHRpcGxlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE11bHRpcGxlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgncmVxdWlyZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpc2FibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkudmFsdWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpe1xuXHRcdFx0aWYgKHYgIT0gdGhpcy5kb20oKS52YWx1ZSkgeyB0aGlzLmRvbSgpLnZhbHVlID0gdiB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3NtYWxsJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzb3VyY2UnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3NwYW4nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3N0cm9uZycpO1xuXHR0YWckLmRlZmluZVRhZygnc3R5bGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3N1YicpO1xuXHR0YWckLmRlZmluZVRhZygnc3VtbWFyeScpO1xuXHR0YWckLmRlZmluZVRhZygnc3VwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0YWJsZScpO1xuXHR0YWckLmRlZmluZVRhZygndGJvZHknKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RkJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygndGV4dGFyZWEnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncmVxdWlyZWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmVxdWlyZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb3dzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm93cycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSb3dzID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyb3dzJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2xzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnY29scycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb2xzID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdjb2xzJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0QXV0b2ZvY3VzID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS52YWx1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodil7XG5cdFx0XHRpZiAodiAhPSB0aGlzLmRvbSgpLnZhbHVlKSB7IHRoaXMuZG9tKCkudmFsdWUgPSB2IH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAodil7XG5cdFx0XHRpZiAodiAhPSB0aGlzLmRvbSgpLnBsYWNlaG9sZGVyKSB7IHRoaXMuZG9tKCkucGxhY2Vob2xkZXIgPSB2IH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnBsYWNlaG9sZGVyO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3Rmb290Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0aCcpO1xuXHR0YWckLmRlZmluZVRhZygndGhlYWQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RpbWUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RpdGxlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0cicpO1xuXHR0YWckLmRlZmluZVRhZygndHJhY2snKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3UnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3VsJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd2aWRlbycpO1xuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3dicicpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0XG5cdHRhZyQuU1ZHLmRlZmluZVRhZygnc3ZnZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLm5hbWVzcGFjZVVSSSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciB0eXBlcyA9IFwiY2lyY2xlIGRlZnMgZWxsaXBzZSBnIGxpbmUgbGluZWFyR3JhZGllbnQgbWFzayBwYXRoIHBhdHRlcm4gcG9seWdvbiBwb2x5bGluZSByYWRpYWxHcmFkaWVudCByZWN0IHN0b3Agc3ZnIHRleHQgdHNwYW5cIi5zcGxpdChcIiBcIik7XG5cdFx0XG5cdFx0dGFnLmJ1aWxkTm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGRvbSA9IEltYmEuZG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlModGhpcy5uYW1lc3BhY2VVUkkoKSx0aGlzLl9ub2RlVHlwZSk7XG5cdFx0XHR2YXIgY2xzID0gdGhpcy5fY2xhc3Nlcy5qb2luKFwiIFwiKTtcblx0XHRcdGlmIChjbHMpIHsgZG9tLmNsYXNzTmFtZS5iYXNlVmFsID0gY2xzIH07XG5cdFx0XHRyZXR1cm4gZG9tO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLmluaGVyaXQgPSBmdW5jdGlvbiAoY2hpbGQpe1xuXHRcdFx0Y2hpbGQuX3Byb3RvRG9tID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKGlkeCQoY2hpbGQuX25hbWUsdHlwZXMpID49IDApIHtcblx0XHRcdFx0Y2hpbGQuX25vZGVUeXBlID0gY2hpbGQuX25hbWU7XG5cdFx0XHRcdHJldHVybiBjaGlsZC5fY2xhc3NlcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25vZGVUeXBlID0gdGhpcy5fbm9kZVR5cGU7XG5cdFx0XHRcdHZhciBjbGFzc05hbWUgPSBcIl9cIiArIGNoaWxkLl9uYW1lLnJlcGxhY2UoL18vZywnLScpO1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQuX2NsYXNzZXMgPSB0aGlzLl9jbGFzc2VzLmNvbmNhdChjbGFzc05hbWUpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdEltYmEuYXR0cih0YWcsJ3gnKTtcblx0XHRJbWJhLmF0dHIodGFnLCd5Jyk7XG5cdFx0XG5cdFx0SW1iYS5hdHRyKHRhZywnd2lkdGgnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdoZWlnaHQnKTtcblx0XHRcblx0XHRJbWJhLmF0dHIodGFnLCdzdHJva2UnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdzdHJva2Utd2lkdGgnKTtcblx0fSk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ3N2ZycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywndmlld2JveCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuU1ZHLmRlZmluZVRhZygncmVjdCcpO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdjaXJjbGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdEltYmEuYXR0cih0YWcsJ2N4Jyk7XG5cdFx0SW1iYS5hdHRyKHRhZywnY3knKTtcblx0XHRJbWJhLmF0dHIodGFnLCdyJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdlbGxpcHNlJywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCdjeCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ2N5Jyk7XG5cdFx0SW1iYS5hdHRyKHRhZywncngnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdyeScpO1xuXHR9KTtcblx0XG5cdHRhZyQuU1ZHLmRlZmluZVRhZygncGF0aCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywnZCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3BhdGhMZW5ndGgnKTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5TVkcuZGVmaW5lVGFnKCdsaW5lJywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCd4MScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3gyJyk7XG5cdFx0SW1iYS5hdHRyKHRhZywneTEnKTtcblx0XHRJbWJhLmF0dHIodGFnLCd5MicpO1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20uc3ZnLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdCkge1xuXHRcdHRhZyQuZXh0ZW5kVGFnKCdodG1sZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XHRcblx0XHRcdHRhZy5wcm90b3R5cGUuaGFzRmxhZyA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIHJlZiArICcoXFxcXHN8JCknKS50ZXN0KHRoaXMuX2RvbS5jbGFzc05hbWUpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGFnLnByb3RvdHlwZS5hZGRGbGFnID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRcdGlmICh0aGlzLmhhc0ZsYWcocmVmKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XHR0aGlzLl9kb20uY2xhc3NOYW1lICs9ICh0aGlzLl9kb20uY2xhc3NOYW1lID8gKCcgJykgOiAoJycpKSArIHJlZjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YWcucHJvdG90eXBlLnVuZmxhZyA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdFx0XHRpZiAoIXRoaXMuaGFzRmxhZyhyZWYpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcdHZhciByZWdleCA9IG5ldyBSZWdFeHAoJyhefFxcXFxzKSonICsgcmVmICsgJyhcXFxcc3wkKSonLCdnJyk7XG5cdFx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgPSB0aGlzLl9kb20uY2xhc3NOYW1lLnJlcGxhY2UocmVnZXgsJycpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRhZy5wcm90b3R5cGUudG9nZ2xlRmxhZyA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5oYXNGbGFnKHJlZikgPyAodGhpcy51bmZsYWcocmVmKSkgOiAodGhpcy5mbGFnKHJlZikpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGFnLnByb3RvdHlwZS5mbGFnID0gZnVuY3Rpb24gKHJlZixib29sKXtcblx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMiAmJiAhIWJvb2wgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudW5mbGFnKHJlZik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZEZsYWcocmVmKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLmxlZ2FjeS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIGRvYyA9IGRvY3VtZW50O1xuXHR2YXIgd2luID0gd2luZG93O1xuXHRcblx0dmFyIGhhc1RvdWNoRXZlbnRzID0gd2luZG93ICYmIHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09IHVuZGVmaW5lZDtcblx0XG5cdEltYmEuUG9pbnRlciA9IGZ1bmN0aW9uIFBvaW50ZXIoKXtcblx0XHR0aGlzLnNldEJ1dHRvbigtMSk7XG5cdFx0dGhpcy5zZXRFdmVudCh7eDogMCx5OiAwLHR5cGU6ICd1bmluaXRpYWxpemVkJ30pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnBoYXNlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9waGFzZTsgfVxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnNldFBoYXNlID0gZnVuY3Rpb24odil7IHRoaXMuX3BoYXNlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5wcmV2RXZlbnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ByZXZFdmVudDsgfVxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnNldFByZXZFdmVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wcmV2RXZlbnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLmJ1dHRvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYnV0dG9uOyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0QnV0dG9uID0gZnVuY3Rpb24odil7IHRoaXMuX2J1dHRvbiA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuZXZlbnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2V2ZW50OyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0RXZlbnQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZXZlbnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kaXJ0eTsgfVxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24odil7IHRoaXMuX2RpcnR5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2V2ZW50czsgfVxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnNldEV2ZW50cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ldmVudHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90b3VjaDsgfVxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnNldFRvdWNoID0gZnVuY3Rpb24odil7IHRoaXMuX3RvdWNoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHR0aGlzLnNldEV2ZW50KGUpO1xuXHRcdHRoaXMuc2V0RGlydHkodHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyB0aGlzIGlzIGp1c3QgZm9yIHJlZ3VsYXIgbW91c2Ugbm93XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBlMSA9IHRoaXMuZXZlbnQoKTtcblx0XHRcblx0XHRpZiAodGhpcy5kaXJ0eSgpKSB7XG5cdFx0XHR0aGlzLnNldFByZXZFdmVudChlMSk7XG5cdFx0XHR0aGlzLnNldERpcnR5KGZhbHNlKTtcblx0XHRcdFxuXHRcdFx0Ly8gYnV0dG9uIHNob3VsZCBvbmx5IGNoYW5nZSBvbiBtb3VzZWRvd24gZXRjXG5cdFx0XHRpZiAoZTEudHlwZSA9PSAnbW91c2Vkb3duJykge1xuXHRcdFx0XHR0aGlzLnNldEJ1dHRvbihlMS5idXR0b24pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZG8gbm90IGNyZWF0ZSB0b3VjaCBmb3IgcmlnaHQgY2xpY2tcblx0XHRcdFx0aWYgKHRoaXMuYnV0dG9uKCkgPT0gMiB8fCAodGhpcy50b3VjaCgpICYmIHRoaXMuYnV0dG9uKCkgIT0gMCkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjYW5jZWwgdGhlIHByZXZpb3VzIHRvdWNoXG5cdFx0XHRcdGlmICh0aGlzLnRvdWNoKCkpIHsgdGhpcy50b3VjaCgpLmNhbmNlbCgpIH07XG5cdFx0XHRcdHRoaXMuc2V0VG91Y2gobmV3IEltYmEuVG91Y2goZTEsdGhpcykpO1xuXHRcdFx0XHR0aGlzLnRvdWNoKCkubW91c2Vkb3duKGUxLGUxKTtcblx0XHRcdH0gZWxzZSBpZiAoZTEudHlwZSA9PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0XHRpZiAodGhpcy50b3VjaCgpKSB7IHRoaXMudG91Y2goKS5tb3VzZW1vdmUoZTEsZTEpIH07XG5cdFx0XHR9IGVsc2UgaWYgKGUxLnR5cGUgPT0gJ21vdXNldXAnKSB7XG5cdFx0XHRcdHRoaXMuc2V0QnV0dG9uKC0xKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLnRvdWNoKCkgJiYgdGhpcy50b3VjaCgpLmJ1dHRvbigpID09IGUxLmJ1dHRvbikge1xuXHRcdFx0XHRcdHRoaXMudG91Y2goKS5tb3VzZXVwKGUxLGUxKTtcblx0XHRcdFx0XHR0aGlzLnNldFRvdWNoKG51bGwpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyB0cmlnZ2VyIHBvaW50ZXJ1cFxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMudG91Y2goKSkgeyB0aGlzLnRvdWNoKCkuaWRsZSgpIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBJbWJhLlBPSU5URVJTO1xuXHR9O1xuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS54ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQoKS54O1xuXHR9O1xuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLnk7XG5cdH07XG5cdFxuXHQvLyBkZXByZWNhdGVkIC0tIHNob3VsZCByZW1vdmVcblx0SW1iYS5Qb2ludGVyLnVwZGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGNvbnNvbGUubG9nKCd1cGRhdGUgdG91Y2gnKVxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChJbWJhLlBPSU5URVJTKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnlbaV0ucHJvY2VzcygpO1xuXHRcdH07XG5cdFx0Ly8gbmVlZCB0byBiZSBhYmxlIHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRvdWNoLCBubz9cblx0XHR3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEltYmEuUG9pbnRlci51cGRhdGUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0dmFyIGxhc3ROYXRpdmVUb3VjaFRpbWVTdGFtcCA9IDA7XG5cdHZhciBsYXN0TmF0aXZlVG91Y2hUaW1lb3V0ID0gNTA7XG5cdFxuXHQvLyBJbWJhLlRvdWNoXG5cdC8vIEJlZ2FuXHRBIGZpbmdlciB0b3VjaGVkIHRoZSBzY3JlZW4uXG5cdC8vIE1vdmVkXHRBIGZpbmdlciBtb3ZlZCBvbiB0aGUgc2NyZWVuLlxuXHQvLyBTdGF0aW9uYXJ5XHRBIGZpbmdlciBpcyB0b3VjaGluZyB0aGUgc2NyZWVuIGJ1dCBoYXNuJ3QgbW92ZWQuXG5cdC8vIEVuZGVkXHRBIGZpbmdlciB3YXMgbGlmdGVkIGZyb20gdGhlIHNjcmVlbi4gVGhpcyBpcyB0aGUgZmluYWwgcGhhc2Ugb2YgYSB0b3VjaC5cblx0Ly8gQ2FuY2VsZWQgVGhlIHN5c3RlbSBjYW5jZWxsZWQgdHJhY2tpbmcgZm9yIHRoZSB0b3VjaC5cblx0XG5cdC8qXG5cdENvbnNvbGlkYXRlcyBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzLiBUb3VjaCBvYmplY3RzIHBlcnNpc3QgYWNyb3NzIGEgdG91Y2gsXG5cdGZyb20gdG91Y2hzdGFydCB1bnRpbCBlbmQvY2FuY2VsLiBXaGVuIGEgdG91Y2ggc3RhcnRzLCBpdCB3aWxsIHRyYXZlcnNlXG5cdGRvd24gZnJvbSB0aGUgaW5uZXJtb3N0IHRhcmdldCwgdW50aWwgaXQgZmluZHMgYSBub2RlIHRoYXQgcmVzcG9uZHMgdG9cblx0b250b3VjaHN0YXJ0LiBVbmxlc3MgdGhlIHRvdWNoIGlzIGV4cGxpY2l0bHkgcmVkaXJlY3RlZCwgdGhlIHRvdWNoIHdpbGxcblx0Y2FsbCBvbnRvdWNobW92ZSBhbmQgb250b3VjaGVuZCAvIG9udG91Y2hjYW5jZWwgb24gdGhlIHJlc3BvbmRlciB3aGVuIGFwcHJvcHJpYXRlLlxuXHRcblx0XHR0YWcgZHJhZ2dhYmxlXG5cdFx0XHQjIGNhbGxlZCB3aGVuIGEgdG91Y2ggc3RhcnRzXG5cdFx0XHRkZWYgb250b3VjaHN0YXJ0IHRvdWNoXG5cdFx0XHRcdGZsYWcgJ2RyYWdnaW5nJ1xuXHRcdFx0XHRzZWxmXG5cdFx0XHRcblx0XHRcdCMgY2FsbGVkIHdoZW4gdG91Y2ggbW92ZXMgLSBzYW1lIHRvdWNoIG9iamVjdFxuXHRcdFx0ZGVmIG9udG91Y2htb3ZlIHRvdWNoXG5cdFx0XHRcdCMgbW92ZSB0aGUgbm9kZSB3aXRoIHRvdWNoXG5cdFx0XHRcdGNzcyB0b3A6IHRvdWNoLmR5LCBsZWZ0OiB0b3VjaC5keFxuXHRcdFx0XG5cdFx0XHQjIGNhbGxlZCB3aGVuIHRvdWNoIGVuZHNcblx0XHRcdGRlZiBvbnRvdWNoZW5kIHRvdWNoXG5cdFx0XHRcdHVuZmxhZyAnZHJhZ2dpbmcnXG5cdFxuXHRAaW5hbWUgdG91Y2hcblx0Ki9cblx0XG5cdEltYmEuVG91Y2ggPSBmdW5jdGlvbiBUb3VjaChldmVudCxwb2ludGVyKXtcblx0XHQvLyBAbmF0aXZlICA9IGZhbHNlXG5cdFx0dGhpcy5zZXRFdmVudChldmVudCk7XG5cdFx0dGhpcy5zZXREYXRhKHt9KTtcblx0XHR0aGlzLnNldEFjdGl2ZSh0cnVlKTtcblx0XHR0aGlzLl9idXR0b24gPSBldmVudCAmJiBldmVudC5idXR0b24gfHwgMDtcblx0XHR0aGlzLl9zdXBwcmVzcyA9IGZhbHNlOyAvLyBkZXByZWNhdGVkXG5cdFx0dGhpcy5fY2FwdHVyZWQgPSBmYWxzZTtcblx0XHR0aGlzLnNldEJ1YmJsZShmYWxzZSk7XG5cdFx0cG9pbnRlciA9IHBvaW50ZXI7XG5cdFx0dGhpcy5zZXRVcGRhdGVzKDApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0dmFyIHRvdWNoZXMgPSBbXTtcblx0dmFyIGNvdW50ID0gMDtcblx0dmFyIGlkZW50aWZpZXJzID0ge307XG5cdFxuXHRJbWJhLlRvdWNoLmNvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5sb29rdXAgPSBmdW5jdGlvbiAoaXRlbSl7XG5cdFx0cmV0dXJuIGl0ZW0gJiYgKGl0ZW0uX190b3VjaF9fIHx8IGlkZW50aWZpZXJzW2l0ZW0uaWRlbnRpZmllcl0pO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5yZWxlYXNlID0gZnVuY3Rpb24gKGl0ZW0sdG91Y2gpe1xuXHRcdHZhciB2XywgJDE7XG5cdFx0KCgodl8gPSBpZGVudGlmaWVyc1tpdGVtLmlkZW50aWZpZXJdKSxkZWxldGUgaWRlbnRpZmllcnNbaXRlbS5pZGVudGlmaWVyXSwgdl8pKTtcblx0XHQoKCgkMSA9IGl0ZW0uX190b3VjaF9fKSxkZWxldGUgaXRlbS5fX3RvdWNoX18sICQxKSk7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGUuY2hhbmdlZFRvdWNoZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCB0OyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHQgPSBhcnlbaV07XG5cdFx0XHRpZiAodGhpcy5sb29rdXAodCkpIHsgY29udGludWU7IH07XG5cdFx0XHR2YXIgdG91Y2ggPSBpZGVudGlmaWVyc1t0LmlkZW50aWZpZXJdID0gbmV3IHRoaXMoZSk7IC8vIChlKVxuXHRcdFx0dC5fX3RvdWNoX18gPSB0b3VjaDtcblx0XHRcdHRvdWNoZXMucHVzaCh0b3VjaCk7XG5cdFx0XHRjb3VudCsrO1xuXHRcdFx0dG91Y2gudG91Y2hzdGFydChlLHQpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9udG91Y2htb3ZlID0gZnVuY3Rpb24gKGUpe1xuXHRcdHZhciB0b3VjaDtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZS5jaGFuZ2VkVG91Y2hlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dCA9IGFyeVtpXTtcblx0XHRcdGlmICh0b3VjaCA9IHRoaXMubG9va3VwKHQpKSB7XG5cdFx0XHRcdHRvdWNoLnRvdWNobW92ZShlLHQpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5vbnRvdWNoZW5kID0gZnVuY3Rpb24gKGUpe1xuXHRcdHZhciB0b3VjaDtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZS5jaGFuZ2VkVG91Y2hlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dCA9IGFyeVtpXTtcblx0XHRcdGlmICh0b3VjaCA9IHRoaXMubG9va3VwKHQpKSB7XG5cdFx0XHRcdHRvdWNoLnRvdWNoZW5kKGUsdCk7XG5cdFx0XHRcdHRoaXMucmVsZWFzZSh0LHRvdWNoKTtcblx0XHRcdFx0Y291bnQtLTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBlLnByZXZlbnREZWZhdWx0XG5cdFx0Ly8gbm90IGFsd2F5cyBzdXBwb3J0ZWQhXG5cdFx0Ly8gdG91Y2hlcyA9IHRvdWNoZXMuZmlsdGVyKHx8KVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5vbnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKGUpe1xuXHRcdHZhciB0b3VjaDtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZS5jaGFuZ2VkVG91Y2hlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dCA9IGFyeVtpXTtcblx0XHRcdGlmICh0b3VjaCA9IHRoaXMubG9va3VwKHQpKSB7XG5cdFx0XHRcdHRvdWNoLnRvdWNoY2FuY2VsKGUsdCk7XG5cdFx0XHRcdHRoaXMucmVsZWFzZSh0LHRvdWNoKTtcblx0XHRcdFx0Y291bnQtLTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5vbm1vdXNldXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5waGFzZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcGhhc2U7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0UGhhc2UgPSBmdW5jdGlvbih2KXsgdGhpcy5fcGhhc2UgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih2KXsgdGhpcy5fYWN0aXZlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZXZlbnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2V2ZW50OyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEV2ZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX2V2ZW50ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUucG9pbnRlciA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcG9pbnRlcjsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRQb2ludGVyID0gZnVuY3Rpb24odil7IHRoaXMuX3BvaW50ZXIgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS50YXJnZXQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RhcmdldDsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbih2KXsgdGhpcy5fdGFyZ2V0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGFuZGxlcjsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRIYW5kbGVyID0gZnVuY3Rpb24odil7IHRoaXMuX2hhbmRsZXIgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS51cGRhdGVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl91cGRhdGVzOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFVwZGF0ZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fdXBkYXRlcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnN1cHByZXNzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zdXBwcmVzczsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRTdXBwcmVzcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9zdXBwcmVzcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RhdGE7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kYXRhID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5fX2J1YmJsZSA9IHtjaGFpbmFibGU6IHRydWUsbmFtZTogJ2J1YmJsZSd9O1xuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCA/ICh0aGlzLnNldEJ1YmJsZSh2KSx0aGlzKSA6IHRoaXMuX2J1YmJsZTsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRCdWJibGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fYnViYmxlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmdlc3R1cmVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9nZXN0dXJlczsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRHZXN0dXJlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9nZXN0dXJlcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Lypcblx0XHRcblx0XG5cdFx0QGludGVybmFsXG5cdFx0QGNvbnN0cnVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmNhcHR1cmUgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9jYXB0dXJlZCA9IHRydWU7XG5cdFx0dGhpcy5fZXZlbnQgJiYgdGhpcy5fZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmlzQ2FwdHVyZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gISF0aGlzLl9jYXB0dXJlZDtcblx0fTtcblx0XG5cdC8qXG5cdFx0RXh0ZW5kIHRoZSB0b3VjaCB3aXRoIGEgcGx1Z2luIC8gZ2VzdHVyZS4gXG5cdFx0QWxsIGV2ZW50cyAodG91Y2hzdGFydCxtb3ZlIGV0YykgZm9yIHRoZSB0b3VjaFxuXHRcdHdpbGwgYmUgdHJpZ2dlcmVkIG9uIHRoZSBwbHVnaW5zIGluIHRoZSBvcmRlciB0aGV5XG5cdFx0YXJlIGFkZGVkLlxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAocGx1Z2luKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcImFkZGVkIGdlc3R1cmUhISFcIlxuXHRcdHRoaXMuX2dlc3R1cmVzIHx8ICh0aGlzLl9nZXN0dXJlcyA9IFtdKTtcblx0XHR0aGlzLl9nZXN0dXJlcy5wdXNoKHBsdWdpbik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJlZGlyZWN0IHRvdWNoIHRvIHNwZWNpZmllZCB0YXJnZXQuIG9udG91Y2hzdGFydCB3aWxsIGFsd2F5cyBiZVxuXHRcdGNhbGxlZCBvbiB0aGUgbmV3IHRhcmdldC5cblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKHRhcmdldCl7XG5cdFx0dGhpcy5fcmVkaXJlY3QgPSB0YXJnZXQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFN1cHByZXNzIHRoZSBkZWZhdWx0IGJlaGF2aW91ci4gV2lsbCBjYWxsIHByZXZlbnREZWZhdWx0IGZvclxuXHRcdGFsbCBuYXRpdmUgZXZlbnRzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIHRvdWNoLlxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zdXBwcmVzcyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGNvbGxpc2lvbiB3aXRoIHRoZSBzdXBwcmVzcyBwcm9wZXJ0eVxuXHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0U3VwcHJlc3MgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdGNvbnNvbGUud2FybignSW1iYS5Ub3VjaCNzdXBwcmVzcz0gaXMgZGVwcmVjYXRlZCcpO1xuXHRcdHRoaXMuX3N1cHJlc3MgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR0aGlzLl9ldmVudCA9IGU7XG5cdFx0dGhpcy5fdG91Y2ggPSB0O1xuXHRcdHRoaXMuX2J1dHRvbiA9IDA7XG5cdFx0dGhpcy5feCA9IHQuY2xpZW50WDtcblx0XHR0aGlzLl95ID0gdC5jbGllbnRZO1xuXHRcdHRoaXMuYmVnYW4oKTtcblx0XHRpZiAoZSAmJiB0aGlzLmlzQ2FwdHVyZWQoKSkgeyBlLnByZXZlbnREZWZhdWx0KCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHRoaXMuX2V2ZW50ID0gZTtcblx0XHR0aGlzLl94ID0gdC5jbGllbnRYO1xuXHRcdHRoaXMuX3kgPSB0LmNsaWVudFk7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHRpZiAoZSAmJiB0aGlzLmlzQ2FwdHVyZWQoKSkgeyBlLnByZXZlbnREZWZhdWx0KCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0dGhpcy5fZXZlbnQgPSBlO1xuXHRcdHRoaXMuX3ggPSB0LmNsaWVudFg7XG5cdFx0dGhpcy5feSA9IHQuY2xpZW50WTtcblx0XHR0aGlzLmVuZGVkKCk7XG5cdFx0XG5cdFx0bGFzdE5hdGl2ZVRvdWNoVGltZVN0YW1wID0gZS50aW1lU3RhbXA7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX21heGRyIDwgMjApIHtcblx0XHRcdHZhciB0YXAgPSBuZXcgSW1iYS5FdmVudChlKTtcblx0XHRcdHRhcC5zZXRUeXBlKCd0YXAnKTtcblx0XHRcdHRhcC5wcm9jZXNzKCk7XG5cdFx0XHRpZiAodGFwLl9yZXNwb25kZXIpIHsgZS5wcmV2ZW50RGVmYXVsdCgpIH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoZSAmJiB0aGlzLmlzQ2FwdHVyZWQoKSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS50b3VjaGNhbmNlbCA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHJldHVybiB0aGlzLmNhbmNlbCgpO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYuX2V2ZW50ID0gZTtcblx0XHRzZWxmLl9idXR0b24gPSBlLmJ1dHRvbjtcblx0XHRzZWxmLl94ID0gdC5jbGllbnRYO1xuXHRcdHNlbGYuX3kgPSB0LmNsaWVudFk7XG5cdFx0c2VsZi5iZWdhbigpO1xuXHRcdFxuXHRcdHNlbGYuX21vdXNlbW92ZSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHNlbGYubW91c2Vtb3ZlKGUsZSk7IH07XG5cdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsc2VsZi5fbW91c2Vtb3ZlLHRydWUpO1xuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0dGhpcy5feCA9IHQuY2xpZW50WDtcblx0XHR0aGlzLl95ID0gdC5jbGllbnRZO1xuXHRcdHRoaXMuX2V2ZW50ID0gZTtcblx0XHRpZiAodGhpcy5pc0NhcHR1cmVkKCkpIHsgZS5wcmV2ZW50RGVmYXVsdCgpIH07XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLm1vdmUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLm1vdXNldXAgPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR0aGlzLl94ID0gdC5jbGllbnRYO1xuXHRcdHRoaXMuX3kgPSB0LmNsaWVudFk7XG5cdFx0dGhpcy5lbmRlZCgpO1xuXHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLHRoaXMuX21vdXNlbW92ZSx0cnVlKTtcblx0XHR0aGlzLl9tb3VzZW1vdmUgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuaWRsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuYmVnYW4gPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9tYXhkciA9IHRoaXMuX2RyID0gMDtcblx0XHR0aGlzLl94MCA9IHRoaXMuX3g7XG5cdFx0dGhpcy5feTAgPSB0aGlzLl95O1xuXHRcdFxuXHRcdHZhciBkb20gPSB0aGlzLmV2ZW50KCkudGFyZ2V0O1xuXHRcdHZhciBub2RlID0gbnVsbDtcblx0XHRcblx0XHR0aGlzLl9zb3VyY2VUYXJnZXQgPSBkb20gJiYgdGFnJHdyYXAoZG9tKTtcblx0XHRcblx0XHR3aGlsZSAoZG9tKXtcblx0XHRcdG5vZGUgPSB0YWckd3JhcChkb20pO1xuXHRcdFx0aWYgKG5vZGUgJiYgbm9kZS5vbnRvdWNoc3RhcnQpIHtcblx0XHRcdFx0dGhpcy5fYnViYmxlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuc2V0VGFyZ2V0KG5vZGUpO1xuXHRcdFx0XHR0aGlzLnRhcmdldCgpLm9udG91Y2hzdGFydCh0aGlzKTtcblx0XHRcdFx0aWYgKCF0aGlzLl9idWJibGUpIHsgYnJlYWs7IH07XG5cdFx0XHR9O1xuXHRcdFx0ZG9tID0gZG9tLnBhcmVudE5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl91cGRhdGVzKys7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdGFyZ2V0Xztcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFxuXHRcdHZhciBkciA9IE1hdGguc3FydCh0aGlzLmR4KCkgKiB0aGlzLmR4KCkgKyB0aGlzLmR5KCkgKiB0aGlzLmR5KCkpO1xuXHRcdGlmIChkciA+IHRoaXMuX2RyKSB7IHRoaXMuX21heGRyID0gZHIgfTtcblx0XHR0aGlzLl9kciA9IGRyO1xuXHRcdFxuXHRcdC8vIGNhdGNoaW5nIGEgdG91Y2gtcmVkaXJlY3Q/IT9cblx0XHRpZiAodGhpcy5fcmVkaXJlY3QpIHtcblx0XHRcdGlmICh0aGlzLl90YXJnZXQgJiYgdGhpcy5fdGFyZ2V0Lm9udG91Y2hjYW5jZWwpIHtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0Lm9udG91Y2hjYW5jZWwodGhpcyk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5zZXRUYXJnZXQodGhpcy5fcmVkaXJlY3QpO1xuXHRcdFx0dGhpcy5fcmVkaXJlY3QgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMudGFyZ2V0KCkub250b3VjaHN0YXJ0KSB7IHRoaXMudGFyZ2V0KCkub250b3VjaHN0YXJ0KHRoaXMpIH07XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0aGlzLl91cGRhdGVzKys7XG5cdFx0aWYgKHRoaXMuX2dlc3R1cmVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fZ2VzdHVyZXMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldLm9udG91Y2h1cGRhdGUodGhpcyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0KHRhcmdldF8gPSB0aGlzLnRhcmdldCgpKSAmJiB0YXJnZXRfLm9udG91Y2h1cGRhdGUgICYmICB0YXJnZXRfLm9udG91Y2h1cGRhdGUodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRhcmdldF87XG5cdFx0aWYgKCF0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcblx0XHRpZiAodGhpcy5fZ2VzdHVyZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9nZXN0dXJlcyksIGxlbiA9IGFyeS5sZW5ndGgsIGc7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRnID0gYXJ5W2ldO1xuXHRcdFx0XHRpZiAoZy5vbnRvdWNobW92ZSkgeyBnLm9udG91Y2htb3ZlKHRoaXMsdGhpcy5fZXZlbnQpIH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0KHRhcmdldF8gPSB0aGlzLnRhcmdldCgpKSAmJiB0YXJnZXRfLm9udG91Y2htb3ZlICAmJiAgdGFyZ2V0Xy5vbnRvdWNobW92ZSh0aGlzLHRoaXMuX2V2ZW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmVuZGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRhcmdldF87XG5cdFx0aWYgKCF0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcblx0XHR0aGlzLl91cGRhdGVzKys7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2dlc3R1cmVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fZ2VzdHVyZXMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldLm9udG91Y2hlbmQodGhpcyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0KHRhcmdldF8gPSB0aGlzLnRhcmdldCgpKSAmJiB0YXJnZXRfLm9udG91Y2hlbmQgICYmICB0YXJnZXRfLm9udG91Y2hlbmQodGhpcyk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAoIXRoaXMuX2NhbmNlbGxlZCkge1xuXHRcdFx0dGhpcy5fY2FuY2VsbGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuY2FuY2VsbGVkKCk7XG5cdFx0XHRpZiAodGhpcy5fbW91c2Vtb3ZlKSB7IGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLHRoaXMuX21vdXNlbW92ZSx0cnVlKSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5jYW5jZWxsZWQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdGFyZ2V0Xztcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFxuXHRcdHRoaXMuX2NhbmNlbGxlZCA9IHRydWU7XG5cdFx0dGhpcy5fdXBkYXRlcysrO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9nZXN0dXJlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2dlc3R1cmVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgZzsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGcgPSBhcnlbaV07XG5cdFx0XHRcdGlmIChnLm9udG91Y2hjYW5jZWwpIHsgZy5vbnRvdWNoY2FuY2VsKHRoaXMpIH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0KHRhcmdldF8gPSB0aGlzLnRhcmdldCgpKSAmJiB0YXJnZXRfLm9udG91Y2hjYW5jZWwgICYmICB0YXJnZXRfLm9udG91Y2hjYW5jZWwodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFRoZSBhYnNvbHV0ZSBkaXN0YW5jZSB0aGUgdG91Y2ggaGFzIG1vdmVkIGZyb20gc3RhcnRpbmcgcG9zaXRpb24gXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5kciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kcjtcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhlIGRpc3RhbmNlIHRoZSB0b3VjaCBoYXMgbW92ZWQgaG9yaXpvbnRhbGx5XG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5keCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl94IC0gdGhpcy5feDA7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFRoZSBkaXN0YW5jZSB0aGUgdG91Y2ggaGFzIG1vdmVkIHZlcnRpY2FsbHlcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3kgLSB0aGlzLl95MDtcblx0fTtcblx0XG5cdC8qXG5cdFx0SW5pdGlhbCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRvdWNoXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS54MCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl94MDtcblx0fTtcblx0XG5cdC8qXG5cdFx0SW5pdGlhbCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0b3VjaFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUueTAgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5feTA7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEhvcml6b250YWwgcG9zaXRpb24gb2YgdG91Y2hcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fTtcblx0XG5cdC8qXG5cdFx0VmVydGljYWwgcG9zaXRpb24gb2YgdG91Y2hcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fTtcblx0XG5cdC8qXG5cdFx0SG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0b3VjaCByZWxhdGl2ZSB0byB0YXJnZXRcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnR4ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fdGFyZ2V0Qm94IHx8ICh0aGlzLl90YXJnZXRCb3ggPSB0aGlzLl90YXJnZXQuZG9tKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuXHRcdHJldHVybiB0aGlzLl94IC0gdGhpcy5fdGFyZ2V0Qm94LmxlZnQ7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRvdWNoIHJlbGF0aXZlIHRvIHRhcmdldFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudHkgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl90YXJnZXRCb3ggfHwgKHRoaXMuX3RhcmdldEJveCA9IHRoaXMuX3RhcmdldC5kb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG5cdFx0cmV0dXJuIHRoaXMuX3kgLSB0aGlzLl90YXJnZXRCb3gudG9wO1xuXHR9O1xuXHRcblx0Lypcblx0XHRCdXR0b24gcHJlc3NlZCBpbiB0aGlzIHRvdWNoLiBOYXRpdmUgdG91Y2hlcyBkZWZhdWx0cyB0byBsZWZ0LWNsaWNrICgwKVxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuYnV0dG9uID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2J1dHRvbjtcblx0fTsgLy8gQHBvaW50ZXIgPyBAcG9pbnRlci5idXR0b24gOiAwXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zb3VyY2VUYXJnZXQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fc291cmNlVGFyZ2V0O1xuXHR9O1xuXHRcblx0XG5cdEltYmEuVG91Y2hHZXN0dXJlID0gZnVuY3Rpb24gVG91Y2hHZXN0dXJlKCl7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaEdlc3R1cmUucHJvdG90eXBlLl9fYWN0aXZlID0geydkZWZhdWx0JzogZmFsc2UsbmFtZTogJ2FjdGl2ZSd9O1xuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9hY3RpdmU7IH1cblx0SW1iYS5Ub3VjaEdlc3R1cmUucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hY3RpdmUgPSB2OyByZXR1cm4gdGhpczsgfVxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcblx0SW1iYS5Ub3VjaEdlc3R1cmUucHJvdG90eXBlLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5vbnRvdWNodXBkYXRlID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaEdlc3R1cmUucHJvdG90eXBlLm9udG91Y2hlbmQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Ly8gQSBUb3VjaC1ldmVudCBpcyBjcmVhdGVkIG9uIG1vdXNlZG93biAoYWx3YXlzKVxuXHQvLyBhbmQgd2hpbGUgaXQgZXhpc3RzLCBtb3VzZW1vdmUgYW5kIG1vdXNldXAgd2lsbFxuXHQvLyBiZSBkZWxlZ2F0ZWQgdG8gdGhpcyBhY3RpdmUgZXZlbnQuXG5cdEltYmEuUE9JTlRFUiA9IG5ldyBJbWJhLlBvaW50ZXIoKTtcblx0SW1iYS5QT0lOVEVSUyA9IFtJbWJhLlBPSU5URVJdO1xuXHRcblx0XG5cdC8vIHJlZ3VsYXIgZXZlbnQgc3R1ZmZcblx0SW1iYS5LRVlNQVAgPSB7XG5cdFx0XCI4XCI6ICdiYWNrc3BhY2UnLFxuXHRcdFwiOVwiOiAndGFiJyxcblx0XHRcIjEzXCI6ICdlbnRlcicsXG5cdFx0XCIxNlwiOiAnc2hpZnQnLFxuXHRcdFwiMTdcIjogJ2N0cmwnLFxuXHRcdFwiMThcIjogJ2FsdCcsXG5cdFx0XCIxOVwiOiAnYnJlYWsnLFxuXHRcdFwiMjBcIjogJ2NhcHMnLFxuXHRcdFwiMjdcIjogJ2VzYycsXG5cdFx0XCIzMlwiOiAnc3BhY2UnLFxuXHRcdFwiMzVcIjogJ2VuZCcsXG5cdFx0XCIzNlwiOiAnaG9tZScsXG5cdFx0XCIzN1wiOiAnbGFycicsXG5cdFx0XCIzOFwiOiAndWFycicsXG5cdFx0XCIzOVwiOiAncmFycicsXG5cdFx0XCI0MFwiOiAnZGFycicsXG5cdFx0XCI0NVwiOiAnaW5zZXJ0Jyxcblx0XHRcIjQ2XCI6ICdkZWxldGUnLFxuXHRcdFwiMTA3XCI6ICdwbHVzJyxcblx0XHRcIjEwNlwiOiAnbXVsdCcsXG5cdFx0XCI5MVwiOiAnbWV0YSdcblx0fTtcblx0XG5cdEltYmEuQ0hBUk1BUCA9IHtcblx0XHRcIiVcIjogJ21vZHVsbycsXG5cdFx0XCIqXCI6ICdtdWx0aXBseScsXG5cdFx0XCIrXCI6ICdhZGQnLFxuXHRcdFwiLVwiOiAnc3ViJyxcblx0XHRcIi9cIjogJ2RpdmlkZScsXG5cdFx0XCIuXCI6ICdkb3QnXG5cdH07XG5cdFxuXHQvKlxuXHRJbWJhIGhhbmRsZXMgYWxsIGV2ZW50cyBpbiB0aGUgZG9tIHRocm91Z2ggYSBzaW5nbGUgbWFuYWdlcixcblx0bGlzdGVuaW5nIGF0IHRoZSByb290IG9mIHlvdXIgZG9jdW1lbnQuIElmIEltYmEgZmluZHMgYSB0YWdcblx0dGhhdCBsaXN0ZW5zIHRvIGEgY2VydGFpbiBldmVudCwgdGhlIGV2ZW50IHdpbGwgYmUgd3JhcHBlZCBcblx0aW4gYW4gYEltYmEuRXZlbnRgLCB3aGljaCBub3JtYWxpemVzIHNvbWUgb2YgdGhlIHF1aXJrcyBhbmQgXG5cdGJyb3dzZXIgZGlmZmVyZW5jZXMuXG5cdFxuXHRAaW5hbWUgZXZlbnRcblx0Ki9cblx0XG5cdEltYmEuRXZlbnQgPSBmdW5jdGlvbiBFdmVudChlKXtcblx0XHR0aGlzLnNldEV2ZW50KGUpO1xuXHRcdHRoaXMuc2V0QnViYmxlKHRydWUpO1xuXHR9O1xuXHRcblx0LyogcmVmZXJlbmNlIHRvIHRoZSBuYXRpdmUgZXZlbnQgKi9cblx0XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuZXZlbnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2V2ZW50OyB9XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNldEV2ZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX2V2ZW50ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHQvKiByZWZlcmVuY2UgdG8gdGhlIG5hdGl2ZSBldmVudCAqL1xuXHRcblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5wcmVmaXggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ByZWZpeDsgfVxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5zZXRQcmVmaXggPSBmdW5jdGlvbih2KXsgdGhpcy5fcHJlZml4ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RhdGE7IH1cblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kYXRhID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHQvKlxuXHRcdHNob3VsZCByZW1vdmUgdGhpcyBhbGx0b2dldGhlcj9cblx0XHRAZGVwcmVjYXRlZFxuXHRcdCovXG5cdFxuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc291cmNlOyB9XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9zb3VyY2UgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdC8qIEEge0Jvb2xlYW59IGluZGljYXRpbmcgd2hldGhlciB0aGUgZXZlbnQgYnViYmxlcyB1cCBvciBub3QgKi9cblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5fX2J1YmJsZSA9IHt0eXBlOiBCb29sZWFuLGNoYWluYWJsZTogdHJ1ZSxuYW1lOiAnYnViYmxlJ307XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkID8gKHRoaXMuc2V0QnViYmxlKHYpLHRoaXMpIDogdGhpcy5fYnViYmxlOyB9XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNldEJ1YmJsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9idWJibGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuRXZlbnQud3JhcCA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gbmV3IHRoaXMoZSk7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24gKHR5cGUpe1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCAoY2FzZS1pbnNlbnNpdGl2ZSlcblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl90eXBlIHx8IHRoaXMuZXZlbnQoKS50eXBlO1xuXHR9O1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9uYW1lIHx8ICh0aGlzLl9uYW1lID0gdGhpcy50eXBlKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXDovZywnJykpO1xuXHR9O1xuXHRcblx0Ly8gbWltYyBnZXRzZXRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gKHYpe1xuXHRcdGlmICh2ICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRCdWJibGUodik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzLl9idWJibGU7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFByZXZlbnRzIGZ1cnRoZXIgcHJvcGFnYXRpb24gb2YgdGhlIGN1cnJlbnQgZXZlbnQuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuaGFsdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuc2V0QnViYmxlKGZhbHNlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0Q2FuY2VsIHRoZSBldmVudCAoaWYgY2FuY2VsYWJsZSkuIEluIHRoZSBjYXNlIG9mIG5hdGl2ZSBldmVudHMgaXRcblx0XHR3aWxsIGNhbGwgYHByZXZlbnREZWZhdWx0YCBvbiB0aGUgd3JhcHBlZCBldmVudCBvYmplY3QuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuZXZlbnQoKS5wcmV2ZW50RGVmYXVsdCkgeyB0aGlzLmV2ZW50KCkucHJldmVudERlZmF1bHQoKSB9O1xuXHRcdHRoaXMuX2NhbmNlbCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCBldmVudC5jYW5jZWwgaGFzIGJlZW4gY2FsbGVkLlxuXHRcblx0XHRAcmV0dXJuIHtCb29sZWFufVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5pc1ByZXZlbnRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmV2ZW50KCkgJiYgdGhpcy5ldmVudCgpLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdGhpcy5fY2FuY2VsO1xuXHR9O1xuXHRcblx0Lypcblx0XHRBIHJlZmVyZW5jZSB0byB0aGUgaW5pdGlhbCB0YXJnZXQgb2YgdGhlIGV2ZW50LlxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS50YXJnZXQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJHdyYXAodGhpcy5ldmVudCgpLl90YXJnZXQgfHwgdGhpcy5ldmVudCgpLnRhcmdldCk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEEgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3QgcmVzcG9uZGluZyB0byB0aGUgZXZlbnQuXG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnJlc3BvbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9yZXNwb25kZXI7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJlZGlyZWN0IHRoZSBldmVudCB0byBuZXcgdGFyZ2V0XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHRoaXMuX3JlZGlyZWN0ID0gbm9kZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0R2V0IHRoZSBub3JtYWxpemVkIGNoYXJhY3RlciBmb3IgS2V5Ym9hcmRFdmVudC9UZXh0RXZlbnRcblx0XHRAcmV0dXJuIHtTdHJpbmd9XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmtleWNoYXIgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5ldmVudCgpIGluc3RhbmNlb2YgVGV4dEV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLmRhdGE7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5ldmVudCgpIGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCkge1xuXHRcdFx0dmFyIGtpID0gdGhpcy5ldmVudCgpLmtleUlkZW50aWZpZXI7XG5cdFx0XHR2YXIgc3ltID0gSW1iYS5LRVlNQVBbdGhpcy5ldmVudCgpLmtleUNvZGVdO1xuXHRcdFx0XG5cdFx0XHQvLyBwICdrZXlzeW0hJyxraSxzeW1cblx0XHRcdFxuXHRcdFx0aWYgKCFzeW0gJiYga2kuc3Vic3RyKDAsMikgPT0gXCJVK1wiKSB7XG5cdFx0XHRcdHN5bSA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoa2kuc3Vic3RyKDIpLDE2KSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHN5bTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0Lypcblx0XHRAZGVwcmVjYXRlZFxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5rZXljb21ibyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzeW07XG5cdFx0aWYgKCEoc3ltID0gdGhpcy5rZXljaGFyKCkpKSB7IHJldHVybiB9O1xuXHRcdHN5bSA9IEltYmEuQ0hBUk1BUFtzeW1dIHx8IHN5bTtcblx0XHR2YXIgY29tYm8gPSBbXSxlID0gdGhpcy5ldmVudCgpO1xuXHRcdGlmIChlLmN0cmxLZXkpIHsgY29tYm8ucHVzaCgnY3RybCcpIH07XG5cdFx0aWYgKGUuc2hpZnRLZXkpIHsgY29tYm8ucHVzaCgnc2hpZnQnKSB9O1xuXHRcdGlmIChlLmFsdEtleSkgeyBjb21iby5wdXNoKCdhbHQnKSB9O1xuXHRcdGlmIChlLm1ldGFLZXkpIHsgY29tYm8ucHVzaCgnY21kJykgfTtcblx0XHRjb21iby5wdXNoKHN5bSk7XG5cdFx0cmV0dXJuIGNvbWJvLmpvaW4oXCJfXCIpLnRvTG93ZXJDYXNlKCk7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBub2RlO1xuXHRcdHZhciBtZXRoID0gKFwib25cIiArICh0aGlzLl9wcmVmaXggfHwgJycpICsgdGhpcy5uYW1lKCkpO1xuXHRcdHZhciBhcmdzID0gbnVsbDtcblx0XHR2YXIgZG9tdGFyZ2V0ID0gdGhpcy5ldmVudCgpLl90YXJnZXQgfHwgdGhpcy5ldmVudCgpLnRhcmdldDtcblx0XHQvLyB2YXIgbm9kZSA9IDx7ZG9tdGFyZ2V0Ol9yZXNwb25kZXIgb3IgZG9tdGFyZ2V0fT5cblx0XHQvLyBuZWVkIHRvIGNsZWFuIHVwIGFuZCBkb2N1bWVudCB0aGlzIGJlaGF2aW91clxuXHRcdFxuXHRcdHZhciBkb21ub2RlID0gZG9tdGFyZ2V0Ll9yZXNwb25kZXIgfHwgZG9tdGFyZ2V0O1xuXHRcdC8vIEB0b2RvIG5lZWQgdG8gc3RvcCBpbmZpbml0ZSByZWRpcmVjdC1ydWxlcyBoZXJlXG5cdFx0XG5cdFx0dmFyICQxO3doaWxlIChkb21ub2RlKXtcblx0XHRcdHRoaXMuX3JlZGlyZWN0ID0gbnVsbDtcblx0XHRcdGlmIChub2RlID0gdGFnJHdyYXAoZG9tbm9kZSkpIHsgLy8gbm90IG9ubHkgdGFnIFxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCh0eXBlb2Ygbm9kZVsoJDEgPSBtZXRoKV09PSdzdHJpbmcnfHxub2RlWyQxXSBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0XHQvLyBzaG91bGQgcmVtZW1iZXIgdGhlIHJlY2VpdmVyIG9mIHRoZSBldmVudFxuXHRcdFx0XHRcdG1ldGggPSBub2RlW21ldGhdO1xuXHRcdFx0XHRcdGNvbnRpbnVlOyAvLyBzaG91bGQgbm90IGNvbnRpbnVlP1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5vZGVbbWV0aF0gaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdGFyZ3MgPSBub2RlW21ldGhdLmNvbmNhdChub2RlKTtcblx0XHRcdFx0XHRtZXRoID0gYXJncy5zaGlmdCgpO1xuXHRcdFx0XHRcdGNvbnRpbnVlOyAvLyBzaG91bGQgbm90IGNvbnRpbnVlP1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5vZGVbbWV0aF0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRcdHRoaXMuX3Jlc3BvbmRlciB8fCAodGhpcy5fcmVzcG9uZGVyID0gbm9kZSk7XG5cdFx0XHRcdFx0Ly8gc2hvdWxkIGF1dG9zdG9wIGJ1YmJsZSBoZXJlP1xuXHRcdFx0XHRcdGFyZ3MgPyAobm9kZVttZXRoXS5hcHBseShub2RlLGFyZ3MpKSA6IChub2RlW21ldGhdKHRoaXMsdGhpcy5kYXRhKCkpKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGFkZCBub2RlLm5leHRFdmVudFJlc3BvbmRlciBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlP1xuXHRcdFx0aWYgKCEodGhpcy5idWJibGUoKSAmJiAoZG9tbm9kZSA9ICh0aGlzLl9yZWRpcmVjdCB8fCAobm9kZSA/IChub2RlLnBhcmVudCgpKSA6IChkb21ub2RlLnBhcmVudE5vZGUpKSkpKSkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnByb2Nlc3NlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnByb2Nlc3NlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdEltYmEuZW1pdChJbWJhLCdldmVudCcsW3RoaXNdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0UmV0dXJuIHRoZSB4L2xlZnQgY29vcmRpbmF0ZSBvZiB0aGUgbW91c2UgLyBwb2ludGVyIGZvciB0aGlzIGV2ZW50XG5cdFx0QHJldHVybiB7TnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgbW91c2UgLyBwb2ludGVyIGZvciBldmVudFxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS54ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQoKS54O1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZXR1cm4gdGhlIHkvdG9wIGNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIC8gcG9pbnRlciBmb3IgdGhpcyBldmVudFxuXHRcdEByZXR1cm4ge051bWJlcn0geSBjb29yZGluYXRlIG9mIG1vdXNlIC8gcG9pbnRlciBmb3IgZXZlbnRcblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUueSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmV2ZW50KCkueTtcblx0fTtcblx0XG5cdC8qXG5cdFx0UmV0dXJucyBhIE51bWJlciByZXByZXNlbnRpbmcgYSBzeXN0ZW0gYW5kIGltcGxlbWVudGF0aW9uXG5cdFx0ZGVwZW5kZW50IG51bWVyaWMgY29kZSBpZGVudGlmeWluZyB0aGUgdW5tb2RpZmllZCB2YWx1ZSBvZiB0aGVcblx0XHRwcmVzc2VkIGtleTsgdGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIGtleUNvZGUuXG5cdFxuXHRcdEZvciBtb3VzZS1ldmVudHMsIHRoZSByZXR1cm5lZCB2YWx1ZSBpbmRpY2F0ZXMgd2hpY2ggYnV0dG9uIHdhc1xuXHRcdHByZXNzZWQgb24gdGhlIG1vdXNlIHRvIHRyaWdnZXIgdGhlIGV2ZW50LlxuXHRcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLndoaWNoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQoKS53aGljaDtcblx0fTtcblx0XG5cdFxuXHQvKlxuXHRcblx0TWFuYWdlciBmb3IgbGlzdGVuaW5nIHRvIGFuZCBkZWxlZ2F0aW5nIGV2ZW50cyBpbiBJbWJhLiBBIHNpbmdsZSBpbnN0YW5jZVxuXHRpcyBhbHdheXMgY3JlYXRlZCBieSBJbWJhIChhcyBgSW1iYS5FdmVudHNgKSwgd2hpY2ggaGFuZGxlcyBhbmQgZGVsZWdhdGVzIGFsbFxuXHRldmVudHMgYXQgdGhlIHZlcnkgcm9vdCBvZiB0aGUgZG9jdW1lbnQuIEltYmEgZG9lcyBub3QgY2FwdHVyZSBhbGwgZXZlbnRzXG5cdGJ5IGRlZmF1bHQsIHNvIGlmIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSBleG90aWMgb3IgY3VzdG9tIERPTUV2ZW50cyBhcmUgZGVsZWdhdGVkXG5cdGluIEltYmEgeW91IHdpbGwgbmVlZCB0byByZWdpc3RlciB0aGVtIGluIGBJbWJhLkV2ZW50cy5yZWdpc3RlcihteUN1c3RvbUV2ZW50TmFtZSlgXG5cdFxuXHRAaW5hbWUgbWFuYWdlclxuXHRcblx0Ki9cblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyID0gZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKG5vZGUscGFycyl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKCFwYXJzfHxwYXJzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHBhcnMgPSB7fTtcblx0XHR2YXIgZXZlbnRzID0gcGFycy5ldmVudHMgIT09IHVuZGVmaW5lZCA/IHBhcnMuZXZlbnRzIDogW107XG5cdFx0c2VsZi5zZXRSb290KG5vZGUpO1xuXHRcdHNlbGYuc2V0Q291bnQoMCk7XG5cdFx0c2VsZi5zZXRMaXN0ZW5lcnMoW10pO1xuXHRcdHNlbGYuc2V0RGVsZWdhdG9ycyh7fSk7XG5cdFx0c2VsZi5zZXREZWxlZ2F0b3IoZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJkZWxlZ2F0aW5nIGV2ZW50PyEge2V9XCJcblx0XHRcdHNlbGYuZGVsZWdhdGUoZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZXZlbnRzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRzZWxmLnJlZ2lzdGVyKGFyeVtpXSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdFxuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH1cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnNldFJvb3QgPSBmdW5jdGlvbih2KXsgdGhpcy5fcm9vdCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY291bnQ7IH1cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnNldENvdW50ID0gZnVuY3Rpb24odil7IHRoaXMuX2NvdW50ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuX19lbmFibGVkID0geydkZWZhdWx0JzogZmFsc2Usd2F0Y2g6ICdlbmFibGVkRGlkU2V0JyxuYW1lOiAnZW5hYmxlZCd9O1xuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZW5hYmxlZDsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0RW5hYmxlZCA9IGZ1bmN0aW9uKHYpe1xuXHRcdHZhciBhID0gdGhpcy5lbmFibGVkKCk7XG5cdFx0aWYodiAhPSBhKSB7IHRoaXMuX2VuYWJsZWQgPSB2OyB9XG5cdFx0aWYodiAhPSBhKSB7IHRoaXMuZW5hYmxlZERpZFNldCAmJiB0aGlzLmVuYWJsZWREaWRTZXQodixhLHRoaXMuX19lbmFibGVkKSB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLl9lbmFibGVkID0gZmFsc2U7XG5cdFxuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbGlzdGVuZXJzOyB9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbih2KXsgdGhpcy5fbGlzdGVuZXJzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmRlbGVnYXRvcnMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RlbGVnYXRvcnM7IH1cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnNldERlbGVnYXRvcnMgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGVsZWdhdG9ycyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5kZWxlZ2F0b3IgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RlbGVnYXRvcjsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0RGVsZWdhdG9yID0gZnVuY3Rpb24odil7IHRoaXMuX2RlbGVnYXRvciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmVuYWJsZWREaWRTZXQgPSBmdW5jdGlvbiAoYm9vbCl7XG5cdFx0Ym9vbCA/ICh0aGlzLm9uZW5hYmxlKCkpIDogKHRoaXMub25kaXNhYmxlKCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdFx0VGVsbCB0aGUgY3VycmVudCBFdmVudE1hbmFnZXIgdG8gaW50ZXJjZXB0IGFuZCBoYW5kbGUgZXZlbnQgb2YgYSBjZXJ0YWluIG5hbWUuXG5cdFx0QnkgZGVmYXVsdCwgSW1iYS5FdmVudHMgd2lsbCByZWdpc3RlciBpbnRlcmNlcHRvcnMgZm9yOiAqa2V5ZG93biosICprZXl1cCosIFxuXHRcdCprZXlwcmVzcyosICp0ZXh0SW5wdXQqLCAqaW5wdXQqLCAqY2hhbmdlKiwgKnN1Ym1pdCosICpmb2N1c2luKiwgKmZvY3Vzb3V0KiwgXG5cdFx0KmJsdXIqLCAqY29udGV4dG1lbnUqLCAqZGJsY2xpY2sqLCAqbW91c2V3aGVlbCosICp3aGVlbCpcblx0XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLGhhbmRsZXIpe1xuXHRcdGlmKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgaGFuZGxlciA9IHRydWU7XG5cdFx0aWYgKG5hbWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5hbWUpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5yZWdpc3RlcihhcnlbaV0saGFuZGxlcik7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5kZWxlZ2F0b3JzKClbbmFtZV0pIHsgcmV0dXJuIHRoaXMgfTtcblx0XHQvLyBjb25zb2xlLmxvZyhcInJlZ2lzdGVyIGZvciBldmVudCB7bmFtZX1cIilcblx0XHR2YXIgZm4gPSB0aGlzLmRlbGVnYXRvcnMoKVtuYW1lXSA9IGhhbmRsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChoYW5kbGVyKSA6ICh0aGlzLmRlbGVnYXRvcigpKTtcblx0XHRpZiAodGhpcy5lbmFibGVkKCkpIHsgcmV0dXJuIHRoaXMucm9vdCgpLmFkZEV2ZW50TGlzdGVuZXIobmFtZSxmbix0cnVlKSB9O1xuXHR9O1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChuYW1lLGhhbmRsZXIsY2FwdHVyZSl7XG5cdFx0aWYoY2FwdHVyZSA9PT0gdW5kZWZpbmVkKSBjYXB0dXJlID0gdHJ1ZTtcblx0XHR0aGlzLmxpc3RlbmVycygpLnB1c2goW25hbWUsaGFuZGxlcixjYXB0dXJlXSk7XG5cdFx0aWYgKHRoaXMuZW5hYmxlZCgpKSB7IHRoaXMucm9vdCgpLmFkZEV2ZW50TGlzdGVuZXIobmFtZSxoYW5kbGVyLGNhcHR1cmUpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZGVsZWdhdGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dGhpcy5zZXRDb3VudCh0aGlzLmNvdW50KCkgKyAxKTtcblx0XHR2YXIgZXZlbnQgPSBJbWJhLkV2ZW50LndyYXAoZSk7XG5cdFx0ZXZlbnQucHJvY2VzcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICh0eXBlLHRhcmdldCxwYXJzKXtcblx0XHRpZighcGFyc3x8cGFycy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSBwYXJzID0ge307XG5cdFx0dmFyIGRhdGEgPSBwYXJzLmRhdGEgIT09IHVuZGVmaW5lZCA/IHBhcnMuZGF0YSA6IG51bGw7XG5cdFx0dmFyIHNvdXJjZSA9IHBhcnMuc291cmNlICE9PSB1bmRlZmluZWQgPyBwYXJzLnNvdXJjZSA6IG51bGw7XG5cdFx0dmFyIGV2ZW50ID0gSW1iYS5FdmVudC53cmFwKHt0eXBlOiB0eXBlLHRhcmdldDogdGFyZ2V0fSk7XG5cdFx0aWYgKGRhdGEpIHsgKGV2ZW50LnNldERhdGEoZGF0YSksZGF0YSkgfTtcblx0XHRpZiAoc291cmNlKSB7IChldmVudC5zZXRTb3VyY2Uoc291cmNlKSxzb3VyY2UpIH07XG5cdFx0cmV0dXJuIGV2ZW50O1xuXHR9O1xuXHRcblx0Ly8gdXNlIGNyZWF0ZSBpbnN0ZWFkP1xuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cykucHJvY2VzcygpO1xuXHR9O1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLm9uZW5hYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0Zm9yICh2YXIgbyA9IHRoaXMuZGVsZWdhdG9ycygpLCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG8pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0dGhpcy5yb290KCkuYWRkRXZlbnRMaXN0ZW5lcihrZXlzW2ldLG9ba2V5c1tpXV0sdHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRmb3IgKHZhciBqID0gMCwgYXJ5ID0gaXRlciQodGhpcy5saXN0ZW5lcnMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIGl0ZW07IGogPCBsZW47IGorKykge1xuXHRcdFx0aXRlbSA9IGFyeVtqXTtcblx0XHRcdHRoaXMucm9vdCgpLmFkZEV2ZW50TGlzdGVuZXIoaXRlbVswXSxpdGVtWzFdLGl0ZW1bMl0pO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUub25kaXNhYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0Zm9yICh2YXIgbyA9IHRoaXMuZGVsZWdhdG9ycygpLCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG8pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0dGhpcy5yb290KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihrZXlzW2ldLG9ba2V5c1tpXV0sdHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRmb3IgKHZhciBqID0gMCwgYXJ5ID0gaXRlciQodGhpcy5saXN0ZW5lcnMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIGl0ZW07IGogPCBsZW47IGorKykge1xuXHRcdFx0aXRlbSA9IGFyeVtqXTtcblx0XHRcdHRoaXMucm9vdCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbVswXSxpdGVtWzFdLGl0ZW1bMl0pO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0RUQgPSBJbWJhLkV2ZW50cyA9IG5ldyBJbWJhLkV2ZW50TWFuYWdlcihkb2N1bWVudCx7ZXZlbnRzOiBbXG5cdFx0J2tleWRvd24nLCdrZXl1cCcsJ2tleXByZXNzJywndGV4dElucHV0JywnaW5wdXQnLCdjaGFuZ2UnLCdzdWJtaXQnLFxuXHRcdCdmb2N1c2luJywnZm9jdXNvdXQnLCdibHVyJywnY29udGV4dG1lbnUnLCdkYmxjbGljaycsXG5cdFx0J21vdXNld2hlZWwnLCd3aGVlbCdcblx0XX0pO1xuXHRcblx0Ly8gc2hvdWxkIHNldCB0aGVzZSB1cCBpbnNpZGUgdGhlIEltYmEuRXZlbnRzIG9iamVjdCBpdHNlbGZcblx0Ly8gc28gdGhhdCB3ZSBjYW4gaGF2ZSBkaWZmZXJlbnQgRXZlbnRNYW5hZ2VyIGZvciBkaWZmZXJlbnQgcm9vdHNcblx0XG5cdGlmIChoYXNUb3VjaEV2ZW50cykge1xuXHRcdEltYmEuRXZlbnRzLmxpc3RlbigndG91Y2hzdGFydCcsZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIEV2ZW50c18sIHZfO1xuXHRcdFx0KCgoRXZlbnRzXyA9IEltYmEuRXZlbnRzKS5zZXRDb3VudCh2XyA9IEV2ZW50c18uY291bnQoKSArIDEpLHZfKSkgLSAxO1xuXHRcdFx0cmV0dXJuIEltYmEuVG91Y2gub250b3VjaHN0YXJ0KGUpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdEltYmEuRXZlbnRzLmxpc3RlbigndG91Y2htb3ZlJyxmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgRXZlbnRzXywgdl87XG5cdFx0XHQoKChFdmVudHNfID0gSW1iYS5FdmVudHMpLnNldENvdW50KHZfID0gRXZlbnRzXy5jb3VudCgpICsgMSksdl8pKSAtIDE7XG5cdFx0XHRyZXR1cm4gSW1iYS5Ub3VjaC5vbnRvdWNobW92ZShlKTtcblx0XHR9KTtcblx0XHRcblx0XHRJbWJhLkV2ZW50cy5saXN0ZW4oJ3RvdWNoZW5kJyxmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgRXZlbnRzXywgdl87XG5cdFx0XHQoKChFdmVudHNfID0gSW1iYS5FdmVudHMpLnNldENvdW50KHZfID0gRXZlbnRzXy5jb3VudCgpICsgMSksdl8pKSAtIDE7XG5cdFx0XHRyZXR1cm4gSW1iYS5Ub3VjaC5vbnRvdWNoZW5kKGUpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdEltYmEuRXZlbnRzLmxpc3RlbigndG91Y2hjYW5jZWwnLGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBFdmVudHNfLCB2Xztcblx0XHRcdCgoKEV2ZW50c18gPSBJbWJhLkV2ZW50cykuc2V0Q291bnQodl8gPSBFdmVudHNfLmNvdW50KCkgKyAxKSx2XykpIC0gMTtcblx0XHRcdHJldHVybiBJbWJhLlRvdWNoLm9udG91Y2hjYW5jZWwoZSk7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50cy5yZWdpc3RlcignY2xpY2snLGZ1bmN0aW9uKGUpIHtcblx0XHQvLyBPbmx5IGZvciBtYWluIG1vdXNlYnV0dG9uLCBubz9cblx0XHRpZiAoKGUudGltZVN0YW1wIC0gbGFzdE5hdGl2ZVRvdWNoVGltZVN0YW1wKSA+IGxhc3ROYXRpdmVUb3VjaFRpbWVvdXQpIHtcblx0XHRcdHZhciB0YXAgPSBuZXcgSW1iYS5FdmVudChlKTtcblx0XHRcdHRhcC5zZXRUeXBlKCd0YXAnKTtcblx0XHRcdHRhcC5wcm9jZXNzKCk7XG5cdFx0XHRpZiAodGFwLl9yZXNwb25kZXIpIHtcblx0XHRcdFx0cmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyBkZWxlZ2F0ZSB0aGUgcmVhbCBjbGljayBldmVudFxuXHRcdHJldHVybiBJbWJhLkV2ZW50cy5kZWxlZ2F0ZShlKTtcblx0fSk7XG5cdFxuXHRJbWJhLkV2ZW50cy5saXN0ZW4oJ21vdXNlZG93bicsZnVuY3Rpb24oZSkge1xuXHRcdGlmICgoZS50aW1lU3RhbXAgLSBsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXApID4gbGFzdE5hdGl2ZVRvdWNoVGltZW91dCkge1xuXHRcdFx0aWYgKEltYmEuUE9JTlRFUikgeyByZXR1cm4gSW1iYS5QT0lOVEVSLnVwZGF0ZShlKS5wcm9jZXNzKCkgfTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdC8vIEltYmEuRXZlbnRzLmxpc3Rlbig6bW91c2Vtb3ZlKSBkbyB8ZXxcblx0Ly8gXHQjIGNvbnNvbGUubG9nICdtb3VzZW1vdmUnLGU6dGltZVN0YW1wXG5cdC8vIFx0aWYgKGU6dGltZVN0YW1wIC0gbGFzdE5hdGl2ZVRvdWNoVGltZVN0YW1wKSA+IGxhc3ROYXRpdmVUb3VjaFRpbWVvdXRcblx0Ly8gXHRcdEltYmEuUE9JTlRFUi51cGRhdGUoZSkucHJvY2VzcyBpZiBJbWJhLlBPSU5URVIgIyAucHJvY2VzcyBpZiB0b3VjaCAjIHNob3VsZCBub3QgaGFwcGVuPyBXZSBwcm9jZXNzIHRocm91Z2ggXG5cdFxuXHRJbWJhLkV2ZW50cy5saXN0ZW4oJ21vdXNldXAnLGZ1bmN0aW9uKGUpIHtcblx0XHQvLyBjb25zb2xlLmxvZyAnbW91c2V1cCcsZTp0aW1lU3RhbXBcblx0XHRpZiAoKGUudGltZVN0YW1wIC0gbGFzdE5hdGl2ZVRvdWNoVGltZVN0YW1wKSA+IGxhc3ROYXRpdmVUb3VjaFRpbWVvdXQpIHtcblx0XHRcdGlmIChJbWJhLlBPSU5URVIpIHsgcmV0dXJuIEltYmEuUE9JTlRFUi51cGRhdGUoZSkucHJvY2VzcygpIH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0SW1iYS5FdmVudHMucmVnaXN0ZXIoWydtb3VzZWRvd24nLCdtb3VzZXVwJ10pO1xuXHRyZXR1cm4gKEltYmEuRXZlbnRzLnNldEVuYWJsZWQodHJ1ZSksdHJ1ZSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLmV2ZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIEltYmFUYWcgPSBJbWJhLlRBR1MuZWxlbWVudDtcblx0XG5cdGZ1bmN0aW9uIHJlbW92ZU5lc3RlZChyb290LG5vZGUsY2FyZXQpe1xuXHRcdC8vIGlmIG5vZGUvbm9kZXMgaXNhIFN0cmluZ1xuXHRcdC8vIFx0d2UgbmVlZCB0byB1c2UgdGhlIGNhcmV0IHRvIHJlbW92ZSBlbGVtZW50c1xuXHRcdC8vIFx0Zm9yIG5vdyB3ZSB3aWxsIHNpbXBseSBub3Qgc3VwcG9ydCB0aGlzXG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRyb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuXHRcdH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobm9kZSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZW1vdmVOZXN0ZWQocm9vdCxhcnlbaV0sY2FyZXQpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gd2hhdCBpZiB0aGlzIGlzIG5vdCBudWxsPyE/IT9cblx0XHRcdC8vIHRha2UgYSBjaGFuY2UgYW5kIHJlbW92ZSBhIHRleHQtZWxlbWVudG5nXG5cdFx0XHR2YXIgbmV4dCA9IGNhcmV0ID8gKGNhcmV0Lm5leHRTaWJsaW5nKSA6IChyb290Ll9kb20uZmlyc3RDaGlsZCk7XG5cdFx0XHRpZiAoKG5leHQgaW5zdGFuY2VvZiBUZXh0KSAmJiBuZXh0LnRleHRDb250ZW50ID09IG5vZGUpIHtcblx0XHRcdFx0cm9vdC5yZW1vdmVDaGlsZChuZXh0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93ICdjYW5ub3QgcmVtb3ZlIHN0cmluZyc7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGNhcmV0O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gYXBwZW5kTmVzdGVkKHJvb3Qsbm9kZSl7XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRyb290LmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobm9kZSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcHBlbmROZXN0ZWQocm9vdCxhcnlbaV0pO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKG5vZGUgIT0gbnVsbCAmJiBub2RlICE9PSBmYWxzZSkge1xuXHRcdFx0cm9vdC5hcHBlbmRDaGlsZChJbWJhLmRvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUobm9kZSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0XG5cdC8vIGluc2VydCBub2RlcyBiZWZvcmUgYSBjZXJ0YWluIG5vZGVcblx0Ly8gZG9lcyBub3QgbmVlZCB0byByZXR1cm4gYW55IHRhaWwsIGFzIGJlZm9yZVxuXHQvLyB3aWxsIHN0aWxsIGJlIGNvcnJlY3QgdGhlcmVcblx0Ly8gYmVmb3JlIG11c3QgYmUgYW4gYWN0dWFsIGRvbW5vZGVcblx0ZnVuY3Rpb24gaW5zZXJ0TmVzdGVkQmVmb3JlKHJvb3Qsbm9kZSxiZWZvcmUpe1xuXHRcdGlmIChub2RlIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0cm9vdC5pbnNlcnRCZWZvcmUobm9kZSxiZWZvcmUpO1xuXHRcdH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobm9kZSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpbnNlcnROZXN0ZWRCZWZvcmUocm9vdCxhcnlbaV0sYmVmb3JlKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChub2RlICE9IG51bGwgJiYgbm9kZSAhPT0gZmFsc2UpIHtcblx0XHRcdHJvb3QuaW5zZXJ0QmVmb3JlKEltYmEuZG9jdW1lbnQoKS5jcmVhdGVUZXh0Tm9kZShub2RlKSxiZWZvcmUpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGJlZm9yZTtcblx0fTtcblx0XG5cdC8vIGFmdGVyIG11c3QgYmUgYW4gYWN0dWFsIGRvbW5vZGVcblx0ZnVuY3Rpb24gaW5zZXJ0TmVzdGVkQWZ0ZXIocm9vdCxub2RlLGFmdGVyKXtcblx0XHR2YXIgYmVmb3JlID0gYWZ0ZXIgPyAoYWZ0ZXIubmV4dFNpYmxpbmcpIDogKHJvb3QuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcblx0XHRpZiAoYmVmb3JlKSB7XG5cdFx0XHRpbnNlcnROZXN0ZWRCZWZvcmUocm9vdCxub2RlLGJlZm9yZSk7XG5cdFx0XHRyZXR1cm4gYmVmb3JlLnByZXZpb3VzU2libGluZztcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXBwZW5kTmVzdGVkKHJvb3Qsbm9kZSk7XG5cdFx0XHRyZXR1cm4gcm9vdC5fZG9tLmxhc3RDaGlsZDtcblx0XHR9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gcmVjb25jaWxlQ29sbGVjdGlvbkNoYW5nZXMocm9vdCxuZXckLG9sZCxjYXJldCl7XG5cdFx0XG5cdFx0dmFyIG5ld0xlbiA9IG5ldyQubGVuZ3RoO1xuXHRcdHZhciBsYXN0TmV3ID0gbmV3JFtuZXdMZW4gLSAxXTtcblx0XHRcblx0XHQvLyBUaGlzIHJlLW9yZGVyIGFsZ29yaXRobSBpcyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHByaW5jaXBsZTpcblx0XHQvLyBcblx0XHQvLyBXZSBidWlsZCBhIFwiY2hhaW5cIiB3aGljaCBzaG93cyB3aGljaCBpdGVtcyBhcmUgYWxyZWFkeSBzb3J0ZWQuXG5cdFx0Ly8gSWYgd2UncmUgZ29pbmcgZnJvbSBbMSwgMiwgM10gLT4gWzIsIDEsIDNdLCB0aGUgdHJlZSBsb29rcyBsaWtlOlxuXHRcdC8vXG5cdFx0Ly8gXHQzIC0+ICAwIChpZHgpXG5cdFx0Ly8gXHQyIC0+IC0xIChpZHgpXG5cdFx0Ly8gXHQxIC0+IC0xIChpZHgpXG5cdFx0Ly9cblx0XHQvLyBUaGlzIHRlbGxzIHVzIHRoYXQgd2UgaGF2ZSB0d28gY2hhaW5zIG9mIG9yZGVyZWQgaXRlbXM6XG5cdFx0Ly8gXG5cdFx0Ly8gXHQoMSwgMykgYW5kICgyKVxuXHRcdC8vIFxuXHRcdC8vIFRoZSBvcHRpbWFsIHJlLW9yZGVyaW5nIHRoZW4gYmVjb21lcyB0d28ga2VlcCB0aGUgbG9uZ2VzdCBjaGFpbiBpbnRhY3QsXG5cdFx0Ly8gYW5kIG1vdmUgYWxsIHRoZSBvdGhlciBpdGVtcy5cblx0XHRcblx0XHR2YXIgbmV3UG9zaXRpb24gPSBbXTtcblx0XHRcblx0XHQvLyBUaGUgdHJlZS9ncmFwaCBpdHNlbGZcblx0XHR2YXIgcHJldkNoYWluID0gW107XG5cdFx0Ly8gVGhlIGxlbmd0aCBvZiB0aGUgY2hhaW5cblx0XHR2YXIgbGVuZ3RoQ2hhaW4gPSBbXTtcblx0XHRcblx0XHQvLyBLZWVwIHRyYWNrIG9mIHRoZSBsb25nZXN0IGNoYWluXG5cdFx0dmFyIG1heENoYWluTGVuZ3RoID0gMDtcblx0XHR2YXIgbWF4Q2hhaW5FbmQgPSAwO1xuXHRcdFxuXHRcdGZvciAodmFyIGlkeCA9IDAsIGFyeSA9IGl0ZXIkKG9sZCksIGxlbiA9IGFyeS5sZW5ndGgsIG5vZGU7IGlkeCA8IGxlbjsgaWR4KyspIHtcblx0XHRcdG5vZGUgPSBhcnlbaWR4XTtcblx0XHRcdHZhciBuZXdQb3MgPSBuZXckLmluZGV4T2Yobm9kZSk7XG5cdFx0XHRuZXdQb3NpdGlvbi5wdXNoKG5ld1Bvcyk7XG5cdFx0XHRcblx0XHRcdGlmIChuZXdQb3MgPT0gLTEpIHtcblx0XHRcdFx0cm9vdC5yZW1vdmVDaGlsZChub2RlKTtcblx0XHRcdFx0cHJldkNoYWluLnB1c2goLTEpO1xuXHRcdFx0XHRsZW5ndGhDaGFpbi5wdXNoKC0xKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgcHJldklkeCA9IG5ld1Bvc2l0aW9uLmxlbmd0aCAtIDI7XG5cdFx0XHRcblx0XHRcdC8vIEJ1aWxkIHRoZSBjaGFpbjpcblx0XHRcdHdoaWxlIChwcmV2SWR4ID49IDApe1xuXHRcdFx0XHRpZiAobmV3UG9zaXRpb25bcHJldklkeF0gPT0gLTEpIHtcblx0XHRcdFx0XHRwcmV2SWR4LS07XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV3UG9zID4gbmV3UG9zaXRpb25bcHJldklkeF0pIHtcblx0XHRcdFx0XHQvLyBZYXksIHdlJ3JlIGJpZ2dlciB0aGFuIHRoZSBwcmV2aW91cyFcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBOb3BlLCBsZXQncyB3YWxrIGJhY2sgdGhlIGNoYWluXG5cdFx0XHRcdFx0cHJldklkeCA9IHByZXZDaGFpbltwcmV2SWR4XTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHByZXZDaGFpbi5wdXNoKHByZXZJZHgpO1xuXHRcdFx0XG5cdFx0XHR2YXIgY3Vyckxlbmd0aCA9IChwcmV2SWR4ID09IC0xKSA/ICgwKSA6IChsZW5ndGhDaGFpbltwcmV2SWR4XSArIDEpO1xuXHRcdFx0XG5cdFx0XHRpZiAoY3Vyckxlbmd0aCA+IG1heENoYWluTGVuZ3RoKSB7XG5cdFx0XHRcdG1heENoYWluTGVuZ3RoID0gY3Vyckxlbmd0aDtcblx0XHRcdFx0bWF4Q2hhaW5FbmQgPSBpZHg7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRsZW5ndGhDaGFpbi5wdXNoKGN1cnJMZW5ndGgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHN0aWNreU5vZGVzID0gW107XG5cdFx0XG5cdFx0Ly8gTm93IHdlIGNhbiB3YWxrIHRoZSBsb25nZXN0IGNoYWluIGJhY2t3YXJkcyBhbmQgbWFyayB0aGVtIGFzIFwic3RpY2t5XCIsXG5cdFx0Ly8gd2hpY2ggaW1wbGllcyB0aGF0IHRoZXkgc2hvdWxkIG5vdCBiZSBtb3ZlZFxuXHRcdHZhciBjdXJzb3IgPSBuZXdQb3NpdGlvbi5sZW5ndGggLSAxO1xuXHRcdHdoaWxlIChjdXJzb3IgPj0gMCl7XG5cdFx0XHRpZiAoY3Vyc29yID09IG1heENoYWluRW5kICYmIG5ld1Bvc2l0aW9uW2N1cnNvcl0gIT0gLTEpIHtcblx0XHRcdFx0c3RpY2t5Tm9kZXNbbmV3UG9zaXRpb25bY3Vyc29yXV0gPSB0cnVlO1xuXHRcdFx0XHRtYXhDaGFpbkVuZCA9IHByZXZDaGFpblttYXhDaGFpbkVuZF07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjdXJzb3IgLT0gMTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIEFuZCBsZXQncyBpdGVyYXRlIGZvcndhcmQsIGJ1dCBvbmx5IG1vdmUgbm9uLXN0aWNreSBub2Rlc1xuXHRcdGZvciAodmFyIGlkeDEgPSAwLCBhcnkgPSBpdGVyJChuZXckKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaWR4MSA8IGxlbjsgaWR4MSsrKSB7XG5cdFx0XHRpZiAoIXN0aWNreU5vZGVzW2lkeDFdKSB7XG5cdFx0XHRcdHZhciBhZnRlciA9IG5ldyRbaWR4MSAtIDFdO1xuXHRcdFx0XHRpbnNlcnROZXN0ZWRBZnRlcihyb290LGFyeVtpZHgxXSwoYWZ0ZXIgJiYgYWZ0ZXIuX2RvbSkgfHwgY2FyZXQpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCB0cnVzdCB0aGF0IHRoZSBsYXN0IGl0ZW0gaW4gbmV3IGxpc3QgaXMgdGhlIGNhcmV0XG5cdFx0cmV0dXJuIGxhc3ROZXcgJiYgbGFzdE5ldy5fZG9tIHx8IGNhcmV0O1xuXHR9O1xuXHRcblx0XG5cdC8vIGV4cGVjdHMgYSBmbGF0IG5vbi1zcGFyc2UgYXJyYXkgb2Ygbm9kZXMgaW4gYm90aCBuZXcgYW5kIG9sZCwgYWx3YXlzXG5cdGZ1bmN0aW9uIHJlY29uY2lsZUNvbGxlY3Rpb24ocm9vdCxuZXckLG9sZCxjYXJldCl7XG5cdFx0dmFyIGsgPSBuZXckLmxlbmd0aDtcblx0XHR2YXIgaSA9IGs7XG5cdFx0dmFyIGxhc3QgPSBuZXckW2sgLSAxXTtcblx0XHRcblx0XHRcblx0XHRpZiAoayA9PSBvbGQubGVuZ3RoICYmIG5ldyRbMF0gPT09IG9sZFswXSkge1xuXHRcdFx0Ly8gcnVubmluZyB0aHJvdWdoIHRvIGNvbXBhcmVcblx0XHRcdHdoaWxlIChpLS0pe1xuXHRcdFx0XHRpZiAobmV3JFtpXSAhPT0gb2xkW2ldKSB7IGJyZWFrOyB9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpID09IC0xKSB7XG5cdFx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0Ll9kb20gfHwgY2FyZXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiByZWNvbmNpbGVDb2xsZWN0aW9uQ2hhbmdlcyhyb290LG5ldyQsb2xkLGNhcmV0KTtcblx0XHR9O1xuXHR9O1xuXHRcblx0Ly8gdGhlIGdlbmVyYWwgcmVjb25jaWxlciB0aGF0IHJlc3BlY3RzIGNvbmRpdGlvbnMgZXRjXG5cdC8vIGNhcmV0IGlzIHRoZSBjdXJyZW50IG5vZGUgd2Ugd2FudCB0byBpbnNlcnQgdGhpbmdzIGFmdGVyXG5cdGZ1bmN0aW9uIHJlY29uY2lsZU5lc3RlZChyb290LG5ldyQsb2xkLGNhcmV0KXtcblx0XHRcblx0XHQvLyBpZiBuZXcgPT0gbnVsbCBvciBuZXcgPT09IGZhbHNlIG9yIG5ldyA9PT0gdHJ1ZVxuXHRcdC8vIFx0aWYgbmV3ID09PSBvbGRcblx0XHQvLyBcdFx0cmV0dXJuIGNhcmV0XG5cdFx0Ly8gXHRpZiBvbGQgJiYgbmV3ICE9IG9sZFxuXHRcdC8vIFx0XHRyZW1vdmVOZXN0ZWQocm9vdCxvbGQsY2FyZXQpIGlmIG9sZFxuXHRcdC8vIFxuXHRcdC8vIFx0cmV0dXJuIGNhcmV0XG5cdFx0XG5cdFx0Ly8gdmFyIHNraXBuZXcgPSBuZXcgPT0gbnVsbCBvciBuZXcgPT09IGZhbHNlIG9yIG5ldyA9PT0gdHJ1ZVxuXHRcdHZhciBuZXdJc051bGwgPSBuZXckID09IG51bGwgfHwgbmV3JCA9PT0gZmFsc2U7XG5cdFx0dmFyIG9sZElzTnVsbCA9IG9sZCA9PSBudWxsIHx8IG9sZCA9PT0gZmFsc2U7XG5cdFx0XG5cdFx0XG5cdFx0aWYgKG5ldyQgPT09IG9sZCkge1xuXHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCB0aGUgY2FyZXQgbXVzdCBiZSBhbiBhY3R1YWwgZG9tIGVsZW1lbnRcblx0XHRcdC8vIHdlIHNob3VsZCBpbnN0ZWFkIG1vdmUgdGhlIGFjdHVhbCBjYXJldD8gLSB0cnVzdFxuXHRcdFx0aWYgKG5ld0lzTnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gY2FyZXQ7XG5cdFx0XHR9IGVsc2UgaWYgKG5ldyQgJiYgbmV3JC5fZG9tKSB7XG5cdFx0XHRcdHJldHVybiBuZXckLl9kb207XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY2FyZXQgPyAoY2FyZXQubmV4dFNpYmxpbmcpIDogKHJvb3QuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChuZXckIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGlmIChvbGQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRpZiAobmV3JC5zdGF0aWMgfHwgb2xkLnN0YXRpYykge1xuXHRcdFx0XHRcdC8vIGlmIHRoZSBzdGF0aWMgaXMgbm90IG5lc3RlZCAtIHdlIGNvdWxkIGdldCBhIGhpbnQgZnJvbSBjb21waWxlclxuXHRcdFx0XHRcdC8vIGFuZCBqdXN0IHNraXAgaXRcblx0XHRcdFx0XHRpZiAobmV3JC5zdGF0aWMgPT0gb2xkLnN0YXRpYykge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5ldyQpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyB3aGVyZSB3ZSBjb3VsZCBkbyB0aGUgdHJpcGxlIGVxdWFsIGRpcmVjdGx5XG5cdFx0XHRcdFx0XHRcdGNhcmV0ID0gcmVjb25jaWxlTmVzdGVkKHJvb3QsYXJ5W2ldLG9sZFtpXSxjYXJldCk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNhcmV0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVOZXN0ZWQocm9vdCxvbGQsY2FyZXQpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gaWYgdGhleSBhcmUgbm90IHRoZSBzYW1lIHdlIGNvbnRpbnVlIHRocm91Z2ggdG8gdGhlIGRlZmF1bHRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVjb25jaWxlQ29sbGVjdGlvbihyb290LG5ldyQsb2xkLGNhcmV0KTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAob2xkIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKG9sZCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFvbGRJc051bGwpIHtcblx0XHRcdFx0Ly8gb2xkIHdhcyBhIHN0cmluZy1saWtlIG9iamVjdD9cblx0XHRcdFx0cm9vdC5yZW1vdmVDaGlsZChjYXJldCA/IChjYXJldC5uZXh0U2libGluZykgOiAocm9vdC5fZG9tLmZpcnN0Q2hpbGQpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBpbnNlcnROZXN0ZWRBZnRlcihyb290LG5ldyQsY2FyZXQpO1xuXHRcdFx0Ly8gcmVtb3ZlIG9sZFxuXHRcdH0gZWxzZSBpZiAobmV3JCBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdGlmICghb2xkSXNOdWxsKSB7IHJlbW92ZU5lc3RlZChyb290LG9sZCxjYXJldCkgfTtcblx0XHRcdGluc2VydE5lc3RlZEFmdGVyKHJvb3QsbmV3JCxjYXJldCk7XG5cdFx0XHRyZXR1cm4gbmV3JDtcblx0XHR9IGVsc2UgaWYgKG5ld0lzTnVsbCkge1xuXHRcdFx0aWYgKCFvbGRJc051bGwpIHsgcmVtb3ZlTmVzdGVkKHJvb3Qsb2xkLGNhcmV0KSB9O1xuXHRcdFx0cmV0dXJuIGNhcmV0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiBvbGQgZGlkIG5vdCBleGlzdCB3ZSBuZWVkIHRvIGFkZCBhIG5ldyBkaXJlY3RseVxuXHRcdFx0dmFyIG5leHROb2RlO1xuXHRcdFx0Ly8gaWYgb2xkIHdhcyBhcnJheSBvciBpbWJhdGFnIHdlIG5lZWQgdG8gcmVtb3ZlIGl0IGFuZCB0aGVuIGFkZFxuXHRcdFx0aWYgKG9sZCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdHJlbW92ZU5lc3RlZChyb290LG9sZCxjYXJldCk7XG5cdFx0XHR9IGVsc2UgaWYgKG9sZCBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdFx0cm9vdC5yZW1vdmVDaGlsZChvbGQpO1xuXHRcdFx0fSBlbHNlIGlmICghb2xkSXNOdWxsKSB7XG5cdFx0XHRcdC8vIC4uLlxuXHRcdFx0XHRuZXh0Tm9kZSA9IGNhcmV0ID8gKGNhcmV0Lm5leHRTaWJsaW5nKSA6IChyb290Ll9kb20uZmlyc3RDaGlsZCk7XG5cdFx0XHRcdGlmICgobmV4dE5vZGUgaW5zdGFuY2VvZiBUZXh0KSAmJiBuZXh0Tm9kZS50ZXh0Q29udGVudCAhPSBuZXckKSB7XG5cdFx0XHRcdFx0bmV4dE5vZGUudGV4dENvbnRlbnQgPSBuZXckO1xuXHRcdFx0XHRcdHJldHVybiBuZXh0Tm9kZTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG5vdyBhZGQgdGhlIHRleHRub2RlXG5cdFx0XHRyZXR1cm4gaW5zZXJ0TmVzdGVkQWZ0ZXIocm9vdCxuZXckLGNhcmV0KTtcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdHJldHVybiB0YWckLmV4dGVuZFRhZygnaHRtbGVsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAobmV3JCx0eXApe1xuXHRcdFx0dmFyIG9sZCA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Ly8gdmFyIGlzQXJyYXkgPSBub2RlcyBpc2EgQXJyYXlcblx0XHRcdGlmIChuZXckID09PSBvbGQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoIW9sZCkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCk7XG5cdFx0XHRcdGFwcGVuZE5lc3RlZCh0aGlzLG5ldyQpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gMikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodHlwID09IDEpIHtcblx0XHRcdFx0Ly8gaGVyZSB3ZSBfa25vdyBfdGhhdCBpdCBpcyBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIHNoYXBlXG5cdFx0XHRcdC8vIGV2ZXJ5IHRpbWVcblx0XHRcdFx0dmFyIGNhcmV0ID0gbnVsbDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5ldyQpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHQvLyBwcmV2ID0gb2xkW2ldXG5cdFx0XHRcdFx0Y2FyZXQgPSByZWNvbmNpbGVOZXN0ZWQodGhpcyxhcnlbaV0sb2xkW2ldLGNhcmV0KTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAodHlwID09IDMpIHtcblx0XHRcdFx0Ly8gdGhpcyBpcyBwb3NzaWJseSBmdWxseSBkeW5hbWljLiBJdCBvZnRlbiBpc1xuXHRcdFx0XHQvLyBidXQgdGhlIG9sZCBvciBuZXcgY291bGQgYmUgc3RhdGljIHdoaWxlIHRoZSBvdGhlciBpcyBub3Rcblx0XHRcdFx0Ly8gdGhpcyBpcyBub3QgaGFuZGxlZCBub3dcblx0XHRcdFx0Ly8gd2hhdCBpZiBpdCB3YXMgcHJldmlvdXNseSBhIHN0YXRpYyBhcnJheT8gZWRnZWNhc2UgLSBidXQgbXVzdCB3b3JrXG5cdFx0XHRcdGlmIChuZXckIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0XHRcdHRoaXMuZW1wdHkoKTtcblx0XHRcdFx0XHR0aGlzLmFwcGVuZENoaWxkKG5ldyQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5ldyQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdGlmIChvbGQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdFx0Ly8gaXMgdGhpcyBub3QgdGhlIHNhbWUgYXMgc2V0dGluZyBzdGF0aWNDaGlsZHJlbiBub3cgYnV0IHdpdGggdGhlXG5cdFx0XHRcdFx0XHRyZWNvbmNpbGVDb2xsZWN0aW9uKHRoaXMsbmV3JCxvbGQsbnVsbCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuZW1wdHkoKTtcblx0XHRcdFx0XHRcdGFwcGVuZE5lc3RlZCh0aGlzLG5ldyQpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRUZXh0KG5ldyQpO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICgobmV3JCBpbnN0YW5jZW9mIEFycmF5KSAmJiAob2xkIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdHJlY29uY2lsZUNvbGxlY3Rpb24odGhpcyxuZXckLG9sZCxudWxsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKTtcblx0XHRcdFx0YXBwZW5kTmVzdGVkKHRoaXMsbmV3JCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IG5ldyQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8vIG9ubHkgZXZlciBjYWxsZWQgd2l0aCBhcnJheSBhcyBhcmd1bWVudFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0U3RhdGljQ2hpbGRyZW4gPSBmdW5jdGlvbiAobmV3JCl7XG5cdFx0XHR2YXIgb2xkID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRcblx0XHRcdHZhciBjYXJldCA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobmV3JCksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHQvLyBwcmV2ID0gb2xkW2ldXG5cdFx0XHRcdGNhcmV0ID0gcmVjb25jaWxlTmVzdGVkKHRoaXMsYXJ5W2ldLG9sZFtpXSxjYXJldCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IG5ldyQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgfHwgdGhpcy5jaGlsZHJlbigpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdGlmICh0ZXh0ICE9IHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuID0gdGV4dDtcblx0XHRcdFx0dGhpcy5kb20oKS50ZXh0Q29udGVudCA9IHRleHQgPT0gbnVsbCB8fCB0ZXh0ID09PSBmYWxzZSA/ICgnJykgOiAodGV4dCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLnN0YXRpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0XG5cdC8qXG5cdFRoZSBzcGVjaWFsIHN5bnRheCBmb3Igc2VsZWN0b3JzIGluIEltYmEgY3JlYXRlcyBJbWJhLlNlbGVjdG9yXG5cdGluc3RhbmNlcy5cblx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IgPSBmdW5jdGlvbiBTZWxlY3RvcihzZWwsc2NvcGUsbm9kZXMpe1xuXHRcdFxuXHRcdHRoaXMuX3F1ZXJ5ID0gc2VsIGluc3RhbmNlb2YgSW1iYS5TZWxlY3RvciA/IChzZWwucXVlcnkoKSkgOiAoc2VsKTtcblx0XHR0aGlzLl9jb250ZXh0ID0gc2NvcGU7XG5cdFx0XG5cdFx0aWYgKG5vZGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobm9kZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlcy5wdXNoKHRhZyR3cmFwKGFyeVtpXSkpO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuX25vZGVzID0gcmVzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fbGF6eSA9ICFub2Rlcztcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuU2VsZWN0b3Iub25lID0gZnVuY3Rpb24gKHNlbCxzY29wZSl7XG5cdFx0dmFyIGVsID0gKHNjb3BlIHx8IEltYmEuZG9jdW1lbnQoKSkucXVlcnlTZWxlY3RvcihzZWwpO1xuXHRcdHJldHVybiBlbCAmJiB0YWckd3JhcChlbCkgfHwgbnVsbDtcblx0fTtcblx0XG5cdEltYmEuU2VsZWN0b3IuYWxsID0gZnVuY3Rpb24gKHNlbCxzY29wZSl7XG5cdFx0cmV0dXJuIG5ldyBJbWJhLlNlbGVjdG9yKHNlbCxzY29wZSk7XG5cdH07XG5cdFxuXHRcblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9xdWVyeTsgfVxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5zZXRRdWVyeSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9xdWVyeSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fbm9kZXMgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgY3R4O1xuXHRcdGlmICh0aGlzLl9zY29wZSkgeyByZXR1cm4gdGhpcy5fc2NvcGUgfTtcblx0XHRpZiAoIShjdHggPSB0aGlzLl9jb250ZXh0KSkgeyByZXR1cm4gSW1iYS5kb2N1bWVudCgpIH07XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlID0gY3R4LnRvU2NvcGUgPyAoY3R4LnRvU2NvcGUoKSkgOiAoY3R4KTtcblx0fTtcblx0XG5cdC8qXG5cdFx0QHJldHVybnMge0ltYmEuVGFnfSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoaXMgc2VsZWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fbGF6eSkgeyByZXR1cm4gdGFnJHdyYXAodGhpcy5fZmlyc3QgfHwgKHRoaXMuX2ZpcnN0ID0gdGhpcy5zY29wZSgpLnF1ZXJ5U2VsZWN0b3IodGhpcy5xdWVyeSgpKSkpIH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlcygpWzBdO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvKlxuXHRcdEByZXR1cm5zIHtJbWJhLlRhZ30gbGFzdCBub2RlIG1hdGNoaW5nIHRoaXMgc2VsZWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLm5vZGVzKClbdGhpcy5fbm9kZXMubGVuZ3RoIC0gMV07XG5cdH07XG5cdFxuXHQvKlxuXHRcdEByZXR1cm5zIFtJbWJhLlRhZ10gYWxsIG5vZGVzIG1hdGNoaW5nIHRoaXMgc2VsZWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fbm9kZXMpIHsgcmV0dXJuIHRoaXMuX25vZGVzIH07XG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5zY29wZSgpLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5xdWVyeSgpKTtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoaXRlbXMpLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRyZXMucHVzaCh0YWckd3JhcChhcnlbaV0pKTtcblx0XHR9O1xuXHRcdHRoaXMuX25vZGVzID0gcmVzO1xuXHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcy5fbm9kZXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFRoZSBudW1iZXIgb2Ygbm9kZXMgbWF0Y2hpbmcgdGhpcyBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLm5vZGVzKCkubGVuZ3RoO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUubGVuID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKS5sZW5ndGg7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEB0b2RvIEFkZCBzdXBwb3J0IGZvciBibG9jayBvciBzZWxlY3Rvcj9cblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmNvdW50KCkgPj0gMTtcblx0fTtcblx0XG5cdC8qXG5cdFx0R2V0IG5vZGUgYXQgaW5kZXhcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaWR4KXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlcygpW2lkeF07XG5cdH07XG5cdFxuXHQvKlxuXHRcdExvb3AgdGhyb3VnaCBub2Rlc1xuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGJsb2NrKXtcblx0XHR0aGlzLm5vZGVzKCkuZm9yRWFjaChibG9jayk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdE1hcCBub2Rlc1xuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoYmxvY2spe1xuXHRcdHJldHVybiB0aGlzLm5vZGVzKCkubWFwKGJsb2NrKTtcblx0fTtcblx0XG5cdC8qXG5cdFx0UmV0dXJucyBhIHBsYWluIGFycmF5IGNvbnRhaW5pbmcgbm9kZXMuIEltcGxpY2l0bHkgY2FsbGVkXG5cdFx0d2hlbiBpdGVyYXRpbmcgb3ZlciBhIHNlbGVjdG9yIGluIEltYmEgYChub2RlIGZvciBub2RlIGluICQoc2VsZWN0b3IpKWBcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLm5vZGVzKCk7XG5cdH07XG5cdFxuXHQvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciwgXG5cdC8vIGJlZ2lubmluZyBhdCB0aGUgY3VycmVudCBlbGVtZW50IGFuZCBwcm9ncmVzc2luZyB1cCB0aHJvdWdoIHRoZSBET00gdHJlZVxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0Ly8gc2VlbXMgc3RyYW5nZSB0aGF0IHdlIGFsdGVyIHRoaXMgc2VsZWN0b3I/XG5cdFx0dGhpcy5fbm9kZXMgPSB0aGlzLm1hcChmdW5jdGlvbihub2RlKSB7IHJldHVybiBub2RlLmNsb3Nlc3Qoc2VsKTsgfSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBHZXQgdGhlIHNpYmxpbmdzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IG9mIG1hdGNoZWQgZWxlbWVudHMsIFxuXHQvLyBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGEgc2VsZWN0b3IuXG5cdC8vIFRPRE8gcmVtb3ZlIGR1cGxpY2F0ZXM/XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnNpYmxpbmdzID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0dGhpcy5fbm9kZXMgPSB0aGlzLm1hcChmdW5jdGlvbihub2RlKSB7IHJldHVybiBub2RlLnNpYmxpbmdzKHNlbCk7IH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gR2V0IHRoZSBkZXNjZW5kYW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIGN1cnJlbnQgc2V0IG9mIG1hdGNoZWQgXG5cdC8vIGVsZW1lbnRzLCBmaWx0ZXJlZCBieSBhIHNlbGVjdG9yLlxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0dGhpcy5fbm9kZXMgPSB0aGlzLl9fcXVlcnlfXyhzZWwucXVlcnkoKSx0aGlzLm5vZGVzKCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKGJsayl7XG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGJsayxmYWxzZSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEZpbHRlciB0aGUgbm9kZXMgaW4gc2VsZWN0b3IgYnkgYSBmdW5jdGlvbiBvciBvdGhlciBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoYmxrLGJvb2wpe1xuXHRcdGlmKGJvb2wgPT09IHVuZGVmaW5lZCkgYm9vbCA9IHRydWU7XG5cdFx0dmFyIGZuID0gKGJsayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiBibGsgfHwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5tYXRjaGVzKGJsayk7IH07XG5cdFx0dmFyIGFyeSA9IHRoaXMubm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24obikgeyByZXR1cm4gZm4obikgPT0gYm9vbDsgfSk7XG5cdFx0Ly8gaWYgd2Ugd2FudCB0byByZXR1cm4gYSBuZXcgc2VsZWN0b3IgZm9yIHRoaXMsIHdlIHNob3VsZCBkbyB0aGF0IGZvclxuXHRcdC8vIG90aGVycyBhcyB3ZWxsXG5cdFx0cmV0dXJuIG5ldyBJbWJhLlNlbGVjdG9yKFwiXCIsdGhpcy5fc2NvcGUsYXJ5KTtcblx0fTtcblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLl9fcXVlcnlfXyA9IGZ1bmN0aW9uIChxdWVyeSxjb250ZXh0cyl7XG5cdFx0dmFyIG5vZGVzID0gW107XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBsID0gY29udGV4dHMubGVuZ3RoO1xuXHRcdFxuXHRcdHdoaWxlIChpIDwgbCl7XG5cdFx0XHRub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLGNvbnRleHRzW2krK10ucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpO1xuXHRcdH07XG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuX19tYXRjaGVzX18gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8qXG5cdFx0QWRkIHNwZWNpZmllZCBmbGFnIHRvIGFsbCBub2RlcyBpbiBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5mbGFnID0gZnVuY3Rpb24gKGZsYWcpe1xuXHRcdHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24obikgeyByZXR1cm4gbi5mbGFnKGZsYWcpOyB9KTtcblx0fTtcblx0XG5cdC8qXG5cdFx0UmVtb3ZlIHNwZWNpZmllZCBmbGFnIGZyb20gYWxsIG5vZGVzIGluIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnVuZmxhZyA9IGZ1bmN0aW9uIChmbGFnKXtcblx0XHRyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udW5mbGFnKGZsYWcpOyB9KTtcblx0fTtcblx0XG5cdFxuXHQvLyBkZWYgSW1iYS5xdWVyeVNlbGVjdG9yQWxsXG5cdHEkID0gZnVuY3Rpb24oc2VsLHNjb3BlKSB7IHJldHVybiBuZXcgSW1iYS5TZWxlY3RvcihzZWwsc2NvcGUpOyB9O1xuXHRcblx0Ly8gZGVmIEltYmEuU2VsZWN0b3Iub25lXG5cdHEkJCA9IGZ1bmN0aW9uKHNlbCxzY29wZSkge1xuXHRcdHZhciBlbCA9IChzY29wZSB8fCBJbWJhLmRvY3VtZW50KCkpLnF1ZXJ5U2VsZWN0b3Ioc2VsKTtcblx0XHRyZXR1cm4gZWwgJiYgdGFnJHdyYXAoZWwpIHx8IG51bGw7XG5cdH07XG5cdFxuXHRcblx0Ly8gZXh0ZW5kaW5nIHRhZ3Mgd2l0aCBxdWVyeS1tZXRob2RzXG5cdC8vIG11c3QgYmUgYSBiZXR0ZXIgd2F5IHRvIHJlb3BlbiBjbGFzc2VzXG5cdHJldHVybiB0YWckLmV4dGVuZFRhZygnZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24gKHEpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5xdWVyeVNlbGVjdG9yQWxsKHEpO1xuXHRcdH07XG5cdFx0dGFnLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHEpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5xdWVyeVNlbGVjdG9yKHEpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIGJlIG1vdmVkIHRvIEltYmEuVGFnIGluc3RlYWQ/XG5cdFx0Ly8gb3Igd2Ugc2hvdWxkIGltcGxlbWVudCBhbGwgb2YgdGhlbSBoZXJlXG5cdFx0dGFnLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRyZXR1cm4gbmV3IEltYmEuU2VsZWN0b3Ioc2VsLHRoaXMpO1xuXHRcdH07XG5cdH0pO1xuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9zZWxlY3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0dmFyIHV0aWw7XG5cdElNREVCVUcgPSB0cnVlO1xuXHRcblx0Ly8gd3RmIGVyIGFsdCBkZXR0ZT9cblx0SU0gPSB7fTtcblx0SU0uTkVXTElORSA9ICdcXG4nO1xuXHRJTS5DSEFSID0gMDtcblx0SU0uV09SRF9TVEFSVCA9IDE7XG5cdElNLldPUkRfRU5EID0gMjtcblx0SU0uUFVOQ1RVQVRJT05fU1RBUlQgPSAzO1xuXHRJTS5QVU5DVFVBVElPTl9FTkQgPSA0O1xuXHRJTS5TVUJfV09SRF9TVEFSVCA9IDU7XG5cdElNLlNVQl9XT1JEX0VORCA9IDY7XG5cdElNLkxJTkVfU1RBUlQgPSA3O1xuXHRJTS5MSU5FX0VORCA9IDg7XG5cdElNLkVNUFRZX0xJTkUgPSA5O1xuXHRcblx0SU0uRlMgPSByZXF1aXJlKCcuL2NvcmUvZnMnKTtcblx0XG5cdHZhciBTb3VyY2VNYXAgPSByZXF1aXJlKCdzb3VyY2UtbWFwJyk7XG5cdFxuXHQvLyBpZiBnbG9iYWw6cmVxdWlyZVxuXHR2YXIgUmVnaW9uID0gcmVxdWlyZShcIi4vcmVnaW9uXCIpLlJlZ2lvbjtcblx0XG5cdHJlcXVpcmUoJy4vaGVscGVycycpO1xuXHRcblx0cmVxdWlyZSgnLi9jb3JlL2hpc3RvcnknKTtcblx0cmVxdWlyZSgnLi9jb3JlL2xvZ2dlcicpO1xuXHRyZXF1aXJlKCcuL2NvcmUvc2hvcnRjdXRzJyk7XG5cdFxuXHRyZXF1aXJlKFwiLi92aWV3cy9jYXB0b3JcIik7XG5cdHJlcXVpcmUoXCIuL3ZpZXdcIik7XG5cdHJlcXVpcmUoXCIuL2VkaXRvclwiKTtcblx0XG5cdHZhciBIaWdobGlnaHRlciA9IHJlcXVpcmUoXCIuL2NvcmUvaGlnaGxpZ2h0ZXJcIikuSGlnaGxpZ2h0ZXI7XG5cdHZhciBJbWJhY1dvcmtlciA9IHJlcXVpcmUoXCIuL2NvcmUvd29ya2VyXCIpLkltYmFjV29ya2VyO1xuXHRcblx0SU0ud29ya2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3dvcmtlciB8fCAodGhpcy5fd29ya2VyID0gbmV3IEltYmFjV29ya2VyKCkpO1xuXHR9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMudXRpbCA9IHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXHQvLyBub2Rlc1xuXHRyZXF1aXJlKFwiLi9ub2Rlcy9pbmRleFwiKTtcblx0XG5cdFxuXHRmdW5jdGlvbiB3b3JrZXIoKXtcblx0XHRyZXR1cm4gSU0ud29ya2VyKCk7XG5cdH07IGV4cG9ydHMud29ya2VyID0gd29ya2VyO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMuU291cmNlTWFwID0gU291cmNlTWFwO1xuXHRtb2R1bGUuZXhwb3J0cy5SZWdpb24gPSBSZWdpb247XG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cy5IaWdobGlnaHRlciA9IEhpZ2hsaWdodGVyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvaW5kZXguaW1iYVxuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0Ly8gZXh0ZXJucztcblx0ZnVuY3Rpb24gc2F2ZShwYXRoLGNvbnRlbnQsZW5jb2RpbmcsY2Ipe1xuXHRcdGlmKGNiPT11bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nID09ICdmdW5jdGlvbicpIGNiID0gZW5jb2RpbmcsZW5jb2RpbmcgPSAndXRmLTgnO1xuXHRcdGlmKGVuY29kaW5nPT11bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0Zi04Jztcblx0XHRjb25zb2xlLmxvZygnc2F2ZScscGF0aCxjb250ZW50LGVuY29kaW5nKTtcblx0XHRcblx0XHRyZXR1cm4geHIucG9zdChwYXRoLHtib2R5OiBjb250ZW50fSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdyZXNwb25kZWQnKTtcblx0XHRcdHJldHVybiBjYiAmJiBjYihhcmd1bWVudHMpO1xuXHRcdH0pO1xuXHR9OyBleHBvcnRzLnNhdmUgPSBzYXZlO1xuXHRcblx0ZnVuY3Rpb24gcmVhZEZpbGVBc3luYyhwYXRoLGVuY29kaW5nLGNiKXtcblx0XHRpZihjYj09dW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyA9PSAnZnVuY3Rpb24nKSBjYiA9IGVuY29kaW5nLGVuY29kaW5nID0gJ3V0Zi04Jztcblx0XHRpZihlbmNvZGluZz09dW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGYtOCc7XG5cdFx0Y29uc29sZS5sb2coJ3NhdmUnLHBhdGgsZW5jb2RpbmcpO1xuXHRcdFxuXHRcdHJldHVybiB4ci5nZXQocGF0aCkudGhlbihmdW5jdGlvbihyZXMpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdyZXNwb25kZWQnLHJlcyk7XG5cdFx0XHRjYiAmJiBjYihhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9KTtcblx0fTsgZXhwb3J0cy5yZWFkRmlsZUFzeW5jID0gcmVhZEZpbGVBc3luYzs7IHJldHVybiByZWFkRmlsZUFzeW5jO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9mcy5pbWJhXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvc291cmNlLW1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICAgKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgICBpZiAoIWFBcmdzKSB7XG4gICAgICBhQXJncyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gIH1cblxuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICAgKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICAgKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gICAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gICAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICAgKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAgICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAgICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICAgKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAgICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gICAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAgICpcbiAgICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICAgKiAgICAgIHRva2VuLlxuICAgKlxuICAgKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAgICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgICAvLyBDYXNlIDEuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICAgKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbWFwcGluZztcbiAgICAgIHZhciBuYW1lSWR4O1xuICAgICAgdmFyIHNvdXJjZUlkeDtcblxuICAgICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJzsnO1xuICAgICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSlcbiAgICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1nZW5lcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xue1xuICB2YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuICAvLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbiAgLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4gIC8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuICAvLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4gIC8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuICAvL1xuICAvLyAgIENvbnRpbnVhdGlvblxuICAvLyAgIHwgICAgU2lnblxuICAvLyAgIHwgICAgfFxuICAvLyAgIFYgICAgVlxuICAvLyAgIDEwMTAxMVxuXG4gIHZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuICAvLyBiaW5hcnk6IDAxMTExMVxuICB2YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuICAvKipcbiAgICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAgICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAgICovXG4gIGZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICAgIHJldHVybiBhVmFsdWUgPCAwXG4gICAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gICAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICAgIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICAgIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gICAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICAgID8gLXNoaWZ0ZWRcbiAgICAgIDogc2hpZnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICAgIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgICB2YXIgZGlnaXQ7XG5cbiAgICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICAgIGRvIHtcbiAgICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgICAgaWYgKHZscSA+IDApIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgICB9XG4gICAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICAgIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gICAgcmV0dXJuIGVuY29kZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICAgKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIHNoaWZ0ID0gMDtcbiAgICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICAgIH1cblxuICAgICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gICAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICAgIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xuICB9O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICB2YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuICAvKipcbiAgICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIGlmICgwIDw9IG51bWJlciAmJiBudW1iZXIgPCBpbnRUb0NoYXJNYXAubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgbnVtYmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICAgKiBmYWlsdXJlLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gICAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gICAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICAgIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICAgIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gICAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gICAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICAgIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAgIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gICAgfVxuXG4gICAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICAgIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyA2MjogK1xuICAgIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgICByZXR1cm4gNjI7XG4gICAgfVxuXG4gICAgLy8gNjM6IC9cbiAgICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICAgIHJldHVybiA2MztcbiAgICB9XG5cbiAgICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgICByZXR1cm4gLTE7XG4gIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvYmFzZTY0LmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAgICogb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gICAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAgICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgICB9XG4gIH1cbiAgZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbiAgdmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuXSopKD86OihcXGQrKSk/KFxcUyopJC87XG4gIHZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuICBmdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gICAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgICAgaG9zdDogbWF0Y2hbM10sXG4gICAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICAgIHBhdGg6IG1hdGNoWzVdXG4gICAgfTtcbiAgfVxuICBleHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbiAgZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICAgIHZhciB1cmwgPSAnJztcbiAgICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgICB9XG4gICAgdXJsICs9ICcvLyc7XG4gICAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAgICpcbiAgICogLSBSZXBsYWNlcyBjb25zZXF1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICAgKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICAgKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAgICpcbiAgICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gICAgdmFyIHBhdGggPSBhUGF0aDtcbiAgICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHVybC5wYXRoO1xuICAgIH1cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICAgIHVwID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgdXAtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICB9XG5cbiAgICBpZiAodXJsKSB7XG4gICAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbiAgLyoqXG4gICAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICAgKlxuICAgKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gICAqXG4gICAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gICAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICAgKiAgIGZpcnN0LlxuICAgKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAgICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gICAqICAgaXMgcmV0dXJuZWQuXG4gICAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAgICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICAgKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gICAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgICBhUm9vdCA9IFwiLlwiO1xuICAgIH1cbiAgICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICAgIGFQYXRoID0gXCIuXCI7XG4gICAgfVxuICAgIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICAgIH1cblxuICAgIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gICAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICAgIH1cblxuICAgIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICAgIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgICB9XG5cbiAgICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICAgID8gYVBhdGhcbiAgICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIGpvaW5lZDtcbiAgfVxuICBleHBvcnRzLmpvaW4gPSBqb2luO1xuXG4gIGV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICAgIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCAhIWFQYXRoLm1hdGNoKHVybFJlZ2V4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gICAqL1xuICBmdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuXG4gICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAgIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gICAgdmFyIGxldmVsID0gMDtcbiAgICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuXG4gICAgICArK2xldmVsO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gICAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbiAgfVxuICBleHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbiAgLyoqXG4gICAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAgICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuICBleHBvcnRzLnRvU2V0U3RyaW5nID0gdG9TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuIGFTdHIuc3Vic3RyKDEpO1xuICB9XG4gIGV4cG9ydHMuZnJvbVNldFN0cmluZyA9IGZyb21TZXRTdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gICAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gICAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG4gIH1cbiAgZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAgICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICAgKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICAgKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG4gIH1cbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICAgKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gIH1cbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qKlxuICAgKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAgICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gICAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAgICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICAgKi9cbiAgZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zZXQgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAgICovXG4gIEFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICAgKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAgICpcbiAgICogQHJldHVybnMgTnVtYmVyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgdmFyIGlzRHVwbGljYXRlID0gdGhpcy5fc2V0Lmhhc093blByb3BlcnR5KHNTdHIpO1xuICAgIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICByZXR1cm4gdGhpcy5fc2V0Lmhhc093blByb3BlcnR5KHNTdHIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAodGhpcy5fc2V0Lmhhc093blByb3BlcnR5KHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICAgKlxuICAgKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICAgKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICAgKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xuICB9O1xuXG4gIGV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gICAqIHBvc2l0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICAgIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gICAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAgICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gICAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gICAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gICAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAgICpcbiAgICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gICAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICpcbiAgICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gICAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICAgKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICAgKiBjb3B5LlxuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICAgIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5O1xuICB9O1xuXG4gIGV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApXG4gICAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCk7XG4gIH1cblxuICBTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCkge1xuICAgIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgfVxuICB9KTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgfVxuICB9KTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gICAgfTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuICBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuICBTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAgICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICAgKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gICAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAgICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gICAqIEBwYXJhbSBhT3JkZXJcbiAgICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAgICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gICAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICAgIHZhciBtYXBwaW5ncztcbiAgICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgICB9O1xuICAgICAgfSwgdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAgICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICAgKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gICAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gICAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICAgKlxuICAgKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKG5lZWRsZS5zb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobmVlZGxlLnNvdXJjZSk7XG5cbiAgICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXBwaW5ncztcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAgICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gICAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAgICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICAgKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICAgKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAgICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gICAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICAgKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAgICogICAgIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gICAqL1xuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAgIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICAgIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICAgIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gICAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAgIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAgIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgICA6IHNvdXJjZTtcbiAgICAgIH0pO1xuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICAgKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgICAgcmV0dXJuIHNtYztcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBwaW5nKCkge1xuICAgIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gICAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgICAgdmFyIHRlbXAgPSB7fTtcbiAgICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgICAvLyBmYWN0IGJ5IGNhY2hpbmcgdGhlIHBhcnNlZCB2YXJpYWJsZSBsZW5ndGggZmllbGRzIG9mIGVhY2ggc2VnbWVudCxcbiAgICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgICBzZWdtZW50ID0gY2FjaGVkU2VnbWVudHNbc3RyXTtcbiAgICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gICAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gICAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gICAqIGluY2x1c2l2ZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgICAgbmVlZGxlLFxuICAgICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICAgKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAgICogYXZhaWxhYmxlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgICAgbmVlZGxlLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICAgKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICAgKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAgICogaW5wdXQuXG4gICAqXG4gICAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICAgKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gICAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgKlxuICAgKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAgICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAgICpcbiAgICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICAgKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAgICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAgICogICAgICAgZmllbGQuXG4gICAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICAgKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICAgKlxuICAgKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAgICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAgICogdW5zdXBwb3J0ZWQuXG4gICAqXG4gICAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gICAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gICAqXG4gICAqICB7XG4gICAqICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICAgKiAgICBzZWN0aW9uczogW3tcbiAgICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAgICogICAgICBtYXA6IHtcbiAgICogICAgICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gICAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAgICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAgICogICAgICB9XG4gICAqICAgIH1dLFxuICAgKiAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gICAqL1xuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gICAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgICBsaW5lOiAtMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIGlmIChzLnVybCkge1xuICAgICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICAgIH1cbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNvdXJjZXM7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgfSk7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07XG5cbiAgICAgIGlmICghc2VjdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgICBuYW1lOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWN0aW9uLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgIDogMCksXG4gICAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICAgKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAgICogYXZhaWxhYmxlLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgICAgOiAwKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICAgIHZhciBzb3VyY2UgPSBzZWN0aW9uLmNvbnN1bWVyLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgICAgdmFyIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgICA6IDApLFxuICAgICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuICBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuICAvKipcbiAgICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICAgKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgLy9cbiAgICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4gICAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gICAgLy9cbiAgICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAgIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICAgKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICAgKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gICAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gICAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAgICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICAgKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICAgKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICovXG4gIGV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gICAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbiAgICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gICAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICAgIHdoaWxlIChpbmRleCAtIDEgPj0gMCkge1xuICAgICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC0taW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2JpbmFyeS1zZWFyY2guanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICAvLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuICAvLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuICAvLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbiAgLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuICAvLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuICAvLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuICAvLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuICAvLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbiAgLyoqXG4gICAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAgICogICAgICAgIFRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gICAqL1xuICBmdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICAgIHZhciB0ZW1wID0gYXJ5W3hdO1xuICAgIGFyeVt4XSA9IGFyeVt5XTtcbiAgICBhcnlbeV0gPSB0ZW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbG93XG4gICAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICAgKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICAgKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcFxuICAgKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSByXG4gICAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gICAqL1xuICBmdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gICAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gICAgaWYgKHAgPCByKSB7XG4gICAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgICAgLy8gdHJ1ZTpcbiAgICAgIC8vXG4gICAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgICAvL1xuICAgICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICAgKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICAgKi9cbiAgZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG4gIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbiAgdmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuICAvLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbiAgdmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4gIC8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2ZcbiAgLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3NcbiAgLy8gdmVyc2lvbnMhXG4gIHZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4gIC8qKlxuICAgKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gICAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICAgKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAgICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gICAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAgICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gICAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICAgKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gICAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICAgIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gICAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICAgIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqXG4gICAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAgICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAgICovXG4gIFNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhpcyBhcnJheSwgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsaW5lQ29udGVudHMgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpO1xuICAgICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICAgIHZhciBuZXdMaW5lID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgICAgaWYgKHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLmpvaW4oXCJcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoYUNodW5rKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAgICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICAgKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gICAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICAgKlxuICAgKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gICAgdmFyIG5ld0NoaWxkcmVuO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgICB9XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gICAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICAgKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAgICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICAgKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHN0ciArPSBjaHVuaztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gICAqIG1hcC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICAgIGNvZGU6IFwiXCIsXG4gICAgICBsaW5lOiAxLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG4gIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0XG5cdFxuXHRmdW5jdGlvbiBSZWdpb24oYSxiLHJvb3Qsdmlldyl7XG5cdFx0dGhpcy5fYSA9IGE7XG5cdFx0dGhpcy5fYiA9IGI7XG5cdFx0dGhpcy5fcm9vdCA9IHJvb3Q7XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLlJlZ2lvbiA9IFJlZ2lvbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuYSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYTsgfVxuXHRSZWdpb24ucHJvdG90eXBlLnNldEEgPSBmdW5jdGlvbih2KXsgdGhpcy5fYSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuYiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYjsgfVxuXHRSZWdpb24ucHJvdG90eXBlLnNldEIgPSBmdW5jdGlvbih2KXsgdGhpcy5fYiA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRSZWdpb24ucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm9vdDsgfVxuXHRSZWdpb24ucHJvdG90eXBlLnNldFJvb3QgPSBmdW5jdGlvbih2KXsgdGhpcy5fcm9vdCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Ly8gcmVtb3ZlIHJvb3QgZnJvbSByZWdpb25cblx0XG5cdFJlZ2lvbi5ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsLHZpZXcpe1xuXHRcdHZhciBsaW5lXztcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgUmVnaW9uKSB7IHJldHVybiB2YWwgfTtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHsgcmV0dXJuIG5ldyBSZWdpb24odmFsWzBdLHZhbFsxXSxudWxsLHZpZXcpIH07XG5cdFx0aWYgKCh0eXBlb2YgdmFsPT0nbnVtYmVyJ3x8dmFsIGluc3RhbmNlb2YgTnVtYmVyKSkgeyByZXR1cm4gbmV3IFJlZ2lvbih2YWwsdmFsLG51bGwsdmlldykgfTtcblx0XHRcblx0XHRpZiAoKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkgJiYgKHR5cGVvZiAobGluZV8gPSB2YWwubGluZSk9PSdudW1iZXInfHxsaW5lXyBpbnN0YW5jZW9mIE51bWJlcikpIHtcblx0XHRcdHZhciBsaW5lcyA9IHZpZXcuX2J1ZmZlci5saW5lcygpO1xuXHRcdFx0dmFyIGxvYyA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobGluZXMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aWYgKGkgPCAodmFsLmxpbmUgLSAxKSkge1xuXHRcdFx0XHRcdGxvYyArPSBhcnlbaV0ubGVuZ3RoICsgMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGxvYyArPSAodmFsLmNvbHVtbiB8fCAwKTtcblx0XHRcdHJldHVybiBuZXcgUmVnaW9uKGxvYyxsb2MsbnVsbCx2aWV3KTtcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gTWF0aC5taW4odGhpcy5fYSx0aGlzLl9iKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIE1hdGgubWF4KHRoaXMuX2EsdGhpcy5fYik7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGFkLGJkKXtcblx0XHRpZihhZCA9PT0gdW5kZWZpbmVkKSBhZCA9IDA7XG5cdFx0aWYoYmQgPT09IHVuZGVmaW5lZCkgYmQgPSAwO1xuXHRcdHJldHVybiBuZXcgUmVnaW9uKHRoaXMuX2EgKyBhZCx0aGlzLl9iICsgYmQsdGhpcy5fcm9vdCx0aGlzLl92aWV3KTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocmVsKXtcblx0XHRpZiAocmVsIGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFydCgpIDw9IHJlbC5zdGFydCgpICYmIHRoaXMuZW5kKCkgPj0gcmVsLmVuZCgpO1xuXHRcdH0gZWxzZSBpZiAoKHR5cGVvZiByZWw9PSdudW1iZXInfHxyZWwgaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFydCgpIDw9IHJlbCAmJiB0aGlzLmVuZCgpID49IHJlbDtcblx0XHR9O1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5hZGp1c3QgPSBmdW5jdGlvbiAocmVsLGFkZCl7XG5cdFx0aWYoYWRkID09PSB1bmRlZmluZWQpIGFkZCA9IHRydWU7XG5cdFx0aWYgKHJlbC5lbmQoKSA8IHRoaXMuc3RhcnQoKSkge1xuXHRcdFx0YWRkID8gKHRoaXMubW92ZShyZWwuc2l6ZSgpKSkgOiAodGhpcy5tb3ZlKC1yZWwuc2l6ZSgpKSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChyZWwpe1xuXHRcdC8vIGlzIHRoaXMgZGVjZW50P1xuXHRcdHJlbCA9IFJlZ2lvbi5ub3JtYWxpemUocmVsKTtcblx0XHR2YXIgYSA9IE1hdGgubWF4KHRoaXMuc3RhcnQoKSxyZWwuc3RhcnQoKSk7XG5cdFx0dmFyIGIgPSBNYXRoLm1pbih0aGlzLmVuZCgpLHJlbC5lbmQoKSk7XG5cdFx0cmV0dXJuIGIgPj0gYTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucmVsYXRpdmVUbyA9IGZ1bmN0aW9uIChyZWwpe1xuXHRcdC8vIGNvdWxkIHVzZSBtb3ZlIGluc3RlYWRcblx0XHRyZXR1cm4gbmV3IFJlZ2lvbih0aGlzLl9hIC0gcmVsLnN0YXJ0KCksdGhpcy5fYiAtIHJlbC5zdGFydCgpLHRoaXMuX3Jvb3QsdGhpcy5fdmlldyk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChyZWdpb24pe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmVnaW9uKXtcblx0XHRyZXR1cm4gdGhpcy5zdGFydCgpID09IHJlZ2lvbi5zdGFydCgpICYmIHRoaXMuZW5kKCkgPT0gcmVnaW9uLmVuZCgpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5zYW1lID0gZnVuY3Rpb24gKHJlZ2lvbil7XG5cdFx0cmV0dXJuIHJlZ2lvbiAmJiByZWdpb24uYSgpID09IHRoaXMuYSgpICYmIHJlZ2lvbi5iKCkgPT0gdGhpcy5iKCk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5lbmQoKSAtIHRoaXMuc3RhcnQoKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChudW0pe1xuXHRcdGlmKG51bSA9PT0gdW5kZWZpbmVkKSBudW0gPSAxO1xuXHRcdHRoaXMuX2EgKz0gbnVtO1xuXHRcdHRoaXMuX2IgKz0gbnVtO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jb2xsYXBzZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5zaXplKCkgPT0gMDtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhID0gdGhpcy5fYSxiID0gdGhpcy5fYjtcblx0XHR0aGlzLl9hID0gYjtcblx0XHR0aGlzLl9iID0gYTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucmV2ZXJzZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYSA+IHRoaXMuX2I7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhID0gdGhpcy5zdGFydCgpO1xuXHRcdHZhciBiID0gdGhpcy5lbmQoKTtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9iID0gYjtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuY29sbGFwc2UgPSBmdW5jdGlvbiAoZm9yd2FyZCl7XG5cdFx0aWYoZm9yd2FyZCA9PT0gdW5kZWZpbmVkKSBmb3J3YXJkID0gdHJ1ZTtcblx0XHRpZiAoZm9yd2FyZCkge1xuXHRcdFx0dGhpcy5fYSA9IHRoaXMuX2IgPSB0aGlzLmVuZCgpO1xuXHRcdFx0Ly8gQGEgPSBAYlxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9iID0gdGhpcy5fYTtcblx0XHRcdHRoaXMuX2EgPSB0aGlzLl9iID0gdGhpcy5zdGFydCgpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBleHBhbmQgdG8gY2xvc2VzdCAvblxuXHRSZWdpb24ucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIChhdFN0YXJ0LGF0RW5kKXtcblx0XHRpZiAodGhpcy5iKCkgPCB0aGlzLmEoKSkge1xuXHRcdFx0dGhpcy5fYiArPSBhdFN0YXJ0O1xuXHRcdFx0dGhpcy5fYSArPSBhdEVuZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYSArPSBhdFN0YXJ0O1xuXHRcdFx0dGhpcy5fYiArPSBhdEVuZDtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmlldygpLnN1YnN0cih0aGlzKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gKFwiW1wiICsgKHRoaXMuX2EpICsgXCIsXCIgKyAodGhpcy5fYikgKyBcIl1cIik7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoaW5jbHVkZUVuZHMpe1xuXHRcdGlmKGluY2x1ZGVFbmRzID09PSB1bmRlZmluZWQpIGluY2x1ZGVFbmRzID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcy52aWV3KCkubm9kZXNJblJlZ2lvbih0aGlzLGluY2x1ZGVFbmRzKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucHJldk5vZGUgPSBmdW5jdGlvbiAocXVlcnkpe1xuXHRcdHZhciBub2RlcyA9IHRoaXMubm9kZXMoZmFsc2UpO1xuXHRcdHZhciBub2RlID0gbm9kZXMubGZ0O1xuXHRcdGlmICgocXVlcnkgaW5zdGFuY2VvZiBJbWJhLlNlbGVjdG9yKSB8fCAodHlwZW9mIHF1ZXJ5PT0nc3RyaW5nJ3x8cXVlcnkgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHR2YXIgJDE7d2hpbGUgKG5vZGUpe1xuXHRcdFx0XHRpZiAobm9kZS5tYXRjaGVzKHF1ZXJ5KSkgeyByZXR1cm4gbm9kZSB9O1xuXHRcdFx0XHRub2RlID0gKCQxID0gbm9kZSkgJiYgJDEuaXNMYXN0ICAmJiAgJDEuaXNMYXN0KCkgPyAobm9kZS5wYXJlbnQoKSkgOiAobnVsbCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUubmV4dE5vZGUgPSBmdW5jdGlvbiAocXVlcnkpe1xuXHRcdHZhciBub2RlcyA9IHRoaXMubm9kZXMoZmFsc2UpO1xuXHRcdHZhciBub2RlID0gbm9kZXMucmd0O1xuXHRcdGlmICgocXVlcnkgaW5zdGFuY2VvZiBJbWJhLlNlbGVjdG9yKSB8fCAodHlwZW9mIHF1ZXJ5PT0nc3RyaW5nJ3x8cXVlcnkgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHR2YXIgJDE7d2hpbGUgKG5vZGUpe1xuXHRcdFx0XHRpZiAobm9kZS5tYXRjaGVzKHF1ZXJ5KSkgeyByZXR1cm4gbm9kZSB9O1xuXHRcdFx0XHRub2RlID0gKCQxID0gbm9kZSkgJiYgJDEuaXNGaXJzdCAgJiYgICQxLmlzRmlyc3QoKSA/IChub2RlLnBhcmVudCgpKSA6IChudWxsKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uIChxdWVyeSl7XG5cdFx0dmFyIG5vZGVzID0gdGhpcy5ub2RlcyhmYWxzZSk7XG5cdFx0dmFyIG5vZGU7XG5cdFx0aWYgKG5vZGVzLmxmdCkge1xuXHRcdFx0bm9kZSA9IG5vZGVzLmxmdC51cChxdWVyeSk7XG5cdFx0fSBlbHNlIGlmIChub2Rlcy5yZ3QpIHtcblx0XHRcdG5vZGUgfHwgKG5vZGUgPSBub2Rlcy5yZ3QudXAocXVlcnkpKTtcblx0XHR9IGVsc2UgaWYgKG5vZGVzWzBdKSB7XG5cdFx0XHRub2RlIHx8IChub2RlID0gbm9kZXNbMF0ubm9kZS5jbG9zZXN0KHF1ZXJ5KSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Jvb3QuY29kZSgpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5zdGFydEF0TGluZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMubm9ybWFsaXplKCk7XG5cdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyKCk7XG5cdFx0dmFyIGEgPSB0aGlzLnN0YXJ0KCk7XG5cdFx0XG5cdFx0aWYgKGJ1ZmZlclthXSA9PSAnXFxuJyAmJiB0aGlzLnNpemUoKSA9PSAwKSB7XG5cdFx0XHRhLS07IC8vIGlmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIGEgbGluZVxuXHRcdH07XG5cdFx0XG5cdFx0d2hpbGUgKGEgPj0gMCAmJiBidWZmZXJbYV0gIT0gJ1xcbicpe1xuXHRcdFx0YS0tO1xuXHRcdH07XG5cdFx0dGhpcy5fYSA9IGE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmVuZEF0TGluZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMubm9ybWFsaXplKCk7XG5cdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyKCk7XG5cdFx0dmFyIGIgPSAodGhpcy5lbmQoKSAtIDEpO1xuXHRcdHdoaWxlIChiID49IDAgJiYgYnVmZmVyW2JdICYmIGJ1ZmZlcltiXSAhPSAnXFxuJyl7XG5cdFx0XHRiKys7XG5cdFx0fTtcblx0XHR0aGlzLl9iID0gYjtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuY2VsbCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnZpZXcoKS5fYnVmZmVyLmxvY1RvQ2VsbCh0aGlzLmEoKSk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnJvdyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmNlbGwoKVswXTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY2VsbCgpWzFdO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5wZWVrYmVoaW5kID0gZnVuY3Rpb24gKGxlbil7XG5cdFx0aWYobGVuID09PSB1bmRlZmluZWQpIGxlbiA9IDE7XG5cdFx0cmV0dXJuIGxlbiA9PSAxID8gKHRoaXMuYnVmZmVyKClbdGhpcy5zdGFydCgpIC0gMV0pIDogKHRoaXMuYnVmZmVyKCkuc3Vic3RyaW5nKHRoaXMuc3RhcnQoKSAtIGxlbix0aGlzLnN0YXJ0KCkpKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucGVla2FoZWFkID0gZnVuY3Rpb24gKGxlbil7XG5cdFx0aWYobGVuID09PSB1bmRlZmluZWQpIGxlbiA9IDE7XG5cdFx0cmV0dXJuIGxlbiA9PSAxID8gKHRoaXMuYnVmZmVyKClbdGhpcy5lbmQoKV0pIDogKHRoaXMuYnVmZmVyKCkuc3Vic3RyKHRoaXMuZW5kKCksbGVuKSk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRBdExpbmUoKS50ZXh0KCkubWF0Y2goL15cXG4/KFxcdCopLylbMV07XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoYmVmb3JlLGFmdGVyKXtcblx0XHRpZihiZWZvcmUgPT09IHVuZGVmaW5lZCkgYmVmb3JlID0gMDtcblx0XHRpZihhZnRlciA9PT0gdW5kZWZpbmVkKSBhZnRlciA9IDA7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoYmVmb3JlLGFmdGVyKS50ZXh0KCk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmxsb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4ge3N0YXJ0TGluZTogMCxzdGFydENvbDogMn07XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5hKCksdGhpcy5iKCldO1xuXHR9O1xuXHRyZXR1cm4gUmVnaW9uO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvcmVnaW9uLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHRcblx0dmFyIEtFWVdPUkRTID0gJ3ZhciBpZiBlbGlmIGVsc2UgZm9yIHdoaWxlIGRlZiBpbiBpc2Egd2hpbGUgdW50aWwgc3dpdGNoIHdoZW4gdGhlbiByZXR1cm4gY2xhc3MgdGFnIGxldCBkbyBhbmQgb3IgcHJvcCBhdHRyIGluIHByb3AnLnNwbGl0KCcgJyk7XG5cdHZhciBPUFMgPSAnKyAtICogLyA9ICsrIC0tID09ID09PSAhPSAhPT0gPiA8ID49IDw9ICYgJiYgfCB8fCBvciAuIDogPycuc3BsaXQoJyAnKTtcblx0XG5cdHZhciBXSElURVNQQUNFID0gL15bIFxcdFxcbl0rJC87XG5cdFxuXHRJTS5ITCA9IHtcblx0XHRuZXdsaW5lOiBcIjxiIGNsYXNzPSdfaW1uZXdsaW5lJz5cXG48L2I+XCIsXG5cdFx0c3BhY2U6IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIChcIjxiIGNsYXNzPSdfaW1zcGFjZSc+XCIgKyBtICsgXCI8L2I+XCIpOyB9LFxuXHRcdHRhYjogZnVuY3Rpb24obSkgeyByZXR1cm4gbmV3IEFycmF5KG0ubGVuZ3RoICsgMSkuam9pbihcIjxiIGNsYXNzPSdfaW10YWInPlxcdDwvYj5cIik7IH1cblx0fTtcblx0XG5cdFxuXHR2YXIgUmVnaW9uID0gcmVxdWlyZSgnLi9yZWdpb24nKS5SZWdpb247XG5cdHZhciBIaWdobGlnaHRlciA9IHJlcXVpcmUoJy4vY29yZS9oaWdobGlnaHRlcicpLkhpZ2hsaWdodGVyO1xuXHRcblx0dmFyIE1BVENIRVJTID0ge1xuXHRcdGtleXdvcmQ6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIEtFWVdPUkRTLmluZGV4T2YodikgPj0gMDsgfSxcblx0XHRzZWxmOiAvXih0aGlzfHNlbGYpJC8sXG5cdFx0Y29uc3Q6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuICgvXltBLVpdW1xcd1xcX10qJC8pLnRlc3Qodik7IH0sXG5cdFx0aXZhcjogZnVuY3Rpb24odikgeyByZXR1cm4gKC9eQFtcXHdcXF9dKyQvKS50ZXN0KHYpOyB9LFxuXHRcdGJvb2w6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuICgvXih0cnVlfHllc3xmYWxzZXxub3xudWxsfHVuZGVmaW5lZCkkLykudGVzdCh2KTsgfSxcblx0XHRpZGVudGlmaWVyOiAvXltcXCRhLXpfXVtcXHdcXF9cXCRdKihcXC1bXFwkXFx3XFxfXSspKiQvLFxuXHRcdGZsb2F0OiAvXlxcZCtcXC5cXGQrJC8sXG5cdFx0aW50OiAvXlxcZCskLyxcblx0XHRjb21tZW50OiAvXlxcIyhbIFxcdF1bXlxcbl0qKT8kL1xuXHR9O1xuXHRcblx0dmFyIE1PREVTID0ge1xuXHRcdGFsbDogT2JqZWN0LmtleXMoTUFUQ0hFUlMpXG5cdH07XG5cdFxuXHRcblx0XHRcblx0XHRTdHJpbmcucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uIChudW0pe1xuXHRcdFx0cmV0dXJuIG5ldyBBcnJheShudW0gKyAxKS5qb2luKHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0U3RyaW5nLnByb3RvdHlwZS5pbnMgPSBmdW5jdGlvbiAoc3RyLHJlZ2lvbil7XG5cdFx0XHR2YXIgdGV4dCA9IHRoaXMudG9TdHJpbmcoKTtcblx0XHRcdGlmIChyZWdpb24gPT0gJ2FwcGVuZCcpIHtcblx0XHRcdFx0cmV0dXJuIHRleHQgKyBzdHI7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZ2lvbiA9PSAncHJlcGVuZCcpIHtcblx0XHRcdFx0cmV0dXJuIFwiXCIgKyBzdHIgKyB0ZXh0O1xuXHRcdFx0fSBlbHNlIGlmIChyZWdpb24gaW5zdGFuY2VvZiBSZWdpb24pIHtcblx0XHRcdFx0cmV0dXJuIHRleHQuc3Vic3RyKDAscmVnaW9uLnN0YXJ0KCkpICsgc3RyICsgdGV4dC5zbGljZShyZWdpb24uZW5kKCkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIGlzV2hpdGVzcGFjZShzdHIpe1xuXHRcdHJldHVybiBXSElURVNQQUNFLnRlc3Qoc3RyKTtcblx0fTsgZXhwb3J0cy5pc1doaXRlc3BhY2UgPSBpc1doaXRlc3BhY2U7XG5cdFxuXHRJTS5udW0gPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gdGFnJC4kaW1udW0oKS5mbGFnKCdudW1iZXInKS5zZXRUZXh0KHZhbCkuZW5kKCk7XG5cdH07XG5cdFxuXHRJTS50YWIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJC4kaW10YWIoKS5zZXRUZXh0KCdcXHQnKS5lbmQoKTtcblx0fTtcblx0XG5cdElNLm5ld2xpbmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJC4kaW1uZXdsaW5lKCkuc2V0VGV4dCgnXFxuJykuZW5kKCk7XG5cdH07XG5cdFxuXHRJTS5vcCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHJldHVybiB0YWckLiRpbW9wKCkuZmxhZygnb3AnKS5zZXRUZXh0KHZhbCkuZW5kKCk7XG5cdH07XG5cdFxuXHRcblx0SU0udG9rID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0aWYgKHZhbCAmJiB2YWwuX2RvbSkgeyByZXR1cm4gdmFsIH07XG5cdFx0aWYgKHZhbC5tYXRjaChXSElURVNQQUNFKSkgeyByZXR1cm4gSU0ucGFyc2VXaGl0ZXNwYWNlKHZhbCkgfTtcblx0XHRpZiAoT1BTLmluZGV4T2YodmFsKSA+PSAwKSB7IHJldHVybiBJTS5vcCh2YWwpIH07IC8vIHNob3VsZCB1c2UgdG9rZW4gZGlyZWN0bHlcblx0XHQvLyByZXR1cm4gSU0ubnVtKHZhbCkgaWYgdmFsLm1hdGNoKC9eXFxkKyhcXC5cXGQrKT8kLykgIyBzaG91bGQgdXNlIHRva2VuIGRpcmVjdGx5XG5cdFx0cmV0dXJuIHRhZyQuJGltdG9rKCkuc2V0VGV4dCh2YWwpLmVuZCgpO1xuXHR9O1xuXHRcblx0SU0ucmF3ID0gZnVuY3Rpb24gKHZhbCxjdHgpe1xuXHRcdHJldHVybiB0YWckLiRpbXJhdygpLnNldFJhdyh2YWwpLmVuZCgpO1xuXHR9O1xuXHRcblx0SU0uaXNXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0cmV0dXJuIFdISVRFU1BBQ0UudGVzdCh2YWwpO1xuXHR9O1xuXHRcblx0SU0uaXNPcCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHJldHVybiBPUFMuaW5kZXhPZih2YWwpID49IDA7XG5cdH07XG5cdFxuXHRJTS5wYXJzZVdoaXRlc3BhY2UgPSBmdW5jdGlvbiAodGV4dCxyaWNoKXtcblx0XHRpZihyaWNoID09PSB1bmRlZmluZWQpIHJpY2ggPSB0cnVlO1xuXHRcdHZhciBobCA9IElNLkhMO1xuXHRcdFxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyhcXG58WyBdK3xbXFx0XSspL2csZnVuY3Rpb24obSxsKSB7XG5cdFx0XHRpZiAobCA9PSAnXFxuJykge1xuXHRcdFx0XHRyZXR1cm4gaGwubmV3bGluZSB8fCAnXFxuJztcblx0XHRcdH0gZWxzZSBpZiAobFswXSA9PSAnICcpIHtcblx0XHRcdFx0cmV0dXJuIGhsLnNwYWNlIGluc3RhbmNlb2YgRnVuY3Rpb24gPyAoaGwuc3BhY2UobCkpIDogKGwpO1xuXHRcdFx0fSBlbHNlIGlmIChsWzBdID09ICdcXHQnKSB7XG5cdFx0XHRcdHJldHVybiBobC50YWIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChobC50YWIobCkpIDogKGwpO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRcblx0XHRpZiAocmljaCAmJiB0ZXh0LmluZGV4T2YoJzwnKSA+PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGFnJC4kaW1mcmFnbWVudCgpLnNldENvbnRlbnQodGV4dCwwKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0ZXh0O1xuXHR9O1xuXHRcblx0SU0uaWRlbnRpZnkgPSBmdW5jdGlvbiAodmFsLG1vZGUpe1xuXHRcdGlmKG1vZGUgPT09IHVuZGVmaW5lZCkgbW9kZSA9ICdhbGwnO1xuXHRcdHZhciBydWxlcyA9IE1PREVTW21vZGVdO1xuXHRcdHZhciByZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHJ1bGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbmFtZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRuYW1lID0gYXJ5W2ldO1xuXHRcdFx0dmFyIHJ1bGUgPSBNQVRDSEVSU1tuYW1lXTtcblx0XHRcdFxuXHRcdFx0aWYgKHJ1bGUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRyZXMgPSBydWxlKHZhbCxtb2RlKTtcblx0XHRcdH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0XHRyZXMgPSBydWxlLnRlc3QodmFsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChyZXMpIHtcblx0XHRcdFx0cmV0dXJuIHJlcyA9PT0gdHJ1ZSA/IChuYW1lKSA6IChyZXMpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0SU0ucGFyc2UgPSBmdW5jdGlvbiAoY29kZSxjb250ZXh0KXtcblx0XHQvLyBkZWNpZGUgaWYgZnVsbD9cblx0XHQvLyBjb25zb2xlLmxvZyBcInBhcnNlIGNvZGUge2NvZGU6bGVuZ3RofSB7Y29kZS5zdWJzdHIoMCwyMCl9XCJcblx0XHRpZiAodHlwZW9mIGNvZGUgIT0gJ3N0cmluZycpIHsgcmV0dXJuIGNvZGUgfTtcblx0XHRcblx0XHRpZiAoV0hJVEVTUEFDRS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRyZXR1cm4gSU0ucGFyc2VXaGl0ZXNwYWNlKGNvZGUsZmFsc2UpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHdzID0gY29kZS5tYXRjaCgvXihbIFxcdF0qKShbXl0qPykoWyBcXHRdKikkLykgfHwgWycnLCcnLGNvZGUsJyddO1xuXHRcdHZhciBobDtcblx0XHRcblx0XHRpZiAod3NbMV0gfHwgd3NbM10pIHtcblx0XHRcdGNvZGUgPSB3c1syXTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBpZCA9IElNLmlkZW50aWZ5KGNvZGUpO1xuXHRcdFxuXHRcdGlmIChpZCkge1xuXHRcdFx0dmFyIHR5cCA9ICdzcGFuJztcblx0XHRcdHZhciBjbHMgPSBIaWdobGlnaHRlci5NYXBwaW5nW2lkXSB8fCBpZDsgLy8gdGhpcyBpcyB0aGUgaXNzdWUsIG5vP1xuXHRcdFx0XG5cdFx0XHRpZiAoY2xzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0dHlwID0gY2xzWzBdO1xuXHRcdFx0XHRjbHMgPSBjbHNbMV07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoIWNscy5tYXRjaCgvXFxiX1tcXHddLykpIHsgY2xzID0gJ19pbXRvayAnICsgY2xzIH07XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncGFyc2VkIGFzIHR5cGUnLGlkLGNsc1xuXHRcdFx0aGwgPSAnPCcgKyB0eXAgKyAnIGNsYXNzPVwiJyArIGNscyArICdcIj4nICsgY29kZSArICc8LycgKyB0eXAgKyAnPic7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIWhsKSB7XG5cdFx0XHRobCA9IEhpZ2hsaWdodGVyLmhpZ2hsaWdodChjb2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh3cykge1xuXHRcdFx0aGwgPSBJTS5wYXJzZVdoaXRlc3BhY2Uod3NbMV0sZmFsc2UpICsgaGwgKyBJTS5wYXJzZVdoaXRlc3BhY2Uod3NbM10sZmFsc2UpO1xuXHRcdH07XG5cdFx0aWYgKGhsKSB7XG5cdFx0XHRyZXR1cm4gaGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjb2RlO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0cmV0dXJuIElNLnRleHROb2RlcyA9IGZ1bmN0aW9uIChyb290LG1hcmspe1xuXHRcdC8vIGNvbnNvbGUudGltZSgndGV4dE5vZGVzMicpXG5cdFx0aWYobWFyayA9PT0gdW5kZWZpbmVkKSBtYXJrID0gZmFsc2U7XG5cdFx0cm9vdCA9IHJvb3QuX2RvbSB8fCByb290O1xuXHRcdHZhciBlbDtcblx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHR2YXIgcG9zID0gMDtcblx0XHR2YXIgd2FsayA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIocm9vdCxOb2RlRmlsdGVyLlNIT1dfVEVYVCxudWxsLGZhbHNlKTtcblx0XHRcblx0XHR3aGlsZSAoZWwgPSB3YWxrLm5leHROb2RlKCkpe1xuXHRcdFx0aWYgKG1hcmspIHtcblx0XHRcdFx0dmFyIGxlbiA9IGVsLmxlbmd0aDtcblx0XHRcdFx0ZWwuX2xvYyA9IHBvcztcblx0XHRcdFx0cG9zICs9IGxlbjtcblx0XHRcdH07XG5cdFx0XHRub2Rlcy5wdXNoKGVsKTtcblx0XHR9O1xuXHRcdHJldHVybiBub2Rlcztcblx0fTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2hlbHBlcnMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0XG5cdC8vIHZhciBpbWJhYyA9IGdsb2JhbC5JbWJhY1xuXHR2YXIgTGV4ZXIgPSByZXF1aXJlKCdpbWJhL3NyYy9jb21waWxlci9sZXhlcicpLkxleGVyO1xuXHRcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblx0XG5cdHZhciBOT0RFVFlQRSA9ICdiJztcblx0dmFyIEtFWVdPUkRTID0gW1xuXHRcdCdudWxsJywndGhpcycsXG5cdFx0J2RlbGV0ZScsJ3R5cGVvZicsJ2luJywnaW5zdGFuY2VvZicsXG5cdFx0J3Rocm93JywnYnJlYWsnLCdjb250aW51ZScsJ2RlYnVnZ2VyJyxcblx0XHQnaWYnLCdlbHNlJywnc3dpdGNoJywnZm9yJywnd2hpbGUnLCdkbycsJ3RyeScsJ2NhdGNoJywnZmluYWxseScsXG5cdFx0J2NsYXNzJywnZXh0ZW5kcycsJ3N1cGVyJywncmV0dXJuJyxcblx0XHQndW5kZWZpbmVkJywndGhlbicsJ3VubGVzcycsJ3VudGlsJywnbG9vcCcsJ29mJywnYnknLFxuXHRcdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHRcdCdhbmQnLCdvcicsJ2lzJywnaXNudCcsJ25vdCcsJ2lzYScsJ2Nhc2UnLCduaWwnXG5cdF07XG5cdFxuXHR2YXIgY2xhc3NlcyA9IHtcblx0XHQnKyc6ICdfaW1vcCBvcCBhZGQgbWF0aCcsXG5cdFx0JysrJzogJ19pbW9wIG9wIGluY3IgbWF0aCcsXG5cdFx0Jy0tJzogJ19pbW9wIG9wIGRlY3IgbWF0aCcsXG5cdFx0Jy0nOiAnX2ltb3Agb3Agc3ViIG1hdGgnLFxuXHRcdCc9JzogJ19pbW9wIG9wIGVxJyxcblx0XHQnLyc6ICdfaW1vcCBvcCBkaXYgbWF0aCcsXG5cdFx0JyonOiAnX2ltb3Agb3AgbXVsdCBtYXRoJyxcblx0XHQnPyc6ICdfaW1vcCBvcCB0ZXJuYXJ5Jyxcblx0XHQnLCc6ICdfaW1vcCBvcCBjb21tYScsXG5cdFx0JzonOiAnX2ltb3Agb3AgY29sb24nLFxuXHRcdCcuJzogJ19pbW9wIG9wIGRvdCcsXG5cdFx0Jy46JzogJ19pbW9wIG9wIGNkb3QnLFxuXHRcdCchJzogJ19pbW9wIG9wIHVuYXJ5Jyxcblx0XHQnPy4nOiAnX2ltb3Agb3AgcWRvdCcsXG5cdFx0J1snOiAnX2ltb3BlbiBzYiBzYmwnLFxuXHRcdCddJzogJ19pbWNsb3NlIHNiIHNicicsXG5cdFx0JygnOiAnX2ltb3BlbiByYiByYmwnLFxuXHRcdCcpJzogJ19pbWNsb3NlIHJiIHJicicsXG5cdFx0J3snOiAnX2ltb3BlbiBjYiBjYmwnLFxuXHRcdCd9JzogJ19pbWNsb3NlIGNiIGNicicsXG5cdFx0JyMnOiAnX2ltb3Agb3AgaGFzaCcsXG5cdFx0J2NhbGxfc3RhcnQnOiAnX2ltb3BlbiBjYWxsIHJiIHJibCcsXG5cdFx0J2NhbGxfZW5kJzogJ19pbWNsb3NlIGNhbGwgcmIgcmJyJyxcblx0XHQndGFnX3N0YXJ0JzogJ19pbW9wZW4gdGFnX29wZW4nLFxuXHRcdCd0YWdfZW5kJzogJ19pbWNsb3NlIHRhZ19jbG9zZScsXG5cdFx0XG5cdFx0J3RydWUnOiAnX2ltYm9vbCB0cnVlJyxcblx0XHQneWVzJzogJ19pbWJvb2wgdHJ1ZScsXG5cdFx0J2ZhbHNlJzogJ19pbWJvb2wgZmFsc2UnLFxuXHRcdCdubyc6ICdfaW1ib29sIGZhbHNlJyxcblx0XHRcblx0XHQne3snOiAnX2ltb3BlbicsXG5cdFx0J319JzogJ19pbWNsb3NlJyxcblx0XHRcblx0XHQnXCInOiAnZG91YmxlcXVvdGUnLFxuXHRcdFwiJ1wiOiAnc2luZ2xlcXVvdGUnLFxuXHRcdFxuXHRcdCdyZWdleCc6ICdfaW1yZWdleCByZWdleCcsXG5cdFx0J2lkZW50aWZpZXInOiAnX2ltdG9rIF9pbWlkZW50aWZpZXIgaWRlbnRpZmllcicsXG5cdFx0XG5cdFx0J2NvbXBvdW5kX2Fzc2lnbic6ICdvcCBhc3NpZ24gY29tcG91bmQnLFxuXHRcdCdzdHInOiAnX2ltc3RyIHN0cmluZycsXG5cdFx0J251bSc6ICdfaW1udW0gbnVtYmVyJyxcblx0XHQnc3RyaW5nJzogJ19pbXN0ciBzdHJpbmcnLFxuXHRcdCdudW1iZXInOiAnX2ltbnVtIG51bWJlcicsXG5cdFx0J21hdGgnOiAnX2ltb3Agb3AgbWF0aCcsXG5cdFx0J3VuYXJ5JzogJ19pbW9wIG9wIHVuYXJ5Jyxcblx0XHQnZm9yaW4nOiAna2V5d29yZCBpbicsXG5cdFx0J2Zvcm9mJzogJ2tleXdvcmQgb2YnLFxuXHRcdCdvd24nOiAna2V5d29yZCBvd24nLFxuXHRcdCdjb21wYXJlJzogJ19pbW9wIG9wIGNvbXBhcmUnLFxuXHRcdCdoZXJlY29tbWVudCc6ICdfaGVyZWNvbW1lbnQnLFxuXHRcdCdyZWxhdGlvbic6ICdrZXl3b3JkIHJlbGF0aW9uJyxcblx0XHQnZXhwb3J0JzogJ2tleXdvcmQgZXhwb3J0Jyxcblx0XHQnZ2xvYmFsJzogJ2tleXdvcmQgZ2xvYmFsJyxcblx0XHQnZXh0ZXJuJzogJ2tleXdvcmQgZ2xvYmFsJyxcblx0XHQnZXh0ZW5kJzogJ2tleXdvcmQgZXh0ZW5kJyxcblx0XHQncmVxdWlyZSc6ICdrZXl3b3JkIHJlcXVpcmUnLFxuXHRcdCdmcm9tJzogJ2tleXdvcmQgZnJvbScsXG5cdFx0J2xvZ2ljJzogJ2tleXdvcmQgbG9naWMnLFxuXHRcdCdwb3N0X2lmJzogJ2tleXdvcmQgaWYgcG9zdF9pZicsXG5cdFx0J3Bvc3RfZm9yJzogJ2tleXdvcmQgZm9yIHBvc3RfZm9yJyxcblx0XHQncHJvcCc6ICdrZXl3b3JkIHByb3AnLFxuXHRcdCdhdHRyJzogJ2tleXdvcmQgYXR0cicsXG5cdFx0XG5cdFx0J3NlbGVjdG9yX3N0YXJ0JzogJ19pbW9wZW4gX2ltc2Vsb3BlbiBzZWxlY3Rvcl9zdGFydCcsXG5cdFx0J3NlbGVjdG9yX2VuZCc6ICdfaW1jbG9zZSBfaW1zZWxjbG9zZSBzZWxlY3Rvcl9lbmQnLFxuXHRcdCdpbmRleF9zdGFydCc6ICdfaW1vcGVuIGluZGV4X3N0YXJ0Jyxcblx0XHQnaW5kZXhfZW5kJzogJ19pbWNsb3NlIGluZGV4X2VuZCcsXG5cdFx0J2Jsb2NrX3BhcmFtX3N0YXJ0JzogJ19pbW9wZW4nLFxuXHRcdCdibG9ja19wYXJhbV9lbmQnOiAnX2ltY2xvc2UnLFxuXHRcdFxuXHRcdCdzdHJpbmdfc3RhcnQnOiAnX2ltc3Ryc3RhcnQgc3RyaW5nX3N0YXJ0Jyxcblx0XHQnc3RyaW5nX2VuZCc6ICdfaW1zdHJlbmQgc3RyaW5nX2VuZCcsXG5cdFx0J25lb3N0cmluZyc6ICdfaW10b2sgX2ltbmVvc3RyaW5nJ1xuXHR9O1xuXHRcblx0dmFyIElOVEVSUE9MQVRJTkcgPSAnX2ltaXN0cmluZyc7XG5cdFxuXHR2YXIgT1BFTiA9IHtcblx0XHQndGFnX3N0YXJ0JzogJ19pbXRhZ25vZGUgdGFnbm9kZScsXG5cdFx0J2NhbGxfc3RhcnQnOiAnX2ltcGFyZW5zIGNhbGwnLFxuXHRcdCdzZWxlY3Rvcl9zdGFydCc6ICdfaW1zZWwgc2VsZWN0b3InLFxuXHRcdCdzdHJpbmdfc3RhcnQnOiAnX2ltaXN0cmluZycsXG5cdFx0J2luZGV4X3N0YXJ0JzogJ2luZGV4Jyxcblx0XHQnYmxvY2tfcGFyYW1fc3RhcnQnOiAnX2ltcGFpciBfaW1ibG9ja3BhcmFtcycsXG5cdFx0Ly8gJ2luZGVudCc6ICdfaW5kZW50J1xuXHRcdCcoJzogJ19pbXBhcmVucyBwYXJlbicsXG5cdFx0J3t7JzogJ19pbWlleHByJyxcblx0XHQneyc6ICdfaW1jdXJseSBjdXJseScsXG5cdFx0J1snOiAnX2ltc3F1YXJlIHNxdWFyZScsXG5cdFx0JyhcIic6ICdfaW1pc3RyaW5nJ1xuXHR9O1xuXHRcblx0XG5cdFxuXHR2YXIgQ0xPU0UgPSB7XG5cdFx0J3RhZ19lbmQnOiAndGFnJyxcblx0XHQnY2FsbF9lbmQnOiAnX2ltcGFyZW5zIGNhbGwnLFxuXHRcdCdzdHJpbmdfZW5kJzogJ19pbWlzdHJpbmcnLFxuXHRcdCdzZWxlY3Rvcl9lbmQnOiAnc2VsJyxcblx0XHQnaW5kZXhfZW5kJzogJ2luZGV4Jyxcblx0XHQnYmxvY2tfcGFyYW1fZW5kJzogJ19pbXBhaXIgX2ltYmxvY2twYXJhbXMnLFxuXHRcdCd9fSc6ICdfaW1pZXhwcicsXG5cdFx0JyknOiAncGFyZW4nLFxuXHRcdCddJzogJ3NxdWFyZScsXG5cdFx0J30nOiAnY3VybHknLFxuXHRcdCdcIiknOiAnc3RyaW5nJ1xuXHR9O1xuXHRcblx0dmFyIE9QUyA9ICcrIC0gKiAvID0gKysgLS0gPT0gPT09ICE9ICE9PSA+IDwgPj0gPD0gJiAmJiB8IHx8IG9yIC4gOiA/Jy5zcGxpdCgnICcpO1xuXHRcblx0dmFyIGhsbyA9IHtcblx0XHRuZXdsaW5lOiBcIjxiIGNsYXNzPSdfaW1uZXdsaW5lJz5cXG48L2I+XCIsXG5cdFx0c3BhY2U6IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIChcIjxiIGNsYXNzPSdfaW1zcGFjZSc+XCIgKyBtICsgXCI8L2I+XCIpOyB9LFxuXHRcdHRhYjogZnVuY3Rpb24obSkgeyByZXR1cm4gbmV3IEFycmF5KG0ubGVuZ3RoICsgMSkuam9pbihcIjxiIGNsYXNzPSdfaW10YWInPlxcdDwvYj5cIik7IH1cblx0fTtcblx0XG5cdGZ1bmN0aW9uIFN0YWNrKCl7XG5cdFx0dGhpcy5fc3RhY2sgPSBbXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0dGhpcy5fc3RhY2sucHVzaCh2YWwpO1xuXHRcdHRoaXMuX2N1cnJlbnQgPSB2YWw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGxlbiA9IHRoaXMuX3N0YWNrLnBvcCgpO1xuXHRcdHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9zdGFja1tsZW4gLSAxXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gVG9rZW4odHlwZSx2YWx1ZSxsaW5lLGxvYyxsZW4pe1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy5fbWV0YSA9IG51bGw7XG5cdFx0dGhpcy5fbGluZSA9IGxpbmUgfHwgMDtcblx0XHR0aGlzLl9jb2wgPSAtMTtcblx0XHR0aGlzLl9sb2MgPSBsb2MgfHwgMDtcblx0XHR0aGlzLl9sZW4gPSBsZW4gfHwgMDtcblx0XHR0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuXHRcdHRoaXMubmV3TGluZSA9IGZhbHNlO1xuXHRcdHRoaXMuc3BhY2VkID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdGV4cG9ydHMuVG9rZW4gPSBUb2tlbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRUb2tlbi5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLmxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9sb2M7XG5cdH07XG5cdFxuXHRUb2tlbi5wcm90b3R5cGUubGVuID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2xlbjtcblx0fTtcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gSGlnaGxpZ2h0ZXIoY29kZSx0b2tlbnMsYXN0LG8pe1xuXHRcdHZhciBobF87XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0dGhpcy5fY29kZSA9IGNvZGU7XG5cdFx0dGhpcy5fdG9rZW5zID0gdG9rZW5zO1xuXHRcdHRoaXMuX2FzdCA9IGFzdDtcblx0XHRcblx0XHRvLnJlbmRlciB8fCAoby5yZW5kZXIgPSB7fSk7XG5cdFx0by5obCB8fCAoby5obCA9IHt9KTtcblx0XHQoaGxfID0gby5obCkubmV3bGluZSB8fCAoaGxfLm5ld2xpbmUgPSAnPGIgY2xhc3M9XCJfblwiPlxcbjwvYj4nKTtcblx0XHR0aGlzLl9vcHRpb25zID0gbztcblx0XHRcblx0XHR0aGlzLl9vcHRpb25zLm5leHRWYXJDb3VudGVyIHx8ICh0aGlzLl9vcHRpb25zLm5leHRWYXJDb3VudGVyID0gMCk7XG5cdFx0dGhpcy5fdmFyUmVmcyA9IHt9O1xuXHRcdFxuXHRcdGlmIChvLm1vZGUgPT0gJ2Z1bGwnICYmICFhc3QpIHtcblx0XHRcdHRoaXMuX2FzdCA9IEltYmFjLnBhcnNlKHRoaXMuX3Rva2Vucyx7fSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuSGlnaGxpZ2h0ZXIgPSBIaWdobGlnaHRlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRIaWdobGlnaHRlci5NYXBwaW5nID0gY2xhc3Nlcztcblx0XG5cdEhpZ2hsaWdodGVyLmxvZ2dlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBWSUVXLmxvZ2dlcigpO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIudG9rZW5pemUgPSBmdW5jdGlvbiAoY29kZSxvKXtcblx0XHQvLyBjb25zb2xlLmxvZyAndG9rZW5pemUgdXNpbmcgbG9jYWwgbGV4ZXInXG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0aWYgKGdsb2JhbC5JbWJhYykge1xuXHRcdFx0cmV0dXJuIEltYmFjLnRva2VuaXplKGNvZGUsbyk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9sZXhlciB8fCAodGhpcy5fbGV4ZXIgPSBuZXcgTGV4ZXIoKSk7XG5cdFx0dGhpcy5fbGV4ZXIucmVzZXQoKTtcblx0XHRyZXR1cm4gdGhpcy5fbGV4ZXIudG9rZW5pemUoY29kZSxvKTtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLnJlY2xhc3NpZnkgPSBmdW5jdGlvbiAoZG9tbm9kZSx0eXBlLHRva2VuLG5ld0NvZGUsb2xkQ29kZSl7XG5cdFx0XG5cdFx0dHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblx0XHQvLyBjb25zb2xlLmxvZyAncmVjbGFzc2lmeSBub2RlIGFzIHR5cGUnLGRvbW5vZGUsdHlwZSx0b2tlblxuXHRcdHZhciBjbHMgPSBJTS5UeXBlc1t0eXBlXSB8fCBJbWJhLlRBR1NbKFwiaW1cIiArIHR5cGUpXSB8fCBJTS5UeXBlcy50b2tlbjtcblx0XHRcblx0XHR2YXIgbm9kZSA9IHRhZyR3cmFwKGRvbW5vZGUpO1xuXHRcdFxuXHRcdGlmIChub2RlIGluc3RhbmNlb2YgY2xzKSB7XG5cdFx0XHRyZXR1cm4gbm9kZS5yZXVzZSh0b2tlbixuZXdDb2RlLG9sZENvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGNscykge1xuXHRcdFx0bm9kZSA9IG5ldyBjbHMoZG9tbm9kZSkuc2V0dXAodG9rZW4sbmV3Q29kZSxvbGRDb2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0XG5cdEhpZ2hsaWdodGVyLm5lc3RUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLG9mZnNldCl7XG5cdFx0dmFyIHBhaXJpbmcgPSB7XG5cdFx0XHQnVEFHX1NUQVJUJzogJ1RBR19FTkQnLFxuXHRcdFx0J1NFTEVDVE9SX1NUQVJUJzogJ1NFTEVDVE9SX0VORCcsXG5cdFx0XHQnQ0FMTF9TVEFSVCc6ICdDQUxMX0VORCcsXG5cdFx0XHQnSU5ERVhfU1RBUlQnOiAnSU5ERVhfRU5EJyxcblx0XHRcdCdTVFJJTkdfU1RBUlQnOiAnU1RSSU5HX0VORCcsXG5cdFx0XHQnQkxPQ0tfUEFSQU1fU1RBUlQnOiAnQkxPQ0tfUEFSQU1fRU5EJyxcblx0XHRcdCd7eyc6ICd9fScsXG5cdFx0XHQneyc6ICd9Jyxcblx0XHRcdCdbJzogJ10nLFxuXHRcdFx0JygnOiAnKSdcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBuYW1pbmcgPSB7XG5cdFx0XHQnVEFHX1NUQVJUJzogJ3RhZ25vZGUnLFxuXHRcdFx0J1NFTEVDVE9SX1NUQVJUJzogJ3NlbGVjdG9yJyxcblx0XHRcdCdTVFJJTkdfU1RBUlQnOiAnaXN0cmluZycsXG5cdFx0XHQnQ0FMTF9TVEFSVCc6ICdwYXJlbnMnLFxuXHRcdFx0J0lOREVYX1NUQVJUJzogJ3NxdWFyZScsXG5cdFx0XHQnQkxPQ0tfUEFSQU1fU1RBUlQnOiAnYmxvY2twYXJhbXMnLFxuXHRcdFx0J3t7JzogJ2lleHByJyxcblx0XHRcdCd7JzogJ2N1cmx5Jyxcblx0XHRcdCdbJzogJ3NxdWFyZScsXG5cdFx0XHQnKCc6ICdwYXJlbnMnXG5cdFx0fTtcblx0XHRcblx0XHR2YXIgaWR4ID0gMDtcblx0XHRcblx0XHR2YXIgcm9vdCA9IHtcblx0XHRcdF9sb2M6IDAsXG5cdFx0XHRfb2Zmc2V0OiAwLFxuXHRcdFx0X2NoaWxkcmVuOiBbXVxuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHN0YWNrID0gW3Jvb3RdO1xuXHRcdHZhciBlbmRzID0gW107XG5cdFx0dmFyIG9mZnNldCA9IDA7XG5cdFx0XG5cdFx0dmFyIGxvYyx2YWwsdHlwLGN0eCx0b2s7XG5cdFx0XG5cdFx0d2hpbGUgKHRvayA9IHRva2Vuc1tpZHgrK10pe1xuXHRcdFx0bG9jID0gdG9rLl9sb2M7XG5cdFx0XHR2YWwgPSB0b2suX3ZhbHVlO1xuXHRcdFx0dHlwID0gdG9rLl90eXBlO1xuXHRcdFx0XG5cdFx0XHQvLyBub3JtYWxpemluZyBiZWNhdXNlIHdlIGRvbnQgcmV3cml0ZSB0b2tlbnMgKHNob3VsZCBzdGFydCB3aXRoIHRoYXQpXG5cdFx0XHRpZiAodHlwID09ICdJREVOVElGSUVSJyAmJiAodmFsID09ICdwcm9wJyB8fCB2YWwgPT0gJ2F0dHInKSkgeyB0eXAgPSB0b2suX3R5cGUgPSAnS0VZV09SRCcgfTsgLy8gbm90IGFsd2F5c1xuXHRcdFx0aWYgKHR5cCA9PSAnSU5ERVhfU1RBUlQnKSB7IHR5cCA9IHRvay5fdHlwZSA9ICdbJyB9O1xuXHRcdFx0aWYgKHR5cCA9PSAnSU5ERVhfRU5EJykgeyB0eXAgPSB0b2suX3R5cGUgPSAnXScgfTtcblx0XHRcdGlmICh0eXAgPT0gJ0NBTExfU1RBUlQnKSB7IHR5cCA9IHRvay5fdHlwZSA9ICcoJyB9O1xuXHRcdFx0aWYgKHR5cCA9PSAnQ0FMTF9FTkQnKSB7IHR5cCA9IHRvay5fdHlwZSA9ICcpJyB9O1xuXHRcdFx0XG5cdFx0XHRjdHggPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdFxuXHRcdFx0bG9jIC09IGN0eC5fb2Zmc2V0O1xuXHRcdFx0Ly8gb2Zmc2V0IHJlbGF0aXZlIHRvIGNvbnRleHRcblx0XHRcdHZhciBjbG9zZXIgPSBwYWlyaW5nW3R5cF07XG5cdFx0XHRcblx0XHRcdGlmIChjbG9zZXIpIHtcblx0XHRcdFx0dmFyIGdyb3VwID0gbmV3IFRva2VuKG5hbWluZ1t0eXBdLCcnLC0xLGxvYyk7XG5cdFx0XHRcdGdyb3VwLl9vZmZzZXQgPSBjdHguX29mZnNldCArIGxvYztcblx0XHRcdFx0b2Zmc2V0ICs9IGxvYztcblx0XHRcdFx0Z3JvdXAuX2NoaWxkcmVuID0gW107XG5cdFx0XHRcdGVuZHMucHVzaChjbG9zZXIpO1xuXHRcdFx0XHRzdGFjay5wdXNoKGdyb3VwKTtcblx0XHRcdFx0Y3R4Ll9jaGlsZHJlbi5wdXNoKGdyb3VwKTtcblx0XHRcdFx0Y3R4ID0gZ3JvdXA7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0b2suX2xvYyAtPSBjdHguX29mZnNldDtcblx0XHRcdFxuXHRcdFx0Ly8gdXBkYXRlIGxlbmd0aCBhdCBhbGwgdGltZXNcblx0XHRcdGlmICh0b2suX2xlbiA+PSAxKSB7XG5cdFx0XHRcdGN0eC5fY2hpbGRyZW4ucHVzaCh0b2spO1xuXHRcdFx0XHRjdHguX2xlbiA9IHRvay5fbG9jICsgdG9rLl9sZW47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZW5kc1tlbmRzLmxlbmd0aCAtIDFdID09IHR5cCkge1xuXHRcdFx0XHRlbmRzLnBvcCgpO1xuXHRcdFx0XHRjdHguX2xlbiA9IHRvay5fbG9jICsgdG9rLl9sZW47XG5cdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHQvLyBvZmZzZXQgLT0gY3R4LkBvZmZzZXRcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyAnY2hpbGRyZW4gaGVyZScscm9vdC5AY2hpbGRyZW5cblx0XHRyZXR1cm4gcm9vdC5fY2hpbGRyZW47XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci5ub3JtYWxpemVUb2tlbnMgPSBmdW5jdGlvbiAoY29kZSx0b2tlbnMsb2Zmc2V0KXtcblx0XHRpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkgb2Zmc2V0ID0gMDtcblx0XHR2YXIgaWR4ID0gMDtcblx0XHR2YXIgY2FyZXQgPSAwO1xuXHRcdHZhciBuZXckID0gW107XG5cdFx0dmFyIHRvayxuZXh0LHR5cCx2YWw7XG5cdFx0dmFyIGxvYyA9IDA7XG5cdFx0XG5cdFx0dmFyIHN0YWNrID0gbmV3IFN0YWNrKCk7XG5cdFx0XG5cdFx0dmFyIHdzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3dG9rID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGxvYyA+IGNhcmV0KXtcblx0XHRcdFx0dmFyIGNociA9IGNvZGVbY2FyZXRdO1xuXHRcdFx0XHRpZiAoY2hyID09ICdcXHQnKSB7XG5cdFx0XHRcdFx0bmV3dG9rID0gbmV3IFRva2VuKCd0YWInLGNociwtMSxjYXJldCwxKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJ1xcbicpIHtcblx0XHRcdFx0XHRuZXd0b2sgPSBuZXcgVG9rZW4oJ25ld2xpbmUnLGNociwtMSxjYXJldCwxKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJzsnKSB7XG5cdFx0XHRcdFx0bmV3dG9rID0gbmV3IFRva2VuKCdzZW1pY29sb24nLGNociwtMSxjYXJldCwxKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJyAnKSB7XG5cdFx0XHRcdFx0aWYgKG5ld3RvayAmJiBuZXd0b2suX3R5cGUgPT0gJ3doaXRlc3BhY2UnKSB7XG5cdFx0XHRcdFx0XHRuZXd0b2suX3ZhbHVlICs9ICcgJztcblx0XHRcdFx0XHRcdG5ld3Rvay5fbGVuICs9IDE7XG5cdFx0XHRcdFx0XHRjYXJldCsrO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRuZXd0b2sgPSBuZXcgVG9rZW4oJ3doaXRlc3BhY2UnLGNociwtMSxjYXJldCwxKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJyMnKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0bG9jID0gY2FyZXQ7XG5cdFx0XHRcdFx0dmFyIGNvbW1lbnQgPSAnJztcblx0XHRcdFx0XHR3aGlsZSAoY2FyZXQgPCBsb2MgJiYgY29kZVtjYXJldF0gIT0gJ1xcbicpe1xuXHRcdFx0XHRcdFx0Y29tbWVudCArPSBjb2RlW2NhcmV0XTtcblx0XHRcdFx0XHRcdGNhcmV0Kys7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRuZXckLnB1c2gobmV3IFRva2VuKCdjb21tZW50Jyxjb21tZW50LC0xLHN0YXJ0bG9jLGNvbW1lbnQubGVuZ3RoKSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3dG9rID0gbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNhcmV0Kys7XG5cdFx0XHRcdGlmIChuZXd0b2spIHsgbmV3JC5wdXNoKG5ld3RvaykgfTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc2tpcCA9IFsnVEVSTUlOQVRPUicsJ0lOREVOVCcsJ09VVERFTlQnLCcgJywnIFxcdCddO1xuXHRcdFxuXHRcdHdoaWxlICh0b2sgPSB0b2tlbnNbaWR4KytdKXtcblx0XHRcdG5leHQgPSB0b2tlbnNbaWR4XTtcblx0XHRcdGxvYyA9IHRvay5fbG9jO1xuXHRcdFx0dmFsID0gdG9rLl92YWx1ZTtcblx0XHRcdHR5cCA9IHRvay5fdHlwZTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cCA9PSAnIycgJiYgbmV4dCAmJiBuZXh0Ll90eXBlID09ICdJREVOVElGSUVSJykge1xuXHRcdFx0XHRuZXh0Ll90eXBlID0gJ0lEUkVGJztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0eXAgPT0gJygnICYmIHZhbCA9PSAnKFwiJykge1xuXHRcdFx0XHRzdGFjay5wdXNoKHZhbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoc2tpcC5pbmRleE9mKHR5cCkgPj0gMCkgeyBjb250aW51ZTsgfTtcblx0XHRcdFxuXHRcdFx0aWYgKGxvYyA+IGNhcmV0KSB7IHdzKCkgfTtcblx0XHRcdGNhcmV0ID0gdG9rLl9sb2MgKyB0b2suX2xlbjtcblx0XHRcdG5ldyQucHVzaCh0b2spO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gbW92ZSB0byB0aGUgZW5kIHRvIHBvc3NpYmx5IHBhcnNlIG1vcmUgd2hpdGVzcGFjZVxuXHRcdGxvYyA9IGNvZGUubGVuZ3RoO1xuXHRcdHdzKCk7XG5cdFx0Ly8gbm93IG5lc3QgdGhlIHRva2Vuc1xuXHRcdG5ldyQgPSB0aGlzLm5lc3RUb2tlbnMobmV3JCk7XG5cdFx0cmV0dXJuIG5ldyQ7XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci53aGl0ZXNwYWNlVG9Ub2tlbnMgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHR2YXIgdG9rO1xuXHRcdHZhciB0b2tlbnMgPSBbXTtcblx0XHR2YXIgY2FyZXQgPSAwO1xuXHRcdHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXHRcdFxuXHRcdHdoaWxlIChsZW4gPiBjYXJldCl7XG5cdFx0XHR2YXIgbG9jID0gY2FyZXQ7XG5cdFx0XHR2YXIgY2hyID0gc3RyW2NhcmV0KytdO1xuXHRcdFx0aWYgKGNociA9PSAnXFx0Jykge1xuXHRcdFx0XHR0b2tlbnMucHVzaCh0b2sgPSBuZXcgVG9rZW4oJ3RhYicsY2hyLC0xLGxvYywxKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnXFxuJykge1xuXHRcdFx0XHR0b2tlbnMucHVzaCh0b2sgPSBuZXcgVG9rZW4oJ25ld2xpbmUnLGNociwtMSxsb2MsMSkpO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJyAnKSB7XG5cdFx0XHRcdGlmICh0b2sgJiYgdG9rLl90eXBlID09ICd3aGl0ZXNwYWNlJykge1xuXHRcdFx0XHRcdHRvay5fdmFsdWUgKz0gJyAnO1xuXHRcdFx0XHRcdHRvay5fbGVuICs9IDE7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRva2Vucy5wdXNoKHRvayA9IG5ldyBUb2tlbignd2hpdGVzcGFjZScsY2hyLC0xLGxvYywxKSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRva2Vucztcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLnJlcGFyc2UgPSBmdW5jdGlvbiAobyl7XG5cdFx0XG5cdFx0dmFyICQxO1xuXHRcdGlmIChvIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0dmFyIGVsID0gdGFnJHdyYXAobyk7XG5cdFx0XHRpZiAoZWwpIHsgKCQxID0gZWwpICYmICQxLm11dGF0ZWQgICYmICAkMS5tdXRhdGVkKCkgfTtcblx0XHRcdHJldHVybjtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBub2RlcyA9IG8ubm9kZXM7XG5cdFx0dmFyIGNvZGUgPSBvLmNvZGU7XG5cdFx0dmFyIHRva2VucyA9IG8udG9rZW5zO1xuXHRcdC8vIHNob3VsZCB1c2UgYSBnbG9iYWwgbG9nZ2VyLWluc3RhbmNlXG5cdFx0dGhpcy5sb2dnZXIoKS5ncm91cENvbGxhcHNlZCgncmVwYXJzZSAlcycsSlNPTi5zdHJpbmdpZnkoY29kZSkpO1xuXHRcdFxuXHRcdGlmICh1dGlsLmlzV2hpdGVzcGFjZShjb2RlKSAmJiAhdG9rZW5zKSB7XG5cdFx0XHRjb25zb2xlLmxvZygndXNpbmcgd2hpdGVzcGFjZVRvVG9rZW5zJyk7XG5cdFx0XHR0b2tlbnMgPSB0aGlzLndoaXRlc3BhY2VUb1Rva2Vucyhjb2RlKTtcblx0XHR9O1xuXHRcdC8vIGxvZ2dlci5sb2cgbm9kZXMuc2xpY2Vcblx0XHQvLyBiaWcgaGFjayAtIGFkZGluZyBhIHNwYWNlIGF0IHRoZSBlbmQgdG8gY2xvc2UgdXAgc2VsZWN0b3JzXG5cdFx0Ly8gc2hvdWxkIHJhdGhlciBkcm9wIGlubGluZSBhbmQgbGV0IHRoZSBwYXJzZXIgcGFpciB1cCBsb29zZSBlbmRzP1xuXHRcdGlmICghdG9rZW5zKSB7XG5cdFx0XHR0b2tlbnMgPSB0aGlzLnRva2VuaXplKGNvZGUgKyAnICcse2lubGluZTogdHJ1ZSxzaWxlbnQ6IHRydWUscmV3cml0ZTogZmFsc2V9KTtcblx0XHRcdHRva2VucyA9IHRoaXMubm9ybWFsaXplVG9rZW5zKGNvZGUsdG9rZW5zKTtcblx0XHRcdHRoaXMubG9nZ2VyKCkubG9nKHRva2Vucy5zbGljZSgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMubG9nZ2VyKCkubG9nKG5vZGVzLnNsaWNlKCkpO1xuXHRcdHRoaXMuYXBwbHlUb2tlbnMoY29kZSx0b2tlbnMsbm9kZXMsby5uZXN0ZWQsby5wYXJlbnQpO1xuXHRcdHRoaXMubG9nZ2VyKCkuZ3JvdXBFbmQoKTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci5hcHBseVRva2VucyA9IGZ1bmN0aW9uIChjb2RlLHRva2Vucyxub2RlcyxuZXN0ZWQscGFyZW50KXtcblx0XHQvLyB3aGF0IGFib3V0IGxlbiBhbmQgbG9jIGZvciBpbm5lciBub2Rlcz8gU2hvdWxkIHRoaXMgYmUgc2V0IGFscmVhZHk/XG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBub2RlO1xuXHRcdHZhciBwcmV2Tm9kZTtcblx0XHRcblx0XHR2YXIgYWRkTm9kZSA9IGZ1bmN0aW9uKG5vZGVzLGluZGV4LGFmdGVyKSB7XG5cdFx0XHRzZWxmLmxvZ2dlcigpLmxvZygnYWRkTm9kZScsaW5kZXgpO1xuXHRcdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChOT0RFVFlQRSk7XG5cdFx0XHRcblx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRpZiAoYWZ0ZXIubmV4dFNpYmxpbmcpIHtcblx0XHRcdFx0XHRhZnRlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCxhZnRlci5uZXh0U2libGluZyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYWZ0ZXIucGFyZW50Tm9kZSkge1xuXHRcdFx0XHRcdGFmdGVyLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmIChwYXJlbnQpIHtcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdG5vZGVzLnNwbGljZShpbmRleCwwLGVsKTtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciByZW1vdmVOb2RlID0gZnVuY3Rpb24obm9kZXMsaW5kZXgpIHtcblx0XHRcdHNlbGYubG9nZ2VyKCkubG9nKCdyZW1vdmVOb2RlJyxpbmRleCk7XG5cdFx0XHR2YXIgZWwgPSBub2Rlc1tpbmRleF07XG5cdFx0XHRpZiAoZWwgJiYgZWwucGFyZW50Tm9kZSkge1xuXHRcdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbm9kZXMuc3BsaWNlKGluZGV4LDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHRvIHNldCB0aGUgbG9jYXRpb25zIG9mIHRoZSBub2Rlc1xuXHRcdHZhciBubG9jID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobm9kZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBub2RlMTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRub2RlMSA9IGFyeVtpXTtcblx0XHRcdG5vZGUxLl9sb2MgPSBubG9jO1xuXHRcdFx0bmxvYyArPSAobm9kZTEuX2xlbiA9IG5vZGUxLnRleHRDb250ZW50Lmxlbmd0aCk7XG5cdFx0fTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodG9rZW5zKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdG9rOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRvayA9IGFyeVtpXTtcblx0XHRcdG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdHZhciB0bG9jID0gdG9rLl9sb2M7XG5cdFx0XHRubG9jID0gbm9kZSAmJiBub2RlLl9sb2M7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChub2RlICYmIG5vZGUuX2xlbiA9PSAwKXtcblx0XHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coJ3JlbW92ZSBub2RlIGJlY2F1c2UgaXQgaXMgZW1wdHknLG5vZGUpO1xuXHRcdFx0XHRyZW1vdmVOb2RlKG5vZGVzLGkpO1xuXHRcdFx0XHRub2RlID0gbm9kZXNbaV07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdFx0Ly8gbmVlZCB0byBpbnNlcnQgbmV3IG5vZGUgaGVyZSAtIFxuXHRcdFx0XHRub2RlID0gYWRkTm9kZShub2RlcyxpLHByZXZOb2RlKTtcblx0XHRcdH0gZWxzZSBpZiAobmxvYyA+IHRsb2MpIHtcblx0XHRcdFx0bm9kZSA9IGFkZE5vZGUobm9kZXMsaSxwcmV2Tm9kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRsb2MgPiBubG9jKSB7XG5cdFx0XHRcdHJlbW92ZU5vZGUobm9kZXMsaSk7XG5cdFx0XHRcdG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG5lZWQgdG8gaW5zZXJ0IG5ldyBub2RlIGhlcmUgLSBcblx0XHRcdGlmICghbm9kZSkgeyBub2RlID0gYWRkTm9kZShub2RlcyxpLHByZXZOb2RlKSB9O1xuXHRcdFx0XG5cdFx0XHRpZiAodG9rLl90eXBlID09ICdTVFJJTkcnICYmIHRvay5fdmFsdWUubWF0Y2goL1xcwqd7M30vKSkge1xuXHRcdFx0XHRpZiAobmVzdGVkKSB7XG5cdFx0XHRcdFx0bmVzdGVkLnBvcCgpOyAvLyB0aGlzIGlzIHRoZSBub2RlXG5cdFx0XHRcdFx0cHJldk5vZGUgPSBub2RlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gd2FudCB0byBtYWtlIHN1cmUgaXQgaXMgYSBwbGFjZWhvbGRlciBmb3IgdGhlIHJpZ2h0IHRoaW5nXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgY3ZhbCA9IGNvZGUuc3Vic3RyKHRsb2MsdG9rLl9sZW4pO1xuXHRcdFx0dmFyIGNwcmV2ID0gbm9kZS50ZXh0Q29udGVudDtcblx0XHRcdHZhciBlbGVtZW50ID0gc2VsZi5yZWNsYXNzaWZ5KG5vZGUsdG9rLl90eXBlLHRvayxjdmFsLGNwcmV2KTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvay5fY2hpbGRyZW4pIHtcblx0XHRcdFx0dmFyIGNub2RlcyA9IG5vZGUuY2hpbGRyZW47XG5cdFx0XHRcdGlmIChjbm9kZXMubGVuZ3RoICYmIGNub2Rlcy5sZW5ndGggPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHNlbGYubG9nZ2VyKCkubG9nKCdyZXVzZSB0aGUgY25vZGVzKCEpJyxjbm9kZXMpO1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBzaG91bGQgcmVtb3ZlIHRoZSB0ZXh0Tm9kZXM/XG5cdFx0XHRcdFx0Ly8gY29udmVydCB0byBhcnJheVxuXHRcdFx0XHRcdGNub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNub2Rlcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coJ3dyb25nIGxlbmd0aCcpO1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBpdGVtcyA9IGl0ZXIkKG5vZGUuY2hpbGROb2RlcyksIGxlbl8gPSBpdGVtcy5sZW5ndGg7IGogPCBsZW5fOyBqKyspIHtcblx0XHRcdFx0XHRcdHNlbGYubG9nZ2VyKCkubG9nKGl0ZW1zW2pdKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIHNlZSBpZiBwcmV2aW91cyB2YWx1ZSBpcyB0aGUgc2FtZT8hXG5cdFx0XHRcdFx0bm9kZS5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0XHRjbm9kZXMgPSBbXTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGxldCBvID1cblx0XHRcdFx0Ly8gXHRjb2RlOiBjdmFsXG5cdFx0XHRcdC8vIFx0bm9kZXM6IGNub2Rlc1xuXHRcdFx0XHQvLyBcdHRva2VuczogdG9rLkBjaGlsZHJlbiAjIGFscmVhZHkgcGFyc2VkXG5cdFx0XHRcdC8vIFx0bmVzdGVkOiBuZXN0ZWRcblx0XHRcdFx0Ly8gXHRwYXJlbnQ6IG5vZGVcblx0XHRcdFx0XG5cdFx0XHRcdHNlbGYuYXBwbHlUb2tlbnMoY3ZhbCx0b2suX2NoaWxkcmVuLGNub2RlcyxuZXN0ZWQsbm9kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNwcmV2ICE9IGN2YWwpIHtcblx0XHRcdFx0bm9kZS50ZXh0Q29udGVudCA9IGN2YWw7IC8vIHRvay5AdmFsdWVcblx0XHRcdFx0ZWxlbWVudC5yZXBhcnNlZChjdmFsLGNwcmV2KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHByZXZOb2RlID0gbm9kZTtcblx0XHRcdC8vIHRvay5AbGVuXG5cdFx0fTtcblx0XHRcblx0XHQvLyBsb29wIHRocm91Z2ggdG9rZW5zPyBub3Qgc3VyZSBpdCB3b3JrcyBkdWUgdG8gdGhlIGlzc3VlcyB3aXRoIHdoaXRlc3BhY2U/XG5cdFx0XG5cdFx0Ly8gcmVtb3ZlIGV4Y2VzcyBvcmlnaW5hbCBub2Rlc1xuXHRcdHdoaWxlIChub2Rlcy5sZW5ndGggPiB0b2tlbnMubGVuZ3RoKXtcblx0XHRcdG5vZGUgPSBub2Rlcy5wb3AoKTtcblx0XHRcdGlmIChub2RlLnBhcmVudE5vZGUpIHsgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpIH07XG5cdFx0XHQvLyBub2RlLm9ycGhhbml6ZVxuXHRcdH07XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHQvLyBzaG91bGQgbGF0ZXIgYmUgYWJsZSB0byByZWhpZ2hsaWdodCB0aGUgdGV4dCAvIG5vZGVzIGRpcmVjdGx5IGluc3RlYWRcblx0Ly8gcHJvYmFibHkgbW9yZSBlZmZpY2llbnRcblx0SGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGNvZGUsbyl7XG5cdFx0Ly8gZmlyc3QgdHJ5IHRvIHBhcnNlIGV0Yz9cblx0XHQvLyBjb3VsZCBoaWdobGlnaHQgc2luZ2xlIHdvcmRzIGFzIHdlbGxcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRvLmhsIHx8IChvLmhsID0gaGxvKTtcblx0XHR2YXIgdG9rZW5zID0gby50b2tlbnMgfHwgbnVsbDtcblx0XHRcblx0XHRpZiAoIXRva2Vucykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gc3VyZSB3ZSBkb250IHdhbnQgdG8gcmV3cml0ZSBhbnl0aGluZyBub3c/XG5cdFx0XHRcdGlmIChERUJVRykgeyBjb25zb2xlLnRpbWUoJ3Rva2VuaXplJykgfTtcblx0XHRcdFx0aWYgKG8ubW9kZSA9PSAnZnVsbCcpIHtcblx0XHRcdFx0XHR0b2tlbnMgPSB0aGlzLnRva2VuaXplKGNvZGUse30pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRva2VucyA9IHRoaXMudG9rZW5pemUoY29kZSx7aW5saW5lOiB0cnVlLHNpbGVudDogdHJ1ZSxyZXdyaXRlOiBmYWxzZX0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoREVCVUcpIHsgY29uc29sZS50aW1lRW5kKCd0b2tlbml6ZScpIH07XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGlmIChlLl9vcHRpb25zKSB7IHRva2VucyA9IGUuX29wdGlvbnMudG9rZW5zIH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGhsID0gbmV3IHRoaXMoY29kZSx0b2tlbnMsbnVsbCxvKTtcblx0XHRyZXR1cm4gaGwucHJvY2VzcygpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRIaWdobGlnaHRlci5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb3B0aW9uczsgfVxuXHRIaWdobGlnaHRlci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vcHRpb25zID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRIaWdobGlnaHRlci5wcm90b3R5cGUudmFyUmVmID0gZnVuY3Rpb24gKHZhcmlhYmxlKXtcblx0XHR2YXIgJDE7XG5cdFx0dmFyIGkgPSB0aGlzLl9vcHRpb25zLm5lc3RlZDtcblx0XHR2YXIgcGZ4ID0gaSA/ICgnaScpIDogKCcnKTtcblx0XHRyZXR1cm4gdGhpcy5fdmFyUmVmc1soJDEgPSB2YXJpYWJsZS5fcmVmKV0gfHwgKHRoaXMuX3ZhclJlZnNbJDFdID0gKHBmeCArIHRoaXMuX29wdGlvbnMubmV4dFZhckNvdW50ZXIrKykpO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIucHJvdG90eXBlLnBhcnNlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHQvLyBwYXJzaW5nIGNvbW1lbnRzXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBobCA9IHRoaXMuX29wdGlvbnMuaGw7XG5cdFx0dmFyIGNvbW1lbnRzID0gW107XG5cdFx0XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvKFxcIykoW15cXG5dKikvZyxmdW5jdGlvbihtLHMscSkge1xuXHRcdFx0aWYgKHNlbGYuX29wdGlvbnMucmVuZGVyLmNvbW1lbnQpIHtcblx0XHRcdFx0bSA9IHNlbGYuX29wdGlvbnMucmVuZGVyLmNvbW1lbnQoJ2NvbW1lbnQnLG0pO1xuXHRcdFx0fTtcblx0XHRcdHZhciBuciA9IGNvbW1lbnRzLnB1c2goKFwiPFwiICsgTk9ERVRZUEUgKyBcIiBjbGFzcz0nX2ltIF9pbWNvbW1lbnQnPlwiICsgbSArIFwiPC9cIiArIE5PREVUWVBFICsgXCI+XCIpKTtcblx0XHRcdHJldHVybiAoXCIkXCIgKyAobnIgLSAxKSArIFwiJFwiKTtcblx0XHR9KTtcblx0XHRcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXFxufFsgXSt8W1xcdF0rKS9nLGZ1bmN0aW9uKG0sbCkge1xuXHRcdFx0aWYgKGwgPT0gJ1xcbicpIHtcblx0XHRcdFx0cmV0dXJuIGhsLm5ld2xpbmUgfHwgJ1xcbic7XG5cdFx0XHR9IGVsc2UgaWYgKGxbMF0gPT0gJyAnKSB7XG5cdFx0XHRcdHJldHVybiBobC5zcGFjZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gKGhsLnNwYWNlKGwpKSA6IChsKTtcblx0XHRcdH0gZWxzZSBpZiAobFswXSA9PSAnXFx0Jykge1xuXHRcdFx0XHRyZXR1cm4gaGwudGFiIGluc3RhbmNlb2YgRnVuY3Rpb24gPyAoaGwudGFiKGwpKSA6IChsKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKGNvbW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFwkKFxcZCspXFwkL2csZnVuY3Rpb24obSxucikge1xuXHRcdFx0XHRyZXR1cm4gY29tbWVudHNbcGFyc2VJbnQobnIpXTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0b2s7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMoKTtcblx0XHRcblx0XHR2YXIgc3RyID0gdGhpcy5fY29kZTtcblx0XHR2YXIgcG9zID0gdGhpcy5fdG9rZW5zLmxlbmd0aDtcblx0XHRcblx0XHR2YXIgc3RhY2sgPSBbXTtcblx0XHR2YXIgZGVwdGggPSAwO1xuXHRcdHZhciBjb250ZXh0ID0gbnVsbDtcblx0XHRcblx0XHR2YXIgcHVzaCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0c3RhY2sucHVzaChjdHgpO1xuXHRcdFx0ZGVwdGggPSBzdGFjay5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gY29udGV4dCA9IHN0YWNrW2RlcHRoIC0gMV07XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgcG9wID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdGRlcHRoID0gc3RhY2subGVuZ3RoO1xuXHRcdFx0cmV0dXJuIGNvbnRleHQgPSBzdGFja1tkZXB0aCAtIDFdO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2FzdCAmJiB0aGlzLl9hc3QuYW5hbHl6ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fYXN0LmFuYWx5emUoe30pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRudWxsO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciByZXMgPSBcIlwiO1xuXHRcdHBvcyA9IDA7XG5cdFx0dmFyIGNhcmV0ID0gMDtcblx0XHRcblx0XHR2YXIgb3BlbixjbG9zZTtcblx0XHRcblx0XHR3aGlsZSAodG9rID0gdGhpcy5fdG9rZW5zW3BvcysrXSl7XG5cdFx0XHR2YXIgbmV4dCA9IHRoaXMuX3Rva2Vuc1twb3NdO1xuXHRcdFx0XG5cdFx0XHRpZiAoY2xvc2UpIHtcblx0XHRcdFx0aWYgKCEoby5pbm5lciAmJiBkZXB0aCA9PSAxKSkgeyByZXMgKz0gKFwiPC9cIiArIE5PREVUWVBFICsgXCI+XCIpIH07XG5cdFx0XHRcdGNsb3NlID0gbnVsbDtcblx0XHRcdFx0cG9wKCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgdHlwID0gdG9rLl90eXBlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgbG9jID0gdG9rLl9sb2M7XG5cdFx0XHR2YXIgdmFsID0gdG9rLl92YWx1ZTtcblx0XHRcdHZhciBsZW4gPSB0b2suX2xlbjsgLy8gb3IgdG9rLkB2YWx1ZTpsZW5ndGhcblx0XHRcdHZhciBtZXRhID0gdG9rLl9tZXRhO1xuXHRcdFx0dmFyIGF0dHJzID0gJyc7XG5cdFx0XHRcblx0XHRcdGlmIChsb2MgPiBjYXJldCkge1xuXHRcdFx0XHR2YXIgYWRkID0gc3RyLnN1YnN0cmluZyhjYXJldCxsb2MpO1xuXHRcdFx0XHRpZiAoY29udGV4dCAhPSBJTlRFUlBPTEFUSU5HKSB7IGFkZCA9IHRoaXMucGFyc2VXaGl0ZXNwYWNlKGFkZCkgfTtcblx0XHRcdFx0cmVzICs9IGFkZDtcblx0XHRcdFx0Y2FyZXQgPSBsb2M7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjbG9zZSA9IENMT1NFW3R5cF07XG5cdFx0XHRcblx0XHRcdGlmIChvcGVuID0gT1BFTlt0eXBdKSB7XG5cdFx0XHRcdC8vIG9wZW4gPSBPUEVOW3ZhbF0gfHwgb3BlblxuXHRcdFx0XHRwdXNoKG9wZW4pO1xuXHRcdFx0XHRpZiAoIShvLmlubmVyICYmIGRlcHRoID09IDEpKSB7IHJlcyArPSAoXCI8XCIgKyBOT0RFVFlQRSArIFwiIGNsYXNzPSdcIiArIG9wZW4gKyBcIic+XCIpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobGVuID09IDAgfHwgdHlwID09ICd0ZXJtaW5hdG9yJyB8fCB0eXAgPT0gJ2luZGVudCcgfHwgdHlwID09ICdvdXRkZW50Jykge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0b2suX2NvbCA9PSAtMSAmJiB0b2suX2xvYyA8PSAwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIG5vZGUgPSBOT0RFVFlQRTtcblx0XHRcdHZhciBjb250ZW50ID0gc3RyLnN1YnN0cihsb2MsbGVuKTtcblx0XHRcdC8vIHRlbXBvcmFyeSB3b3JrYXJvdW5kIHVudGlsIHdlIHJlZGVmaW5lIHJlcXVpcmUgYXMgYW4gaWRlbnRpZmllclxuXHRcdFx0aWYgKHR5cCA9PSAnY29uc3QnICYmIGNvbnRlbnQgPT0gJ3JlcXVpcmUnKSB7XG5cdFx0XHRcdHR5cCA9ICdyZXF1aXJlJztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dmFyIGNscyA9IGNsYXNzZXNbdHlwXSB8fCB0eXA7XG5cdFx0XHRcblx0XHRcdGlmIChjbHMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRub2RlID0gY2xzWzBdO1xuXHRcdFx0XHRjbHMgPSBjbHNbMV07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjbHMgPSBjbHMuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XG5cdFx0XHRpZiAoS0VZV09SRFMuaW5kZXhPZih0eXApID49IDApIHtcblx0XHRcdFx0Y2xzLnVuc2hpZnQoJ2tleXdvcmQnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNhcmV0ID0gbG9jICsgbGVuO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwID09ICdpZGVudGlmaWVyJykge1xuXHRcdFx0XHRpZiAoY29udGVudFswXSA9PSAnIycpIHtcblx0XHRcdFx0XHRjbHMucHVzaCgnaWRyZWYnKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChtZXRhKSB7XG5cdFx0XHRcdFx0aWYgKG1ldGEudHlwZSA9PSAnQUNDRVNTJykgeyBjbHMucHVzaCgnYWNjZXNzJykgfTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjb250ZW50ID09ICdsb2cnKSB7XG5cdFx0XHRcdFx0Y2xzLnB1c2goJ2xvZycpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvay5fdmFyaWFibGUpIHtcblx0XHRcdFx0XG5cdFx0XHRcdGNscy5wdXNoKCdsdmFyJyk7XG5cdFx0XHRcdHZhciByZWYgPSB0aGlzLnZhclJlZih0b2suX3ZhcmlhYmxlKTtcblx0XHRcdFx0YXR0cnMgKz0gKFwiIGVyZWY9J3ZcIiArIHJlZiArIFwiJ1wiKTtcblx0XHRcdFx0Ly8gY2xzLnB1c2goXCJyZWYtXCIrcmVmKVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cCA9PSAnaGVyZWNvbW1lbnQnKSB7XG5cdFx0XHRcdHZhciBlbmQgPSAoXCI8XCIgKyBOT0RFVFlQRSArIFwiPiMjIzwvXCIgKyBOT0RFVFlQRSArIFwiPlwiKTtcblx0XHRcdFx0Y29udGVudCA9IGVuZCArIGNvbnRlbnQuc2xpY2UoMywtMykgKyBlbmQ7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmIChjb250ZW50Lm1hdGNoKC9eWydcIl0/XFwuP1xcLlxcLy8pKSB7IGNscy5wdXNoKCdwYXRobmFtZScpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgY2xzdHIgPSBjbHMuam9pbihcIiBcIik7XG5cdFx0XHRpZiAoIWNsc3RyLm1hdGNoKC9cXGJcXF8vKSkgeyBjbHN0ciA9ICdfaW10b2sgJyArIGNsc3RyIH07XG5cdFx0XHRyZXMgKz0gKFwiPFwiICsgbm9kZSArIFwiIGNsYXNzPSdcIiArIGNsc3RyICsgXCInXCIpICsgYXR0cnMgKyBcIj5cIiArIGNvbnRlbnQgKyAoXCI8L1wiICsgbm9kZSArIFwiPlwiKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNsb3NlIGFmdGVyP1xuXHRcdGlmIChjbG9zZSkge1xuXHRcdFx0cmVzICs9IChcIjwvXCIgKyBOT0RFVFlQRSArIFwiPlwiKTtcblx0XHRcdGNsb3NlID0gbnVsbDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChjYXJldCA8IHN0ci5sZW5ndGggLSAxKSB7XG5cdFx0XHRhZGQgPSBzdHIuc2xpY2UoY2FyZXQpO1xuXHRcdFx0aWYgKGNvbnRleHQgIT0gSU5URVJQT0xBVElORykgeyBhZGQgPSB0aGlzLnBhcnNlV2hpdGVzcGFjZShhZGQpIH07XG5cdFx0XHRyZXMgKz0gYWRkO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX3Rva2Vucy5sZW5ndGggPT0gMCkge1xuXHRcdFx0cmVzID0gdGhpcy5fY29kZTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiByZXM7XG5cdH07XG5cdHJldHVybiBIaWdobGlnaHRlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlnaGxpZ2h0ZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBoZWxwZXIgZm9yIHN1YmNsYXNzaW5nXG5cdGZ1bmN0aW9uIHN1YmNsYXNzJChvYmosc3VwKSB7XG5cdFx0Zm9yICh2YXIgayBpbiBzdXApIHtcblx0XHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIG9ialtrXSA9IHN1cFtrXTtcblx0XHR9O1xuXHRcdC8vIG9iai5fX3N1cGVyX18gPSBzdXA7XG5cdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHR9O1xuXHRcblx0dmFyIEFMTF9LRVlXT1JEUztcblx0XG5cdHZhciBUID0gcmVxdWlyZSgnLi90b2tlbicpO1xuXHR2YXIgVG9rZW4gPSBULlRva2VuO1xuXHRcblx0dmFyIHJ3ID0gcmVxdWlyZSgnLi9yZXdyaXRlcicpO1xuXHR2YXIgUmV3cml0ZXIgPSBydy5SZXdyaXRlcjtcblx0dmFyIElOVkVSU0VTID0gcncuSU5WRVJTRVM7XG5cdFxuXHR2YXIgSyA9IDA7XG5cdFxuXHR2YXIgRVJSID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblx0XG5cdC8vIENvbnN0YW50c1xuXHQvLyAtLS0tLS0tLS1cblx0XG5cdC8vIEtleXdvcmRzIHRoYXQgSW1iYSBzaGFyZXMgaW4gY29tbW9uIHdpdGggSmF2YVNjcmlwdC5cblx0dmFyIEpTX0tFWVdPUkRTID0gW1xuXHRcdCd0cnVlJywnZmFsc2UnLCdudWxsJywndGhpcycsXG5cdFx0J2RlbGV0ZScsJ3R5cGVvZicsJ2luJywnaW5zdGFuY2VvZicsXG5cdFx0J3Rocm93JywnYnJlYWsnLCdjb250aW51ZScsJ2RlYnVnZ2VyJyxcblx0XHQnaWYnLCdlbHNlJywnc3dpdGNoJywnZm9yJywnd2hpbGUnLCdkbycsJ3RyeScsJ2NhdGNoJywnZmluYWxseScsXG5cdFx0J2NsYXNzJywnZXh0ZW5kcycsJ3N1cGVyJywncmV0dXJuJ1xuXHRdO1xuXHRcblx0Ly8gbmV3IGNhbiBiZSB1c2VkIGFzIGEga2V5d29yZCBpbiBpbWJhLCBzaW5jZSBvYmplY3QgaW5pdGluZyBpcyBkb25lIHRocm91Z2hcblx0Ly8gTXlPYmplY3QubmV3LiBuZXcgaXMgYSB2ZXJ5IHVzZWZ1bCB2YXJuYW1lLlxuXHRcblx0Ly8gV2Ugd2FudCB0byB0cmVhdCByZXR1cm4gbGlrZSBhbnkgcmVndWxhciBjYWxsIGZvciBub3dcblx0Ly8gTXVzdCBiZSBjYXJlZnVsIHRvIHRocm93IHRoZSBleGNlcHRpb25zIGluIEFTVCwgc2luY2UgdGhlIHBhcnNlclxuXHQvLyB3b250XG5cdFxuXHQvLyBJbWJhLW9ubHkga2V5d29yZHMuIHZhciBzaG91bGQgbW92ZSB0byBKU19LZXl3b3Jkc1xuXHQvLyBzb21lIHdvcmRzIChsaWtlIHRva2lkKSBzaG91bGQgYmUgY29udGV4dC1zcGVjaWZpY1xuXHR2YXIgSU1CQV9LRVlXT1JEUyA9IFtcblx0XHQndW5kZWZpbmVkJywndGhlbicsJ3VubGVzcycsJ3VudGlsJywnbG9vcCcsJ29mJywnYnknLFxuXHRcdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnXG5cdF07XG5cdFxuXHR2YXIgSU1CQV9DT05URVhUVUFMX0tFWVdPUkRTID0gWydleHRlbmQnLCdzdGF0aWMnLCdsb2NhbCcsJ2V4cG9ydCcsJ2dsb2JhbCcsJ3Byb3AnXTtcblx0XG5cdHZhciBJTUJBX0FMSUFTX01BUCA9IHtcblx0XHQnYW5kJzogJyYmJyxcblx0XHQnb3InOiAnfHwnLFxuXHRcdCdpcyc6ICc9PScsXG5cdFx0J2lzbnQnOiAnIT0nLFxuXHRcdCdub3QnOiAnIScsXG5cdFx0J3llcyc6ICd0cnVlJyxcblx0XHQnbm8nOiAnZmFsc2UnLFxuXHRcdCdpc2EnOiAnaW5zdGFuY2VvZicsXG5cdFx0J2Nhc2UnOiAnc3dpdGNoJyxcblx0XHQnbmlsJzogJ251bGwnXG5cdH07XG5cdFxuXHR2YXIgSU1CQV9BTElBU0VTID0gT2JqZWN0LmtleXMoSU1CQV9BTElBU19NQVApO1xuXHRJTUJBX0tFWVdPUkRTID0gSU1CQV9LRVlXT1JEUy5jb25jYXQoSU1CQV9BTElBU0VTKTtcblx0XG5cdC8vIEZpeGVkQXJyYXkgZm9yIHBlcmZvcm1hbmNlXG5cdC8vIHZhciBBTExfS0VZV09SRFMgPSBKU19LRVlXT1JEUy5jb25jYXQoSU1CQV9LRVlXT1JEUylcblx0bW9kdWxlLmV4cG9ydHMuQUxMX0tFWVdPUkRTID0gQUxMX0tFWVdPUkRTID0gW1xuXHRcdCd0cnVlJywnZmFsc2UnLCdudWxsJywndGhpcycsXG5cdFx0J2RlbGV0ZScsJ3R5cGVvZicsJ2luJywnaW5zdGFuY2VvZicsXG5cdFx0J3Rocm93JywnYnJlYWsnLCdjb250aW51ZScsJ2RlYnVnZ2VyJyxcblx0XHQnaWYnLCdlbHNlJywnc3dpdGNoJywnZm9yJywnd2hpbGUnLCdkbycsJ3RyeScsJ2NhdGNoJywnZmluYWxseScsXG5cdFx0J2NsYXNzJywnZXh0ZW5kcycsJ3N1cGVyJywncmV0dXJuJyxcblx0XHQndW5kZWZpbmVkJywndGhlbicsJ3VubGVzcycsJ3VudGlsJywnbG9vcCcsJ29mJywnYnknLFxuXHRcdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHRcdCdhbmQnLCdvcicsJ2lzJywnaXNudCcsJ25vdCcsJ3llcycsJ25vJywnaXNhJywnY2FzZScsJ25pbCdcblx0XTtcblx0XG5cdC8vIFRoZSBsaXN0IG9mIGtleXdvcmRzIHRoYXQgYXJlIHJlc2VydmVkIGJ5IEphdmFTY3JpcHQsIGJ1dCBub3QgdXNlZCwgb3IgYXJlXG5cdC8vIHVzZWQgYnkgSW1iYSBpbnRlcm5hbGx5LiBXZSB0aHJvdyBhbiBlcnJvciB3aGVuIHRoZXNlIGFyZSBlbmNvdW50ZXJlZCxcblx0Ly8gdG8gYXZvaWQgaGF2aW5nIGEgSmF2YVNjcmlwdCBlcnJvciBhdCBydW50aW1lLiAgIyAndmFyJywgJ2xldCcsIC0gbm90IGluc2lkZSBoZXJlXG5cdHZhciBSRVNFUlZFRCA9IFsnY2FzZScsJ2RlZmF1bHQnLCdmdW5jdGlvbicsJ3ZvaWQnLCd3aXRoJywnY29uc3QnLCdlbnVtJywnbmF0aXZlJ107XG5cdHZhciBTVFJJQ1RfUkVTRVJWRUQgPSBbJ2Nhc2UnLCdmdW5jdGlvbicsJ3ZvaWQnLCdjb25zdCddO1xuXHRcblx0Ly8gVGhlIHN1cGVyc2V0IG9mIGJvdGggSmF2YVNjcmlwdCBrZXl3b3JkcyBhbmQgcmVzZXJ2ZWQgd29yZHMsIG5vbmUgb2Ygd2hpY2ggbWF5XG5cdC8vIGJlIHVzZWQgYXMgaWRlbnRpZmllcnMgb3IgcHJvcGVydGllcy5cblx0dmFyIEpTX0ZPUkJJRERFTiA9IEpTX0tFWVdPUkRTLmNvbmNhdChSRVNFUlZFRCk7XG5cdFxuXHR2YXIgTUVUSE9EX0lERU5USUZJRVIgPSAvXigoKFtcXHgyM10/W1xcJEEtWmEtel9cXHg3Zi1cXHVmZmZmXVskXFwtXFx3XFx4N2YtXFx1ZmZmZl0qKShbXFw9XT8pKXwoPD0+fFxcfCg/IVtcXHw9XSkpKS87XG5cdC8vIHJlbW92ZWQgfj18fnwgfCYoPyFbJj1dKVxuXHRcblx0Ly8gVG9rZW4gbWF0Y2hpbmcgcmVnZXhlcy5cblx0Ly8gYWRkZWQgaHlwaGVucyB0byBpZGVudGlmaWVycyBub3cgLSB0byB0ZXN0XG5cdHZhciBJREVOVElGSUVSID0gL14oKFxcJHxAQHxAfFxcIylbXFx3QS1aYS16X1xcLVxceDdmLVxcdWZmZmZdWyRcXHdcXHg3Zi1cXHVmZmZmXSooXFwtWyRcXHdcXHg3Zi1cXHVmZmZmXSspKnxbJEEtWmEtel9dWyRcXHdcXHg3Zi1cXHVmZmZmXSooXFwtWyRcXHdcXHg3Zi1cXHVmZmZmXSspKikoW15cXG5cXFNdKjooPyFbXFwqXFw9OiRcXHdcXHg3Zi1cXHVmZmZmXSkpPy87XG5cdFxuXHR2YXIgT0JKRUNUX0tFWSA9IC9eKChcXCR8QEB8QHwpWyRBLVphLXpfXFx4N2YtXFx1ZmZmZlxcLV1bJFxcd1xceDdmLVxcdWZmZmZcXC1dKikoW15cXG5cXFNcXHNdKjooPyFbXFwqXFw9OiRcXHdcXHg3Zi1cXHVmZmZmXSkpLztcblx0XG5cdHZhciBUQUcgPSAvXihcXDx8JSkoPz1bQS1aYS16XFwjXFwuXFx7XFxAXFw+XSkvO1xuXHRcblx0dmFyIFRBR19UWVBFID0gL14oXFx3W1xcd1xcZF0qOik/KFxcd1tcXHdcXGRdKikoLVtcXHdcXGRdKykqLztcblx0dmFyIFRBR19JRCA9IC9eIygoXFx3W1xcd1xcZF0qKSgtW1xcd1xcZF0rKSopLztcblx0XG5cdHZhciBUQUdfQVRUUiA9IC9eKFtcXC5cXDpdP1tcXHdcXF9dKyhbXFwtXFw6XVtcXHddKykqKShcXHMpKlxcPS87XG5cdFxuXHR2YXIgU0VMRUNUT1IgPSAvXihbJVxcJF17MSwyfSkoW1xcKFxcd1xcI1xcLlxcW10pLztcblx0dmFyIFNFTEVDVE9SX1BBUlQgPSAvXihcXCN8XFwufDp8OjopPyhbXFx3XSsoXFwtW1xcd10rKSopLztcblx0dmFyIFNFTEVDVE9SX0NPTUJJTkFUT1IgPSAvXiAoXFwrfFxcPnxcXH4pKlxccyooPz1bXFx3XFwuXFwjXFw6XFx7XFwqXFxbXSkvO1xuXHRcblx0dmFyIFNFTEVDVE9SX1BTRVVET19DTEFTUyA9IC9eKDo6PykoW1xcd10rKFxcLVtcXHddKykqKS87XG5cdHZhciBTRUxFQ1RPUl9BVFRSX09QID0gL14oXFwkPXxcXH49fFxcXj18XFwqPXxcXHw9fD18XFwhPSkvO1xuXHR2YXIgU0VMRUNUT1JfQVRUUiA9IC9eXFxbKFtcXHdcXF9cXC1dKykoXFwkPXxcXH49fFxcXj18XFwqPXxcXHw9fD18XFwhPSkvO1xuXHRcblx0dmFyIFNZTUJPTCA9IC9eXFw6KCgoW1xcKlxcQCRcXHdcXHg3Zi1cXHVmZmZmXSspKyhbXFwtXFxcXC9cXFxcXFw6XVtcXHdcXHg3Zi1cXHVmZmZmXSspKil8PT18XFw8PVxcPnxcXFtcXF18XFxbXFxdXFw9fFxcKnxbXFxcXC8sXFxcXF0pLztcblx0XG5cdFxuXHR2YXIgTlVNQkVSID0gL14weFtcXGRhLWZdK3xeMGJbMDFdK3xeXFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/L2k7XG5cdFxuXHR2YXIgSEVSRURPQyA9IC9eKFwiXCJcInwnJycpKFtcXHNcXFNdKj8pKD86XFxuW15cXG5cXFNdKik/XFwxLztcblx0XG5cdHZhciBPUEVSQVRPUiA9IC9eKD86Wy09XT0+fD09PXwtPnwhPT18Wy0rKlxcLyU8PiZ8XiE/PV09fD08fD4+Pj0/fChbLSs6XSlcXDF8KFsmfDw+XSlcXDI9P3xcXD9cXC58XFw/XFw6fFxcLnsyLDN9fFxcKig/PVthLXpBLVpcXF9dKSkvO1xuXHRcblx0Ly8gRklYTUUgc3BsYXQgc2hvdWxkIG9ubHkgYmUgYWxsb3dlZCB3aGVuIHRoZSBwcmV2aW91cyB0aGluZyBpcyBzcGFjZWQgb3IgaW5zaWRlIGNhbGw/XG5cdFxuXHR2YXIgV0hJVEVTUEFDRSA9IC9eW15cXG5cXFNdKy87XG5cdFxuXHR2YXIgQ09NTUVOVCA9IC9eIyMjKFteI11bXFxzXFxTXSo/KSg/OiMjI1teXFxuXFxTXSp8KD86IyMjKT8kKS87XG5cdC8vIENPTU1FTlQgICAgPSAvXiMjIyhbXiNdW1xcc1xcU10qPykoPzojIyNbXlxcblxcU10qfCg/OiMjIyk/JCl8Xig/OlxccyooI1xccy4qfCNcXHMqJCkpKy9cblx0dmFyIElOTElORV9DT01NRU5UID0gL14oXFxzKikoI1sgXFx0XFwhXSguKil8I1sgXFx0XT8oPz1cXG58JCkpKy87XG5cdFxuXHR2YXIgQ09ERSA9IC9eWy09XT0+Lztcblx0XG5cdHZhciBNVUxUSV9ERU5UID0gL14oPzpcXG5bXlxcblxcU10qKSsvO1xuXHRcblx0dmFyIFNJTVBMRVNUUiA9IC9eJ1teXFxcXCddKig/OlxcXFwuW15cXFxcJ10qKSonLztcblx0XG5cdHZhciBKU1RPS0VOID0gL15gW15cXFxcYF0qKD86XFxcXC5bXlxcXFxgXSopKmAvO1xuXHRcblx0Ly8gUmVnZXgtbWF0Y2hpbmctcmVnZXhlcy5cblx0dmFyIFJFR0VYID0gL14oXFwvKD8hW1xccz1dKVteW1xcL1xcblxcXFxdKig/Oig/OlxcXFxbXFxzXFxTXXxcXFtbXlxcXVxcblxcXFxdKig/OlxcXFxbXFxzXFxTXVteXFxdXFxuXFxcXF0qKSpdKVteW1xcL1xcblxcXFxdKikqXFwvKShbaW1neV17MCw0fSkoPyFcXHcpLztcblx0XG5cdHZhciBIRVJFR0VYID0gL15cXC97M30oW1xcc1xcU10rPylcXC97M30oW2ltZ3ldezAsNH0pKD8hXFx3KS87XG5cdFxuXHR2YXIgSEVSRUdFWF9PTUlUID0gL1xccysoPzojLiopPy9nO1xuXHRcblx0Ly8gVG9rZW4gY2xlYW5pbmcgcmVnZXhlcy5cblx0dmFyIE1VTFRJTElORVIgPSAvXFxuL2c7XG5cdFxuXHR2YXIgSEVSRURPQ19JTkRFTlQgPSAvXFxuKyhbXlxcblxcU10qKS9nO1xuXHRcblx0dmFyIEhFUkVET0NfSUxMRUdBTCA9IC9cXCpcXC8vO1xuXHRcblx0Ly8gZXhwZW5zaXZlP1xuXHR2YXIgTElORV9DT05USU5VRVIgPSAvXlxccyooPzosfFxcPz9cXC4oPyFbLlxcZF0pfDo6KS87XG5cdFxuXHR2YXIgVFJBSUxJTkdfU1BBQ0VTID0gL1xccyskLztcblx0XG5cdHZhciBDT05TVF9JREVOVElGSUVSID0gL15bQS1aXS87XG5cdFxuXHR2YXIgQVJHVkFSID0gL15cXCRcXGQkLztcblx0XG5cdC8vIENvbXBvdW5kIGFzc2lnbm1lbnQgdG9rZW5zLlxuXHR2YXIgQ09NUE9VTkRfQVNTSUdOID0gWyctPScsJys9JywnLz0nLCcqPScsJyU9JywnfHw9JywnJiY9JywnPz0nLCc8PD0nLCc+Pj0nLCc+Pj49JywnJj0nLCdePScsJ3w9JywnPTwnXTtcblx0XG5cdC8vIFVuYXJ5IHRva2Vucy5cblx0dmFyIFVOQVJZID0gWychJywnficsJ05FVycsJ1RZUEVPRicsJ0RFTEVURSddO1xuXHRcblx0Ly8gTG9naWNhbCB0b2tlbnMuXG5cdHZhciBMT0dJQyA9IFsnJiYnLCd8fCcsJyYnLCd8JywnXiddO1xuXHRcblx0Ly8gQml0LXNoaWZ0aW5nIHRva2Vucy5cblx0dmFyIFNISUZUID0gWyc8PCcsJz4+JywnPj4+J107XG5cdFxuXHQvLyBDb21wYXJpc29uIHRva2Vucy5cblx0dmFyIENPTVBBUkUgPSBbJz09PScsJyE9PScsJz09JywnIT0nLCc8JywnPicsJzw9JywnPj0nLCc9PT0nLCchPT0nXTtcblx0XG5cdC8vIE92ZXJpZGVhYmxlIG1ldGhvZHNcblx0dmFyIE9QX01FVEhPRFMgPSBbJzw9PicsJzw8JywnLi4nXTtcblx0XG5cdC8vIE1hdGhlbWF0aWNhbCB0b2tlbnMuXG5cdHZhciBNQVRIID0gWycqJywnLycsJyUnLCfiiKonLCfiiKknLCfiiJonXTtcblx0XG5cdC8vIFJlbGF0aW9uYWwgdG9rZW5zIHRoYXQgYXJlIG5lZ2F0YWJsZSB3aXRoIGBub3RgIHByZWZpeC5cblx0dmFyIFJFTEFUSU9OID0gWydJTicsJ09GJywnSU5TVEFOQ0VPRicsJ0lTQSddO1xuXHRcblx0Ly8gQm9vbGVhbiB0b2tlbnMuXG5cdHZhciBCT09MID0gWydUUlVFJywnRkFMU0UnLCdOVUxMJywnVU5ERUZJTkVEJ107XG5cdFxuXHQvLyBPdXIgbGlzdCBpcyBzaG9ydGVyLCBkdWUgdG8gc2Fucy1wYXJlbnRoZXNlcyBtZXRob2QgY2FsbHMuXG5cdHZhciBOT1RfUkVHRVggPSBbJ05VTUJFUicsJ1JFR0VYJywnQk9PTCcsJ1RSVUUnLCdGQUxTRScsJysrJywnLS0nLCddJ107XG5cdFxuXHQvLyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgbm90IHNwYWNlZCwgdGhlcmUgYXJlIG1vcmUgcHJlY2VkaW5nIHRva2VucyB0aGF0XG5cdC8vIGZvcmNlIGEgZGl2aXNpb24gcGFyc2U6XG5cdHZhciBOT1RfU1BBQ0VEX1JFR0VYID0gWydOVU1CRVInLCdSRUdFWCcsJ0JPT0wnLCdUUlVFJywnRkFMU0UnLCcrKycsJy0tJywnXScsJyknLCd9JywnVEhJUycsJ1NFTEYnLCdJREVOVElGSUVSJywnU1RSSU5HJ107XG5cdFxuXHQvLyBUb2tlbnMgd2hpY2ggY291bGQgbGVnaXRpbWF0ZWx5IGJlIGludm9rZWQgb3IgaW5kZXhlZC4gQW4gb3BlbmluZ1xuXHQvLyBwYXJlbnRoZXNlcyBvciBicmFja2V0IGZvbGxvd2luZyB0aGVzZSB0b2tlbnMgd2lsbCBiZSByZWNvcmRlZCBhcyB0aGUgc3RhcnRcblx0Ly8gb2YgYSBmdW5jdGlvbiBpbnZvY2F0aW9uIG9yIGluZGV4aW5nIG9wZXJhdGlvbi5cblx0Ly8gcmVhbGx5PyFcblx0XG5cdHZhciBVTkZJTklTSEVEID0gWydcXFxcJywnLicsJz8uJywnPzonLCdVTkFSWScsJ01BVEgnLCcrJywnLScsJ1NISUZUJywnUkVMQVRJT04nLCdDT01QQVJFJywnTE9HSUMnLCdDT01QT1VORF9BU1NJR04nLCdUSFJPVycsJ0VYVEVORFMnXTtcblx0XG5cdC8vIH0gc2hvdWxkIG5vdCBiZSBjYWxsYWJsZSBhbnltb3JlISEhICd9JywgJzo6Jyxcblx0dmFyIENBTExBQkxFID0gWydJREVOVElGSUVSJywnU1RSSU5HJywnUkVHRVgnLCcpJywnXScsJ1RISVMnLCdTVVBFUicsJ1RBR19FTkQnLCdJVkFSJywnR1ZBUicsJ1NFTEYnLCdDT05TVCcsJ05FVycsJ0FSR1ZBUicsJ1NZTUJPTCcsJ1JFVFVSTiddO1xuXHQvLyB2YXIgSU5ERVhBQkxFID0gQ0FMTEFCTEUuY29uY2F0ICdOVU1CRVInLCAnQk9PTCcsICdUQUdfU0VMRUNUT1InLCAnSURSRUYnLCAnQVJHVU1FTlRTJywnfScgIyBhcmUgYm9vbGVhbnMgaW5kZXhhYmxlPyByZWFsbHk/XG5cdC8vIG9wdGltaXplIGZvciBGaXhlZEFycmF5XG5cdHZhciBJTkRFWEFCTEUgPSBbXG5cdFx0J0lERU5USUZJRVInLCdTVFJJTkcnLCdSRUdFWCcsJyknLCddJywnVEhJUycsJ1NVUEVSJywnVEFHX0VORCcsJ0lWQVInLCdHVkFSJywnU0VMRicsJ0NPTlNUJywnTkVXJywnQVJHVkFSJywnU1lNQk9MJywnUkVUVVJOJyxcblx0XHQnTlVNQkVSJywnQk9PTCcsJ1RBR19TRUxFQ1RPUicsJ0lEUkVGJywnQVJHVU1FTlRTJywnfScsJ1RBR19UWVBFJ1xuXHRdO1xuXHRcblx0dmFyIEdMT0JBTF9JREVOVElGSUVSUyA9IFsnZ2xvYmFsJywnZXhwb3J0cycsJ3JlcXVpcmUnXTtcblx0XG5cdC8vIFRva2VucyB0aGF0LCB3aGVuIGltbWVkaWF0ZWx5IHByZWNlZGluZyBhIGBXSEVOYCwgaW5kaWNhdGUgdGhhdCB0aGUgYFdIRU5gXG5cdC8vIG9jY3VycyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLiBXZSBkaXNhbWJpZ3VhdGUgdGhlc2UgZnJvbSB0cmFpbGluZyB3aGVucyB0b1xuXHQvLyBhdm9pZCBhbiBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIuXG5cdHZhciBMSU5FX0JSRUFLID0gWydJTkRFTlQnLCdPVVRERU5UJywnVEVSTUlOQVRPUiddO1xuXHRcblx0XG5cdGZ1bmN0aW9uIExleGVyRXJyb3IobWVzc2FnZSxmaWxlLGxpbmUpe1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0dGhpcy5maWxlID0gZmlsZTtcblx0XHR0aGlzLmxpbmUgPSBsaW5lO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRzdWJjbGFzcyQoTGV4ZXJFcnJvcixTeW50YXhFcnJvcik7XG5cdGV4cG9ydHMuTGV4ZXJFcnJvciA9IExleGVyRXJyb3I7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gbGFzdChhcnJheSxiYWNrKXtcblx0XHRpZihiYWNrID09PSB1bmRlZmluZWQpIGJhY2sgPSAwO1xuXHRcdHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSBiYWNrIC0gMV07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBjb3VudChzdHIsc3Vic3RyKXtcblx0XHRyZXR1cm4gc3RyLnNwbGl0KHN1YnN0cikubGVuZ3RoIC0gMTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHJlcGVhdFN0cmluZyhzdHIsdGltZXMpe1xuXHRcdHZhciByZXMgPSAnJztcblx0XHR3aGlsZSAodGltZXMgPiAwKXtcblx0XHRcdGlmICh0aW1lcyAlIDIgPT0gMSkge1xuXHRcdFx0XHRyZXMgKz0gc3RyO1xuXHRcdFx0fTtcblx0XHRcdHN0ciArPSBzdHI7XG5cdFx0XHR0aW1lcyA+Pj0gMTtcblx0XHR9O1xuXHRcdHJldHVybiByZXM7XG5cdH07XG5cdFxuXHR2YXIgdFQgPSBULnR5cDtcblx0dmFyIHRWID0gVC52YWw7XG5cdHZhciB0VHMgPSBULnNldFR5cDtcblx0dmFyIHRWcyA9IFQuc2V0VmFsO1xuXHRcblx0Ly8gVGhlIExleGVyIGNsYXNzIHJlYWRzIGEgc3RyZWFtIG9mIEltYmEgYW5kIGRpdnZpZXMgaXQgdXAgaW50byB0b2tpZGdlZFxuXHQvLyB0b2tlbnMuIFNvbWUgcG90ZW50aWFsIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hciBoYXMgYmVlbiBhdm9pZGVkIGJ5XG5cdC8vIHB1c2hpbmcgc29tZSBleHRyYSBzbWFydHMgaW50byB0aGUgTGV4ZXIuXG5cdFxuXHQvLyBCYXNlZCBvbiB0aGUgb3JpZ2luYWwgbGV4ZXIuY29mZmVlIGZyb20gQ29mZmVlU2NyaXB0XG5cdGZ1bmN0aW9uIExleGVyKCl7XG5cdFx0dGhpcy5yZXNldCgpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkxleGVyID0gTGV4ZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0TGV4ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fY29kZSA9IG51bGw7XG5cdFx0dGhpcy5fY2h1bmsgPSBudWxsOyAvLyBUaGUgcmVtYWluZGVyIG9mIHRoZSBzb3VyY2UgY29kZS5cblx0XHR0aGlzLl9vcHRzID0gbnVsbDtcblx0XHRcblx0XHR0aGlzLl9pbmRlbnQgPSAwOyAvLyBUaGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC5cblx0XHR0aGlzLl9pbmRlYnQgPSAwOyAvLyBUaGUgb3Zlci1pbmRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHR0aGlzLl9vdXRkZWJ0ID0gMDsgLy8gVGhlIHVuZGVyLW91dGRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHRcblx0XHR0aGlzLl9pbmRlbnRzID0gW107IC8vIFRoZSBzdGFjayBvZiBhbGwgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbHMuXG5cdFx0dGhpcy5fZW5kcyA9IFtdOyAvLyBUaGUgc3RhY2sgZm9yIHBhaXJpbmcgdXAgdG9rZW5zLlxuXHRcdHRoaXMuX2NvbnRleHRzID0gW107IC8vIHN1cGxlbWVudHMgQGVuZHNcblx0XHR0aGlzLl9zY29wZXMgPSBbXTtcblx0XHR0aGlzLl9uZXh0U2NvcGUgPSBudWxsOyAvLyB0aGUgc2NvcGUgdG8gYWRkIG9uIHRoZSBuZXh0IGluZGVudFxuXHRcdC8vIHNob3VsZCByYXRoZXIgbWFrZSBpdCBsaWtlIGEgc3RhdGVtYWNoaW5lIHRoYXQgbW92ZXMgZnJvbSBDTEFTU19ERUYgdG8gQ0xBU1NfQk9EWSBldGNcblx0XHQvLyBUaGluZ3Mgc2hvdWxkIGNvbXBpbGUgZGlmZmVyZW50bHkgd2hlbiB5b3UgYXJlIGluIGEgQ0xBU1NfQk9EWSB0aGFuIHdoZW4gaW4gYSBERUZfQk9EWSsrXG5cdFx0XG5cdFx0dGhpcy5fdG9rZW5zID0gW107IC8vIFN0cmVhbSBvZiBwYXJzZWQgdG9rZW5zIGluIHRoZSBmb3JtIGBbJ1RZUEUnLCB2YWx1ZSwgbGluZV1gLlxuXHRcdHRoaXMuX3NlZW5Gb3IgPSBmYWxzZTtcblx0XHR0aGlzLl9sb2MgPSAwO1xuXHRcdHRoaXMuX2xvY09mZnNldCA9IDA7XG5cdFx0XG5cdFx0dGhpcy5fZW5kID0gbnVsbDtcblx0XHR0aGlzLl9jaGFyID0gbnVsbDtcblx0XHR0aGlzLl9icmlkZ2UgPSBudWxsO1xuXHRcdHRoaXMuX2xhc3QgPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RUeXAgPSAnJztcblx0XHR0aGlzLl9sYXN0VmFsID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5qaXNvbkJyaWRnZSA9IGZ1bmN0aW9uIChqaXNvbil7XG5cdFx0cmV0dXJuIHRoaXMuX2JyaWRnZSA9IHtcblx0XHRcdGxleDogVC5sZXgsXG5cdFx0XHRzZXRJbnB1dDogZnVuY3Rpb24odG9rZW5zKSB7XG5cdFx0XHRcdHRoaXMudG9rZW5zID0gdG9rZW5zO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wb3MgPSAwO1xuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0dXBjb21pbmdJbnB1dDogZnVuY3Rpb24oKSB7IHJldHVybiBcIlwiOyB9XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoY29kZSxvKXtcblx0XHRcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRpZiAoY29kZS5sZW5ndGggPT0gMCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCFvLmlubGluZSkge1xuXHRcdFx0aWYgKFdISVRFU1BBQ0UudGVzdChjb2RlKSkge1xuXHRcdFx0XHRjb2RlID0gKFwiXFxuXCIgKyBjb2RlKTtcblx0XHRcdFx0aWYgKGNvZGUubWF0Y2goL15cXHMqJC9nKSkgeyByZXR1cm4gW10gfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcci9nLCcnKS5yZXBsYWNlKC9bXFx0IF0rJC9nLCcnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX2xhc3QgPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RUeXAgPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RWYWwgPSBudWxsO1xuXHRcdFxuXHRcdHRoaXMuX2NvZGUgPSBjb2RlO1xuXHRcdHRoaXMuX29wdHMgPSBvO1xuXHRcdHRoaXMuX2xvY09mZnNldCA9IG8ubG9jIHx8IDA7XG5cdFx0Ly8gYWRkIGEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdFxuXHRcdG8uX3Rva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHQvLyB3aGF0IGFib3V0IGNvbCBoZXJlP1xuXHRcdFxuXHRcdC8vIEBpbmRlbnQgID0gMCAjIFRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuXHRcdC8vIEBpbmRlYnQgID0gMCAjIFRoZSBvdmVyLWluZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdC8vIEBvdXRkZWJ0ID0gMCAjIFRoZSB1bmRlci1vdXRkZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0Ly8gQGluZGVudHMgPSBbXSAjIFRoZSBzdGFjayBvZiBhbGwgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbHMuXG5cdFx0Ly8gQGVuZHMgICAgPSBbXSAjIFRoZSBzdGFjayBmb3IgcGFpcmluZyB1cCB0b2tlbnMuXG5cdFx0Ly8gQHRva2VucyAgPSBbXSAjIFN0cmVhbSBvZiBwYXJzZWQgdG9rZW5zIGluIHRoZSBmb3JtIGBbJ1RZUEUnLCB2YWx1ZSwgbGluZV1gLlxuXHRcdC8vIEBjaGFyID0gbmlsXG5cdFx0XG5cdFx0aWYgKG8ucHJvZmlsZSkgeyBjb25zb2xlLnRpbWUoXCJ0b2tlbml6ZTpsZXhlclwiKSB9O1xuXHRcdHRoaXMucGFyc2UoY29kZSk7XG5cdFx0aWYgKCFvLmlubGluZSkgdGhpcy5jbG9zZUluZGVudGF0aW9uKCk7XG5cdFx0aWYgKCFvLnNpbGVudCAmJiB0aGlzLl9lbmRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5lcnJvcigoXCJtaXNzaW5nIFwiICsgKHRoaXMuX2VuZHMucG9wKCkpKSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoby5wcm9maWxlKSB7IGNvbnNvbGUudGltZUVuZChcInRva2VuaXplOmxleGVyXCIpIH07XG5cdFx0aWYgKG8ucmV3cml0ZSA9PSBmYWxzZSB8fCBvLm5vcmV3cml0ZSkgeyByZXR1cm4gdGhpcy5fdG9rZW5zIH07XG5cdFx0cmV0dXJuIG5ldyBSZXdyaXRlcigpLnJld3JpdGUodGhpcy5fdG9rZW5zLG8pO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcGkgPSAwO1xuXHRcdFxuXHRcdHdoaWxlICh0aGlzLl9jaHVuayA9IGNvZGUuc2xpY2UoaSkpe1xuXHRcdFx0dGhpcy5fbG9jID0gdGhpcy5fbG9jT2Zmc2V0ICsgaTtcblx0XHRcdHBpID0gKHRoaXMuX2VuZCA9PSAnVEFHJyAmJiB0aGlzLnRhZ0RlZkNvbnRleHRUb2tlbigpKSB8fCAodGhpcy5faW5UYWcgJiYgdGhpcy50YWdDb250ZXh0VG9rZW4oKSkgfHwgdGhpcy5iYXNpY0NvbnRleHQoKTtcblx0XHRcdGkgKz0gcGk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuYmFzaWNDb250ZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0b3JUb2tlbigpIHx8IHRoaXMuc3ltYm9sVG9rZW4oKSB8fCB0aGlzLm1ldGhvZE5hbWVUb2tlbigpIHx8IHRoaXMuaWRlbnRpZmllclRva2VuKCkgfHwgdGhpcy53aGl0ZXNwYWNlVG9rZW4oKSB8fCB0aGlzLmxpbmVUb2tlbigpIHx8IHRoaXMuY29tbWVudFRva2VuKCkgfHwgdGhpcy5oZXJlZG9jVG9rZW4oKSB8fCB0aGlzLnRhZ1Rva2VuKCkgfHwgdGhpcy5zdHJpbmdUb2tlbigpIHx8IHRoaXMubnVtYmVyVG9rZW4oKSB8fCB0aGlzLnJlZ2V4VG9rZW4oKSB8fCB0aGlzLmpzVG9rZW4oKSB8fCB0aGlzLmxpdGVyYWxUb2tlbigpIHx8IDA7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUubW92ZUNhcmV0ID0gZnVuY3Rpb24gKGkpe1xuXHRcdHJldHVybiB0aGlzLl9sb2MgKz0gaTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5pbkNvbnRleHQgPSBmdW5jdGlvbiAoa2V5KXtcblx0XHR2YXIgbyA9IHRoaXMuX2NvbnRleHRzW3RoaXMuX2NvbnRleHRzLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiBvICYmIG9ba2V5XTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5wdXNoRW5kID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJwdXNoaW5nIGVuZFwiLHZhbFxuXHRcdHRoaXMuX2VuZHMucHVzaCh2YWwpO1xuXHRcdHRoaXMuX2NvbnRleHRzLnB1c2gobnVsbCk7XG5cdFx0dGhpcy5fZW5kID0gdmFsO1xuXHRcdHRoaXMucmVmcmVzaFNjb3BlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucG9wRW5kID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0dGhpcy5fZW5kcy5wb3AoKTtcblx0XHR0aGlzLl9jb250ZXh0cy5wb3AoKTtcblx0XHR0aGlzLl9lbmQgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0dGhpcy5yZWZyZXNoU2NvcGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5yZWZyZXNoU2NvcGUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgY3R4MCA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgY3R4MSA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAyXTtcblx0XHRyZXR1cm4gdGhpcy5faW5UYWcgPSBjdHgwID09ICdUQUdfRU5EJyB8fCAoY3R4MSA9PSAnVEFHX0VORCcgJiYgY3R4MCA9PSAnT1VUREVOVCcpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucXVldWVTY29wZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdC8vIGNvbnNvbGUubG9nKFwicHVzaGluZyBzY29wZSB7dmFsfSAtIHtAaW5kZW50c30ge0BpbmRlbnRzOmxlbmd0aH1cIilcblx0XHQvLyBAc2NvcGVzLnB1c2godmFsKSAjIG5vIG5vXG5cdFx0dGhpcy5fc2NvcGVzW3RoaXMuX2luZGVudHMubGVuZ3RoXSA9IHZhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5wb3BTY29wZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHRoaXMuX3Njb3Blcy5wb3AoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5nZXRTY29wZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9zY29wZXNbdGhpcy5faW5kZW50cy5sZW5ndGggLSAxXTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uIChzeW0sb3B0cyl7XG5cdFx0dmFyIGxlbiA9IHRoaXMuX2VuZHMucHVzaCh0aGlzLl9lbmQgPSBzeW0pO1xuXHRcdHRoaXMuX2NvbnRleHRzLnB1c2gob3B0cyB8fCBudWxsKTtcblx0XHRyZXR1cm4gc3ltO1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5jbG9zZVNlbGVjdG9yID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2VuZCA9PSAnJScpIHtcblx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0VORCcsJyUnLDApO1xuXHRcdFx0cmV0dXJuIHRoaXMucGFpcignJScpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLm9wZW5EZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5wdXNoRW5kKCdERUYnKTtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuY2xvc2VEZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5jb250ZXh0KCkgPT0gJ0RFRicpIHtcblx0XHRcdHZhciBwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJjbG9zZSBkZWYge3ByZXZ9XCJcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdjbG9zZURlZiB3aXRoIGxhc3Q+JyxwcmV2KVxuXHRcdFx0aWYgKHRUKHByZXYpID09ICdERUZfRlJBR01FTlQnKSB7XG5cdFx0XHRcdHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKHRUKHByZXYpID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImhlcmU/IT8/XCJcblx0XHRcdFx0dmFyIG4gPSB0aGlzLl90b2tlbnMucG9wKCk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIG5cblx0XHRcdFx0dGhpcy50b2tlbignREVGX0JPRFknLCdERUZfQk9EWScsMCk7XG5cdFx0XHRcdC8vIHRva2VuKCdURVJNSU5BVE9SJywgJycsMCkgdW5sZXNzIG4uQHZhbHVlLmluZGV4T2YoJy8vJykgPj0gMFxuXHRcdFx0XHR0aGlzLl90b2tlbnMucHVzaChuKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0RFRl9CT0RZJywnREVGX0JPRFknLDApO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5wYWlyKCdERUYnKTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS50YWdDb250ZXh0VG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2g7XG5cdFx0aWYgKHRoaXMuX2NodW5rWzBdID09ICcjJykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2ZvdW5kIGlkICMgaW4gdGFnQ29udGV4dFRva2VuJylcblx0XHRcdHRoaXMudG9rZW4oJyMnLCcjJywxKTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG1hdGNoID0gVEFHX0FUVFIuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdUQUdfU0REU0FUVFIgSU4gdG9raWQnLG1hdGNoXG5cdFx0XHQvLyB2YXIgcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdFx0Ly8gaWYgdGhlIHByZXYgaXMgYSB0ZXJtaW5hdG9yLCB3ZSBkb250IHJlYWxseSBuZWVkIHRvIGNhcmU/XG5cdFx0XHRpZiAodGhpcy5fbGFzdFR5cCAhPSAnVEFHX05BTUUnKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9sYXN0VHlwID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdwcmV2IHdhcyB0ZXJtaW5hdG9yIC0tIGRyb3AgaXQ/Jylcblx0XHRcdFx0XHR0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oXCIsXCIsXCIsXCIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGwgPSBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdHRoaXMudG9rZW4oJ1RBR19BVFRSJyxtYXRjaFsxXSxsIC0gMSk7IC8vIGFkZCB0byBsb2M/XG5cdFx0XHR0aGlzLl9sb2MgKz0gbCAtIDE7XG5cdFx0XHR0aGlzLnRva2VuKCc9JywnPScsMSk7XG5cdFx0XHRyZXR1cm4gbDtcblx0XHR9O1xuXHRcdHJldHVybiAwO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnRhZ0RlZkNvbnRleHRUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwidGFnQ29udGV4dFRva2VuXCJcblx0XHR2YXIgbWF0Y2g7XG5cdFx0aWYgKG1hdGNoID0gVEFHX1RZUEUuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHRoaXMudG9rZW4oJ1RBR19UWVBFJyxtYXRjaFswXSxtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChtYXRjaCA9IFRBR19JRC5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dmFyIGlucHV0ID0gbWF0Y2hbMF07XG5cdFx0XHR0aGlzLnRva2VuKCdUQUdfSUQnLGlucHV0LGlucHV0Lmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gaW5wdXQubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLnRhZ1Rva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLCBhcnk7XG5cdFx0aWYgKCEobWF0Y2ggPSBUQUcuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKG1hdGNoKTt2YXIgaW5wdXQgPSBhcnlbMF0sdHlwZSA9IGFyeVsxXSxpZGVudGlmaWVyID0gYXJ5WzJdO1xuXHRcdFxuXHRcdGlmICh0eXBlID09ICc8Jykge1xuXHRcdFx0dGhpcy50b2tlbignVEFHX1NUQVJUJywnPCcsMSk7XG5cdFx0XHR0aGlzLnB1c2hFbmQoSU5WRVJTRVMuVEFHX1NUQVJUKTtcblx0XHRcdFxuXHRcdFx0aWYgKG1hdGNoID0gVEFHX1RZUEUuZXhlYyh0aGlzLl9jaHVuay5zdWJzdHIoMSw0MCkpKSB7XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSBzaG91bGQgcHJvYmFibHkgYmUgaGFuZGxlZCBpbiBBU1Rcblx0XHRcdFx0aWYgKG1hdGNoWzBdICE9ICdzZWxmJykge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1RBR19UWVBFJyxtYXRjaFswXSxtYXRjaFswXS5sZW5ndGgsMSk7XG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0Lmxlbmd0aCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChpZGVudGlmaWVyKSB7XG5cdFx0XHRcdGlmIChpZGVudGlmaWVyLnN1YnN0cigwLDEpID09ICd7Jykge1xuXHRcdFx0XHRcdHJldHVybiB0eXBlLmxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdUQUdfTkFNRScsaW5wdXQuc3Vic3RyKDEpLDApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBpbnB1dC5sZW5ndGg7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLnNlbGVjdG9yVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYXJ5LCBzdHJpbmc7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdFxuXHRcdC8vIHNwZWNpYWwgaGFuZGxpbmcgaWYgd2UgYXJlIGluIHRoaXMgY29udGV4dFxuXHRcdGlmICh0aGlzLl9lbmQgPT0gJyUnKSB7XG5cdFx0XHR2YXIgY2hyID0gdGhpcy5fY2h1bmsuY2hhckF0KDApO1xuXHRcdFx0dmFyIG9wZW4gPSB0aGlzLmluQ29udGV4dCgnb3BlbicpO1xuXHRcdFx0XG5cdFx0XHQvLyBzaG91bGQgYWRkIGZvciArLCB+IGV0Y1xuXHRcdFx0Ly8gc2hvdWxkIG1heWJlIHJhdGhlciBsb29rIGZvciB0aGUgY29ycmVjdCB0eXBlIG9mIGNoYXJhY3Rlcj9cblx0XHRcdFxuXHRcdFx0aWYgKG9wZW4gJiYgKGNociA9PSAnICcgfHwgY2hyID09ICdcXG4nIHx8IGNociA9PSAnLCcgfHwgY2hyID09ICcrJyB8fCBjaHIgPT0gJ34nIHx8IGNociA9PSAnKScgfHwgY2hyID09ICddJykpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJjbG9zZSB0aGlzIHNlbGVjdG9yIGRpcmVjdGx5XCJcblx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfRU5EJywnJScsMCk7XG5cdFx0XHRcdHRoaXMucGFpcignJScpO1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChtYXRjaCA9IFNFTEVDVE9SX0NPTUJJTkFUT1IuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdFx0Ly8gc3BhY2VzIGJldHdlZW4/IC0tIGluY2x1ZGUgdGhlIHdob2xlXG5cdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0NPTUJJTkFUT1InLG1hdGNoWzFdIHx8IFwiIFwiLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGNoID0gU0VMRUNUT1JfUEFSVC5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdO1xuXHRcdFx0XHR2YXIgaWQgPSBtYXRjaFsyXTtcblx0XHRcdFx0XG5cdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJy4nOlxuXHRcdFx0XHRcdFx0dG9raWQgPSAnU0VMRUNUT1JfQ0xBU1MnO2JyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgJyMnOlxuXHRcdFx0XHRcdFx0dG9raWQgPSAnU0VMRUNUT1JfSUQnO2JyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgJzonOlxuXHRcdFx0XHRcdFx0dG9raWQgPSAnU0VMRUNUT1JfUFNFVURPX0NMQVNTJzticmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlICc6Oic6XG5cdFx0XHRcdFx0XHR0b2tpZCA9ICdTRUxFQ1RPUl9QU0VVRE9fQ0xBU1MnO2JyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR2YXIgdG9raWQgPSAnU0VMRUNUT1JfVEFHJztcblx0XHRcdFx0XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnRva2VuKHRva2lkLG1hdGNoWzJdLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnWycpIHtcblx0XHRcdFx0dGhpcy50b2tlbignWycsJ1snLDEpO1xuXHRcdFx0XHR0aGlzLnB1c2hFbmQoJ10nKTtcblx0XHRcdFx0aWYgKG1hdGNoID0gU0VMRUNUT1JfQVRUUi5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0XHRcdC8vIGZ1Y2sgdGhpcyBsZW5ndGggc2hpdFxuXHRcdFx0XHRcdHZhciBpZG9mZnNldCA9IG1hdGNoWzBdLmluZGV4T2YobWF0Y2hbMV0pO1xuXHRcdFx0XHRcdHZhciBvcG9mZnNldCA9IG1hdGNoWzBdLmluZGV4T2YobWF0Y2hbMl0pO1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ0lERU5USUZJRVInLG1hdGNoWzFdLG1hdGNoWzFdLmxlbmd0aCxpZG9mZnNldCk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfQVRUUl9PUCcsbWF0Y2hbMl0sbWF0Y2hbMl0ubGVuZ3RoLG9wb2Zmc2V0KTtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICd8Jykge1xuXHRcdFx0XHR2YXIgdG9rID0gdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXTtcblx0XHRcdFx0dFRzKHRvaywnU0VMRUNUT1JfTlMnKTtcblx0XHRcdFx0Ly8gdG9rWzBdID0gJ1NFTEVDVE9SX05TJyAjIEZJWFxuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICcsJykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9HUk9VUCcsJywnLDEpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICcqJykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdVTklWRVJTQUxfU0VMRUNUT1InLCcqJywxKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnKScpIHtcblx0XHRcdFx0dGhpcy5wYWlyKCclJyk7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0VORCcsJyknLDEpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH0gZWxzZSBpZiAoaWR4JChjaHIsWycpJywnfScsJ10nLCcnXSkgPj0gMCkge1xuXHRcdFx0XHR0aGlzLnBhaXIoJyUnKTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBTRUxFQ1RPUi5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBpbnB1dCA9IGFyeVswXSxpZCA9IGFyeVsxXSxraW5kID0gYXJ5WzJdO1xuXHRcdFxuXHRcdC8vIHRoaXMgaXMgYSBjbG9zZWQgc2VsZWN0b3Jcblx0XHRpZiAoa2luZCA9PSAnKCcpIHtcblx0XHRcdC8vIHRva2VuICcoJywnKCdcblx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX1NUQVJUJyxpZCxpZC5sZW5ndGggKyAxKTtcblx0XHRcdC8vIHNlbGYucHVzaEVuZCgnKScpICMgYXJlIHdlIHNvIHN1cmUgYWJvdXQgdGhpcz9cblx0XHRcdHRoaXMucHVzaEVuZCgnJScpO1xuXHRcdFx0XG5cdFx0XHQvLyBAZW5kcy5wdXNoICcpJ1xuXHRcdFx0Ly8gQGVuZHMucHVzaCAnJSdcblx0XHRcdHJldHVybiBpZC5sZW5ndGggKyAxO1xuXHRcdH0gZWxzZSBpZiAoaWQgPT0gJyUnKSB7XG5cdFx0XHQvLyB3ZSBhcmUgYWxyZWFkeSBzY29wZWQgaW4gb24gYSBzZWxlY3RvclxuXHRcdFx0aWYgKHRoaXMuY29udGV4dCgpID09ICclJykgeyByZXR1cm4gMSB9O1xuXHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfU1RBUlQnLGlkLGlkLmxlbmd0aCk7XG5cdFx0XHQvLyB0aGlzIGlzIGEgc2VwYXJhdGUgLSBzY29wZS4gRnVsbCBzZWxlY3RvciBzaG91bGQgcmF0aGVyIGJlICQsIGFuZCBrZWVwIHRoZSBzaW5nbGUgc2VsZWN0b3IgYXMgJVxuXHRcdFx0XG5cdFx0XHR0aGlzLnNjb3BlKCclJyx7b3BlbjogdHJ1ZX0pO1xuXHRcdFx0Ly8gQGVuZHMucHVzaCAnJSdcblx0XHRcdC8vIG1ha2Ugc3VyZSBhIHRlcm1pbmF0b3IgYnJlYWtzIG91dFxuXHRcdFx0cmV0dXJuIGlkLmxlbmd0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoKGlkID09ICclJyB8fCBpZCA9PSAnJCcpICYmIFsnJScsJyQnLCdAJywnKCcsJ1snXS5pbmRleE9mKGNocikgPj0gMCkge1xuXHRcdFx0dmFyIGlkeCA9IDI7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gVkVSWSB0ZW1wb3Jhcnkgd2F5IG9mIHNvbHZpbmcgdGhpc1xuXHRcdFx0aWYgKChjaHIgPT0gJyUnIHx8IGNociA9PSAnJCcgfHwgY2hyID09ICdAJykpIHtcblx0XHRcdFx0aWQgKz0gY2hyO1xuXHRcdFx0XHRpZHggPSAzO1xuXHRcdFx0XHRjaHIgPSB0aGlzLl9jaHVuay5jaGFyQXQoMik7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGlmIChjaHIgPT0gJygnKSB7XG5cdFx0XHRcdGlmICghKHN0cmluZyA9IHRoaXMuYmFsYW5jZWRTZWxlY3Rvcih0aGlzLl9jaHVuaywnKScpKSkgeyByZXR1cm4gMCB9O1xuXHRcdFx0XHRpZiAoMCA8IHN0cmluZy5pbmRleE9mKCd7JywxKSkge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SJyxpZCk7XG5cdFx0XHRcdFx0Ly8gaXMgdGhpcyBldmVuIHVzZWQgYW55bW9yZT8gSWYgc28gLSB3ZSBuZWVkIHRvIGZpeCBpdFxuXHRcdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGVTdHJpbmcoc3RyaW5nLnNsaWNlKGlkeCwtMSkpO1xuXHRcdFx0XHRcdHJldHVybiBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SJyxpZCk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignKCcsJygnKTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTVFJJTkcnLCdcIicgKyBzdHJpbmcuc2xpY2UoaWR4LC0xKSArICdcIicpO1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJyknLCcpJyk7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnWycpIHtcblx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1InLGlkKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdC8vIHRva2VuICdbJywnWydcblx0XHRcdFx0Ly8gQGVuZHMucHVzaCAnJ1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0fTtcblx0XG5cdC8vIGlzIHRoaXMgcmVhbGx5IG5lZWRlZD8gU2hvdWxkIGJlIHBvc3NpYmxlIHRvXG5cdC8vIHBhcnNlIHRoZSBpZGVudGlmaWVycyBhbmQgPSBldGMgaSBqaXNvbj9cblx0Ly8gd2hhdCBpcyBzcGVjaWFsIGFib3V0IG1ldGhvZE5hbWVUb2tlbj8gcmVhbGx5P1xuXHRMZXhlci5wcm90b3R5cGUubWV0aG9kTmFtZVRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gd2UgY2FuIG9wdGltaXplIHRoaXMgYnkgYWZ0ZXIgYSBkZWYgc2ltcGx5XG5cdFx0Ly8gZmV0Y2hpbmcgYWxsIHRoZSB3YXkgYWZ0ZXIgdGhlIGRlZiB1bnRpbCBhIHNwYWNlIG9yIChcblx0XHQvLyBhbmQgdGhlbiBhZGQgdGhpcyB0byB0aGUgZGVmLXRva2VuIGl0c2VsZiAoYXMgd2l0aCBmcmFnbWVudClcblx0XHRpZiAodGhpcy5fY2h1bmsuY2hhckF0KDApID09ICcgJykgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdHZhciBtYXRjaDtcblx0XHRcblx0XHRpZiAodGhpcy5fZW5kID09ICcpJykge1xuXHRcdFx0dmFyIG91dGVyY3R4ID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDJdO1xuXHRcdFx0Ly8gd2VpcmQgYXNzdW1wdGlvbiwgbm8/XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnY29udGV4dCBpcyBpbnNpZGUhISEnXG5cdFx0XHRpZiAob3V0ZXJjdHggPT0gJyUnICYmIChtYXRjaCA9IFRBR19BVFRSLmV4ZWModGhpcy5fY2h1bmspKSkge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdUQUdfQVRUUl9TRVQnLG1hdGNoWzFdKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IE1FVEhPRF9JREVOVElGSUVSLmV4ZWModGhpcy5fY2h1bmspKSkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHQvLyB2YXIgcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdHZhciBsZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XG5cdFx0dmFyIGlkID0gbWF0Y2hbMF07XG5cdFx0dmFyIGx0eXAgPSB0aGlzLl9sYXN0VHlwO1xuXHRcdHZhciB0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0dmFyIHByZSA9IGlkLmNoYXJBdCgwKTtcblx0XHR2YXIgc3BhY2UgPSBmYWxzZTtcblx0XHRcblx0XHR2YXIgbTQgPSBtYXRjaFs0XTsgLy8gbWlnaHQgYmUgb3V0IG9mIGJvdW5kcz8gc2hvdWxkIHJhdGhlciBjaGVjayBjaGFyQXRcblx0XHQvLyBkcm9wIG1hdGNoIDQ/P1xuXHRcdFxuXHRcdC8vIHNob3VsZCB0aGlzIG5vdCBxdWl0IGhlcmUgaW4gcHJhY3RpY2FsbHkgYWxsIGNhc2VzP1xuXHRcdGlmICghKChsdHlwID09ICcuJyB8fCBsdHlwID09ICdERUYnKSB8fCAobTQgPT0gJyEnIHx8IG00ID09ICc/JykgfHwgbWF0Y2hbNV0pKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGFnYWluLCB3aHk/XG5cdFx0aWYgKGlkID09ICdzZWxmJyB8fCBpZCA9PSAndGhpcycgfHwgaWQgPT0gJ3N1cGVyJykgeyAvLyBpbiBbJ1NFTEYnLCdUSElTJ11cblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGlkID09ICduZXcnKSB7XG5cdFx0XHR0eXAgPSAnTkVXJztcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpZCA9PSAnLi4uJyAmJiBbJywnLCcoJywnQ0FMTF9TVEFSVCcsJ0JMT0NLX1BBUkFNX1NUQVJUJywnUEFSQU1fU1RBUlQnXS5pbmRleE9mKGx0eXApID49IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGlkID09ICd8Jykge1xuXHRcdFx0Ly8gaGFja3kgd2F5IHRvIGltcGxlbWVudCB0aGlzXG5cdFx0XHQvLyB3aXRoIG5ldyBsZXhlciB3ZSdsbCB1c2UgeyAuLi4gfSBpbnN0ZWFkLCBhbmQgYXNzdW1lIG9iamVjdC1jb250ZXh0LFxuXHRcdFx0Ly8gdGhlbiBnbyBiYWNrIGFuZCBjb3JyZWN0IHdoZW4gd2Ugc2VlIHRoZSBjb250ZXh0IGlzIGludmFsaWRcblx0XHRcdGlmIChsdHlwID09ICcoJyB8fCBsdHlwID09ICdDQUxMX1NUQVJUJykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdETycsJ0RPJywwKTtcblx0XHRcdFx0dGhpcy5wdXNoRW5kKCd8Jyk7XG5cdFx0XHRcdC8vIEBlbmRzLnB1c2ggJ3wnXG5cdFx0XHRcdHRoaXMudG9rZW4oJ0JMT0NLX1BBUkFNX1NUQVJUJyxpZCwxKTtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAobHR5cCA9PSAnRE8nIHx8IGx0eXAgPT0gJ3snKSB7XG5cdFx0XHRcdC8vIEBlbmRzLnB1c2ggJ3wnXG5cdFx0XHRcdHRoaXMucHVzaEVuZCgnfCcpO1xuXHRcdFx0XHR0aGlzLnRva2VuKCdCTE9DS19QQVJBTV9TVEFSVCcsaWQsMSk7XG5cdFx0XHRcdHJldHVybiBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXSA9PSAnfCcpIHtcblx0XHRcdFx0dGhpcy50b2tlbignQkxPQ0tfUEFSQU1fRU5EJywnfCcsMSk7XG5cdFx0XHRcdHRoaXMucGFpcignfCcpO1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gd2hhYXQ/XG5cdFx0Ly8gY29uc29sZS5sb2coXCJtZXRob2QgaWRlbnRpZmllclwiLGlkKVxuXHRcdGlmICgoWycmJywnXicsJzw8JywnPDw8JywnPj4nXS5pbmRleE9mKGlkKSA+PSAwIHx8IChpZCA9PSAnfCcgJiYgdGhpcy5jb250ZXh0KCkgIT0gJ3wnKSkpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKE9QX01FVEhPRFMuaW5kZXhPZihpZCkgPj0gMCkge1xuXHRcdFx0c3BhY2UgPSB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gbm90IGV2ZW4gYW55dGhpbmcgd2Ugc2hvdWxkIHVzZT8hP1xuXHRcdGlmIChwcmUgPT0gJ0AnKSB7XG5cdFx0XHR0eXAgPSAnSVZBUic7XG5cdFx0fSBlbHNlIGlmIChwcmUgPT0gJyQnKSB7XG5cdFx0XHR0cnVlO1xuXHRcdFx0Ly8gdHlwID0gJ0dWQVInXG5cdFx0fSBlbHNlIGlmIChwcmUgPT0gJyMnKSB7XG5cdFx0XHR0eXAgPSAnVEFHSUQnO1xuXHRcdH0gZWxzZSBpZiAoQ09OU1RfSURFTlRJRklFUi50ZXN0KHByZSkgfHwgaWQgPT0gJ3JlcXVpcmUnIHx8IGlkID09ICdnbG9iYWwnIHx8IGlkID09ICdleHBvcnRzJykge1xuXHRcdFx0Ly8gcmVhbGx5PyBzZWVtcyB2ZXJ5IHN0cmFuZ2Vcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdnbG9iYWwhIScsdHlwLGlkKVxuXHRcdFx0dHlwID0gJ0NPTlNUJztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHdoYXQgaXMgdGhpcyByZWFsbHkgZm9yP1xuXHRcdGlmIChtYXRjaFs1XSAmJiBbJ0lERU5USUZJRVInLCdDT05TVCcsJ0dWQVInLCdDVkFSJywnSVZBUicsJ1NFTEYnLCdUSElTJywnXScsJ30nLCcpJywnTlVNQkVSJywnU1RSSU5HJywnSURSRUYnXS5pbmRleE9mKGx0eXApID49IDApIHtcblx0XHRcdHRoaXMudG9rZW4oJy4nLCcuJywwKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMudG9rZW4odHlwLGlkLGxlbmd0aCk7XG5cdFx0XG5cdFx0aWYgKHNwYWNlKSB7XG5cdFx0XHR0aGlzLl9sYXN0LnNwYWNlZCA9IHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbGVuZ3RoO1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5pblRhZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBsZW4gPSB0aGlzLl9lbmRzLmxlbmd0aDtcblx0XHRpZiAobGVuID4gMCkge1xuXHRcdFx0dmFyIGN0eDAgPSB0aGlzLl9lbmRzW2xlbiAtIDFdO1xuXHRcdFx0dmFyIGN0eDEgPSBsZW4gPiAxID8gKHRoaXMuX2VuZHNbbGVuIC0gMl0pIDogKGN0eDApO1xuXHRcdFx0cmV0dXJuIGN0eDAgPT0gJ1RBR19FTkQnIHx8IChjdHgxID09ICdUQUdfRU5EJyAmJiBjdHgwID09ICdPVVRERU5UJyk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKGlkKXtcblx0XHRpZiAoKGlkID09ICdhdHRyJyB8fCBpZCA9PSAncHJvcCcpKSB7XG5cdFx0XHR2YXIgc2NvcCA9IHRoaXMuZ2V0U2NvcGUoKTtcblx0XHRcdHZhciBpbmNscyA9IHNjb3AgPT0gJ0NMQVNTJyB8fCBzY29wID09ICdUQUcnO1xuXHRcdFx0Ly8gdmFyIHNjb3BlcyA9IEBpbmRlbnRzLm1hcCh8aW5kLGl8IEBzY29wZXNbaV0gb3IgJ05PTkUnKVxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJpZCBpcyBwcm9wOiB7c2NvcGVzLmpvaW4oXCIgLT4gXCIpfSB8IHtAaW5kZW50cy5qb2luKFwiIC0+IFwiKX1cIlxuXHRcdFx0aWYgKGluY2xzKSB7IHJldHVybiB0cnVlIH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gQUxMX0tFWVdPUkRTLmluZGV4T2YoaWQpID49IDA7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGlkZW50aWZ5aW5nIGxpdGVyYWxzOiB2YXJpYWJsZXMsIGtleXdvcmRzLCBtZXRob2QgbmFtZXMsIGV0Yy5cblx0Ly8gQ2hlY2sgdG8gZW5zdXJlIHRoYXQgSmF2YVNjcmlwdCByZXNlcnZlZCB3b3JkcyBhcmVuJ3QgYmVpbmcgdXNlZCBhc1xuXHQvLyBpZGVudGlmaWVycy4gQmVjYXVzZSBJbWJhIHJlc2VydmVzIGEgaGFuZGZ1bCBvZiBrZXl3b3JkcyB0aGF0IGFyZVxuXHQvLyBhbGxvd2VkIGluIEphdmFTY3JpcHQsIHdlJ3JlIGNhcmVmdWwgbm90IHRvIHRva2lkIHRoZW0gYXMga2V5d29yZHMgd2hlblxuXHQvLyByZWZlcmVuY2VkIGFzIHByb3BlcnR5IG5hbWVzIGhlcmUsIHNvIHlvdSBjYW4gc3RpbGwgZG8gYGpRdWVyeS5pcygpYCBldmVuXG5cdC8vIHRob3VnaCBgaXNgIG1lYW5zIGA9PT1gIG90aGVyd2lzZS5cblx0TGV4ZXIucHJvdG90eXBlLmlkZW50aWZpZXJUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhcnk7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdFxuXHRcdHZhciBjdHgwID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdO1xuXHRcdHZhciBjdHgxID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDJdO1xuXHRcdHZhciBpbm5lcmN0eCA9IGN0eDA7XG5cdFx0dmFyIHR5cDtcblx0XHR2YXIgcmVzZXJ2ZWQgPSBmYWxzZTtcblx0XHRcblx0XHR2YXIgYWRkTG9jID0gZmFsc2U7XG5cdFx0dmFyIGluVGFnID0gY3R4MCA9PSAnVEFHX0VORCcgfHwgKGN0eDEgPT0gJ1RBR19FTkQnICYmIGN0eDAgPT0gJ09VVERFTlQnKTtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyBjdHgxLGN0eDBcblx0XHRcblx0XHRpZiAoaW5UYWcgJiYgKG1hdGNoID0gVEFHX0FUVFIuZXhlYyh0aGlzLl9jaHVuaykpKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnVEFHX0FUVFIgSU4gdG9raWQnLG1hdGNoXG5cdFx0XHQvLyB2YXIgcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdFx0Ly8gaWYgdGhlIHByZXYgaXMgYSB0ZXJtaW5hdG9yLCB3ZSBkb250IHJlYWxseSBuZWVkIHRvIGNhcmU/XG5cdFx0XHRpZiAodGhpcy5fbGFzdFR5cCAhPSAnVEFHX05BTUUnKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9sYXN0VHlwID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdwcmV2IHdhcyB0ZXJtaW5hdG9yIC0tIGRyb3AgaXQ/Jylcblx0XHRcdFx0XHR0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oXCIsXCIsXCIsXCIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGwgPSBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdHRoaXMudG9rZW4oJ1RBR19BVFRSJyxtYXRjaFsxXSxsIC0gMSk7IC8vIGFkZCB0byBsb2M/XG5cdFx0XHR0aGlzLl9sb2MgKz0gbCAtIDE7XG5cdFx0XHR0aGlzLnRva2VuKCc9JywnPScsMSk7XG5cdFx0XHRyZXR1cm4gbDtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNlZSBpZiB0aGlzIGlzIGEgcGxhaW4gb2JqZWN0LWtleVxuXHRcdC8vIHdheSB0b28gbXVjaCBsb2dpYyBnb2luZyBvbiBoZXJlP1xuXHRcdC8vIHRoZSBhc3Qgc2hvdWxkIG5vcm1hbGl6ZSB3aGV0aGVyIGtleXNcblx0XHQvLyBhcmUgYWNjZXNzYWJsZSBhcyBrZXlzIG9yIHN0cmluZ3MgZXRjXG5cdFx0aWYgKG1hdGNoID0gT0JKRUNUX0tFWS5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dmFyIGlkID0gbWF0Y2hbMV07XG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0XHRcblx0XHRcdC8vIEZJWE1FIGxvYyBvZiBrZXkgaW5jbHVkZXMgY29sb25cblx0XHRcdC8vIG1vdmVDYXJldChpZDpsZW5ndGgpXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcIm9rXCJcblx0XHRcdGlmICh0cnVlKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZ290IGhlcmU/IHttYXRjaH1cIlxuXHRcdFx0XHR0aGlzLnRva2VuKHR5cCxpZCxpZC5sZW5ndGgpO1xuXHRcdFx0XHR0aGlzLm1vdmVDYXJldChpZC5sZW5ndGgpO1xuXHRcdFx0XHR0aGlzLnRva2VuKCc6JywnOicsbWF0Y2hbM10ubGVuZ3RoKTtcblx0XHRcdFx0dGhpcy5tb3ZlQ2FyZXQoLWlkLmxlbmd0aCk7XG5cdFx0XHRcdC8vIG1vdmVDYXJldChtYXRjaFszXTpsZW5ndGgpXG5cdFx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBtb3ZlQ2FyZXQobWF0Y2hbMl06bGVuZ3RoKVxuXHRcdFx0Ly8gcmV0dXJuIDBcblx0XHRcdGNvbnNvbGUubG9nKG1hdGNoWzNdLmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKHR5cCxpZCxtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0dGhpcy50b2tlbignOicsJzonLDEpO1xuXHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gSURFTlRJRklFUi5leGVjKHRoaXMuX2NodW5rKSkpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKG1hdGNoKTt2YXIgaW5wdXQgPSBhcnlbMF0saWQgPSBhcnlbMV0sdHlwID0gYXJ5WzJdLG0zID0gYXJ5WzNdLG00ID0gYXJ5WzRdLGNvbG9uID0gYXJ5WzVdO1xuXHRcdHZhciBpZGxlbiA9IGlkLmxlbmd0aDtcblx0XHRcblx0XHQvLyBXaGF0IGlzIHRoZSBsb2dpYyBoZXJlP1xuXHRcdGlmIChpZCA9PSAnb3duJyAmJiB0aGlzLmxhc3RUb2tlblR5cGUoKSA9PSAnRk9SJykge1xuXHRcdFx0dGhpcy50b2tlbignT1dOJyxpZCxpZC5sZW5ndGgpO1xuXHRcdFx0cmV0dXJuIGlkLmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdHZhciBsYXN0VHlwID0gdGhpcy5fbGFzdFR5cDtcblx0XHRcblx0XHQvLyBzaG91bGQgd2UgZm9yY2UgdGhpcyB0byBiZSBhbiBpZGVudGlmaWVyIGV2ZW4gaWYgaXQgaXMgYSByZXNlcnZlZCB3b3JkP1xuXHRcdC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGZvciB3aGVuIHBhcnQgb2Ygb2JqZWN0IGV0Y1xuXHRcdC8vIHdpbGwgcHJldiBldmVyIGJlIEA/Pz9cblx0XHR2YXIgZm9yY2VkSWRlbnRpZmllcjtcblx0XHRcblx0XHQvLyBhZ2FpblxuXHRcdGZvcmNlZElkZW50aWZpZXIgPSBjb2xvbiB8fCBsYXN0VHlwID09ICcuJyB8fCBsYXN0VHlwID09ICc/Lic7IC8vIGluIFsnLicsICc/Lidcblx0XHRcblx0XHRcblx0XHQvLyB0ZW1wIGhhY2shIG5lZWQgdG8gc29sdmUgZm9yIG90aGVyIGtleXdvcmRzIGV0YyBhcyB3ZWxsXG5cdFx0Ly8gcHJvYmxlbSBhcHBlYXJzIHdpdGggdGVybmFyeSBjb25kaXRpb25zLlxuXHRcdFxuXHRcdC8vIHdlbGwgLS0gaXQgc2hvdWxkIHN0aWxsIGJlIGFuIGluZGVudGlmaWVyIGlmIGluIG9iamVjdD9cblx0XHQvLyBmb3JjZWRJZGVudGlmaWVyID0gbm8gaWYgaWQgaW4gWyd1bmRlZmluZWQnLCdicmVhayddXG5cdFx0XG5cdFx0aWYgKGNvbG9uICYmIGxhc3RUeXAgPT0gJz8nKSB7IGZvcmNlZElkZW50aWZpZXIgPSBmYWxzZSB9OyAvLyBmb3IgdGVybmFyeVxuXHRcdFxuXHRcdC8vIGlmIHdlIGFyZSBub3QgYXQgdGhlIHRvcCBsZXZlbD8gLS0gaGFja3lcblx0XHRpZiAoaWQgPT0gJ3RhZycgJiYgdGhpcy5fY2h1bmsuaW5kZXhPZihcInRhZyhcIikgPT0gMCkgeyAvLyBAY2h1bmsubWF0Y2goL150b2tpZFxcKC8pXG5cdFx0XHRmb3JjZWRJZGVudGlmaWVyID0gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBpc0tleXdvcmQgPSBmYWxzZTtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyBcIm1hdGNoXCIsbWF0Y2hcblx0XHQvLyBjb25zb2xlLmxvZyBcInR5cCBpcyB7dHlwfVwiXG5cdFx0Ly8gbGl0dGxlIHJlYXNvbiB0byBjaGVjayBmb3IgdGhpcyByaWdodCBoZXJlPyBidXQgSSBndWVzcyBpdCBpcyBvbmx5IGEgc2ltcGxlIGNoZWNrXG5cdFx0aWYgKHR5cCA9PSAnJCcgJiYgQVJHVkFSLnRlc3QoaWQpKSB7IC8vIGlkLm1hdGNoKC9eXFwkXFxkJC8pXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcIlRZUCAkXCJcblx0XHRcdGlmIChpZCA9PSAnJDAnKSB7XG5cdFx0XHRcdHR5cCA9ICdBUkdVTUVOVFMnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwID0gJ0FSR1ZBUic7XG5cdFx0XHRcdGlkID0gaWQuc3Vic3RyKDEpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnQCcpIHtcblx0XHRcdHR5cCA9ICdJVkFSJztcblx0XHRcdFxuXHRcdFx0Ly8gaWQ6cmVzZXJ2ZWQgPSB5ZXMgaWYgY29sb25cblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnIycpIHtcblx0XHRcdC8vIHdlIGFyZSB0cnlpbmcgdG8gbW92ZSB0byBnZW5lcmljIHRva2Vucyxcblx0XHRcdC8vIHNvIHdlIGFyZSBzdGFydGluZyB0byBzcGxpdHRpbmcgdXAgdGhlIHN5bWJvbHMgYW5kIHRoZSBpdGVtc1xuXHRcdFx0Ly8gd2UnbGwgc2VlIGlmIHRoYXQgd29ya3Ncblx0XHRcdHR5cCA9ICdJREVOVElGSUVSJztcblx0XHRcdHRoaXMudG9rZW4oJyMnLCcjJyk7XG5cdFx0XHRpZCA9IGlkLnN1YnN0cigxKTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnQEAnKSB7XG5cdFx0XHR0eXAgPSAnQ1ZBUic7XG5cdFx0fSBlbHNlIGlmICh0eXAgPT0gJyQnICYmICFjb2xvbikge1xuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInO1xuXHRcdFx0Ly8gdHlwID0gJ0dWQVInXG5cdFx0fSBlbHNlIGlmIChDT05TVF9JREVOVElGSUVSLnRlc3QoaWQpIHx8IGlkID09ICdyZXF1aXJlJyB8fCBpZCA9PSAnZ2xvYmFsJyB8fCBpZCA9PSAnZXhwb3J0cycpIHtcblx0XHRcdC8vIHRob3VzIHNob3VsZCByZWFsbHkgYmUgaGFuZGxlZCBieSB0aGUgYXN0IGluc3RlYWRcblx0XHRcdHR5cCA9ICdDT05TVCc7XG5cdFx0fSBlbHNlIGlmIChpZCA9PSAnZWxpZicpIHtcblx0XHRcdHRoaXMudG9rZW4oJ0VMU0UnLCdlbGlmJyxpZC5sZW5ndGgpO1xuXHRcdFx0dGhpcy50b2tlbignSUYnLCdpZicpO1xuXHRcdFx0cmV0dXJuIGlkLmxlbmd0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0Ly8gdGhpcyBjYXRjaGVzIGFsbCBcblx0XHRpZiAoIWZvcmNlZElkZW50aWZpZXIgJiYgKGlzS2V5d29yZCA9IHRoaXMuaXNLZXl3b3JkKGlkKSkpIHtcblx0XHRcdC8vIChpZCBpbiBKU19LRVlXT1JEUyBvciBpZCBpbiBJTUJBX0tFWVdPUkRTKVxuXHRcdFx0dHlwID0gaWQudG9VcHBlckNhc2UoKTtcblx0XHRcdGFkZExvYyA9IHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIGNsdW1zeSAtIGJ1dCB0ZXN0aW5nIHBlcmZvcm1hbmNlXG5cdFx0XHRpZiAodHlwID09ICdZRVMnKSB7XG5cdFx0XHRcdHR5cCA9ICdUUlVFJztcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdOTycpIHtcblx0XHRcdFx0dHlwID0gJ0ZBTFNFJztcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdOSUwnKSB7XG5cdFx0XHRcdHR5cCA9ICdOVUxMJztcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdWQVInKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9sYXN0VmFsID09ICdleHBvcnQnKSB7XG5cdFx0XHRcdFx0dFRzKHByZXYsJ0VYUE9SVCcpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0lGJyB8fCB0eXAgPT0gJ0VMU0UnIHx8IHR5cCA9PSAnVFJVRScgfHwgdHlwID09ICdGQUxTRScgfHwgdHlwID09ICdOVUxMJykge1xuXHRcdFx0XHR0cnVlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1RBRycpIHtcblx0XHRcdFx0dGhpcy5wdXNoRW5kKCdUQUcnKTtcblx0XHRcdFx0Ly8gQGVuZHMucHVzaCgnVEFHJylcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdERUYnKSB7XG5cdFx0XHRcdC8vIHNob3VsZCBwcm9iYWJseSBzaGlmdCBjb250ZXh0IGFuZCBvcHRpbWl6ZSB0aGlzXG5cdFx0XHRcdHRoaXMub3BlbkRlZigpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0RPJykge1xuXHRcdFx0XHRpZiAodGhpcy5jb250ZXh0KCkgPT0gJ0RFRicpIHRoaXMuY2xvc2VEZWYoKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdXSEVOJyAmJiBMSU5FX0JSRUFLLmluZGV4T2YodGhpcy5sYXN0VG9rZW5UeXBlKCkpID49IDApIHtcblx0XHRcdFx0dHlwID0gJ0xFQURJTkdfV0hFTic7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnRk9SJykge1xuXHRcdFx0XHR0aGlzLl9zZWVuRm9yID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdVTkxFU1MnKSB7XG5cdFx0XHRcdHR5cCA9ICdJRic7IC8vIFdBUk5cblx0XHRcdH0gZWxzZSBpZiAoVU5BUlkuaW5kZXhPZih0eXApID49IDApIHtcblx0XHRcdFx0dHlwID0gJ1VOQVJZJztcblx0XHRcdH0gZWxzZSBpZiAoUkVMQVRJT04uaW5kZXhPZih0eXApID49IDApIHtcblx0XHRcdFx0aWYgKHR5cCAhPSAnSU5TVEFOQ0VPRicgJiYgdHlwICE9ICdJU0EnICYmIHRoaXMuX3NlZW5Gb3IpIHtcblx0XHRcdFx0XHR0eXAgPSAnRk9SJyArIHR5cDsgLy8gP1xuXHRcdFx0XHRcdHRoaXMuX3NlZW5Gb3IgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0eXAgPSAnUkVMQVRJT04nO1xuXHRcdFx0XHRcdGlmIChTdHJpbmcodGhpcy52YWx1ZSgpKSA9PSAnIScpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3Rva2Vucy5wb3AoKTsgLy8gaXMgZnVja2VkIHVwPz8hXG5cdFx0XHRcdFx0XHQvLyBXQVJOIHdlIG5lZWQgdG8ga2VlcCB0aGUgbG9jLCBubz9cblx0XHRcdFx0XHRcdGlkID0gJyEnICsgaWQ7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaWQgPT0gJ3N1cGVyJykge1xuXHRcdFx0dHlwID0gJ1NVUEVSJztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGRvIHdlIHJlYWxseSB3YW50IHRvIGNoZWNrIHRoaXMgaGVyZVxuXHRcdGlmICghZm9yY2VkSWRlbnRpZmllcikge1xuXHRcdFx0Ly8gc2hvdWxkIGFscmVhZHkgaGF2ZSBkZWFsdCB3aXRoIHRoaXNcblx0XHRcdFxuXHRcdFx0aWYgKGlzS2V5d29yZCAmJiBJTUJBX0FMSUFTRVMuaW5kZXhPZihpZCkgPj0gMCkgeyBpZCA9IElNQkFfQUxJQVNfTUFQW2lkXSB9O1xuXHRcdFx0Ly8gdGhlc2UgcmVhbGx5IHNob3VsZCBub3QgZ28gaGVyZT8hP1xuXHRcdFx0c3dpdGNoIChpZCkge1xuXHRcdFx0XHRjYXNlICchJzpcblx0XHRcdFx0XHR0eXAgPSAnVU5BUlknO2JyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnPT0nOlxuXHRcdFx0XHRjYXNlICchPSc6XG5cdFx0XHRcdGNhc2UgJz09PSc6XG5cdFx0XHRcdGNhc2UgJyE9PSc6XG5cdFx0XHRcdFx0dHlwID0gJ0NPTVBBUkUnO2JyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnJiYnOlxuXHRcdFx0XHRjYXNlICd8fCc6XG5cdFx0XHRcdFx0dHlwID0gJ0xPR0lDJzticmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgJ2JyZWFrJzpcblx0XHRcdFx0Y2FzZSAnY29udGludWUnOlxuXHRcdFx0XHRjYXNlICdkZWJ1Z2dlcic6XG5cdFx0XHRcdGNhc2UgJ2FyZ3VtZW50cyc6XG5cdFx0XHRcdFx0dHlwID0gaWQudG9VcHBlckNhc2UoKTticmVhaztcblx0XHRcdFxuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHR2YXIgbGVuID0gaW5wdXQubGVuZ3RoO1xuXHRcdFxuXHRcdC8vIHNob3VsZCBiZSBzdHJpY3QgYWJvdXQgdGhlIG9yZGVyLCBjaGVjayB0aGlzIG1hbnVhbGx5IGluc3RlYWRcblx0XHRpZiAodHlwID09ICdDTEFTUycgfHwgdHlwID09ICdERUYnIHx8IHR5cCA9PSAnVEFHJykge1xuXHRcdFx0dGhpcy5xdWV1ZVNjb3BlKHR5cCk7XG5cdFx0XHRcblx0XHRcdHZhciBpID0gdGhpcy5fdG9rZW5zLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGkpe1xuXHRcdFx0XHRwcmV2ID0gdGhpcy5fdG9rZW5zWy0taV07XG5cdFx0XHRcdHZhciBjdHJsID0gXCJcIiArIHRWKHByZXYpO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcImN0cmwgaXMge2N0cmx9XCIpXG5cdFx0XHRcdC8vIG5lZWQgdG8gY29lcmNlIHRvIHN0cmluZyBiZWNhdXNlIG9mIHN0dXBpZCBDUyA9PT1cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJwcmV2IGlzXCIscHJldlswXSxwcmV2WzFdKVxuXHRcdFx0XHRpZiAoaWR4JChjdHJsLElNQkFfQ09OVEVYVFVBTF9LRVlXT1JEUykgPj0gMCkge1xuXHRcdFx0XHRcdHRUcyhwcmV2LGN0cmwudG9VcHBlckNhc2UoKSk7XG5cdFx0XHRcdFx0Ly8gcHJldlswXSA9IGN0cmwudG9VcHBlckNhc2UgIyBGSVhcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0lGJykge1xuXHRcdFx0dGhpcy5xdWV1ZVNjb3BlKHR5cCk7XG5cdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0lNUE9SVCcpIHtcblx0XHRcdC8vIGNvdWxkIG1hbnVhbGx5IHBhcnNlIHRoZSB3aG9sZSB0aW5nIGhlcmU/XG5cdFx0XHR0aGlzLnB1c2hFbmQoJ0lNUE9SVCcpO1xuXHRcdFx0Ly8gQGVuZHMucHVzaCAnSU1QT1JUJ1xuXHRcdH0gZWxzZSBpZiAoaWQgPT0gJ2Zyb20nICYmIGN0eDAgPT0gJ0lNUE9SVCcpIHtcblx0XHRcdHR5cCA9ICdGUk9NJztcblx0XHRcdHRoaXMucGFpcignSU1QT1JUJyk7XG5cdFx0fSBlbHNlIGlmIChpZCA9PSAnYXMnICYmIGN0eDAgPT0gJ0lNUE9SVCcpIHtcblx0XHRcdHR5cCA9ICdBUyc7XG5cdFx0XHR0aGlzLnBhaXIoJ0lNUE9SVCcpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHR5cCA9PSAnSURFTlRJRklFUicpIHtcblx0XHRcdC8vIHNlZSBpZiBwcmV2aW91cyB3YXMgY2F0Y2ggLS0gYmVsb25ncyBpbiByZXdyaXRlcj9cblx0XHRcdGlmIChsYXN0VHlwID09ICdDQVRDSCcpIHtcblx0XHRcdFx0dHlwID0gJ0NBVENIX1ZBUic7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGNvbG9uKSB7XG5cdFx0XHR0aGlzLnRva2VuKHR5cCxpZCxpZGxlbik7XG5cdFx0XHR0aGlzLm1vdmVDYXJldChpZGxlbik7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImFkZCBjb2xvbj9cIlxuXHRcdFx0dGhpcy50b2tlbignOicsJzonLGNvbG9uLmxlbmd0aCk7XG5cdFx0XHR0aGlzLm1vdmVDYXJldCgtaWRsZW4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRva2VuKHR5cCxpZCxpZGxlbik7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbGVuO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBudW1iZXJzLCBpbmNsdWRpbmcgZGVjaW1hbHMsIGhleCwgYW5kIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuXHQvLyBCZSBjYXJlZnVsIG5vdCB0byBpbnRlcmZlcmUgd2l0aCByYW5nZXMtaW4tcHJvZ3Jlc3MuXG5cdExleGVyLnByb3RvdHlwZS5udW1iZXJUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBiaW5hcnlMaXRlcmFsO1xuXHRcdHZhciBtYXRjaCxudW1iZXIsbGV4ZWRMZW5ndGg7XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBOVU1CRVIuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0bnVtYmVyID0gbWF0Y2hbMF07XG5cdFx0bGV4ZWRMZW5ndGggPSBudW1iZXIubGVuZ3RoO1xuXHRcdFxuXHRcdGlmIChiaW5hcnlMaXRlcmFsID0gLzBiKFswMV0rKS8uZXhlYyhudW1iZXIpKSB7XG5cdFx0XHRcblx0XHRcdG51bWJlciA9IFwiXCIgKyBwYXJzZUludChiaW5hcnlMaXRlcmFsWzFdLDIpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XG5cdFx0aWYgKG1hdGNoWzBdWzBdID09ICcuJyAmJiBwcmV2ICYmICFwcmV2LnNwYWNlZCAmJiBbJ0lERU5USUZJRVInLCcpJywnfScsJ10nLCdOVU1CRVInXS5pbmRleE9mKHRUKHByZXYpKSA+PSAwKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImdvdCBoZXJlXCJcblx0XHRcdHRoaXMudG9rZW4oXCIuXCIsXCIuXCIpO1xuXHRcdFx0bnVtYmVyID0gbnVtYmVyLnN1YnN0cigxKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRoaXMudG9rZW4oJ05VTUJFUicsbnVtYmVyLGxleGVkTGVuZ3RoKTtcblx0XHRyZXR1cm4gbGV4ZWRMZW5ndGg7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuc3ltYm9sVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsc3ltYm9sLHByZXY7XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBTWU1CT0wuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0c3ltYm9sID0gbWF0Y2hbMF0uc3Vic3RyKDEpO1xuXHRcdHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XG5cdFx0Ly8gaXMgdGhpcyBhIHByb3BlcnR5LWFjY2Vzcz9cblx0XHQvLyBzaG91bGQgaW52ZXJ0IHRoaXMgLS0gb25seSBhbGxvdyB3aGVuIHByZXYgSVMgLi4gXG5cdFx0XG5cdFx0Ly8gOiBzaG91bGQgYmUgYSB0b2tlbiBpdHNlbGYsIHdpdGggYSBzcGVjaWZpY2F0aW9uIG9mIHNwYWNpbmcgKExSLFIsTCxOT05FKVxuXHRcdFxuXHRcdC8vIEZJWFxuXHRcdGlmIChwcmV2ICYmICFwcmV2LnNwYWNlZCAmJiBpZHgkKHRUKHByZXYpLFsnKCcsJ3snLCdbJywnLicsJ0NBTExfU1RBUlQnLCdJTkRFWF9TVEFSVCcsJywnLCc9JywnSU5ERU5UJywnVEVSTUlOQVRPUiddKSA9PSAtMSkge1xuXHRcdFx0dGhpcy50b2tlbignLjonLCc6JywxKTtcblx0XHRcdHZhciBzeW0gPSBzeW1ib2wuc3BsaXQoL1tcXDpcXFxcXFwvXS8pWzBdOyAvLyByZWFsbHk/XG5cdFx0XHQvLyB0b2tlbiAnU1lNQk9MJywgXCInI3tzeW1ib2x9J1wiXG5cdFx0XHR0aGlzLnRva2VuKCdJREVOVElGSUVSJyxzeW0sc3ltLmxlbmd0aCwxKTtcblx0XHRcdHJldHVybiAoc3ltLmxlbmd0aCArIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB0b2tlbiAnU1lNQk9MJywgXCInI3tzeW1ib2x9J1wiXG5cdFx0XHR0aGlzLnRva2VuKCdTWU1CT0wnLHN5bWJvbCxtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHR9O1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmVzY2FwZVN0ciA9IGZ1bmN0aW9uIChzdHIsaGVyZWRvYyxxKXtcblx0XHRzdHIgPSBzdHIucmVwbGFjZShNVUxUSUxJTkVSLChoZXJlZG9jID8gKCdcXFxcbicpIDogKCcnKSkpO1xuXHRcdGlmIChxKSB7XG5cdFx0XHR2YXIgciA9IFJlZ0V4cCgoXCJcXFxcXFxcXFtcIiArIHEgKyBcIl1cIiksXCJnXCIpO1xuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UocixxKTtcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKFJlZ0V4cCgoXCJcIiArIHEpLFwiZ1wiKSwnXFxcXCQmJyk7XG5cdFx0fTtcblx0XHRyZXR1cm4gc3RyO1xuXHRcdFxuXHRcdC8vIHN0ciA9IHN0ci5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcbicpXG5cdFx0Ly8gc3RyID0gc3RyLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKVxuXHR9O1xuXHQvLyBNYXRjaGVzIHN0cmluZ3MsIGluY2x1ZGluZyBtdWx0aS1saW5lIHN0cmluZ3MuIEVuc3VyZXMgdGhhdCBxdW90YXRpb24gbWFya3Ncblx0Ly8gYXJlIGJhbGFuY2VkIHdpdGhpbiB0aGUgc3RyaW5nJ3MgY29udGVudHMsIGFuZCB3aXRoaW4gbmVzdGVkIGludGVycG9sYXRpb25zLlxuXHRMZXhlci5wcm90b3R5cGUuc3RyaW5nVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsc3RyaW5nO1xuXHRcdFxuXHRcdHN3aXRjaCAodGhpcy5fY2h1bmsuY2hhckF0KDApKSB7XG5cdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHRpZiAoIShtYXRjaCA9IFNJTVBMRVNUUi5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcdFx0c3RyaW5nID0gbWF0Y2hbMF07XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1NUUklORycsdGhpcy5lc2NhcGVTdHIoc3RyaW5nKSxzdHJpbmcubGVuZ3RoKTtcblx0XHRcdFx0Ly8gdG9rZW4gJ1NUUklORycsIChzdHJpbmcgPSBtYXRjaFswXSkucmVwbGFjZShNVUxUSUxJTkVSLCAnXFxcXFxcbicpLCBzdHJpbmc6bGVuZ3RoXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHRjYXNlICdcIic6XG5cdFx0XHRcdGlmICghKHN0cmluZyA9IHRoaXMuYmFsYW5jZWRTdHJpbmcodGhpcy5fY2h1bmssJ1wiJykpKSB7IHJldHVybiAwIH07XG5cdFx0XHRcdC8vIHdoYXQgYWJvdXQgdHJpcGUgcXVvdGVkIHN0cmluZ3M/XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3RyaW5nLmluZGV4T2YoJ3snKSA+PSAwKSB7XG5cdFx0XHRcdFx0dmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyBoYXMgbm8gaW50ZXJwb2xhdGlvbj9cblx0XHRcdFx0XHQvLyB3ZSBhcmUgbm93IG1lc3Npbmcgd2l0aCBsb2NhdGlvbnMgLSBiZXdhcmVcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTVFJJTkdfU1RBUlQnLHN0cmluZy5jaGFyQXQoMCksMSk7XG5cdFx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVN0cmluZyhzdHJpbmcuc2xpY2UoMSwtMSkpO1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NUUklOR19FTkQnLHN0cmluZy5jaGFyQXQobGVuIC0gMSksMSxzdHJpbmcubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGVuID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0XHQvLyBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShNVUxUSUxJTkVSLCAnXFxcXFxcbicpXG5cdFx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HJyx0aGlzLmVzY2FwZVN0cihzdHJpbmcpLGxlbik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFxuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5tb3ZlSGVhZChzdHJpbmcpO1xuXHRcdHJldHVybiBzdHJpbmcubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBoZXJlZG9jcywgYWRqdXN0aW5nIGluZGVudGF0aW9uIHRvIHRoZSBjb3JyZWN0IGxldmVsLCBhcyBoZXJlZG9jc1xuXHQvLyBwcmVzZXJ2ZSB3aGl0ZXNwYWNlLCBidXQgaWdub3JlIGluZGVudGF0aW9uIHRvIHRoZSBsZWZ0LlxuXHRMZXhlci5wcm90b3R5cGUuaGVyZWRvY1Rva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLGhlcmVkb2MscXVvdGUsZG9jO1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gSEVSRURPQy5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHRoZXJlZG9jID0gbWF0Y2hbMF07XG5cdFx0cXVvdGUgPSBoZXJlZG9jLmNoYXJBdCgwKTtcblx0XHRkb2MgPSB0aGlzLnNhbml0aXplSGVyZWRvYyhtYXRjaFsyXSx7cXVvdGU6IHF1b3RlLGluZGVudDogbnVsbH0pO1xuXHRcdC8vIGNvbnNvbGUubG9nIFwiZm91bmQgaGVyZWRvYyB7bWF0Y2hbMF06bGVuZ3RofSB7ZG9jOmxlbmd0aH1cIlxuXHRcdFxuXHRcdGlmIChxdW90ZSA9PSAnXCInICYmIGRvYy5pbmRleE9mKCd7JykgPj0gMCkge1xuXHRcdFx0dmFyIG9wZW4gPSBtYXRjaFsxXTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIGRvYy5zdWJzdHIoMCwzKSxtYXRjaFsxXVxuXHRcdFx0dGhpcy50b2tlbignU1RSSU5HX1NUQVJUJyxvcGVuLG9wZW4ubGVuZ3RoKTtcblx0XHRcdHRoaXMuaW50ZXJwb2xhdGVTdHJpbmcoZG9jLHtoZXJlZG9jOiB0cnVlLG9mZnNldDogb3Blbi5sZW5ndGgscXVvdGU6IHF1b3RlfSk7XG5cdFx0XHR0aGlzLnRva2VuKCdTVFJJTkdfRU5EJyxvcGVuLG9wZW4ubGVuZ3RoLGhlcmVkb2MubGVuZ3RoIC0gb3Blbi5sZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRva2VuKCdTVFJJTkcnLHRoaXMubWFrZVN0cmluZyhkb2MscXVvdGUsdHJ1ZSksMCk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLm1vdmVIZWFkKGhlcmVkb2MpO1xuXHRcdHJldHVybiBoZXJlZG9jLmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgYW5kIGNvbnN1bWVzIGNvbW1lbnRzLlxuXHRMZXhlci5wcm90b3R5cGUuY29tbWVudFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLGxlbmd0aCxjb21tZW50LGluZGVudCxwcmV2O1xuXHRcdFxuXHRcdHZhciB0eXAgPSAnSEVSRUNPTU1FTlQnO1xuXHRcdFxuXHRcdGlmIChtYXRjaCA9IElOTElORV9DT01NRU5ULmV4ZWModGhpcy5fY2h1bmspKSB7IC8vIC5tYXRjaChJTkxJTkVfQ09NTUVOVClcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwibWF0Y2ggaW5saW5lIGNvbW1lbnRcIlxuXHRcdFx0bGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0aW5kZW50ID0gbWF0Y2hbMV07XG5cdFx0XHRjb21tZW50ID0gbWF0Y2hbMl07XG5cdFx0XHRcblx0XHRcdHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XHR2YXIgcHQgPSBwcmV2ICYmIHRUKHByZXYpO1xuXHRcdFx0dmFyIG5vdGUgPSAnLy8nICsgY29tbWVudC5zdWJzdHIoMSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9sYXN0ICYmIHRoaXMuX2xhc3Quc3BhY2VkKSB7XG5cdFx0XHRcdG5vdGUgPSAnICcgKyBub3RlO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcInRoZSBwcmV2aW91cyBub2RlIHdhcyBTUEFDRURcIlxuXHRcdFx0fTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiY29tbWVudCB7bm90ZX0gLSBpbmRlbnQoe2luZGVudH0pIC0ge2xlbmd0aH0ge2NvbW1lbnQ6bGVuZ3RofVwiXG5cdFx0XHRcblx0XHRcdGlmICgocHQgJiYgcHQgIT0gJ0lOREVOVCcgJiYgcHQgIT0gJ1RFUk1JTkFUT1InKSB8fCAhcHQpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJza2lwIGNvbW1lbnRcIlxuXHRcdFx0XHQvLyB0b2tlbiAnSU5MSU5FQ09NTUVOVCcsIGNvbW1lbnQuc3Vic3RyKDIpXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkaW5nIGFzIHRlcm1pbmF0b3JcIlxuXHRcdFx0XHR0aGlzLnRva2VuKCdURVJNSU5BVE9SJyxub3RlLGxlbmd0aCk7IC8vICsgJ1xcbidcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkIGNvbW1lbnQgKHtub3RlfSlcIlxuXHRcdFx0XHRpZiAocHQgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdFx0dFZzKHByZXYsdFYocHJldikgKyBub3RlKTtcblx0XHRcdFx0XHQvLyBwcmV2WzFdICs9IG5vdGVcblx0XHRcdFx0fSBlbHNlIGlmIChwdCA9PSAnSU5ERU5UJykge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkaW5nIGNvbW1lbnQgdG8gSU5ERU5UOiB7bm90ZX1cIiAjIHdoeSBub3QgYWRkIGRpcmVjdGx5IGhlcmU/XG5cdFx0XHRcdFx0dGhpcy5hZGRMaW5lYnJlYWtzKDEsbm90ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJjb21tZW50IGhlcmVcIlxuXHRcdFx0XHRcdC8vIHNob3VsZCB3ZSBldmVyIGdldCBoZXJlP1xuXHRcdFx0XHRcdHRoaXMudG9rZW4odHlwLGNvbW1lbnQuc3Vic3RyKDIpLGxlbmd0aCk7IC8vIGFyZSB3ZSBzdXJlP1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxlbmd0aDsgLy8gZGlzYWJsZSBub3cgd2hpbGUgY29tcGlsaW5nXG5cdFx0fTtcblx0XHRcblx0XHQvLyBzaG91bGQgdXNlIGV4ZWM/XG5cdFx0aWYgKCEobWF0Y2ggPSBDT01NRU5ULmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdGNvbW1lbnQgPSBtYXRjaFswXTtcblx0XHR2YXIgaGVyZSA9IG1hdGNoWzFdO1xuXHRcdFxuXHRcdGlmIChoZXJlKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdIRVJFQ09NTUVOVCcsdGhpcy5zYW5pdGl6ZUhlcmVkb2MoaGVyZSx7aGVyZWNvbW1lbnQ6IHRydWUsaW5kZW50OiBBcnJheSh0aGlzLl9pbmRlbnQgKyAxKS5qb2luKCcgJyl9KSxjb21tZW50Lmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKCdURVJNSU5BVE9SJywnXFxuJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudG9rZW4oJ0hFUkVDT01NRU5UJyxjb21tZW50LGNvbW1lbnQubGVuZ3RoKTtcblx0XHRcdHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLCdcXG4nKTsgLy8gYXV0bz8gcmVhbGx5P1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5tb3ZlSGVhZChjb21tZW50KTtcblx0XHRyZXR1cm4gY29tbWVudC5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIEphdmFTY3JpcHQgaW50ZXJwb2xhdGVkIGRpcmVjdGx5IGludG8gdGhlIHNvdXJjZSB2aWEgYmFja3RpY2tzLlxuXHRMZXhlci5wcm90b3R5cGUuanNUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxzY3JpcHQ7XG5cdFx0XG5cdFx0aWYgKCEodGhpcy5fY2h1bmsuY2hhckF0KDApID09ICdgJyAmJiAobWF0Y2ggPSBKU1RPS0VOLmV4ZWModGhpcy5fY2h1bmspKSkpIHsgcmV0dXJuIDAgfTtcblx0XHR0aGlzLnRva2VuKCdKUycsKHNjcmlwdCA9IG1hdGNoWzBdKS5zbGljZSgxLC0xKSk7XG5cdFx0cmV0dXJuIHNjcmlwdC5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFscy4gTGV4aW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMgaXMgZGlmZmljdWx0XG5cdC8vIHRvIGRpc3Rpbmd1aXNoIGZyb20gZGl2aXNpb24sIHNvIHdlIGJvcnJvdyBzb21lIGJhc2ljIGhldXJpc3RpY3MgZnJvbVxuXHQvLyBKYXZhU2NyaXB0IGFuZCBSdWJ5LlxuXHRMZXhlci5wcm90b3R5cGUucmVnZXhUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhcnk7XG5cdFx0dmFyIG1hdGNoLGxlbmd0aCxwcmV2O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9jaHVuay5jaGFyQXQoMCkgIT0gJy8nKSB7IHJldHVybiAwIH07XG5cdFx0aWYgKG1hdGNoID0gSEVSRUdFWC5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0bGVuZ3RoID0gdGhpcy5oZXJlZ2V4VG9rZW4obWF0Y2gpO1xuXHRcdFx0dGhpcy5tb3ZlSGVhZChtYXRjaFswXSk7XG5cdFx0XHRyZXR1cm4gbGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHQvLyBGSVhcblx0XHRpZiAocHJldiAmJiAoaWR4JCh0VChwcmV2KSwocHJldi5zcGFjZWQgPyAoXG5cdFx0XHROT1RfUkVHRVhcblx0XHQpIDogKFxuXHRcdFx0Tk9UX1NQQUNFRF9SRUdFWFxuXHRcdCkpKSA+PSAwKSkgeyByZXR1cm4gMCB9O1xuXHRcdGlmICghKG1hdGNoID0gUkVHRVguZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKG1hdGNoKTt2YXIgbSA9IGFyeVswXSxyZWdleCA9IGFyeVsxXSxmbGFncyA9IGFyeVsyXTtcblx0XHRcblx0XHQvLyBGSVhNRVxuXHRcdC8vIGlmIHJlZ2V4Wy4uMV0gaXMgJy8qJ1xuXHRcdC8vXHRlcnJvciAncmVndWxhciBleHByZXNzaW9ucyBjYW5ub3QgYmVnaW4gd2l0aCBgKmAnXG5cdFx0XG5cdFx0aWYgKHJlZ2V4ID09ICcvLycpIHtcblx0XHRcdHJlZ2V4ID0gJy8oPzopLyc7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRva2VuKCdSRUdFWCcsKFwiXCIgKyByZWdleCArIGZsYWdzKSxtLmxlbmd0aCk7XG5cdFx0cmV0dXJuIG0ubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBtdWx0aWxpbmUgZXh0ZW5kZWQgcmVndWxhciBleHByZXNzaW9ucy5cblx0Ly8gVGhlIGVzY2FwaW5nIHNob3VsZCByYXRoZXIgaGFwcGVuIGluIEFTVCAtIHBvc3NpYmx5IGFzIGFuIGFkZGl0aW9uYWwgZmxhZz9cblx0TGV4ZXIucHJvdG90eXBlLmhlcmVnZXhUb2tlbiA9IGZ1bmN0aW9uIChtYXRjaCl7XG5cdFx0dmFyIGFyeTtcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBoZXJlZ2V4ID0gYXJ5WzBdLGJvZHkgPSBhcnlbMV0sZmxhZ3MgPSBhcnlbMl07XG5cdFx0XG5cdFx0aWYgKDAgPiBib2R5LmluZGV4T2YoJyN7JykpIHtcblx0XHRcdFxuXHRcdFx0dmFyIHJlID0gYm9keS5yZXBsYWNlKEhFUkVHRVhfT01JVCwnJykucmVwbGFjZSgvXFwvL2csJ1xcXFwvJyk7XG5cdFx0XHRcblx0XHRcdGlmIChyZS5tYXRjaCgvXlxcKi8pKSB7XG5cdFx0XHRcdHRoaXMuZXJyb3IoJ3JlZ3VsYXIgZXhwcmVzc2lvbnMgY2Fubm90IGJlZ2luIHdpdGggYCpgJyk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLnRva2VuKCdSRUdFWCcsKFwiL1wiICsgKHJlIHx8ICcoPzopJykgKyBcIi9cIiArIGZsYWdzKSxoZXJlZ2V4Lmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gaGVyZWdleC5sZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB1c2UgbW9yZSBiYXNpYyByZWdleCB0eXBlXG5cdFx0XG5cdFx0dGhpcy50b2tlbignQ09OU1QnLCdSZWdFeHAnKTtcblx0XHR0aGlzLl90b2tlbnMucHVzaChULnRva2VuKCdDQUxMX1NUQVJUJywnKCcsMCkpO1xuXHRcdHZhciB0b2tlbnMgPSBbXTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgaXRlbXMgPSBpdGVyJCh0aGlzLmludGVycG9sYXRlU3RyaW5nKGJvZHkse3JlZ2V4OiB0cnVlfSkpLCBsZW4gPSBpdGVtcy5sZW5ndGgsIHBhaXI7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XG5cdFx0XHRwYWlyID0gaXRlbXNbaV07XG5cdFx0XHR2YXIgdG9rID0gdFQocGFpcik7IC8vIEZJWFxuXHRcdFx0dmFyIHZhbHVlID0gdFYocGFpcik7IC8vIEZJWFxuXHRcdFx0XG5cdFx0XHRpZiAodG9rID09ICdUT0tFTlMnKSB7XG5cdFx0XHRcdC8vIEZJWE1FIHdoYXQgaXMgdGhpcz9cblx0XHRcdFx0dG9rZW5zLnB1c2guYXBwbHkodG9rZW5zLHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghdmFsdWUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIndoYXQ/P1wiKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghKHZhbHVlID0gdmFsdWUucmVwbGFjZShIRVJFR0VYX09NSVQsJycpKSkgeyBjb250aW51ZTsgfTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCdcXFxcXFxcXCcpO1xuXHRcdFx0XHR0b2tlbnMucHVzaChULnRva2VuKCdTVFJJTkcnLHRoaXMubWFrZVN0cmluZyh2YWx1ZSwnXCInLHRydWUpLDApKTsgLy8gRklYXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0b2tlbnMucHVzaChULnRva2VuKCcrJywnKycsMCkpOyAvLyBGSVhcblx0XHR9O1xuXHRcdFxuXHRcdHRva2Vucy5wb3AoKTtcblx0XHRcblx0XHQvLyBGSVhcblx0XHRpZiAoISh0b2tlbnNbMF0gJiYgdFQodG9rZW5zWzBdKSA9PSAnU1RSSU5HJykpIHtcblx0XHRcdC8vIEZJWFxuXHRcdFx0dGhpcy5fdG9rZW5zLnB1c2goVC50b2tlbignU1RSSU5HJywnXCJcIicpLFQudG9rZW4oJysnLCcrJykpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fdG9rZW5zLnB1c2guYXBwbHkodGhpcy5fdG9rZW5zLHRva2Vucyk7IC8vIHdoYXQgaXMgdGhpcz9cblx0XHQvLyBGSVhcblx0XHRcblx0XHRpZiAoZmxhZ3MpIHtcblx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKFQudG9rZW4oJywnLCcsJywwKSk7XG5cdFx0XHR0aGlzLl90b2tlbnMucHVzaChULnRva2VuKCdTVFJJTkcnLCdcIicgKyBmbGFncyArICdcIicsMCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy50b2tlbignKScsJyknLDApO1xuXHRcdFxuXHRcdHJldHVybiBoZXJlZ2V4Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgbmV3bGluZXMsIGluZGVudHMsIGFuZCBvdXRkZW50cywgYW5kIGRldGVybWluZXMgd2hpY2ggaXMgd2hpY2guXG5cdC8vIElmIHdlIGNhbiBkZXRlY3QgdGhhdCB0aGUgY3VycmVudCBsaW5lIGlzIGNvbnRpbnVlZCBvbnRvIHRoZSB0aGUgbmV4dCBsaW5lLFxuXHQvLyB0aGVuIHRoZSBuZXdsaW5lIGlzIHN1cHByZXNzZWQ6XG5cdC8vXG5cdC8vICAgICBlbGVtZW50c1xuXHQvLyAgICAgICAuZWFjaCggLi4uIClcblx0Ly8gICAgICAgLm1hcCggLi4uIClcblx0Ly9cblx0Ly8gS2VlcHMgdHJhY2sgb2YgdGhlIGxldmVsIG9mIGluZGVudGF0aW9uLCBiZWNhdXNlIGEgc2luZ2xlIG91dGRlbnQgdG9rZW5cblx0Ly8gY2FuIGNsb3NlIG11bHRpcGxlIGluZGVudHMsIHNvIHdlIG5lZWQgdG8ga25vdyBob3cgZmFyIGluIHdlIGhhcHBlbiB0byBiZS5cblx0TGV4ZXIucHJvdG90eXBlLmxpbmVUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaDtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IE1VTFRJX0RFTlQuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0Ly8gc2hvdWxkIGl0IG5vdCBwYWlyIGJ5IGl0c2VsZiB0b2tlbignU0VMRUNUT1JfRU5EJywnJScsMClcblx0XHQvLyBpZiBAZW5kID09ICclJ1xuXHRcdC8vIFx0Y29uc29sZS5sb2cgXCJwYWlyaW5nIHNlbGVjdG9yIGluIGxpbmVUb2tlbiB7QGNodW5rLnN1YnN0cigwLDEwKX1cIlxuXHRcdC8vIFx0IyBzaG91bGQgbm90IG5lZWQgdG8gYWRkIGFueXRoaW5nIGhlcmU/XG5cdFx0Ly8gXHRwYWlyKCclJylcblx0XHRcblx0XHR2YXIgaW5kZW50ID0gbWF0Y2hbMF07XG5cdFx0Ly8gdmFyIGJyQ291bnQgPSBjb3VudCBpbmRlbnQsICdcXG4nXG5cdFx0dmFyIGJyQ291bnQgPSB0aGlzLm1vdmVIZWFkKGluZGVudCk7XG5cdFx0dGhpcy5fc2VlbkZvciA9IGZhbHNlO1xuXHRcdC8vIHJlc2V0IGNvbHVtbiBhcyB3ZWxsP1xuXHRcdFxuXHRcdHZhciBwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMsMSk7XG5cdFx0dmFyIHNpemUgPSBpbmRlbnQubGVuZ3RoIC0gMSAtIGluZGVudC5sYXN0SW5kZXhPZignXFxuJyk7XG5cdFx0dmFyIG5vTmV3bGluZXMgPSB0aGlzLnVuZmluaXNoZWQoKTtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyBcIm5vTmV3bGluZXNcIixub05ld2xpbmVzXG5cdFx0Ly8gY29uc29sZS5sb2cgXCJsaW5lVG9rZW4gLS0gXCIsQGNodW5rLnN1YnN0cigwLDEwKSxcIi0tXCJcblx0XHRpZiAoKC9eXFxuI1xccy8pLnRlc3QodGhpcy5fY2h1bmspKSB7XG5cdFx0XHR0aGlzLmFkZExpbmVicmVha3MoMSk7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChzaXplIC0gdGhpcy5faW5kZWJ0ID09IHRoaXMuX2luZGVudCkge1xuXHRcdFx0aWYgKG5vTmV3bGluZXMpIHtcblx0XHRcdFx0dGhpcy5zdXBwcmVzc05ld2xpbmVzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5ld2xpbmVUb2tlbihickNvdW50KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaW5kZW50Lmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChzaXplID4gdGhpcy5faW5kZW50KSB7XG5cdFx0XHRpZiAobm9OZXdsaW5lcykge1xuXHRcdFx0XHR0aGlzLl9pbmRlYnQgPSBzaXplIC0gdGhpcy5faW5kZW50O1xuXHRcdFx0XHR0aGlzLnN1cHByZXNzTmV3bGluZXMoKTtcblx0XHRcdFx0cmV0dXJuIGluZGVudC5sZW5ndGg7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pblRhZygpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiaW5kZW50IGluc2lkZSB0b2tpZD8hP1wiXG5cdFx0XHRcdC8vIEBpbmRlYnQgPSBzaXplIC0gQGluZGVudFxuXHRcdFx0XHQvLyBzdXBwcmVzc05ld2xpbmVzKClcblx0XHRcdFx0cmV0dXJuIGluZGVudC5sZW5ndGg7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHZhciBkaWZmID0gc2l6ZSAtIHRoaXMuX2luZGVudCArIHRoaXMuX291dGRlYnQ7XG5cdFx0XHR0aGlzLmNsb3NlRGVmKCk7XG5cdFx0XHRcblx0XHRcdHZhciBpbW1lZGlhdGUgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XHRcblx0XHRcdGlmIChpbW1lZGlhdGUgJiYgdFQoaW1tZWRpYXRlKSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0dFRzKGltbWVkaWF0ZSwnSU5ERU5UJyk7XG5cdFx0XHRcdGltbWVkaWF0ZS5fbWV0YSB8fCAoaW1tZWRpYXRlLl9tZXRhID0ge3ByZTogdFYoaW1tZWRpYXRlKSxwb3N0OiAnJ30pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gc2hvdWxkIHJhdGhlciBhZGQgdG8gbWV0YSBzb21laG93PyE/XG5cdFx0XHRcdC8vIHRWcyhpbW1lZGlhdGUsdFYoaW1tZWRpYXRlKSArICclfCUnKSAjIGNyYXp5XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdJTkRFTlQnLFwiXCIgKyBkaWZmLDApO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJpbmRlbnRpbmdcIiwgcHJldiwgbGFzdChAdG9rZW5zLDEpXG5cdFx0XHQvLyBpZiBwcmV2IGFuZCBwcmV2WzBdID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0Ly8gICBjb25zb2xlLmxvZyBcInRlcm1pbmF0b3IgYmVmb3JlIGluZGVudD8/XCJcblx0XHRcdFxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNvbW1lbnRzIGFzIHdlbGwgP1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9pbmRlbnRzLnB1c2goZGlmZik7XG5cdFx0XHR0aGlzLnB1c2hFbmQoJ09VVERFTlQnKTtcblx0XHRcdC8vIEBlbmRzLnB1c2ggJ09VVERFTlQnXG5cdFx0XHR0aGlzLl9vdXRkZWJ0ID0gdGhpcy5faW5kZWJ0ID0gMDtcblx0XHRcdHRoaXMuYWRkTGluZWJyZWFrcyhickNvdW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faW5kZWJ0ID0gMDtcblx0XHRcdHRoaXMub3V0ZGVudFRva2VuKHRoaXMuX2luZGVudCAtIHNpemUsbm9OZXdsaW5lcyxickNvdW50KTtcblx0XHRcdHRoaXMuYWRkTGluZWJyZWFrcyhickNvdW50IC0gMSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcIm91dGRlbnRcIixub05ld2xpbmVzLHRva2lkKClcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX2luZGVudCA9IHNpemU7XG5cdFx0cmV0dXJuIGluZGVudC5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBSZWNvcmQgYW4gb3V0ZGVudCB0b2tlbiBvciBtdWx0aXBsZSB0b2tlbnMsIGlmIHdlIGhhcHBlbiB0byBiZSBtb3ZpbmcgYmFja1xuXHQvLyBpbndhcmRzIHBhc3Qgc2V2ZXJhbCByZWNvcmRlZCBpbmRlbnRzLlxuXHRMZXhlci5wcm90b3R5cGUub3V0ZGVudFRva2VuID0gZnVuY3Rpb24gKG1vdmVPdXQsbm9OZXdsaW5lcyxuZXdsaW5lQ291bnQpe1xuXHRcdC8vIGhlcmUgd2Ugc2hvdWxkIGFsc28gdGFrZSBjYXJlIHRvIHBvcCAvIHJlc2V0IHRoZSBzY29wZS1ib2R5XG5cdFx0Ly8gb3IgY29udGV4dC10eXBlIGZvciBpbmRlbnRhdGlvbiBcblx0XHR2YXIgZGVudCA9IDA7XG5cdFx0d2hpbGUgKG1vdmVPdXQgPiAwKXtcblx0XHRcdHZhciBsZW4gPSB0aGlzLl9pbmRlbnRzLmxlbmd0aCAtIDE7XG5cdFx0XHRpZiAodGhpcy5faW5kZW50c1tsZW5dID09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRtb3ZlT3V0ID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5faW5kZW50c1tsZW5dID09IHRoaXMuX291dGRlYnQpIHtcblx0XHRcdFx0bW92ZU91dCAtPSB0aGlzLl9vdXRkZWJ0O1xuXHRcdFx0XHR0aGlzLl9vdXRkZWJ0ID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5faW5kZW50c1tsZW5dIDwgdGhpcy5fb3V0ZGVidCkge1xuXHRcdFx0XHR0aGlzLl9vdXRkZWJ0IC09IHRoaXMuX2luZGVudHNbbGVuXTtcblx0XHRcdFx0bW92ZU91dCAtPSB0aGlzLl9pbmRlbnRzW2xlbl07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZW50ID0gdGhpcy5faW5kZW50cy5wb3AoKSAtIHRoaXMuX291dGRlYnQ7XG5cdFx0XHRcdG1vdmVPdXQgLT0gZGVudDtcblx0XHRcdFx0dGhpcy5fb3V0ZGVidCA9IDA7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIW5vTmV3bGluZXMpIHsgdGhpcy5hZGRMaW5lYnJlYWtzKDEpIH07XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnBhaXIoJ09VVERFTlQnKTtcblx0XHRcdFx0dGhpcy50b2tlbignT1VUREVOVCcsXCJcIiArIGRlbnQsMCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGRlbnQpIHsgdGhpcy5fb3V0ZGVidCAtPSBtb3ZlT3V0IH07XG5cdFx0XG5cdFx0d2hpbGUgKHRoaXMubGFzdFRva2VuVmFsdWUoKSA9PSAnOycpe1xuXHRcdFx0dGhpcy5fdG9rZW5zLnBvcCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCEodGhpcy5sYXN0VG9rZW5UeXBlKCkgPT0gJ1RFUk1JTkFUT1InIHx8IG5vTmV3bGluZXMpKSB7IHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLCdcXG4nLDApIH07XG5cdFx0XG5cdFx0Ly8gY2FwcGluZyBzY29wZXMgc28gdGhleSBkb250IGhhbmcgYXJvdW5kIFxuXHRcdHRoaXMuX3Njb3Blcy5sZW5ndGggPSB0aGlzLl9pbmRlbnRzLmxlbmd0aDtcblx0XHRcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0KCk7XG5cdFx0aWYgKGN0eCA9PSAnJScgfHwgY3R4ID09ICdUQUcnKSB7IHRoaXMucGFpcihjdHgpIH07IC8vIHJlYWxseT9cblx0XHR0aGlzLmNsb3NlRGVmKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGFuZCBjb25zdW1lcyBub24tbWVhbmluZ2Z1bCB3aGl0ZXNwYWNlLiB0b2tpZCB0aGUgcHJldmlvdXMgdG9rZW5cblx0Ly8gYXMgYmVpbmcgXCJzcGFjZWRcIiwgYmVjYXVzZSB0aGVyZSBhcmUgc29tZSBjYXNlcyB3aGVyZSBpdCBtYWtlcyBhIGRpZmZlcmVuY2UuXG5cdExleGVyLnByb3RvdHlwZS53aGl0ZXNwYWNlVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsbmxpbmUscHJldjtcblx0XHRpZiAoISgobWF0Y2ggPSBXSElURVNQQUNFLmV4ZWModGhpcy5fY2h1bmspKSB8fCAobmxpbmUgPSB0aGlzLl9jaHVuay5jaGFyQXQoMCkgPT0gJ1xcbicpKSkgeyByZXR1cm4gMCB9O1xuXHRcdHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XG5cdFx0Ly8gRklYIC0gd2h5IG9oIHdoeT9cblx0XHRpZiAocHJldikge1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdHByZXYuc3BhY2VkID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXYubmV3TGluZSA9IHRydWU7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmFkZE5ld2xpbmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy50b2tlbignVEVSTUlOQVRPUicsJ1xcbicpO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLm1vdmVIZWFkID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0dmFyIGJyID0gY291bnQoc3RyLCdcXG4nKTtcblx0XHRyZXR1cm4gYnI7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLmFkZExpbmVicmVha3MgPSBmdW5jdGlvbiAoY291bnQscmF3KXtcblx0XHR2YXIgYnI7XG5cdFx0XG5cdFx0aWYgKCFyYXcgJiYgY291bnQgPT0gMCkgeyByZXR1cm4gdGhpcyB9OyAvLyBubyB0ZXJtaW5hdG9ycz9cblx0XHRcblx0XHR2YXIgcHJldiA9IHRoaXMuX2xhc3Q7XG5cdFx0XG5cdFx0aWYgKCFyYXcpIHtcblx0XHRcdGlmIChjb3VudCA9PSAxKSB7XG5cdFx0XHRcdGJyID0gJ1xcbic7XG5cdFx0XHR9IGVsc2UgaWYgKGNvdW50ID09IDIpIHtcblx0XHRcdFx0YnIgPSAnXFxuXFxuJztcblx0XHRcdH0gZWxzZSBpZiAoY291bnQgPT0gMykge1xuXHRcdFx0XHRiciA9ICdcXG5cXG5cXG4nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnIgPSByZXBlYXRTdHJpbmcoJ1xcbicsY291bnQpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIEZJWFxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHR2YXIgdCA9IHByZXYuX3R5cGU7IC8vIEBsYXN0VHlwXG5cdFx0XHR2YXIgdiA9IHRWKHByZXYpO1xuXHRcdFx0XG5cdFx0XHQvLyB3ZSByZWFsbHkgd2FudCB0byBhZGQgdGhpc1xuXHRcdFx0aWYgKHQgPT0gJ0lOREVOVCcpIHtcblx0XHRcdFx0Ly8gVE9ETyB3ZSB3YW50IHRvIGFkZCB0byB0aGUgaW5kZW50XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkIHRoZSBjb21tZW50IHRvIHRoZSBpbmRlbnQgLS0gcHJlPyB7cmF3fSB7YnJ9XCJcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBtZXRhID0gcHJldi5fbWV0YSB8fCAocHJldi5fbWV0YSA9IHtwcmU6ICcnLHBvc3Q6ICcnfSk7XG5cdFx0XHRcdG1ldGEucG9zdCArPSAocmF3IHx8IGJyKTtcblx0XHRcdFx0Ly8gdFZzKHYgKyAocmF3IG9yIGJyKSlcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWxyZWFkeSBleGlzdHMgdGVybWluYXRvciB7YnJ9IHtyYXd9XCJcblx0XHRcdFx0dFZzKHByZXYsdiArIChyYXcgfHwgYnIpKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy50b2tlbignVEVSTUlOQVRPUicsYnIsMCk7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gR2VuZXJhdGUgYSBuZXdsaW5lIHRva2VuLiBDb25zZWN1dGl2ZSBuZXdsaW5lcyBnZXQgbWVyZ2VkIHRvZ2V0aGVyLlxuXHRMZXhlci5wcm90b3R5cGUubmV3bGluZVRva2VuID0gZnVuY3Rpb24gKGxpbmVzKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcIm5ld2xpbmVUb2tlblwiXG5cdFx0d2hpbGUgKHRoaXMubGFzdFRva2VuVmFsdWUoKSA9PSAnOycpe1xuXHRcdFx0Y29uc29sZS5sb2coXCJwb3AgdG9rZW5cIix0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdKTtcblx0XHRcdHRoaXMuX3Rva2Vucy5wb3AoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuYWRkTGluZWJyZWFrcyhsaW5lcyk7XG5cdFx0XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dCgpO1xuXHRcdC8vIFdBUk4gbm93IGltcG9ydCBjYW5ub3QgZ28gb3ZlciBtdWx0aXBsZSBsaW5lc1xuXHRcdGlmIChjdHggPT0gJ1RBRycgfHwgY3R4ID09ICdJTVBPUlQnKSB7IHRoaXMucGFpcihjdHgpIH07XG5cdFx0dGhpcy5jbG9zZURlZigpOyAvLyBjbG9zZSBkZWYgLS0gcmVhbGx5P1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gVXNlIGEgYFxcYCBhdCBhIGxpbmUtZW5kaW5nIHRvIHN1cHByZXNzIHRoZSBuZXdsaW5lLlxuXHQvLyBUaGUgc2xhc2ggaXMgcmVtb3ZlZCBoZXJlIG9uY2UgaXRzIGpvYiBpcyBkb25lLlxuXHRMZXhlci5wcm90b3R5cGUuc3VwcHJlc3NOZXdsaW5lcyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLnZhbHVlKCkgPT0gJ1xcXFwnKSB7IHRoaXMuX3Rva2Vucy5wb3AoKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gV2UgdHJlYXQgYWxsIG90aGVyIHNpbmdsZSBjaGFyYWN0ZXJzIGFzIGEgdG9rZW4uIEUuZy46IGAoICkgLCAuICFgXG5cdC8vIE11bHRpLWNoYXJhY3RlciBvcGVyYXRvcnMgYXJlIGFsc28gbGl0ZXJhbCB0b2tlbnMsIHNvIHRoYXQgSmlzb24gY2FuIGFzc2lnblxuXHQvLyB0aGUgcHJvcGVyIG9yZGVyIG9mIG9wZXJhdGlvbnMuIFRoZXJlIGFyZSBzb21lIHN5bWJvbHMgdGhhdCB3ZSB0b2tpZCBzcGVjaWFsbHlcblx0Ly8gaGVyZS4gYDtgIGFuZCBuZXdsaW5lcyBhcmUgYm90aCB0cmVhdGVkIGFzIGEgYFRFUk1JTkFUT1JgLCB3ZSBkaXN0aW5ndWlzaFxuXHQvLyBwYXJlbnRoZXNlcyB0aGF0IGluZGljYXRlIGEgbWV0aG9kIGNhbGwgZnJvbSByZWd1bGFyIHBhcmVudGhlc2VzLCBhbmQgc28gb24uXG5cdExleGVyLnByb3RvdHlwZS5saXRlcmFsVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsdmFsdWU7XG5cdFx0aWYgKG1hdGNoID0gT1BFUkFUT1IuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHZhbHVlID0gbWF0Y2hbMF07XG5cdFx0XHRpZiAoQ09ERS50ZXN0KHZhbHVlKSkgdGhpcy50YWdQYXJhbWV0ZXJzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gdGhpcy5fY2h1bmsuY2hhckF0KDApO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGVuZDEgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0dmFyIGVuZDIgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMl07XG5cdFx0XG5cdFx0dmFyIGluVGFnID0gZW5kMSA9PSAnVEFHX0VORCcgfHwgZW5kMSA9PSAnT1VUREVOVCcgJiYgZW5kMiA9PSAnVEFHX0VORCc7XG5cdFx0XG5cdFx0dmFyIHRva2lkID0gdmFsdWU7XG5cdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0dmFyIHB0ID0gcHJldiAmJiB0VChwcmV2KTtcblx0XHR2YXIgcHYgPSBwcmV2ICYmIHRWKHByZXYpO1xuXHRcdHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XG5cdFx0Ly8gaXMgdGhpcyBuZWVkZWQ/XG5cdFx0aWYgKHZhbHVlID09ICc9JyAmJiBwcmV2KSB7XG5cdFx0XHRcblx0XHRcdGlmIChwdiA9PSAnfHwnIHx8IHB2ID09ICcmJicpIHsgLy8gaW4gWyd8fCcsICcmJiddXG5cdFx0XHRcdHRUcyhwcmV2LCdDT01QT1VORF9BU1NJR04nKTtcblx0XHRcdFx0dFZzKHByZXYscHYgKyAnPScpO1xuXHRcdFx0XHQvLyBwcmV2WzBdID0gJ0NPTVBPVU5EX0FTU0lHTidcblx0XHRcdFx0Ly8gcHJldlsxXSArPSAnPSdcblx0XHRcdFx0cmV0dXJuIHZhbHVlLmxlbmd0aDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodmFsdWUgPT0gJzsnKSB7XG5cdFx0XHR0aGlzLl9zZWVuRm9yID0gZmFsc2U7XG5cdFx0XHR0b2tpZCA9ICdURVJNSU5BVE9SJztcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICcoJyAmJiBpblRhZyAmJiBwdCAhPSAnPScgJiYgcHJldi5zcGFjZWQpIHsgLy8gRklYZWRcblx0XHRcdC8vIGNvbnNvbGUubG9nICdzcGFjZWQgYmVmb3JlICggaW4gdG9raWQnXG5cdFx0XHQvLyBGSVhNRSAtIHNob3VsZCByYXRoZXIgYWRkIGEgc3BlY2lhbCB0b2tlbiBsaWtlIFRBR19QQVJBTVNfU1RBUlRcblx0XHRcdHRoaXMudG9rZW4oJywnLCcsJyk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnLT4nICYmIGluVGFnKSB7XG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJztcblx0XHRcdHRoaXMucGFpcignVEFHX0VORCcpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJy8+JyAmJiBpblRhZykge1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCc7XG5cdFx0XHR0aGlzLnBhaXIoJ1RBR19FTkQnKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICc+JyAmJiBpblRhZykge1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCc7XG5cdFx0XHR0aGlzLnBhaXIoJ1RBR19FTkQnKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICc+JyAmJiB0aGlzLmNvbnRleHQoKSA9PSAnREVGJykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ3BpY2tlZCB1cCA+ISEnKVxuXHRcdFx0dG9raWQgPSAnREVGX0ZSQUdNRU5UJztcblx0XHRcdFxuXHRcdFx0Ly8gZWxpZiB2YWx1ZSBpcyAnVEVSTUlOQVRPUicgYW5kIGVuZDEgaXMgJyUnIFxuXHRcdFx0Ly8gXHRjbG9zZVNlbGVjdG9yKClcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICdURVJNSU5BVE9SJyAmJiBlbmQxID09ICdERUYnKSB7XG5cdFx0XHR0aGlzLmNsb3NlRGVmKCk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnJicgJiYgdGhpcy5jb250ZXh0KCkgPT0gJ0RFRicpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwib2theSFcIilcblx0XHRcdHRva2lkID0gJ0JMT0NLX0FSRyc7XG5cdFx0XHQvLyBjaGFuZ2UgdGhlIG5leHQgaWRlbnRpZmllciBpbnN0ZWFkP1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJyonICYmIHRoaXMuX2NodW5rLmNoYXJBdCgxKS5tYXRjaCgvW0EtWmEtelxcX1xcQFxcW10vKSAmJiAocHJldi5zcGFjZWQgfHwgWycsJywnKCcsJ1snLCd7JywnfCcsJ1xcbicsJ1xcdCddLmluZGV4T2YocHYpID49IDApKSB7XG5cdFx0XHR0b2tpZCA9IFwiU1BMQVRcIjtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICfiiJonKSB7XG5cdFx0XHR0b2tpZCA9ICdTUVJUJztcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICfGkicpIHtcblx0XHRcdHRva2lkID0gJ0ZVTkMnO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxNQVRIKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdNQVRIJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsQ09NUEFSRSkgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnQ09NUEFSRSc7XG5cdFx0fSBlbHNlIGlmIChpZHgkKHZhbHVlLENPTVBPVU5EX0FTU0lHTikgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnQ09NUE9VTkRfQVNTSUdOJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsVU5BUlkpID49IDApIHtcblx0XHRcdHRva2lkID0gJ1VOQVJZJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsU0hJRlQpID49IDApIHtcblx0XHRcdHRva2lkID0gJ1NISUZUJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsTE9HSUMpID49IDApIHtcblx0XHRcdHRva2lkID0gJ0xPR0lDJzsgLy8gb3IgdmFsdWUgaXMgJz8nIGFuZCBwcmV2PzpzcGFjZWQgXG5cdFx0fSBlbHNlIGlmIChwcmV2ICYmICFwcmV2LnNwYWNlZCkge1xuXHRcdFx0Ly8gbmVlZCBhIGJldHRlciB3YXkgdG8gZG8gdGhlc2Vcblx0XHRcdGlmICh2YWx1ZSA9PSAnKCcgJiYgZW5kMSA9PSAnJScpIHtcblx0XHRcdFx0dG9raWQgPSAnVEFHX0FUVFJTX1NUQVJUJztcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJygnICYmIGlkeCQocHQsQ0FMTEFCTEUpID49IDApIHtcblx0XHRcdFx0Ly8gbm90IHVzaW5nIHRoaXMgPz8/XG5cdFx0XHRcdC8vIHByZXZbMF0gPSAnRlVOQ19FWElTVCcgaWYgcHJldlswXSBpcyAnPydcblx0XHRcdFx0dG9raWQgPSAnQ0FMTF9TVEFSVCc7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICdbJyAmJiBpZHgkKHB0LElOREVYQUJMRSkgPj0gMCkge1xuXHRcdFx0XHR0b2tpZCA9ICdJTkRFWF9TVEFSVCc7XG5cdFx0XHRcdGlmIChwdCA9PSAnPycpIHsgdFRzKHByZXYsJ0lOREVYX1NPQUsnKSB9O1xuXHRcdFx0XHQvLyBwcmV2WzBdID0gJ0lOREVYX1NPQUsnIGlmIHByZXZbMF0gPT0gJz8nXG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0c3dpdGNoICh2YWx1ZSkge1xuXHRcdFx0Y2FzZSAnKCc6XG5cdFx0XHRjYXNlICd7Jzpcblx0XHRcdGNhc2UgJ1snOlxuXHRcdFx0XHR0aGlzLnB1c2hFbmQoSU5WRVJTRVNbdmFsdWVdKTticmVhaztcblx0XHRcdFxuXHRcdFx0Y2FzZSAnKSc6XG5cdFx0XHRjYXNlICd9Jzpcblx0XHRcdGNhc2UgJ10nOlxuXHRcdFx0XHR0aGlzLnBhaXIodmFsdWUpO2JyZWFrO1xuXHRcdFxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gaGFja3kgcnVsZSB0byB0cnkgdG8gYWxsb3cgZm9yIHR1cGxlLWFzc2lnbm1lbnRzIGluIGJsb2Nrc1xuXHRcdC8vIGlmIHZhbHVlIGlzICcsJyBhbmQgcHJldlswXSBpcyAnSURFTlRJRklFUicgYW5kIEB0b2tlbnNbQHRva2VuczpsZW5ndGggLSAyXVswXSBpbiBbJ1RFUk1JTkFUT1InLCdJTkRFTlQnXVxuXHRcdC8vICAgIyB0b2tlbiBcIlRVUExFXCIsIFwidHVwbGVcIiAjIHNob3VsZCByYXRoZXIgaW5zZXJ0IGl0IHNvbWV3aGVyZSBlbHNlLCBubz9cblx0XHQvLyAgIGNvbnNvbGUubG9nKFwiZm91bmQgY29tbWFcIilcblx0XHRcblx0XHR0aGlzLnRva2VuKHRva2lkLHZhbHVlLHZhbHVlLmxlbmd0aCk7XG5cdFx0cmV0dXJuIHZhbHVlLmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIFRva2VuIE1hbmlwdWxhdG9yc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblx0XG5cdC8vIFNhbml0aXplIGEgaGVyZWRvYyBvciBoZXJlY29tbWVudCBieVxuXHQvLyBlcmFzaW5nIGFsbCBleHRlcm5hbCBpbmRlbnRhdGlvbiBvbiB0aGUgbGVmdC1oYW5kIHNpZGUuXG5cdExleGVyLnByb3RvdHlwZS5zYW5pdGl6ZUhlcmVkb2MgPSBmdW5jdGlvbiAoZG9jLG9wdGlvbnMpe1xuXHRcdHZhciBtYXRjaDtcblx0XHR2YXIgaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQ7XG5cdFx0dmFyIGhlcmVjb21tZW50ID0gb3B0aW9ucy5oZXJlY29tbWVudDtcblx0XHRcblx0XHRpZiAoaGVyZWNvbW1lbnQpIHtcblx0XHRcdGlmIChIRVJFRE9DX0lMTEVHQUwudGVzdChkb2MpKSB7XG5cdFx0XHRcdHRoaXMuZXJyb3IoXCJibG9jayBjb21tZW50IGNhbm5vdCBjb250YWluICcqLycgc3RhcnRpbmdcIik7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGRvYy5pbmRleE9mKCdcXG4nKSA8PSAwKSB7IHJldHVybiBkb2MgfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxlbmd0aF87d2hpbGUgKG1hdGNoID0gSEVSRURPQ19JTkRFTlQuZXhlYyhkb2MpKXtcblx0XHRcdFx0dmFyIGF0dGVtcHQgPSBtYXRjaFsxXTtcblx0XHRcdFx0aWYgKGluZGVudCA9PSBudWxsIHx8IDAgPCAobGVuZ3RoXyA9IGF0dGVtcHQubGVuZ3RoKSAmJiBsZW5ndGhfIDwgaW5kZW50Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGluZGVudCA9IGF0dGVtcHQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGluZGVudCkgeyBkb2MgPSBkb2MucmVwbGFjZShSZWdFeHAoKFwiXFxcXG5cIiArIGluZGVudCksXCJnXCIpLCdcXG4nKSB9O1xuXHRcdGlmICghaGVyZWNvbW1lbnQpIHsgZG9jID0gZG9jLnJlcGxhY2UoL15cXG4vLCcnKSB9O1xuXHRcdHJldHVybiBkb2M7XG5cdH07XG5cdFxuXHQvLyBBIHNvdXJjZSBvZiBhbWJpZ3VpdHkgaW4gb3VyIGdyYW1tYXIgdXNlZCB0byBiZSBwYXJhbWV0ZXIgbGlzdHMgaW4gZnVuY3Rpb25cblx0Ly8gZGVmaW5pdGlvbnMgdmVyc3VzIGFyZ3VtZW50IGxpc3RzIGluIGZ1bmN0aW9uIGNhbGxzLiBXYWxrIGJhY2t3YXJkcywgdG9raWRnaW5nXG5cdC8vIHBhcmFtZXRlcnMgc3BlY2lhbGx5IGluIG9yZGVyIHRvIG1ha2UgdGhpbmdzIGVhc2llciBmb3IgdGhlIHBhcnNlci5cblx0TGV4ZXIucHJvdG90eXBlLnRhZ1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rO1xuXHRcdGlmICh0aGlzLmxhc3RUb2tlblR5cGUoKSAhPSAnKScpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHR2YXIgc3RhY2sgPSBbXTtcblx0XHR2YXIgdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuXHRcdHZhciBpID0gdG9rZW5zLmxlbmd0aDtcblx0XHRcblx0XHR0VHModG9rZW5zWy0taV0sJ1BBUkFNX0VORCcpO1xuXHRcdFxuXHRcdHdoaWxlICh0b2sgPSB0b2tlbnNbLS1pXSl7XG5cdFx0XHR2YXIgdCA9IHRUKHRvayk7XG5cdFx0XHRzd2l0Y2ggKHQpIHtcblx0XHRcdFx0Y2FzZSAnKSc6XG5cdFx0XHRcdFx0c3RhY2sucHVzaCh0b2spO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnKCc6XG5cdFx0XHRcdGNhc2UgJ0NBTExfU1RBUlQnOlxuXHRcdFx0XHRcdGlmIChzdGFjay5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodCA9PSAnKCcpIHtcblx0XHRcdFx0XHRcdHRUcyh0b2ssJ1BBUkFNX1NUQVJUJyk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gQ2xvc2UgdXAgYWxsIHJlbWFpbmluZyBvcGVuIGJsb2NrcyBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuXHRMZXhlci5wcm90b3R5cGUuY2xvc2VJbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGN0eCA9IGNvbnRleHRcblx0XHQvLyBwYWlyKGN0eCkgaWYgY3R4IGluIFsnJScsJ0RFRiddXG5cdFx0dGhpcy5jbG9zZURlZigpO1xuXHRcdHRoaXMuY2xvc2VTZWxlY3RvcigpO1xuXHRcdHJldHVybiB0aGlzLm91dGRlbnRUb2tlbih0aGlzLl9pbmRlbnQsZmFsc2UsMCk7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGEgYmFsYW5jZWQgZ3JvdXAgc3VjaCBhcyBhIHNpbmdsZSBvciBkb3VibGUtcXVvdGVkIHN0cmluZy4gUGFzcyBpblxuXHQvLyBhIHNlcmllcyBvZiBkZWxpbWl0ZXJzLCBhbGwgb2Ygd2hpY2ggbXVzdCBiZSBuZXN0ZWQgY29ycmVjdGx5IHdpdGhpbiB0aGVcblx0Ly8gY29udGVudHMgb2YgdGhlIHN0cmluZy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIGhhdmUgc3RyaW5ncyB3aXRoaW5cblx0Ly8gaW50ZXJwb2xhdGlvbnMgd2l0aGluIHN0cmluZ3MsIGFkIGluZmluaXR1bS5cblx0TGV4ZXIucHJvdG90eXBlLmJhbGFuY2VkU3RyaW5nID0gZnVuY3Rpb24gKHN0cixlbmQpe1xuXHRcdHZhciBtYXRjaCxsZXR0ZXIscHJldjtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyAnYmFsYW5jaW5nIHN0cmluZyEnLCBzdHIsIGVuZFxuXHRcdHZhciBzdGFjayA9IFtlbmRdO1xuXHRcdHZhciBpID0gMDtcblx0XHRcblx0XHQvLyBjb3VsZCBpdCBub3QgaGFwcGVuIGhlcmU/XG5cdFx0d2hpbGUgKGkgPCAoc3RyLmxlbmd0aCAtIDEpKXtcblx0XHRcdGkrKztcblx0XHRcdGxldHRlciA9IHN0ci5jaGFyQXQoaSk7XG5cdFx0XHRzd2l0Y2ggKGxldHRlcikge1xuXHRcdFx0XHRjYXNlICdcXFxcJzpcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlIGVuZDpcblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRpZiAoIXN0YWNrLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dmFyIHYgPSBzdHIuc2xpY2UoMCxpICsgMSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGVuZCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZW5kID09ICd9JyAmJiAobGV0dGVyID09ICdcIicgfHwgbGV0dGVyID09IFwiJ1wiKSkge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9IGxldHRlcik7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnfScgJiYgbGV0dGVyID09ICcvJyAmJiAobWF0Y2ggPSAoSEVSRUdFWC5leGVjKHN0ci5zbGljZShpKSkgfHwgUkVHRVguZXhlYyhzdHIuc2xpY2UoaSkpKSkpIHtcblx0XHRcdFx0aSArPSBtYXRjaFswXS5sZW5ndGggLSAxO1xuXHRcdFx0fSBlbHNlIGlmIChlbmQgPT0gJ30nICYmIGxldHRlciA9PSAneycpIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSAnfScpO1xuXHRcdFx0fSBlbHNlIGlmIChlbmQgPT0gJ1wiJyAmJiBsZXR0ZXIgPT0gJ3snKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gJ30nKTtcblx0XHRcdH07XG5cdFx0XHRwcmV2ID0gbGV0dGVyO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCF0aGlzLl9vcHRzLnNpbGVudCkgeyByZXR1cm4gdGhpcy5lcnJvcigoXCJtaXNzaW5nIFwiICsgKHN0YWNrLnBvcCgpKSArIFwiLCBzdGFydGluZ1wiKSkgfTtcblx0fTtcblx0XG5cdC8vIEV4cGFuZCB2YXJpYWJsZXMgYW5kIGV4cHJlc3Npb25zIGluc2lkZSBkb3VibGUtcXVvdGVkIHN0cmluZ3MgdXNpbmdcblx0Ly8gUnVieS1saWtlIG5vdGF0aW9uIGZvciBzdWJzdGl0dXRpb24gb2YgYXJiaXRyYXJ5IGV4cHJlc3Npb25zLlxuXHQvL1xuXHQvLyAgICAgXCJIZWxsbyAje25hbWUuY2FwaXRhbGl6ZSgpfS5cIlxuXHQvL1xuXHQvLyBJZiBpdCBlbmNvdW50ZXJzIGFuIGludGVycG9sYXRpb24sIHRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHkgY3JlYXRlIGFcblx0Ly8gbmV3IExleGVyLCB0b2tlbml6ZSB0aGUgaW50ZXJwb2xhdGVkIGNvbnRlbnRzLCBhbmQgbWVyZ2UgdGhlbSBpbnRvIHRoZVxuXHQvLyB0b2tlbiBzdHJlYW0uXG5cdExleGVyLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIsb3B0aW9ucyl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJpbnRlcnBvbGF0ZSBzdHJpbmdcIlxuXHRcdGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuXHRcdHZhciBoZXJlZG9jID0gb3B0aW9ucy5oZXJlZG9jO1xuXHRcdHZhciBxdW90ZSA9IG9wdGlvbnMucXVvdGU7XG5cdFx0dmFyIHJlZ2V4ID0gb3B0aW9ucy5yZWdleDtcblx0XHR2YXIgcHJlZml4ID0gb3B0aW9ucy5wcmVmaXg7XG5cdFx0XG5cdFx0dmFyIHN0YXJ0TG9jID0gdGhpcy5fbG9jO1xuXHRcdHZhciB0b2tlbnMgPSBbXTtcblx0XHR2YXIgcGkgPSAwO1xuXHRcdHZhciBpID0gLTE7XG5cdFx0dmFyIGxvY09mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDE7XG5cdFx0dmFyIHN0cmxlbiA9IHN0ci5sZW5ndGg7XG5cdFx0dmFyIGxldHRlcjtcblx0XHR2YXIgZXhwcjtcblx0XHRcblx0XHR2YXIgaXNJbnRlcnBvbGF0ZWQgPSBmYWxzZTtcblx0XHQvLyBvdXQgb2YgYm91bmRzXG5cdFx0d2hpbGUgKGxldHRlciA9IHN0ci5jaGFyQXQoaSArPSAxKSl7XG5cdFx0XHRpZiAobGV0dGVyID09ICdcXFxcJykge1xuXHRcdFx0XHRpICs9IDE7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoc3RyLmNoYXJBdChpKSA9PSAneycgJiYgKGV4cHIgPSB0aGlzLmJhbGFuY2VkU3RyaW5nKHN0ci5zbGljZShpKSwnfScpKSkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpc0ludGVycG9sYXRlZCA9IHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIHRoZXNlIGhhdmUgbm8gcmVhbCBzZW5zZSBvZiBsb2NhdGlvbiBvciBhbnl0aGluZz9cblx0XHRcdGlmIChwaSA8IGkpIHtcblx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgcHJlZml4LXN0cmluZyAtIGJlZm9yZSBhbnkgaXRlbVxuXHRcdFx0XHR2YXIgdG9rID0gbmV3IFRva2VuKCdORU9TVFJJTkcnLHRoaXMuZXNjYXBlU3RyKHN0ci5zbGljZShwaSxpKSxoZXJlZG9jLHF1b3RlKSx0aGlzLl9sb2MgKyBwaSArIGxvY09mZnNldCxpIC0gcGkpO1xuXHRcdFx0XHQvLyB0b2suQGxvYyA9IEBsb2MgKyBwaVxuXHRcdFx0XHQvLyB0b2suQGxlbiA9IGkgLSBwaSArIDJcblx0XHRcdFx0dG9rZW5zLnB1c2godG9rKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRva2Vucy5wdXNoKG5ldyBUb2tlbigne3snLCd7Jyx0aGlzLl9sb2MgKyBpICsgbG9jT2Zmc2V0LDEpKTtcblx0XHRcdFxuXHRcdFx0dmFyIGlubmVyID0gZXhwci5zbGljZSgxLC0xKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdpbm5lciBpcycsaW5uZXJcblx0XHRcdC8vIHJlbW92ZSBsZWFkaW5nIHNwYWNlcyBcblx0XHRcdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3cgbXVjaCB3aGl0ZXNwYWNlIHdlIGRyb3BwZWQgZnJvbSB0aGUgc3RhcnRcblx0XHRcdGlubmVyID0gaW5uZXIucmVwbGFjZSgvXlteXFxuXFxTXSsvLCcnKTtcblx0XHRcdFxuXHRcdFx0aWYgKGlubmVyLmxlbmd0aCkge1xuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBsb2Mgd2Ugc3RhcnQgYXRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2ludGVycG9sYXRlIGZyb20gbG9jJyxAbG9jLGkpXG5cdFx0XHRcdC8vIHJlYWxseT8gd2h5IG5vdCBqdXN0IGFkZCB0byB0aGUgc3RhY2s/P1xuXHRcdFx0XHQvLyB3aGF0IGFib3V0IHRoZSBhZGRlZCBcblx0XHRcdFx0Ly8gc2hvdWxkIHNoYXJlIHdpdGggdGhlIHNlbGVjdG9yIG5vP1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcInRva2VuaXplIGlubmVyIHBhcnRzIG9mIHN0cmluZ1wiLGlubmVyXG5cdFx0XHRcdHZhciBzcGFjZXMgPSAwO1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fbG9jICsgaSArIChleHByLmxlbmd0aCAtIGlubmVyLmxlbmd0aCkgLSAxO1xuXHRcdFx0XHQvLyB3aHkgY3JlYXRlIGEgd2hvbGUgbmV3IGxleGVyPyBTaG91bGQgcmF0aGVyIHJldXNlIG9uZVxuXHRcdFx0XHQvLyBtdWNoIGJldHRlciB0byBzaW1wbHkgbW92ZSBpbnRvIGludGVycG9sYXRpb24gbW9kZSB3aGVyZVxuXHRcdFx0XHQvLyB3ZSBjb250aW51ZSBwYXJzaW5nIHVudGlsIHdlIG1lZXQgdW5wYWlyZWQgfVxuXHRcdFx0XHR2YXIgbmVzdGVkID0gbmV3IExleGVyKCkudG9rZW5pemUoaW5uZXIse2lubGluZTogdHJ1ZSxyZXdyaXRlOiBmYWxzZSxsb2M6IG9mZnNldCArIGxvY09mZnNldH0pO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBuZXN0ZWQucG9wXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmVzdGVkWzBdICYmIHRUKG5lc3RlZFswXSkgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdFx0bmVzdGVkLnNoaWZ0KCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmVzdGVkLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRva2Vucy5wdXNoLmFwcGx5KHRva2VucyxuZXN0ZWQpOyAvLyBULnRva2VuKCdUT0tFTlMnLG5lc3RlZCwwKVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIHJhdGhlciBhZGQgdGhlIGFtb3VudCBieSB3aGljaCBvdXIgbGV4ZXIgaGFzIG1vdmVkP1xuXHRcdFx0aSArPSBleHByLmxlbmd0aCAtIDE7XG5cdFx0XHR0b2tlbnMucHVzaChuZXcgVG9rZW4oJ319JywnfScsdGhpcy5fbG9jICsgaSArIGxvY09mZnNldCwxKSk7XG5cdFx0XHRwaSA9IGkgKyAxO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gYWRkaW5nIHRoZSBsYXN0IHBhcnQgb2YgdGhlIHN0cmluZyBoZXJlXG5cdFx0aWYgKGkgPj0gcGkgJiYgcGkgPCBzdHIubGVuZ3RoKSB7XG5cdFx0XHQvLyBzZXQgdGhlIGxlbmd0aCBhcyB3ZWxsIC0gb3I/XG5cdFx0XHQvLyB0aGUgc3RyaW5nIGFmdGVyP1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3B1c2ggbmVvc3RyaW5nJ1xuXHRcdFx0dG9rZW5zLnB1c2gobmV3IFRva2VuKCdORU9TVFJJTkcnLHRoaXMuZXNjYXBlU3RyKHN0ci5zbGljZShwaSksaGVyZWRvYyxxdW90ZSksdGhpcy5fbG9jICsgcGkgKyBsb2NPZmZzZXQsc3RyLmxlbmd0aCAtIHBpKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyB0b2tlbnM6bGVuZ3RoXG5cdFx0aWYgKHJlZ2V4KSB7IHJldHVybiB0b2tlbnMgfTtcblx0XHRcblx0XHRpZiAoIXRva2Vucy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMudG9rZW4oJ05FT1NUUklORycsJ1wiXCInKSB9O1xuXHRcdFxuXHRcdGZvciAodmFyIGogPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcblx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKHRva2Vuc1tqXSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdG9rZW5zO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBhIGJhbGFuY2VkIGdyb3VwIHN1Y2ggYXMgYSBzaW5nbGUgb3IgZG91YmxlLXF1b3RlZCBzdHJpbmcuIFBhc3MgaW5cblx0Ly8gYSBzZXJpZXMgb2YgZGVsaW1pdGVycywgYWxsIG9mIHdoaWNoIG11c3QgYmUgbmVzdGVkIGNvcnJlY3RseSB3aXRoaW4gdGhlXG5cdC8vIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBoYXZlIHN0cmluZ3Mgd2l0aGluXG5cdC8vIGludGVycG9sYXRpb25zIHdpdGhpbiBzdHJpbmdzLCBhZCBpbmZpbml0dW0uXG5cdExleGVyLnByb3RvdHlwZS5iYWxhbmNlZFNlbGVjdG9yID0gZnVuY3Rpb24gKHN0cixlbmQpe1xuXHRcdHZhciBwcmV2O1xuXHRcdHZhciBsZXR0ZXI7XG5cdFx0dmFyIHN0YWNrID0gW2VuZF07XG5cdFx0Ly8gRklYTUVcblx0XHRmb3IgKHZhciBsZW4gPSBzdHIubGVuZ3RoLCBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRzd2l0Y2ggKGxldHRlciA9IHN0ci5jaGFyQXQoaSkpIHtcblx0XHRcdFx0Y2FzZSAnXFxcXCc6XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSBlbmQ6XG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0aWYgKCFzdGFjay5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzdHIuc2xpY2UoMCxpICsgMSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRlbmQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0fTtcblx0XHRcdGlmIChlbmQgPT0gJ30nICYmIGxldHRlciA9PSBbJyknXSkge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9IGxldHRlcik7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnfScgJiYgbGV0dGVyID09ICd7Jykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9ICd9Jyk7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnKScgJiYgbGV0dGVyID09ICd7Jykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9ICd9Jyk7XG5cdFx0XHR9O1xuXHRcdFx0cHJldiA9IGxldHRlcjsgLy8gd2hhdCwgd2h5P1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuZXJyb3IoKFwibWlzc2luZyBcIiArIChzdGFjay5wb3AoKSkgKyBcIiwgc3RhcnRpbmdcIikpO1xuXHR9O1xuXHRcblx0Ly8gUGFpcnMgdXAgYSBjbG9zaW5nIHRva2VuLCBlbnN1cmluZyB0aGF0IGFsbCBsaXN0ZWQgcGFpcnMgb2YgdG9rZW5zIGFyZVxuXHQvLyBjb3JyZWN0bHkgYmFsYW5jZWQgdGhyb3VnaG91dCB0aGUgY291cnNlIG9mIHRoZSB0b2tlbiBzdHJlYW0uXG5cdExleGVyLnByb3RvdHlwZS5wYWlyID0gZnVuY3Rpb24gKHRvayl7XG5cdFx0dmFyIHdhbnRlZCA9IGxhc3QodGhpcy5fZW5kcyk7XG5cdFx0aWYgKHRvayAhPSB3YW50ZWQpIHtcblx0XHRcdGlmICgnT1VUREVOVCcgIT0gd2FudGVkKSB7IHRoaXMuZXJyb3IoKFwidW5tYXRjaGVkIFwiICsgdG9rKSkgfTtcblx0XHRcdHZhciBzaXplID0gbGFzdCh0aGlzLl9pbmRlbnRzKTtcblx0XHRcdHRoaXMuX2luZGVudCAtPSBzaXplO1xuXHRcdFx0dGhpcy5vdXRkZW50VG9rZW4oc2l6ZSx0cnVlLDApO1xuXHRcdFx0cmV0dXJuIHRoaXMucGFpcih0b2spO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMucG9wRW5kKCk7XG5cdH07XG5cdFxuXHRcblx0Ly8gSGVscGVyc1xuXHQvLyAtLS0tLS0tXG5cdFxuXHQvLyBBZGQgYSB0b2tlbiB0byB0aGUgcmVzdWx0cywgdGFraW5nIG5vdGUgb2YgdGhlIGxpbmUgbnVtYmVyLlxuXHRMZXhlci5wcm90b3R5cGUudG9rZW4gPSBmdW5jdGlvbiAoaWQsdmFsdWUsbGVuLG9mZnNldCl7XG5cdFx0dGhpcy5fbGFzdFR5cCA9IGlkO1xuXHRcdHRoaXMuX2xhc3RWYWwgPSB2YWx1ZTtcblx0XHR2YXIgdG9rID0gdGhpcy5fbGFzdCA9IG5ldyBUb2tlbihpZCx2YWx1ZSx0aGlzLl9sb2MgKyAob2Zmc2V0IHx8IDApLGxlbiB8fCAwKTtcblx0XHR0aGlzLl90b2tlbnMucHVzaCh0b2spO1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5sYXN0VG9rZW5UeXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRva2VuID0gdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4gdG9rZW4gPyAodFQodG9rZW4pKSA6ICgnTk9ORScpO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmxhc3RUb2tlblZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRva2VuID0gdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4gdG9rZW4gPyAodG9rZW4uX3ZhbHVlKSA6ICgnJyk7XG5cdH07XG5cdFxuXHQvLyBQZWVrIGF0IGEgdG9raWQgaW4gdGhlIGN1cnJlbnQgdG9rZW4gc3RyZWFtLlxuXHRMZXhlci5wcm90b3R5cGUudG9raWQgPSBmdW5jdGlvbiAoaW5kZXgsdmFsKXtcblx0XHR2YXIgdG9rO1xuXHRcdGlmICh0b2sgPSBsYXN0KHRoaXMuX3Rva2VucyxpbmRleCkpIHtcblx0XHRcdGlmICh2YWwpIHsgdFRzKHRvayx2YWwpIH07XG5cdFx0XHRyZXR1cm4gdFQodG9rKTtcblx0XHRcdC8vIHRvay5AdHlwZSA9IHRva2lkIGlmIHRva2lkICMgd2h5P1xuXHRcdFx0Ly8gdG9rLkB0eXBlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvLyBQZWVrIGF0IGEgdmFsdWUgaW4gdGhlIGN1cnJlbnQgdG9rZW4gc3RyZWFtLlxuXHRMZXhlci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoaW5kZXgsdmFsKXtcblx0XHR2YXIgdG9rO1xuXHRcdGlmICh0b2sgPSBsYXN0KHRoaXMuX3Rva2VucyxpbmRleCkpIHtcblx0XHRcdGlmICh2YWwpIHsgdFZzKHRvayx2YWwpIH07XG5cdFx0XHRyZXR1cm4gdFYodG9rKTtcblx0XHRcdC8vIHRvay5AdmFsdWUgPSB2YWwgaWYgdmFsICMgd2h5P1xuXHRcdFx0Ly8gdG9rLkB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdC8vIEFyZSB3ZSBpbiB0aGUgbWlkc3Qgb2YgYW4gdW5maW5pc2hlZCBleHByZXNzaW9uP1xuXHRMZXhlci5wcm90b3R5cGUudW5maW5pc2hlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmIChMSU5FX0NPTlRJTlVFUi50ZXN0KHRoaXMuX2NodW5rKSkgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdHJldHVybiBVTkZJTklTSEVELmluZGV4T2YodGhpcy5fbGFzdFR5cCkgPj0gMDtcblx0fTtcblx0XG5cdC8vIHZhciB0b2tlbnMgPSBbJ1xcXFwnLCcuJywgJz8uJywgJ1VOQVJZJywgJ01BVEgnLCAnKycsICctJywgJ1NISUZUJywgJ1JFTEFUSU9OJywgJ0NPTVBBUkUnLCAnTE9HSUMnLCAnQ09NUE9VTkRfQVNTSUdOJywgJ1RIUk9XJywgJ0VYVEVORFMnXVxuXHRcblx0Ly8gQ29udmVydHMgbmV3bGluZXMgZm9yIHN0cmluZyBsaXRlcmFscy5cblx0TGV4ZXIucHJvdG90eXBlLmVzY2FwZUxpbmVzID0gZnVuY3Rpb24gKHN0cixoZXJlZG9jKXtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwoaGVyZWRvYyA/ICgnXFxcXG4nKSA6ICgnJykpKTtcblx0fTtcblx0XG5cdC8vIENvbnN0cnVjdHMgYSBzdHJpbmcgdG9rZW4gYnkgZXNjYXBpbmcgcXVvdGVzIGFuZCBuZXdsaW5lcy5cblx0TGV4ZXIucHJvdG90eXBlLm1ha2VTdHJpbmcgPSBmdW5jdGlvbiAoYm9keSxxdW90ZSxoZXJlZG9jKXtcblx0XHRpZiAoIWJvZHkpIHsgcmV0dXJuIHF1b3RlICsgcXVvdGUgfTtcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlKC9cXFxcKFtcXHNcXFNdKS9nLGZ1bmN0aW9uKG1hdGNoLGNvbnRlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKGNvbnRlbnRzID09ICdcXG4nIHx8IGNvbnRlbnRzID09IHF1b3RlKSA/IChjb250ZW50cykgOiAobWF0Y2gpO1xuXHRcdH0pO1xuXHRcdC8vIERvZXMgbm90IHdvcmsgbm93XG5cdFx0Ym9keSA9IGJvZHkucmVwbGFjZShSZWdFeHAoKFwiXCIgKyBxdW90ZSksXCJnXCIpLCdcXFxcJCYnKTtcblx0XHRyZXR1cm4gcXVvdGUgKyB0aGlzLmVzY2FwZUxpbmVzKGJvZHksaGVyZWRvYykgKyBxdW90ZTtcblx0fTtcblx0XG5cdC8vIFRocm93cyBhIHN5bnRheCBlcnJvciBvbiB0aGUgY3VycmVudCBgQGxpbmVgLlxuXHRMZXhlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSxsZW4pe1xuXHRcdGlmICgodHlwZW9mIHRoaXMuX2xpbmU9PSdudW1iZXInfHx0aGlzLl9saW5lIGluc3RhbmNlb2YgTnVtYmVyKSkgeyBtZXNzYWdlID0gKFwiXCIgKyBtZXNzYWdlICsgXCIgb24gbGluZSBcIiArICh0aGlzLl9saW5lKSkgfTtcblx0XHRcblx0XHRpZiAobGVuKSB7XG5cdFx0XHRtZXNzYWdlICs9IChcIiBbXCIgKyAodGhpcy5fbG9jKSArIFwiOlwiICsgKHRoaXMuX2xvYyArIGxlbikgKyBcIl1cIik7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuXHRcdGVyci5saW5lID0gdGhpcy5fbGluZTtcblx0XHQvLyBlcnI6Y29sdW1uTnVtYmVyXG5cdFx0ZXJyID0gbmV3IEVSUi5JbWJhUGFyc2VFcnJvcihlcnIse3Rva2VuczogdGhpcy5fdG9rZW5zLHBvczogdGhpcy5fdG9rZW5zLmxlbmd0aH0pO1xuXHRcdGVyci5yZWdpb24gPSBbdGhpcy5fbG9jLHRoaXMuX2xvYyArIChsZW4gfHwgMCldO1xuXHRcdHRocm93IGVycjtcblx0fTtcblx0cmV0dXJuIExleGVyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L2ltYmEvc3JjL2NvbXBpbGVyL2xleGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciBUT0ssIExCUkFDS0VULCBSQlJBQ0tFVCwgTFBBUkVOLCBSUEFSRU4sIElOREVOVCwgT1VUREVOVDtcblx0XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5UT0sgPSBUT0sgPSB7fTtcblx0dmFyIFRURVJNSU5BVE9SID0gVE9LLlRFUk1JTkFUT1IgPSAxO1xuXHR2YXIgVElERU5USUZJRVIgPSBUT0suSURFTlRJRklFUiA9IDI7XG5cdFRJREVOVElGSUVSID0gVE9LLklWQVIgPSAyO1xuXHR2YXIgQ09OU1QgPSBUT0suQ09OU1QgPSAzO1xuXHR2YXIgVkFSID0gVE9LLlZBUiA9IDQ7XG5cdHZhciBJRiA9IFRPSy5JRiA9IDU7XG5cdHZhciBFTFNFID0gVE9LLkVMU0UgPSA2O1xuXHR2YXIgREVGID0gVE9LLkRFRiA9IDc7XG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIFRva2VuKHR5cGUsdmFsdWUsbG9jLGxlbil7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLl9sb2MgPSBsb2MgIT0gbnVsbCA/IChsb2MpIDogKC0xKTtcblx0XHR0aGlzLl9sZW4gPSBsZW4gfHwgMDtcblx0XHR0aGlzLl9tZXRhID0gbnVsbDtcblx0XHR0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuXHRcdHRoaXMubmV3TGluZSA9IGZhbHNlO1xuXHRcdHRoaXMuc3BhY2VkID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLlRva2VuID0gVG9rZW47IC8vIGV4cG9ydCBjbGFzcyBcblx0VG9rZW4ucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFwiXCIgKyB0aGlzLl92YWx1ZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5jaGFyQXQgPSBmdW5jdGlvbiAoaSl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLmNoYXJBdChpKTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChpKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUuc2xpY2UoaSk7XG5cdH07XG5cdFxuXHRUb2tlbi5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLl9sb2MsdGhpcy5fbG9jICsgKHRoaXMuX2xlbiB8fCB0aGlzLl92YWx1ZS5sZW5ndGgpXTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5zb3VyY2VNYXBNYXJrZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbG9jID09IC0xID8gKCc6JykgOiAoKFwiJSRcIiArICh0aGlzLl9sb2MpICsgXCIkJVwiKSk7XG5cdFx0Ly8gQGNvbCA9PSAtMSA/ICcnIDogXCIlJXtAbGluZX0ke0Bjb2x9JSVcIlxuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIGxleCgpe1xuXHRcdHZhciB0b2tlbiA9IHRoaXMudG9rZW5zW3RoaXMucG9zKytdO1xuXHRcdHZhciB0dGFnO1xuXHRcdFxuXHRcdGlmICh0b2tlbikge1xuXHRcdFx0dHRhZyA9IHRva2VuLl90eXBlO1xuXHRcdFx0dGhpcy55eXRleHQgPSB0b2tlbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dHRhZyA9ICcnO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHR0YWc7XG5cdH07IGV4cG9ydHMubGV4ID0gbGV4O1xuXHRcblx0XG5cdC8vIGV4cG9ydCBkZWYgdG9rZW4gdHlwLCB2YWwsIGxpbmUsIGNvbCwgbGVuIGRvIFRva2VuLm5ldyh0eXAsdmFsLGxpbmUsIGNvbCBvciAwLCBsZW4gb3IgMCkgIyBbbnVsbCx0eXAsdmFsLGxvY11cblx0ZnVuY3Rpb24gdG9rZW4odHlwLHZhbCl7XG5cdFx0cmV0dXJuIG5ldyBUb2tlbih0eXAsdmFsLC0xLDApO1xuXHR9OyBleHBvcnRzLnRva2VuID0gdG9rZW47XG5cdFxuXHRmdW5jdGlvbiB0eXAodG9rKXtcblx0XHRyZXR1cm4gdG9rLl90eXBlO1xuXHR9OyBleHBvcnRzLnR5cCA9IHR5cDtcblx0ZnVuY3Rpb24gdmFsKHRvayl7XG5cdFx0cmV0dXJuIHRvay5fdmFsdWU7XG5cdH07IGV4cG9ydHMudmFsID0gdmFsOyAvLyB0b2tbb2Zmc2V0ICsgMV1cblx0ZnVuY3Rpb24gbGluZSh0b2spe1xuXHRcdHJldHVybiB0b2suX2xpbmU7XG5cdH07IGV4cG9ydHMubGluZSA9IGxpbmU7IC8vIHRva1tvZmZzZXQgKyAyXVxuXHRmdW5jdGlvbiBsb2ModG9rKXtcblx0XHRyZXR1cm4gdG9rLl9sb2M7XG5cdH07IGV4cG9ydHMubG9jID0gbG9jOyAvLyB0b2tbb2Zmc2V0ICsgMl1cblx0XG5cdGZ1bmN0aW9uIHNldFR5cCh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fdHlwZSA9IHY7XG5cdH07IGV4cG9ydHMuc2V0VHlwID0gc2V0VHlwO1xuXHRmdW5jdGlvbiBzZXRWYWwodG9rLHYpe1xuXHRcdHJldHVybiB0b2suX3ZhbHVlID0gdjtcblx0fTsgZXhwb3J0cy5zZXRWYWwgPSBzZXRWYWw7XG5cdGZ1bmN0aW9uIHNldExpbmUodG9rLHYpe1xuXHRcdHJldHVybiB0b2suX2xpbmUgPSB2O1xuXHR9OyBleHBvcnRzLnNldExpbmUgPSBzZXRMaW5lO1xuXHRmdW5jdGlvbiBzZXRMb2ModG9rLHYpe1xuXHRcdHJldHVybiB0b2suX2xvYyA9IHY7XG5cdH07IGV4cG9ydHMuc2V0TG9jID0gc2V0TG9jO1xuXHRcblx0XG5cdG1vZHVsZS5leHBvcnRzLkxCUkFDS0VUID0gTEJSQUNLRVQgPSBuZXcgVG9rZW4oJ3snLCd7JywwLDAsMCk7XG5cdG1vZHVsZS5leHBvcnRzLlJCUkFDS0VUID0gUkJSQUNLRVQgPSBuZXcgVG9rZW4oJ30nLCd9JywwLDAsMCk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5MUEFSRU4gPSBMUEFSRU4gPSBuZXcgVG9rZW4oJygnLCcoJywwLDAsMCk7XG5cdG1vZHVsZS5leHBvcnRzLlJQQVJFTiA9IFJQQVJFTiA9IG5ldyBUb2tlbignKScsJyknLDAsMCwwKTtcblx0XG5cdExCUkFDS0VULmdlbmVyYXRlZCA9IHRydWU7XG5cdFJCUkFDS0VULmdlbmVyYXRlZCA9IHRydWU7XG5cdExQQVJFTi5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRSUEFSRU4uZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLklOREVOVCA9IElOREVOVCA9IG5ldyBUb2tlbignSU5ERU5UJywnMicsMCwwLDApO1xuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHMuT1VUREVOVCA9IE9VVERFTlQgPSBuZXcgVG9rZW4oJ09VVERFTlQnLCcyJywwLDAsMCk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vaW1iYS9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYVxuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHR2YXIgSU5WRVJTRVMsIExJTkVCUkVBS1M7XG5cdFxuXHQvLyBUaGUgSW1iYSBsYW5ndWFnZSBoYXMgYSBnb29kIGRlYWwgb2Ygb3B0aW9uYWwgc3ludGF4LCBpbXBsaWNpdCBzeW50YXgsXG5cdC8vIGFuZCBzaG9ydGhhbmQgc3ludGF4LiBUaGlzIGNhbiBncmVhdGx5IGNvbXBsaWNhdGUgYSBncmFtbWFyIGFuZCBibG9hdFxuXHQvLyB0aGUgcmVzdWx0aW5nIHBhcnNlIHRhYmxlLiBJbnN0ZWFkIG9mIG1ha2luZyB0aGUgcGFyc2VyIGhhbmRsZSBpdCBhbGwsIHdlIHRha2Vcblx0Ly8gYSBzZXJpZXMgb2YgcGFzc2VzIG92ZXIgdGhlIHRva2VuIHN0cmVhbSwgdXNpbmcgdGhpcyAqKlJld3JpdGVyKiogdG8gY29udmVydFxuXHQvLyBzaG9ydGhhbmQgaW50byB0aGUgdW5hbWJpZ3VvdXMgbG9uZyBmb3JtLCBhZGQgaW1wbGljaXQgaW5kZW50YXRpb24gYW5kXG5cdC8vIHBhcmVudGhlc2VzLCBhbmQgZ2VuZXJhbGx5IGNsZWFuIHRoaW5ncyB1cC5cblx0XG5cdHZhciBUID0gcmVxdWlyZSgnLi90b2tlbicpO1xuXHR2YXIgVG9rZW4gPSBULlRva2VuO1xuXHRcblx0Ly8gQmFzZWQgb24gdGhlIG9yaWdpbmFsIHJld3JpdGVyLmNvZmZlZSBmcm9tIENvZmZlZVNjcmlwdFxuXHRmdW5jdGlvbiBSZXdyaXRlcigpeyB9O1xuXHRcblx0ZXhwb3J0cy5SZXdyaXRlciA9IFJld3JpdGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFJld3JpdGVyLnByb3RvdHlwZS50b2tlbnMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdG9rZW5zO1xuXHR9O1xuXHRcblx0Ly8gSGVscGZ1bCBzbmlwcGV0IGZvciBkZWJ1Z2dpbmc6XG5cdC8vICAgICBjb25zb2xlLmxvZyAodFswXSArICcvJyArIHRbMV0gZm9yIHQgaW4gQHRva2Vucykuam9pbiAnICdcblx0Ly8gUmV3cml0ZSB0aGUgdG9rZW4gc3RyZWFtIGluIG11bHRpcGxlIHBhc3Nlcywgb25lIGxvZ2ljYWwgZmlsdGVyIGF0XG5cdC8vIGEgdGltZS4gVGhpcyBjb3VsZCBjZXJ0YWlubHkgYmUgY2hhbmdlZCBpbnRvIGEgc2luZ2xlIHBhc3MgdGhyb3VnaCB0aGVcblx0Ly8gc3RyZWFtLCB3aXRoIGEgYmlnIG9sJyBlZmZpY2llbnQgc3dpdGNoLCBidXQgaXQncyBtdWNoIG5pY2VyIHRvIHdvcmsgd2l0aFxuXHQvLyBsaWtlIHRoaXMuIFRoZSBvcmRlciBvZiB0aGVzZSBwYXNzZXMgbWF0dGVycyAtLSBpbmRlbnRhdGlvbiBtdXN0IGJlXG5cdC8vIGNvcnJlY3RlZCBiZWZvcmUgaW1wbGljaXQgcGFyZW50aGVzZXMgY2FuIGJlIHdyYXBwZWQgYXJvdW5kIGJsb2NrcyBvZiBjb2RlLlxuXHRSZXdyaXRlci5wcm90b3R5cGUucmV3cml0ZSA9IGZ1bmN0aW9uICh0b2tlbnMsb3B0cyl7XG5cdFx0dmFyIHRva2VuO1xuXHRcdGlmKG9wdHMgPT09IHVuZGVmaW5lZCkgb3B0cyA9IHt9O1xuXHRcdHRoaXMuX3Rva2VucyA9IHRva2Vucztcblx0XHR0aGlzLl9vcHRpb25zID0gb3B0cztcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyBcInRva2VucyBpbjogXCIgKyB0b2tlbnM6bGVuZ3RoXG5cdFx0aWYgKG9wdHMucHJvZmlsZSkgeyBjb25zb2xlLnRpbWUoXCJ0b2tlbml6ZTpyZXdyaXRlXCIpIH07XG5cdFx0XG5cdFx0dmFyIGkgPSAwO1xuXHRcdC8vIGZsYWcgZW1wdHkgbWV0aG9kc1xuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHR2YXIgbmV4dCA9IHRva2Vuc1tpICsgMV07XG5cdFx0XHRpZiAodG9rZW4uX3R5cGUgPT0gJ0RFRl9CT0RZJyAmJiBuZXh0ICYmIG5leHQuX3R5cGUgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdHRva2VuLl90eXBlID0gJ0RFRl9FTVBUWSc7XG5cdFx0XHR9O1xuXHRcdFx0aSsrO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5zdGVwKFwiZW5zdXJlRmlyc3RMaW5lXCIpO1xuXHRcdHRoaXMuc3RlcChcInJlbW92ZUxlYWRpbmdOZXdsaW5lc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJyZW1vdmVNaWRFeHByZXNzaW9uTmV3bGluZXNcIik7XG5cdFx0dGhpcy5zdGVwKFwidGFnRGVmQXJndW1lbnRzXCIpO1xuXHRcdHRoaXMuc3RlcChcImNsb3NlT3BlbkNhbGxzXCIpO1xuXHRcdHRoaXMuc3RlcChcImNsb3NlT3BlbkluZGV4ZXNcIik7XG5cdFx0dGhpcy5zdGVwKFwiY2xvc2VPcGVuVGFnc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJjbG9zZU9wZW5UYWdBdHRyTGlzdHNcIik7XG5cdFx0dGhpcy5zdGVwKFwiYWRkSW1wbGljaXRJbmRlbnRhdGlvblwiKTtcblx0XHR0aGlzLnN0ZXAoXCJ0YWdQb3N0Zml4Q29uZGl0aW9uYWxzXCIpO1xuXHRcdHRoaXMuc3RlcChcImFkZEltcGxpY2l0QnJhY2VzXCIpO1xuXHRcdHRoaXMuc3RlcChcImFkZEltcGxpY2l0UGFyZW50aGVzZXNcIik7XG5cdFx0XG5cdFx0aWYgKG9wdHMucHJvZmlsZSkgeyBjb25zb2xlLnRpbWVFbmQoXCJ0b2tlbml6ZTpyZXdyaXRlXCIpIH07XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJ0b2tlbnMgb3V0OiBcIiArIEB0b2tlbnM6bGVuZ3RoXG5cdFx0cmV0dXJuIHRoaXMuX3Rva2Vucztcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKGZuKXtcblx0XHRpZiAodGhpcy5fb3B0aW9ucy5wcm9maWxlKSB7XG5cdFx0XHRjb25zb2xlLmxvZygoXCItLS0tIHN0YXJ0aW5nIFwiICsgZm4gKyBcIiAtLS0tIFwiKSk7XG5cdFx0XHRjb25zb2xlLnRpbWUoZm4pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpc1tmbl0oKTtcblx0XHRcblx0XHRpZiAodGhpcy5fb3B0aW9ucy5wcm9maWxlKSB7XG5cdFx0XHRjb25zb2xlLnRpbWVFbmQoZm4pO1xuXHRcdFx0Y29uc29sZS5sb2coXCJcXG5cXG5cIik7XG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBSZXdyaXRlIHRoZSB0b2tlbiBzdHJlYW0sIGxvb2tpbmcgb25lIHRva2VuIGFoZWFkIGFuZCBiZWhpbmQuXG5cdC8vIEFsbG93IHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGJsb2NrIHRvIHRlbGwgdXMgaG93IG1hbnkgdG9rZW5zIHRvIG1vdmVcblx0Ly8gZm9yd2FyZHMgKG9yIGJhY2t3YXJkcykgaW4gdGhlIHN0cmVhbSwgdG8gbWFrZSBzdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmdcblx0Ly8gYXMgdG9rZW5zIGFyZSBpbnNlcnRlZCBhbmQgcmVtb3ZlZCwgYW5kIHRoZSBzdHJlYW0gY2hhbmdlcyBsZW5ndGggdW5kZXJcblx0Ly8gb3VyIGZlZXQuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5zY2FuVG9rZW5zID0gZnVuY3Rpb24gKGJsb2NrKXtcblx0XHR2YXIgdG9rZW47XG5cdFx0dmFyIHRva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHRcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdGkgKz0gYmxvY2suY2FsbCh0aGlzLHRva2VuLGksdG9rZW5zKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmRldGVjdEVuZCA9IGZ1bmN0aW9uIChpLGNvbmRpdGlvbixhY3Rpb24pe1xuXHRcdHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7XG5cdFx0dmFyIGxldmVscyA9IDA7XG5cdFx0dmFyIHN0YXJ0cyA9IFtdO1xuXHRcdHZhciB0b2tlbjtcblx0XHR2YXIgdCx2O1xuXHRcdFxuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHRpZiAobGV2ZWxzID09IDAgJiYgY29uZGl0aW9uLmNhbGwodGhpcyx0b2tlbixpLHN0YXJ0cykpIHtcblx0XHRcdFx0cmV0dXJuIGFjdGlvbi5jYWxsKHRoaXMsdG9rZW4saSk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCF0b2tlbiB8fCBsZXZlbHMgPCAwKSB7XG5cdFx0XHRcdHJldHVybiBhY3Rpb24uY2FsbCh0aGlzLHRva2VuLGkgLSAxKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHQgPSBULnR5cCh0b2tlbik7XG5cdFx0XHRcblx0XHRcdGlmIChFWFBSRVNTSU9OX1NUQVJULmluZGV4T2YodCkgPj0gMCkge1xuXHRcdFx0XHRpZiAobGV2ZWxzID09IDApIHsgc3RhcnRzLnB1c2goaSkgfTtcblx0XHRcdFx0bGV2ZWxzICs9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKEVYUFJFU1NJT05fRU5ELmluZGV4T2YodCkgPj0gMCkge1xuXHRcdFx0XHRsZXZlbHMgLT0gMTtcblx0XHRcdH07XG5cdFx0XHRpICs9IDE7XG5cdFx0fTtcblx0XHRyZXR1cm4gaSAtIDE7XG5cdH07XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUuZW5zdXJlRmlyc3RMaW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRvayA9IHRoaXMuX3Rva2Vuc1swXTtcblx0XHRcblx0XHRpZiAoVC50eXAodG9rKSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkaW5nIGJvZHlzdGFydFwiXG5cdFx0XHR0aGlzLl90b2tlbnMgPSBbVC50b2tlbignQk9EWVNUQVJUJywnQk9EWVNUQVJUJyldLmNvbmNhdCh0aGlzLl90b2tlbnMpO1xuXHRcdFx0Ly8gVC5zZXRUeXAodG9rLCdIRUFERVInKVxuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gTGVhZGluZyBuZXdsaW5lcyB3b3VsZCBpbnRyb2R1Y2UgYW4gYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyLCBzbyB3ZVxuXHQvLyBkaXNwYXRjaCB0aGVtIGhlcmUuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5yZW1vdmVMZWFkaW5nTmV3bGluZXMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYXQgPSAwO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl90b2tlbnMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChULnR5cChhcnlbaV0pICE9ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHRhdCA9IGk7YnJlYWs7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGF0KSB7IHRoaXMuX3Rva2Vucy5zcGxpY2UoMCxhdCkgfTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBTb21lIGJsb2NrcyBvY2N1ciBpbiB0aGUgbWlkZGxlIG9mIGV4cHJlc3Npb25zIC0tIHdoZW4gd2UncmUgZXhwZWN0aW5nXG5cdC8vIHRoaXMsIHJlbW92ZSB0aGVpciB0cmFpbGluZyBuZXdsaW5lcy5cblx0UmV3cml0ZXIucHJvdG90eXBlLnJlbW92ZU1pZEV4cHJlc3Npb25OZXdsaW5lcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGksdG9rZW5zKSB7IC8vIGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdHZhciBuZXh0ID0gc2VsZi50b2tlblR5cGUoaSArIDEpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIShULnR5cCh0b2tlbikgPT0gJ1RFUk1JTkFUT1InICYmIEVYUFJFU1NJT05fQ0xPU0UuaW5kZXhPZihuZXh0KSA+PSAwKSkgeyByZXR1cm4gMSB9O1xuXHRcdFx0aWYgKG5leHQgPT0gJ09VVERFTlQnKSB7IHJldHVybiAxIH07XG5cdFx0XHR0b2tlbnMuc3BsaWNlKGksMSk7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9KTtcblx0fTtcblx0XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUudGFnRGVmQXJndW1lbnRzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvLyBUaGUgbGV4ZXIgaGFzIHRhZ2dlZCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvZiBhIG1ldGhvZCBjYWxsLiBNYXRjaCBpdCB3aXRoXG5cdC8vIGl0cyBwYWlyZWQgY2xvc2UuIFdlIGhhdmUgdGhlIG1pcy1uZXN0ZWQgb3V0ZGVudCBjYXNlIGluY2x1ZGVkIGhlcmUgZm9yXG5cdC8vIGNhbGxzIHRoYXQgY2xvc2Ugb24gdGhlIHNhbWUgbGluZSwganVzdCBiZWZvcmUgdGhlaXIgb3V0ZGVudC5cblx0UmV3cml0ZXIucHJvdG90eXBlLmNsb3NlT3BlbkNhbGxzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHR2YXIgdCA9IFQudHlwKHRva2VuKTtcblx0XHRcdHJldHVybiAodCA9PSAnKScgfHwgdCA9PSAnQ0FMTF9FTkQnKSB8fCB0ID09ICdPVVRERU5UJyAmJiBzZWxmLnRva2VuVHlwZShpIC0gMSkgPT0gJyknO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHZhciB0ID0gVC50eXAodG9rZW4pO1xuXHRcdFx0dmFyIHRvayA9IHNlbGYuX3Rva2Vuc1t0ID09ICdPVVRERU5UJyA/IChpIC0gMSkgOiAoaSldO1xuXHRcdFx0cmV0dXJuIFQuc2V0VHlwKHRvaywnQ0FMTF9FTkQnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0aWYgKFQudHlwKHRva2VuKSA9PSAnQ0FMTF9TVEFSVCcpIHsgc2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGFjdGlvbikgfTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0Ly8gVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYW4gaW5kZXhpbmcgb3BlcmF0aW9uIGNhbGwuXG5cdC8vIE1hdGNoIGl0IHdpdGggaXRzIHBhaXJlZCBjbG9zZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLmNsb3NlT3BlbkluZGV4ZXMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIGlkeCQoVC50eXAodG9rZW4pLFsnXScsJ0lOREVYX0VORCddKSA+PSAwOyB9O1xuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBULnNldFR5cCh0b2tlbiwnSU5ERVhfRU5EJyk7IH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRpZiAoVC50eXAodG9rZW4pID09ICdJTkRFWF9TVEFSVCcpIHsgc2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGFjdGlvbikgfTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5jbG9zZU9wZW5UYWdBdHRyTGlzdHMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIGlkeCQoVC50eXAodG9rZW4pLFsnKScsJ1RBR19BVFRSU19FTkQnXSkgPj0gMDsgfTtcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gVC5zZXRUeXAodG9rZW4sJ1RBR19BVFRSU19FTkQnKTsgfTsgLy8gJ1RBR19BVFRSU19FTkQnXG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRpZiAoVC50eXAodG9rZW4pID09ICdUQUdfQVRUUlNfU1RBUlQnKSB7IHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmRpdGlvbixhY3Rpb24pIH07XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdC8vIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGFuIGluZGV4aW5nIG9wZXJhdGlvbiBjYWxsLlxuXHQvLyBNYXRjaCBpdCB3aXRoIGl0cyBwYWlyZWQgY2xvc2UuIFNob3VsZCBiZSBkb25lIGluIGxleGVyIGRpcmVjdGx5XG5cdFJld3JpdGVyLnByb3RvdHlwZS5jbG9zZU9wZW5UYWdzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBpZHgkKFQudHlwKHRva2VuKSxbJz4nLCdUQUdfRU5EJ10pID49IDA7IH07XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIFQuc2V0VHlwKHRva2VuLCdUQUdfRU5EJyk7IH07IC8vIHRva2VuWzBdID0gJ1RBR19FTkQnXG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRpZiAoVC50eXAodG9rZW4pID09ICdUQUdfU1RBUlQnKSB7IHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmRpdGlvbixhY3Rpb24pIH07XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdENvbW1hcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdEJsb2NrQ2FsbHMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rZW47XG5cdFx0dmFyIGkgPSAxO1xuXHRcdHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7XG5cdFx0XG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdHZhciB0ID0gdG9rZW4uX3R5cGU7XG5cdFx0XHR2YXIgdiA9IHRva2VuLl92YWx1ZTtcblx0XHRcdC8vIGhtbVxuXHRcdFx0aWYgKHQgPT0gJ0RPJyAmJiAodiA9PSAnSU5ERVhfRU5EJyB8fCB2ID09ICdJREVOVElGSUVSJyB8fCB2ID09ICdORVcnKSkge1xuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGkgKyAxLDAsVC50b2tlbignQ0FMTF9FTkQnLCcpJykpO1xuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGkgKyAxLDAsVC50b2tlbignQ0FMTF9TVEFSVCcsJygnKSk7XG5cdFx0XHRcdGkrKztcblx0XHRcdH07XG5cdFx0XHRpKys7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBPYmplY3QgbGl0ZXJhbHMgbWF5IGJlIHdyaXR0ZW4gd2l0aCBpbXBsaWNpdCBicmFjZXMsIGZvciBzaW1wbGUgY2FzZXMuXG5cdC8vIEluc2VydCB0aGUgbWlzc2luZyBicmFjZXMgaGVyZSwgc28gdGhhdCB0aGUgcGFyc2VyIGRvZXNuJ3QgaGF2ZSB0by5cblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0QnJhY2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciBzdGFydCA9IG51bGw7XG5cdFx0dmFyIHN0YXJ0SW5kZW50ID0gMDtcblx0XHR2YXIgc3RhcnRJZHggPSBudWxsO1xuXHRcdFxuXHRcdHZhciBub0JyYWNlVGFnID0gWydDTEFTUycsJ0lGJywnVU5MRVNTJywnVEFHJywnV0hJTEUnLCdGT1InLCdVTlRJTCcsJ0NBVENIJywnRklOQUxMWScsJ01PRFVMRScsJ0xFQURJTkdfV0hFTiddO1xuXHRcdHZhciBub0JyYWNlQ29udGV4dCA9IFsnSUYnLCdURVJOQVJZJywnRk9SJ107XG5cdFx0XG5cdFx0dmFyIG5vQnJhY2UgPSBmYWxzZTtcblx0XHRcblx0XHR2YXIgc2NvcGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSB8fCBbXTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdG9rZW5zLnNwbGljZShpLDAsVC5SQlJBQ0tFVCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgb3BlbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHJldHVybiBzZWxmLl90b2tlbnMuc3BsaWNlKGksMCxULkxCUkFDS0VUKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBjbG9zZSA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHJldHVybiBzZWxmLl90b2tlbnMuc3BsaWNlKGksMCxULlJCUkFDS0VUKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBzdGFja1Rva2VuID0gZnVuY3Rpb24oYSxiKSB7XG5cdFx0XHRyZXR1cm4gW2EsYl07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGksdG9rZW5zKSB7XG5cdFx0XHR2YXIgdHlwZSA9IFQudHlwKHRva2VuKTtcblx0XHRcdHZhciB2ID0gVC52YWwodG9rZW4pO1xuXHRcdFx0dmFyIGN0eCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdIHx8IFtdO1xuXHRcdFx0dmFyIGlkeDtcblx0XHRcdFxuXHRcdFx0aWYgKG5vQnJhY2VDb250ZXh0LmluZGV4T2YodHlwZSkgPj0gMCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImZvdW5kIG5vQnJhY2VUYWcge3R5cGV9XCJcblx0XHRcdFx0c3RhY2sucHVzaChzdGFja1Rva2VuKHR5cGUsaSkpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh2ID09ICc/Jykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnVEVSTkFSWSBPUEVSQVRPUiEnKVxuXHRcdFx0XHRzdGFjay5wdXNoKHN0YWNrVG9rZW4oJ1RFUk5BUlknLGkpKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBubyBuZWVkIHRvIHRlc3QgZm9yIHRoaXMgaGVyZSBhcyB3ZWxsIGFzIGluXG5cdFx0XHRpZiAoRVhQUkVTU0lPTl9TVEFSVC5pbmRleE9mKHR5cGUpID49IDApIHtcblx0XHRcdFx0aWYgKHR5cGUgPT0gJ0lOREVOVCcgJiYgbm9CcmFjZUNvbnRleHQuaW5kZXhPZihjdHhbMF0pID49IDApIHtcblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdleHByZXNzaW9uIHN0YXJ0Jyx0eXBlLGN0eFswXSlcblx0XHRcdFx0aWYgKHR5cGUgPT0gJ0lOREVOVCcgJiYgc2VsZi50b2tlblR5cGUoaSAtIDEpID09ICd7Jykge1xuXHRcdFx0XHRcdC8vIHN0YWNrID8hPyBubyB0b2tlblxuXHRcdFx0XHRcdHN0YWNrLnB1c2goc3RhY2tUb2tlbigneycsaSkpOyAvLyBzaG91bGQgbm90IGF1dG9nZW5lcmF0ZSBhbm90aGVyP1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YWNrLnB1c2goc3RhY2tUb2tlbih0eXBlLGkpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoRVhQUkVTU0lPTl9FTkQuaW5kZXhPZih0eXBlKSA+PSAwKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiRVhQUkVTU0lPTl9FTkQgYXQge3R5cGV9IC0gc3RhY2sgaXMge2N0eFswXX1cIlxuXHRcdFx0XHRpZiAoY3R4WzBdID09ICdURVJOQVJZJykgeyAvLyBGSVg/XG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGFydCA9IHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRpZiAoIXN0YXJ0KSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJOTyBTVEFDSyEhXCIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRzdGFydFsyXSA9IGk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBzZWVtcyBsaWtlIHRoZSBzdGFjayBzaG91bGQgdXNlIHRva2Vucywgbm8/KVxuXHRcdFx0XHRpZiAoc3RhcnRbMF0gPT0gJ3snICYmIHN0YXJ0LmdlbmVyYXRlZCkgeyAvLyAgIyB0eXBlICE9ICd9JyAjIGFuZCBzdGFydDpnZW5lcmF0ZWRcblx0XHRcdFx0XHRjbG9zZSh0b2tlbixpKTtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gaXMgdGhpcyBjb3JyZWN0PyBzYW1lIGZvciBpZi9jbGFzcyBldGM/XG5cdFx0XHRpZiAoY3R4WzBdID09ICdURVJOQVJZJyAmJiAodHlwZSA9PSAnVEVSTUlOQVRPUicgfHwgdHlwZSA9PSAnT1VUREVOVCcpKSB7XG5cdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPj0gMCAmJiB0eXBlID09ICdJTkRFTlQnKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwicG9wcGluZyBub0JyYWNlQ29udGV4dFwiKTtcblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnLCcpIHtcblx0XHRcdFx0Ly8gYXV0b21hdGljYWxseSBhZGQgYW4gZW5kaW5nIGhlcmUgaWYgaW5zaWRlOmdlbmVyYXRlZCBzY29wZT9cblx0XHRcdFx0Ly8gaXQgaXMgaW1wb3J0YW50IHRoYXQgdGhpcyBpczpnZW5lcmF0ZWQoISlcblx0XHRcdFx0aWYgKGN0eFswXSA9PSAneycgJiYgY3R4LmdlbmVyYXRlZCkge1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwwLFQuUkJSQUNLRVQpO1xuXHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0cnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gZm91bmQgYSB0eXBlXG5cdFx0XHRpZiAodHlwZSA9PSAnOicgJiYgY3R4WzBdICE9ICd7JyAmJiBjdHhbMF0gIT0gJ1RFUk5BUlknICYmIChub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPT0gLTEpKSB7XG5cdFx0XHRcdC8vIGNvdWxkIGp1c3QgY2hlY2sgaWYgdGhlIGVuZCB3YXMgcmlnaHQgYmVmb3JlIHRoaXM/XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3RhcnQgJiYgc3RhcnRbMl0gPT0gaSAtIDEpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygndGhpcyBleHByZXNzaW9uIHdhcyBqdXN0IGVuZGluZyBiZWZvcmUgY29sb24hJylcblx0XHRcdFx0XHRpZHggPSBzdGFydFsxXSAtIDE7IC8vIHRoZXNlIGFyZSB0aGUgc3RhY2tUb2tlbnNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcInJld3JpdGUgaGVyZT8gI3tpfVwiXG5cdFx0XHRcdFx0aWR4ID0gaSAtIDI7IC8vIGlmIHN0YXJ0IHRoZW4gc3RhcnRbMV0gLSAxIGVsc2UgaSAtIDJcblx0XHRcdFx0XHQvLyBpZHggPSBpZHggLSAxIGlmIHRva2VuVHlwZShpZHgpIGlzICdURVJNSU5BVE9SJ1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHNlbGYudG9rZW5UeXBlKGlkeCAtIDEpID09ICdIRVJFQ09NTUVOVCcpe1xuXHRcdFx0XHRcdGlkeCAtPSAyO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHQwID0gdG9rZW5zW2lkeCAtIDFdO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHQwICYmIFQudHlwKHQwKSA9PSAnfScgJiYgdDAuZ2VuZXJhdGVkKSB7XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpZHggLSAxLDEpO1xuXHRcdFx0XHRcdHZhciBzID0gc3RhY2tUb2tlbigneycpO1xuXHRcdFx0XHRcdHMuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHMpO1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQwICYmIFQudHlwKHQwKSA9PSAnLCcgJiYgc2VsZi50b2tlblR5cGUoaWR4IC0gMikgPT0gJ30nKSB7XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpZHggLSAyLDEpO1xuXHRcdFx0XHRcdHMgPSBzdGFja1Rva2VuKCd7Jyk7XG5cdFx0XHRcdFx0cy5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHN0YWNrLnB1c2gocyk7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cyA9IHN0YWNrVG9rZW4oJ3snKTtcblx0XHRcdFx0XHRzLmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChzKTtcblx0XHRcdFx0XHRvcGVuKHRva2VuLGlkeCArIDEpO1xuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gd2UgcHJvYmFibHkgbmVlZCB0byBydW4gdGhyb3VnaCBhdXRvY2FsbCBmaXJzdD8hXG5cdFx0XHRcblx0XHRcdGlmICh0eXBlID09ICdETycpIHsgLy8gYW5kIGN0eDpnZW5lcmF0ZWRcblx0XHRcdFx0dmFyIHByZXYgPSBULnR5cCh0b2tlbnNbaSAtIDFdKTsgLy8gWzBdXG5cdFx0XHRcdGlmIChbJ05VTUJFUicsJ1NUUklORycsJ1JFR0VYJywnU1lNQk9MJywnXScsJ30nLCcpJywnU1RSSU5HX0VORCddLmluZGV4T2YocHJldikgPj0gMCkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciB0b2sgPSBULnRva2VuKCcsJywnLCcpO1xuXHRcdFx0XHRcdHRvay5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwwLHRvayk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGN0eC5nZW5lcmF0ZWQpIHtcblx0XHRcdFx0XHRcdGNsb3NlKHRva2VuLGkpO1xuXHRcdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKCh0eXBlID09ICdURVJNSU5BVE9SJyB8fCB0eXBlID09ICdPVVRERU5UJyB8fCB0eXBlID09ICdERUZfQk9EWScpICYmIGN0eC5nZW5lcmF0ZWQpIHtcblx0XHRcdFx0Y2xvc2UodG9rZW4saSk7XG5cdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0Ly8gTWV0aG9kcyBtYXkgYmUgb3B0aW9uYWxseSBjYWxsZWQgd2l0aG91dCBwYXJlbnRoZXNlcywgZm9yIHNpbXBsZSBjYXNlcy5cblx0Ly8gSW5zZXJ0IHRoZSBpbXBsaWNpdCBwYXJlbnRoZXNlcyBoZXJlLCBzbyB0aGF0IHRoZSBwYXJzZXIgZG9lc24ndCBoYXZlIHRvXG5cdC8vIGRlYWwgd2l0aCB0aGVtLlxuXHQvLyBQcmFjdGljYWxseSBldmVyeXRoaW5nIHdpbGwgbm93IGJlIGNhbGxhYmxlIHRoaXMgd2F5IChldmVyeSBpZGVudGlmaWVyKVxuXHRSZXdyaXRlci5wcm90b3R5cGUuYWRkSW1wbGljaXRQYXJlbnRoZXNlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdHZhciBzZWxmID0gdGhpcywgdG9rZW47XG5cdFx0dmFyIG5vQ2FsbFRhZyA9IFsnQ0xBU1MnLCdJRicsJ1VOTEVTUycsJ1RBRycsJ1dISUxFJywnRk9SJywnVU5USUwnLCdDQVRDSCcsJ0ZJTkFMTFknLCdNT0RVTEUnLCdMRUFESU5HX1dIRU4nXTtcblx0XHRcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0cmV0dXJuIHNlbGYuX3Rva2Vucy5zcGxpY2UoaSwwLFQudG9rZW4oJ0NBTExfRU5EJywnKScpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkaW5nIGltcGxpY2l0IHBhcmVudGhlc2lzXCIgIyAsc2VsZjpzY2FuVG9rZW5zXG5cdFx0dmFyIHRva2VucyA9IHNlbGYuX3Rva2Vucztcblx0XHRcblx0XHR2YXIgbm9DYWxsID0gZmFsc2U7XG5cdFx0dmFyIHNlZW5Gb3IgPSBmYWxzZTtcblx0XHR2YXIgZW5kQ2FsbEF0VGVybWluYXRvciA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBpID0gMDtcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0XG5cdFx0XHQvLyB0byBoYW5kbGUgY2FzZXMgbGlrZTpcblx0XHRcdC8vIGlmIGEoZG8geWVzKS50ZXN0XG5cdFx0XHQvLyBcdHllc1xuXHRcdFx0Ly8gd2UgbmVlZCB0byBrZWVwIGEgc3RhY2sgZm9yIGJhbGFuY2VkIHBhaXJzXG5cdFx0XHQvLyB1bnRpbCB0aGVuIHlvdSBtdXN0IGV4cGxpY2l0bHkgZW5kIHRoZSBjYWxsIGxpa2Vcblx0XHRcdC8vIGlmIGEoZG8geWVzKS50ZXN0KClcblx0XHRcdC8vIFx0eWVzXG5cdFx0XHRcblx0XHRcdHZhciB0eXBlID0gdG9rZW4uX3R5cGU7XG5cdFx0XHRcblx0XHRcdHZhciBwcmV2ID0gdG9rZW5zW2kgLSAxXTtcblx0XHRcdHZhciBjdXJyZW50ID0gdG9rZW5zW2ldO1xuXHRcdFx0dmFyIG5leHQgPSB0b2tlbnNbaSArIDFdO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHQgPSBwcmV2ICYmIHByZXYuX3R5cGU7XG5cdFx0XHR2YXIgbnQgPSBuZXh0ICYmIG5leHQuX3R5cGU7XG5cdFx0XHRcblx0XHRcdC8vIGlmIHB0ID09ICdXSEVOJ1xuXHRcdFx0Ly8gTmV2ZXIgbWFrZSB0aGVzZSB0YWdzIGltcGxpY2l0bHkgY2FsbFxuXHRcdFx0Ly8gc2hvdWxkIHdlIG5vdCBqdXN0IHJlbW92ZSB0aGVzZSBmcm9tIElNUExJQ0lUX0ZVTkM/XG5cdFx0XHRpZiAoKHB0ID09ICcpJyB8fCBwdCA9PSAnXScpICYmIHR5cGUgPT0gJ0lOREVOVCcpIHtcblx0XHRcdFx0bm9DYWxsID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChub0NhbGxUYWcuaW5kZXhPZihwdCkgPj0gMCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInNlZW4gbm9jYWxsIHRhZyB7cHR9ICh7cHR9IHt0eXBlfSB7bnR9KVwiKVxuXHRcdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0gdHJ1ZTtcblx0XHRcdFx0bm9DYWxsID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHB0ID09ICdGT1InKSB7IHNlZW5Gb3IgPSB0cnVlIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHZhciBjYWxsT2JqZWN0ID0gZmFsc2U7XG5cdFx0XHR2YXIgY2FsbEluZGVudCA9IGZhbHNlO1xuXHRcdFx0XG5cdFx0XHQvLyBbcHJldiwgY3VycmVudCwgbmV4dF0gPSB0b2tlbnNbaSAtIDEgLi4gaSArIDFdXG5cdFx0XHRcblx0XHRcdC8vIGNoZWNrIGZvciBjb21tZW50c1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJkZXRlY3QgZW5kPz9cIlxuXHRcdFx0aWYgKCFub0NhbGwgJiYgdHlwZSA9PSAnSU5ERU5UJyAmJiBuZXh0KSB7XG5cdFx0XHRcdHZhciBwcmV2SW1wRnVuYyA9IHB0ICYmIElNUExJQ0lUX0ZVTkMuaW5kZXhPZihwdCkgPj0gMDtcblx0XHRcdFx0dmFyIG5leHRJbXBDYWxsID0gbnQgJiYgSU1QTElDSVRfQ0FMTC5pbmRleE9mKG50KSA+PSAwO1xuXHRcdFx0XHRjYWxsT2JqZWN0ID0gKChuZXh0LmdlbmVyYXRlZCAmJiBudCA9PSAneycpIHx8IG5leHRJbXBDYWxsKSAmJiBwcmV2SW1wRnVuYztcblx0XHRcdFx0Y2FsbEluZGVudCA9IG5leHRJbXBDYWxsICYmIHByZXZJbXBGdW5jO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHNlZW5TaW5nbGUgPSBmYWxzZTtcblx0XHRcdHZhciBzZWVuQ29udHJvbCA9IGZhbHNlO1xuXHRcdFx0Ly8gSG1tID9cblx0XHRcdFxuXHRcdFx0Ly8gdGhpcyBpcyBub3QgY29ycmVjdCBpZiB0aGlzIGlzIGluc2lkZSBhIGJsb2NrLG5vP1xuXHRcdFx0aWYgKCh0eXBlID09ICdURVJNSU5BVE9SJyB8fCB0eXBlID09ICdPVVRERU5UJyB8fCB0eXBlID09ICdJTkRFTlQnKSkge1xuXHRcdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0gZmFsc2U7XG5cdFx0XHRcdG5vQ2FsbCA9IGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGUgPT0gJz8nICYmIHByZXYgJiYgIXByZXYuc3BhY2VkKSB7IHRva2VuLmNhbGwgPSB0cnVlIH07XG5cdFx0XHRcblx0XHRcdC8vIHdoZXJlIGRvZXMgZnJvbVRoZW0gY29tZSBmcm9tP1xuXHRcdFx0aWYgKHRva2VuLmZyb21UaGVuKSB7XG5cdFx0XHRcdGkgKz0gMTtjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHQvLyBoZXJlIHdlIGRlYWwgd2l0aCA6c3BhY2VkIGFuZCA6bmV3TGluZVxuXHRcdFx0aWYgKCEoY2FsbE9iamVjdCB8fCBjYWxsSW5kZW50IHx8IChwcmV2ICYmIHByZXYuc3BhY2VkKSAmJiAocHJldi5jYWxsIHx8IElNUExJQ0lUX0ZVTkMuaW5kZXhPZihwdCkgPj0gMCkgJiYgKElNUExJQ0lUX0NBTEwuaW5kZXhPZih0eXBlKSA+PSAwIHx8ICEodG9rZW4uc3BhY2VkIHx8IHRva2VuLm5ld0xpbmUpICYmIElNUExJQ0lUX1VOU1BBQ0VEX0NBTEwuaW5kZXhPZih0eXBlKSA+PSAwKSkpIHtcblx0XHRcdFx0aSArPSAxO2NvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHR0b2tlbnMuc3BsaWNlKGksMCxULnRva2VuKCdDQUxMX1NUQVJUJywnKCcpKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkZWQgKCB7cHJldn1cIlxuXHRcdFx0dmFyIGNvbmQgPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gVC50eXAodG9rZW4pO1xuXHRcdFx0XHRpZiAoIXNlZW5TaW5nbGUgJiYgdG9rZW4uZnJvbVRoZW4pIHsgcmV0dXJuIHRydWUgfTtcblx0XHRcdFx0dmFyIGlmZWxzZSA9IHR5cGUgPT0gJ0lGJyB8fCB0eXBlID09ICdVTkxFU1MnIHx8IHR5cGUgPT0gJ0VMU0UnO1xuXHRcdFx0XHRpZiAoaWZlbHNlIHx8IHR5cGUgPT0gJ0NBVENIJykgeyBzZWVuU2luZ2xlID0gdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoaWZlbHNlIHx8IHR5cGUgPT0gJ1NXSVRDSCcgfHwgdHlwZSA9PSAnVFJZJykgeyBzZWVuQ29udHJvbCA9IHRydWUgfTtcblx0XHRcdFx0dmFyIHByZXYgPSBzZWxmLnRva2VuVHlwZShpIC0gMSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoKHR5cGUgPT0gJy4nIHx8IHR5cGUgPT0gJz8uJyB8fCB0eXBlID09ICc6OicpICYmIHByZXYgPT0gJ09VVERFTlQnKSB7IHJldHVybiB0cnVlIH07XG5cdFx0XHRcdGlmIChlbmRDYWxsQXRUZXJtaW5hdG9yICYmICh0eXBlID09ICdJTkRFTlQnIHx8IHR5cGUgPT0gJ1RFUk1JTkFUT1InKSkgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoKHR5cGUgPT0gJ1dIRU4nIHx8IHR5cGUgPT0gJ0JZJykgJiYgIXNlZW5Gb3IpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImRvbnQgY2xvc2UgaW1wbGljaXQgY2FsbCBvdXRzaWRlIGZvclwiXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHBvc3QgPSB0b2tlbnNbaSArIDFdO1xuXHRcdFx0XHR2YXIgcG9zdFR5cCA9IHBvc3QgJiYgVC50eXAocG9zdCk7XG5cdFx0XHRcdC8vIFdURlxuXHRcdFx0XHRyZXR1cm4gIXRva2VuLmdlbmVyYXRlZCAmJiBwcmV2ICE9ICcsJyAmJiAoSU1QTElDSVRfRU5ELmluZGV4T2YodHlwZSkgPj0gMCB8fCAodHlwZSA9PSAnSU5ERU5UJyAmJiAhc2VlbkNvbnRyb2wpIHx8ICh0eXBlID09ICdET1MnICYmIHByZXYgIT0gJz0nKSkgJiYgKHR5cGUgIT0gJ0lOREVOVCcgfHwgKHNlbGYudG9rZW5UeXBlKGkgLSAyKSAhPSAnQ0xBU1MnICYmIElNUExJQ0lUX0JMT0NLLmluZGV4T2YocHJldikgPT0gLTEgJiYgIShwb3N0ICYmICgocG9zdC5nZW5lcmF0ZWQgJiYgcG9zdFR5cCA9PSAneycpIHx8IElNUExJQ0lUX0NBTEwuaW5kZXhPZihwb3N0VHlwKSA+PSAwKSkpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBhY3Rpb24gZm9yIGRldGVjdGluZyB3aGVuIHRoZSBjYWxsIHNob3VsZCBlbmRcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZGV0ZWN0IGVuZD8/XCJcblx0XHRcdHNlbGYuZGV0ZWN0RW5kKGkgKyAxLGNvbmQsYWN0aW9uKTtcblx0XHRcdGlmIChULnR5cChwcmV2KSA9PSAnPycpIHsgVC5zZXRUeXAocHJldiwnRlVOQ19FWElTVCcpIH07XG5cdFx0XHRpICs9IDI7XG5cdFx0XHQvLyBuZWVkIHRvIHJlc2V0IGFmdGVyIGEgbWF0Y2hcblx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSBmYWxzZTtcblx0XHRcdG5vQ2FsbCA9IGZhbHNlO1xuXHRcdFx0c2VlbkZvciA9IGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gQmVjYXVzZSBvdXIgZ3JhbW1hciBpcyBMQUxSKDEpLCBpdCBjYW4ndCBoYW5kbGUgc29tZSBzaW5nbGUtbGluZVxuXHQvLyBleHByZXNzaW9ucyB0aGF0IGxhY2sgZW5kaW5nIGRlbGltaXRlcnMuIFRoZSAqKlJld3JpdGVyKiogYWRkcyB0aGUgaW1wbGljaXRcblx0Ly8gYmxvY2tzLCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8uICcpJyBjYW4gY2xvc2UgYSBzaW5nbGUtbGluZSBibG9jayxcblx0Ly8gYnV0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgYmFsYW5jZWQuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdEluZGVudGF0aW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0XG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCB0b2tlbjtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHRva2VucyA9IHNlbGYuX3Rva2Vucztcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0dmFyIHR5cGUgPSBULnR5cCh0b2tlbik7XG5cdFx0XHR2YXIgbmV4dCA9IHNlbGYudG9rZW5UeXBlKGkgKyAxKTtcblx0XHRcdFxuXHRcdFx0Ly8gd2h5IGFyZSB3ZSByZW1vdmluZyB0ZXJtaW5hdG9ycyBhZnRlciB0aGVuPyBzaG91bGQgYmUgYWJsZSB0byBoYW5kbGVcblx0XHRcdGlmICh0eXBlID09ICdURVJNSU5BVE9SJyAmJiBuZXh0ID09ICdUSEVOJykge1xuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksMSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGUgPT0gJ0NBVENIJyAmJiBpZHgkKHNlbGYudG9rZW5UeXBlKGkgKyAyKSxbJ09VVERFTlQnLCdURVJNSU5BVE9SJywnRklOQUxMWSddKSA+PSAwKSB7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UuYXBwbHkodG9rZW5zLFtdLmNvbmNhdChbaSArIDIsMF0sIFtdLnNsaWNlLmNhbGwoc2VsZi5pbmRlbnRhdGlvbih0b2tlbikpKSk7XG5cdFx0XHRcdGkgKz0gNDtjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChTSU5HTEVfTElORVJTLmluZGV4T2YodHlwZSkgPj0gMCAmJiAobmV4dCAhPSAnSU5ERU5UJyAmJiBuZXh0ICE9ICdCTE9DS19QQVJBTV9TVEFSVCcpICYmICEodHlwZSA9PSAnRUxTRScgJiYgbmV4dCA9PSAnSUYnKSAmJiB0eXBlICE9ICdFTElGJykge1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHN0YXJ0ZXIgPSB0eXBlO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGluZGVudCA9IFQudG9rZW4oJ0lOREVOVCcsJzInKTtcblx0XHRcdFx0dmFyIG91dGRlbnQgPSBULk9VVERFTlQ7XG5cdFx0XHRcdC8vIHZhciBpbmRlbnQsIG91dGRlbnQgPSBpbmRlbnRhdGlvbih0b2tlbilcblx0XHRcdFx0aWYgKHN0YXJ0ZXIgPT0gJ1RIRU4nKSB7IGluZGVudC5mcm9tVGhlbiA9IHRydWUgfTsgLy8gc2V0dGluZyBzcGVjaWFsIHZhbHVlcyBmb3IgdGhlc2UgLS0gY2Fubm90IHJlYWxseSByZXVzZT9cblx0XHRcdFx0aW5kZW50LmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdC8vIG91dGRlbnQ6Z2VuZXJhdGVkID0gdHJ1ZVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGkgKyAxLDAsaW5kZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBjb25kaXRpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSBULnR5cCh0b2tlbik7XG5cdFx0XHRcdFx0cmV0dXJuIFQudmFsKHRva2VuKSAhPSAnOycgJiYgU0lOR0xFX0NMT1NFUlMuaW5kZXhPZih0KSA+PSAwICYmICEodCA9PSAnRUxTRScgJiYgc3RhcnRlciAhPSAnSUYnICYmIHN0YXJ0ZXIgIT0gJ1RIRU4nKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRcdFx0dmFyIGlkeCA9IHNlbGYudG9rZW5UeXBlKGkgLSAxKSA9PSAnLCcgPyAoaSAtIDEpIDogKGkpO1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMuc3BsaWNlKGlkeCwwLG91dGRlbnQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0c2VsZi5kZXRlY3RFbmQoaSArIDIsY29uZGl0aW9uLGFjdGlvbik7XG5cdFx0XHRcdGlmICh0eXBlID09ICdUSEVOJykgeyB0b2tlbnMuc3BsaWNlKGksMSkgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGkrKztcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIFRhZyBwb3N0Zml4IGNvbmRpdGlvbmFscyBhcyBzdWNoLCBzbyB0aGF0IHdlIGNhbiBwYXJzZSB0aGVtIHdpdGggYVxuXHQvLyBkaWZmZXJlbnQgcHJlY2VkZW5jZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLnRhZ1Bvc3RmaXhDb25kaXRpb25hbHMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIGlkeCQoVC50eXAodG9rZW4pLFsnVEVSTUlOQVRPUicsJ0lOREVOVCddKSA+PSAwOyB9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0dmFyIHR5cCA9IFQudHlwKHRva2VuKTtcblx0XHRcdGlmICghKHR5cCA9PSAnSUYnIHx8IHR5cCA9PSAnRk9SJykpIHsgcmV0dXJuIDEgfTtcblx0XHRcdHZhciBvcmlnaW5hbCA9IHRva2VuO1xuXHRcdFx0c2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdFx0aWYgKFQudHlwKHRva2VuKSAhPSAnSU5ERU5UJykgeyByZXR1cm4gVC5zZXRUeXAob3JpZ2luYWwsJ1BPU1RfJyArIFQudHlwKG9yaWdpbmFsKSkgfTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQvLyBHZW5lcmF0ZSB0aGUgaW5kZW50YXRpb24gdG9rZW5zLCBiYXNlZCBvbiBhbm90aGVyIHRva2VuIG9uIHRoZSBzYW1lIGxpbmUuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICh0b2tlbil7XG5cdFx0cmV0dXJuIFtULnRva2VuKCdJTkRFTlQnLCcyJyksVC50b2tlbignT1VUREVOVCcsJzInKV07XG5cdH07XG5cdFxuXHQvLyBMb29rIHVwIGEgdHlwZSBieSB0b2tlbiBpbmRleC5cblx0UmV3cml0ZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoaSl7XG5cdFx0Ly8gaWYgaSA8IDAgdGhlbiByZXR1cm4gbnVsbFxuXHRcdHZhciB0b2sgPSB0aGlzLl90b2tlbnNbaV07XG5cdFx0cmV0dXJuIHRvayAmJiBULnR5cCh0b2spO1xuXHRcdC8vIGlmIHRvayB0aGVuIHRva1swXSBlbHNlIG51bGxcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS50b2tlblR5cGUgPSBmdW5jdGlvbiAoaSl7XG5cdFx0dmFyIHRvayA9IHRoaXMuX3Rva2Vuc1tpXTtcblx0XHRyZXR1cm4gdG9rICYmIFQudHlwKHRvayk7XG5cdFx0Ly8gcmV0dXJuIHRvayBhbmQgdG9rWzBdXG5cdH07XG5cdFxuXHQvLyBDb25zdGFudHNcblx0Ly8gLS0tLS0tLS0tXG5cdFxuXHQvLyBMaXN0IG9mIHRoZSB0b2tlbiBwYWlycyB0aGF0IG11c3QgYmUgYmFsYW5jZWQuXG5cdHZhciBCQUxBTkNFRF9QQUlSUyA9IFtcblx0XHRbJygnLCcpJ10sXG5cdFx0WydbJywnXSddLFxuXHRcdFsneycsJ30nXSxcblx0XHRbJ3t7JywnfX0nXSxcblx0XHRbJ0lOREVOVCcsJ09VVERFTlQnXSxcblx0XHRbJ0NBTExfU1RBUlQnLCdDQUxMX0VORCddLFxuXHRcdFsnUEFSQU1fU1RBUlQnLCdQQVJBTV9FTkQnXSxcblx0XHRbJ0lOREVYX1NUQVJUJywnSU5ERVhfRU5EJ10sXG5cdFx0WydUQUdfU1RBUlQnLCdUQUdfRU5EJ10sXG5cdFx0WydUQUdfUEFSQU1fU1RBUlQnLCdUQUdfUEFSQU1fRU5EJ10sXG5cdFx0WydUQUdfQVRUUlNfU1RBUlQnLCdUQUdfQVRUUlNfRU5EJ10sXG5cdFx0WydCTE9DS19QQVJBTV9TVEFSVCcsJ0JMT0NLX1BBUkFNX0VORCddXG5cdF07XG5cdFxuXHQvLyBUaGUgaW52ZXJzZSBtYXBwaW5ncyBvZiBgQkFMQU5DRURfUEFJUlNgIHdlJ3JlIHRyeWluZyB0byBmaXggdXAsIHNvIHdlIGNhblxuXHQvLyBsb29rIHRoaW5ncyB1cCBmcm9tIGVpdGhlciBlbmQuXG5cdG1vZHVsZS5leHBvcnRzLklOVkVSU0VTID0gSU5WRVJTRVMgPSB7fTtcblx0XG5cdC8vIFRoZSB0b2tlbnMgdGhhdCBzaWduYWwgdGhlIHN0YXJ0L2VuZCBvZiBhIGJhbGFuY2VkIHBhaXIuXG5cdC8vIHZhciBFWFBSRVNTSU9OX1NUQVJUID0gW11cblx0Ly8gdmFyIEVYUFJFU1NJT05fRU5EICAgPSBbXVxuXHRcblx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKEJBTEFOQ0VEX1BBSVJTKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcGFpcjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cGFpciA9IGFyeVtpXTtcblx0XHR2YXIgbGVmdCA9IHBhaXJbMF07XG5cdFx0dmFyIHJpdGUgPSBwYWlyWzFdO1xuXHRcdElOVkVSU0VTW3JpdGVdID0gbGVmdDtcblx0XHRJTlZFUlNFU1tsZWZ0XSA9IHJpdGU7XG5cdH07XG5cdFxuXHR2YXIgRVhQUkVTU0lPTl9TVEFSVCA9IFsnKCcsJ1snLCd7JywnSU5ERU5UJywnQ0FMTF9TVEFSVCcsJ1BBUkFNX1NUQVJUJywnSU5ERVhfU1RBUlQnLCdUQUdfUEFSQU1fU1RBUlQnLCdCTE9DS19QQVJBTV9TVEFSVCcsJ1NUUklOR19TVEFSVCcsJ3t7JywnVEFHX1NUQVJUJ107XG5cdHZhciBFWFBSRVNTSU9OX0VORCA9IFsnKScsJ10nLCd9JywnT1VUREVOVCcsJ0NBTExfRU5EJywnUEFSQU1fRU5EJywnSU5ERVhfRU5EJywnVEFHX1BBUkFNX0VORCcsJ0JMT0NLX1BBUkFNX0VORCcsJ1NUUklOR19FTkQnLCd9fScsJ1RBR19FTkQnXTtcblx0XG5cdHZhciBJREVOVElGSUVSUyA9IFsnSURFTlRJRklFUicsJ0dWQVInLCdJVkFSJywnQ1ZBUicsJ0NPTlNUJywnQVJHVkFSJ107XG5cdFxuXHQvLyBUb2tlbnMgdGhhdCBpbmRpY2F0ZSB0aGUgY2xvc2Ugb2YgYSBjbGF1c2Ugb2YgYW4gZXhwcmVzc2lvbi5cblx0dmFyIEVYUFJFU1NJT05fQ0xPU0UgPSBbJ0NBVENIJywnV0hFTicsJ0VMU0UnLCdGSU5BTExZJ10uY29uY2F0KEVYUFJFU1NJT05fRU5EKTtcblx0XG5cdC8vIFRva2VucyB0aGF0LCBpZiBmb2xsb3dlZCBieSBhbiBgSU1QTElDSVRfQ0FMTGAsIGluZGljYXRlIGEgZnVuY3Rpb24gaW52b2NhdGlvbi5cblx0dmFyIElNUExJQ0lUX0ZVTkMgPSBbJ0lERU5USUZJRVInLCdTVVBFUicsJ0AnLCdUSElTJywnU0VMRicsJ0VWRU5UJywnVFJJR0dFUicsJ1RBR19FTkQnLCdJVkFSJyxcblx0J0dWQVInLCdDT05TVCcsJ0FSR1ZBUicsJ05FVycsJ0JSRUFLJywnQ09OVElOVUUnLCdSRVRVUk4nXTtcblx0XG5cdC8vIElmIHByZWNlZGVkIGJ5IGFuIGBJTVBMSUNJVF9GVU5DYCwgaW5kaWNhdGVzIGEgZnVuY3Rpb24gaW52b2NhdGlvbi5cblx0dmFyIElNUExJQ0lUX0NBTEwgPSBbXG5cdFx0J1NFTEVDVE9SJywnSURFTlRJRklFUicsJ05VTUJFUicsJ1NUUklORycsJ1NZTUJPTCcsJ0pTJywnUkVHRVgnLCdORVcnLCdQQVJBTV9TVEFSVCcsJ0NMQVNTJyxcblx0XHQnSUYnLCdVTkxFU1MnLCdUUlknLCdTV0lUQ0gnLCdUSElTJywnQk9PTCcsJ1RSVUUnLCdGQUxTRScsJ05VTEwnLCdVTkRFRklORUQnLCdVTkFSWScsJ1NVUEVSJywnSVZBUicsJ0dWQVInLCdDT05TVCcsJ0FSR1ZBUicsJ1NFTEYnLFxuXHRcdCdAJywnWycsJygnLCd7JywnLS0nLCcrKycsJ1NFTEVDVE9SJywnVEFHX1NUQVJUJywnVEFHSUQnLCcjJywnU0VMRUNUT1JfU1RBUlQnLCdJRFJFRicsJ1NQTEFUJywnRE8nLCdCTE9DS19BUkcnLFxuXHRcdCdGT1InLCdTVFJJTkdfU1RBUlQnLCdDT05USU5VRScsJ0JSRUFLJ1xuXHRdOyAvLyAnLT4nLCAnPT4nLCB3aHkgZG9lcyBpdCBub3Qgd29yayB3aXRoIHN5bWJvbD9cblx0XG5cdHZhciBJTVBMSUNJVF9JTkRFTlRfQ0FMTCA9IFtcblx0XHQnRk9SJ1xuXHRdO1xuXHQvLyBpcyBub3QgZG8gYW4gaW1wbGljaXQgY2FsbD8/XG5cdFxuXHR2YXIgSU1QTElDSVRfVU5TUEFDRURfQ0FMTCA9IFsnKycsJy0nXTtcblx0XG5cdC8vIFRva2VucyBpbmRpY2F0aW5nIHRoYXQgdGhlIGltcGxpY2l0IGNhbGwgbXVzdCBlbmNsb3NlIGEgYmxvY2sgb2YgZXhwcmVzc2lvbnMuXG5cdHZhciBJTVBMSUNJVF9CTE9DSyA9IFsneycsJ1snLCcsJywnQkxPQ0tfUEFSQU1fRU5EJywnRE8nXTsgLy8gJy0+JywgJz0+JywgXG5cdFxuXHR2YXIgQ09ORElUSU9OQUxfQVNTSUdOID0gWyd8fD0nLCcmJj0nLCc/PScsJyY9JywnfD0nXTtcblx0dmFyIENPTVBPVU5EX0FTU0lHTiA9IFsnLT0nLCcrPScsJy89JywnKj0nLCclPScsJ3x8PScsJyYmPScsJz89JywnPDw9JywnPj49JywnPj4+PScsJyY9JywnXj0nLCd8PSddO1xuXHR2YXIgVU5BUlkgPSBbJyEnLCd+JywnTkVXJywnVFlQRU9GJywnREVMRVRFJ107XG5cdHZhciBMT0dJQyA9IFsnJiYnLCd8fCcsJyYnLCd8JywnXiddO1xuXHRcblx0Ly8gb3B0aW1pemUgZm9yIGZpeGVkIGFycmF5c1xuXHR2YXIgTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTCA9IFtcblx0XHQnQ0FMTF9FTkQnLCc9JywnREVGX0JPRFknLCcoJywnQ0FMTF9TVEFSVCcsJywnLCc6JywnUkVUVVJOJyxcblx0XHQnLT0nLCcrPScsJy89JywnKj0nLCclPScsJ3x8PScsJyYmPScsJz89JywnPDw9JywnPj49JywnPj4+PScsJyY9JywnXj0nLCd8PSdcblx0XTsgLy8gLmNvbmNhdChDT01QT1VORF9BU1NJR04pXG5cdFxuXHRcblx0Ly8gY29uc29sZS5sb2cgTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTDpsZW5ndGhcblx0Ly8gTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTFxuXHQvLyBJTVBMSUNJVF9DT01NQSA9IFsnLT4nLCAnPT4nLCAneycsICdbJywgJ05VTUJFUicsICdTVFJJTkcnLCAnU1lNQk9MJywgJ0lERU5USUZJRVInLCdETyddXG5cdFxuXHR2YXIgSU1QTElDSVRfQ09NTUEgPSBbJ0RPJ107XG5cdFxuXHQvLyBUb2tlbnMgdGhhdCBhbHdheXMgbWFyayB0aGUgZW5kIG9mIGFuIGltcGxpY2l0IGNhbGwgZm9yIHNpbmdsZS1saW5lcnMuXG5cdHZhciBJTVBMSUNJVF9FTkQgPSBbJ1BPU1RfSUYnLCdQT1NUX1VOTEVTUycsJ1BPU1RfRk9SJywnV0hJTEUnLCdVTlRJTCcsJ1dIRU4nLCdCWScsJ0xPT1AnLCdURVJNSU5BVE9SJywnREVGX0JPRFknLCdERUZfRlJBR01FTlQnXTtcblx0XG5cdC8vIFNpbmdsZS1saW5lIGZsYXZvcnMgb2YgYmxvY2sgZXhwcmVzc2lvbnMgdGhhdCBoYXZlIHVuY2xvc2VkIGVuZGluZ3MuXG5cdC8vIFRoZSBncmFtbWFyIGNhbid0IGRpc2FtYmlndWF0ZSB0aGVtLCBzbyB3ZSBpbnNlcnQgdGhlIGltcGxpY2l0IGluZGVudGF0aW9uLlxuXHR2YXIgU0lOR0xFX0xJTkVSUyA9IFsnRUxTRScsJ1RSWScsJ0ZJTkFMTFknLCdUSEVOJywnQkxPQ0tfUEFSQU1fRU5EJywnRE8nLCdCRUdJTicsJ0NBVENIX1ZBUiddOyAvLyAnLT4nLCAnPT4nLCByZWFsbHk/XG5cdHZhciBTSU5HTEVfQ0xPU0VSUyA9IFsnVEVSTUlOQVRPUicsJ0NBVENIJywnRklOQUxMWScsJ0VMU0UnLCdPVVRERU5UJywnTEVBRElOR19XSEVOJ107XG5cdFxuXHQvLyBUb2tlbnMgdGhhdCBlbmQgYSBsaW5lLlxuXHRyZXR1cm4gTElORUJSRUFLUyA9IFsnVEVSTUlOQVRPUicsJ0lOREVOVCcsJ09VVERFTlQnXTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9pbWJhL3NyYy9jb21waWxlci9yZXdyaXRlci5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHQvLyBoZWxwZXIgZm9yIHN1YmNsYXNzaW5nXG5cdGZ1bmN0aW9uIHN1YmNsYXNzJChvYmosc3VwKSB7XG5cdFx0Zm9yICh2YXIgayBpbiBzdXApIHtcblx0XHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIG9ialtrXSA9IHN1cFtrXTtcblx0XHR9O1xuXHRcdC8vIG9iai5fX3N1cGVyX18gPSBzdXA7XG5cdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHR9O1xuXHRcblx0Ly8gY3JlYXRlIHNlcGFyYXRlIGVycm9yLXR5cGVzIHdpdGggYWxsIHRoZSBsb2dpY1xuXHRcblx0ZnVuY3Rpb24gSW1iYVBhcnNlRXJyb3IoZSxvKXtcblx0XHR0aGlzLmVycm9yID0gZTtcblx0XHR0aGlzLm1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG5cdFx0dGhpcy5maWxlbmFtZSA9IGUuZmlsZW5hbWU7XG5cdFx0dGhpcy5saW5lID0gZS5saW5lO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvIHx8IHt9O1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoSW1iYVBhcnNlRXJyb3IsRXJyb3IpO1xuXHRleHBvcnRzLkltYmFQYXJzZUVycm9yID0gSW1iYVBhcnNlRXJyb3I7IC8vIGV4cG9ydCBjbGFzcyBcblx0SW1iYVBhcnNlRXJyb3Iud3JhcCA9IGZ1bmN0aW9uIChlcnIpe1xuXHRcdC8vIHdoYXQgYWJvdXQgdGhlIHN0YWNrdHJhY2U/XG5cdFx0cmV0dXJuIG5ldyBJbWJhUGFyc2VFcnJvcihlcnIpO1xuXHR9O1xuXHRcblx0SW1iYVBhcnNlRXJyb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvcHRzKXtcblx0XHR0aGlzLl9vcHRpb25zIHx8ICh0aGlzLl9vcHRpb25zID0ge30pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMob3B0cyksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHR0aGlzLl9vcHRpb25zW2tleXNbaV1dID0gb3B0c1trZXlzW2ldXTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYVBhcnNlRXJyb3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG8gPSB0aGlzLl9vcHRpb25zO1xuXHRcdHZhciBpZHggPSBvLnBvcyAtIDE7XG5cdFx0dmFyIHRvayA9IG8udG9rZW5zICYmIG8udG9rZW5zW2lkeF07XG5cdFx0d2hpbGUgKHRvayAmJiB0b2suX2xvYyA9PSAtMSl7XG5cdFx0XHR0b2sgPSBvLnRva2Vuc1stLWlkeF07XG5cdFx0fTtcblx0XHRyZXR1cm4gdG9rO1xuXHR9O1xuXHRcblx0SW1iYVBhcnNlRXJyb3IucHJvdG90eXBlLmRlc2MgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0dmFyIG1zZyA9IHRoaXMubWVzc2FnZTtcblx0XHRpZiAoby50b2tlbiAmJiBvLnRva2VuLl9sb2MgPT0gLTEpIHtcblx0XHRcdHJldHVybiAnU3ludGF4IEVycm9yJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG1zZztcblx0XHR9O1xuXHR9O1xuXHRcblx0SW1iYVBhcnNlRXJyb3IucHJvdG90eXBlLmxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzdGFydF87XG5cdFx0cmV0dXJuIChzdGFydF8gPSB0aGlzLnN0YXJ0KCkpICYmIHN0YXJ0Xy5yZWdpb24gICYmICBzdGFydF8ucmVnaW9uKCk7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG8gPSB0aGlzLl9vcHRpb25zO1xuXHRcdHZhciB0b2sgPSB0aGlzLnN0YXJ0KCk7XG5cdFx0Ly8gdmFyIHRvayA9IG86dG9rZW5zIGFuZCBvOnRva2Vuc1tvOnBvcyAtIDFdXG5cdFx0Ly8gdmFyIGxvYyA9IHRvayBhbmQgW3Rvay5AbG9jLHRvay5AbG9jICsgKHRvay5AbGVuIG9yIHRvay5AdmFsdWU6bGVuZ3RoKV0gb3IgWzAsMF1cblx0XHQvLyAsIGNvbDogdG9rLkBjb2wsIGxpbmU6IHRvay5AbGluZVxuXHRcdC8vIGdldCB0aGUgdG9rZW4gaXRzZWxmP1xuXHRcdHJldHVybiB7d2FybjogdHJ1ZSxtZXNzYWdlOiB0aGlzLmRlc2MoKSxsb2M6IHRoaXMubG9jKCl9O1xuXHR9O1xuXHRyZXR1cm4gSW1iYVBhcnNlRXJyb3I7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vaW1iYS9zcmMvY29tcGlsZXIvZXJyb3JzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuLi9yZWdpb24nKS5SZWdpb247XG5cdFxuXHRcblx0ZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKHN0cil7XG5cdFx0cmV0dXJuICgvXltcXG5cXHRcXCBdKyQvKS50ZXN0KHN0cik7XG5cdH07IGV4cG9ydHMuaXNXaGl0ZXNwYWNlID0gaXNXaGl0ZXNwYWNlO1xuXHRcblx0ZnVuY3Rpb24gY29tbW9uQW5jZXN0b3IoYSxiKXtcblx0XHRpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR2YXIgYXJyID0gYS5zbGljZSgpO1xuXHRcdFx0cmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24ocHJldixjdXJyLGkpIHtcblx0XHRcdFx0cmV0dXJuIGNvbW1vbkFuY2VzdG9yKHByZXYsY3Vycik7XG5cdFx0XHR9LGFyci5zaGlmdCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghYSB8fCAhYikgeyByZXR1cm4gKGEgfHwgYikgfTtcblx0XHRcblx0XHRhID0gYS5fZG9tIHx8IGE7XG5cdFx0YiA9IGIuX2RvbSB8fCBiO1xuXHRcdFxuXHRcdHdoaWxlICghYS5jb250YWlucyhiKSl7XG5cdFx0XHRhID0gYS5wYXJlbnROb2RlO1xuXHRcdH07XG5cdFx0d2hpbGUgKCFiLmNvbnRhaW5zKGEpKXtcblx0XHRcdGIgPSBiLnBhcmVudE5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGFnJHdyYXAoYSk7XG5cdH07IGV4cG9ydHMuY29tbW9uQW5jZXN0b3IgPSBjb21tb25BbmNlc3Rvcjtcblx0XG5cdFxuXHR2YXIgcGFpcnMgPSB7XG5cdFx0J1wiJzogJ1wiJyxcblx0XHRcIidcIjogXCInXCIsXG5cdFx0JygnOiAnKScsXG5cdFx0JzwnOiAnPicsXG5cdFx0J1snOiAnXScsXG5cdFx0J3snOiAnfSdcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHdyYXBUZXh0KHRleHQsb3BlbixjbG9zZSl7XG5cdFx0Y2xvc2UgfHwgKGNsb3NlID0gcGFpcnNbb3Blbl0pO1xuXHRcdGlmIChvcGVuID09IFwiJ1wiKSB7IHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcJy9nLFwiXFxcXCdcIikgfTtcblx0XHRyZXR1cm4gKG9wZW4gfHwgJycpICsgdGV4dCArIChjbG9zZSB8fCAnJyk7XG5cdH07IGV4cG9ydHMud3JhcFRleHQgPSB3cmFwVGV4dDtcblx0XG5cdFxuXHRmdW5jdGlvbiBzdHJpbmdJc0JhbGFuY2VkKHN0cil7XG5cdFx0dmFyIG9wZW5zID0gJ1t7KFwiXFwnJztcblx0XHR2YXIgY2xvc2VzID0gJ119KVwiXFwnJztcblx0XHR2YXIgc3RhY2sgPSBbXTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHMsZW5kO1xuXHRcdFxuXHRcdHdoaWxlIChzID0gc3RyW2krK10pe1xuXHRcdFx0dmFyIG9pZCA9IG9wZW5zLmluZGV4T2Yocyk7XG5cdFx0XHRcblx0XHRcdGlmIChzID09IGVuZCkge1xuXHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0ZW5kID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHR9IGVsc2UgaWYgKG9pZCA+PSAwKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gY2xvc2VzW29pZF0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzdGFjay5sZW5ndGggPT0gMCA/ICh0cnVlKSA6IChmYWxzZSk7XG5cdH07IGV4cG9ydHMuc3RyaW5nSXNCYWxhbmNlZCA9IHN0cmluZ0lzQmFsYW5jZWQ7XG5cdFxuXHRmdW5jdGlvbiBjb2xUb0xvYyhsaW5lLGNvbCx0YWJzaXplKXtcblx0XHRpZih0YWJzaXplID09PSB1bmRlZmluZWQpIHRhYnNpemUgPSA0O1xuXHRcdHZhciBjaSA9IDA7XG5cdFx0dmFyIHJjaSA9IDA7IC8vIHJlYWwgY29sdW1uXG5cdFx0dmFyIGNoYXIkO1xuXHRcdFxuXHRcdGlmIChjb2wgPT0gMCkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdHdoaWxlIChjaGFyJCA9IGxpbmVbY2krK10pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXHQnKSB7XG5cdFx0XHRcdHZhciByZXN0ID0gdGFic2l6ZSAtIHJjaSAlIHRhYnNpemU7XG5cdFx0XHRcdHJjaSArPSByZXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmNpICs9IDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAocmNpID49IGNvbCkge1xuXHRcdFx0XHRyZXR1cm4gY2k7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGxpbmUubGVuZ3RoO1xuXHR9OyBleHBvcnRzLmNvbFRvTG9jID0gY29sVG9Mb2M7XG5cdFxuXHRmdW5jdGlvbiBjb2xUb1ZpZXdDb2wobGluZSxjb2wsdGFic2l6ZSl7XG5cdFx0aWYodGFic2l6ZSA9PT0gdW5kZWZpbmVkKSB0YWJzaXplID0gNDtcblx0XHR2YXIgY2kgPSAwO1xuXHRcdHZhciByY2kgPSAwOyAvLyByZWFsIGNvbHVtblxuXHRcdHZhciBjaGFyJDtcblx0XHRcblx0XHRpZiAoY29sID09IDApIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHR3aGlsZSAoY2hhciQgPSBsaW5lW2NpKytdKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFx0Jykge1xuXHRcdFx0XHR2YXIgcmVzdCA9IHRhYnNpemUgLSByY2kgJSB0YWJzaXplO1xuXHRcdFx0XHRpZiAocmVzdCA+IDMgJiYgY29sIDw9IHJjaSArIDIpIHsgYnJlYWs7IH07XG5cdFx0XHRcdHJjaSArPSByZXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmNpICs9IDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY29sIDw9IHJjaSkgeyBicmVhazsgfTtcblx0XHR9O1xuXHRcdHJldHVybiByY2k7XG5cdH07IGV4cG9ydHMuY29sVG9WaWV3Q29sID0gY29sVG9WaWV3Q29sO1xuXHRcblx0ZnVuY3Rpb24gY29sc0ZvckxpbmUobGluZSx0YWJzaXplKXtcblx0XHRpZih0YWJzaXplID09PSB1bmRlZmluZWQpIHRhYnNpemUgPSA0O1xuXHRcdHZhciBjb2wgPSAwO1xuXHRcdHZhciBpZHggPSAwO1xuXHRcdHZhciBjaGFyJDtcblx0XHR3aGlsZSAoY2hhciQgPSBsaW5lW2lkeCsrXSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcdCcpIHtcblx0XHRcdFx0dmFyIHJlc3QgPSB0YWJzaXplIC0gY29sICUgdGFic2l6ZTtcblx0XHRcdFx0Y29sICs9IHJlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2wgKz0gMTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRyZXR1cm4gY29sO1xuXHR9OyBleHBvcnRzLmNvbHNGb3JMaW5lID0gY29sc0ZvckxpbmU7XG5cdFxuXHRmdW5jdGlvbiByb3djb2woYnVmLGxvYyx0YWJzaXplKXtcblx0XHRpZih0YWJzaXplID09PSB1bmRlZmluZWQpIHRhYnNpemUgPSA0O1xuXHRcdGJ1ZiA9IGJ1Zi50b1N0cmluZygpO1xuXHRcdHZhciBwb3MgPSBsb2M7XG5cdFx0dmFyIGNvbCA9IDA7XG5cdFx0dmFyIGxpbmUgPSAwO1xuXHRcdHZhciBjaGFyJDtcblx0XHRcblx0XHQvLyBnbyBiYWNrIHRvIHN0YXJ0IG9mIGxpbmVcblx0XHR3aGlsZSAoY2hhciQgPSBidWZbcG9zIC0gMV0pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXG4nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fTtcblx0XHRcdHBvcy0tO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZ2V0IGNvbHVtbiBmb3Igc2xpY2Vcblx0XHR3aGlsZSAoKHBvcyA8IGxvYykgJiYgKGNoYXIkID0gYnVmW3Bvc10pKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFx0Jykge1xuXHRcdFx0XHR2YXIgcmVzdCA9IHRhYnNpemUgLSAoY29sICUgdGFic2l6ZSk7XG5cdFx0XHRcdGNvbCArPSByZXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sICs9IDE7XG5cdFx0XHR9O1xuXHRcdFx0cG9zKys7XG5cdFx0fTtcblx0XHRcblx0XHR3aGlsZSAoY2hhciQgPSBidWZbcG9zIC0gMV0pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXG4nKSB7XG5cdFx0XHRcdGxpbmUrKztcblx0XHRcdH07XG5cdFx0XHRwb3MtLTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBbbGluZSxjb2xdO1xuXHR9OyBleHBvcnRzLnJvd2NvbCA9IHJvd2NvbDtcblx0XG5cdGZ1bmN0aW9uIGluY3JlYXNlSW5kZW50KHN0cil7XG5cdFx0dmFyIHJlZyA9IC9eKFxccyooLipcXD1cXHMqKT8oZXhwb3J0IHxnbG9iYWwgfGV4dGVuZCApPyhjbGFzc3xkZWZ8dGFnfHVubGVzc3xpZnxlbHNlfGVsaWZ8c3dpdGNofHRyeXxjYXRjaHxmaW5hbGx5fGZvcnx3aGlsZXx1bnRpbHxkbykpLztcblx0XHR2YXIgb3RoZXIgPSAvXFxiKGRvKVxcYi87XG5cdFx0cmV0dXJuIHJlZy50ZXN0KHN0cikgfHwgb3RoZXIudGVzdChzdHIpO1xuXHR9OyBleHBvcnRzLmluY3JlYXNlSW5kZW50ID0gaW5jcmVhc2VJbmRlbnQ7XG5cdFxuXHRcblx0ZnVuY3Rpb24gcmVwZWF0U3RyaW5nKHN0cixjb3VudCl7XG5cdFx0cmV0dXJuIG5ldyBBcnJheShjb3VudCArIDEpLmpvaW4oc3RyKTtcblx0fTsgZXhwb3J0cy5yZXBlYXRTdHJpbmcgPSByZXBlYXRTdHJpbmc7XG5cdFxuXHRcblx0ZnVuY3Rpb24gcGF0Y2hTdHJpbmcob3JpZyxzdHIsbW9kZSl7XG5cdFx0dmFyIHJlZ2lvbjtcblx0XHR2YXIgdGV4dCA9IG9yaWcudG9TdHJpbmcoKTtcblx0XHRcblx0XHRpZiAobW9kZSA9PSAnYXBwZW5kJykge1xuXHRcdFx0cmV0dXJuIHRleHQgKyBzdHI7XG5cdFx0fSBlbHNlIGlmIChtb2RlID09ICdwcmVwZW5kJykge1xuXHRcdFx0cmV0dXJuIFwiXCIgKyBzdHIgKyB0ZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAocmVnaW9uID0gUmVnaW9uLm5vcm1hbGl6ZShtb2RlKSkge1xuXHRcdFx0XHQvLyBsZXQgcmVnaW9uID0gUmVnaW9uLm5vcm1hbGl6ZSgpXG5cdFx0XHRcdHJldHVybiB0ZXh0LnN1YnN0cigwLHJlZ2lvbi5zdGFydCgpKSArIHN0ciArIHRleHQuc2xpY2UocmVnaW9uLmVuZCgpKTtcblx0XHRcdH07XG5cdFx0fTtcblx0fTsgZXhwb3J0cy5wYXRjaFN0cmluZyA9IHBhdGNoU3RyaW5nOzsgcmV0dXJuIHBhdGNoU3RyaW5nO1xuXHRcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL3V0aWwuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gaGVscGVyIGZvciBzdWJjbGFzc2luZ1xuXHRmdW5jdGlvbiBzdWJjbGFzcyQob2JqLHN1cCkge1xuXHRcdGZvciAodmFyIGsgaW4gc3VwKSB7XG5cdFx0XHRpZiAoc3VwLmhhc093blByb3BlcnR5KGspKSBvYmpba10gPSBzdXBba107XG5cdFx0fTtcblx0XHQvLyBvYmouX19zdXBlcl9fID0gc3VwO1xuXHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEhpc3RvcnlTdGF0ZShkYXRhKXtcblx0XHRpZihkYXRhID09PSB1bmRlZmluZWQpIGRhdGEgPSB7fTtcblx0XHR0aGlzLl90aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuXHRcdHRoaXMuX2RhdGEgPSBkYXRhO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdEhpc3RvcnlTdGF0ZS5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXHRIaXN0b3J5U3RhdGUucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGF0YSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpc3RvcnlTdGF0ZS5wcm90b3R5cGUudGltZXN0YW1wID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90aW1lc3RhbXA7IH1cblx0SGlzdG9yeVN0YXRlLnByb3RvdHlwZS5zZXRUaW1lc3RhbXAgPSBmdW5jdGlvbih2KXsgdGhpcy5fdGltZXN0YW1wID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRIaXN0b3J5U3RhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeVN0YXRlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSl7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdFx0dGhpcy5fdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBGdWxsSGlzdG9yeVN0YXRlKCl7IHJldHVybiBIaXN0b3J5U3RhdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoRnVsbEhpc3RvcnlTdGF0ZSxIaXN0b3J5U3RhdGUpO1xuXHRGdWxsSGlzdG9yeVN0YXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHR2aWV3LmxvYWRTdGF0ZSh0aGlzLl9kYXRhKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGZ1bmN0aW9uIERpZmZIaXN0b3J5U3RhdGUoKXsgcmV0dXJuIEhpc3RvcnlTdGF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChEaWZmSGlzdG9yeVN0YXRlLEhpc3RvcnlTdGF0ZSk7XG5cdFxuXHRcblx0dmFyIHR5cGVzID0ge307XG5cdFxuXHRmdW5jdGlvbiBDb21tYW5kKHBhcmFtcyl7XG5cdFx0dGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wcmV2OyB9XG5cdENvbW1hbmQucHJvdG90eXBlLnNldFByZXYgPSBmdW5jdGlvbih2KXsgdGhpcy5fcHJldiA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX25leHQ7IH1cblx0Q29tbWFuZC5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9uZXh0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUuZnJhbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2ZyYW1lOyB9XG5cdENvbW1hbmQucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24odil7IHRoaXMuX2ZyYW1lID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRDb21tYW5kLnN5bSA9IGZ1bmN0aW9uIChzeW0pe1xuXHRcdHZhciAkMCA9IGFyZ3VtZW50cywgaSA9ICQwLmxlbmd0aDtcblx0XHR2YXIgcGFycyA9IG5ldyBBcnJheShpPjEgPyBpLTEgOiAwKTtcblx0XHR3aGlsZShpPjEpIHBhcnNbLS1pIC0gMV0gPSAkMFtpXTtcblx0XHR0aGlzLnByb3RvdHlwZS5fc3ltYm9sID0gc3ltO1xuXHRcdHRoaXMucHJvdG90eXBlLl9zaWduYXR1cmUgPSBwYXJzO1xuXHRcdHR5cGVzW3N5bV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5sb2FkID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciB0eXAgPSB0eXBlc1tvWzBdXTtcblx0XHR2YXIgZnJhbWUgPSBvWzFdO1xuXHRcdHZhciBjbWQgPSB0eXAuYnVpbGQob1syXSk7XG5cdFx0Y21kLnNldEZyYW1lKGZyYW1lKTtcblx0XHRyZXR1cm4gY21kO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5idWlsZCA9IGZ1bmN0aW9uIChwYXJhbXMpe1xuXHRcdHJldHVybiBuZXcgdGhpcyhwYXJhbXMpO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmFtcztcblx0fTtcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0cmV0dXJuIHRoaXMucHJldigpO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHZfO1xuXHRcdGlmICh0aGlzLnByZXYoKSkgeyAodGhpcy5wcmV2KCkuc2V0TmV4dCh2XyA9IHRoaXMubmV4dCgpKSx2XykgfTtcblx0XHRpZiAodGhpcy5uZXh0KCkpIHsgKHRoaXMubmV4dCgpLnNldFByZXYodl8gPSB0aGlzLnByZXYoKSksdl8pIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX3N5bWJvbCx0aGlzLl9mcmFtZSB8fCAwLHRoaXMucGFyYW1zKCkgfHwgW11dO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gTWFyaygpeyByZXR1cm4gQ29tbWFuZC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChNYXJrLENvbW1hbmQpO1xuXHRNYXJrLnN5bSgnTScsJ3ZhbHVlJyk7XG5cdFxuXHRcblx0ZnVuY3Rpb24gU25hcHNob3QocGFyYW1zKXtcblx0XHR0aGlzLl9jb2RlID0gcGFyYW1zWzBdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFNuYXBzaG90LE1hcmspO1xuXHRTbmFwc2hvdC5zeW0oJ1MnLCdjb2RlJyk7XG5cdFxuXHRTbmFwc2hvdC5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLl9jb2RlXTtcblx0fTtcblx0XG5cdFNuYXBzaG90LnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdGNvbnNvbGUubG9nKCdsb2FkJyx0aGlzLl9jb2RlKTtcblx0XHR2aWV3LmxvYWQodGhpcy5fY29kZSk7XG5cdFx0Ly8gbXVzdCByZXBhaXI/IHdoYXQgYWJvdXQgYW5ub3RhdGlvbnM/XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBTZWxlY3Rpb24ocGFyYW1zKXtcblx0XHR0aGlzLl9vbGQgPSBwYXJhbXNbMF07XG5cdFx0dGhpcy5fbmV3ID0gcGFyYW1zWzFdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFNlbGVjdGlvbixDb21tYW5kKTtcblx0U2VsZWN0aW9uLnN5bSgnfCcsJ29sZCcsJ25ldycpO1xuXHRcblx0U2VsZWN0aW9uLmxvYWQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gbmV3IHRoaXModmFsKTtcblx0fTtcblx0XG5cdFNlbGVjdGlvbi5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLl9vbGQsdGhpcy5fbmV3XTtcblx0fTtcblx0XG5cdFNlbGVjdGlvbi5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHR2aWV3LmNhcmV0KCkuc2V0KEpTT04ucGFyc2UodGhpcy5fbmV3KSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTZWxlY3Rpb24ucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHRoaXMucmVkbyh2aWV3KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFNlbGVjdGlvbi5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHQvLyB3ZSBuZWVkIHRvIGtub3cgYWJvdXQgdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBmb3IgdGhpcz9cblx0XHQvLyBjYW4gZWl0aGVyIHN0b3JlIGJvdGggLSBvciB0cmF2ZXJzZSBiYWNrd2FyZHMgdG8gdGhlIHByZXZpb3VzXG5cdFx0Ly8gY29tbWFuZCBsaWtlIHRoaXNcblx0XHR2YXIgb2xkID0gSlNPTi5wYXJzZSh0aGlzLl9vbGQpO1xuXHRcdGNvbnNvbGUubG9nKCdtb3ZlIHNlbGVjdGlvbiBiYWNrIHRvIG9sZCcsb2xkLHRoaXMuZGF0YSgpKTtcblx0XHR2aWV3LmNhcmV0KCkuc2V0KG9sZCk7XG5cdFx0cmV0dXJuIHRoaXMucHJldigpO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIEluc2VydChwYXJzKXtcblx0XHR0aGlzLl9wb2ludCA9IHBhcnNbMF07XG5cdFx0dGhpcy5fc3RyID0gcGFyc1sxXTtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChJbnNlcnQsQ29tbWFuZCk7XG5cdEluc2VydC5zeW0oJysnLCdwb2ludCcsJ3N0cicpO1xuXHRcblx0SW5zZXJ0LnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX3BvaW50LHRoaXMuX3N0cl07XG5cdH07XG5cdFxuXHRJbnNlcnQucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Y29uc29sZS5sb2coJ3JlZG8gSW5zZXJ0Jyk7XG5cdFx0cmV0dXJuIHZpZXcuaW5zZXJ0KHRoaXMuX3BvaW50LHRoaXMuX3N0cik7XG5cdH07XG5cdFxuXHRJbnNlcnQucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Y29uc29sZS5sb2coJ3VuZG8gSW5zZXJ0Jyk7XG5cdFx0dmlldy5lcmFzZShbdGhpcy5fcG9pbnQsdGhpcy5fcG9pbnQgKyB0aGlzLl9zdHIubGVuZ3RoXSk7XG5cdFx0cmV0dXJuIHRoaXMucHJldigpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gRXJhc2UocGFyYW1zKXtcblx0XHR0aGlzLl9yZWdpb24gPSBwYXJhbXNbMF07XG5cdFx0dGhpcy5fc3RyID0gcGFyYW1zWzFdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKEVyYXNlLENvbW1hbmQpO1xuXHRFcmFzZS5zeW0oJy0nLCdyZWdpb24nLCdzdHInKTtcblx0XG5cdEVyYXNlLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX3JlZ2lvbix0aGlzLl9zdHJdO1xuXHR9O1xuXHRcblx0RXJhc2UucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Y29uc29sZS5sb2coJ3JlZG8gRXJhc2UnKTtcblx0XHRyZXR1cm4gdmlldy5lcmFzZSh0aGlzLl9yZWdpb24pO1xuXHR9O1xuXHRcblx0RXJhc2UucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Ly8gaWYgd2UgZG9udCBrbm93IHRoZSB0ZXh0IHRvIFxuXHRcdGNvbnNvbGUubG9nKCd1bmRvIEVyYXNlJyk7XG5cdFx0dmlldy5pbnNlcnQodGhpcy5fcmVnaW9uLnN0YXJ0KCksdGhpcy5fc3RyKTtcblx0XHRyZXR1cm4gdGhpcy5wcmV2KCk7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gSGlzdG9yeSh2aWV3KXtcblx0XHR0aGlzLl9tb2RlID0gJ25vcm1hbCc7XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0dGhpcy5zZXRDdXJyZW50KHRoaXMuX3NlZWQgPSBuZXcgTWFyaygpKTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5IaXN0b3J5ID0gSGlzdG9yeTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLm1vZGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX21vZGU7IH1cblx0SGlzdG9yeS5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9tb2RlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lbmFibGVkOyB9XG5cdEhpc3RvcnkucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZW5hYmxlZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7IH1cblx0SGlzdG9yeS5wcm90b3R5cGUuc2V0Q3VycmVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jdXJyZW50ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUuc2VlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2VlZDsgfVxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZXRTZWVkID0gZnVuY3Rpb24odil7IHRoaXMuX3NlZWQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS50YWlsID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90YWlsOyB9XG5cdEhpc3RvcnkucHJvdG90eXBlLnNldFRhaWwgPSBmdW5jdGlvbih2KXsgdGhpcy5fdGFpbCA9IHY7IHJldHVybiB0aGlzOyB9OyAvLyBpcyB0aGlzIGJlaGluZCBvciBpbiB0aGUgdmVyeSBmcm9udD9cblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtLG1vdmUsZnJhbWUpe1xuXHRcdGlmKG1vdmUgPT09IHVuZGVmaW5lZCkgbW92ZSA9IHRydWU7XG5cdFx0aWYoZnJhbWUgPT09IHVuZGVmaW5lZCkgZnJhbWUgPSB0aGlzLnZpZXcoKS5mcmFtZXMoKTtcblx0XHRpdGVtLnNldEZyYW1lKGZyYW1lKTtcblx0XHRcblx0XHRpZiAodGhpcy5jdXJyZW50KCkpIHtcblx0XHRcdC8vIGlmIGN1cnJlbnQgaGFzIGEgbmV4dCBldmVudFxuXHRcdFx0Ly8gdGhpcyBzaG91bGQgYmUgZGV0YWNoZWQgaGVyZT9cblx0XHRcdGl0ZW0uc2V0UHJldih0aGlzLmN1cnJlbnQoKSk7XG5cdFx0XHR0aGlzLmN1cnJlbnQoKS5zZXROZXh0KGl0ZW0pO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG1vdmUpIHsgKHRoaXMuc2V0Q3VycmVudChpdGVtKSxpdGVtKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBjdXJyZW50Xztcblx0XHRyZXR1cm4gKGN1cnJlbnRfID0gdGhpcy5jdXJyZW50KCkpICYmIGN1cnJlbnRfLm5leHQgICYmICBjdXJyZW50Xy5uZXh0KCk7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGN1cnJlbnRfO1xuXHRcdHJldHVybiAoY3VycmVudF8gPSB0aGlzLmN1cnJlbnQoKSkgJiYgY3VycmVudF8ucHJldiAgJiYgIGN1cnJlbnRfLnByZXYoKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoZGlyKXtcblx0XHRpZihkaXIgPT09IHVuZGVmaW5lZCkgZGlyID0gMTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5hcHBseShmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSBbXTt3aGlsZSAoc2VsZi5uZXh0KCkpe1xuXHRcdFx0XHRzZWxmLm5leHQoKS5yZWRvKHNlbGYudmlldygpLHNlbGYpO1xuXHRcdFx0XHRzZWxmLnNldEN1cnJlbnQoc2VsZi5uZXh0KCkpO1xuXHRcdFx0XHRpZiAoc2VsZi5jdXJyZW50KCkgaW5zdGFuY2VvZiBNYXJrKSB7IGJyZWFrOyB9O1xuXHRcdFx0fTtyZXR1cm4gcmVzO1xuXHRcdH0pO1xuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLmFwcGx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVuZG8gXG5cdFx0XHR2YXIgcmVzID0gW10sIHZfLCBjdXJyZW50Xzt3aGlsZSAoc2VsZi5jdXJyZW50KCkpe1xuXHRcdFx0XHRpZiAoc2VsZi5wcmV2KCkpIHsgKHNlbGYuc2V0Q3VycmVudCh2XyA9IHNlbGYuY3VycmVudCgpLnVuZG8oc2VsZi52aWV3KCksc2VsZikpLHZfKSB9O1xuXHRcdFx0XHQoY3VycmVudF8gPSBzZWxmLmN1cnJlbnQoKSkgJiYgY3VycmVudF8uZW50ZXIgICYmICBjdXJyZW50Xy5lbnRlcihzZWxmLnZpZXcoKSxzZWxmKTtcblx0XHRcdFx0aWYgKHNlbGYuY3VycmVudCgpIGluc3RhbmNlb2YgTWFyaykgeyBicmVhazsgfTtcblx0XHRcdH07cmV0dXJuIHJlcztcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGNiKXtcblx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXHRcdGNiICYmIGNiKCk7XG5cdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChjYil7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChzdGF0ZSl7XG5cdFx0c3RhdGUuYXBwbHkodGhpcy52aWV3KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUub25lcmFzZSA9IGZ1bmN0aW9uIChyZWcsc3RyLGVkaXQpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRyZXR1cm4gdGhpcy5hZGQobmV3IEVyYXNlKFtyZWcsc3RyXSkpO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUub25pbnNlcnQgPSBmdW5jdGlvbiAobG9jLHN0cixlZGl0KXtcblx0XHRpZiAodGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0cmV0dXJuIHRoaXMuYWRkKG5ldyBJbnNlcnQoW2xvYyxzdHJdKSk7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5vbmNhcmV0ID0gZnVuY3Rpb24gKG9sZCxuZXckKXtcblx0XHRpZiAodGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0cmV0dXJuIHRoaXMuYWRkKG5ldyBTZWxlY3Rpb24oW29sZCxuZXckXSkpO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUub25sb2FkID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHR2YXIgbWFyayA9IG5ldyBTbmFwc2hvdChbY29kZV0pO1xuXHRcdHJldHVybiB0aGlzLmFkZChtYXJrKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHR2YXIgbWFyayA9IG5ldyBNYXJrKFt2YWx1ZV0pO1xuXHRcdHJldHVybiB0aGlzLmFkZChtYXJrKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYgKHNlbGYuX21vZGUgPT0gJ3BsYXknKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncGx5YWluZydcblx0XHRcdHZhciBmcmFtZSA9IHNlbGYudmlldygpLmZyYW1lcygpIC0gc2VsZi5fb2Zmc2V0O1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2hpc3RvcnkudGljayB3aWxsIHBsYXknLGZyYW1lLG5leHQsY3VycmVudFxuXHRcdFx0c2VsZi5hcHBseShmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJlcyA9IFtdLCB2Xzt3aGlsZSAoc2VsZi5uZXh0KCkgJiYgc2VsZi5uZXh0KCkuZnJhbWUoKSA8PSBmcmFtZSl7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2hpc3RvcnkudGljayBwbGF5JyxmcmFtZSxuZXh0LGN1cnJlbnRcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncmVwbGF5IGZyYW1lISdcblx0XHRcdFx0XHRzZWxmLm5leHQoKS5yZWRvKHNlbGYudmlldygpLHNlbGYpO1xuXHRcdFx0XHRcdHJlcy5wdXNoKCgoc2VsZi5zZXRDdXJyZW50KHZfID0gc2VsZi5uZXh0KCkpLHZfKSkpO1xuXHRcdFx0XHR9O3JldHVybiByZXM7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoc2VsZi5uZXh0KCkpKSB7XG5cdFx0XHRcdHNlbGYuc2V0TW9kZSgnbGl2ZScpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHNob3VsZCBwcm9iYWJseSBoYXBwZW4gaW4gYSBkaWZmZXJlbnQgbWFuYWdlclxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgc25hcCA9IHNlbGYuc2VlZCgpO1xuXHRcdHdoaWxlICghKCFzbmFwIHx8IChzbmFwIGluc3RhbmNlb2YgU25hcHNob3QpKSl7XG5cdFx0XHRzbmFwID0gc25hcC5uZXh0KCk7XG5cdFx0fTtcblx0XHRcblx0XHRzZWxmLl9vZmZzZXQgPSBzZWxmLnZpZXcoKS5mcmFtZXMoKSAtIHNuYXAuZnJhbWUoKTtcblx0XHRjb25zb2xlLmxvZyhcInBsYXlpbmcgZnJvbSBzZWVkXCIsc25hcCxzZWxmLl9vZmZzZXQpO1xuXHRcdC8vIGNvbnNvbGUubG9nICdmb3VuZCBzbmFwc2hvdD8hPyAtLSBvZmZzZXQgZnJhbWUnLEBvZmZzZXRcblx0XHRzZWxmLmFwcGx5KGZ1bmN0aW9uKCkgeyB2YXIgdl87XG5cdFx0cmV0dXJuIChzZWxmLnNldEN1cnJlbnQodl8gPSBzbmFwLnJlZG8oc2VsZi52aWV3KCksc2VsZikpLHZfKTsgfSk7XG5cdFx0c2VsZi5zZXRNb2RlKCdwbGF5Jyk7XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgZGF0YSA9IFtdO1xuXHRcdHZhciBzdGVwID0gdGhpcy5fc2VlZDtcblx0XHRcblx0XHR3aGlsZSAoc3RlcCl7XG5cdFx0XHRkYXRhLnB1c2goc3RlcC50b0pTT04oKSk7XG5cdFx0XHRzdGVwID0gc3RlcC5uZXh0KCk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4ge2NvbW1hbmRzOiBkYXRhfTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoZGF0YSl7XG5cdFx0dmFyIHN0ZXAgPSB0aGlzLnNlZWQoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZGF0YS5jb21tYW5kcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBDb21tYW5kLmxvYWQoYXJ5W2ldKTtcblx0XHRcdGl0ZW0uc2V0UHJldihzdGVwKTtcblx0XHRcdHN0ZXAuc2V0TmV4dChpdGVtKTtcblx0XHRcdHN0ZXAgPSBpdGVtO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2xvYWQgaXRlbScsaXRlbVxuXHRcdH07XG5cdFx0Ly8gY29uc29sZS5sb2cgJ2xvYWRlZCdcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cmV0dXJuIEhpc3Rvcnk7XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlzdG9yeS5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0ZnVuY3Rpb24gTG9nZ2VyKHZpZXcpe1xuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkxvZ2dlciA9IExvZ2dlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdExvZ2dlci5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZW5hYmxlZDsgfVxuXHRMb2dnZXIucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZW5hYmxlZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdExvZ2dlci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRMb2dnZXIucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCBERUJVRykgeyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLGFyZ3VtZW50cykgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9lbmFibGVkIHx8IERFQlVHKSB7IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCBERUJVRykgeyBjb25zb2xlLmdyb3VwLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS5ncm91cENvbGxhcHNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9lbmFibGVkIHx8IERFQlVHKSB7IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMb2dnZXIucHJvdG90eXBlLmdyb3VwRW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgREVCVUcpIHsgY29uc29sZS5ncm91cEVuZCgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBMb2dnZXI7XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvbG9nZ2VyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXHRcblx0dmFyIHNwZWNpYWxLZXlzID0ge1xuXHRcdDg6IFwiYmFja3NwYWNlXCIsXG5cdFx0OTogXCJ0YWJcIixcblx0XHQxMDogXCJyZXR1cm5cIixcblx0XHQxMzogXCJyZXR1cm5cIixcblx0XHQxNjogXCJzaGlmdFwiLFxuXHRcdDE3OiBcImN0cmxcIixcblx0XHQxODogXCJhbHRcIixcblx0XHQxOTogXCJwYXVzZVwiLFxuXHRcdDIwOiBcImNhcHNsb2NrXCIsXG5cdFx0Mjc6IFwiZXNjXCIsXG5cdFx0MzI6IFwic3BhY2VcIixcblx0XHQzMzogXCJwYWdldXBcIixcblx0XHQzNDogXCJwYWdlZG93blwiLFxuXHRcdDM1OiBcImVuZFwiLFxuXHRcdDM2OiBcImhvbWVcIixcblx0XHQzNzogXCJsZWZ0XCIsXG5cdFx0Mzg6IFwidXBcIixcblx0XHQzOTogXCJyaWdodFwiLFxuXHRcdDQwOiBcImRvd25cIixcblx0XHQ0NTogXCJpbnNlcnRcIixcblx0XHQ0NjogXCJkZWxcIixcblx0XHQ1OTogXCI7XCIsXG5cdFx0NjE6IFwiPVwiLFxuXHRcdDk2OiBcIjBcIixcblx0XHQ5NzogXCIxXCIsXG5cdFx0OTg6IFwiMlwiLFxuXHRcdDk5OiBcIjNcIixcblx0XHQxMDA6IFwiNFwiLFxuXHRcdDEwMTogXCI1XCIsXG5cdFx0MTAyOiBcIjZcIixcblx0XHQxMDM6IFwiN1wiLFxuXHRcdDEwNDogXCI4XCIsXG5cdFx0MTA1OiBcIjlcIixcblx0XHQxMDY6IFwiKlwiLFxuXHRcdDEwNzogXCIrXCIsXG5cdFx0MTA5OiBcIi1cIixcblx0XHQxMTA6IFwiLlwiLFxuXHRcdDExMTogXCIvXCIsXG5cdFx0MTEyOiBcImYxXCIsXG5cdFx0MTEzOiBcImYyXCIsXG5cdFx0MTE0OiBcImYzXCIsXG5cdFx0MTE1OiBcImY0XCIsXG5cdFx0MTE2OiBcImY1XCIsXG5cdFx0MTE3OiBcImY2XCIsXG5cdFx0MTE4OiBcImY3XCIsXG5cdFx0MTE5OiBcImY4XCIsXG5cdFx0MTIwOiBcImY5XCIsXG5cdFx0MTIxOiBcImYxMFwiLFxuXHRcdDEyMjogXCJmMTFcIixcblx0XHQxMjM6IFwiZjEyXCIsXG5cdFx0MTQ0OiBcIm51bWxvY2tcIixcblx0XHQxNDU6IFwic2Nyb2xsXCIsXG5cdFx0MTczOiBcIi1cIixcblx0XHQxODY6IFwiO1wiLFxuXHRcdDE4NzogXCI9XCIsXG5cdFx0MTg4OiBcIixcIixcblx0XHQxODk6IFwiLVwiLFxuXHRcdDE5MDogXCIuXCIsXG5cdFx0MTkxOiBcIi9cIixcblx0XHQxOTI6IFwiYFwiLFxuXHRcdDIxOTogXCJbXCIsXG5cdFx0MjIwOiBcIlxcXFxcIixcblx0XHQyMjE6IFwiXVwiLFxuXHRcdDIyMjogXCInXCJcblx0fTtcblx0XG5cdHZhciBzaGlmdE51bXMgPSB7XG5cdFx0XCJgXCI6IFwiflwiLFxuXHRcdFwiMVwiOiBcIiFcIixcblx0XHRcIjJcIjogXCJAXCIsXG5cdFx0XCIzXCI6IFwiI1wiLFxuXHRcdFwiNFwiOiBcIiRcIixcblx0XHRcIjVcIjogXCIlXCIsXG5cdFx0XCI2XCI6IFwiXlwiLFxuXHRcdFwiN1wiOiBcIiZcIixcblx0XHRcIjhcIjogXCIqXCIsXG5cdFx0XCI5XCI6IFwiKFwiLFxuXHRcdFwiMFwiOiBcIilcIixcblx0XHRcIi1cIjogXCJfXCIsXG5cdFx0XCI9XCI6IFwiK1wiLFxuXHRcdFwiO1wiOiBcIjogXCIsXG5cdFx0XCInXCI6ICdcIicsXG5cdFx0XCIsXCI6IFwiPFwiLFxuXHRcdFwiLlwiOiBcIj5cIixcblx0XHRcIi9cIjogXCI/XCIsXG5cdFx0XCJcXFxcXCI6IFwifFwiXG5cdH07XG5cdFxuXHRmdW5jdGlvbiB0cmlnZ2VyKGtleSxvKXtcblx0XHRpZiAobyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRvID0ge2NvbW1hbmQ6IG99O1xuXHRcdH07XG5cdFx0by50cmlnZ2VyID0ga2V5O1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gY29tYm8oa2V5cyxvKXtcblx0XHRpZiAobyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7IG8gPSB7Y29tbWFuZDogb30gfTtcblx0XHRvLmtleXMgPSBrZXlzO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0SU0uS2V5QmluZGluZ3MgPSBbXG5cdFx0XG5cdFx0Y29tYm8oWydzdXBlcit6J10sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudmlldygpLmhpc3RvcnkoKS51bmRvKCk7IH0pLFxuXHRcdGNvbWJvKFtcInN1cGVyK3NoaWZ0K3pcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudmlldygpLmhpc3RvcnkoKS5yZWRvKCk7IH0pLFxuXHRcdGNvbWJvKFtcImFsdCtzdXBlcitwXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnZpZXcoKS5oaXN0b3J5KCkucGxheSgpOyB9KSxcblx0XHQvLyBjb21ibyBbXCJhbHQrc2hpZnQrclwiXSBkbyB8c2VsfCBzZWwudmlldy5oaXN0b3J5LnBsYXlcblx0XHRcblx0XHRjb21ibyhbXCJzdXBlcitzXCJdLHtjb21tYW5kOiBcInNhdmVcIn0pLFxuXHRcdGNvbWJvKFtcInN1cGVyK2JcIl0se2NvbW1hbmQ6IFwicnVuXCJ9KSxcblx0XHRjb21ibyhbXCJhbHQrc3VwZXIrc1wiXSx7Y29tbWFuZDogXCJzYXZlU2Vzc2lvblwifSksXG5cdFx0Y29tYm8oW1wiYWx0K3NoaWZ0K2xcIl0se2NvbW1hbmQ6IFwicmVwYXJzZVwifSksXG5cdFx0Y29tYm8oW1wiYWx0K3NoaWZ0K2tcIl0se2NvbW1hbmQ6IFwicmVwYXJzZUV4dGVudFwifSksXG5cdFx0XG5cdFx0Y29tYm8oW1wic3VwZXIrYVwiXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5zZWxlY3RBbGwoKTsgfSksXG5cdFx0XG5cdFx0XG5cdFx0Y29tYm8oWyd0YWInXSx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudGV4dCgpLmluZGV4T2YoJ1xcbicpID49IDA7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRzZWwuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0dmFyIHJlZ2lvbiA9IHNlbC5yZWdpb24oKTtcblx0XHRcdHZhciBub2RlcyA9IHNlbC52aWV3KCkubm9kZXNJblJlZ2lvbihyZWdpb24pO1xuXHRcdFx0XG5cdFx0XHRub2Rlcy5tYXAoZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0aWYgKG1hdGNoLm5vZGUubWF0Y2hlcygnLl9pbW5ld2xpbmUnKSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdmb3VuZCB0YWIgaW4gc2VsZWN0aW9uJyxtYXRjaCk7XG5cdFx0XHRcdFx0aWYgKG1hdGNoLm1vZGUgIT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoLm5vZGUuaW5kZW50KCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNlbC5kaXJ0eSgpO1xuXHRcdH19KSxcblx0XHRcblx0XHRcblx0XHRcblx0XHRjb21ibyhbXCJzaGlmdCt0YWJcIl0se2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnRleHQoKS5pbmRleE9mKCdcXG4nKSA+PSAwOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0c2VsLmV4cGFuZFRvTGluZXMoKTtcblx0XHRcdHZhciByZWdpb24gPSBzZWwucmVnaW9uKCk7XG5cdFx0XHR2YXIgbm9kZXMgPSBzZWwudmlldygpLm5vZGVzSW5SZWdpb24ocmVnaW9uKTtcblx0XHRcdFxuXHRcdFx0bm9kZXMubWFwKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdGlmIChtYXRjaC5ub2RlLm1hdGNoZXMoJy5faW1uZXdsaW5lJykgJiYgbWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoLm5vZGUudW5kZW50KCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzZWwuZGlydHkoKTtcblx0XHR9fSksXG5cdFx0XG5cdFx0Y29tYm8oW1wic2hpZnQrdGFiXCJdLHtjb250ZXh0OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gU3RyaW5nKGUudmlldy5zZWxlY3Rpb24pLmluZGV4T2YoJ1xcbicpID49IDBcblx0XHR9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ3RyeSB1bmRlbnQnKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJhbHQrc2hpZnQrcmV0dXJuXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gY29uc29sZS5sb2coJ3ByZXR0aWZ5Jyk7IH0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcImJhY2tzcGFjZVwiXSx7Y29udGV4dDogZnVuY3Rpb24oZSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ2RlbGV0ZUxlZnRSaWdodCBiYWNrc3BhY2U/IT8nLGUucmVnaW9uKCksZS5yZWdpb24oKS5wZWVrKC0xLDEpKTtcblx0XHRcdHJldHVybiBpZHgkKGUucmVnaW9uKCkucGVlaygtMSwxKSxbJ1tdJywne30nLCc8PicsJygpJywnXCJcIicsXCInJ1wiXSkgPj0gMDtcblx0XHR9LFxuXHRcdFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ21vdmluZyEhJyk7XG5cdFx0XHRzZWwuZXhwYW5kKC0xLDEpO1xuXHRcdFx0cmV0dXJuIHNlbC5lcmFzZSgpO1xuXHRcdH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJiYWNrc3BhY2VcIl0se2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCxvKSB7XG5cdFx0XHR2YXIgcmVnID0gc2VsLnJlZ2lvbigpO1xuXHRcdFx0aWYgKHJlZy5zaXplKCkgPT0gMCkge1xuXHRcdFx0XHRpZiAoby5ub2RlID0gcmVnLnByZXZOb2RlKCcuX2ltcGFpciwuX2ltc3RyJykpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwsbykgeyB2YXIgdl87XG5cdFx0cmV0dXJuIChzZWwuc2V0UmVnaW9uKHZfID0gby5ub2RlLnJlZ2lvbigpLmNsb25lKCkucmV2ZXJzZSgpKSx2Xyk7IH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJiYWNrc3BhY2VcIl0se2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCxvKSB7XG5cdFx0XHRpZiAoc2VsLnRleHQoKSAmJiAhdXRpbC5zdHJpbmdJc0JhbGFuY2VkKHNlbC50ZXh0KCkpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCxvKSB7IHJldHVybiB0cnVlOyB9fSksXG5cdFx0XG5cdFx0Y29tYm8oW1wiYmFja3NwYWNlXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmVyYXNlKCk7IH0pLFxuXHRcdGNvbWJvKFtcInNoaWZ0K2JhY2tzcGFjZVwiXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5lcmFzZSgpOyB9KSxcblx0XHRjb21ibyhbXCJhbHQrYmFja3NwYWNlXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmVyYXNlKElNLldPUkRfU1RBUlQpOyB9KSxcblx0XHRjb21ibyhbXCJzdXBlcitiYWNrc3BhY2VcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuZXJhc2UoSU0uTElORV9TVEFSVCk7IH0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcInJldHVyblwiLCdzaGlmdCtyZXR1cm4nLCdzdXBlcityZXR1cm4nXSxmdW5jdGlvbihzZWwpIHtcblx0XHRcdHZhciBpbmQgPSBzZWwuaW5kZW50KCk7XG5cdFx0XHRpZiAodXRpbC5pbmNyZWFzZUluZGVudChzZWwuaGVhZCgpLnBlZWtiZWhpbmQoKSkpIHsgaW5kICs9ICdcXHQnIH07XG5cdFx0XHRcblx0XHRcdC8vIHNob3VsZCBub3QgaGFwcGVuIGluIHN0cmluZ1xuXHRcdFx0aWYgKGlkeCQoc2VsLnJlZ2lvbigpLnBlZWsoLTEsMSksWydbXScsJ3t9JywnKCknXSkgPj0gMCkge1xuXHRcdFx0XHRzZWwuaW5zZXJ0KCdcXG5cXHQnICsgaW5kKTtcblx0XHRcdFx0c2VsLnZpZXcoKS5pbnNlcnQoc2VsLmhlYWQoKS5sb2MoKSwnXFxuJyArIGluZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWwuaW5zZXJ0KCdcXG4nICsgaW5kKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pLFxuXHRcdFxuXHRcdFxuXHRcdGNvbWJvKFsnc3BhY2UnLCdzaGlmdCtzcGFjZSddLGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0aWYgKHNlbC5yZWdpb24oKS5wZWVrKC0xLDEpID09ICc8PicpIHtcblx0XHRcdFx0c2VsLm1vdmUoMSkuZXJhc2UoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWwuaW5zZXJ0KCcgJyk7XG5cdFx0fSksXG5cdFx0XG5cdFx0Y29tYm8oWyd0YWInXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJ1xcdCcpOyB9KSxcblx0XHRcblx0XHRcblx0XHRjb21ibyhbJ3N1cGVyK3VwJ10sZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRzZWwuY29sbGFwc2UoKS5oZWFkKCkuc2V0KDAsMCkubm9ybWFsaXplKCk7XG5cdFx0XHRyZXR1cm4gc2VsLmRpcnR5KCk7XG5cdFx0fSksXG5cdFx0XG5cdFx0Y29tYm8oWydzdXBlcitkb3duJ10sZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRzZWwuY29sbGFwc2UoKS5oZWFkKCkuc2V0KDEwMDAwMCwwKS5ub3JtYWxpemUoKTtcblx0XHRcdHJldHVybiBzZWwuZGlydHkoKTtcblx0XHR9KSxcblx0XHRcblx0XHRjb21ibyhbJ3N1cGVyK3UnXSxmdW5jdGlvbihzZWwsbykge1xuXHRcdFx0Y29uc29sZS5sb2coc2VsLnRhcmdldCgpLFwiZm91bmQgdXQhISFcIik7XG5cdFx0XHRyZXR1cm4gY29uc29sZS5sb2coc2VsLnRhcmdldCgpLmJ1YmJsZSgndW53cmFwJyx7fSkpO1xuXHRcdH0pLFxuXHRcdFxuXHRcdGNvbWJvKFsnYWx0K3N1cGVyK3InXSxmdW5jdGlvbigpIHsgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTsgfSlcblx0XTtcblx0XG5cdElNLlRyaWdnZXJzID0gW1xuXHRcdFxuXHRcdHRyaWdnZXIoJ3wnLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5yZWdpb24oKS5wZWVrKC0xLDEpID09ICd8fCc7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwubW92ZSgxKTsgfX0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJ1snLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgnWyQwXScpOyB9KSxcblx0XHR0cmlnZ2VyKCd8JyxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJ3wkMHwnKTsgfSksXG5cdFx0dHJpZ2dlcignKCcsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCcoJDApJyk7IH0pLFxuXHRcdHRyaWdnZXIoJ3snLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgneyQwfScpOyB9KSxcblx0XHRcblx0XHR0cmlnZ2VyKCc8Jyx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiAhc2VsLnBlZWtiZWhpbmQoLyhcXGIodGFnfGlmfGNsYXNzKSB8XFxkXFxzKiQpLyk7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCc8JDA+Jyk7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKCdcIicse2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCxvKSB7XG5cdFx0XHRpZiAoc2VsLnJlZ2lvbigpLnBlZWsoLTEsMCkgPT0gJ1xcXFwnICYmIChvLm5vZGUgPSBzZWwucmVnaW9uKCkuc2NvcGUocSQoJy5faW1zdHInLHNlbGYpKSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCdcIicpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcihcIidcIix7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHsgcmV0dXJuIHNlbC5yZWdpb24oKS5wZWVrKC0xLDEpID09IFwiJydcIjsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5tb3ZlKDEpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcihcIidcIix7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHsgcmV0dXJuIG8ubm9kZSA9IHNlbC5yZWdpb24oKS5zY29wZShxJCgnLl9pbXN0cicsc2VsZikpOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydChcIlxcXFwnXCIpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcignXCInLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgnXCIkMFwiJyk7IH0pLFxuXHRcdHRyaWdnZXIoXCInXCIsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KFwiJyQwJ1wiKTsgfSksXG5cdFx0XG5cdFx0dHJpZ2dlcignXScse2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnJlZ2lvbigpLnBlZWsoMCwxKSA9PSAnXSc7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwubW92ZSgxKTsgfX0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJ30nLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5yZWdpb24oKS5wZWVrKDAsMSkgPT0gJ30nOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLm1vdmUoMSk7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKCcpJyx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwucmVnaW9uKCkucGVlaygwLDEpID09ICcpJzsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5tb3ZlKDEpOyB9fSlcblx0XTtcblx0XG5cdGZ1bmN0aW9uIFNob3J0Y3V0TWFuYWdlcih2aWV3LGJpbmRpbmdzKXtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHR0aGlzLl9iaW5kaW5ncyA9IGJpbmRpbmdzIHx8IElNLktleUJpbmRpbmdzO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRnbG9iYWwuU2hvcnRjdXRNYW5hZ2VyID0gU2hvcnRjdXRNYW5hZ2VyOyAvLyBnbG9iYWwgY2xhc3MgXG5cdFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHR9O1xuXHRcblx0U2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5rZXlzRm9yRXZlbnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIGNvbWJvID0gW107XG5cdFx0dmFyIHNwZWNpYWwgPSBzcGVjaWFsS2V5c1tlLndoaWNoXTtcblx0XHR2YXIgY2hyID0gc3BlY2lhbCB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpO1xuXHRcdFxuXHRcdGNociA9IGNoci50b0xvd2VyQ2FzZSgpOyAvLyB1bmxlc3MgZTpzaGlmdEtleVxuXHRcdFxuXHRcdGlmIChlLmN0cmxLZXkgJiYgc3BlY2lhbCAhPSAnY3RybCcpIHsgY29tYm8ucHVzaCgnY3RybCcpIH07XG5cdFx0aWYgKGUuYWx0S2V5ICYmIHNwZWNpYWwgIT0gJ2FsdCcpIHsgY29tYm8ucHVzaCgnYWx0JykgfTtcblx0XHRpZiAoZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkgJiYgc3BlY2lhbCAhPT0gJ21ldGEnKSB7IGNvbWJvLnB1c2goJ3N1cGVyJykgfTtcblx0XHRpZiAoZS5zaGlmdEtleSAmJiBzcGVjaWFsICE9ICdzaGlmdCcpIHsgY29tYm8ucHVzaCgnc2hpZnQnKSB9O1xuXHRcdGlmIChjb21iby5pbmRleE9mKGNocikgPCAwKSB7IGNvbWJvLnB1c2goY2hyKSB9O1xuXHRcdFxuXHRcdHJldHVybiBjb21iby5qb2luKCcrJyk7XG5cdH07XG5cdFxuXHRTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmNvbW1hbmRzRm9yS2V5cyA9IGZ1bmN0aW9uIChjb21ibyl7XG5cdFx0cmV0dXJuIHRoaXMuX2JpbmRpbmdzLmZpbHRlcihmdW5jdGlvbihiaW5kaW5nKSB7IHJldHVybiBiaW5kaW5nLmtleXMgPT0gY29tYm87IH0pO1xuXHR9O1xuXHRcblx0U2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRTaG9ydGN1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgY29tYm8gPSB0aGlzLmtleXNGb3JFdmVudChlLmV2ZW50KCkpO1xuXHRcdGNvbnNvbGUubG9nKGNvbWJvKTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fYmluZGluZ3MpLCBsZW4gPSBhcnkubGVuZ3RoLCBjbWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y21kID0gYXJ5W2ldO1xuXHRcdFx0aWYgKGNtZC5rZXlzLmluZGV4T2YoY29tYm8pID49IDApIHtcblx0XHRcdFx0dmFyIG8gPSB7fTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZvdW5kIHNob3J0Y3V0Jyxjb21ibyxjbWQ6a2V5c1xuXHRcdFx0XHRpZiAoIWNtZC5jb250ZXh0IHx8IGNtZC5jb250ZXh0LmNhbGwodGhpcy52aWV3KCksdGhpcy52aWV3KCkuY2FyZXQoKSxvLGUsdGhpcy52aWV3KCkpKSB7XG5cdFx0XHRcdFx0Y21kLmRhdGEgPSBvO1xuXHRcdFx0XHRcdHJldHVybiBjbWQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHRTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmdldFRyaWdnZXIgPSBmdW5jdGlvbiAodmlldyx0ZXh0KXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoSU0uVHJpZ2dlcnMpLCBsZW4gPSBhcnkubGVuZ3RoLCBjbWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y21kID0gYXJ5W2ldO1xuXHRcdFx0aWYgKGNtZC50cmlnZ2VyID09IHRleHQpIHtcblx0XHRcdFx0dmFyIHJlcyA9IGNtZC5jb250ZXh0ID8gKGNtZC5jb250ZXh0LmNhbGwodmlldyx2aWV3LmNhcmV0KCksdmlldyx0ZXh0KSkgOiAodHJ1ZSk7XG5cdFx0XHRcdGlmIChyZXMpIHsgcmV0dXJuIGNtZCB9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRyZXR1cm4gU2hvcnRjdXRNYW5hZ2VyO1xuXHRcblx0XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvc2hvcnRjdXRzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW1jYXB0b3InLCAnaW5wdXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAoIXRoaXMuZG9tKCkudmFsdWUpIHtcblx0XHRcdFx0dGhpcy5kb20oKS52YWx1ZSA9ICd4Jztcblx0XHRcdH07XG5cdFx0XHR0aGlzLmRvbSgpLnNlbGVjdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHNlbGYsYXJndW1lbnRzKTtcblx0XHRcdHNlbGYuZG9tKCkub25mb2N1cyA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ2RvbSBvbmZvY3VzISEhIScpO1xuXHRcdFx0XHR2YXIgZXZlbnQgPSBJbWJhLkV2ZW50LndyYXAoe3R5cGU6ICdpbnB1dGZvY3VzJyx0YXJnZXQ6IHNlbGYuZG9tKCl9KTtcblx0XHRcdFx0cmV0dXJuIGV2ZW50LnByb2Nlc3MoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHNlbGYuZG9tKCkub25ibHVyID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnZG9tIG9uYmx1ciEhISEnLGUpO1xuXHRcdFx0XHR2YXIgZXZlbnQgPSBJbWJhLkV2ZW50LndyYXAoe3R5cGU6ICdpbnB1dGJsdXInLHRhcmdldDogc2VsZi5kb20oKSxyZWxhdGVkVGFyZ2V0OiBlLnJlbGF0ZWRUYXJnZXR9KTtcblx0XHRcdFx0cmV0dXJuIGV2ZW50LnByb2Nlc3MoKTtcblx0XHRcdFx0Ly8gSW1iYS5FdmVudHMudHJpZ2dlcignaW5wdXRibHVyJyxkb20pXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL3ZpZXdzL2NhcHRvci5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBkaXNhYmxpbmcgbG9ncyBmb3Igbm93XG5cdC8vIGNvbnNvbGU6bG9nID0gZG8gdHJ1ZVxuXHQvLyBleHRlcm5zO1xuXHRcblx0dmFyIE9QRU4gPSBbJ1wiJyxcIidcIiwnKCcsJ1snLCd7JywnPCddO1xuXHR2YXIgQ0xPU0UgPSBbJ1wiJyxcIidcIiwnKScsJ10nLCd9JywnPiddO1xuXHRcblx0aWYgKEltYmEuRXZlbnRzKSB7XG5cdFx0SW1iYS5FdmVudHMucmVnaXN0ZXIoWydjb3B5JywncGFzdGUnLCdjdXQnLCdiZWZvcmVjdXQnLCdiZWZvcmVwYXN0ZScsJ2JlZm9yZWNvcHknLCdrZXlwcmVzcyddKTtcblx0fTtcblx0XG5cdHZhciBMb2dnZXIgPSByZXF1aXJlKCcuL2NvcmUvbG9nZ2VyJykuTG9nZ2VyO1xuXHR2YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vY29yZS9oaXN0b3J5JykuSGlzdG9yeTtcblx0dmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vY29yZS9idWZmZXInKS5CdWZmZXI7XG5cdHZhciBPYnNlcnZlciA9IHJlcXVpcmUoJy4vY29yZS9vYnNlcnZlcicpLk9ic2VydmVyO1xuXHRcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4vcmVnaW9uJykuUmVnaW9uO1xuXHR2YXIgaGludHMkID0gcmVxdWlyZSgnLi9jb3JlL2hpbnRzJyksIEhpbnRzID0gaGludHMkLkhpbnRzLCBIaW50ID0gaGludHMkLkhpbnQ7XG5cdHZhciBIaWdobGlnaHRlciA9IHJlcXVpcmUoJy4vY29yZS9oaWdobGlnaHRlcicpLkhpZ2hsaWdodGVyO1xuXHRcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXHRcblx0cmVxdWlyZSgnLi9jb3JlL2NhcmV0Jyk7XG5cdFxuXHRyZXF1aXJlKCcuL3ZpZXdzL292ZXJsYXlzJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1kaW1zJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyB1bmNhY2hlXG5cdFx0XHRpZiAodGhpcy5fb3cgIT0gdGhpcy5kb20oKS5vZmZzZXRXaWR0aCkge1xuXHRcdFx0XHR0aGlzLl9vdyA9IHRoaXMuZG9tKCkub2Zmc2V0V2lkdGg7XG5cdFx0XHRcdHRoaXMuX2NoID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9jaCB8fCAodGhpcy5fY2ggPSB0aGlzLmRvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXZpZXdib2R5Jyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW12aWV3JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZpbGVuYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9maWxlbmFtZTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RmlsZW5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5fZmlsZW5hbWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ic2VydmVyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9vYnNlcnZlcjsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0T2JzZXJ2ZXIgPSBmdW5jdGlvbih2KXsgdGhpcy5fb2JzZXJ2ZXIgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2hpc3Rvcnk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhpc3RvcnkgPSBmdW5jdGlvbih2KXsgdGhpcy5faGlzdG9yeSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGludHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2hpbnRzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIaW50cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oaW50cyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9nZ2VyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9sb2dnZXI7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldExvZ2dlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9sb2dnZXIgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNob3J0Y3V0cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2hvcnRjdXRzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTaG9ydGN1dHMgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2hvcnRjdXRzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2ZvY3VzTm9kZSA9IHt3YXRjaDogJ2ZvY3VzTm9kZURpZFNldCcsbmFtZTogJ2ZvY3VzTm9kZSd9O1xuXHRcdHRhZy5wcm90b3R5cGUuZm9jdXNOb2RlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9mb2N1c05vZGU7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEZvY3VzTm9kZSA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmZvY3VzTm9kZSgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2ZvY3VzTm9kZSA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmZvY3VzTm9kZURpZFNldCAmJiB0aGlzLmZvY3VzTm9kZURpZFNldCh2LGEsdGhpcy5fX2ZvY3VzTm9kZSkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhcmV0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jYXJldDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2FyZXQgPSBmdW5jdGlvbih2KXsgdGhpcy5fY2FyZXQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZyYW1lcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZnJhbWVzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRGcmFtZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fZnJhbWVzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWFkb25seSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVhZG9ubHk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlYWRvbmx5ID0gZnVuY3Rpb24odil7IHRoaXMuX3JlYWRvbmx5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oaWdobGlnaHRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEhpZ2hsaWdodGVyO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5saW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGltcy5kb20oKS5vZmZzZXRIZWlnaHQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoYXJXaWR0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RpbXMuY2goKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNSZWFkT25seSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuaGlzdG9yeSgpLm1vZGUoKSA9PSAncGxheSc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRhYlNpemUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiA0O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2J1aWxkIGltdmlldydcblx0XHRcdFZJRVcgPSB0aGlzO1xuXHRcdFx0dGhpcy5zZXRUYWJpbmRleCgwKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5fcmVhZG9ubHkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIodGhpcyk7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSAwO1xuXHRcdFx0dGhpcy5fY2hhbmdlcyA9IDA7XG5cdFx0XHRcblx0XHRcdHRoaXMuX2hpbnRzID0gbmV3IEhpbnRzKHRoaXMpO1xuXHRcdFx0dGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlcih0aGlzKTtcblx0XHRcdHRoaXMuX2hpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzKTtcblx0XHRcdHRoaXMuX3Nob3J0Y3V0cyA9IG5ldyBTaG9ydGN1dE1hbmFnZXIodGhpcyk7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIodGhpcyk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuc2V0UmVnaW9uKG5ldyBSZWdpb24oMCwwLHRoaXMucm9vdCgpLHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0Ly8gYmluZCB0byBtb3VzZW1vdmUgb2YgZG9tP1xuXHRcdFx0XG5cdFx0XHR0aGlzLmRvbSgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsZnVuY3Rpb24oZSkgeyByZXR1cm4gSW1iYS5FdmVudHMuZGVsZWdhdGUoZSk7IH0pO1xuXHRcdFx0dGhpcy5kb20oKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsZnVuY3Rpb24oZSkgeyByZXR1cm4gSW1iYS5FdmVudHMuZGVsZWdhdGUoZSk7IH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCl7XG5cdFx0XHRcblx0XHRcdGlmIChpbnB1dCAhPSB0aGlzLl9pbnB1dCkge1xuXHRcdFx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnc2V0IGlucHV0ISEhJyxAaW5wdXRcblx0XHRcdFx0dGhpcy5faW5wdXQuZG9tKCkuX3Jlc3BvbmRlciA9IHRoaXMuZG9tKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlucHV0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5faW5wdXQgfHwgdGhpcy5fY2FyZXQuaW5wdXQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNhbGxlZCBldmVyeSBmcmFtZSAtIGxvb2tpbmcgZm9yIGNoYW5nZWQgbm9kZXMgdG8gZGVhbCB3aXRoXG5cdFx0Ly8gdG8gZGVhbCB3aXRoIG11dGF0aW9ucy5cblx0XHR0YWcucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuX2ZyYW1lcysrO1xuXHRcdFx0dGhpcy5oaXN0b3J5KCkudGljaygpO1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkgdGhpcy5yZXBhaXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnRpY2soKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgbG9nZ2VyXztcblx0XHRcdChsb2dnZXJfID0gdGhpcy5sb2dnZXIoKSkubG9nLmFwcGx5KGxvZ2dlcl8sYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lZGl0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYuX2NoYW5nZXMrKztcblx0XHRcdHNlbGYuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdHNlbGYuX2J1ZmZlci5yZWZyZXNoKCk7XG5cdFx0XHRcblx0XHRcdHNlbGYudmlldygpLmhpbnRzKCkucmVtKGZ1bmN0aW9uKGhpbnQpIHtcblx0XHRcdFx0cmV0dXJuIGhpbnQuZ3JvdXAoKSA9PSAncnVudGltZSc7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0c2VsZi5oaW50cygpLmNsZWFudXAoKTtcblx0XHRcdFxuXHRcdFx0c2VsZi5kZWxheSgnZGlkY2hhbmdlJyw1MCxmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIEltYmEuRXZlbnRzLnRyaWdnZXIoJ2VkaXRlZDphc3luYycsc2VsZix7ZGF0YTogc2VsZn0pO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIHdlIGNhbiBpbXByb3ZlIGhvdy93aGVuIHdlIGNob29zZSB0byBhbm5vdGF0ZS5cblx0XHRcdC8vIGN1cnJlbnRseSB3ZSBkbyBpdCBhZnRlciBldmVyeSBlZGl0IC0gYnV0IGl0IHNob3VsZFxuXHRcdFx0Ly8gcmVhbGx5IG9ubHkgYmUgbmVlZGVkIHdoZW4gd2UgaGF2ZSBjaGFuZ2VkIGlkZW50aWZpZXJzLlxuXHRcdFx0Ly8gc2hvdWxkIGFsc28gb25seSByZWFubm90YXRlIHRoZSBjbG9zZXN0IGtub3duIHNjb3BlLFxuXHRcdFx0Ly8gYnV0IHRoaXMgY29tZXMgbGF0ZXIgd2l0aCByZWZhY3RvcmluZyBmcm9tIHdob2xlIGZpbGVzXG5cdFx0XHQvLyB0byBzY29wZXMuXG5cdFx0XHRzZWxmLmRlbGF5KCdhbm5vdGF0ZScsNTAwLGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5hbm5vdGF0ZSgpOyB9KTtcblx0XHRcdHNlbGYuZGVsYXkoJ3JlY29tcGlsZScsLTEpOyAvLyBjYW5jZWwgcmVjb21waWxhdGlvblxuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZmxhZygnYWN0aXZlJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy51bmZsYWcoJ2FjdGl2ZScpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiAodDAgPSB0aGlzLl9ib2R5PXRoaXMuX2JvZHkgfHwgdGFnJC4kaW12aWV3Ym9keSgpLnNldFJlZignYm9keScsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodGhpcy5fZGltcyA9IHRoaXMuX2RpbXMgfHwgdGFnJC4kaW1kaW1zKCkuc2V0UmVmKCdkaW1zJyx0aGlzKSkuc2V0VGV4dChcInhcIikuZW5kKCksXG5cdFx0XHRcdCh0aGlzLl9jYXJldCA9IHRoaXMuX2NhcmV0IHx8IHRhZyQuJGltY2FyZXQoKS5zZXRSZWYoJ2NhcmV0Jyx0aGlzKSkuc2V0Vmlldyh0aGlzKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMuX3Jvb3QgPSB0aGlzLl9yb290IHx8IHRhZyQuJGltcm9vdCgpLnNldFJlZigncm9vdCcsdGhpcykuZmxhZygnaW1iYScpKS5zZXRWaWV3KHRoaXMpLmVuZCgpXG5cdFx0XHRdLDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWFkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5mb290ZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vdmVybGF5cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICh0aGlzLl9vdmVybGF5cyA9IHRoaXMuX292ZXJsYXlzIHx8IHRhZyQuJHNjcmltYmxhX292ZXJsYXlzKCkuc2V0UmVmKCdvdmVybGF5cycsdGhpcykpLnNldFZpZXcodGhpcykuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygncmVhZG9ubHknLHRoaXMuaXNSZWFkT25seSgpKS5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHRoaXMuaGVhZGVyKCksXG5cdFx0XHRcdHRoaXMuYm9keSgpLFxuXHRcdFx0XHR0aGlzLmZvb3RlcigpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYXJldCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcm9vdDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyO1xuXHRcdFx0Ly8gcm9vdC5jb2RlXG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnJvb3QoKS5zaXplKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29kZSxvKXtcblx0XHRcdHZhciBwYXJzZWQ7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdHRoaXMuc2V0RmlsZW5hbWUoby5maWxlbmFtZSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9hZGluZyBmaWxlIHdpdGggZmlsZW5hbWUnLG86ZmlsZW5hbWVcblx0XHRcdC8vIG9ic2VydmVyLnBhdXNlIGRvXG5cdFx0XHRpZiAoby5odG1sKSB7XG5cdFx0XHRcdHRoaXMucm9vdCgpLmRvbSgpLmlubmVySFRNTCA9IG8uaHRtbDtcblx0XHRcdFx0dGhpcy5fYnVmZmVyLnJlZnJlc2goKTtcblx0XHRcdFx0dGhpcy5oaXN0b3J5KCkub25sb2FkKHRoaXMuY29kZSgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHNob3VsZCB1c2Ugb3VyIG5ldyBwYXJzZXJcblx0XHRcdFx0aWYgKHBhcnNlZCA9IHRoaXMucGFyc2UoY29kZSkpIHtcblx0XHRcdFx0XHRpZiAocGFyc2VkLmhpZ2hsaWdodGVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJvb3QoKS5kb20oKS5pbm5lckhUTUwgPSBwYXJzZWQuaGlnaGxpZ2h0ZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucm9vdCgpLmRvbSgpLnRleHRDb250ZW50ID0gY29kZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLl9idWZmZXIucmVmcmVzaCgpO1xuXHRcdFx0XHR0aGlzLmhpc3RvcnkoKS5vbmxvYWQoY29kZSk7XG5cdFx0XHRcdHRoaXMuYW5ub3RhdGUoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHQvLyBoZXJlIHdlIGNhbiBwYXJzZSB0aGUgZnVsbCBjb2RlXG5cdFx0XHRyZXR1cm4ge2hpZ2hsaWdodGVkOiBJTS5wYXJzZShjb2RlKX07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlZm9jdXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuaW5wdXQoKS5kb20oKSkgeyB0aGlzLmlucHV0KCkuZm9jdXMoKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5wdXRmb2N1cyA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGNvbnNvbGUubG9nKCdvbmlucHV0Zm9jdXMhIScpO1xuXHRcdFx0VklFVyA9IHRoaXM7IC8vIGhhY2tcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ2ZvY3VzJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5wdXRibHVyID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIHRoaXMudW5mbGFnKCdmb2N1cycpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmZvY3VzaW4gPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRWSUVXID0gdGhpczsgLy8gaGFja1xuXHRcdFx0dGhpcy5mbGFnKCdmb2N1cycpO1xuXHRcdFx0Y29uc29sZS5sb2coJ2ZvY3VzJyxlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmZvY3Vzb3V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy51bmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHRjb25zb2xlLmxvZygndW5mb2N1cycsZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRleHRpbnB1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5leGVjQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbixrZXlkb3duKXtcblx0XHRcdHZhciBjb21tYW5kXztcblx0XHRcdGlmIChhY3Rpb24uY29tbWFuZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBhY3Rpb24uY29tbWFuZC5jYWxsKHRoaXMsdGhpcy5jYXJldCgpLGFjdGlvbi5kYXRhIHx8IHtldmVudDoga2V5ZG93bn0sdGhpcyk7XG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgKGNvbW1hbmRfID0gYWN0aW9uLmNvbW1hbmQpPT0nc3RyaW5nJ3x8Y29tbWFuZF8gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdjb21tYW5kIGlzIHN0cmluZycsYWN0aW9uLmNvbW1hbmQpO1xuXHRcdFx0XHR2YXIgZXYgPSBJbWJhLkV2ZW50cy50cmlnZ2VyKGFjdGlvbi5jb21tYW5kLHRoaXMse2RhdGE6IGFjdGlvbn0pO1xuXHRcdFx0XHR0aGlzLmxvZyhldik7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHJ5Q29tbWFuZCA9IGZ1bmN0aW9uIChjbWQsdGFyZ2V0LHBhcmFtcyl7XG5cdFx0XHRpZihwYXJhbXMgPT09IHVuZGVmaW5lZCkgcGFyYW1zID0gW107XG5cdFx0XHRpZiAoY21kLmNvbnRleHQpIHtcblx0XHRcdFx0dmFyIGd1YXJkID0gY21kLmNvbnRleHQuYXBwbHkodGFyZ2V0IHx8IHRoaXMscGFyYW1zKTtcblx0XHRcdFx0aWYgKCFndWFyZCkgeyByZXR1cm4gZmFsc2UgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjbWQuY29tbWFuZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBjbWQuY29tbWFuZC5hcHBseSh0YXJnZXQgfHwgdGhpcyxwYXJhbXMpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25rZXlkb3duID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIGFycjtcblx0XHRcdFZJRVcgPSB0aGlzOyAvLyBoYWNrXG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdC8vIHZhciBjb21ibyA9IGUua2V5Y29tYm9cblx0XHRcdHZhciBjb21ibyA9IHRoaXMuc2hvcnRjdXRzKCkua2V5c0ZvckV2ZW50KGUuZXZlbnQoKSk7XG5cdFx0XHR2YXIgYWN0aW9uID0gdGhpcy5zaG9ydGN1dHMoKS5nZXRTaG9ydGN1dChlKTtcblx0XHRcdHZhciBpbnMgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHR2YXIgc2hpZnQgPSAoL1xcYnNoaWZ0XFxiLykudGVzdChjb21ibyk7XG5cdFx0XHR2YXIgYWx0ID0gKC9cXGJhbHRcXGIvKS50ZXN0KGNvbWJvKTtcblx0XHRcdHZhciBzdXAgPSAoL1xcYnN1cGVyXFxiLykudGVzdChjb21ibyk7XG5cdFx0XHRcblx0XHRcdC8vIGxvZyAnaW12aWV3IGtleWRvd24nLGNvbWJvXG5cdFx0XHRcblx0XHRcdGlmIChhY3Rpb24pIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2FjdGlvbiBoZXJlPyEnLGFjdGlvblxuXHRcdFx0XHRpZiAodGhpcy5leGVjQWN0aW9uKGFjdGlvbixlKSkgeyBlLmNhbmNlbCgpIH07XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG1vdmUgdGhlc2UgaW50byBjb21tYW5kcyBhcyB3ZWxsXG5cdFx0XHQvLyB0aGlzc2hvdWxkIG1vdmUgdGhpcyBpbnRvIGNvbW1hbmRzIGluc3RlYWRcblx0XHRcdGlmIChhcnIgPSBjb21iby5tYXRjaCgvXFxiKGxlZnR8cmlnaHR8dXB8ZG93bikvKSkge1xuXHRcdFx0XHR0aGlzLmhpbnRzKCkuYWN0aXZhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBpc0NvbGxhcHNlZCA9IHRoaXMuY2FyZXQoKS5pc0NvbGxhcHNlZCgpO1xuXHRcdFx0XHR2YXIgZW5kcyA9IHRoaXMuY2FyZXQoKS5lbmRzKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRzaGlmdCA/ICh0aGlzLmNhcmV0KCkuZGVjb2xsYXBzZSgpKSA6ICh0aGlzLmNhcmV0KCkuY29sbGFwc2UoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYXJyWzBdID09ICdkb3duJykge1xuXHRcdFx0XHRcdHRoaXMuY2FyZXQoKS5tb3ZlRG93bigpO1xuXHRcdFx0XHRcdHJldHVybiBlLmNhbmNlbCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyclswXSA9PSAndXAnKSB7XG5cdFx0XHRcdFx0dGhpcy5jYXJldCgpLm1vdmVVcCgpO1xuXHRcdFx0XHRcdHJldHVybiBlLmNhbmNlbCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIG1vZGUgPSBJTS5DSEFSQUNURVJTO1xuXHRcdFx0XHR2YXIgZGlyID0gMDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhcnJbMF0gPT0gJ2xlZnQnKSB7XG5cdFx0XHRcdFx0ZGlyID0gLTE7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYXJyWzBdID09ICdyaWdodCcpIHtcblx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGFsdCkge1xuXHRcdFx0XHRcdG1vZGUgPSBkaXIgPiAwID8gKElNLldPUkRfRU5EKSA6IChJTS5XT1JEX1NUQVJUKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdXApIHtcblx0XHRcdFx0XHRtb2RlID0gZGlyID4gMCA/IChJTS5MSU5FX0VORCkgOiAoSU0uTElORV9TVEFSVCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXNoaWZ0ICYmICFpc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRcdHRoaXMuY2FyZXQoKS5oZWFkKCkuc2V0KGRpciA+IDAgPyAoZW5kc1sxXSkgOiAoZW5kc1swXSkpO1xuXHRcdFx0XHRcdHRoaXMuY2FyZXQoKS5kaXJ0eSgpOyAvLyBzaG91bGQgbm90IG5lZWQgdG8gY2FsbCB0aGlzIGFsbCB0aGUgdGltZVxuXHRcdFx0XHRcdHJldHVybiBlLmNhbmNlbCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5jYXJldCgpLm1vdmUoZGlyLG1vZGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGUuY2FuY2VsKCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZS5ldmVudCgpLndoaWNoID09IDIyOSkge1xuXHRcdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY29tYm8ubWF0Y2goL15zdXBlclxcKyhjfHZ8eCkkLykpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ21hdGNoaW5nIGNvbWJvIGZvciBjb3B5IHBhc3RlJ1xuXHRcdFx0XHRlLmhhbHQoKTtcblx0XHRcdFx0dGhpcy5fYXdhaXRDb21ibyA9IHRydWU7XG5cdFx0XHRcdHRoaXMucmVmb2N1cygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoaW5zICE9IG51bGwpIHtcblx0XHRcdFx0ZS5oYWx0KCkuY2FuY2VsKCk7XG5cdFx0XHRcdHRoaXMuY2FyZXQoKS5pbnNlcnQoaW5zKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25rZXlwcmVzcyA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmICh0aGlzLl9hd2FpdENvbWJvKSB7XG5cdFx0XHRcdHRoaXMuX2F3YWl0Q29tYm8gPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHR2YXIgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS5ldmVudCgpLmNoYXJDb2RlKTtcblx0XHRcdGUuX3RleHQgPSB0ZXh0O1xuXHRcdFx0ZS5jYW5jZWwoKTtcblx0XHRcdHRoaXMub250eXBlKGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udGV4dGlucHV0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCkuY2FuY2VsKCk7XG5cdFx0XHRlLl90ZXh0ID0gZS5ldmVudCgpLmRhdGE7XG5cdFx0XHR0aGlzLm9udHlwZShlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmtleXVwID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udHlwZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBpbnMgPSBlLl90ZXh0O1xuXHRcdFx0XHQvLyBsb2cgJ29udHlwZScsZSxpbnNcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBzcGFucyA9IHRoaXMudmlldygpLm5vZGVzSW5SZWdpb24odGhpcy5jYXJldCgpLnJlZ2lvbigpLGZhbHNlLHRydWUpO1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gc3BhbnNbMF07XG5cdFx0XHRcdHZhciBjbWQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3BhbnMubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0XHQvLyBsb2cgJ3NpbmdsZSBub2RlIGZvciBub2Rlc0luUmVnaW9uJyx0YXJnZXQ6bm9kZVxuXHRcdFx0XHRcdGlmIChjbWQgPSB0YXJnZXQubm9kZVsoXCJ0cmlnZ2VyLVwiICsgaW5zKV0pIHtcblx0XHRcdFx0XHRcdC8vIGxvZyBcImZvdW5kIGNvbWJvIGZvciB0aGlzIT8/IVwiLGNtZFxuXHRcdFx0XHRcdFx0aWYgKHRoaXMudHJ5Q29tbWFuZChjbWQsdGhpcy5jYXJldCgpLFt0YXJnZXQubm9kZSx0YXJnZXRdKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNtZCA9IHRoaXMuc2hvcnRjdXRzKCkuZ2V0VHJpZ2dlcih0aGlzLGlucyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY21kICYmIChjbWQuY29tbWFuZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuXHRcdFx0XHRcdC8vIGxvZyAnZm91bmQgY29tbWFuZCEhJyxjbWRcblx0XHRcdFx0XHQvLyBzaG91bGQgcmF0aGVyIHJ1biB0cnlDb21tYW5kPyE/XG5cdFx0XHRcdFx0cmV0dXJuIGNtZC5jb21tYW5kKHRoaXMuY2FyZXQoKSx0aGlzLGlucyxlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaW5zKSB7IHJldHVybiB0aGlzLmNhcmV0KCkuaW5zZXJ0KGlucykgfTtcblx0XHRcdFx0fTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubG9nKCdlcnJvciBmcm9tIG9udHlwZScpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25iYWNrc3BhY2UgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmNhbmNlbCgpLmhhbHQoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5lcmFzZSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmJlZm9yZWNvcHkgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoREVCVUcpIHsgY29uc29sZS5sb2coJ29uYmVmb3JlY29weScsZSkgfTtcblx0XHRcdHRoaXMuaW5wdXQoKS5zZWxlY3QoKTtcblx0XHRcdHZhciBkYXRhID0gZS5ldmVudCgpLmNsaXBib2FyZERhdGE7XG5cdFx0XHRkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLHRoaXMuY2FyZXQoKS50ZXh0KCkpO1xuXHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmNvcHkgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoREVCVUcpIHsgY29uc29sZS5sb2coJ29uY29weScsZSx0aGlzLmNhcmV0KCkudGV4dCgpKSB9O1xuXHRcdFx0dmFyIGRhdGEgPSBlLmV2ZW50KCkuY2xpcGJvYXJkRGF0YTtcblx0XHRcdGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsdGhpcy5jYXJldCgpLnRleHQoKSk7XG5cdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdHRoaXMucmVmb2N1cygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmN1dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmIChERUJVRykge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnb25jdXQnLGUpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBkYXRhID0gZS5ldmVudCgpLmNsaXBib2FyZERhdGE7XG5cdFx0XHRkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLHRoaXMuY2FyZXQoKS50ZXh0KCkpO1xuXHRcdFx0ZS5oYWx0KCkuY2FuY2VsKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYXJldCgpLmVyYXNlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uYmVmb3JlcGFzdGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gY29uc29sZS5sb2coJ29uYmVmb3JlcGFzdGUnLGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnBhc3RlID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Y29uc29sZS5sb2coJ29ucGFzdGUnLGUpO1xuXHRcdFx0dmFyIGRhdGEgPSBlLmV2ZW50KCkuY2xpcGJvYXJkRGF0YTtcblx0XHRcdHZhciB0ZXh0ID0gZGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG5cdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5pbnNlcnQodGV4dCk7XG5cdFx0XHR0aGlzLnJlZm9jdXMoKTtcblx0XHRcdHJldHVybiB0aGlzLnJlcGFpcigpO1xuXHRcdFx0Ly8gZWRpdCB0ZXh0OiBkYXRhXG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGZvY3VzTm9kZSA9IHNlbC5ub2RlICMgb25seSBpZiBpdCBpcyBpbnNpZGUgdGhlIHNjb3BlP1xuXHRcdFx0Ly8gY2FyZXQucmVnaW9uID0gc2VsLnJlZ2lvblxuXHRcdFx0dGhpcy5jYXJldCgpLnJlbmRlcigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHR2YXIgZm4gPSBvLmNvbW1hbmQ7XG5cdFx0XHR2YXIgYXJncyA9IG8uYXJncyB8fCBbXTtcblx0XHRcdHZhciBldiA9IG5ldyBJbWJhLkV2ZW50KHt0eXBlOiAnY29tbWFuZCcsdGFyZ2V0OiB0aGlzLmRvbSgpLGRhdGE6IG99KTtcblx0XHRcdGV2LnNldERhdGEobyk7XG5cdFx0XHRldi5wcm9jZXNzKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKHRvdWNoKXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHR0aGlzLl9yZWN0ID0gdGhpcy5fYm9keS5kb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvdWNoLmJ1dHRvbigpICE9IDApIHsgcmV0dXJuIH07XG5cdFx0XHRcblx0XHRcdGlmICh0b3VjaC5fdG91Y2gpIHtcblx0XHRcdFx0Ly8gaXMgaXQgbm90IHJlZGlyZWN0ZWQ/XG5cdFx0XHRcdHJldHVybiB0b3VjaC5yZWRpcmVjdCh7fSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgZSA9IHRvdWNoLmV2ZW50KCk7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHQvLyBzZWUgaWYgc2hpZnQgaXMgZG93bj8gc2hvdWxkIGNoYW5nZSBiZWhhdmlvdXJcblx0XHRcdHZhciBzaGlmdCA9IGUuc2hpZnRLZXk7XG5cdFx0XHQvLyBsb2cgJ29udG91Y2hzdGFydCcsdG91Y2gsdG91Y2gueCx0b3VjaC55LGUsdG91Y2guYnV0dG9uXG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5yY0ZvclRvdWNoKHRvdWNoKSk7dmFyIHIgPSBhcnlbMF0sYyA9IGFyeVsxXTtcblx0XHRcdFxuXHRcdFx0aWYgKHNoaWZ0KSB7XG5cdFx0XHRcdHRoaXMuY2FyZXQoKS5zZWxlY3RhYmxlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNhcmV0KCkuY29sbGFwc2UoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuY2FyZXQoKS5oZWFkKCkuc2V0KHIsYykubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICd0b3VjaCBzdGFydCByZWZvY3VzPydcblx0XHRcdHRoaXMucmVmb2N1cygpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnh5VG9Sb3dDb2wgPSBmdW5jdGlvbiAoeCx5KXtcblx0XHRcdHZhciBjb2wgPSBNYXRoLm1heChNYXRoLnJvdW5kKHggLyB0aGlzLmNoYXJXaWR0aCgpKSwwKTtcblx0XHRcdHZhciByb3cgPSBNYXRoLm1heChNYXRoLmNlaWwoeSAvIHRoaXMubGluZUhlaWdodCgpKSwxKTtcblx0XHRcdHJldHVybiBbcm93IC0gMSxjb2xdO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yY0ZvclRvdWNoID0gZnVuY3Rpb24gKHRvdWNoKXtcblx0XHRcdHZhciB4ID0gTWF0aC5tYXgodG91Y2gueCgpIC0gdGhpcy5fcmVjdC5sZWZ0LDApO1xuXHRcdFx0dmFyIHkgPSBNYXRoLm1heCh0b3VjaC55KCkgLSB0aGlzLl9yZWN0LnRvcCwwKTtcblx0XHRcdHJldHVybiB0aGlzLnh5VG9Sb3dDb2woeCx5KTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250b3VjaHVwZGF0ZSA9IGZ1bmN0aW9uICh0b3VjaCl7XG5cdFx0XHR2YXIgYXJ5O1xuXHRcdFx0aWYgKHRvdWNoLmJ1dHRvbigpICE9IDApIHsgcmV0dXJuIH07XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5yY0ZvclRvdWNoKHRvdWNoKSk7dmFyIHIgPSBhcnlbMF0sYyA9IGFyeVsxXTtcblx0XHRcdHRoaXMuY2FyZXQoKS5zZWxlY3RhYmxlKCk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuaGVhZCgpLnNldChyLGMpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5jYXJldCgpLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250b3VjaGVuZCA9IGZ1bmN0aW9uICh0b3VjaCl7XG5cdFx0XHR2YXIgYXJ5O1xuXHRcdFx0aWYgKHRvdWNoLmJ1dHRvbigpICE9IDApIHsgcmV0dXJuIH07XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5yY0ZvclRvdWNoKHRvdWNoKSk7dmFyIHIgPSBhcnlbMF0sYyA9IGFyeVsxXTtcblx0XHRcdHRoaXMuY2FyZXQoKS5oZWFkKCkuc2V0KHIsYykubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lcmFzZSA9IGZ1bmN0aW9uIChyZWcsZWRpdCl7XG5cdFx0XHRyZWcgPSBSZWdpb24ubm9ybWFsaXplKHJlZyx0aGlzKTtcblx0XHRcdFxuXHRcdFx0dmFyIHRleHQgPSByZWcudGV4dCgpO1xuXHRcdFx0dGhpcy5oaXN0b3J5KCkub25lcmFzZShyZWcsdGV4dCxlZGl0KTtcblx0XHRcdFxuXHRcdFx0dmFyIHNwYW5zID0gdGhpcy5ub2Rlc0luUmVnaW9uKHJlZyxmYWxzZSx0cnVlKTtcblx0XHRcdC8vIGdyb3B1IHRoZSBub2Rlc1xuXHRcdFx0dGhpcy5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoc3BhbnMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdHNwYW5zWzFdLm5vZGUuc2V0UHJldih0YWckLiRpbWluc2VydCgpLmZsYWcoJ2RpcnR5JykuZW5kKCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNwYW5zWzBdICYmIHNwYW5zWzBdLm1vZGUgPT0gJ2FsbCcpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygncmVtb3Zpbmcgc2luZ2xlIG5vZGU/IScpO1xuXHRcdFx0XHRcdHZhciBiZWZvcmUgPSBzcGFuc1swXS5ub2RlLnByZXYoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzcGFuc1swXS5ub2RlLnNldFByZXYodGFnJC4kaW1pbnNlcnQoKS5mbGFnKCdkaXJ0eScpLmVuZCgpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzcGFucyksIGxlbiA9IGFyeS5sZW5ndGgsIHNlbCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdC8vIGJ1ZmZlciBuZWVkIHRvIHVwZGF0ZWQgZHVyaW5nIHRoaXM/XG5cdFx0XHRcdFx0c2VsID0gYXJ5W2ldO1xuXHRcdFx0XHRcdHJlcy5wdXNoKHNlbC5ub2RlLmVyYXNlKHNlbC5yZWdpb24sc2VsLm1vZGUsZWRpdCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIGRlbGF5KCdhbm5vdGF0ZScsNTAwKSBkbyBhbm5vdGF0ZVxuXHRcdFx0cmV0dXJuIHRoaXMuZXJhc2VkKHJlZyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluc2VydGVkID0gZnVuY3Rpb24gKGxvYyxzdHIpe1xuXHRcdFx0Y29uc29sZS5sb2coJ2luc2VydGVkJyxsb2Msc3RyKTtcblx0XHRcdHZhciByZWcgPSBuZXcgUmVnaW9uKGxvYyxsb2MgKyBzdHIubGVuZ3RoLG51bGwsdGhpcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5oaW50cygpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFyeVtpXS5hZGp1c3QocmVnLHRydWUpO1xuXHRcdFx0fTtcblx0XHRcdC8vIGhpbnRzLmNsZWFudXBcblx0XHRcdHRoaXMuZWRpdGVkKCk7XG5cdFx0XHRpZiAodXRpbC5pc1doaXRlc3BhY2Uoc3RyKSkgdGhpcy5yZXBhaXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lcmFzZWQgPSBmdW5jdGlvbiAocmVnKXtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmhpbnRzKCkpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldLmFkanVzdChyZWcsZmFsc2UpO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuZWRpdGVkKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXBhaXIoKTsgLy8gcmVwYWlyIHN5bmNocm9ub3VzbHlcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvaW50LHN0cixlZGl0KXtcblx0XHRcdGlmIChwb2ludCBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0XHRpZiAocG9pbnQuc2l6ZSgpID4gMCkge1xuXHRcdFx0XHRcdHRoaXMubG9nZ2VyKCkud2FybigndW5jb2xsYXBzZWQgcmVnaW9uIGluIGluc2VydCBpcyBub3QgYWxsb3dlZCcpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRwb2ludCA9IHBvaW50LnN0YXJ0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLmxvZygnaW5zZXJ0Jyxwb2ludCxzdHIpO1xuXHRcdFx0Ly8gc2hvdWxkIG1heWJlIGNyZWF0ZSB0aGlzIGFzIGEgY29tbWFuZCAtIGFuZCB0aGVuIG1ha2UgaXQgaGFwcGVuP1xuXHRcdFx0XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS5vbmluc2VydChwb2ludCxzdHIsZWRpdCk7XG5cdFx0XHRcblx0XHRcdC8vIGxvZyAnaW5zZXJ0IGluIHZpZXcnXG5cdFx0XHR2YXIgc3BhbnMgPSB0aGlzLm5vZGVzSW5SZWdpb24oUmVnaW9uLm5vcm1hbGl6ZShwb2ludCx0aGlzKSxmYWxzZSk7XG5cdFx0XHR2YXIgbWlkID0gc3BhbnNbMF07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gbWlkIHx8IHNwYW5zLnByZXYgfHwgc3BhbnMubmV4dDtcblx0XHRcdHZhciBsZnQgPSBzcGFucy5sZnQscmd0ID0gc3BhbnMucmd0O1xuXHRcdFx0dmFyIG5vZGU7XG5cdFx0XHR2YXIgcmVnO1xuXHRcdFx0XG5cdFx0XHQvLyBsb2cgc3BhbnMsbWlkLGxmdCxyZ3Rcblx0XHRcdHRoaXMubG9nKCdiZWZvcmUgYW5kIGFmdGVyJyxsZnQscmd0LHN0cik7XG5cdFx0XHRcblx0XHRcdGlmIChtaWQpIHtcblx0XHRcdFx0dGhpcy5sb2coJ2luc2VydCBtaWQnLG1pZC5ub2RlKTtcblx0XHRcdFx0bWlkLm5vZGUuaW5zZXJ0KG1pZC5yZWdpb24sc3RyLGVkaXQsbWlkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocmd0KXtcblx0XHRcdFx0XHRpZiAocmd0LmNhblByZXBlbmQoc3RyKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5sb2coJ3ByZXBlbmQnLHJndCxzdHIpO1xuXHRcdFx0XHRcdFx0cmd0Lmluc2VydCgncHJlcGVuZCcsc3RyLGVkaXQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0ZWQocG9pbnQsc3RyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJndC5pc0ZpcnN0KCkpIHtcblx0XHRcdFx0XHRcdHJndCA9IHJndC5wYXJlbnQoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBmaW5kIHRoZSBjbG9zZXN0IHBhcmVudFxuXHRcdFx0XHR3aGlsZSAobGZ0KXtcblx0XHRcdFx0XHRpZiAobGZ0LmNhbkFwcGVuZChzdHIpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxvZygnYXBwZW5kJyxsZnQsc3RyKTtcblx0XHRcdFx0XHRcdGxmdC5pbnNlcnQoJ2FwcGVuZCcsc3RyLGVkaXQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0ZWQocG9pbnQsc3RyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxmdC5pc0xhc3QoKSkge1xuXHRcdFx0XHRcdFx0bGZ0ID0gbGZ0LnBhcmVudCgpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdG5vZGUgPSB0YWckLiRpbWluc2VydCgpLmVuZCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxmdCkge1xuXHRcdFx0XHRcdGxmdC5zZXROZXh0KG5vZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJndCkge1xuXHRcdFx0XHRcdHJndC5zZXRQcmV2KG5vZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG11c3QgYmUgZW1wdHlcblx0XHRcdFx0XHR0aGlzLnJvb3QoKS5kb20oKS5hcHBlbmRDaGlsZChub2RlLmRvbSgpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdG5vZGUuaW5zZXJ0KCdhcHBlbmQnLHN0cixlZGl0KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmluc2VydGVkKHBvaW50LHN0cik7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubXV0YXRpb25zID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYWlyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0dmFyIGVscyA9IHRoaXMuZG9tKCkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZGlydHknKTtcblx0XHRcdFxuXHRcdFx0aWYgKGVscy5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gbG9nZ2VyLmxvZyBcIntlbHM6bGVuZ3RofSBkaXJ0eSBub2RlcyB0byByZXBhaXJcIlxuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgbXV0cyA9IFtdLCBpID0gMCwgYXJ5ID0gaXRlciQoZWxzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bXV0cy5wdXNoKHRhZyR3cmFwKGFyeVtpXSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG11dHMpLCBsZW4gPSBhcnkubGVuZ3RoLCBtdXQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdG11dCA9IGFyeVtpXTtcblx0XHRcdFx0XHRtdXQudW5mbGFnKCdkaXJ0eScpO1xuXHRcdFx0XHRcdG11dC5tdXRhdGVkKG11dHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcm9vdC5kb20oKS50ZXh0Q29udGVudDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZm9jdXNOb2RlRGlkU2V0ID0gZnVuY3Rpb24gKG5ldyQsb2xkKXtcblx0XHRcdGlmICghdGhpcy5yb290KCkuY29udGFpbnMobmV3JCkpIHsgcmV0dXJuIH07XG5cdFx0XHRcblx0XHRcdHZhciBwYXRoID0gW107XG5cdFx0XHRcblx0XHRcdHdoaWxlIChuZXckICYmIG5ldyQgIT0gdGhpcy5yb290KCkpe1xuXHRcdFx0XHRwYXRoLnB1c2gobmV3JCk7XG5cdFx0XHRcdG5ldyQgPSBuZXckLnBhcmVudCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cSQoJy5mb2N1c18nLHRoaXMpLm1hcChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdGlmIChwYXRoLmluZGV4T2YobikgPCAwKSB7IHJldHVybiBuLnVuZmxhZygnZm9jdXNfJykgfTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwYXRoW2ldLmZsYWcoJ2ZvY3VzXycpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWNvbXBpbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIHNob3VsZCBoYXBwZW4gaW4gYSBzZXBhcmF0ZSB0aHJlYWQgLSBhbmQgYmUgZGVsYXllZFxuXHRcdFx0Y29uc29sZS5sb2coJ3JlY29tcGlsZScpO1xuXHRcdFx0dmFyIHJlcztcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzID0gSW1iYWMuY29tcGlsZSh0aGlzLmNvZGUoKSx7YmFyZTogdHJ1ZX0pO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyB9O1xuXHRcdFx0XG5cdFx0XHRpZiAocmVzKSB7XG5cdFx0XHRcdHRoaXMuY29tcGlsZWQocmVzKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYXJzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ3JlcGFyc2UnKTtcblx0XHRcdHRoaXMucm9vdCgpLnJlaGlnaGxpZ2h0KHtpbm5lcjogdHJ1ZX0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbXBpbGVkID0gZnVuY3Rpb24gKHJlcyl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25ydW5lcnJvciA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGNvbnNvbGUubG9nKCdvbnJ1bmVycm9yJyxlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hZGRFcnJvciA9IGZ1bmN0aW9uIChtc2csbG9jKXtcblx0XHRcdHZhciBub2RlO1xuXHRcdFx0dmFyIHJlZyA9IFJlZ2lvbi5ub3JtYWxpemUobG9jLHRoaXMpO1xuXHRcdFx0Y29uc29sZS5sb2coJ2ZvdW5kIHdhcm5pbmdzJyxyZWcsbXNnLGxvYyk7XG5cdFx0XHRpZiAobm9kZSA9IHRoaXMubm9kZUF0UmVnaW9uKHJlZykpIHtcblx0XHRcdFx0dGhpcy5sb2coJ25vZGUgYXQgcmVnaW9uIGlzPyEnLG5vZGUpO1xuXHRcdFx0XHRtc2cgPSBtc2cuc3BsaXQoL2Vycm9yIGF0IChcXFtbXFxkXFw6XSpcXF0pXFw6XFxzKi8pLnBvcCgpO1xuXHRcdFx0XHRub2RlLmZsYWcoJ2VycicpO1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnZXJyb3InLG1zZyk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5kZWxheSgnYW5ub3RhdGUnLC0xKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hbm5vdGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2Fubm90YXRlJ1xuXHRcdFx0XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWxmLnJvb3QoKS5jb2RlU3RhdGUoKTtcblx0XHRcdHZhciBjb2RlID0gc3RhdGUuY29kZTtcblx0XHRcdFxuXHRcdFx0dmFyIGFwcGx5ID0gZnVuY3Rpb24obWV0YSkge1xuXHRcdFx0XHR2YXIgdmFycyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobWV0YS5zY29wZXMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMCwgaXRlbXMgPSBpdGVyJChhcnlbaV0udmFycyksIGxlbl8gPSBpdGVtcy5sZW5ndGg7IGogPCBsZW5fOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhcnMucHVzaChpdGVtc1tqXSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciB3YXJuaW5ncyA9IG1ldGEud2FybmluZ3MgfHwgW107XG5cdFx0XHRcdHZhciBvbGRXYXJuaW5ncyA9IHNlbGYuaGludHMoKS5maWx0ZXIoZnVuY3Rpb24oaGludCkgeyByZXR1cm4gaGludC5ncm91cCgpID09ICdhbmFseXNpcyc7IH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG9sZFdhcm5pbmdzKSB7XG5cdFx0XHRcdFx0Ly8gY291bGQgaW50ZWxsaWdlbnRseSBrZWVwIHRoZW0gaW5zdGVhZFxuXHRcdFx0XHRcdHNlbGYuaGludHMoKS5yZW0ob2xkV2FybmluZ3MpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHdhcm5pbmdzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgd2FybjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0d2FybiA9IGFyeVtpXTtcblx0XHRcdFx0XHR3YXJuLnR5cGUgfHwgKHdhcm4udHlwZSA9ICdlcnJvcicpO1xuXHRcdFx0XHRcdHdhcm4uZ3JvdXAgPSAnYW5hbHlzaXMnO1xuXHRcdFx0XHRcdHNlbGYuaGludHMoKS5hZGQod2FybikuYWN0aXZhdGUoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh3YXJuaW5ncy5sZW5ndGgpIHsgcmV0dXJuIHNlbGYgfTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBub2RlcyA9IElNLnRleHROb2RlcyhzZWxmLnJvb3QoKS5kb20oKSx0cnVlKTtcblx0XHRcdFx0Ly8gd2hhdCBhYm91dCByZW1vdmluZyBvbGQgd2FybmluZ3M/XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgbWFwID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIG5vZGU7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdG5vZGUgPSBhcnlbaV07XG5cdFx0XHRcdFx0bWFwW25vZGUuX2xvY10gPSBub2RlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZ2V0IHRleHROb2RlcyB3aXRoIG1hcHBpbmcoISlcblx0XHRcdFx0Zm9yICh2YXIgaTEgPSAwLCBsZW4gPSB2YXJzLmxlbmd0aDsgaTEgPCBsZW47IGkxKyspIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gMCwgYXJ5ID0gaXRlciQodmFyc1tpMV0ucmVmcyksIGxlbl8gPSBhcnkubGVuZ3RoLCByZWY7IGsgPCBsZW5fOyBrKyspIHtcblx0XHRcdFx0XHRcdHJlZiA9IGFyeVtrXTtcblx0XHRcdFx0XHRcdHZhciBhID0gcmVmLmxvY1swXTtcblx0XHRcdFx0XHRcdHZhciBiID0gcmVmLmxvY1sxXTtcblx0XHRcdFx0XHRcdHZhciBlcmVmID0gKFwidlwiICsgaTEpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAobWFwW2FdKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBtYXBbYV0ucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdFx0dmFyIG9sZFJlZiA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2VyZWYnKTtcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3NldHRpbmcgdGhlIHJlZiBmb3Igbm9kZT8nLGRvbSxkb20uQHRhZ1xuXHRcdFx0XHRcdFx0XHR0YWckd3JhcChkb20pLnNldEVyZWYoZXJlZik7XG5cdFx0XHRcdFx0XHRcdC8vIGlmIGRvbS5AdGFnXG5cdFx0XHRcdFx0XHRcdC8vIFx0ZG9tLkB0YWcuZXJlZiA9IGVyZWZcblx0XHRcdFx0XHRcdFx0Ly8gZWxzZVxuXHRcdFx0XHRcdFx0XHQvLyBcdGRvbS5zZXRBdHRyaWJ1dGUoJ2VyZWYnLGVyZWYpIHVubGVzcyBvbGRSZWYgPT0gZXJlZlxuXHRcdFx0XHRcdFx0XHQvLyBcdGRvbTpjbGFzc0xpc3QuYWRkKCdsdmFyJylcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zb2xlLnRpbWUoJ2FuYWx5emUnKTtcblx0XHRcdFx0SU0ud29ya2VyKCkuYW5hbHl6ZShjb2RlLHtiYXJlOiB0cnVlfSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygncmVzdWx0IGZyb20gd29ya2VyIGFuYWx5emUnKTtcblx0XHRcdFx0XHRjb25zb2xlLnRpbWVFbmQoJ2FuYWx5emUnKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocmVzLmRhdGEpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUudGltZSgnYW5ub3RhdGUnKTtcblx0XHRcdFx0XHRcdGFwcGx5KHJlcy5kYXRhKTtcblx0XHRcdFx0XHRcdHJldHVybiBjb25zb2xlLnRpbWVFbmQoJ2Fubm90YXRlJyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHNlbGYubG9nKCdlcnJvciBmcm9tIGFubm90YXRlJyxlKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmNvbW1hbmQgPSBmdW5jdGlvbiAoZSxjKXtcblx0XHRcdGlmICh0aGlzW2MuY29tbWFuZF0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHR0aGlzW2MuY29tbWFuZF0uY2FsbCh0aGlzLGMuYXJncyB8fCBbXSk7XG5cdFx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kdW1wU3RhdGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGh0bWw6IHRoaXMucm9vdCgpLmRvbSgpLmlubmVySFRNTCxcblx0XHRcdFx0Y29kZTogdGhpcy5yb290KCkuY29kZSgpLFxuXHRcdFx0XHRzZWxlY3Rpb246IHRoaXMuY2FyZXQoKS5yZWdpb24oKSxcblx0XHRcdFx0dGltZXN0YW1wOiBuZXcgRGF0ZSgpXG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkU3RhdGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdHNlbGYub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZfO1xuXHRcdFx0XHRpZiAoby5odG1sKSB7XG5cdFx0XHRcdFx0c2VsZi5yb290KCkuZG9tKCkuaW5uZXJIVE1MID0gby5odG1sO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG8uY29kZSkge1xuXHRcdFx0XHRcdHNlbGYubG9hZChvLmNvZGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoby5zZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gKHNlbGYuY2FyZXQoKS5zZXRSZWdpb24odl8gPSBvLnNlbGVjdGlvbiksdl8pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbil7XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS5sb2FkKHNlc3Npb24pO1xuXHRcdFx0dGhpcy5oaXN0b3J5KCkucGxheSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRleHROb2RlcyA9IGZ1bmN0aW9uIChyZWwpe1xuXHRcdFx0aWYocmVsID09PSB1bmRlZmluZWQpIHJlbCA9IHRoaXMucm9vdCgpO1xuXHRcdFx0cmV0dXJuIElNLnRleHROb2RlcyhyZWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gU2hvdWxkIGJlIHNlcGFyYXRlIGZyb20gdGhlIHZpZXdjb2RlP1xuXHRcdHRhZy5wcm90b3R5cGUucmVnaW9uRm9yTm9kZSA9IGZ1bmN0aW9uIChub2RlLHJlbCl7XG5cdFx0XHRpZihyZWwgPT09IHVuZGVmaW5lZCkgcmVsID0gdGhpcy5yb290KCk7XG5cdFx0XHR2YXIgZWwgPSBub2RlLl9kb20gfHwgbm9kZTtcblx0XHRcdHZhciBsZW4gPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG5cdFx0XHR2YXIgcm5nID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblx0XHRcdHJuZy5zZXRTdGFydChyZWwuX2RvbSB8fCByZWwsMCk7XG5cdFx0XHRybmcuc2V0RW5kKG5vZGUuX2RvbSB8fCBub2RlLDApO1xuXHRcdFx0dmFyIHByZSA9IHJuZy50b1N0cmluZygpO1xuXHRcdFx0cmV0dXJuIG5ldyBSZWdpb24ocHJlLmxlbmd0aCxwcmUubGVuZ3RoICsgbGVuLHJlbCx0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIFNob3VsZCBtZXJnZSB3aXRoIG5vZGVzSW5SZWdpb25cblx0XHR0YWcucHJvdG90eXBlLm5vZGVBdFJlZ2lvbiA9IGZ1bmN0aW9uIChyZWdpb24sZXhhY3Qpe1xuXHRcdFx0aWYoZXhhY3QgPT09IHVuZGVmaW5lZCkgZXhhY3QgPSBmYWxzZTtcblx0XHRcdGNvbnNvbGUudGltZSgnbm9kZUF0UmVnaW9uJyk7XG5cdFx0XHR2YXIgcmVsID0gdGhpcy5yb290KCk7XG5cdFx0XHR2YXIgYSA9IHJlZ2lvbi5hKCk7XG5cdFx0XHR2YXIgYiA9IHJlZ2lvbi5iKCk7XG5cdFx0XHRcblx0XHRcdHZhciBub2RlcyA9IHRoaXMudGV4dE5vZGVzKHJlbCk7XG5cdFx0XHQvLyBtb3ZlIGludG8gcmVnaW9uIGluc3RlYWQ/XG5cdFx0XHR2YXIgcG9zID0gMDtcblx0XHRcdHZhciBtYXRjaCA9IG51bGw7XG5cdFx0XHR2YXIgYWRpc3QsYmRpc3Qsc3RyLGxlbjtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuXyA9IGFyeS5sZW5ndGgsIG5vZGU7IGkgPCBsZW5fOyBpKyspIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2xvb2tpbmcgdGhyb3VnaCBub2Rlcydcblx0XHRcdFx0bm9kZSA9IGFyeVtpXTtcblx0XHRcdFx0YWRpc3QgPSBhIC0gcG9zO1xuXHRcdFx0XHRiZGlzdCA9IGIgLSBwb3M7XG5cdFx0XHRcdHN0ciA9IG5vZGUudGV4dENvbnRlbnQ7XG5cdFx0XHRcdGxlbiA9IHN0ci5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYWRpc3QgPj0gMCAmJiBhZGlzdCA8IGxlbikge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmb3VuZCBzdGFydGluZyBwb2ludD8nLG5vZGUsc3RyLGFkaXN0XG5cdFx0XHRcdFx0bWF0Y2ggPSBub2RlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdC8vIHJldHVybiB0YWcobm9kZTpwYXJlbnROb2RlKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGJkaXN0ID49IDAgJiYgYmRpc3QgPCBsZW4pIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnZm91bmQgZW5kaW5nIHBvaW50Jyxub2RlLHN0cixiZGlzdFxuXHRcdFx0XHRcdC8vIHJhbmdlLnNldEVuZChub2RlLGJkaXN0KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdHBvcyArPSBsZW47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgZWwgPSB0YWckd3JhcChtYXRjaC5wYXJlbnROb2RlKTtcblx0XHRcdC8vIHdlIHdhbnQgdG8gbWF0Y2ggdGhlIG9uZSB0aGF0IGlzIGZ1bGwgbGVuZ3RoXG5cdFx0XHRpZiAoZXhhY3QgJiYgbGVuIDwgcmVnaW9uLnNpemUoKSkge1xuXHRcdFx0XHR3aGlsZSAoZWwpe1xuXHRcdFx0XHRcdC8vIGJlIGNhcmVmdWxcblx0XHRcdFx0XHR2YXIgZWxyZWcgPSBlbC5yZWdpb24oKTtcblx0XHRcdFx0XHRpZiAocmVnaW9uLmVxdWFscyhlbHJlZykpIHsgcmV0dXJuIGVsIH07XG5cdFx0XHRcdFx0ZWwgPSBlbC5wYXJlbnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnNvbGUudGltZUVuZCgnbm9kZUF0UmVnaW9uJyk7XG5cdFx0XHRyZXR1cm4gbWF0Y2ggPyAodGFnJHdyYXAobWF0Y2gucGFyZW50Tm9kZSkpIDogKG51bGwpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ub2Rlc0ZvckVudGl0eSA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdFx0cmV0dXJuIHEkKCdbZXJlZj1cIicrKFwiXCIgKyByZWYpKydcIl0nLHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZG9lcyBub3QgbmVlZCB0byBiZWxvbmcgdG8gdmlldyBkaXJlY3RseVxuXHRcdHRhZy5wcm90b3R5cGUubm9kZXNJblJlZ2lvbiA9IGZ1bmN0aW9uIChyZWdpb24saW5jbHVkZUVuZHMsZ2VuZXJhbGl6ZSl7XG5cdFx0XHRpZihpbmNsdWRlRW5kcyA9PT0gdW5kZWZpbmVkKSBpbmNsdWRlRW5kcyA9IHRydWU7XG5cdFx0XHRpZihnZW5lcmFsaXplID09PSB1bmRlZmluZWQpIGdlbmVyYWxpemUgPSBmYWxzZTtcblx0XHRcdGNvbnNvbGUudGltZSgnbm9kZXNJblJlZ2lvbicpO1xuXHRcdFx0cmVnaW9uID0gUmVnaW9uLm5vcm1hbGl6ZShyZWdpb24sdGhpcykubm9ybWFsaXplKCk7XG5cdFx0XHR2YXIgYSA9IHJlZ2lvbi5zdGFydCgpO1xuXHRcdFx0dmFyIGIgPSByZWdpb24uZW5kKCk7XG5cdFx0XHRcblx0XHRcdC8vIGNhbiBiZSBvcHRpbWl6ZWQgYnkgc3VwcGx5aW5nIHRoZSByZWdpb25zXG5cdFx0XHR2YXIgbm9kZXMgPSBJTS50ZXh0Tm9kZXMocmVnaW9uLnJvb3QoKSB8fCB0aGlzLnJvb3QoKSk7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IFtdO1xuXHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0Ly8gbW92ZSBpbnRvIHJlZ2lvbiBpbnN0ZWFkP1xuXHRcdFx0bWF0Y2hlcy5pbmNsdWRlRW5kcyA9IGluY2x1ZGVFbmRzO1xuXHRcdFx0bWF0Y2hlcy5yZWdpb24gPSByZWdpb247XG5cdFx0XHRcblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIGVuZHMgPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaTEgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbl8gPSBhcnkubGVuZ3RoLCBub2RlOyBpMSA8IGxlbl87IGkxKyspIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2xvb2tpbmcgdGhyb3VnaCBub2Rlcydcblx0XHRcdFx0bm9kZSA9IGFyeVtpMV07XG5cdFx0XHRcdHZhciBhZGlzdCA9IGEgLSBwb3M7XG5cdFx0XHRcdHZhciBiZGlzdCA9IGIgLSBwb3M7XG5cdFx0XHRcdHZhciBzdHIgPSBub2RlLnRleHRDb250ZW50O1xuXHRcdFx0XHR2YXIgbGVuID0gc3RyLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICgocG9zICsgbGVuKSA+PSBhICYmIHBvcyA8PSBiKSB7XG5cdFx0XHRcdFx0ZWwgPSB0YWckd3JhcChub2RlLnBhcmVudE5vZGUpO1xuXHRcdFx0XHRcdHZhciBzdGFydCA9IE1hdGgubWF4KDAsYSAtIHBvcyk7XG5cdFx0XHRcdFx0dmFyIGVuZCA9IE1hdGgubWluKGxlbixNYXRoLm1heChiIC0gcG9zLDApKTtcblx0XHRcdFx0XHR2YXIgcGFyO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdG1hdGNoID0ge1xuXHRcdFx0XHRcdFx0bm9kZTogZWwsXG5cdFx0XHRcdFx0XHRzdGFydE9mZnNldDogc3RhcnQsXG5cdFx0XHRcdFx0XHRlbmRPZmZzZXQ6IGVuZCxcblx0XHRcdFx0XHRcdHJlZ2lvbjogbmV3IFJlZ2lvbihzdGFydCxlbmQsZWwsdGhpcyksXG5cdFx0XHRcdFx0XHRzaXplOiBsZW5cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIGxvZyBcIm5vZGUgYXQge3Bvc30gKyB7bGVufSAtIGxvb2tpbmcgaW4gcmFuZ2Uge2F9IC0ge2J9XCJcblx0XHRcdFx0XHR2YXIgbW9kZSA9ICdhbGwnO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChzdGFydCA9PSBsZW4pIHtcblx0XHRcdFx0XHRcdG1vZGUgPSAnZW5kJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRtb2RlID0gJ3N0YXJ0Jztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0YXJ0ID09IDAgJiYgZW5kID09IGxlbikge1xuXHRcdFx0XHRcdFx0cGFyID0gZWwuZG9tKCkucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdHZhciBpc09wZW5lciA9IHBhciAhPSB0aGlzLl9yb290LmRvbSgpICYmIGVsLmRvbSgpID09IHBhci5maXJzdENoaWxkO1xuXHRcdFx0XHRcdFx0dmFyIGlzQ2xvc2VyID0gcGFyICE9IHRoaXMuX3Jvb3QuZG9tKCkgJiYgZWwuZG9tKCkgPT0gcGFyLmxhc3RDaGlsZDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGlzT3BlbmVyKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoLm9wZW5zID0gZWwucGFyZW50KCk7XG5cdFx0XHRcdFx0XHRcdGVuZHMucHVzaChtYXRjaCk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoaXNDbG9zZXIpIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdFx0XHRpZiAoZW5kICYmIGVuZC5vcGVucyA9PSBlbC5wYXJlbnQoKSkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZC5jbG9zZXIgPSBtYXRjaDtcblx0XHRcdFx0XHRcdFx0XHRtYXRjaC5vcGVuZXIgPSBlbmQ7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kcy5wb3AoKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdG1hdGNoLmNsb3NlcyA9IGVsLnBhcmVudCgpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0bW9kZSA9ICdhbGwnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtb2RlID0gJ3BhcnRpYWwnO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bWF0Y2gubW9kZSA9IG1vZGU7XG5cdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKG1hdGNoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHBvcyArPSBsZW47XG5cdFx0XHRcdGlmIChwb3MgPiBiKSB7IGJyZWFrOyB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGZpcnN0ID0gbWF0Y2hlc1swXTtcblx0XHRcdHZhciBsYXN0ID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XG5cdFx0XHRpZiAoZmlyc3QgJiYgZmlyc3QubW9kZSA9PSAnZW5kJykge1xuXHRcdFx0XHRtYXRjaGVzLnByZXYgPSBmaXJzdDtcblx0XHRcdFx0bWF0Y2hlcy5sZnQgPSBmaXJzdC5ub2RlO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaWYgZmlyc3Q6bm9kZSBpc2EgSU0uVHlwZXM6Y2xvc2Vcblx0XHRcdFx0Ly8gXHRtYXRjaGVzOmxmdCA9IGZpcnN0Om5vZGUucGFyZW50XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWluY2x1ZGVFbmRzKSB7IG1hdGNoZXMuc2hpZnQoKSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGxhc3QgJiYgbGFzdC5tb2RlID09ICdzdGFydCcpIHtcblx0XHRcdFx0bWF0Y2hlcy5uZXh0ID0gbGFzdDtcblx0XHRcdFx0bWF0Y2hlcy5yZ3QgPSBsYXN0Lm5vZGU7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpZiBsYXN0Om5vZGUgaXNhIElNLlR5cGVzOm9wZW5cblx0XHRcdFx0Ly8gXHRtYXRjaGVzOnJndCA9IGxhc3Q6bm9kZS5wYXJlbnRcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghaW5jbHVkZUVuZHMpIHsgbWF0Y2hlcy5wb3AoKSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBub3JtYWxpemUgdGhlIG5vZGVzIGluIGdyb3Vwc1xuXHRcdFx0aWYgKGdlbmVyYWxpemUpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2dlbmVyYWxpemUhJyxtYXRjaGVzXG5cdFx0XHRcdHZhciBpID0gMDtcblx0XHRcdFx0dmFyIG07XG5cdFx0XHRcdHdoaWxlIChtID0gbWF0Y2hlc1tpXSl7XG5cdFx0XHRcdFx0aWYgKG0uY2xvc2VyKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4ID0gbWF0Y2hlcy5pbmRleE9mKG0uY2xvc2VyKTtcblx0XHRcdFx0XHRcdGxlbiA9IG0ub3BlbnMuc2l6ZSgpO1xuXHRcdFx0XHRcdFx0dmFyIG5ldyQgPSB7XG5cdFx0XHRcdFx0XHRcdG1vZGU6ICdhbGwnLFxuXHRcdFx0XHRcdFx0XHRyZWdpb246IG5ldyBSZWdpb24oMCxsZW4sbS5vcGVucyx0aGlzKSxcblx0XHRcdFx0XHRcdFx0c3RhcnRPZmZzZXQ6IDAsXG5cdFx0XHRcdFx0XHRcdGVuZE9mZnNldDogbGVuLFxuXHRcdFx0XHRcdFx0XHRub2RlOiBtLm9wZW5zXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0dmFyIHJlbSA9IG1hdGNoZXMuc3BsaWNlKGksaWR4IC0gaSArIDEsbmV3JCk7XG5cdFx0XHRcdFx0XHRuZXckLmNoaWxkcmVuID0gcmVtO1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3NsaWNlIGF3YXkgdGhlIGl0ZW1zJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS50aW1lRW5kKCdub2Rlc0luUmVnaW9uJyk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCBtb3ZlIHRvIEJ1ZmZlciBjbGFzc1xuXHRcdHRhZy5wcm90b3R5cGUubGluZWNvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5idWZmZXIoKS5saW5lY291bnQoKTtcblx0XHRcdC8vIGJ1ZmZlci5zcGxpdCgnXFxuJylbOmxlbmd0aF1cblx0XHR9O1xuXHRcdFxuXHRcdC8vIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSByZWdpb24gYXMgYSBzdHJpbmcuXG5cdFx0Ly8gUmV0dXJucyB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodCBvZiB0aGUgcG9pbnQuXG5cdFx0dGFnLnByb3RvdHlwZS5zdWJzdHIgPSBmdW5jdGlvbiAocmVnaW9uLGxlbil7XG5cdFx0XHRyZXR1cm4gdGhpcy5idWZmZXIoKS5zdWJzdHIocmVnaW9uLGxlbik7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBtb3ZlIGludG8gQnVmZmVyXG5cdFx0dGFnLnByb3RvdHlwZS5saW5lc3RyID0gZnVuY3Rpb24gKG5yKXtcblx0XHRcdHJldHVybiB0aGlzLmJ1ZmZlcigpLmxpbmUobnIpO1xuXHRcdFx0Ly8gaWYgbnIgaXNhIE51bWJlclxuXHRcdFx0Ly8gXHRidWZmZXIuc3BsaXQoJ1xcbicpW25yXSBvciAnJ1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5leHBhbmRSZWdpb25UbyA9IGZ1bmN0aW9uIChyZWdpb24sbWF0Y2gsZm9yd2FyZCl7XG5cdFx0XHRpZihmb3J3YXJkID09PSB1bmRlZmluZWQpIGZvcndhcmQgPSB0cnVlO1xuXHRcdFx0dmFyIGJ1ZiA9IHRoaXMuYnVmZmVyKCkudG9TdHJpbmcoKTtcblx0XHRcdHZhciBwb3MgPSByZWdpb24uc3RhcnQoKTtcblx0XHRcdHZhciBlbmQgPSByZWdpb24uZW5kKCk7XG5cdFx0XHRcblx0XHRcdGlmIChmb3J3YXJkKSB7XG5cdFx0XHRcdHdoaWxlIChidWZbZW5kICsgMV0gIT0gbWF0Y2gpe1xuXHRcdFx0XHRcdGVuZCsrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKGJ1Zltwb3MgLSAxXSAhPSBtYXRjaCl7XG5cdFx0XHRcdFx0cG9zLS07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2lvbihwb3MsZW5kLHRoaXMpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHJldHVybiBWSUVXID0gbnVsbDtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL3ZpZXcuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuLi9yZWdpb24nKS5SZWdpb247XG5cdFxuXHRmdW5jdGlvbiBCdWZmZXIodmlldyl7XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdFx0dGhpcy5fYnVmZmVyID0gJyc7XG5cdFx0dGhpcy5fY2FjaGUgPSB7fTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0QnVmZmVyLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGJ1ZmZlcil7XG5cdFx0aWYgKGJ1ZmZlciA9PSB0aGlzLl9idWZmZXIpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuXHRcdHRoaXMuX2NhY2hlID0ge307XG5cdFx0dGhpcy5fbGluZXMgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuc2V0KHRoaXMudmlldygpLnJvb3QoKS5jb2RlKCkpO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5saW5lcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9saW5lcyB8fCAodGhpcy5fbGluZXMgPSAodHJ1ZSkgJiYgKFxuXHRcdFx0dGhpcy5fYnVmZmVyLnNwbGl0KCdcXG4nKVxuXHRcdCkpO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9idWZmZXIuc3BsaXQuYXBwbHkodGhpcy5fYnVmZmVyLGFyZ3VtZW50cyk7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxpbmVjb3VudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmxpbmVzKCkubGVuZ3RoO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5saW5lID0gZnVuY3Rpb24gKG5yKXtcblx0XHRpZiAoKHR5cGVvZiBucj09J251bWJlcid8fG5yIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubGluZXMoKVtucl0gfHwgJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9O1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyLmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIGxvY2F0aW9uIHRvIFxuXHRCdWZmZXIucHJvdG90eXBlLmxvY1RvUmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUubG9jYXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUubG9jVG9Sb3cgPSBmdW5jdGlvbiAobG9jKXtcblx0XHR2YXIgbG4gPSAwO1xuXHRcdHZhciBsZW4gPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmxpbmVzKCkpLCBsZW5fID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbl87IGkrKykge1xuXHRcdFx0bGVuICs9IGFyeVtpXS5sZW5ndGggKyAxO1xuXHRcdFx0aWYgKGxvYyA8IGxlbikgeyByZXR1cm4gaSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMubGluZXMoKS5sZW5ndGg7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxvY1RvQ2VsbCA9IGZ1bmN0aW9uIChsb2Mpe1xuXHRcdGlmICh0aGlzLl9jYWNoZVtsb2NdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FjaGVbbG9jXTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBwb3MgPSBsb2M7XG5cdFx0dmFyIGNvbCA9IDA7XG5cdFx0dmFyIHJvdyA9IDA7XG5cdFx0dmFyIGNoYXIkO1xuXHRcdFxuXHRcdHZhciBidWYgPSB0aGlzLl9idWZmZXI7XG5cdFx0dmFyIHRhYnNpemUgPSB0aGlzLl92aWV3LnRhYlNpemUoKTtcblx0XHRcblx0XHQvLyBnbyBiYWNrIHRvIHN0YXJ0IG9mIGxpbmVcblx0XHQvLyBnb2VzIHRocm91Z2ggdGhlIHdob2xlXG5cdFx0d2hpbGUgKGNoYXIkID0gYnVmW3BvcyAtIDFdKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFxuJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH07XG5cdFx0XHRwb3MtLTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGdldCBjb2x1bW4gZm9yIHNsaWNlXG5cdFx0d2hpbGUgKChwb3MgPCBsb2MpICYmIChjaGFyJCA9IGJ1Zltwb3NdKSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcdCcpIHtcblx0XHRcdFx0dmFyIHJlc3QgPSB0YWJzaXplIC0gKGNvbCAlIHRhYnNpemUpO1xuXHRcdFx0XHRjb2wgKz0gcmVzdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbCArPSAxO1xuXHRcdFx0fTtcblx0XHRcdHBvcysrO1xuXHRcdH07XG5cdFx0XG5cdFx0d2hpbGUgKGNoYXIkID0gYnVmW3BvcyAtIDFdKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFxuJykge1xuXHRcdFx0XHRyb3crKztcblx0XHRcdH07XG5cdFx0XHRwb3MtLTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzLl9jYWNoZVtsb2NdID0gW3Jvdyxjb2xdO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5zdWJzdHIgPSBmdW5jdGlvbiAocmVnaW9uLGxlbil7XG5cdFx0aWYgKHJlZ2lvbiBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2J1ZmZlci5zdWJzdHIocmVnaW9uLnN0YXJ0KCkscmVnaW9uLnNpemUoKSk7XG5cdFx0fSBlbHNlIGlmICgodHlwZW9mIHJlZ2lvbj09J251bWJlcid8fHJlZ2lvbiBpbnN0YW5jZW9mIE51bWJlcikpIHtcblx0XHRcdHJldHVybiB0aGlzLl9idWZmZXIuc3Vic3RyKHJlZ2lvbixsZW4gfHwgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93ICdtdXN0IGJlIHJlZ2lvbiBvciBudW1iZXInO1xuXHRcdH07XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2J1ZmZlciB8fCAnJztcblx0fTtcblx0cmV0dXJuIEJ1ZmZlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvYnVmZmVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cdFxuXHRmdW5jdGlvbiBPYnNlcnZlcih2aWV3LGNmZyl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdHNlbGYuX3ZpZXcgPSB2aWV3O1xuXHRcdHNlbGYuX2NvbmZpZyA9IGNmZyB8fCB7YXR0cmlidXRlczogZmFsc2UsY2hpbGRMaXN0OiB0cnVlLGNoYXJhY3RlckRhdGE6IHRydWUsc3VidHJlZTogdHJ1ZX07XG5cdFx0c2VsZi5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbihtdXRzKSB7IHJldHVybiBzZWxmLm9ubXV0YXRpb25zKG11dHMpOyB9KTtcblx0XHRzZWxmO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5PYnNlcnZlciA9IE9ic2VydmVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0T2JzZXJ2ZXIucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdE9ic2VydmVyLnByb3RvdHlwZS5jb25maWcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvbmZpZzsgfVxuXHRPYnNlcnZlci5wcm90b3R5cGUuc2V0Q29uZmlnID0gZnVuY3Rpb24odil7IHRoaXMuX2NvbmZpZyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdE9ic2VydmVyLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuXHRPYnNlcnZlci5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24odil7IHRoaXMuX2FjdGl2ZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7XG5cdFx0XHR0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMudmlldygpLnJvb3QoKS5kb20oKSx0aGlzLmNvbmZpZygpKTtcblx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE9ic2VydmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChibGspe1xuXHRcdHZhciB3YXNBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG5cdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0aWYgKHdhc0FjdGl2ZSkgeyB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCkgfTtcblx0XHRcblx0XHRpZiAoYmxrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdGJsaygpO1xuXHRcdFx0aWYgKHdhc0FjdGl2ZSkgdGhpcy5yZXN1bWUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLnBhdXNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAhdGhpcy5fYWN0aXZlO1xuXHR9O1xuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLm9ubXV0YXRpb25zID0gZnVuY3Rpb24gKG11dGF0aW9ucyl7XG5cdFx0dmFyIGVsO1xuXHRcdHRoaXMudmlldygpLmxvZ2dlcigpLmdyb3VwKCdtdXRhdGlvbnMnKTtcblx0XHRcblx0XHR2YXIgZGVlcCA9IGZhbHNlO1xuXHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChtdXRhdGlvbnMpLCBsZW4gPSBhcnkubGVuZ3RoLCBtdXQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0bXV0ID0gYXJ5W2ldO1xuXHRcdFx0dGhpcy52aWV3KCkubG9nKCdtdXRhdGlvbicsbXV0KTtcblx0XHRcdHZhciB0eXBlID0gbXV0LnR5cGU7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gbXV0LnByZXZpb3VzU2libGluZyB8fCBtdXQudGFyZ2V0O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnY2hhcmFjdGVyRGF0YScpIHtcblx0XHRcdFx0dGhpcy52aWV3KCkubG9nKChcInVwZGF0ZWQgY29kZSB0byBcIiArICh0YXJnZXQudGV4dENvbnRlbnQpKSk7XG5cdFx0XHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09ICdjaGlsZExpc3QnKSB7XG5cdFx0XHRcdGRlZXAgPSB0cnVlO1xuXHRcdFx0XHR2YXIgYWRkID0gbXV0LmFkZGVkTm9kZXM7XG5cdFx0XHRcdGlmIChhZGQubGVuZ3RoID09IDEgJiYgKGFkZFswXSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gYWRkWzBdO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy52aWV3KCkubG9nKHRhcmdldCx0YWckd3JhcCh0YXJnZXQpKTtcblx0XHRcdC8vIHZhciBhZGRlZCA9IG11dDphZGRlZE5vZGVzXG5cdFx0XHQvLyBmb3Igbm9kZSBpbiBtdXQ6YWRkZWROb2Rlc1xuXHRcdFx0Ly8gaWYgdGFyZ2V0IGFuZCB0YXJnZXQ6cGFyZW50Tm9kZSAjIGFuZCB0YXJnZXQuQHRhZ1xuXHRcdFx0aWYgKGVsID0gdGFnJHdyYXAodGFyZ2V0KSkge1xuXHRcdFx0XHR0aGlzLnZpZXcoKS5sb2coJ2FkZCB0YXJnZXQ/IScpO1xuXHRcdFx0XHRpZiAobm9kZXMuaW5kZXhPZihlbCkgPCAwKSB7IG5vZGVzLnB1c2goZWwpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBpZiB3ZSBoYXZlIGFkZGVkIGEgbm9kZSBpbnN0ZWFkXG5cdFx0fTtcblx0XHRcblx0XHQvLyBtdXRhdGlvbnMgYXJlIG5vdCByZWdpc3RlcmVkIG9uIG5vZGUtbGV2ZWwgYnV0IG9uIGV4dGVudFxuXHRcdC8vIG5vdCByZWFsbHkgaG93IHRoaXMgc2hvdWxkIGhhcHBlblxuXHRcdFxuXHRcdHZhciBjb21tb24gPSB1dGlsLmNvbW1vbkFuY2VzdG9yKG5vZGVzKTtcblx0XHRcblx0XHR0aGlzLnZpZXcoKS5sb2coJ2NvbW1vbiBjb250YWluZXIgZm9yIG11dGF0aW9ucyBpcycsY29tbW9uLG5vZGVzKTtcblx0XHRcblx0XHR2YXIgZXh0ZW50O1xuXHRcdFxuXHRcdGlmIChub2Rlcy5sZW5ndGggPT0gMSkge1xuXHRcdFx0dGhpcy52aWV3KCkubG9nKCdhIHNpbmdsZSBub2RlIHdhcyBtdXRhdGVkJyxub2Rlc1swXSk7XG5cdFx0XHRub2Rlc1swXS5tdXRhdGVkKHtkZWVwOiBkZWVwLG11dGF0aW9uczogbXV0YXRpb25zfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGNvbGxlY3QgZXh0ZW50cyBmb3IgYWxsIG5vZGVzP1xuXHRcdFx0Ly8gcmF0aGVyIG1ha2UgYSByZWdpb24gZXhwYW5kIFxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdFx0aWYgKGV4dGVudCAmJiBleHRlbnQuY29udGFpbnMobm9kZS5kb20oKSkpIHsgLy8gOm5vZGVzLmluZGV4T2Yobm9kZS5kb20pID49IDBcblx0XHRcdFx0XHR0aGlzLnZpZXcoKS5sb2coJ3RoaXMgbm9kZSBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIGV4dGVudCcsbm9kZS5kb20oKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gbm9kZS5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBub2RlPy5tdXRhdGVkXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZXh0ZW50KSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmb3VuZCBleHRlbnQoISknLGV4dGVudFxuXHRcdFx0XHR0aGlzLnBhdXNlKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy52aWV3KCkubG9nZ2VyKCkuZ3JvdXBFbmQoKTtcblx0XHR0aGlzLnZpZXcoKS5vbm11dGF0aW9ucyh7bm9kZXM6IG5vZGVzLG11dGF0aW9uczogbXV0YXRpb25zLGV4dGVudDogZXh0ZW50fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBPYnNlcnZlcjtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL29ic2VydmVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuLi9yZWdpb24nKS5SZWdpb247XG5cdFxuXHR2YXIgbGFiZWxzID0ge1xuXHRcdFwiVW5leHBlY3RlZCAnVEFHX0VORCdcIjogJ1RhZyBjbG9zZWQgdW5leHBlY3RlZGx5Jyxcblx0XHRcIlVuZXhwZWN0ZWQgJ1RFUk1JTkFUT1InXCI6ICdVbmV4cGVjdGVkIOKPjicsXG5cdFx0XCJVbmV4cGVjdGVkICdQT1NUX0lGJ1wiOiAnTWlzc2luZyBib2R5IGluIDxiPklGPC9iPidcblx0fTtcblx0XG5cdHZhciBydWxlcyA9IFtcblx0XHRbL1VuY2F1Z2h0IEVycm9yOiB0YWcgKFxcdyspIGlzIG5vdCBkZWZpbmVkLyxcInRhZyA8Yj4kMTwvYj4gZG9lcyBub3QgZXhpc3RcIl1cblx0XTtcblx0XG5cdGZ1bmN0aW9uIEhpbnQob3B0cyx2aWV3KXtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHR0aGlzLl9kYXRhID0gb3B0cztcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLl9yZWdpb24gPSBvcHRzLmxvYyA/IChSZWdpb24ubm9ybWFsaXplKG9wdHMubG9jLHZpZXcpKSA6IChudWxsKTtcblx0XHQvLyB0cnkgdG8gZmluZCB0aGUgbm9kZSBpbW1lZGlhdGVseVxuXHRcdHRoaXMuX25vZGUgPSBvcHRzLm5vZGUgfHwgdGhpcy5ub2RlKCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuSGludCA9IEhpbnQ7IC8vIGV4cG9ydCBjbGFzcyBcblx0SGludC5idWlsZCA9IGZ1bmN0aW9uIChvLHZpZXcpe1xuXHRcdHJldHVybiBuZXcgdGhpcyhvLHZpZXcpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRIaW50LnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdEhpbnQucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpbnQucHJvdG90eXBlLnJlZ2lvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVnaW9uOyB9XG5cdEhpbnQucHJvdG90eXBlLnNldFJlZ2lvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZWdpb24gPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaW50LnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuXHRIaW50LnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih2KXsgdGhpcy5fYWN0aXZlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoa2V5KXtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YVtrZXldO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGtleSx2YWwpe1xuXHRcdHRoaXMuX2RhdGFba2V5XSA9IHZhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YS50eXBlIHx8ICdlcnJvcic7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kYXRhLmdyb3VwO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGEucmVmO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9ub2RlIHx8ICh0aGlzLl9ub2RlID0gdGhpcy5fcmVnaW9uICYmIHRoaXMudmlldygpLm5vZGVBdFJlZ2lvbih0aGlzLl9yZWdpb24pKTtcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLnJvdyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnJlZ2lvbigpLnJvdygpO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMucmVnaW9uKCkuY29sKCk7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBsYmw7XG5cdFx0cmV0dXJuIHRoaXMuX2xhYmVsIHx8ICh0aGlzLl9sYWJlbCA9ICh0cnVlKSAmJiAoXG5cdFx0XHRsYmwgPSB0aGlzLl9kYXRhLmxhYmVsIHx8IHRoaXMuX2RhdGEubWVzc2FnZSB8fCAnSGludCcsXG5cdFx0XHRsYmwgPSBsYmwuc3BsaXQoL2Vycm9yIGF0IChcXFtbXFxkXFw6XSpcXF0pXFw6XFxzKi8pLnBvcCgpLFxuXHRcdFx0bGJsID0gbGFiZWxzW2xibF0gfHwgbGJsXG5cdFx0KSk7XG5cdH07XG5cdFxuXHRcblx0SGludC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbm9kZV87XG5cdFx0aWYgKCF0aGlzLl9hY3RpdmUpIHtcblx0XHRcdC8vIG5vZGU/LnNldEF0dHJpYnV0ZSgnaGludCcscmVmKVxuXHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTtcblx0XHRcdChub2RlXyA9IHRoaXMubm9kZSgpKSAmJiBub2RlXy5zZXRIaW50ICAmJiAgbm9kZV8uc2V0SGludCh0aGlzKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGNvbnNvbGUubG9nKCdkZWFjdGl2YXRlIGhpbnQhIScpO1xuXHRcdHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0XHQvLyBjbGVhbnVwXG5cdFx0Ly8gcmVtb3ZlXG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5wcnVuZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnZpZXcoKS5oaW50cygpLnBydW5lKHRoaXMpO1xuXHR9O1xuXHRcblx0Ly8gc2hvdWxkIG1ha2UgdGhpcyBoaW50IHJlYWR5IHRvIGJlIHJlbW92ZWRcblx0SGludC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9ub2RlKSB7XG5cdFx0XHRpZiAodGhpcy5fbm9kZS5oaW50KCkgPT0gdGhpcykgeyB0aGlzLl9ub2RlLnNldEhpbnQobnVsbCkgfTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy52aWV3KCkuaGludHMoKS5yZW0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29uc29sZS5sb2cgJ2RlYWN0aXZhdGUgb24gY2hhbmdlZCEnXG5cdFx0Ly8gQGRlYWN0aXZhdGUgPSB5ZXNcblx0XHR0aGlzLnBydW5lKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5hZGp1c3QgPSBmdW5jdGlvbiAocmVnLGlucyl7XG5cdFx0aWYoaW5zID09PSB1bmRlZmluZWQpIGlucyA9IHRydWU7XG5cdFx0aWYgKHRoaXMucmVnaW9uKCkuaW50ZXJzZWN0cyhyZWcpKSB7XG5cdFx0XHQvLyBkZWFjdGl2YXRlXG5cdFx0XHR0aGlzLnBydW5lKCk7XG5cdFx0XHQvLyBAZGVhY3RpdmF0ZSA9IHllc1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5yZWdpb24oKS5hZGp1c3QocmVnLGlucyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBIaW50cyh2aWV3KXtcblx0XHR0aGlzLl9wcnVuZSA9IFtdO1xuXHRcdHRoaXMuX2FycmF5ID0gW107XG5cdFx0dGhpcy5fbWFwID0ge307XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdH07XG5cdFxuXHRleHBvcnRzLkhpbnRzID0gSGludHM7IC8vIGV4cG9ydCBjbGFzcyBcblx0dmFyIG5yID0gMDtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2FycmF5O1xuXHR9O1xuXHRcblx0SGludHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdHJldHVybiB0aGlzLl9tYXBbcmVmXTtcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9hcnJheSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJ5W2ldLmFjdGl2YXRlKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIHRoaXMgc2hvdWxkIHRha2UgY2FyZSBvZiBkZWFsbG9jYXRpbmcgdGhlIGhpbnQgbm8/XG5cdEhpbnRzLnByb3RvdHlwZS5yZW0gPSBmdW5jdGlvbiAoaGludCl7XG5cdFx0aWYgKGhpbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0aGludCA9IHRoaXMuX2FycmF5LmZpbHRlcihoaW50KTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChoaW50IGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChoaW50KSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMucmVtKGFyeVtpXSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGhpbnQ7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoKHR5cGVvZiBoaW50PT0nc3RyaW5nJ3x8aGludCBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbSh0aGlzLmdldChoaW50KSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5fYXJyYXkuaW5kZXhPZihoaW50KSA+PSAwKSB7XG5cdFx0XHRoaW50LmNsZWFudXAoKTtcblx0XHRcdHRoaXMuX2FycmF5LnNwbGljZSh0aGlzLl9hcnJheS5pbmRleE9mKGhpbnQpLDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGhpbnQ7XG5cdH07XG5cdFxuXHRIaW50cy5wcm90b3R5cGUucHJ1bmUgPSBmdW5jdGlvbiAoaGludCl7XG5cdFx0aWYgKHRoaXMuX3BydW5lLmluZGV4T2YoaGludCkgPCAwKSB7IHRoaXMuX3BydW5lLnB1c2goaGludCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhcnIgPSB0aGlzLl9hcnJheTtcblx0XHR0aGlzLl9hcnJheSA9IFtdO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChhcnIpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFyeVtpXS5kZWFjdGl2YXRlKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCl7XG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYuX2FycmF5Lm1hcChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoc2VsZi5fcHJ1bmUuaW5kZXhPZihpdGVtKSA+PSAwKSB7XG5cdFx0XHRcdGl0ZW0uZGVhY3RpdmF0ZSgpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5yZW0oaXRlbSk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdHNlbGYuX3BydW5lID0gW107XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRcblx0SGludHMucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChjYil7XG5cdFx0cmV0dXJuIHRoaXMuX2FycmF5LmZpbHRlcihjYik7XG5cdH07XG5cdFxuXHRIaW50cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciByZWYgPSBvLnJlZiA9IChcImhpbnRcIiArIChucisrKSk7XG5cdFx0aWYgKCEoKG8gaW5zdGFuY2VvZiBIaW50KSkpIHsgbyA9IEhpbnQuYnVpbGQobyx0aGlzLl92aWV3KSB9O1xuXHRcdHRoaXMuX21hcFtyZWZdID0gbztcblx0XHR0aGlzLl9hcnJheS5wdXNoKG8pO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRyZXR1cm4gSGludHM7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL2hpbnRzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuLi9yZWdpb24nKS5SZWdpb247XG5cdFxuXHRmdW5jdGlvbiBSb3dDb2wocm93LGNvbCxjYXJldCl7XG5cdFx0aWYocm93ID09PSB1bmRlZmluZWQpIHJvdyA9IDA7XG5cdFx0aWYoY29sID09PSB1bmRlZmluZWQpIGNvbCA9IDA7XG5cdFx0aWYoY2FyZXQgPT09IHVuZGVmaW5lZCkgY2FyZXQgPSBudWxsO1xuXHRcdHRoaXMuX3JvdyA9IHJvdztcblx0XHR0aGlzLl9jb2wgPSBjb2w7XG5cdFx0dGhpcy5fY2FyZXQgPSBjYXJldDtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnJvdyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm93OyB9XG5cdFJvd0NvbC5wcm90b3R5cGUuc2V0Um93ID0gZnVuY3Rpb24odil7IHRoaXMuX3JvdyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb2w7IH1cblx0Um93Q29sLnByb3RvdHlwZS5zZXRDb2wgPSBmdW5jdGlvbih2KXsgdGhpcy5fY29sID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0Um93Q29sLnByb3RvdHlwZS5jYXJldCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY2FyZXQ7IH1cblx0Um93Q29sLnByb3RvdHlwZS5zZXRDYXJldCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jYXJldCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY2FyZXQoKS52aWV3KCk7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX2NvbCA9IHRoaXMucmVhbENvbCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocm93LGNvbCl7XG5cdFx0dmFyIGFyeTtcblx0XHRpZiAocm93IGluc3RhbmNlb2YgUm93Q29sKSB7XG5cdFx0XHRjb2wgPSByb3cuY29sKCk7XG5cdFx0XHRyb3cgPSByb3cucm93KCk7XG5cdFx0XHRcblx0XHRcdC8vIHJldHVybiBzZXQocm93LnJvdyxyb3cuY29sKVxuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHJvdyBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0dmFyIGFyeSA9IGl0ZXIkKHV0aWwucm93Y29sKHRoaXMudmlldygpLl9idWZmZXIscm93LnN0YXJ0KCkpKTtyb3cgPSBhcnlbMF07Y29sID0gYXJ5WzFdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGxjID0gdGhpcy52aWV3KCkuX2J1ZmZlci5saW5lY291bnQoKTtcblx0XHRcblx0XHRpZiAocm93ID49IGxjKSB7XG5cdFx0XHRyb3cgPSBsYyAtIDE7XG5cdFx0XHRjb2wgPSAxMDAwO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fcm93ID0gcm93O1xuXHRcdHRoaXMuX2NvbCA9IGNvbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAob2Zmc2V0KXtcblx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdFxuXHRcdHZhciBjb2wgPSB0aGlzLnJlYWxDb2woKSArIG9mZnNldDtcblx0XHR2YXIgbGxlbiA9IHRoaXMubGluZWxlbigpO1xuXHRcdFxuXHRcdHZhciBsbG9jID0gdGhpcy5saW5lbG9jKCk7XG5cdFx0Ly8gZmluZCB0aGUgcmVhbCBvZmZzZXQgaW4gY2hhcmFjdGVycyAobm90IGNvbHVtbnMpXG5cdFx0XG5cdFx0XG5cdFx0Ly8gaWYgb2Zmc2V0IDwgMFxuXHRcdC8vIFx0IyBub3JtYWxpemU/XG5cdFx0Ly8gXHRAY29sID0gTWF0aC5taW4oQGNvbCxsbGVuKVxuXHRcdFxuXHRcdGlmIChjb2wgPCAwKSB7XG5cdFx0XHRpZiAodGhpcy5fcm93ID4gMCkge1xuXHRcdFx0XHR0aGlzLm1vdmVVcCgpO1xuXHRcdFx0XHR0aGlzLl9jb2wgPSB0aGlzLmxpbmVsZW4oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3JvdyA9IDA7XG5cdFx0XHRcdHRoaXMuX2NvbCA9IDA7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSBlbHNlIGlmIChjb2wgPiBsbGVuKSB7XG5cdFx0XHRpZiAodGhpcy5fcm93ID49ICh0aGlzLnZpZXcoKS5fYnVmZmVyLmxpbmVjb3VudCgpIC0gMSkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLm1vdmVEb3duKCk7XG5cdFx0XHR2YXIgcmVzdCA9IE1hdGgubWF4KDAsY29sIC0gbGxlbiAtIDEpO1xuXHRcdFx0dmFyIG1vdmVzID0gdXRpbC5jb2xzRm9yTGluZSh0aGlzLmxpbmVzdHIoKS5zdWJzdHIoMCxyZXN0KSk7XG5cdFx0XHR0aGlzLl9jb2wgPSBtb3Zlcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdGhpcyBzaG91bGQgd29ya1xuXHRcdHRoaXMuX2NvbCA9IHV0aWwuY29sc0ZvckxpbmUodGhpcy5saW5lc3RyKCkuc3Vic3RyKDAsbGxvYyArIG9mZnNldCkpO1xuXHRcdC8vIEBjb2wgKz0gb2Zmc2V0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLm1vdmVVcCA9IGZ1bmN0aW9uIChsZW4pe1xuXHRcdHRoaXMuX3JvdyA9IE1hdGgubWF4KDAsdGhpcy5fcm93IC0gMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24gKGxlbil7XG5cdFx0Y29uc29sZS5sb2coJ21vdmVEb3duJyk7XG5cdFx0dmFyIGxjID0gdGhpcy52aWV3KCkuX2J1ZmZlci5saW5lY291bnQoKTsgLy8gc3BsaXQoJ1xcbicpWzpsZW5ndGhdXG5cdFx0dGhpcy5fcm93ID0gdGhpcy5fcm93ICsgMTtcblx0XHRpZiAodGhpcy5fcm93ID49IGxjKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcycpO1xuXHRcdFx0dGhpcy5zZXRMb2ModGhpcy52aWV3KCkuX2J1ZmZlci5sZW4oKSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gbmV3IFJvd0NvbCh0aGlzLnJvdygpLHRoaXMuY29sKCksdGhpcy5jYXJldCgpKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubGluZWxlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB1dGlsLmNvbHNGb3JMaW5lKHRoaXMubGluZXN0cigpKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubGluZWxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB1dGlsLmNvbFRvTG9jKHRoaXMubGluZXN0cigpLHRoaXMucmVhbENvbCgpKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUucmVhbENvbCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciByYyA9IHV0aWwuY29sVG9WaWV3Q29sKHRoaXMubGluZXN0cigpLHRoaXMuX2NvbCk7XG5cdFx0cmV0dXJuIHJjO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5saW5lc3RyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmlldygpLmxpbmVzdHIodGhpcy5yb3coKSk7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnBlZWtiZWhpbmQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc3RyID0gdGhpcy5saW5lc3RyKCk7XG5cdFx0cmV0dXJuIHN0ci5zdWJzdHIoMCx1dGlsLmNvbFRvTG9jKHN0cix0aGlzLnJlYWxDb2woKSkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5wZWVrYWhlYWQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc3RyID0gdGhpcy5saW5lc3RyKCk7XG5cdFx0cmV0dXJuIHN0ci5zbGljZSh1dGlsLmNvbFRvTG9jKHN0cix0aGlzLnJlYWxDb2woKSkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5zZXRMb2MgPSBmdW5jdGlvbiAobG9jKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBhcnkgPSBpdGVyJCh1dGlsLnJvd2NvbCh0aGlzLnZpZXcoKS5fYnVmZmVyLGxvYykpO3ZhciByb3cgPSBhcnlbMF0sY29sID0gYXJ5WzFdO1xuXHRcdHRoaXMuc2V0KHJvdyxjb2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBzaG91bGQgY2FjaGUoISlcblx0XHR2YXIgbGluZXMgPSB0aGlzLnZpZXcoKS5fYnVmZmVyLmxpbmVzKCk7XG5cdFx0Ly8gdmFyIGxpbmVzID0gdmlldy5idWZmZXIuc3BsaXQoJ1xcbicpXG5cdFx0dmFyIGxvYyA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGxpbmVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbGluZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRsaW5lID0gYXJ5W2ldO1xuXHRcdFx0dmFyIGxuID0gbGluZS5sZW5ndGg7XG5cdFx0XHRpZiAoaSA8IHRoaXMuX3Jvdykge1xuXHRcdFx0XHRsb2MgKz0gbG4gKyAxOyAvLyBpbmNsdWRlIG5ld2xpbmVcblx0XHRcdH0gZWxzZSBpZiAoaSA9PSB0aGlzLl9yb3cpIHtcblx0XHRcdFx0dmFyIHZpZXdjb2wgPSB1dGlsLmNvbFRvVmlld0NvbChsaW5lLHRoaXMuX2NvbCk7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSB1dGlsLmNvbFRvTG9jKGxpbmUsdmlld2NvbCk7XG5cdFx0XHRcdGxvYyArPSBNYXRoLm1pbihsbixvZmZzZXQpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiBsb2M7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnRhYiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHdyb25nIC0gbmVlZCB0byByb3VuZCBpbnN0ZWFkP1xuXHRcdFxuXHRcdHZhciBsZnQgPSB0aGlzLmNvbCgpICUgNDtcblx0XHR0aGlzLnNldENvbCh0aGlzLmNvbCgpICsgKDQgLSBsZnQpKTsgLy8gTWF0aC5mbG9vcihjb2wgLyA0KSAqIDQgKyA0XG5cdFx0Y29uc29sZS5sb2coJ21hcmtlciB0YWInLGxmdCx0aGlzLmNvbCgpLHRoaXMucmVhbENvbCgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUudW50YWIgPSBmdW5jdGlvbiAoKXtcblx0XHRjb25zb2xlLmxvZygndW50YWInLHRoaXMuY29sKCkpO1xuXHRcdHZhciByZXN0ID0gNCAtIHRoaXMuY29sKCkgJSA0O1xuXHRcdHRoaXMuc2V0Q29sKE1hdGguY2VpbCh0aGlzLmNvbCgpIC8gNCkgKiA0IC0gNCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLmFsdGVyID0gZnVuY3Rpb24gKG1vZGUsZGlyKXtcblx0XHR2YXIgJDEsICQyLCAkMywgJDQsICQ1LCAkNjtcblx0XHR2YXIgbm9kZXMgPSB0aGlzLmNhcmV0KCkudmlldygpLm5vZGVzSW5SZWdpb24odGhpcy5sb2MoKSxmYWxzZSk7XG5cdFx0dmFyIG5vZGUgPSBub2Rlc1swXTtcblx0XHR2YXIgbWlkID0gbm9kZSAmJiBub2RlLm5vZGU7XG5cdFx0dmFyIGxmdCA9IG5vZGVzLnByZXYgJiYgbm9kZXMucHJldi5ub2RlO1xuXHRcdHZhciByZ3QgPSBub2Rlcy5uZXh0ICYmIG5vZGVzLm5leHQubm9kZTtcblx0XHR2YXIgcGFydDtcblx0XHRcblx0XHQvLyBsb2cgJ21vdmUnLG9mZnNldCxtb2RlLG5vZGVzXG5cdFx0aWYgKG1vZGUgPT0gSU0uV09SRF9TVEFSVCkge1xuXHRcdFx0dmFyIGVsID0gbWlkIHx8IGxmdDtcblx0XHRcdGlmICgoJDEgPSBsZnQpICYmICQxLm1hdGNoZXMgICYmICAkMS5tYXRjaGVzKHEkKCcuX2ltY2xvc2UnLHRoaXMpKSkge1xuXHRcdFx0XHR0aGlzLnNldExvYyhsZnQucGFyZW50KCkucmVnaW9uKCkuc3RhcnQoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKCgkMiA9IGxmdCkgJiYgJDIubWF0Y2hlcyAgJiYgICQyLm1hdGNoZXMocSQoJy5faW1zdHInLHRoaXMpKSkge1xuXHRcdFx0XHR0aGlzLnNldExvYyhsZnQucmVnaW9uKCkuc3RhcnQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbG9jID0gdGhpcy5sb2MoKTtcblx0XHRcdFx0Ly8gbGV0IGJ1ZiA9IHZpZXcuYnVmZmVyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdwZWVrYmVoaW5kJyxwZWVrYmVoaW5kLGxvYyxzdHJcblx0XHRcdFx0dmFyIHN0ciA9IHRoaXMucGVla2JlaGluZCgpLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG5cdFx0XHRcdGxvYyAtPSBzdHIubWF0Y2goL14oW1xcc1xcdFxcLl0qLis/fCkoXFxifCQpLylbMV0ubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnNldExvYyhsb2MpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKG1vZGUgPT0gSU0uV09SRF9FTkQpIHtcblx0XHRcdGVsID0gbWlkIHx8IHJndDtcblx0XHRcdGlmICgoJDMgPSByZ3QpICYmICQzLm1hdGNoZXMgICYmICAkMy5tYXRjaGVzKHEkKCcuX2ltb3BlbicsdGhpcykpKSB7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKHJndC5wYXJlbnQoKS5yZWdpb24oKS5lbmQoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKCgkNCA9IHJndCkgJiYgJDQubWF0Y2hlcyAgJiYgICQ0Lm1hdGNoZXMocSQoJy5faW1zdHInLHRoaXMpKSkge1xuXHRcdFx0XHR0aGlzLnNldExvYyhyZ3QucmVnaW9uKCkuZW5kKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGxvYzEgPSB0aGlzLmxvYygpO1xuXHRcdFx0XHQvLyBsZXQgYnVmID0gdmlldy5idWZmZXJcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncGVla2FoZWFkJyxwZWVrYWhlYWQsbG9jXG5cdFx0XHRcdGxvYzEgKz0gdGhpcy5wZWVrYWhlYWQoKS5tYXRjaCgvXihbXFxzXFwuXSouKz98KShcXGJ8JCkvKVsxXS5sZW5ndGg7XG5cdFx0XHRcdC8vIGxvYysrIHVudGlsIGJ1Zltsb2NdLm1hdGNoKC9bXFxuXFxdLylcblx0XHRcdFx0dGhpcy5zZXRMb2MobG9jMSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobW9kZSA9PSBJTS5MSU5FX0VORCkge1xuXHRcdFx0dGhpcy5zZXQodGhpcy5yb3coKSwxMDAwKTtcblx0XHR9IGVsc2UgaWYgKG1vZGUgPT0gSU0uTElORV9TVEFSVCkge1xuXHRcdFx0Ly8gRklYTUUgdGFicy1mb3Itc3BhY2VzXG5cdFx0XHR2YXIgdGFicyA9IHRoaXMubGluZXN0cigpLm1hdGNoKC9eXFx0Ki8pWzBdLmxlbmd0aDtcblx0XHRcdHZhciBuZXdjb2wgPSB0YWJzICogdGhpcy52aWV3KCkudGFiU2l6ZSgpO1xuXHRcdFx0dGhpcy5zZXRDb2wodGhpcy5jb2woKSA+IG5ld2NvbCA/IChuZXdjb2wpIDogKDApKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGRpciA8IDAgJiYgKCQ1ID0gbGZ0KSAmJiAkNS5tYXRjaGVzICAmJiAgJDUubWF0Y2hlcygnLl9pbXRhYicpKSB7XG5cdFx0XHRcdC8vIGhlYWQuY29sID0gaGVhZC5jb2wgLSA0XG5cdFx0XHRcdC8vIGNhcmV0LnZpZXcubG9nICdyaWdodCBpcyB0YWInLGxmdC5yZWdpb25cblx0XHRcdFx0dGhpcy5zZXRMb2MobGZ0LnJlZ2lvbigpLnN0YXJ0KCkpO1xuXHRcdFx0XHQvLyBoZWFkLnVudGFiXG5cdFx0XHR9IGVsc2UgaWYgKGRpciA+IDAgJiYgKCQ2ID0gcmd0KSAmJiAkNi5tYXRjaGVzICAmJiAgJDYubWF0Y2hlcygnLl9pbXRhYicpKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyB1c2UgdGFiIGluc3RlYWRcblx0XHRcdFx0dGhpcy50YWIoKTtcblx0XHRcdFx0Ly8gaGVhZC5jb2wgPSBoZWFkLmNvbCArIDRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIC4uLlxuXHRcdFx0XHR0aGlzLm1vdmUoZGlyKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWNhcmV0aGVhZCcpO1xuXHRcblx0Ly8gc2hvdWxkIG1vdmUgaW50byBNYXJrZXIgKGxpa2UgQXRvbSlcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWNhcmV0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlZ2lvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVnaW9uOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZWdpb24gPSBmdW5jdGlvbih2KXsgdGhpcy5fcmVnaW9uID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxpbmVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9saW5lczsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TGluZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fbGluZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJhbmdlcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmFuZ2VzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSYW5nZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fcmFuZ2VzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX21vZGUgPSB7d2F0Y2g6ICdtb2RlRGlkU2V0JyxuYW1lOiAnbW9kZSd9O1xuXHRcdHRhZy5wcm90b3R5cGUubW9kZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbW9kZTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLm1vZGUoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9tb2RlID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMubW9kZURpZFNldCAmJiB0aGlzLm1vZGVEaWRTZXQodixhLHRoaXMuX19tb2RlKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19jb2wgPSB7J2RlZmF1bHQnOiAwLHdhdGNoOiAnZGlydHknLG5hbWU6ICdjb2wnfTtcblx0XHR0YWcucHJvdG90eXBlLmNvbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY29sOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb2wgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5jb2woKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9jb2wgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5kaXJ0eSAmJiB0aGlzLmRpcnR5KHYsYSx0aGlzLl9fY29sKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGFnLnByb3RvdHlwZS5fY29sID0gMDsgLy8gdGhlIHJlYWwgY29sdW1uIG9mIHRoZSBjYXJldFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19yb3cgPSB7J2RlZmF1bHQnOiAwLHdhdGNoOiAnZGlydHknLG5hbWU6ICdyb3cnfTtcblx0XHR0YWcucHJvdG90eXBlLnJvdyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm93OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSb3cgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5yb3coKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9yb3cgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5kaXJ0eSAmJiB0aGlzLmRpcnR5KHYsYSx0aGlzLl9fcm93KSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGFnLnByb3RvdHlwZS5fcm93ID0gMDtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlucHV0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9pbnB1dDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbih2KXsgdGhpcy5faW5wdXQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRhaWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RhaWw7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFRhaWwgPSBmdW5jdGlvbih2KXsgdGhpcy5fdGFpbCA9IHY7IHJldHVybiB0aGlzOyB9OyAvLyByb3djb2xcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2hlYWQ7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhlYWQgPSBmdW5jdGlvbih2KXsgdGhpcy5faGVhZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGFzaDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGFzaCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oYXNoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAobGZ0LHJndCl7XG5cdFx0XHR2YXIgYXJ5O1xuXHRcdFx0aWYobGZ0ID09PSB1bmRlZmluZWQpIGxmdCA9IDA7XG5cdFx0XHRpZihyZ3QgPT09IHVuZGVmaW5lZCkgcmd0ID0gMDtcblx0XHRcdHRoaXMubG9nKCdpbWNhcmV0IGV4cGFuZCcsbGZ0LHJndCk7XG5cdFx0XHR0aGlzLmRlY29sbGFwc2UoKTtcblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLmVuZHMoKSk7dmFyIGEgPSBhcnlbMF0sYiA9IGFyeVsxXTtcblx0XHRcdGEubW92ZShsZnQpO1xuXHRcdFx0Yi5tb3ZlKHJndCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuXHRcdFx0XHRyZXR1cm4gW3RoaXMuaGVhZCgpLnJvdygpLHRoaXMuaGVhZCgpLmNvbCgpXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBbdGhpcy5oZWFkKCkucm93KCksdGhpcy5oZWFkKCkuY29sKCksdGhpcy50YWlsKCkucm93KCksdGhpcy50YWlsKCkuY29sKCldO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gJ1snICsgdGhpcy50b0FycmF5KCkuam9pbignLCcpICsgJ10nO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmICh2YWwgaW5zdGFuY2VvZiBJTS5UeXBlcy5Ub2spIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KHZhbC5yZWdpb24oKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsIGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHRcdHJldHVybiAodGhpcy5zZXRSZWdpb24odmFsKSx2YWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdHRoaXMuaGVhZCgpLnNldFJvdyh2YWxbMF0pO1xuXHRcdFx0XHR0aGlzLmhlYWQoKS5zZXRDb2wodmFsWzFdKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh2YWwubGVuZ3RoID09IDQpIHtcblx0XHRcdFx0XHR0aGlzLmRlY29sbGFwc2UoKTtcblx0XHRcdFx0XHR0aGlzLnRhaWwoKS5zZXRSb3codmFsWzJdKTtcblx0XHRcdFx0XHR0aGlzLnRhaWwoKS5zZXRDb2wodmFsWzNdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNldFRhaWwodGhpcy5oZWFkKCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5leHBhbmRUb0xpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgYXJ5O1xuXHRcdFx0dGhpcy5zZWxlY3RhYmxlKCk7XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5lbmRzKCkpO3ZhciBhID0gYXJ5WzBdLGIgPSBhcnlbMV07XG5cdFx0XHRhLnNldENvbCgwKTtcblx0XHRcdGIuc2V0Q29sKDEwMDApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlydHkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmRlY29sbGFwc2UoKTtcblx0XHRcdHRoaXMudGFpbCgpLnNldExvYygwKTtcblx0XHRcdHRoaXMuaGVhZCgpLnNldExvYyh0aGlzLnZpZXcoKS5fYnVmZmVyLmxlbigpKTsgLy8gOmxlbmd0aFxuXHRcdFx0dGhpcy5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNlbGVjdGFibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlY29sbGFwc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB2Xztcblx0XHRcdGlmICh0aGlzLnRhaWwoKSA9PSB0aGlzLmhlYWQoKSkgeyAodGhpcy5zZXRUYWlsKHZfID0gdGhpcy5oZWFkKCkuY2xvbmUoKSksdl8pIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29sbGFwc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuc2V0VGFpbCh0aGlzLmhlYWQoKSk7XG5cdFx0XHR0aGlzLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29sbGFwc2VUb1N0YXJ0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5pc1JldmVyc2VkKCkpIHtcblx0XHRcdFx0dGhpcy5zZXRUYWlsKHRoaXMuaGVhZCgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0SGVhZCh0aGlzLnRhaWwoKSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9yaWVudGF0aW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1JldmVyc2VkKCkgPyAoJ3JldmVyc2VkJykgOiAoJ25vcm1hbCcpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0NvbGxhcHNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudGFpbCgpID09IHRoaXMuaGVhZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc1JldmVyc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5oZWFkKCkucm93KCkgPCB0aGlzLnRhaWwoKS5yb3coKSB8fCAodGhpcy50YWlsKCkucm93KCkgPT0gdGhpcy5oZWFkKCkucm93KCkgJiYgdGhpcy5oZWFkKCkuY29sKCkgPCB0aGlzLnRhaWwoKS5jb2woKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHN0ciA9IHRoaXMuaGVhZCgpLmxpbmVzdHIoKTtcblx0XHRcdHZhciBpbmQgPSBzdHIubWF0Y2goL14oXFx0KikvKVswXTtcblx0XHRcdHJldHVybiBpbmQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBlZWtiZWhpbmQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdHZhciBzdHIgPSB0aGlzLmVuZHMoKVswXS5wZWVrYmVoaW5kKCk7XG5cdFx0XHRpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7IHJldHVybiBzdHIubWF0Y2godmFsKSB9O1xuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChvZmZzZXQsbW9kZSl7XG5cdFx0XHRpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkgb2Zmc2V0ID0gMTtcblx0XHRcdGlmKG1vZGUgPT09IHVuZGVmaW5lZCkgbW9kZSA9IDA7XG5cdFx0XHR0aGlzLmhlYWQoKS5hbHRlcihtb2RlLG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gd2hhdCBpZiB3ZSBcblx0XHR0YWcucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24gKGxlbil7XG5cdFx0XHRpZihsZW4gPT09IHVuZGVmaW5lZCkgbGVuID0gMTtcblx0XHRcdHRoaXMuaGVhZCgpLm1vdmVEb3duKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tb3ZlVXAgPSBmdW5jdGlvbiAobGVuKXtcblx0XHRcdGlmKGxlbiA9PT0gdW5kZWZpbmVkKSBsZW4gPSAxO1xuXHRcdFx0dGhpcy5oZWFkKCkubW92ZVVwKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lbmRzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1JldmVyc2VkKCkgPyAoW3RoaXMuaGVhZCgpLHRoaXMudGFpbCgpXSkgOiAoW3RoaXMudGFpbCgpLHRoaXMuaGVhZCgpXSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnJlZ2lvbigpLnRleHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBnZXQgdGhlIGFjdHVhbCByZWdpb24gYmFzZWQgb24gaGVhZCBhbmQgdGFpbFxuXHRcdFx0Ly8gZ2V0dGluZyB0aGUgY29kZSBtaWdodCBiZSBleHBlbnNpdmUgaWYgZG9uZVxuXHRcdFx0Ly8gdG9vIG1hbnkgdGltZXMgLS0gYnV0IGVhc3kgdG8gY2FjaGVcblx0XHRcdC8vIHNlbmQgdGhpcyB0byB1dGlsIGluc3RlYWRcblx0XHRcdHZhciBhcnk7XG5cdFx0XHR2YXIgY29kZSA9IHRoaXMudmlldygpLmNvZGUoKTtcblx0XHRcdHZhciBsaW5lcyA9IGNvZGUuc3BsaXQoJ1xcbicpO1xuXHRcdFx0dmFyIGFyeSA9IGl0ZXIkKHRoaXMuZW5kcygpKTt2YXIgYSA9IGFyeVswXSxiID0gYXJ5WzFdO1xuXHRcdFx0XG5cdFx0XHR2YXIgc3RhcnQgPSAwO1xuXHRcdFx0dmFyIGVuZCA9IDA7XG5cdFx0XHR2YXIgbG4gPSAwO1xuXHRcdFx0XG5cdFx0XHR2YXIgYXIgPSBhLnJvdygpLGFjID0gYS5jb2woKSxiciA9IGIucm93KCksYmMgPSBiLmNvbCgpO1xuXHRcdFx0dmFyIGNoYXIkO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaXRlbXMgPSBpdGVyJChsaW5lcyksIGxlbiA9IGl0ZW1zLmxlbmd0aCwgbGluZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGxpbmUgPSBpdGVtc1tpXTtcblx0XHRcdFx0bG4gPSBsaW5lLmxlbmd0aDtcblx0XHRcdFx0aWYgKGkgPCBhcikge1xuXHRcdFx0XHRcdHN0YXJ0ICs9IGxuICsgMTsgLy8gaW5jbHVkZSBuZXdsaW5lXG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA9PSBhcikge1xuXHRcdFx0XHRcdHZhciBvZmZzZXQgPSB1dGlsLmNvbFRvTG9jKGxpbmUsYWMpO1xuXHRcdFx0XHRcdHN0YXJ0ICs9IE1hdGgubWluKGxuLG9mZnNldCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaSA8IGJyKSB7XG5cdFx0XHRcdFx0ZW5kICs9IGxuICsgMTsgLy8gaW5jbHVkZSBuZXdsaW5lXG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA9PSBicikge1xuXHRcdFx0XHRcdG9mZnNldCA9IHV0aWwuY29sVG9Mb2MobGluZSxiYyk7XG5cdFx0XHRcdFx0ZW5kICs9IE1hdGgubWluKGxuLG9mZnNldCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2lvbihzdGFydCxlbmQsdGhpcy52aWV3KCkucm9vdCgpLHRoaXMudmlldygpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmVnaW9uID0gZnVuY3Rpb24gKHJlZyl7XG5cdFx0XHR2YXIgYnVmID0gdGhpcy52aWV3KCkuY29kZSgpO1xuXHRcdFx0dmFyIGEgPSB1dGlsLnJvd2NvbChidWYscmVnLmEoKSk7XG5cdFx0XHR2YXIgYiA9IHV0aWwucm93Y29sKGJ1ZixyZWcuYigpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zZXRIZWFkKG5ldyBSb3dDb2woYlswXSxiWzFdLHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlZy5zaXplKCkgPT0gMCkge1xuXHRcdFx0XHR0aGlzLnNldFRhaWwodGhpcy5oZWFkKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRUYWlsKG5ldyBSb3dDb2woYVswXSxhWzFdLHRoaXMpKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uIChyZWcpe1xuXHRcdFx0aWYocmVnID09PSB1bmRlZmluZWQpIHJlZyA9IHRoaXMucmVnaW9uKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkubm9kZXNJblJlZ2lvbihyZWcsdGhpcy5pc0NvbGxhcHNlZCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCByYXRoZXIgbW92ZSB0aGlzIHRvIHJlZ2lvbiBpdHNlbGZcblx0XHR0YWcucHJvdG90eXBlLnRhcmdldCA9IGZ1bmN0aW9uIChyZWcpe1xuXHRcdFx0aWYocmVnID09PSB1bmRlZmluZWQpIHJlZyA9IHRoaXMucmVnaW9uKCk7XG5cdFx0XHR2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKHJlZyk7XG5cdFx0XHRpZiAobm9kZXMubGVuZ3RoID4gMikge1xuXHRcdFx0XHRyZXR1cm4gdXRpbC5jb21tb25BbmNlc3Rvcihub2Rlcy5tYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbi5ub2RlOyB9KSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIG5vZGVzWzBdLm5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh0ZXh0LGVkaXQpe1xuXHRcdFx0XG5cdFx0XHR2YXIgc3ViID0gJyc7XG5cdFx0XHR0aGlzLnZpZXcoKS5oaXN0b3J5KCkubWFyaygnYWN0aW9uJyk7XG5cdFx0XHRcblx0XHRcdGlmICghKHRoaXMuaXNDb2xsYXBzZWQoKSkpIHtcblx0XHRcdFx0dmFyIHJlZyA9IHRoaXMucmVnaW9uKCk7XG5cdFx0XHRcdHN1YiA9IHJlZy50ZXh0KCk7XG5cdFx0XHRcdHRoaXMudmlldygpLmVyYXNlKHJlZyk7XG5cdFx0XHRcdHRoaXMuY29sbGFwc2VUb1N0YXJ0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbW92ZSA9IDA7XG5cdFx0XHR2YXIgc2VsO1xuXHRcdFx0XG5cdFx0XHQvLyBuZWVkIGEgZGlmZmVyZW50IHN5bnRheCBmb3IgJDAgLS0gY2FuIGJlIGluIHJlZ3VsYXIgcGFzdGVkIGNvZGVcblx0XHRcdC8vIHNob3VsZCBoYXZlIGEgc2VwYXJhdGUgY29tbWFuZCBmb3IgaW5zZXJ0U25pcHBldCBwcm9iYWJseS5cblx0XHRcdGlmICh0ZXh0LmluZGV4T2YoJyQwJykgPj0gMCkge1xuXHRcdFx0XHRzZWwgPSB0aGlzLnJlZ2lvbigpLmNsb25lKDAsc3ViLmxlbmd0aCkubW92ZSh0ZXh0LmluZGV4T2YoJyQwJykpO1xuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCckMCcsc3ViKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGVkaXQgfHwgKGVkaXQgPSB7c2l6ZTogdGV4dC5sZW5ndGh9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5oZWFkKCkubm9ybWFsaXplKCk7XG5cdFx0XHR2YXIgcmVzID0gdGhpcy52aWV3KCkuaW5zZXJ0KHRoaXMucmVnaW9uKCkuc3RhcnQoKSx0ZXh0LGVkaXQpO1xuXHRcdFx0dGhpcy52aWV3KCkubG9nKCdpbnNlcnRlZCAtLSBub3cgbW92ZScsZWRpdC5zaXplKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlbCkge1xuXHRcdFx0XHR0aGlzLnNldFJlZ2lvbihzZWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbW92ZSBsb2NhdGlvbnNcblx0XHRcdFx0dGhpcy5oZWFkKCkuc2V0TG9jKHRoaXMuaGVhZCgpLmxvYygpICsgZWRpdC5zaXplKTtcblx0XHRcdFx0Ly8gaGVhZC5tb3ZlKGVkaXQ6c2l6ZSlcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuZGlydHkoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24gKG1vZGUpe1xuXHRcdFx0dGhpcy52aWV3KCkuaGlzdG9yeSgpLm1hcmsoJ2FjdGlvbicpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdpc0NvbGxhcHNlZCcsbW9kZSk7XG5cdFx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0XHR0aGlzLmhlYWQoKS5hbHRlcihtb2RlLC0xKTsgLy8gXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBkaXJ0eVxuXHRcdFx0XHQvLyByZXR1cm4gZXJhc2UgIyBjYWxsIGFnYWluIG5vd1xuXHRcdFx0fTtcblx0XHRcdGNvbnNvbGUubG9nKCdlcmFzaW5nIHJlZ2lvbicsdGhpcy5yZWdpb24oKSk7XG5cdFx0XHR0aGlzLnZpZXcoKS5lcmFzZSh0aGlzLnJlZ2lvbigpKTtcblx0XHRcdC8vIGxvZyAnbm93IGNvbGxhcHNlIHJlZ2lvbiB0byBzdGFydCcscmVnaW9uXG5cdFx0XHR0aGlzLmNvbGxhcHNlVG9TdGFydCgpO1xuXHRcdFx0Ly8gbG9nIHJlZ2lvblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCh0aGlzLnJlZygpKTtcblx0XHRcdHRoaXMuc2V0UmVnaW9uKHRoaXMucmVnKCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuZWRpdChcblx0XHRcdFx0e3RleHQ6ICcnLFxuXHRcdFx0XHR0YXJnZXQ6IHRhcmdldCxcblx0XHRcdFx0cmVnaW9uOiB0aGlzLnJlZygpLFxuXHRcdFx0XHRjYXJldDogdGhpcy5yZWcoKS5jbG9uZSgpLmNvbGxhcHNlKGZhbHNlKX1cblx0XHRcdCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgJDEsICQyO1xuXHRcdFx0dGhpcy5fdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblx0XHRcdC8vIHZhciBoYXNoID0gdG9BcnJheS5qb2luKFwiXCIpXG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9oYXNoICE9IHRoaXMudG9IYXNoKCkpIHtcblx0XHRcdFx0Ly8gdGhlIHJlYWxDb2wgdmFsdWVzIGNvdWxkIGhhdmUgY2hhbmdlZCB0aG91Z2g/XG5cdFx0XHRcdHRoaXMudmlldygpLmhpc3RvcnkoKS5vbmNhcmV0KHRoaXMuX2hhc2gsdGhpcy50b0hhc2goKSx0aGlzKTtcblx0XHRcdFx0dGhpcy5faGFzaCA9IHRoaXMudG9IYXNoKCk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdjYXJldCBoYXMgYWN0dWFsbHkgY2hhbmdlZCcsQGhhc2hcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciByZXYgPSB0aGlzLmlzUmV2ZXJzZWQoKTtcblx0XHRcdHZhciBhID0gdGhpcy50YWlsKCk7XG5cdFx0XHR2YXIgYiA9IHRoaXMuaGVhZCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAocmV2KSB7ICQxID0gYiwkMiA9IGEsYSA9ICQxLGIgPSAkMiB9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbGMgPSBiLnJvdygpIC0gYS5yb3coKTtcblx0XHRcdHZhciByb3cgPSBhLnJvdygpO1xuXHRcdFx0XG5cdFx0XHR2YXIgYWMgPSBhLnJlYWxDb2woKTsgLy8gTWF0aC5taW4oIGEuY29sLCB1dGlsLmNvbHNGb3JMaW5lKHZpZXcubGluZXN0cihhLnJvdykgKSApXG5cdFx0XHR2YXIgYmMgPSBiLnJlYWxDb2woKTsgLy8gTWF0aC5taW4oIGIuY29sLCB1dGlsLmNvbHNGb3JMaW5lKHZpZXcubGluZXN0cihiLnJvdykgKSApXG5cdFx0XHR2YXIgaGMsdGM7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzUmV2ZXJzZWQoKSkge1xuXHRcdFx0XHRoYyA9IGFjO1xuXHRcdFx0XHR0YyA9IGJjO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGMgPSBiYztcblx0XHRcdFx0dGMgPSBhYztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGxvZyAnZGlydHknLHJlZ2lvbixhLnJvdyxhLmNvbCxiLnJvdyxiLmNvbCxoYyx0YyxoZWFkLHRhaWwscmV2XG5cdFx0XHRcblx0XHRcdHRoaXMuY3NzKHt0cmFuc2Zvcm06IChcInRyYW5zbGF0ZSgwcHgsXCIgKyAoYS5yb3coKSAqIDEwMCkgKyBcIiUpXCIpfSk7XG5cdFx0XHQvLyBjb252ZXJ0IHRoZSByb3cgYW5kIGNvbHVtbiB0byBhIHJlZ2lvbiAoc2hvdWxkIGdvIGJvdGggd2F5cylcblx0XHRcdHRoaXMuX2NhcmV0LmNzcyh7dHJhbnNmb3JtOiAoXCJ0cmFuc2xhdGUoXCIgKyBoYyArIFwiY2gsXCIgKyAoKHRoaXMuaGVhZCgpLnJvdygpIC0gcm93KSAqIDEwMCkgKyBcIiUpXCIpfSk7XG5cdFx0XHR0aGlzLl9zdGFydC5jc3Moe21hcmdpbkxlZnQ6IChcIlwiICsgYWMgKyBcImNoXCIpLHdpZHRoOiBcImF1dG9cIn0pO1xuXHRcdFx0dGhpcy5fZW5kLmNzcyh7d2lkdGg6IChcIlwiICsgYmMgKyBcImNoXCIpfSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcblx0XHRcdFx0dGhpcy5zZXRNb2RlKCdjb2xsYXBzZWQnKTtcblx0XHRcdH0gZWxzZSBpZiAobGMgPT0gMCkge1xuXHRcdFx0XHR0aGlzLnNldE1vZGUoJ3NpbmdsZScpO1xuXHRcdFx0XHR0aGlzLl9zdGFydC5jc3Moe3dpZHRoOiAoYmMgLSBhYykgKyBcImNoXCJ9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX21pZC5zZXRUZXh0KGxjID4gMSA/ICgoJ1xcbicpLnJlcGVhdChsYyAtIDEpKSA6ICgnJykpO1xuXHRcdFx0XHR0aGlzLnNldE1vZGUoJ211bHRpJyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGVsYXBzZWQgPSAobmV3IERhdGUoKSAtIHRoaXMuX3RpbWVzdGFtcCk7XG5cdFx0XHR2YXIgZmxpcCA9IE1hdGgucm91bmQoZWxhcHNlZCAvIDUwMCkgJSAyO1xuXHRcdFx0XG5cdFx0XHRpZiAoZmxpcCAhPSB0aGlzLl9mbGlwKSB7XG5cdFx0XHRcdHRoaXMuX2NhcmV0LmZsYWcoJ2JsaW5rJyxmbGlwKTtcblx0XHRcdFx0dGhpcy5fZmxpcCA9IGZsaXA7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB2XywgdDA7XG5cdFx0XHR0aGlzLnNldFRhaWwoKHRoaXMuc2V0SGVhZCh2XyA9IG5ldyBSb3dDb2woMCwwLHRoaXMpKSx2XykpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdC8vIDxpbWNhcHRvckBpbnB1dCB2YWx1ZT0neCc+XG5cdFx0XHRcdCh0aGlzLiRhID0gdGhpcy4kYSB8fCB0YWckLiRzcGFuKCkuZmxhZygnZGltJykpLnNldFRleHQoJ3gnKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMuX2NhcmV0ID0gdGhpcy5fY2FyZXQgfHwgdGFnJC4kaW1jYXJldGhlYWQoKS5zZXRSZWYoJ2NhcmV0Jyx0aGlzKSkuZW5kKCksXG5cdFx0XHRcdCh0MCA9IHRoaXMuX2xpbmVzPXRoaXMuX2xpbmVzIHx8IHRhZyQuJGRpdigpLnNldFJlZignbGluZXMnLHRoaXMpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodGhpcy5fc3RhcnQgPSB0aGlzLl9zdGFydCB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ3N0YXJ0Jyx0aGlzKSkuc2V0VGV4dChcIiBcIikuZW5kKCksXG5cdFx0XHRcdFx0KHRoaXMuX21pZCA9IHRoaXMuX21pZCB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ21pZCcsdGhpcykpLmVuZCgpLFxuXHRcdFx0XHRcdCh0aGlzLl9lbmQgPSB0aGlzLl9lbmQgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdlbmQnLHRoaXMpKS5zZXRUZXh0KFwiIFwiKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRdLDIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuaGVhZCgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1vZGVEaWRTZXQgPSBmdW5jdGlvbiAobmV3JCxvbGQpe1xuXHRcdFx0dGhpcy51bmZsYWcob2xkKTtcblx0XHRcdHJldHVybiB0aGlzLmZsYWcobmV3JCk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL2NhcmV0LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc2NyaW1ibGEtb3ZlcmxheScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QoKSksMykuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3NjcmltYmxhLW92ZXJsYXlzJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHR5cGUsZGF0YSl7XG5cdFx0XHRpZihkYXRhID09PSB1bmRlZmluZWQpIGRhdGEgPSB7fTtcblx0XHRcdGNvbnNvbGUubG9nKCdhZGQgb3ZlcmxheSEnKTtcblx0XHRcdHRoaXMuYXBwZW5kKHRhZyQuJHNjcmltYmxhX292ZXJsYXkoKS5zZXRWaWV3KHRoaXMudmlldygpKS5zZXRPYmplY3QoZGF0YSkuZW5kKCkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcG9zaXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvdmlld3Mvb3ZlcmxheXMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW1lZGl0b3InLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihcblx0XHRcdFx0KHRoaXMuX3ZpZXcgPSB0aGlzLl92aWV3IHx8IHRhZyQuJGltdmlldygpLnNldFJlZigndmlldycsdGhpcykpLmVuZCgpXG5cdFx0XHQsMikuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy52aWV3KCkuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5kZWFjdGl2YXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb2RlLG9wdHMpe1xuXHRcdFx0dGhpcy52aWV3KCkubG9hZChjb2RlLG9wdHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gSU0uRlM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY29tbWFuZCA9IGZ1bmN0aW9uIChlLGMpe1xuXHRcdFx0aWYgKHRoaXNbYy5jb21tYW5kXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHRoaXNbYy5jb21tYW5kXS5jYWxsKHRoaXMsYy5hcmdzIHx8IFtdKTtcblx0XHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uc2F2ZXNlc3Npb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdGNvbnNvbGUubG9nKFwiaW1lZGl0b3Iuc2F2ZVNlc3Npb25cIix0aGlzKTtcblx0XHRcdHZhciBwYXRoID0gdGhpcy52aWV3KCkuZmlsZW5hbWUoKS5yZXBsYWNlKC9cXC5pbWJhJC8sJy5pbWJhc2Vzc2lvbicpO1xuXHRcdFx0dmFyIGJvZHkgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnZpZXcoKS5oaXN0b3J5KCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gSU0uRlMuc2F2ZShwYXRoLGJvZHksZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBjb25zb2xlLmxvZygncmV0dXJuZWQgZnJvbSBzYXZpbmchJyxwYXRoKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvZWRpdG9yLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHQvKlxuXHRCcmlkZ2UgZm9yIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgSW1iYSBjb21waWxlciBpbiBhIHdvcmtlclxuXHQqL1xuXHRcblx0ZnVuY3Rpb24gSW1iYWNXb3JrZXIocGF0aCl7XG5cdFx0aWYocGF0aCA9PT0gdW5kZWZpbmVkKSBwYXRoID0gXCIvdmVuZG9yL2ltYmEvaW1iYWMud29ya2VyLm1pbi5qc1wiO1xuXHRcdHRoaXMuX3BhdGggPSBwYXRoO1xuXHRcdHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkltYmFjV29ya2VyID0gSW1iYWNXb3JrZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0SW1iYWNXb3JrZXIucHJvdG90eXBlLndvcmtlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcywgcHJvY2VzczE7XG5cdFx0cmV0dXJuIHNlbGYuX3dvcmtlciB8fCAoc2VsZi5fd29ya2VyID0gKHRydWUpICYmIChcblx0XHRcdHByb2Nlc3MxID0gbmV3IFdvcmtlcihzZWxmLl9wYXRoKSxcblx0XHRcdHByb2Nlc3MxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHNlbGYub25tZXNzYWdlKGUpOyB9LFxuXHRcdFx0cHJvY2VzczFcblx0XHQpKTtcblx0fTtcblx0XG5cdEltYmFjV29ya2VyLnByb3RvdHlwZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIGZuO1xuXHRcdGlmIChmbiA9IHRoaXMuX2NhbGxiYWNrcy5zaGlmdCgpKSB7XG5cdFx0XHRyZXR1cm4gZm4oZS5kYXRhLGUpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRJbWJhY1dvcmtlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChjb2RlLG8sY2Ipe1xuXHRcdHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNiKTtcblx0XHR0aGlzLndvcmtlcigpLnBvc3RNZXNzYWdlKFsnY29tcGlsZScsY29kZSxvXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhY1dvcmtlci5wcm90b3R5cGUuYW5hbHl6ZSA9IGZ1bmN0aW9uIChjb2RlLG8sY2Ipe1xuXHRcdHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNiKTtcblx0XHR0aGlzLndvcmtlcigpLnBvc3RNZXNzYWdlKFsnYW5hbHl6ZScsY29kZSxvXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBJbWJhY1dvcmtlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvd29ya2VyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5cdHJlcXVpcmUoXCIuL3Rva2VuXCIpO1xuXHRyZXF1aXJlKFwiLi9ibG9ja1wiKTtcblx0cmVxdWlyZShcIi4vcm9vdFwiKTtcblx0cmVxdWlyZShcIi4vbGl0ZXJhbHNcIik7XG5cdHJlcXVpcmUoXCIuL29wZXJhdG9yc1wiKTtcblx0cmVxdWlyZShcIi4vc2VsZWN0b3JcIik7XG5cdHJlcXVpcmUoXCIuL3doaXRlc3BhY2VcIik7XG5cdHJldHVybiByZXF1aXJlKFwiLi9hbm5vdGF0aW9uc1wiKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL2luZGV4LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBIaWdobGlnaHRlciA9IHJlcXVpcmUoJy4uL2NvcmUvaGlnaGxpZ2h0ZXInKS5IaWdobGlnaHRlcjtcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblx0XG5cdC8vIGRhbmdlcm91cyB0byBleHRlbmQgYWxsIGh0bWxlbGVtZW50IHRhZ3MgZ2xvYmFsbHlcblx0dGFnJC5leHRlbmRUYWcoJ2h0bWxlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIChuYW1lLGRhdGEpe1xuXHRcdFx0Ly8gbG9nIFwiYnViYmxlIGV2ZW50XCIsbmFtZSxkYXRhXG5cdFx0XHR2YXIgZXYgPSBJbWJhLkV2ZW50cy50cmlnZ2VyKG5hbWUsdGhpcyx7ZGF0YTogZGF0YSxidWJibGU6IHRydWV9KTtcblx0XHRcdHJldHVybiBldjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAobmFtZSx0aW1lLGJsayl7XG5cdFx0XHR0aGlzLl90aW1lb3V0cyB8fCAodGhpcy5fdGltZW91dHMgPSB7fSk7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dHNbbmFtZV0pO1xuXHRcdFx0aWYgKHRpbWUgIT0gLTEpIHsgdGhpcy5fdGltZW91dHNbbmFtZV0gPSBzZXRUaW1lb3V0KGJsayx0aW1lKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAoZWwpe1xuXHRcdFx0aWYgKGVsIGluc3RhbmNlb2YgSU1GcmFnbWVudCkge1xuXHRcdFx0XHRlbCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsLmRvbSgpLmNoaWxkTm9kZXMpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGVsLnJldmVyc2UoKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuc2V0TmV4dChhcnlbaV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBjdXJyID0gdGhpcy5kb20oKS5uZXh0U2libGluZztcblx0XHRcdGlmICgodHlwZW9mIGVsPT0nc3RyaW5nJ3x8ZWwgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGN1cnIpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQoKS5pbnNlcnRCZWZvcmUoZWwsY3Vycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBhcmVudCgpLmFwcGVuZENoaWxkKGVsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UHJldiA9IGZ1bmN0aW9uIChlbCl7XG5cdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBJTUZyYWdtZW50KSB7XG5cdFx0XHRcdGVsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuZG9tKCkuY2hpbGROb2Rlcyk7XG5cdFx0XHRcdC8vIGVsID0gW10uY29uY2F0KGVsLmRvbTpjaGlsZE5vZGVzKVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGVsKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRQcmV2KGFyeVtpXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGN1cnIgPSB0aGlzLmRvbSgpLnByZXZTaWJsaW5nO1xuXHRcdFx0aWYgKCh0eXBlb2YgZWw9PSdzdHJpbmcnfHxlbCBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0ZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlbCk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5wYXJlbnQoKS5pbnNlcnRCZWZvcmUoZWwsdGhpcyk7XG5cdFx0XHQvLyBwYXJlbnQuaW5zZXJ0KGVsLCBiZWZvcmU6IHNlbGYpXG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5leHROb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5uZXh0U2libGluZztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJldk5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnByZXZTaWJsaW5nO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0SU0uVHlwZXMgPSB7fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbScsICdiJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcua2V5ID0gZnVuY3Rpb24gKGtleSxoYW5kbGVyKXtcblx0XHRcdHRoaXMucHJvdG90eXBlWyhcImhhbmRsZVwiICsga2V5KV0gPSBoYW5kbGVyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcubmF0aXZlID0gZnVuY3Rpb24gKHR5cCl7XG5cdFx0XHR0aGlzLl9uYXRpdmVUeXBlID0gdHlwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcudHlwZSA9IGZ1bmN0aW9uICh0eXApe1xuXHRcdFx0SU0uVHlwZXNbdHlwXSA9IHRoaXM7XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwO1xuXHRcdFx0dGhpcy5wcm90b3R5cGUuX3R5cGUgPSB0eXA7XG5cdFx0XHQvLyBAZG9tRmxhZ3MucHVzaCh0eXApIGlmIEBkb21GbGFnc1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcudHlwZSgnVG9rJyk7XG5cdFx0XG5cdFx0dGFnLmFsaWFzID0gZnVuY3Rpb24gKHR5cCl7XG5cdFx0XHRJTS5UeXBlc1t0eXBdID0gdGhpcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnRyaWdnZXIgPSBmdW5jdGlvbiAobWF0Y2gsY21kKXtcblx0XHRcdGlmIChjbWQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRjbWQgPSB7Y29tbWFuZDogY21kfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNtZC50cmlnZ2VyID0gbWF0Y2g7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcm90b3R5cGVbKFwidHJpZ2dlci1cIiArIG1hdGNoKV0gPSBjbWQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldEhpbnQgPSBmdW5jdGlvbiAoaGludCl7XG5cdFx0XHRpZiAoaGludCAmJiBoaW50ICE9IHRoaXMuX2hpbnQpIHtcblx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ2hpbnQnLGhpbnQucmVmKCkpO1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShcImhpbnQtdHlwZVwiLGhpbnQudHlwZSgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKCdoaW50Jyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKCdoaW50LXR5cGUnKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcy5faGludCA9IGhpbnQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhpbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIHN0cmFuZ2Ugbm8/XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2hpbnQgfHwgdGhpcy52aWV3KCkuaGludHMoKS5nZXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hpbnQnKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBnbyBvdmVyIHRvIHVzaW5nIHRoaXMgXG5cdFx0dGFnLnByb3RvdHlwZS53YWxrVGV4dE5vZGVzID0gZnVuY3Rpb24gKG1hcmspe1xuXHRcdFx0aWYobWFyayA9PT0gdW5kZWZpbmVkKSBtYXJrID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNldFJvb3QodGhpcy5kb20oKSk7XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIHdhbGsgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHRoaXMucm9vdCgpLE5vZGVGaWx0ZXIuU0hPV19URVhULG51bGwsZmFsc2UpO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoZWwgPSB3YWxrLm5leHROb2RlKCkpe1xuXHRcdFx0XHRpZiAobWFyaykge1xuXHRcdFx0XHRcdHZhciBsZW4gPSBlbC5sZW5ndGg7XG5cdFx0XHRcdFx0ZWwuX2xvYyA9IHBvcztcblx0XHRcdFx0XHRwb3MgKz0gbGVuO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRub2Rlcy5wdXNoKGVsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBub2Rlcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudXRpbCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHV0aWw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLmNhcmV0KCkuc2V0KHRoaXMucmVnaW9uKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGxvZ2dlcl87XG5cdFx0XHQobG9nZ2VyXyA9IHRoaXMudmlldygpLmxvZ2dlcigpKS5sb2cuYXBwbHkobG9nZ2VyXyxhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5vdXRlckhUTUw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNwYWNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKHRoaXMuZG9tKCkubmV4dFNpYmxpbmcgaW5zdGFuY2VvZiBUZXh0KSB7XG5cdFx0XHRcdHJldHVybiAoL1tcXHQgXS8pLnRlc3QodGhpcy5kb20oKS5uZXh0U2libGluZy50ZXh0Q29udGVudFswXSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51bnNwYWNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICEodGhpcy5zcGFjZWQoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5leHRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGNvdWxkIGJlIHRleHQgYXMgd2VsbD9cblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLm5leHRTaWJsaW5nIGluc3RhbmNlb2YgVGV4dCA/IChudWxsKSA6ICh0aGlzLm5leHQoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnByZXZJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGNvdWxkIGJlIHRleHQgYXMgd2VsbD9cblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnByZXZpb3VzU2libGluZyBpbnN0YW5jZW9mIFRleHQgPyAobnVsbCkgOiAodGhpcy5wcmV2KCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS50ZXh0Q29udGVudDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHRoaXMuZG9tKCkudGV4dENvbnRlbnQgPSB0ZXh0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnRleHRDb250ZW50O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb2RlID0gZnVuY3Rpb24gKGNvZGUsc2lsZW50KXtcblx0XHRcdHZhciBoaW50Xztcblx0XHRcdGlmKHNpbGVudCA9PT0gdW5kZWZpbmVkKSBzaWxlbnQgPSBmYWxzZTtcblx0XHRcdHZhciBwcmV2ID0gdGhpcy5jb2RlKCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9kb20uZmlyc3RDaGlsZCA9PSB0aGlzLl9kb20ubGFzdENoaWxkICYmICh0aGlzLl9kb20uZmlyc3RDaGlsZCBpbnN0YW5jZW9mIFRleHQpKSB7XG5cdFx0XHRcdC8vIHN0aWxsIHNldCBpZiBpdCBoYXMgbm90IGNoYW5nZWQ/XG5cdFx0XHRcdHRoaXMuX2RvbS5maXJzdENoaWxkLnRleHRDb250ZW50ID0gY29kZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2RvbS50ZXh0Q29udGVudCA9IGNvZGU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY29kZSAhPSBwcmV2KSB7XG5cdFx0XHRcdChoaW50XyA9IHRoaXMuaGludCgpKSAmJiBoaW50Xy5jaGFuZ2VkICAmJiAgaGludF8uY2hhbmdlZCgpO1xuXHRcdFx0XHRpZiAoIXNpbGVudCkgeyB0aGlzLm9uY2hhbmdlZChjb2RlLHByZXYpIH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY2hhbmdlZCA9IGZ1bmN0aW9uIChjb2RlLHByZXYpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnZGlydHknKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpLmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHBhcmVudF87XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmlldyB8fCAoKHBhcmVudF8gPSB0aGlzLnBhcmVudCgpKSAmJiBwYXJlbnRfLnZpZXcgICYmICBwYXJlbnRfLnZpZXcoKSkgfHwgVklFVztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuY2FyZXQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkucmVnaW9uRm9yTm9kZSh0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWdpb24oKS5sb2MoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlY3JlYXNlSW5kZW50ID0gZnVuY3Rpb24gKHByZSxzdGF0ZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluY3JlYXNlSW5kZW50ID0gZnVuY3Rpb24gKHByZSxzdGF0ZSl7XG5cdFx0XHR2YXIgcmVnID0gL14oXFxzKiguKlxcPVxccyopPyhjbGFzc3xkZWZ8dGFnfHVubGVzc3xpZnxlbHNlfGVsaWZ8c3dpdGNofHRyeXxjYXRjaHxmaW5hbGx5fGZvcnx3aGlsZXx1bnRpbHxkbykpLztcblx0XHRcdHJldHVybiByZWcudGVzdChwcmUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lcmFzZSA9IGZ1bmN0aW9uIChyZWdpb24sbW9kZSl7XG5cdFx0XHRpZiAobW9kZSA9PSAnYWxsJykge1xuXHRcdFx0XHR0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRDb2RlKHV0aWwucGF0Y2hTdHJpbmcodGhpcy5jb2RlKCksJycscmVnaW9uKSk7IC8vIGNvZGUuaW5zKCcnLHJlZ2lvbilcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlZ2lvbixzdHIsZWRpdCxwYXJzKXtcblx0XHRcdGlmKCFwYXJzfHxwYXJzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHBhcnMgPSB7fTtcblx0XHRcdHZhciBtb2RlID0gcGFycy5tb2RlICE9PSB1bmRlZmluZWQgPyBwYXJzLm1vZGUgOiBudWxsO1xuXHRcdFx0dGhpcy5zZXRDb2RlKHV0aWwucGF0Y2hTdHJpbmcodGhpcy5jb2RlKCksc3RyLHJlZ2lvbikpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5zZXJ0ZWQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25jb21tYW5kID0gZnVuY3Rpb24gKGUsY21kKXtcblx0XHRcdHZhciBuYW1lID0gY21kLmNvbW1hbmQ7XG5cdFx0XHR2YXIgZm4gPSB0aGlzW25hbWVdO1xuXHRcdFx0dGhpcy5sb2coJ3J1biBvbmNvbW1hbmQnLG5hbWUsY21kKTtcblx0XHRcdFxuXHRcdFx0aWYgKGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGlzLGUsY21kKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZW50QmxvY2sgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW0uaW5kZW50QmxvY2snLGFyZ3VtZW50cyx0aGlzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0cmV0dXJuIElNLnRvayh2YWwpLmNsYXNzaWZ5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0ZpcnN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcGFyID0gdGhpcy5wYXJlbnQoKTtcblx0XHRcdHJldHVybiAocGFyIGluc3RhbmNlb2YgSU0uVHlwZXMuVG9rKSAmJiBwYXIuZG9tKCkuZmlyc3RDaGlsZCA9PSB0aGlzLmRvbSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0xhc3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBwYXIgPSB0aGlzLnBhcmVudCgpO1xuXHRcdFx0cmV0dXJuIChwYXIgaW5zdGFuY2VvZiBJTS5UeXBlcy5Ub2spICYmIHBhci5kb20oKS5sYXN0Q2hpbGQgPT0gdGhpcy5kb20oKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdGlmKGNvZGUgPT09IHVuZGVmaW5lZCkgY29kZSA9IHRoaXMudGV4dCgpO1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWRhdGUoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1hcmtJbnZhbGlkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmZsYWcoJ2ludmFsaWQnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tYXJrVmFsaWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMudW5mbGFnKCdpbnZhbGlkJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNJbnZhbGlkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYXNGbGFnKCdpbnZhbGlkJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsYXNzaWZ5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHVud3JhcCAvIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSBwYXJlbnRcblx0XHR0YWcucHJvdG90eXBlLnVud3JhcCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGVsID0gdGhpcy5kb20oKTtcblx0XHRcdHZhciBwYXIgPSBlbC5wYXJlbnROb2RlO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoZWwuZmlyc3RDaGlsZCl7XG5cdFx0XHRcdHBhci5pbnNlcnRCZWZvcmUoZWwuZmlyc3RDaGlsZCxlbCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG90aGVyKXtcblx0XHRcdHRoaXMuc2V0UHJldihvdGhlcik7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcnBoYW5pemUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QocSQoJy5faW5kZW50Jyx0aGlzKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAobXV0cyl7XG5cdFx0XHQvLyByZW1vdmUgbm9kZSBpZiBpdCBpcyBvcnBoYW5pemVkXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoc2VsZi5jb2RlKCkgPT0gJycpIHtcblx0XHRcdFx0c2VsZi5sb2coJ3JlbW92ZSB3aG9sZSBub2RlJyk7XG5cdFx0XHRcdC8vIHNob3VsZCBwb3NzaWJseVxuXHRcdFx0XHRyZXR1cm4gc2VsZi5vcnBoYW5pemUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYubG9nKCdtdXRhdGVkIC0tIHJlcGFyc2UnKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYudmlldygpLm9ic2VydmVyKCkucGF1c2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYudmlldygpLmhpZ2hsaWdodGVyKCkucmVwYXJzZShzZWxmLmRpcnR5RXh0ZW50KCkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlY2xhc3NpZnkgPSBmdW5jdGlvbiAodHlwZSl7XG5cdFx0XHQvLyByZWNsYXNzaWZ5IHNob3VsZCBoYXBwZW4gdGhyb3VnaCB0aGUgaGlnaGxpZ2h0ZXJcblx0XHRcdC8vIGxvZyAncmVjbGFzc2lmeSBub2RlIGFzIHR5cGUnLHR5cGVcblx0XHRcdHZhciBjbHMgPSBJTS5UeXBlc1t0eXBlXSB8fCBJbWJhLlRBR1NbKFwiaW1cIiArIHR5cGUpXTtcblx0XHRcdFxuXHRcdFx0aWYgKGNscykge1xuXHRcdFx0XHQvLyBsb2cgJ2ZvdW5kIGNsYXNzIHRvIHJlY2xhc3NpZnkgYXMnLGNscyxzZWxmOmNvbnN0cnVjdG9yXG5cdFx0XHRcdGlmIChjbHMgPT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gbG9nICdmb3VuZCBjbGFzcyB0byByZWNsYXNzaWZ5IGFzJyxjbHNcblx0XHRcdFx0dmFyIG5vZGUgPSBuZXcgY2xzKHRoaXMuZG9tKCkpLnNldHVwKCk7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhcnNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJhc2VDbGFzc2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgY2xzID0gdGhpcy5jb25zdHJ1Y3Rvci5kb20oKS5jbGFzc05hbWU7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSkgeyBjbHMgKz0gJyAnICsgdGhpcy5fdHlwZSB9O1xuXHRcdFx0cmV0dXJuIGNscztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc2VzKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmV1c2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNldHVwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNBdG9taWMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGZpbmQgdGhlIG5vZGVzIC8gcmVnaW9uIHRoYXQgc2hvdWxkIGJlIHJlcGFyc2VkIGlmIHRoaXMgZWxlbWVudCBoYXMgY2hhbmdlZFxuXHRcdC8vIHRoaXMgaXMgY3VycmVudGx5IHF1b3RlIFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlydHlFeHRlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIDNsb2cgXCJnZXQgZGlydHkgZXh0ZW50IGZvclwiLGRvbVxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBzZWwsIHNlbDEsIHNlbDIsICQxO1xuXHRcdFx0aWYgKHNlbCA9IHNlbGYudXAocSQoJy5zZWxlY3Rvcicsc2VsZikpKSB7XG5cdFx0XHRcdHJldHVybiBzZWwuZGlydHlFeHRlbnQoKTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsMSA9IHNlbGYudXAocSQoJy5faW10YWdub2RlJyxzZWxmKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbDEuZGlydHlFeHRlbnQoKTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsMiA9IHNlbGYudXAocSQoJy5faW1pc3RyaW5nJyxzZWxmKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbDIuZGlydHlFeHRlbnQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChzZWxmLmlzQXRvbWljKCkpIHsgLy8gaG1tXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bm9kZXM6IFtzZWxmLmRvbSgpXSxcblx0XHRcdFx0XHRjb2RlOiBzZWxmLmNvZGUoKSxcblx0XHRcdFx0XHRjb250YWluczogZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHNlbGYuZG9tKCkuY29udGFpbnMoZWwuX2RvbSB8fCBlbCk7IH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBzdGFydCA9IHNlbGYuZG9tKCk7XG5cdFx0XHR2YXIgZW5kID0gc2VsZi5kb20oKTtcblx0XHRcdFxuXHRcdFx0dmFyIHByZXYsbmV4dDtcblx0XHRcdHZhciBub2RlcyA9IFtzZWxmLmRvbSgpXTtcblx0XHRcdHZhciBvcGVuZXIsY2xvc2VyO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAocHJldiA9IHN0YXJ0LnByZXZpb3VzU2libGluZyl7XG5cdFx0XHRcdGlmIChwcmV2IGluc3RhbmNlb2YgVGV4dCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXYubWF0Y2hlcygnLl9pbW5ld2xpbmUsLl9pbXRhYicpKSB7IC8vICwuX2ltb3BlbiwuX2ltY2xvc2Vcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwcmV2Lm1hdGNoZXMoJy5faW1vcGVuJykpIHtcblx0XHRcdFx0XHRvcGVuZXIgPSBwcmV2O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0c3RhcnQgPSBwcmV2O1xuXHRcdFx0XHRub2Rlcy51bnNoaWZ0KHN0YXJ0KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHdoaWxlIChuZXh0ID0gZW5kLm5leHRTaWJsaW5nKXtcblx0XHRcdFx0aWYgKG5leHQgaW5zdGFuY2VvZiBUZXh0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV4dC5tYXRjaGVzKCcuX2ltbmV3bGluZScpKSB7IC8vIC5faW1vcGVuLC5faW1jbG9zZVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5leHQubWF0Y2hlcygnLl9pbWNsb3NlJykpIHtcblx0XHRcdFx0XHRjbG9zZXIgPSBuZXh0O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0ZW5kID0gbmV4dDtcblx0XHRcdFx0bm9kZXMucHVzaChlbmQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gc2VlIGlmIHdlIGluY2x1ZGUgYW4gb3BlbiBvciBjbG9zZS10YWdcblx0XHRcdFxuXHRcdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdFx0bm9kZXM6IG5vZGVzLFxuXHRcdFx0XHRjb2RlOiBcIlwiLFxuXHRcdFx0XHR0YXJnZXQ6IHNlbGYuZG9tKCksXG5cdFx0XHRcdG5lc3RlZDogW10sXG5cdFx0XHRcdGNvbnRhaW5zOiBmdW5jdGlvbihub2RlKSB7IHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2Yobm9kZSkgPj0gMDsgfVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG9wZW5lciB8fCBjbG9zZXIpIHtcblx0XHRcdFx0Ly8gbG9nIFwiaW5jbHVkZXMgb3BlbmVyIGFuZCAvIG9yIGNsb3NlclwiLG9wZW5lcixjbG9zZXJcblx0XHRcdFx0dmFyIHBhciA9IHRhZyR3cmFwKChvcGVuZXIgfHwgY2xvc2VyKS5wYXJlbnROb2RlKTtcblx0XHRcdFx0aWYgKCgkMSA9IHBhcikgJiYgJDEuaXNBdG9taWMgICYmICAkMS5pc0F0b21pYygpKSB7XG5cdFx0XHRcdFx0Ly8gbG9nICdyZXR1cm4gdGhlIHBhcmVudCBkaXJ0eSBleHRlbnQnLHBhclxuXHRcdFx0XHRcdHJldHVybiBwYXIuZGlydHlFeHRlbnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAodmFyIG5vZGVzID0gW10sIGkgPSAwLCBhcnkgPSBpdGVyJCgob3BlbmVyIHx8IGNsb3NlcikucGFyZW50Tm9kZS5jaGlsZHJlbiksIGxlbl8gPSBhcnkubGVuZ3RoOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaChhcnlbaV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGxvYyA9IDA7XG5cdFx0XHRcblx0XHRcdC8vIHNob3VsZCB1c2UgdGhlIHRhZ3MgZGlyZWN0bHlcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbl8gPSBhcnkubGVuZ3RoLCBub2RlOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdG5vZGUgPSBhcnlbaV07XG5cdFx0XHRcdHZhciByaWNoID0gdGFnJHdyYXAobm9kZSk7XG5cdFx0XHRcdHZhciB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudDtcblx0XHRcdFx0dmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGZhbHNlICYmIHJpY2ggJiYgKChyaWNoIGluc3RhbmNlb2YgSU0uVHlwZXMucGFpcikgfHwgcmljaC5pc0ludmFsaWQoKSkpIHtcblx0XHRcdFx0XHR0ZXh0ID0gXCInwqfCp8KnJ1wiO1xuXHRcdFx0XHRcdGxlbiA9IDU7XG5cdFx0XHRcdFx0c2VsZi5sb2coXCJhZGRlZCBub2RlIGFzIG5lc3RlZCByZWZlcmVuY2VcIixyaWNoLmRvbSgpKTtcblx0XHRcdFx0XHQvLyB0aGlzIGlzIGZ1Y2tlZCB1cFxuXHRcdFx0XHRcdC8vIHRoaXMgcmVhbGx5IGRvZXMgbWVzcyB1cCB0aGUgcmljaCBub2RlcyBoZXJlKD8hKVxuXHRcdFx0XHRcdHJlc3VsdC5uZXN0ZWQucHVzaChyaWNoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHJlc3VsdC5jb2RlICs9IHRleHQ7XG5cdFx0XHRcdGxvYyArPSBsZW47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXN1bHQubm9kZXMgPSBub2Rlcztcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFyc2VFeHRlbnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRpcnR5ID0gc2VsZi5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0XHRpZiAoZSkgeyBlLmhhbmRsZWQoKSB9O1xuXHRcdFx0XHRyZXR1cm4gSGlnaGxpZ2h0ZXIucmVwYXJzZShkaXJ0eSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHQvLyBwaWVjZSBvZiB1bnBhcnNlZCBjb2RlXG5cdHRhZyQuZGVmaW5lVGFnKCdpbXJhdycsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3JhdycpO1xuXHRcdHRhZy5hbGlhcygnQCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmF3ID0gZnVuY3Rpb24gKHJhdyl7XG5cdFx0XHR0aGlzLl9yYXcgPSByYXc7XG5cdFx0XHR0aGlzLl9kb20udGV4dENvbnRlbnQgPSByYXc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25lZGl0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy5zZXRDb2RlKGUucGF0Y2godGhpcykpO1xuXHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltZnJhZ21lbnQnLCAnaW1yYXcnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdmcmFnbWVudCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KXtcblx0XHRcdGlmICh0eXBlb2YgY29udGVudCA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YWcuX19zdXBlcl9fLnNldENvbnRlbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMudW53cmFwKCk7XG5cdFx0XHR0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRJTUZyYWdtZW50ID0gSW1iYS5UQUdTLmltZnJhZ21lbnQ7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1vcGVuJywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHQvLyBAbm9kZVR5cGUgPSAncydcblx0XHR0YWcudHlwZSgnb3BlbicpO1xuXHRcdFxuXHRcdHRhZy5hbGlhcygnWycpO1xuXHRcdHRhZy5hbGlhcygnKCcpO1xuXHRcdHRhZy5hbGlhcygneycpO1xuXHRcdHRhZy5hbGlhcygne3snKTtcblx0XHR0YWcuYWxpYXMoJ2luZGV4X3N0YXJ0Jyk7XG5cdFx0dGFnLmFsaWFzKCdibG9ja19wYXJhbV9zdGFydCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWNsb3NlJywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnY2xvc2UnKTtcblx0XHQvLyBAbm9kZVR5cGUgPSAncydcblx0XHRcblx0XHR0YWcuYWxpYXMoJ10nKTtcblx0XHR0YWcuYWxpYXMoJyknKTtcblx0XHR0YWcuYWxpYXMoJ30nKTtcblx0XHR0YWcuYWxpYXMoJ319Jyk7XG5cdFx0dGFnLmFsaWFzKCdpbmRleF9lbmQnKTtcblx0XHR0YWcuYWxpYXMoJ2Jsb2NrX3BhcmFtX2VuZCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXJwYXJlbicsICdpbWNsb3NlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgncnBhcmVuJyk7XG5cdFx0dGFnLmFsaWFzKCcpJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltdGFnb3BlbicsICdpbW9wZW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCd0YWdfc3RhcnQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWdjbG9zZScsICdpbWNsb3NlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX2VuZCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbG9wZW4nLCAnaW1vcGVuJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3Jfc3RhcnQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zZWxjbG9zZScsICdpbWNsb3NlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfZW5kJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcXVvdGUnLCAnaW0nKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNpbmdsZXF1b3RlJywgJ2ltcXVvdGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKFwiJ1wiKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1kb3VibGVxdW90ZScsICdpbXF1b3RlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnXCInKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zdHJzdGFydCcsICdpbW9wZW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzdHJpbmdfc3RhcnQnKTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltc3RyZW5kJywgJ2ltY2xvc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzdHJpbmdfZW5kJyk7XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvYmFzZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi4vY29yZS9oaWdobGlnaHRlcicpLkhpZ2hsaWdodGVyO1xuXHRcblx0XG5cdHZhciBrZXl3b3JkcyA9IFtcblx0XHQndHJ1ZScsJ2ZhbHNlJywnbnVsbCcsJ3RoaXMnLFxuXHRcdCdkZWxldGUnLCd0eXBlb2YnLCdpbicsJ2luc3RhbmNlb2YnLFxuXHRcdCd0aHJvdycsJ2JyZWFrJywnY29udGludWUnLCdkZWJ1Z2dlcicsXG5cdFx0J2lmJywnZWxzZScsJ3N3aXRjaCcsJ2ZvcicsJ3doaWxlJywnZG8nLCd0cnknLCdjYXRjaCcsJ2ZpbmFsbHknLFxuXHRcdCdjbGFzcycsJ2V4dGVuZHMnLCdzdXBlcicsJ3JldHVybicsXG5cdFx0J3VuZGVmaW5lZCcsJ3RoZW4nLCd1bmxlc3MnLCd1bnRpbCcsJ2xvb3AnLCdvZicsJ2J5Jyxcblx0XHQnd2hlbicsJ2RlZicsJ3RhZycsJ2RvJywnZWxpZicsJ2JlZ2luJywndmFyJywnbGV0Jywnc2VsZicsJ2F3YWl0JywnaW1wb3J0Jyxcblx0XHQnYW5kJywnb3InLCdpcycsJ2lzbnQnLCdub3QnLCd5ZXMnLCdubycsJ2lzYScsJ2Nhc2UnLCduaWwnLCdleHRlbmQnLCdleHBvcnQnLCdvd24nXG5cdF07XG5cdFxuXHQvLyB0aGlzIGlzIHJlYWxseSB0aGUgZ2VuZXJhbCB0b2tlblxuXHR0YWckLmRlZmluZVRhZygnaW10b2snLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy5hbGlhcygndG9rZW4nKTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fZXJlZiA9IHt3YXRjaDogJ2VyZWZEaWRTZXQnLG5hbWU6ICdlcmVmJ307XG5cdFx0dGFnLnByb3RvdHlwZS5lcmVmID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZXJlZicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRFcmVmID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMuZXJlZigpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuc2V0QXR0cmlidXRlKCdlcmVmJyx2KTsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuZXJlZkRpZFNldCAmJiB0aGlzLmVyZWZEaWRTZXQodixhLHRoaXMuX19lcmVmKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZXJlZkRpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHQvLyBleHBlcmltZW50YWxcblx0XHRcdC8vIGNvbnNvbGUubG9nICdlcmVmRGlkU2V0JyxuZXcsb2xkXG5cdFx0XHRpZiAoIShuZXckICYmIG9sZCkpIHsgdGhpcy5mbGFnKCdsdmFyJywhKCEobmV3JCkpKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzVmFyUmVmID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYXNGbGFnKCdsdmFyJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsZWFyVmFyUmVmID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnNldEVyZWYobnVsbCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdHJldHVybiBJTS50b2sodmFsKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHRhZy5fX3N1cGVyX18uc2V0VGV4dC5jYWxsKHRoaXMsdGV4dCk7XG5cdFx0XHR0aGlzLmNsYXNzaWZ5KCk7XG5cdFx0XHRcblx0XHRcdHZhciB0eXAgPSBJTS5pZGVudGlmeSh0ZXh0KTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cCkge1xuXHRcdFx0XHR0aGlzLmxvZygncmVjbGFzc2lmeWluZyBpbXRvayBpbW1lZGlhdGVseScpO1xuXHRcdFx0XHR0aGlzLnNldENvZGUodGV4dCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlY2xhc3NpZnkodHlwKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHJldHVybiByYXcgdG9rZW4gaWYgbm90IGNsYXNzaWZpZWQ/XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwID8gKHRoaXMpIDogKHRhZyQuJGltcmF3KCkuc2V0UmF3KHRleHQpLmVuZCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2FuUHJlcGVuZCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xhc3NpZnkgPSBmdW5jdGlvbiAobWFwKXtcblx0XHRcdG1hcCB8fCAobWFwID0gSU0uaWRlbnRpZnkodGhpcy5jb2RlKCkpKTtcblx0XHRcdGlmIChtYXApIHtcblx0XHRcdFx0aWYgKCFtYXAubWF0Y2goL1xcYl9bXFx3XS8pKSB7IG1hcCA9ICdfaW10b2sgJyArIG1hcCB9O1xuXHRcdFx0XHR0aGlzLmRvbSgpLmNsYXNzTmFtZSA9IG1hcDtcblx0XHRcdFx0dGhpcy5fdHlwID0gbWFwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdHlwID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ3JlcGFpcicpO1xuXHRcdFx0dGhpcy5jbGFzc2lmeSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHJlZ2lvbil7XG5cdFx0XHRyZWdpb24gPSBSZWdpb24ubm9ybWFsaXplKHJlZ2lvbik7XG5cdFx0XHR2YXIgbGZ0ID0gdGhpcy5jb2RlKCkuc3Vic3RyaW5nKDAscmVnaW9uLnN0YXJ0KCkpO1xuXHRcdFx0dmFyIHJndCA9IHRoaXMuY29kZSgpLnNsaWNlKHJlZ2lvbi5lbmQoKSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuc2V0Q29kZShsZnQpO1xuXHRcdFx0dGhpcy5zZXROZXh0KElNLnRvayhyZ3QpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHR2YXIgZGlydHkgPSB0aGlzLmRpcnR5RXh0ZW50KCk7XG5cdFx0XHR0aGlzLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkgeyByZXR1cm4gSGlnaGxpZ2h0ZXIucmVwYXJzZShkaXJ0eSk7IH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJldXNlID0gZnVuY3Rpb24gKHRvayxuZXckLG9sZCl7XG5cdFx0XHRpZiAobmV3JCA9PSBvbGQpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLnJldXNlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0aWYgKCFvLmRlZXAgJiYgdGhpcy52YWxpZGF0ZSh0aGlzLmNvZGUoKSkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLm11dGF0ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmRibGNsaWNrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWxlY3QoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuZXJlZigpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5ub2Rlc0ZvckVudGl0eSh0aGlzLmVyZWYoKSkubWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC5mbGFnKCdobCcpOyB9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdGlmICh0aGlzLmVyZWYoKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkubm9kZXNGb3JFbnRpdHkodGhpcy5lcmVmKCkpLm1hcChmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwudW5mbGFnKCdobCcpOyB9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaWRlbnRpZmllcicsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2lkZW50aWZpZXInKTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0Ly8gcmVnZXggZm9yIGlkZW50aWZpZXJcblx0XHRcdHJldHVybiAoL15bYS16XSgtP1tcXHdBLVphLXpfXFwtXFx4N2YtXFx1ZmZmZlxcJF0rKSokLykudGVzdChjb2RlKSAmJiBrZXl3b3Jkcy5pbmRleE9mKGNvZGUpID09IC0xO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICh0b2ssbmV3JCxvbGQpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2lkZW50aWZpZXIgc2V0dXAnLGJhc2VDbGFzc2VzXG5cdFx0XHR2YXIgdl87XG5cdFx0XHRpZiAodG9rICYmIHRvay5fdmFsdWUpIHsgKHRoaXMuc2V0TmFtZSh2XyA9IHRvay5fdmFsdWUpLHZfKSB9O1xuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzZXMoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaW1pZGVudGlmaWVyIG11dGF0ZWQnXG5cdFx0XHR0aGlzLnNldE5hbWUodGhpcy5jb2RlKCkpO1xuXHRcdFx0aWYgKHRoaXMuaXNWYXJSZWYoKSkge1xuXHRcdFx0XHR0aGlzLmNsZWFyVmFyUmVmKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ubXV0YXRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWd0eXBlJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX3R5cGUnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWdpZCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3RhZ19pZCcpO1xuXHRcdHRhZy5hbGlhcygnaWRyZWYnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1jb25zdCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2NvbnN0Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdHJldHVybiAoL15bQS1aXSgtP1tcXHdBLVphLXpfXFwtXFx4N2YtXFx1ZmZmZlxcJF0rKSokLykudGVzdChjb2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGRlZiBvbmNoYW5nZWQgY29kZSwgcHJldlxuXHRcdC8vIFx0IyBjb25zb2xlLmxvZyAnaW1jb25zdCBvbmNoYW5nZWQnLGNvZGUscHJldlxuXHRcdC8vIFx0ZmxhZygnZGlydHknKSB1bmxlc3MgdmFsaWRhdGUoY29kZSlcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaXZhcicsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2l2YXInKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1jdmFyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnY3ZhcicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWtleXdvcmQnLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdrZXl3b3JkJyk7XG5cdFx0dGFnLmFsaWFzKCduZXcnKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKHRvayxuZXckLG9sZCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnc2V0dXAgaW1rZXl3b3JkJyx0b2ssIG5ldywgb2xkXG5cdFx0XHR2YXIgY2xzID0gdGhpcy5iYXNlQ2xhc3NlcygpO1xuXHRcdFx0aWYgKHRvayAmJiB0b2suX3ZhbHVlKSB7IGNscyArPSAnICcgKyB0b2suX3ZhbHVlIH07XG5cdFx0XHR0aGlzLl9kb20uY2xhc3NOYW1lID0gY2xzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRrZXl3b3Jkcy5tYXAoZnVuY3Rpb24oa2V5d29yZCkgeyByZXR1cm4gSU0uVHlwZXNba2V5d29yZF0gPSBJTS5UeXBlcy5rZXl3b3JkOyB9KTtcblx0XG5cdElNLlR5cGVzLmZvcmluID0gSU0uVHlwZXMua2V5d29yZDtcblx0SU0uVHlwZXMuZm9yb2YgPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRJTS5UeXBlcy5wb3N0X2lmID0gSU0uVHlwZXMua2V5d29yZDtcblx0SU0uVHlwZXMucG9zdF91bmxlc3MgPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRJTS5UeXBlcy5wb3N0X2ZvciA9IElNLlR5cGVzLmtleXdvcmQ7XG5cdElNLlR5cGVzLnBvc3Rfd2hpbGUgPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltbnVtJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnbnVtYmVyJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdHJldHVybiAoL15cXGQrKFxcLlxcZCspPyQvKS50ZXN0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXVzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pbnQnLCAnaW1udW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdpbnQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1mbG9hdCcsICdpbW51bScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2Zsb2F0Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltYm9vbCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2Jvb2wnKTtcblx0XHR0YWcuYWxpYXMoJ3RydWUnKTtcblx0XHR0YWcuYWxpYXMoJ2ZhbHNlJyk7XG5cdH0pO1xuXHRcblx0Ly8gdGhpcyBzaG91bGQgYmUgbW9yZSBhZHZhbmNlZCAtIG5vXG5cdHRhZyQuZGVmaW5lVGFnKCdpbXN0cicsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N0cmluZycpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucXVvdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNvZGUoKVswXTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UXVvdGUgPSBmdW5jdGlvbiAocXVvdGUpe1xuXHRcdFx0dGhpcy5zZXRDb2RlKHF1b3RlICsgdGhpcy5jb2RlKCkuc2xpY2UoMSwtMSkgKyBxdW90ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAodG9rLG5ldyQsb2xkKXtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdzZXR1cCBzdHJpbmcnLHRvaywgbmV3LCBvbGRcblx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc2VzKCk7XG5cdFx0XHR0aGlzLnNldENvZGUobmV3JCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub251bndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgdl87XG5cdFx0XHR0aGlzLmxvZygnaW1zdHJpbmcgb251bndyYXAhISEnLGUpO1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHQvLyBsb29rIGF0IHByZXYgYW5kIG5leHQgYXMgd2VsbD9cblx0XHRcdC8vIHNob3VsZCBkbyB0aGlzIHRocm91Z2ggdGhlIHZpZXdcblx0XHRcdHJldHVybiAodGhpcy5zZXRDb2RlKHZfID0gdGhpcy5jb2RlKCkuc2xpY2UoMSwtMSkpLHZfKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25kYmxjbGljayA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2VsZWN0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0aWYgKGNvZGVbMF0gPT0gJ1wiJykge1xuXHRcdFx0XHRyZXR1cm4gKC9eXFxcIihbXlwiXFx7XSopXFxcIiQvKS50ZXN0KGNvZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb2RlWzBdID09IFwiJ1wiKSB7XG5cdFx0XHRcdHJldHVybiAoL15cXCcoW14nXFx7XSopXFwnJC8pLnRlc3QoY29kZSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnRyaWdnZXIoJ1wiJyxmdW5jdGlvbih0b2tlbixvKSB7XG5cdFx0XHRpZiAodG9rZW4ucXVvdGUoKSA9PSAnXCInKSB7XG5cdFx0XHRcdHRoaXMuaW5zZXJ0KCdcXFxcXCInKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnF1b3RlKCkgPT0gXCInXCIgJiYgby5tb2RlID09ICdhbGwnKSB7XG5cdFx0XHRcdHRva2VuLnNldFF1b3RlKCdcIicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0XG5cdFx0dGFnLnRyaWdnZXIoXCInXCIsZnVuY3Rpb24odG9rZW4sbykge1xuXHRcdFx0dmFyIHZfO1xuXHRcdFx0aWYgKHRva2VuLnF1b3RlKCkgPT0gJ1wiJykge1xuXHRcdFx0XHRyZXR1cm4gKHRva2VuLnNldFF1b3RlKHZfID0gXCInXCIpLHZfKTtcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4ucXVvdGUoKSA9PSBcIidcIiAmJiBvLm1vZGUgPT0gJ2FsbCcpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0KFwiXFxcXCdcIik7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9KTtcblx0XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltbmVvc3RyaW5nJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnbmVvc3RyaW5nJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoIW8uZGVlcCAmJiAhdGhpcy5jb2RlKCkubWF0Y2goL1tcXHtcXFwiXFwnXS8pKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5tdXRhdGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXN5bScsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N5bWJvbCcpO1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW10YWdhdHRyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX2F0dHInKTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy90b2tlbi5pbWJhXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHR2YXIgSGlnaGxpZ2h0ZXIgPSByZXF1aXJlKCcuLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1ibG9jaycsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWxldGVMZWZ0UmlnaHQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1ibG9jayBkZWxldGVMZWZ0UmlnaHQnLGUucmVnaW9uKCkucGVlaygtMSwxKSk7XG5cdFx0XHRcblx0XHRcdGlmIChlLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gdGhpcy5jb2RlKCkpIHtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluZGVudEJsb2NrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0ZS5oYW5kbGVkKCk7XG5cdFx0XHRcblx0XHRcdHNlbGYudmlldygpLmNhcmV0KCkuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0dmFyIHJlZ2lvbiA9IHNlbGYudmlldygpLmNhcmV0KCkucmVnaW9uKCk7XG5cdFx0XHR2YXIgbm9kZXMgPSBzZWxmLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHJlZ2lvbik7XG5cdFx0XHRcblx0XHRcdG5vZGVzLm1hcChmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRpZiAobWF0Y2gubm9kZS5tYXRjaGVzKCcuX2ltbmV3bGluZScpKSB7XG5cdFx0XHRcdFx0c2VsZi5sb2coJ2ZvdW5kIHRhYiBpbiBzZWxlY3Rpb24nLG1hdGNoKTtcblx0XHRcdFx0XHRpZiAobWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gubm9kZS5pbmRlbnQoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHNlbGYudmlldygpLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51bmRlbnQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1ibG9jay51bmRlbnQnLGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgbm9kZXMgPSBlLnZpZXcoKS5ub2Rlc0luUmVnaW9uKGUucmVnaW9uKCkuY2xvbmUoKS5zdGFydEF0TGluZSgpKTtcblx0XHRcdG5vZGVzLm1hcChmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRpZiAobWF0Y2gubm9kZS5tYXRjaGVzKCcuX2ltbmV3bGluZScpICYmIG1hdGNoLm1vZGUgIT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaC5ub2RlLnVuZGVudCgpO1xuXHRcdFx0XHRcdC8vIGUuY2FyZXQuZXhwYW5kKDAsLTEpXG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMudmlldygpLmNhcmV0KCkuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYWlyYWJsZSA9IGZ1bmN0aW9uIChzdHIsZSl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRcdHRoaXMuc2V0Q2hpbGRyZW4oW25vZGVdKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGxvZyBcInJlcGFpciBibG9ja1wiXG5cdFx0XHRxJCgnLl9pbXJhdycsdGhpcykubWFwKGZ1bmN0aW9uKHJhdykgeyByZXR1cm4gcmF3LnJlcGFpcigpOyB9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gdmFyIHJlZyA9IHZpZXcuc2VsLnJlZ2lvblxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5jb2RlU3RhdGUoKTtcblx0XHRcdHZhciBobCA9IElNLnBhcnNlKHN0YXRlLmNvZGUpO1xuXHRcdFx0Ly8gY291bGQgc2VuZCB0aGlzIHRocm91Z2ggbG9hZCBpbnN0ZWFkXG5cdFx0XHQvLyB3aGF0IGFib3V0IGFubm90YXRpb25zIGhlcmU/XG5cdFx0XHR0aHJvdyAnZG9udCByZWhpZ2hsaWdodCc7XG5cdFx0XHRcblx0XHRcdGlmIChobCkge1xuXHRcdFx0XHRzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYuZG9tKCkuaW5uZXJIVE1MID0gaGwgKyAnXFxuJztcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUuaW52YWxpZHMubWFwKGZ1bmN0aW9uKGludikge1xuXHRcdFx0XHRcdFx0Ly8gd2UgY291bGQgZ28gbG9jYWwgaW5zdGVhZFxuXHRcdFx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdFx0XHRpZiAobm9kZSA9IHNlbGYudmlldygpLm5vZGVBdFJlZ2lvbihpbnYucmVnaW9uLHRydWUpKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYubG9nKCdmb3VuZCBub2RlIGF0IGludmFsaWQgcG9zaXRpb24nLG5vZGUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZS5yZXBsYWNlV2l0aChpbnYubm9kZSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGJhZCBuYW1pbmdcblx0XHR0YWcucHJvdG90eXBlLmNvZGVTdGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHJlYWwgPSBzZWxmLmNvZGUoKTtcblx0XHRcdHZhciB2YWxpZCA9IHJlYWw7XG5cdFx0XHR2YXIgaW52YWxpZHMgPSBxJCgnLmludmFsaWQnLHNlbGYpO1xuXHRcdFx0dmFyIG93bnJlZyA9IHNlbGYucmVnaW9uKCk7XG5cdFx0XHR2YXIgc2VscmVnID0gc2VsZi52aWV3KCkuc2VsKCkucmVnaW9uKCk7XG5cdFx0XHRcblx0XHRcdHZhciByZW1lbWJlciA9IGludmFsaWRzLm1hcChmdW5jdGlvbihpbnYpIHtcblx0XHRcdFx0Ly8gbXVsdGlsZXZlbCBuZXN0aW5nP1xuXHRcdFx0XHR2YXIgcmVnaW9uID0gaW52LnJlZ2lvbigpO1xuXHRcdFx0XHR2YXIgcmVscmVnID0gcmVnaW9uLnJlbGF0aXZlVG8ob3ducmVnKTtcblx0XHRcdFx0c2VsZi5sb2coJ2ludmFsaWQgcmVnaW9uJyxvd25yZWcsJ3NlbGYnLHJlZ2lvbixyZWxyZWcpO1xuXHRcdFx0XHR2YWxpZCA9IHZhbGlkLmlucyhpbnYucGxhY2Vob2xkZXIoKSxyZWxyZWcpO1xuXHRcdFx0XHRyZXR1cm4ge3JlZ2lvbjogcmVnaW9uLHBsYWNlaG9sZGVyOiBpbnYucGxhY2Vob2xkZXIoKSxyYXc6IGludi5jb2RlKCksbm9kZTogaW52LHJvb3Q6IHNlbGYscmVsUmVnaW9uOiByZWxyZWd9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlZ2lvbjogb3ducmVnLFxuXHRcdFx0XHRtYXJrZXI6IChzZWxyZWcuaW50ZXJzZWN0cyhvd25yZWcpID8gKHNlbHJlZykgOiAobnVsbCkpLFxuXHRcdFx0XHRyYXc6IHJlYWwsXG5cdFx0XHRcdGNvZGU6IHZhbGlkLFxuXHRcdFx0XHRpbnZhbGlkczogcmVtZW1iZXJcblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaW50ZXJwb2xhdGVkJywgJ2ltYmxvY2snKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbmRlbnQnLCAnaW1ibG9jaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBtYXAgPSB7fTtcblx0XHRcdHZhciB2YXJzID0gW107XG5cdFx0XHRxJCgnLl9sdmFyJyx0aGlzKS5tYXAoZnVuY3Rpb24obHZhcikge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGx2YXIudGV4dCgpO1xuXHRcdFx0XHRpZiAoIW1hcFtuYW1lXSkge1xuXHRcdFx0XHRcdG1hcFtuYW1lXSA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIHZhcnMucHVzaChuYW1lKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHZhcnM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1wYWlyJywgJ2ltYmxvY2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdwYWlyJyk7XG5cdFx0XG5cdFx0dGFnLnBhaXIgPSBmdW5jdGlvbiAob3BlbixjbG9zZSl7XG5cdFx0XHR0aGlzLnByb3RvdHlwZS5fb3BlbiA9IG9wZW47XG5cdFx0XHR0aGlzLnByb3RvdHlwZS5fY2xvc2UgPSBjbG9zZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb3BlbiB8fCAnJztcblx0XHR9O1xuXHRcdHRhZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9jbG9zZSB8fCAnJztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZ2VuKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KXtcblx0XHRcdHRocm93ICdzaG91bGQgbm90IGdldCBoZXJlJztcblx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gdGhpcy5vcGVuKCkgKyBJTS5wYXJzZShjb250ZW50KSArIHRoaXMuY2xvc2UoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKCkucmVwbGFjZSgvW1xcc1xcdCBcXG5dLywnJykgPT0gKHRoaXMub3BlbigpICsgdGhpcy5jbG9zZSgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNQYWlyZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBjb2RlID0gdGhpcy5jb2RlKCk7XG5cdFx0XHRyZXR1cm4gY29kZVswXSA9PSB0aGlzLm9wZW4oKSAmJiBjb2RlW2NvZGUubGVuZ3RoIC0gMV0gPT0gdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc09wZW5lZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpWzBdID09IHRoaXMub3BlbigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpW3RoaXMuY29kZSgpLmxlbmd0aCAtIDFdID09IHRoaXMuY2xvc2UoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlbW92ZSB0aGUgd2hvbGUgdGhpbmcnKTtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlbDtcblx0XHRcdFx0dmFyIHBhciA9IHRoaXMucGFyZW50KCk7XG5cdFx0XHRcdHdoaWxlIChlbCA9IHRoaXMuX2RvbS5maXJzdENoaWxkKXtcblx0XHRcdFx0XHRwYXIuZG9tKCkuaW5zZXJ0QmVmb3JlKGVsLHRoaXMuX2RvbSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHJlbW92ZSBzZWxmIGFzIHdlbGxcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub251bndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1wYWlyIG9udW53cmFwISEhJyxlKTtcblx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGFnJC4kaW1vcGVuKCkuc2V0Q29udGVudCh0aGlzLm9wZW4oKSwwKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kaW1jbG9zZSgpLnNldENvbnRlbnQodGhpcy5jbG9zZSgpLDApLmVuZCgpXG5cdFx0XHRdKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmluc2VydGVkID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5zZXRDYXJldCh0aGlzLnJlZ2lvbigpLmNvbGxhcHNlKGZhbHNlKS5tb3ZlKDEpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmxpbmVicmVhayA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBwcmUgPSBlLmxpbmVzdHIoJ3ByZScpO1xuXHRcdFx0dmFyIGluZGVudCA9IGUuaW5kZW50KCk7XG5cdFx0XHR2YXIgbmV3JCA9IHRoaXMudGV4dCgpLmlucygnJyxlLnJlbFJlZ2lvbigpKTtcblx0XHRcdFxuXHRcdFx0Ly8gdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIG5vP1xuXHRcdFx0aWYgKG5ldyQgPT0gKHRoaXMub3BlbigpICsgdGhpcy5jbG9zZSgpKSkge1xuXHRcdFx0XHR2YXIgcHJlZml4ID0gJ1xcbicgKyBpbmRlbnQgKyAnXFx0Jztcblx0XHRcdFx0dmFyIHBvc3QgPSAnXFxuJyArIGluZGVudDtcblx0XHRcdFx0dGhpcy5vbndoaXRlc3BhY2UoZSxwcmVmaXggKyBwb3N0KTtcblx0XHRcdFx0ZS5jYXJldCgpLmNvbGxhcHNlKGZhbHNlKS5tb3ZlKC1wb3N0Lmxlbmd0aCk7XG5cdFx0XHRcdHJldHVybiBlLmhhbmRsZWQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG5lZWQgdG8gZmlyc3QgY29uc2lkZXIgdGhlIHNwbGl0dGluZywgbm8/XG5cdFx0XHRpZiAodGhpcy5pbmNyZWFzZUluZGVudChwcmUpKSB7IGluZGVudCArPSAnXFx0JyB9O1xuXHRcdFx0aWYgKHRoaXMuZGVjcmVhc2VJbmRlbnQocHJlKSkgeyBpbmRlbnQgPSBpbmRlbnQuc2xpY2UoMSkgfTtcblx0XHRcdHRoaXMub253aGl0ZXNwYWNlKGUsJ1xcbicgKyBpbmRlbnQpO1xuXHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdyZXBhaXIgaW10YWcnKTtcblx0XHRcdGlmICghKHRoaXMuaXNQYWlyZWQoKSkpIHsgdGhpcy5yZXZhbGlkYXRlKHRydWUpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ2ltcGFpciBtdXRhdGVkJyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZhbGlkYXRlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlZmF1bHRWYWxpZGF0aW9uTW9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICd0b2tlbml6ZSc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmV2YWxpZGF0ZSA9IGZ1bmN0aW9uIChtb2RlLHdyaXRlKXtcblx0XHRcdC8vIHRyaWNreSBtb3RoZXJmdWNrZXIgLS0gbW9zdGx5IHVzZWZ1bCBmb3IgdmFsaWRhdGlvbnNcblx0XHRcdC8vIEkgc3VwcG9zZSB3ZSBjYW4gZG8gdGhpcyBhIHNpbXBsZXIgd2F5IC0tIGJ5IHR1cm5pbmdcblx0XHRcdC8vIG9mZiBvYnNlcnZlcnMgLS0gdGVtcG9yYXJpbHkgcmVwbGFjaW5nIGlubmVyIGNvZGUgZXRjXG5cdFx0XHRcblx0XHRcdC8vIHdoZW4gYSBibG9jayBjaGVja3MgdmFsaWRpdHkgaXQgc2hvdWxkIHByb2JhYmx5XG5cdFx0XHQvLyBzdWJzdGl0dXRlIGlubmVyIGludmFsaWQgcGFydHMgLSBzbyB0aGF0IHRoZSBibG9ja1xuXHRcdFx0Ly8gdGhpbmcgaXMgc3RpbGwgdmFsaWRcblx0XHRcdHZhciBzZWxmID0gdGhpcywgaGw7XG5cdFx0XHRpZihtb2RlID09PSB1bmRlZmluZWQpIG1vZGUgPSBzZWxmLmRlZmF1bHRWYWxpZGF0aW9uTW9kZSgpO1xuXHRcdFx0aWYod3JpdGUgPT09IHVuZGVmaW5lZCkgd3JpdGUgPSBmYWxzZTtcblx0XHRcdHZhciB3YXNJbnZhbGlkID0gc2VsZi5oYXNGbGFnKCdpbnZhbGlkJyk7XG5cdFx0XHR2YXIgb2xkU3RhdGUgPSBzZWxmLmhhc0ZsYWcoJ2ludmFsaWQnKTtcblx0XHRcdHZhciBzdGF0ZSA9IHNlbGYuY29kZVN0YXRlKCk7XG5cdFx0XHR2YXIgY29kZSA9IHN0YXRlLmNvZGU7XG5cdFx0XHRcblx0XHRcdGlmICghKHNlbGYuaXNQYWlyZWQoKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYubWFya0ludmFsaWQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnNvbGUubG9nKCd3aWxsIHJldmFsaWRhdGUgd2l0aCBjb2RlJyxjb2RlKTtcblx0XHRcdGNvbnNvbGUudGltZSgncmV2YWxpZGF0ZScpO1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAobW9kZSA9PSAnY29tcGlsZScpIHtcblx0XHRcdFx0XHRzZWxmLl9vdXRwdXQgPSBJbWJhYy5jb21waWxlKGNvZGUse2JhcmU6IHRydWV9KTtcblx0XHRcdFx0XHRzZWxmLl90b2tlbnMgPSBzZWxmLl9vdXRwdXQub3B0aW9ucy5fdG9rZW5zO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuX3Rva2VucyA9IEltYmFjLnRva2VuaXplKGNvZGUse2JhcmU6IHRydWV9KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0c2VsZi5tYXJrVmFsaWQoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5fdG9rZW5zID0gbnVsbDtcblx0XHRcdFx0c2VsZi5tYXJrSW52YWxpZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS50aW1lRW5kKCdyZXZhbGlkYXRlJyk7XG5cdFx0XHRcblx0XHRcdGlmICh3YXNJbnZhbGlkICYmIHNlbGYuX3Rva2Vucykge1xuXHRcdFx0XHQvLyBuZWVkIHRvIGZpeCBpbm5lciBmb3Igcm9vdFxuXHRcdFx0XHRpZiAoaGwgPSBIaWdobGlnaHRlci5oaWdobGlnaHQoY29kZSx7dG9rZW5zOiBzZWxmLl90b2tlbnMsaW5uZXI6IHRydWV9KSkge1xuXHRcdFx0XHRcdC8vIHRoaXMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgb3V0IGludG8gYSBzZXBhcmF0ZSBtZXRob2Rcblx0XHRcdFx0XHQvLyBwb3NzaWJseSBkbyBsb2FkU3RhdGUgLyBkdW1wU3RhdGVcblx0XHRcdFx0XHRzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5kb20oKS5pbm5lckhUTUwgPSBobDtcblx0XHRcdFx0XHRcdHN0YXRlLmludmFsaWRzLm1hcChmdW5jdGlvbihpbnYpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdFx0XHRcdGlmIChub2RlID0gc2VsZi52aWV3KCkubm9kZUF0UmVnaW9uKGludi5yZWdpb24sdHJ1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZS5yZXBsYWNlV2l0aChpbnYubm9kZSk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGlmIChzdGF0ZS5tYXJrZXIpIHsgcmV0dXJuIHNlbGYudmlldygpLnNlbCgpLnNldChzdGF0ZS5tYXJrZXIpIH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9wZW4oKSArICgnICcpLnJlcGVhdCh0aGlzLnNpemUoKSAtIDIpICsgdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0F0b21pYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdtdWF0ZWQgaW1jdXJseScpO1xuXHRcdFx0dGhpcy52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKHRoaXMuZGlydHlFeHRlbnQoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWN1cmx5JywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2N1cmx5Jyk7XG5cdFx0dGFnLnBhaXIoJ3snLCd9Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc3F1YXJlJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NxdWFyZScpO1xuXHRcdHRhZy5wYWlyKCdbJywnXScpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJldHRpZnkgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmxvZygncHJldHRpZnkhJyk7XG5cdFx0XHRlLmhhbmRsZWQoKTtcblx0XHRcdHZhciBpbmQgPSBlLnJlZ2lvbigpLmluZGVudCgpO1xuXHRcdFx0c2VsZi5sb2coJ3dpdGggaW5kZW50YXRpb24nLGluZCxpbmQubGVuZ3RoKTtcblx0XHRcdFxuXHRcdFx0c2VsZi52aWV3KCkub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuY2hpbGRyZW4oKSksIGxlbiA9IGFyeS5sZW5ndGgsIGNoaWxkLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Y2hpbGQgPSBhcnlbaV07XG5cdFx0XHRcdFx0cmVzLnB1c2goY2hpbGQubWF0Y2hlcygnLmNvbW1hLC5faW1vcGVuJykgPyAoXG5cdFx0XHRcdFx0XHRjaGlsZC5zZXROZXh0KCdcXG4nICsgaW5kICsgJ1xcdCcpXG5cdFx0XHRcdFx0KSA6ICgoY2hpbGQubWF0Y2hlcygnLl9pbWNsb3NlJykpICYmIChcblx0XHRcdFx0XHRcdGNoaWxkLnNldFByZXYoJ1xcbicgKyBpbmQpXG5cdFx0XHRcdFx0KSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcGFyZW5zJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3BhcmVucycpO1xuXHRcdHRhZy5wYWlyKCcoJywnKScpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub251bndyYXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLmxvZygnaW1wYWlyIG9udW53cmFwISEhJyxlKTtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0Ly8gbG9vayBhdCBwcmV2IGFuZCBuZXh0IGFzIHdlbGw/XG5cdFx0XHQvLyBzaG91bGQgZG8gdGhpcyB0aHJvdWdoIHRoZSB2aWV3XG5cdFx0XHR0aGlzLnNldENvZGUoJyAnICsgdGhpcy5jb2RlKCkuc2xpY2UoMSwtMSkpO1xuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLnJlcGFpcigpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaXN0cmluZycsICdpbXBhaXInLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdpc3RyaW5nJyk7XG5cdFx0dGFnLnBhaXIoJ1wiJywnXCInKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pZXhwcicsICdpbXBhaXInLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdpZXhwcicpO1xuXHRcdHRhZy5wYWlyKCd7JywnfScpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWJsb2NrcGFyYW1zJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2Jsb2NrcGFyYW1zJyk7XG5cdFx0dGFnLnBhaXIoJ3wnLCd8Jyk7XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbXRhZ25vZGUnLCAnaW1wYWlyJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnbm9kZScpO1xuXHRcdHRhZy5wYWlyKCc8JywnPicpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFpcmFibGUgPSBmdW5jdGlvbiAoc3RyLGUpe1xuXHRcdFx0cmV0dXJuIGlkeCQoc3RyLFsneycsJ1snLCcoJywnXCInLFwiJ1wiXSkgPj0gMDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9wZW4oKSArICgneCcpLnJlcGVhdCh0aGlzLnNpemUoKSAtIDIpICsgdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWZhdWx0VmFsaWRhdGlvbk1vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAnY29tcGlsZSc7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9ibG9jay5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbXJvb3QnLCAnaW1ibG9jaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcuX25vZGVUeXBlID0gJ2NvZGUnO1xuXHRcdC8vIGRlZiBzZWxmLmRvbVxuXHRcdC8vXHRAZG9tIHx8PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJylcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRyeVVuZGVudCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYubG9nKCd0cnlVbmRlbnQnKTtcblx0XHRcdHZhciBub2RlcyA9IGUudmlldygpLm5vZGVzSW5SZWdpb24oZS5yZWdpb24oKS5jbG9uZSgpLnN0YXJ0QXRMaW5lKCkpO1xuXHRcdFx0bm9kZXMubWFwKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdGlmIChtYXRjaC5ub2RlLm1hdGNoZXMoJy5faW1uZXdsaW5lJykgJiYgbWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0bWF0Y2gubm9kZS51bmRlbnQoKTtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkuY2FyZXQoKS5tb3ZlKC0xKTtcblx0XHRcdFx0XHQvLyBlLmNhcmV0Lm1vdmUoLTEpXG5cdFx0XHRcdFx0Ly8gZS5jYXJldC5leHBhbmQoMCwtMSlcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBlLm1vdmVDYXJldCA9IDBcblx0XHRcdGUuaGFuZGxlZCgpO1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5kb20oKS5hZGRFdmVudExpc3RlbmVyKCcnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROZXh0ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0dGhpcy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQcmV2ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0dmFyIGZpcnN0ID0gdGhpcy5kb20oKS5maXJzdENoaWxkO1xuXHRcdFx0Zmlyc3QgPyAodGhpcy5pbnNlcnRCZWZvcmUobm9kZSxmaXJzdCkpIDogKHRoaXMuYXBwZW5kQ2hpbGQobm9kZSkpO1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubGluZWJyZWFrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIHByZSA9IGUubGluZXN0cigncHJlJyk7XG5cdFx0XHR2YXIgaW5kZW50ID0gZS5pbmRlbnQoKTtcblx0XHRcdHZhciBuZXckID0gdGhpcy50ZXh0KCkuaW5zKCcnLGUucmVsUmVnaW9uKCkpO1xuXHRcdFx0Ly8gbmVlZCB0byBmaXJzdCBjb25zaWRlciB0aGUgc3BsaXR0aW5nLCBubz9cblx0XHRcdGlmICh0aGlzLmluY3JlYXNlSW5kZW50KHByZSkpIHsgaW5kZW50ICs9ICdcXHQnIH07XG5cdFx0XHRpZiAodGhpcy5kZWNyZWFzZUluZGVudChwcmUpKSB7IGluZGVudCA9IGluZGVudC5zbGljZSgxKSB9O1xuXHRcdFx0dGhpcy5vbndoaXRlc3BhY2UoZSwnXFxuJyArIGluZGVudCk7XG5cdFx0XHRyZXR1cm4gZS5oYW5kbGVkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdpbXJvb3QgbXV0YXRlZCcpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRpcnR5RXh0ZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmxvZygnaW1yb290IGRpcnR5RXh0ZW50Jyk7XG5cdFx0XHQvLyBzdXBlclxuXHRcdFx0dmFyIG5vZGVzID0gc2VsZi5jaGlsZHJlbigpLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBuLmRvbSgpOyB9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y29kZTogc2VsZi5jb2RlKCksXG5cdFx0XHRcdG5vZGVzOiBub2Rlcyxcblx0XHRcdFx0cGFyZW50OiBzZWxmLmRvbSgpLFxuXHRcdFx0XHRjb250YWluczogZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHNlbGYuZG9tKCkuY29udGFpbnMoZWwuX2RvbSB8fCBlbCk7IH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9yb290LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGV4dGVybnM7XG5cdFxuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXHRcblx0dmFyIFNJTkdMRV9TVFIgPSAvXidbXiddKickLztcblx0dmFyIERPVUJMRV9TVFIgPSAvXlwiW15cIlxce10qXCIkLztcblx0dmFyIENPTU1FTlQgPSAvXlxcI1sgXFx0XVteXFxuXSokLztcblx0XG5cdERPVUJMRV9TVFIgPSAvXlwiKFteXFxcXFwiXFx7XXxcXFxcXFxcXHxcXFxcXCIpKlwiJC87XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1saXQnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltcmVnZXgnLCAnaW1saXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCdyZWdleCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhaXJpbmcgPSBmdW5jdGlvbiAoY2hyKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXZhbGlkYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcmVnID0gdGhpcy5jb2RlKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgb2JqID0gZXZhbChyZWcpO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyB9O1xuXHRcdFx0dGhpcy5sb2coJ3JlZ2V4IGlzJyxyZWcsb2JqKTtcblx0XHRcdHRoaXMuZmxhZygnaW52YWxpZCcsIW9iaik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ3JlZ2V4IG11dGF0ZWQnKTtcblx0XHRcdHJldHVybiB0aGlzLnJldmFsaWRhdGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAnLycgKyAnUicucmVwZWF0KHRoaXMuc2l6ZSgpIC0gMikgKyAnLyc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzQXRvbWljID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9saXRlcmFscy5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0Ly8gc2hvdWxkIHJhdGhlciByZWNvbmNpbGUgaW50byB0b2tlbiAtIG9yIHNvbWV0aGluZyBsaWtlIGl0XG5cdHZhciBuYW1lcyA9IHtcblx0XHQnLic6ICdkb3QnLFxuXHRcdCc9JzogJ2VxJyxcblx0XHQnPyc6ICdxJyxcblx0XHQnISc6ICd1bmFyeScsXG5cdFx0JzonOiAnY29sb24nLFxuXHRcdCcsJzogJ2NvbW1hJyxcblx0XHQnIyc6ICdoYXNoJyxcblx0XHQnKic6ICdtdWx0Jyxcblx0XHQnPj4nOiAnYml0c2hpZnQnXG5cdH07XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1vcCcsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnR5cGUoJ29wJyk7XG5cdFx0dGFnLmFsaWFzKCdyZWxhdGlvbicpO1xuXHRcdHRhZy5hbGlhcygnY29tcGFyZScpO1xuXHRcdHRhZy5hbGlhcygnY29tcG91bmRfYXNzaWduJyk7XG5cdFx0dGFnLmFsaWFzKCdhc3NpZ24nKTtcblx0XHR0YWcuYWxpYXMoJ2Jsb2NrX2FyZycpO1xuXHRcdHRhZy5hbGlhcygnc3BsYXQnKTtcblx0XHR0YWcuYWxpYXMoJ2xvZ2ljJyk7XG5cdFx0dGFnLmFsaWFzKCdtYXRoJyk7XG5cdFx0dGFnLmFsaWFzKCdzaGlmdCcpO1xuXHRcdHRhZy5hbGlhcygndW5hcnknKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuIElNLmlzT3AoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJhc2VDbGFzc2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5iYXNlQ2xhc3Nlcy5hcHBseSh0aGlzLGFyZ3VtZW50cykgKyAnICcgKyAobmFtZXNbdGhpcy5jb2RlKCldIHx8ICcnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAodG9rZW4pe1xuXHRcdFx0dmFyIHZhbCA9IHRva2VuICYmIHRva2VuLl92YWx1ZSB8fCB0aGlzLmNvZGUoKTtcblx0XHRcdHRoaXMuZG9tKCkuY2xhc3NOYW1lID0gKFwiX2ltIF9pbW9wIG9wIFwiICsgKG5hbWVzW3ZhbF0gfHwgJycpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIG1lcmdlIHdpdGggYSBtb3JlIGdlbmVyaWMgdmVyc2lvbiBmb3IgdG9rZW4gaW4gZ2VuZXJhbFxuXHRcdC8vIHNhbWUgZ29lcyBmb3IgdGV4dCBldGNcblx0XHR0YWcucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGFnLl9fc3VwZXJfXy5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5jb2RlKCkgPT0gJy8vJykge1xuXHRcdFx0XHR0aGlzLmxvZygnaXMgYSByZWdleCEhJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlY2xhc3NpZnkoJ3JlZ2V4Jyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0Ly8gbGluayByZWd1bGFyIG9wcyB0byBvcC1ub2RlXG5cdHJldHVybiAnKyAtICogLyA9ICsrIC0tID09ID09PSAhPSAhPT0gPiA8ID49IDw9ICYgJiYgfCB8fCBvciAuIDogPyAmPSB8fD0gJiY9ID8uID86ICwgISAuLiAuLi4gLjogPj4gPDwgIycuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24ob3ApIHtcblx0XHRyZXR1cm4gSU0uVHlwZXNbb3BdID0gSU0uVHlwZXMub3A7XG5cdH0pO1xuXHRcblx0XG5cdC8vIElNLlR5cGVzOmxvZ2ljID0gSU0uVHlwZXM6b3Bcblx0Ly8gSU0uVHlwZXM6Y29tcGFyZSA9IElNLlR5cGVzOm9wXG5cdC8vIElNLlR5cGVzOm1hdGggPSBJTS5UeXBlczpvcFxuXHQvLyBJTS5UeXBlczpzaGlmdCA9IElNLlR5cGVzOm9wXG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvb3BlcmF0b3JzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHQvLyB0aGlzIHNob3VsZCBiZSBtb3JlIGFkdmFuY2VkIHRoYW4gdGhpcywgbm8/XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0F0b21pYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFyc2VkID0gZnVuY3Rpb24gKGNvZGUsb2xkKXtcblx0XHRcdHRoaXMubG9nKFwiaW1zZWwgcmVwYXJzZWRcIixjb2RlLG9sZCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbHRhZycsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yX3RhZycpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGNsYXNzJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfY2xhc3MnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zZWxjb21iJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfY29tYmluYXRvcicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGF0dHJvcCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3NlbGVjdG9yX2F0dHJfb3AnKTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltc2VsYXR0cm9wJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfYXR0cl9vcCcpO1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL3NlbGVjdG9yLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWluc2VydCcsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlZyxpbnMpe1xuXHRcdFx0Y29uc29sZS5sb2coJ2luc2VydCBjb2RlIGludG8gaW1pbnNlcnQhIScsaW5zLHJlZyk7XG5cdFx0XHRcblx0XHRcdGlmIChpbnMgaW5zdGFuY2VvZiBJTS5UeXBlcy5mcmFnbWVudCkge1xuXHRcdFx0XHRpbnMgPSBpbnMuY29kZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChpbnMgaW5zdGFuY2VvZiBJTS5UeXBlcy5yYXcpIHtcblx0XHRcdFx0aW5zID0gaW5zLl9yYXc7XG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgaW5zPT0nc3RyaW5nJ3x8aW5zIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0XHRpbnMgPSAodGhpcy5jb2RlKCkgfHwgXCJcIikuaW5zKGlucyxyZWcpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zZXRDb2RlKGlucyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKCkubWF0Y2goL15bXFxuXFx0XFwgXSskLyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdpbWluc2VydCBtdXRhdGVkJyk7XG5cdFx0XHRcblx0XHRcdHZhciBkaXJ0eSA9IHRoaXMuZGlydHlFeHRlbnQoKTtcblx0XHRcdHRoaXMudmlldygpLmhpZ2hsaWdodGVyKCkucmVwYXJzZShkaXJ0eSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXdoaXRlc3BhY2UnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2FuUHJlcGVuZCA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWRhdGUoc3RyICsgdGhpcy5jb2RlKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHRcdHJldHVybiB0aGlzLnZhbGlkYXRlKHRoaXMuY29kZSgpICsgc3RyKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbW5ld2xpbmUnLCAnaW13aGl0ZXNwYWNlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnbmV3bGluZScpO1xuXHRcdHRhZy5hbGlhcygnXFxuJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0XHRpZiAoc3RyLm1hdGNoKC9eW1xcblxcdFxcIF0rJC8pKSB7XG5cdFx0XHRcdC8vIHNob3VsZCBub3QgcmVhbGx5IGJlIGFibGUgdG8gcHJlcGVuZCBoZXJlXG5cdFx0XHRcdC8vIGl0IHNob2xkIHJhdGhlciBpbnNlcnQgYSBuZXcgbmV3bGluZSBpblxuXHRcdFx0XHQvLyBhbiBpbWluc2VydCwgYW5kIHRoYXQgc2hvdWxkIGJlIGFibGUgdG9cblx0XHRcdFx0Ly8gZGVjaWRlIHRoYXQgbm8gcmVwYXJzZSBpcyBuZWVkZWRcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYodmFsID09PSB1bmRlZmluZWQpIHZhbCA9IHRoaXMuY29kZSgpO1xuXHRcdFx0cmV0dXJuIHZhbCA9PSAnXFxuJztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5pbnNlcnQodGhpcy5yZWdpb24oKS5lbmQoKSwnXFx0Jyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygndW5kZW50IG5ld2xpbmUnKTtcblx0XHRcdHZhciByZWcgPSB0aGlzLnJlZ2lvbigpLmNsb25lKCkuY29sbGFwc2UodHJ1ZSkuY2xvbmUoMCwxKTtcblx0XHRcdGlmIChyZWcudGV4dCgpID09ICdcXHQnKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdjYW4gdW5kZW50ISEnKTtcblx0XHRcdFx0dGhpcy52aWV3KCkuZXJhc2UocmVnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHZpZXcub2JzZXJ2ZXIucGF1c2UgZG9cblx0XHRcdC8vXHRuZXh0Lm9ycGhhbml6ZSBpZiBuZXh0Py5tYXRjaGVzKCcuX2ltdGFiJylcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBsb2cgJ2ltbmV3bGluZSBtdXRhdGVkISEnXG5cdFx0XHQvLyByZW1vdmUgbm9kZSBpZiBpdCBpcyBvcnBoYW5pemVkXG5cdFx0XHRpZiAodGhpcy5jb2RlKCkgPT0gJycpIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlbW92ZSB3aG9sZSBub2RlJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5sb2coJ3JlcGFyc2UgbmV3bGluZScpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKHtub2RlczogW3RoaXMuZG9tKCldLGNvZGU6IHRoaXMuY29kZSgpfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zcGFjZScsICdpbXdoaXRlc3BhY2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCd3aGl0ZXNwYWNlJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYodmFsID09PSB1bmRlZmluZWQpIHZhbCA9IHRoaXMuY29kZSgpO1xuXHRcdFx0cmV0dXJuICgvXlsgXSskLykudGVzdCh2YWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdGhpcyBzaG91bGQgYmUgdGhlIGRlZmF1bHQgZm9yIGFsbCBub2Rlcywgbm8/XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoIW8uZGVlcCAmJiB0aGlzLnZhbGlkYXRlKHRoaXMuY29kZSgpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ubXV0YXRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zZW1pY29sb24nLCAnaW13aGl0ZXNwYWNlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VtaWNvbG9uJyk7XG5cdFx0dGFnLmFsaWFzKCc7Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltdGFiJywgJ2ltd2hpdGVzcGFjZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnR5cGUoJ3RhYicpO1xuXHRcdHRhZy5hbGlhcygnXFx0Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVkaXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoZS5pc1N1cnJvdW5kZWQoKSkge1xuXHRcdFx0XHR0aGlzLmxvZygnZGVsZXRlIHRhYj8hPycpO1xuXHRcdFx0XHRpZiAoZS50ZXh0KCkpIHsgLy8gb3RoZXJ3aXNlIHdlIHJlYWxseSBhcmUgZG9uZVxuXHRcdFx0XHRcdGUucmVkaXJlY3QodGhpcy5wcmV2KCkgfHwgdGhpcy5uZXh0KCkgfHwgdGhpcy5wYXJlbnQoKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZS5oYW5kbGVkKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRlLnJlZ2lvbigpLmNvbGxhcHNlKGZhbHNlKTtcblx0XHRcdFx0dGhpcy5vcnBoYW5pemUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmKHZhbCA9PT0gdW5kZWZpbmVkKSB2YWwgPSB0aGlzLmNvZGUoKTtcblx0XHRcdHJldHVybiB2YWwgPT0gJ1xcdCc7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1jb21tZW50JywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnY29tbWVudCcpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gQ09NTUVOVC50ZXN0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygnaW1jb21tZW50IG11dGF0ZWQnKTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLm11dGF0ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXM7XG5cdFx0XHR0aGlzLmxvZygncmVwYWlyIGNvbW1lbnQnKTtcblx0XHRcdHZhciByZWdpb24gPSB0aGlzLnJlZ2lvbigpLmVuZEF0TGluZSgpO1xuXHRcdFx0dmFyIGZ1bGwgPSByZWdpb24udGV4dCgpOyAvLyBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxhc3QgbGluZT9cblx0XHRcdHZhciBub2RlcyA9IHJlZ2lvbi5ub2RlcyhmYWxzZSk7XG5cdFx0XHR0aGlzLmxvZygnd2hvbGUgcmVnaW9uIHNob3VsZCBiZScscmVnaW9uLGZ1bGwsbm9kZXMpO1xuXHRcdFx0dGhpcy5sb2coJ2FsbCBub2Rlcycsbm9kZXMpO1xuXHRcdFx0XG5cdFx0XHQvLyBWRVJZIHRlbXBvcmFyeVxuXHRcdFx0aWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dGhpcy5zZXRDb2RlKGZ1bGwpO1xuXHRcdFx0XHR3aGlsZSAobm9kZXMubGVuZ3RoID4gMSl7XG5cdFx0XHRcdFx0dmFyIGVsID0gbm9kZXMucG9wKCk7XG5cdFx0XHRcdFx0ZWwubm9kZS5vcnBoYW5pemUoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnNlcnRlZCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzLnJlcGFpcigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRpZiAoIXRleHQubWF0Y2goL1tcXG5dLykpIHsgcmV0dXJuIHRydWUgfTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHQvLyBhbGxvdyBpbnNlcnRpbmcgYWRkaXRpb25hbCB0YWJzIGRpcmVjdGx5IGhlcmU/XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2VvZicpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvd2hpdGVzcGFjZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXdhcm4nLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ21lc3NhZ2UnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbWVzc2FnZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdidWlsdCBlcnJvciB3aXRoIGVycm9yJyx0aGlzLm9iamVjdCgpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWVycicsICdpbXdhcm4nKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Fubm90YXRpb25zLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciBSb3V0ZXIgPSByZXF1aXJlKCcuL3JvdXRlcicpLlJvdXRlcjtcblx0XG5cdGZ1bmN0aW9uIEFwcCgpe1xuXHRcdHRoaXMuc2V0Q2FjaGUoe30pO1xuXHRcdHRoaXMuc2V0RGVwcyh7fSk7XG5cdFx0dGhpcy5yZXNldCgpO1xuXHRcdHRoaXMudGljaygpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkFwcCA9IEFwcDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdEFwcC5wcm90b3R5cGUucmVxID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZXE7IH1cblx0QXBwLnByb3RvdHlwZS5zZXRSZXEgPSBmdW5jdGlvbih2KXsgdGhpcy5fcmVxID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0QXBwLnByb3RvdHlwZS5yZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3JlczsgfVxuXHRBcHAucHJvdG90eXBlLnNldFJlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLmRlcHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RlcHM7IH1cblx0QXBwLnByb3RvdHlwZS5zZXREZXBzID0gZnVuY3Rpb24odil7IHRoaXMuX2RlcHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLnNpdGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3NpdGU7IH1cblx0QXBwLnByb3RvdHlwZS5zZXRTaXRlID0gZnVuY3Rpb24odil7IHRoaXMuX3NpdGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jYWNoZTsgfVxuXHRBcHAucHJvdG90eXBlLnNldENhY2hlID0gZnVuY3Rpb24odil7IHRoaXMuX2NhY2hlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0QXBwLnByb3RvdHlwZS5pc3N1ZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2lzc3VlczsgfVxuXHRBcHAucHJvdG90eXBlLnNldElzc3VlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pc3N1ZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEFwcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnNldENhY2hlKHt9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUucm91dGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3JvdXRlciB8fCAodGhpcy5fcm91dGVyID0gbmV3IFJvdXRlcih0aGlzKSk7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gSW1iYS5TRVJWRVIgPyAodGhpcy5yZXEoKS5wYXRoKSA6ICh0aGlzLl9wYXRoKTtcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAnJztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBJbWJhLlNFUlZFUiA/ICgnJykgOiAoZG9jdW1lbnQubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpO1xuXHR9O1xuXHRcblx0QXBwLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKCFJbWJhLlNFUlZFUikge1xuXHRcdFx0dGhpcy5fcGF0aCA9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCl7XG5cdFx0SW1iYS5zY2hlZHVsZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUudW5zY2hlZHVsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdEltYmEudW5zY2hlZHVsZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuZmV0Y2hEb2N1bWVudCA9IGZ1bmN0aW9uIChzcmMsY2Ipe1xuXHRcdFxuXHRcdHZhciBkZXBzXywgJDEsICQzLCAkMjtcblx0XHRpZiAoSW1iYS5TRVJWRVIpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdmZXRjaCBkb2N1bWVudCcsc3JjKTtcblx0XHRcdFxuXHRcdFx0dmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcblx0XHRcdHZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXHRcdFx0XG5cdFx0XHR2YXIgZmlsZXBhdGggPSAoXCJcIiArIF9fZGlybmFtZSArIFwiLy4uL2RvY3MvXCIgKyBzcmMpLnJlcGxhY2UoL1xcL1xcLy9nLCcvJyk7XG5cdFx0XHRcblx0XHRcdHZhciByZXMgPSB0aGlzLmRlcHMoKVtzcmNdO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXJlcykge1xuXHRcdFx0XHR2YXIgYm9keSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCwndXRmLTgnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzcmMubWF0Y2goL1xcLm1kJC8pKSB7XG5cdFx0XHRcdFx0cmVzID0gdGhpcy5NYXJrZG93bi5yZW5kZXIoYm9keSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3JjLm1hdGNoKC9cXC5qc29uJC8pKSB7XG5cdFx0XHRcdFx0cmVzID0gSlNPTi5wYXJzZShib2R5KTtcblx0XHRcdFx0fSBlbHNlIGlmIChzcmMubWF0Y2goL1xcLmltYmEkLykpIHtcblx0XHRcdFx0XHR2YXIgaHRtbCA9IHRoaXMuSGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0KGJvZHkse21vZGU6ICdmdWxsJ30pO1xuXHRcdFx0XHRcdHJlcyA9IHtib2R5OiBib2R5LGh0bWw6IGh0bWx9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0KGRlcHNfID0gdGhpcy5kZXBzKCkpWygkMSA9IHNyYyldIHx8IChkZXBzX1skMV0gPSByZXMpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5zaXRlKCkpIHtcblx0XHRcdFx0KCQzID0gdGhpcy5zaXRlKCkuZGVwcygpKVsoJDIgPSBzcmMpXSB8fCAoJDNbJDJdID0gcmVzKTtcblx0XHRcdH07XG5cdFx0XHRjYiAmJiBjYihyZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoREVQU1tzcmNdKSB7XG5cdFx0XHRcdGNiICYmIGNiKERFUFNbc3JjXSk7XG5cdFx0XHRcdHJldHVybiB7dGhlbjogZnVuY3Rpb24odikgeyByZXR1cm4gdihyZXMpOyB9fTsgLy8gZmFrZSBwcm9taXNlIGhhY2tcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0REVQU1tzcmNdID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0cmV0dXJuIGNiICYmIGNiKERFUFNbc3JjXSk7XG5cdFx0XHRcdC8vIFhIUiA9IHhoclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncmVzcG9uc2UgaGVyZScseGhyOnJlc3BvbnNlVGV4dFxuXHRcdFx0fSk7XG5cdFx0XHR4aHIub3BlbihcIkdFVFwiLHNyYyk7XG5cdFx0XHR4aHIuc2VuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLmlzc3VlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9pc3N1ZXMgfHwgKHRoaXMuX2lzc3VlcyA9IERvYy5nZXQoJy9pc3N1ZXMvYWxsLmpzb24nKSk7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBEb2MocGF0aCl7XG5cdFx0dGhpcy5fcGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5fcmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLmZldGNoKCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuRG9jID0gRG9jOyAvLyBleHBvcnQgY2xhc3MgXG5cdHZhciBjYWNoZSA9IHt9O1xuXHRcblx0RG9jLmdldCA9IGZ1bmN0aW9uIChwYXRoKXtcblx0XHR2YXIgJDE7XG5cdFx0dmFyIGNhY2hlID0gQVBQLmNhY2hlKCk7XG5cdFx0cmV0dXJuIGNhY2hlWygkMSA9ICdkb2MtJyArIHBhdGgpXSB8fCAoY2FjaGVbJDFdID0gbmV3IHRoaXMocGF0aCkpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHREb2MucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BhdGg7IH1cblx0RG9jLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24odil7IHRoaXMuX3BhdGggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHREb2MucHJvdG90eXBlLm9iamVjdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb2JqZWN0OyB9XG5cdERvYy5wcm90b3R5cGUuc2V0T2JqZWN0ID0gZnVuY3Rpb24odil7IHRoaXMuX29iamVjdCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0RG9jLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9yZWFkeTtcblx0fTtcblx0XG5cdERvYy5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnZmV0Y2ggR3VpZGUgb24gc2VydmVyJyxwYXRoXG5cdFx0XHRyZXR1cm4gQVBQLmZldGNoRG9jdW1lbnQoc2VsZi5fcGF0aCxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoIEd1aWRlIG9uIHNlcnZlciBkb25lJyxwYXRoXG5cdFx0XHRcdHJldHVybiBzZWxmLmxvYWQocmVzKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuX3Byb21pc2UgfHwgKHNlbGYuX3Byb21pc2UgPSBBUFAuZmV0Y2hEb2N1bWVudChzZWxmLl9wYXRoLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0cmV0dXJuIHNlbGYubG9hZChyZXMpO1xuXHRcdH0pKTtcblx0fTtcblx0XG5cdERvYy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChkb2Mpe1xuXHRcdHRoaXMuX29iamVjdCA9IGRvYztcblx0XHR0aGlzLl9tZXRhID0gZG9jLm1ldGEgfHwge307XG5cdFx0dGhpcy5fcmVhZHkgPSB0cnVlO1xuXHRcdEltYmEuZW1pdCh0aGlzLCdyZWFkeScpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0RG9jLnByb3RvdHlwZS50aXRsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9vYmplY3QudGl0bGUgfHwgJ3BhdGgnO1xuXHR9O1xuXHRcblx0RG9jLnByb3RvdHlwZS50b2MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb2JqZWN0ICYmIHRoaXMuX29iamVjdC50b2NbMF07XG5cdH07XG5cdFxuXHREb2MucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb2JqZWN0ICYmIHRoaXMuX29iamVjdC5ib2R5O1xuXHR9O1xuXHRyZXR1cm4gRG9jO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hcHAuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0Ly8gZXh0ZXJucztcblx0XG5cdGZ1bmN0aW9uIFJvdXRlcihhcHApe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLl9hcHAgPSBhcHA7XG5cdFx0XG5cdFx0aWYgKEltYmEuaXNDbGllbnQoKSkge1xuXHRcdFx0d2luZG93Lm9ucG9wc3RhdGUgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHNlbGYucmVmcmVzaCgpO1xuXHRcdFx0XHRjb25zb2xlLmxvZygncG9wc3RhdGUnKTtcblx0XHRcdFx0cmV0dXJuIEltYmEuc2V0VGltZW91dCgwLGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0c2VsZjtcblx0fTtcblx0XG5cdGV4cG9ydHMuUm91dGVyID0gUm91dGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0Um91dGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXRoOyB9XG5cdFJvdXRlci5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRSb3V0ZXIuc2x1ZyA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCcnKS50b0xvd2VyQ2FzZSgpOyAvLyB0cmltXG5cdFx0Ly8gcmVtb3ZlIGFjY2VudHMsIHN3YXAgw7EgZm9yIG4sIGV0Y1xuXHRcdHZhciBmcm9tID0gXCLDoMOhw6TDosOlw6jDqcOrw6rDrMOtw6/DrsOyw7PDtsO0w7nDusO8w7vDscOnwrcvXyw6O1wiO1xuXHRcdHZhciB0byA9IFwiYWFhYWFlZWVlaWlpaW9vb291dXV1bmMtLS0tLS1cIjtcblx0XHRcblx0XHQvLyBmb3IgKHZhciBpPTAsIGw9ZnJvbS5sZW5ndGggOyBpPGwgOyBpKyspXG5cdFx0Ly8gXHRzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGZyb20uY2hhckF0KGkpLCAnZycpLCB0by5jaGFyQXQoaSkpXG5cdFx0XG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoL1teYS16MC05IC1dL2csJycpOyAvLyByZW1vdmUgaW52YWxpZCBjaGFyc1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9cXHMrL2csJy0nKTsgLy8gY29sbGFwc2Ugd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBieSAtXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoLy0rL2csJy0nKTsgLy8gY29sbGFwc2UgZGFzaGVzXG5cdFx0XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblx0XG5cdFJvdXRlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um91dGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcC5wYXRoKCk7XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYXBwLmhhc2goKTtcblx0fTtcblx0XG5cdFJvdXRlci5wcm90b3R5cGUuZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGgoKTtcblx0XHR2YXIgbSA9IHBhdGgubWF0Y2goL1xcLihbXlxcL10rKSQvKTtcblx0XHRyZXR1cm4gbSAmJiBtWzFdIHx8ICcnO1xuXHR9O1xuXHRcblx0Um91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChocmVmLHN0YXRlLHJlcGxhY2Upe1xuXHRcdGlmKHN0YXRlID09PSB1bmRlZmluZWQpIHN0YXRlID0ge307XG5cdFx0aWYocmVwbGFjZSA9PT0gdW5kZWZpbmVkKSByZXBsYWNlID0gZmFsc2U7XG5cdFx0aWYgKGhyZWYgPT0gJy9pbnN0YWxsJykge1xuXHRcdFx0Ly8gcmVkaXJlY3RzIGhlcmVcblx0XHRcdGhyZWYgPSAnL2d1aWRlcyN0b2MtZ2V0dGluZy1zdGFydGVkLWluc3RhbGxhdGlvbic7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAocmVwbGFjZSkge1xuXHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsbnVsbCxocmVmKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsbnVsbCxocmVmKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghaHJlZi5tYXRjaCgvXFwjLykpIHtcblx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLDApO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLnNjb3BlZCA9IGZ1bmN0aW9uIChyZWcscGFydCl7XG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGgoKSArICcjJyArIHRoaXMuaGFzaCgpO1xuXHRcdGlmICgodHlwZW9mIHJlZz09J3N0cmluZyd8fHJlZyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHZhciBueHQgPSBwYXRoW3JlZy5sZW5ndGhdO1xuXHRcdFx0cmV0dXJuIHBhdGguc3Vic3RyKDAscmVnLmxlbmd0aCkgPT0gcmVnICYmICghbnh0IHx8IG54dCA9PSAnLScgfHwgbnh0ID09ICcvJyB8fCBueHQgPT0gJyMnIHx8IG54dCA9PSAnPycgfHwgbnh0ID09ICdfJyk7XG5cdFx0fSBlbHNlIGlmIChyZWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdHZhciBtID0gcGF0aC5tYXRjaChyZWcpO1xuXHRcdFx0cmV0dXJuIHBhcnQgJiYgbSA/IChtW3BhcnRdKSA6IChtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHJlZyxwYXJ0KXtcblx0XHR2YXIgcGF0aCA9IHRoaXMucGF0aCgpICsgJyMnICsgdGhpcy5oYXNoKCk7XG5cdFx0XG5cdFx0aWYgKCh0eXBlb2YgcmVnPT0nc3RyaW5nJ3x8cmVnIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0cmV0dXJuIHBhdGggPT0gcmVnO1xuXHRcdH0gZWxzZSBpZiAocmVnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHR2YXIgbSA9IHBhdGgubWF0Y2gocmVnKTtcblx0XHRcdHJldHVybiBwYXJ0ICYmIG0gPyAobVtwYXJ0XSkgOiAobSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9O1xuXHRyZXR1cm4gUm91dGVyO1xuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcm91dGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRyZXF1aXJlKCcuL2Jhc2UnKTtcblx0cmVxdWlyZSgnLi9tYXJrZG93bicpO1xuXHRcblx0cmVxdWlyZSgnLi9zaXRlJyk7XG5cdHJlcXVpcmUoJy4vbmF2Jyk7XG5cdHJlcXVpcmUoJy4vcGFnZScpO1xuXHRyZXF1aXJlKCcuL2lzc3VlcycpO1xuXHRyZXF1aXJlKCcuL2hvbWUnKTtcblx0cmVxdWlyZSgnLi9ibG9nJyk7XG5cdHJlcXVpcmUoJy4vZ3VpZGVzJyk7XG5cdHJlcXVpcmUoJy4vZG9jcycpO1xuXHRyZXR1cm4gcmVxdWlyZSgnLi9zbmlwcGV0Jyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2luZGV4LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZXh0ZW5kVGFnKCdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm91dGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um91dGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvdXRlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0Ly8gZGVmIGh0bWw9IGh0bWxcblx0XHQvLyBcdEBkb206aW5uZXJIVE1MID0gaHRtbFxuXHRcdC8vIFx0c2VsZlxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHRtbCA9IGZ1bmN0aW9uIChodG1sKXtcblx0XHRcdGlmIChodG1sICE9IHRoaXMuX2h0bWwpIHtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB0aGlzLl9odG1sID0gaHRtbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAocm91dGUpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEFQUC5yb3V0ZXIoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVyb3V0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5mbGFnKCdzY29wZWQnLHRoaXMucm91dGVyKCkuc2NvcGVkKHRoaXMucm91dGUoKSx0aGlzKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdzZWxlY3RlZCcsdGhpcy5yb3V0ZXIoKS5tYXRjaCh0aGlzLnJvdXRlKCksdGhpcykpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0dGhpcy5jc3MoJ3RyYW5zZm9ybScsdmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY3NzKCd0cmFuc2Zvcm0nKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZXh0ZW5kVGFnKCdodG1sZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIdG1sID0gZnVuY3Rpb24gKGh0bWwpe1xuXHRcdFx0aWYgKGh0bWwgIT0gdGhpcy5faHRtbCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IHRoaXMuX2h0bWwgPSBodG1sO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5leHRlbmRUYWcoJ3NjcmlwdCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGlsZHJlbiA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IHZhbHVlO1xuXHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5leHRlbmRUYWcoJ2NhbnZhcycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kcHIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kcHIgfHwgKHRoaXMuX2RwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCl7XG5cdFx0XHRpZiAod2lkdGggIT0gdGhpcy5fd2lkdGgpIHtcblx0XHRcdFx0dGhpcy5kb20oKS53aWR0aCA9IHdpZHRoICogdGhpcy5kcHIoKTtcblx0XHRcdFx0dGhpcy5jc3Moe3dpZHRoOiB3aWR0aH0pO1xuXHRcdFx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KXtcblx0XHRcdGlmIChoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kcHIoKTtcblx0XHRcdFx0dGhpcy5jc3Moe2hlaWdodDogaGVpZ2h0fSk7XG5cdFx0XHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmV4dGVuZFRhZygnYScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yb3V0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JvdXRlIHx8IHRoaXMuaHJlZigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRhcCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmIChlLmV2ZW50KCkubWV0YUtleSB8fCBlLmV2ZW50KCkuYWx0S2V5KSB7XG5cdFx0XHRcdGUuX3Jlc3BvbmRlciA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmhyZWYoKVswXSA9PSAnIycgfHwgdGhpcy5ocmVmKClbMF0gPT0gJy8nKSB7XG5cdFx0XHRcdGUuY2FuY2VsKCkuaGFsdCgpO1xuXHRcdFx0XHR0aGlzLnJvdXRlcigpLmdvKHRoaXMuaHJlZigpLHt9KTtcblx0XHRcdFx0SW1iYS5FdmVudHMudHJpZ2dlcigncm91dGUnLHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZS5fcmVzcG9uZGVyID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnJlcm91dGUoKTtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvYmFzZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBmb3IgbWFya2Rvd24gcmVuZGVyaW5nXG5cdHRhZyQuZGVmaW5lVGFnKCdtZCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX3NyYyA9IHt3YXRjaDogJ3JlbG9hZCcsbmFtZTogJ3NyYyd9O1xuXHRcdHRhZy5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLnNyYygpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLHYpOyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5yZWxvYWQgJiYgdGhpcy5yZWxvYWQodixhLHRoaXMuX19zcmMpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2h0bWwgPSB7d2F0Y2g6ICdodG1sRGlkU2V0JyxuYW1lOiAnaHRtbCd9O1xuXHRcdHRhZy5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faHRtbDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHRtbCA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmh0bWwoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9odG1sID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuaHRtbERpZFNldCAmJiB0aGlzLmh0bWxEaWRTZXQodixhLHRoaXMuX19odG1sKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZG9jID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kb2M7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldERvYyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kb2MgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmdoc3JjID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKFwiaHR0cHM6Ly9naXRodWIuY29tL3NvbWViZWUvaW1iYS5pby9ibG9iL21hc3Rlci9kb2NzXCIgKyB0aGlzLnNyYygpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaHRtbERpZFNldCA9IGZ1bmN0aW9uIChodG1sKXtcblx0XHRcdHRoaXMuYm9keSgpLmRvbSgpLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHR0aGlzLnNldHVwKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoSW1iYS5TRVJWRVIpIHtcblx0XHRcdFx0QVBQLmZldGNoRG9jdW1lbnQoc2VsZi5zcmMoKSArICcubWQnLGZ1bmN0aW9uKGRvYykge1xuXHRcdFx0XHRcdHJldHVybiBzZWxmLmFzc2VtYmxlKGRvYyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmIChzZWxmLl9zbmlwcGV0cykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5fc25pcHBldHMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRhcnlbaV0uZW5kKCk7IC8vIHNpbXVsYXRlIHJlYWwgcmVuZGVyaW5nIGhlcmU/XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBub3Qgb24gZnJvbnRwYWdlPyFcblx0XHR0YWcucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKGRvYyl7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdtZCcpLnNldEh0bWwoZG9jLmJvZHkpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGFnLl9fc3VwZXJfXy5idWlsZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpICYmIHRoaXMuc3JjKCkpIHsgcmV0dXJuIHRoaXMucmVsb2FkKCkgfTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBsb2cgXCJhd2FrZW5lZCBtZCBmcm9tIGNsaWVudCghKVwiXG5cdFx0XHR0aGlzLl9zbmlwcGV0cyA9IHEkKCcuX3NuaXBwZXQnLHRoaXMpLnRvQXJyYXkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKGh0bWwpe1xuXHRcdFx0dGhpcy5fZG9tLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHR0aGlzLl9zbmlwcGV0cyA9IHEkKCcuX3NuaXBwZXQnLHRoaXMpLnRvQXJyYXkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmIChJbWJhLmlzQ2xpZW50KCkpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3JlbG9hZGluZyBtYXJrZG93bidcblx0XHRcdFx0c2VsZi5fc25pcHBldHMgPSBbXTtcblx0XHRcdFx0QVBQLmZldGNoRG9jdW1lbnQoc2VsZi5zcmMoKSArICcubWQnLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdyZXR1cm5lZCBmcm9tIG1hcmtkb3duIGhlcmU/IScscmVzXG5cdFx0XHRcdFx0c2VsZi5hc3NlbWJsZSgoc2VsZi5zZXREb2MocmVzKSxyZXMpKTtcblx0XHRcdFx0XHRzZWxmLl9zbmlwcGV0cyA9IHEkKCcuX3NuaXBwZXQnLHNlbGYpLnRvQXJyYXkoKTtcblx0XHRcdFx0XHRzZWxmLnBhcmVudCgpLmRvbSgpLnNjcm9sbFRvcCA9IDA7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0Ly8gZGVmaW5lIHJlbmRlcmVyXG5cdHZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcblx0dmFyIG1kciA9IG5ldyAobWFya2VkLlJlbmRlcmVyKSgpO1xuXHRcblx0bWRyLmhlYWRpbmcgPSBmdW5jdGlvbiAodGV4dCxsdmwpe1xuXHRcdHJldHVybiAoXCI8aFwiICsgbHZsICsgXCI+XCIgKyB0ZXh0ICsgXCI8L2hcIiArIGx2bCArIFwiPlwiKTtcblx0fTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnbWFya2VkJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlcmVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHJldHVybiB0aGlzLnNldENvbnRlbnQodGV4dCwwKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICh2YWwsdHlwKXtcblx0XHRcdGlmICh2YWwgIT0gdGhpcy5fY29udGVudCkge1xuXHRcdFx0XHR0aGlzLl9jb250ZW50ID0gdmFsO1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IG1hcmtlZCh2YWwse3JlbmRlcmVyOiBtZHJ9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvbWFya2Rvd24uaW1iYVxuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL15cXG4rLyxcbiAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICBmZW5jZXM6IG5vb3AsXG4gIGhyOiAvXiggKlstKl9dKXszLH0gKig/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpLyxcbiAgbnB0YWJsZTogbm9vcCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuICooPXwtKXsyLH0gKig/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rKFxcbig/IWRlZilbXlxcbl0rKSpcXG4qKSsvLFxuICBsaXN0OiAvXiggKikoYnVsbCkgW1xcc1xcU10rPyg/OmhyfGRlZnxcXG57Mix9KD8hICkoPyFcXDFidWxsIClcXG4qfFxccyokKS8sXG4gIGh0bWw6IC9eICooPzpjb21tZW50ICooPzpcXG58XFxzKiQpfGNsb3NlZCAqKD86XFxuezIsfXxcXHMqJCl8Y2xvc2luZyAqKD86XFxuezIsfXxcXHMqJCkpLyxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wLFxuICBwYXJhZ3JhcGg6IC9eKCg/OlteXFxuXStcXG4/KD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfHRhZ3xkZWYpKSspXFxuKi8sXG4gIHRleHQ6IC9eW15cXG5dKy9cbn07XG5cbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGQrXFwuKS87XG5ibG9jay5pdGVtID0gL14oICopKGJ1bGwpIFteXFxuXSooPzpcXG4oPyFcXDFidWxsIClbXlxcbl0qKSovO1xuYmxvY2suaXRlbSA9IHJlcGxhY2UoYmxvY2suaXRlbSwgJ2dtJylcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCk7XG5cbmJsb2NrLmxpc3QgPSByZXBsYWNlKGJsb2NrLmxpc3QpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86Wy0qX10gKil7Myx9KD86XFxcXG4rfCQpKScpXG4gICgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IHJlcGxhY2UoYmxvY2suYmxvY2txdW90ZSlcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG5ibG9jay5fdGFnID0gJyg/ISg/OidcbiAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGUnXG4gICsgJ3x2YXJ8c2FtcHxrYmR8c3VifHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkbydcbiAgKyAnfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfFteXFxcXHdcXFxcc0BdKkApXFxcXGInO1xuXG5ibG9jay5odG1sID0gcmVwbGFjZShibG9jay5odG1sKVxuICAoJ2NvbW1lbnQnLCAvPCEtLVtcXHNcXFNdKj8tLT4vKVxuICAoJ2Nsb3NlZCcsIC88KHRhZylbXFxzXFxTXSs/PFxcL1xcMT4vKVxuICAoJ2Nsb3NpbmcnLCAvPHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8pXG4gICgvdGFnL2csIGJsb2NrLl90YWcpXG4gICgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCdocicsIGJsb2NrLmhyKVxuICAoJ2hlYWRpbmcnLCBibG9jay5oZWFkaW5nKVxuICAoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICgnYmxvY2txdW90ZScsIGJsb2NrLmJsb2NrcXVvdGUpXG4gICgndGFnJywgJzwnICsgYmxvY2suX3RhZylcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2subm9ybWFsID0gbWVyZ2Uoe30sIGJsb2NrKTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IG1lcmdlKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgZmVuY2VzOiAvXiAqKGB7Myx9fH57Myx9KVsgXFwuXSooXFxTKyk/ICpcXG4oW1xcc1xcU10qPylcXHMqXFwxICooPzpcXG4rfCQpLyxcbiAgcGFyYWdyYXBoOiAvXi8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSArKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvXG59KTtcblxuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJyg/IScsICcoPyEnXG4gICAgKyBibG9jay5nZm0uZmVuY2VzLnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMicpICsgJ3wnXG4gICAgKyBibG9jay5saXN0LnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMycpICsgJ3wnKVxuICAoKTtcblxuLyoqXG4gKiBHRk0gKyBUYWJsZXMgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLnRhYmxlcyA9IG1lcmdlKHt9LCBibG9jay5nZm0sIHtcbiAgbnB0YWJsZTogL14gKihcXFMuKlxcfC4qKVxcbiAqKFstOl0rICpcXHxbLXwgOl0qKVxcbigoPzouKlxcfC4qKD86XFxufCQpKSopXFxuKi8sXG4gIHRhYmxlOiAvXiAqXFx8KC4rKVxcbiAqXFx8KCAqWy06XStbLXwgOl0qKVxcbigoPzogKlxcfC4qKD86XFxufCQpKSopXFxuKi9cbn0pO1xuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cblxuZnVuY3Rpb24gTGV4ZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2Vucy5saW5rcyA9IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5ydWxlcyA9IGJsb2NrLm5vcm1hbDtcblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGFibGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2sudGFibGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2suZ2ZtO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBCbG9jayBSdWxlc1xuICovXG5cbkxleGVyLnJ1bGVzID0gYmxvY2s7XG5cbi8qKlxuICogU3RhdGljIExleCBNZXRob2RcbiAqL1xuXG5MZXhlci5sZXggPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG59O1xuXG4vKipcbiAqIFByZXByb2Nlc3NpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHNyYyA9IHNyY1xuICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJylcbiAgICAucmVwbGFjZSgvXFx1MjQyNC9nLCAnXFxuJyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4oc3JjLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTGV4aW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLnRva2VuID0gZnVuY3Rpb24oc3JjLCB0b3AsIGJxKSB7XG4gIHZhciBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpXG4gICAgLCBuZXh0XG4gICAgLCBsb29zZVxuICAgICwgY2FwXG4gICAgLCBidWxsXG4gICAgLCBiXG4gICAgLCBpdGVtXG4gICAgLCBzcGFjZVxuICAgICwgaVxuICAgICwgbDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gbmV3bGluZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLm5ld2xpbmUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdzcGFjZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gezR9L2dtLCAnJyk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgPyBjYXAucmVwbGFjZSgvXFxuKyQvLCAnJylcbiAgICAgICAgICA6IGNhcFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmZW5jZXMgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5mZW5jZXMuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgbGFuZzogY2FwWzJdLFxuICAgICAgICB0ZXh0OiBjYXBbM10gfHwgJydcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IGNhcFsyXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLm5wdGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV0uc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdocidcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYmxvY2txdW90ZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrcXVvdGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfc3RhcnQnXG4gICAgICB9KTtcblxuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuXG4gICAgICAvLyBQYXNzIGB0b3BgIHRvIGtlZXAgdGhlIGN1cnJlbnRcbiAgICAgIC8vIFwidG9wbGV2ZWxcIiBzdGF0ZS4gVGhpcyBpcyBleGFjdGx5XG4gICAgICAvLyBob3cgbWFya2Rvd24ucGwgd29ya3MuXG4gICAgICB0aGlzLnRva2VuKGNhcCwgdG9wLCB0cnVlKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaXN0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGlzdC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBidWxsID0gY2FwWzJdO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3Rfc3RhcnQnLFxuICAgICAgICBvcmRlcmVkOiBidWxsLmxlbmd0aCA+IDFcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbS5cbiAgICAgIGNhcCA9IGNhcFswXS5tYXRjaCh0aGlzLnJ1bGVzLml0ZW0pO1xuXG4gICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICBsID0gY2FwLmxlbmd0aDtcbiAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVtID0gY2FwW2ldO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgIC8vIHNvIGl0IGlzIHNlZW4gYXMgdGhlIG5leHQgdG9rZW4uXG4gICAgICAgIHNwYWNlID0gaXRlbS5sZW5ndGg7XG4gICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrXFwuKSArLywgJycpO1xuXG4gICAgICAgIC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgIC8vIGxpc3QgaXRlbSBjb250YWlucy4gSGFja3kuXG4gICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICBzcGFjZSAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJylcbiAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydExpc3RzICYmIGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgYiA9IGJsb2NrLmJ1bGxldC5leGVjKGNhcFtpICsgMV0pWzBdO1xuICAgICAgICAgIGlmIChidWxsICE9PSBiICYmICEoYnVsbC5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICAgIHNyYyA9IGNhcC5zbGljZShpICsgMSkuam9pbignXFxuJykgKyBzcmM7XG4gICAgICAgICAgICBpID0gbCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbSBpcyBsb29zZSBvciBub3QuXG4gICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgIC8vIGZvciBkaXNjb3VudCBiZWhhdmlvci5cbiAgICAgICAgbG9vc2UgPSBuZXh0IHx8IC9cXG5cXG4oPyFcXHMqJCkvLnRlc3QoaXRlbSk7XG4gICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgIG5leHQgPSBpdGVtLmNoYXJBdChpdGVtLmxlbmd0aCAtIDEpID09PSAnXFxuJztcbiAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBsb29zZVxuICAgICAgICAgICAgPyAnbG9vc2VfaXRlbV9zdGFydCdcbiAgICAgICAgICAgIDogJ2xpc3RfaXRlbV9zdGFydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgdGhpcy50b2tlbihpdGVtLCBmYWxzZSwgYnEpO1xuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fZW5kJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBodG1sXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHRtbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgICAgPyAncGFyYWdyYXBoJ1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgJiYgKGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScpLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVmXG4gICAgaWYgKCghYnEgJiYgdG9wKSAmJiAoY2FwID0gdGhpcy5ydWxlcy5kZWYuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLmxpbmtzW2NhcFsxXS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoLyg/OiAqXFx8ICopP1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldXG4gICAgICAgICAgLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKVxuICAgICAgICAgIC5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5wYXJhZ3JhcGguZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgOiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICAvLyBUb3AtbGV2ZWwgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnRva2Vucztcbn07XG5cbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbXFxcXGAqe31cXFtcXF0oKSMrXFwtLiFfPl0pLyxcbiAgYXV0b2xpbms6IC9ePChbXiA+XSsoQHw6XFwvKVteID5dKyk+LyxcbiAgdXJsOiBub29wLFxuICB0YWc6IC9ePCEtLVtcXHNcXFNdKj8tLT58XjxcXC8/XFx3Kyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8sXG4gIGxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxcKGhyZWZcXCkvLFxuICByZWZsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKCg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dKSopXFxdLyxcbiAgc3Ryb25nOiAvXl9fKFtcXHNcXFNdKz8pX18oPyFfKXxeXFwqXFwqKFtcXHNcXFNdKz8pXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXlxcYl8oKD86W15fXXxfXykrPylfXFxifF5cXCooKD86XFwqXFwqfFtcXHNcXFNdKSs/KVxcKig/IVxcKikvLFxuICBjb2RlOiAvXihgKylcXHMqKFtcXHNcXFNdKj9bXmBdKVxccypcXDEoPyFgKS8sXG4gIGJyOiAvXiB7Mix9XFxuKD8hXFxzKiQpLyxcbiAgZGVsOiBub29wLFxuICB0ZXh0OiAvXltcXHNcXFNdKz8oPz1bXFxcXDwhXFxbXypgXXwgezIsfVxcbnwkKS9cbn07XG5cbmlubGluZS5faW5zaWRlID0gLyg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dfFxcXSg/PVteXFxbXSpcXF0pKSovO1xuaW5saW5lLl9ocmVmID0gL1xccyo8PyhbXFxzXFxTXSo/KT4/KD86XFxzK1snXCJdKFtcXHNcXFNdKj8pWydcIl0pP1xccyovO1xuXG5pbmxpbmUubGluayA9IHJlcGxhY2UoaW5saW5lLmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgnaHJlZicsIGlubGluZS5faHJlZilcbiAgKCk7XG5cbmlubGluZS5yZWZsaW5rID0gcmVwbGFjZShpbmxpbmUucmVmbGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCk7XG5cbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLm5vcm1hbCA9IG1lcmdlKHt9LCBpbmxpbmUpO1xuXG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLnBlZGFudGljID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgc3Ryb25nOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXyl8XlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopL1xufSk7XG5cbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmdmbSA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIGVzY2FwZTogcmVwbGFjZShpbmxpbmUuZXNjYXBlKSgnXSknLCAnfnxdKScpKCksXG4gIHVybDogL14oaHR0cHM/OlxcL1xcL1teXFxzPF0rW148Liw6O1wiJylcXF1cXHNdKS8sXG4gIGRlbDogL15+fig/PVxcUykoW1xcc1xcU10qP1xcUyl+fi8sXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLnRleHQpXG4gICAgKCddfCcsICd+XXwnKVxuICAgICgnfCcsICd8aHR0cHM/Oi8vfCcpXG4gICAgKClcbn0pO1xuXG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmJyZWFrcyA9IG1lcmdlKHt9LCBpbmxpbmUuZ2ZtLCB7XG4gIGJyOiByZXBsYWNlKGlubGluZS5icikoJ3syLH0nLCAnKicpKCksXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLmdmbS50ZXh0KSgnezIsfScsICcqJykoKVxufSk7XG5cbi8qKlxuICogSW5saW5lIExleGVyICYgQ29tcGlsZXJcbiAqL1xuXG5mdW5jdGlvbiBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5saW5rcyA9IGxpbmtzO1xuICB0aGlzLnJ1bGVzID0gaW5saW5lLm5vcm1hbDtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBpZiAoIXRoaXMubGlua3MpIHtcbiAgICB0aHJvdyBuZXdcbiAgICAgIEVycm9yKCdUb2tlbnMgYXJyYXkgcmVxdWlyZXMgYSBgbGlua3NgIHByb3BlcnR5LicpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5icmVha3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuZ2ZtO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICB0aGlzLnJ1bGVzID0gaW5saW5lLnBlZGFudGljO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIElubGluZSBSdWxlc1xuICovXG5cbklubGluZUxleGVyLnJ1bGVzID0gaW5saW5lO1xuXG4vKipcbiAqIFN0YXRpYyBMZXhpbmcvQ29tcGlsaW5nIE1ldGhvZFxuICovXG5cbklubGluZUxleGVyLm91dHB1dCA9IGZ1bmN0aW9uKHNyYywgbGlua3MsIG9wdGlvbnMpIHtcbiAgdmFyIGlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucyk7XG4gIHJldHVybiBpbmxpbmUub3V0cHV0KHNyYyk7XG59O1xuXG4vKipcbiAqIExleGluZy9Db21waWxpbmdcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbGlua1xuICAgICwgdGV4dFxuICAgICwgaHJlZlxuICAgICwgY2FwO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBlc2NhcGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lc2NhcGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGNhcFsxXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGF1dG9saW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYXV0b2xpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgIHRleHQgPSBjYXBbMV0uY2hhckF0KDYpID09PSAnOidcbiAgICAgICAgICA/IHRoaXMubWFuZ2xlKGNhcFsxXS5zdWJzdHJpbmcoNykpXG4gICAgICAgICAgOiB0aGlzLm1hbmdsZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGhpcy5tYW5nbGUoJ21haWx0bzonKSArIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHVybCAoZ2ZtKVxuICAgIGlmICghdGhpcy5pbkxpbmsgJiYgKGNhcCA9IHRoaXMucnVsZXMudXJsLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICBocmVmID0gdGV4dDtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50YWcuZXhlYyhzcmMpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKVxuICAgICAgICA6IGNhcFswXVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBsaW5rID0gdGhpcy5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHNyYyA9IGNhcFswXS5zdWJzdHJpbmcoMSkgKyBzcmM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0cm9uZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnN0cm9uZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZW1cbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLCB0cnVlKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBiclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWwgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5kZWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZGVsKHRoaXMub3V0cHV0KGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGV4dChlc2NhcGUodGhpcy5zbWFydHlwYW50cyhjYXBbMF0pKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb21waWxlIExpbmtcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0TGluayA9IGZ1bmN0aW9uKGNhcCwgbGluaykge1xuICB2YXIgaHJlZiA9IGVzY2FwZShsaW5rLmhyZWYpXG4gICAgLCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuXG4gIHJldHVybiBjYXBbMF0uY2hhckF0KDApICE9PSAnISdcbiAgICA/IHRoaXMucmVuZGVyZXIubGluayhocmVmLCB0aXRsZSwgdGhpcy5vdXRwdXQoY2FwWzFdKSlcbiAgICA6IHRoaXMucmVuZGVyZXIuaW1hZ2UoaHJlZiwgdGl0bGUsIGVzY2FwZShjYXBbMV0pKTtcbn07XG5cbi8qKlxuICogU21hcnR5cGFudHMgVHJhbnNmb3JtYXRpb25zXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLnNtYXJ0eXBhbnRzID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zbWFydHlwYW50cykgcmV0dXJuIHRleHQ7XG4gIHJldHVybiB0ZXh0XG4gICAgLy8gZW0tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tLS9nLCAnXFx1MjAxNCcpXG4gICAgLy8gZW4tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tL2csICdcXHUyMDEzJylcbiAgICAvLyBvcGVuaW5nIHNpbmdsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgJyQxXFx1MjAxOCcpXG4gICAgLy8gY2xvc2luZyBzaW5nbGVzICYgYXBvc3Ryb3BoZXNcbiAgICAucmVwbGFjZSgvJy9nLCAnXFx1MjAxOScpXG4gICAgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csICckMVxcdTIwMWMnKVxuICAgIC8vIGNsb3NpbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC9cIi9nLCAnXFx1MjAxZCcpXG4gICAgLy8gZWxsaXBzZXNcbiAgICAucmVwbGFjZSgvXFwuezN9L2csICdcXHUyMDI2Jyk7XG59O1xuXG4vKipcbiAqIE1hbmdsZSBMaW5rc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5tYW5nbGUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLm1hbmdsZSkgcmV0dXJuIHRleHQ7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbCA9IHRleHQubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgY2g7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgY2ggPSAneCcgKyBjaC50b1N0cmluZygxNik7XG4gICAgfVxuICAgIG91dCArPSAnJiMnICsgY2ggKyAnOyc7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbihjb2RlLCBsYW5nLCBlc2NhcGVkKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICBjb2RlID0gb3V0O1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGFuZykge1xuICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICsgJ1xcbjwvY29kZT48L3ByZT4nO1xuICB9XG5cbiAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXhcbiAgICArIGVzY2FwZShsYW5nLCB0cnVlKVxuICAgICsgJ1wiPidcbiAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICArICdcXG48L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ibG9ja3F1b3RlID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaGVhZGluZyA9IGZ1bmN0aW9uKHRleHQsIGxldmVsLCByYXcpIHtcbiAgcmV0dXJuICc8aCdcbiAgICArIGxldmVsXG4gICAgKyAnIGlkPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeFxuICAgICsgcmF3LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15cXHddKy9nLCAnLScpXG4gICAgKyAnXCI+J1xuICAgICsgdGV4dFxuICAgICsgJzwvaCdcbiAgICArIGxldmVsXG4gICAgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKGJvZHksIG9yZGVyZWQpIHtcbiAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gIHJldHVybiAnPCcgKyB0eXBlICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3RpdGVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucGFyYWdyYXBoID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxwPicgKyB0ZXh0ICsgJzwvcD5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24oaGVhZGVyLCBib2R5KSB7XG4gIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICArICc8dGhlYWQ+XFxuJ1xuICAgICsgaGVhZGVyXG4gICAgKyAnPC90aGVhZD5cXG4nXG4gICAgKyAnPHRib2R5PlxcbidcbiAgICArIGJvZHlcbiAgICArICc8L3Rib2R5PlxcbidcbiAgICArICc8L3RhYmxlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVyb3cgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZWNlbGwgPSBmdW5jdGlvbihjb250ZW50LCBmbGFncykge1xuICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICB2YXIgdGFnID0gZmxhZ3MuYWxpZ25cbiAgICA/ICc8JyArIHR5cGUgKyAnIHN0eWxlPVwidGV4dC1hbGlnbjonICsgZmxhZ3MuYWxpZ24gKyAnXCI+J1xuICAgIDogJzwnICsgdHlwZSArICc+JztcbiAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cbi8vIHNwYW4gbGV2ZWwgcmVuZGVyZXJcblJlbmRlcmVyLnByb3RvdHlwZS5zdHJvbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxlbT4nICsgdGV4dCArICc8L2VtPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZXNwYW4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGNvZGU+JyArIHRleHQgKyAnPC9jb2RlPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYnIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxkZWw+JyArIHRleHQgKyAnPC9kZWw+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3Ol0vZywgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG4gIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiB0ZXh0O1xufTtcblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucywgcmVuZGVyZXIpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucywgcmVuZGVyZXIpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyYyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExvb3BcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIHRoaXMuaW5saW5lID0gbmV3IElubGluZUxleGVyKHNyYy5saW5rcywgdGhpcy5vcHRpb25zLCB0aGlzLnJlbmRlcmVyKTtcbiAgdGhpcy50b2tlbnMgPSBzcmMucmV2ZXJzZSgpO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgd2hpbGUgKHRoaXMubmV4dCgpKSB7XG4gICAgb3V0ICs9IHRoaXMudG9rKCk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2VuID0gdGhpcy50b2tlbnMucG9wKCk7XG59O1xuXG4vKipcbiAqIFByZXZpZXcgTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMDtcbn07XG5cbi8qKlxuICogUGFyc2UgVGV4dCBUb2tlbnNcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYm9keSA9IHRoaXMudG9rZW4udGV4dDtcblxuICB3aGlsZSAodGhpcy5wZWVrKCkudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYm9keSArPSAnXFxuJyArIHRoaXMubmV4dCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pbmxpbmUub3V0cHV0KGJvZHkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBDdXJyZW50IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS50b2sgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLnRva2VuLnR5cGUpIHtcbiAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY2FzZSAnaHInOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgIH1cbiAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaGVhZGluZyhcbiAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCksXG4gICAgICAgIHRoaXMudG9rZW4uZGVwdGgsXG4gICAgICAgIHRoaXMudG9rZW4udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jb2RlKHRoaXMudG9rZW4udGV4dCxcbiAgICAgICAgdGhpcy50b2tlbi5sYW5nLFxuICAgICAgICB0aGlzLnRva2VuLmVzY2FwZWQpO1xuICAgIH1cbiAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgIHZhciBoZWFkZXIgPSAnJ1xuICAgICAgICAsIGJvZHkgPSAnJ1xuICAgICAgICAsIGlcbiAgICAgICAgLCByb3dcbiAgICAgICAgLCBjZWxsXG4gICAgICAgICwgZmxhZ3NcbiAgICAgICAgLCBqO1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGNlbGwgPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyA9IHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9O1xuICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLmhlYWRlcltpXSksXG4gICAgICAgICAgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSB0aGlzLnRva2VuLmNlbGxzW2ldO1xuXG4gICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQocm93W2pdKSxcbiAgICAgICAgICAgIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25bal0gfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdibG9ja3F1b3RlX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdibG9ja3F1b3RlX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJ1xuICAgICAgICAsIG9yZGVyZWQgPSB0aGlzLnRva2VuLm9yZGVyZWQ7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkKTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rZW4udHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgPyB0aGlzLnBhcnNlVGV4dCgpXG4gICAgICAgICAgOiB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbG9vc2VfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIHZhciBodG1sID0gIXRoaXMudG9rZW4ucHJlICYmICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgPyB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KVxuICAgICAgICA6IHRoaXMudG9rZW4udGV4dDtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmh0bWwoaHRtbCk7XG4gICAgfVxuICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZVRleHQoKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gIHJldHVybiBodG1sXG4gICAgLnJlcGxhY2UoIWVuY29kZSA/IC8mKD8hIz9cXHcrOykvZyA6IC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgvJihbI1xcd10rKTsvZywgZnVuY3Rpb24oXywgbikge1xuICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG4gICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnXG4gICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKVxuICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgb3B0KSB7XG4gIHJlZ2V4ID0gcmVnZXguc291cmNlO1xuICBvcHQgPSBvcHQgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbiBzZWxmKG5hbWUsIHZhbCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLyhefFteXFxbXSlcXF4vZywgJyQxJyk7XG4gICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxubm9vcC5leGVjID0gbm9vcDtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gIHZhciBpID0gMVxuICAgICwgdGFyZ2V0XG4gICAgLCBrZXk7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBNYXJrZWRcbiAqL1xuXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayB8fCB0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG5cbiAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodFxuICAgICAgLCB0b2tlbnNcbiAgICAgICwgcGVuZGluZ1xuICAgICAgLCBpID0gMDtcblxuICAgIHRyeSB7XG4gICAgICB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIHBlbmRpbmcgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IFBhcnNlci5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG5cbiAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBjYWxsYmFjayhlcnIpXG4gICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICB9O1xuXG4gICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG5cbiAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICBmb3IgKDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgaWYgKGNvZGUgPT0gbnVsbCB8fCBjb2RlID09PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSh0b2tlbnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHQpIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShMZXhlci5sZXgoc3JjLCBvcHQpLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkLic7XG4gICAgaWYgKChvcHQgfHwgbWFya2VkLmRlZmF1bHRzKS5zaWxlbnQpIHtcbiAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJlZDo8L3A+PHByZT4nXG4gICAgICAgICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICArICc8L3ByZT4nO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9uc1xuICovXG5cbm1hcmtlZC5vcHRpb25zID1cbm1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0KSB7XG4gIG1lcmdlKG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgcmV0dXJuIG1hcmtlZDtcbn07XG5cbm1hcmtlZC5kZWZhdWx0cyA9IHtcbiAgZ2ZtOiB0cnVlLFxuICB0YWJsZXM6IHRydWUsXG4gIGJyZWFrczogZmFsc2UsXG4gIHBlZGFudGljOiBmYWxzZSxcbiAgc2FuaXRpemU6IGZhbHNlLFxuICBzYW5pdGl6ZXI6IG51bGwsXG4gIG1hbmdsZTogdHJ1ZSxcbiAgc21hcnRMaXN0czogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG4gIGhpZ2hsaWdodDogbnVsbCxcbiAgbGFuZ1ByZWZpeDogJ2xhbmctJyxcbiAgc21hcnR5cGFudHM6IGZhbHNlLFxuICBoZWFkZXJQcmVmaXg6ICcnLFxuICByZW5kZXJlcjogbmV3IFJlbmRlcmVyLFxuICB4aHRtbDogZmFsc2Vcbn07XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubWFya2VkLlBhcnNlciA9IFBhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBQYXJzZXIucGFyc2U7XG5cbm1hcmtlZC5SZW5kZXJlciA9IFJlbmRlcmVyO1xuXG5tYXJrZWQuTGV4ZXIgPSBMZXhlcjtcbm1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcblxubWFya2VkLklubGluZUxleGVyID0gSW5saW5lTGV4ZXI7XG5tYXJrZWQuaW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlci5vdXRwdXQ7XG5cbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IG1hcmtlZDtcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIG1hcmtlZDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLm1hcmtlZCA9IG1hcmtlZDtcbn1cblxufSkuY2FsbChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKTtcbn0oKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tYXJrZWQvbGliL21hcmtlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0dGFnJC5kZWZpbmVUYWcoJ3NpdGUnLCAnaHRtbCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZXBzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kZXBzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREZXBzID0gZnVuY3Rpb24odil7IHRoaXMuX2RlcHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0YWckLiRoZWFkKCkuc2V0Q29udGVudChbXG5cdFx0XHRcdHRhZyQuJHRpdGxlKCkuc2V0VGV4dChcImltYmFcIikuZW5kKCksXG5cdFx0XHRcdHRhZyQuJG1ldGEoKS5zZXRDaGFyc2V0KFwidXRmLThcIikuZW5kKCksXG5cdFx0XHRcdHRhZyQuJG1ldGEoKS5zZXROYW1lKFwidmlld3BvcnRcIikuc2V0Q29udGVudChcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsbWluaW11bS1zY2FsZT0xXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0TmFtZShcIkRlc2NyaXB0aW9uXCIpLnNldENvbnRlbnQoXCJJbWJhIGlzIGEgcmljaCBwcm9ncmFtbWluZyBsYW5ndWFnZSBmb3IgdGhlIHdlYi5cIikuZW5kKCksXG5cdFx0XHRcdHRhZyQuJG1ldGEoKS5zZXROYW1lKFwia2V5d29yZHNcIikuc2V0Q29udGVudChcImltYmEgamF2YXNjcmlwdCBsYW5ndWFnZSBqc1wiKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kbGluaygpLnNldEhyZWYoJ2h0dHA6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNvdXJjZStDb2RlK1Bybzo0MDAsNTAwLDYwMCcpLnNldFJlbCgnc3R5bGVzaGVldCcpLnNldFR5cGUoJ3RleHQvY3NzJykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGxpbmsoKS5zZXRSZWwoXCJzdHlsZXNoZWV0XCIpLnNldEhyZWYoXCIvY3NzL3NpdGUuY3NzXCIpLnNldE1lZGlhKFwic2NyZWVuXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRzY3JpcHQoKS5zZXRUZXh0KCdERVBTID0ge307JykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJHNjcmlwdCgpLnNldFNyYyhcIi92ZW5kb3IvZ2EuanNcIikuZW5kKClcblx0XHRcdF0sMikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0YWckLiRib2R5KCkuc2V0SWQoJ3NpdGUnKS5zZXRDb250ZW50KFtcblx0XHRcdFx0dGFnJC4kc2l0ZV9uYXYoKS5zZXRJZCgnaGVhZGVyJykuZmxhZygnYXdha2VuJykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGhvbWUoKS5zZXRSb3V0ZSgnL2hvbWUnKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kZ3VpZGVzKCkuc2V0Um91dGUoJy9ndWlkZXMnKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kZG9jcygpLnNldFJvdXRlKCcvZG9jcycpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRibG9nKCkuc2V0Um91dGUoJy9ibG9nJykuZW5kKClcblx0XHRcdF0sMikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNjcmlwdHMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgdDA7XG5cdFx0XHRyZXR1cm4gdGFnJC4kZGl2KCkuZmxhZygnc2NyaXB0cycpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQoZnVuY3Rpb24odDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBvID0gc2VsZi5kZXBzKCksIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMobyksIGwgPSBrZXlzLmxlbmd0aCwgcmVzID0gW107IGkgPCBsOyBpKyspe1xuXHRcdFx0XHRcdFx0cmVzLnB1c2godGFnJC4kc2NyaXB0KCkuc2V0VHlwZShcInRleHQvamF2YXNjcmlwdFwiKS5zZXRTcmMoKGtleXNbaV0gKyAnLmRlcCcpKS5lbmQoKSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9KSh0MCksXG5cdFx0XHRcdHRhZyQuJHNjcmlwdCgpLnNldFNyYyhcIi92ZW5kb3IvaGwuanNcIikuZW5kKCksXG5cdFx0XHRcdHRhZyQuJHNjcmlwdCgpLnNldFNyYyhcIi9jbGllbnQuanNcIikuZW5kKClcblx0XHRcdF0sMCkuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gZGlydHkgd29ya2Fyb3VuZHNcblx0XHRcdEFQUC5zZXRTaXRlKHRoaXMpO1xuXHRcdFx0dGhpcy5zZXREZXBzKHtcblx0XHRcdFx0XCIvaXNzdWVzL2FsbC5qc29uXCI6IHRydWVcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRBUFAuZmV0Y2hEb2N1bWVudCgnL2d1aWRlcy5tZCcpO1xuXHRcdFx0QVBQLmZldGNoRG9jdW1lbnQoJy9ibG9nLmpzb24nKTtcblx0XHRcdHZhciBib2R5ID0gdGhpcy5ib2R5KCk7XG5cdFx0XHRib2R5LmFwcGVuZCh0aGlzLnNjcmlwdHMoKSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuZmxhZygnbGlnaHQnKS5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHRoaXMuaGVhZCgpLFxuXHRcdFx0XHRib2R5XG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdFx0QVBQLnNldFNpdGUobnVsbCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3NpdGUtbmF2JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvZ2dsZU1lbnUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBxJCQoJ2JvZHknKS50b2dnbGVGbGFnKCdtZW51Jyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0Nztcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFxuXHRcdFx0XHQodDAgPSB0aGlzLiRhPXRoaXMuJGEgfHwgdGFnJC4kbmF2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGEoKS5mbGFnKCdtZW51Jykuc2V0SGFuZGxlcigndGFwJywndG9nZ2xlTWVudScsdGhpcykpLnNldENvbnRlbnQoKHQxLiQkYSA9IHQxLiQkYSB8fCB0YWckLiRiKCkpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MiA9IHQwLiQkYj10MC4kJGIgfHwgdGFnJC4kYSgpLmZsYWcoJ3RhYicpLmZsYWcoJ2xvZ28nKS5zZXRIcmVmKCcvaG9tZScpKS5zZXRDb250ZW50KCh0Mi4kJGEgPSB0Mi4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdpbWJhJykuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0KHQwLiQkYyA9IHQwLiQkYyB8fCB0YWckLiRzcGFuKCkuZmxhZygnZ3JlZWR5JykpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MyA9IHQwLiQkZD10MC4kJGQgfHwgdGFnJC4kYSgpLmZsYWcoJ3RhYicpLmZsYWcoJ2hvbWUnKS5zZXRIcmVmKCcvaG9tZScpKS5zZXRDb250ZW50KCh0My4kJGEgPSB0My4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdob21lJykuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0KHQ0ID0gdDAuJCRlPXQwLiQkZSB8fCB0YWckLiRhKCkuZmxhZygndGFiJykuZmxhZygnZ3VpZGVzJykuc2V0SHJlZignL2d1aWRlcycpKS5zZXRDb250ZW50KCh0NC4kJGEgPSB0NC4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdndWlkZXMnKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDUgPSB0MC4kJGY9dDAuJCRmIHx8IHRhZyQuJGEoKS5mbGFnKCd0YWInKS5mbGFnKCdkb2NzJykuc2V0SHJlZignL2RvY3MnKSkuc2V0Q29udGVudCgodDUuJCRhID0gdDUuJCRhIHx8IHRhZyQuJGkoKSkuc2V0VGV4dCgnZG9jcycpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0NiA9IHQwLiQkZz10MC4kJGcgfHwgdGFnJC4kYSgpLmZsYWcoJ3RhYicpLmZsYWcoJ2Jsb2cnKS5zZXRIcmVmKCcvYmxvZycpKS5zZXRDb250ZW50KCh0Ni4kJGEgPSB0Ni4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdibG9nJykuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQ3ID0gdDAuJCRoPXQwLiQkaCB8fCB0YWckLiRhKCkuZmxhZygnZ2l0aHViJykuc2V0SHJlZignaHR0cHM6Ly9naXRodWIuY29tL3NvbWViZWUvaW1iYScpKS5zZXRDb250ZW50KCh0Ny4kJGEgPSB0Ny4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdnaXRodWInKS5lbmQoKSwyKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHQsMikuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2NoZWR1bGUoe2ZwczogMH0pO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9zaXRlLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ25hdm1lbnUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25yb3V0ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbWVudScpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbmF2LWxpc3QnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCduYXYtbGluaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIcmVmID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdocmVmJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKCh0MCA9IHRoaXMuJGE9dGhpcy4kYSB8fCB0YWckLiRhKCkpLnNldEhyZWYodGhpcy5ocmVmKCkpLnNldENvbnRlbnQodGhpcy5fY29udGVudCwzKS5lbmQoKSwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygndG9jJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudG9nZ2xlRmxhZygnY29sbGFwc2VkJyk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL25hdi5pbWJhXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdwYWdlJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAodGhpcy5fYm9keSA9IHRoaXMuX2JvZHkgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdib2R5Jyx0aGlzKSkuc2V0VGV4dChcIkNvbnRlbnQgaGVyZVwiKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmF2ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX25hdiA9IHRoaXMuX25hdiB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ25hdicsdGhpcykpLnNldFRleHQoXCJOYXZpZ2F0aW9uIGhlcmVcIikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHRoaXMubmF2KCksXG5cdFx0XHRcdHRoaXMuYm9keSgpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gbG9nICdyZW5kZXIgcGFnZScscm91dGVcblx0XHRcdHZhciBzY29wZWQgPSB0aGlzLnJvdXRlcigpLnNjb3BlZCh0aGlzLnJvdXRlKCksdGhpcyk7XG5cdFx0XHR0aGlzLmZsYWcoJ3Njb3BlZCcsc2NvcGVkKTtcblx0XHRcdHRoaXMuZmxhZygnc2VsZWN0ZWQnLHRoaXMucm91dGVyKCkubWF0Y2godGhpcy5yb3V0ZSgpLHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoc2NvcGVkICYmIHRoaXMucmVhZHkoKSkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdHJldHVybiB0aGlzLmFzc2VtYmxlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2NoZWR1bGUoe2ZwczogMX0pO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9wYWdlLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdGZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpe1xuXHRcdHZhciBjb3VudGVyID0gYXJyYXkubGVuZ3RoLHRlbXAsaW5kZXg7XG5cdFx0XG5cdFx0Ly8gV2hpbGUgdGhlcmUgYXJlIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuXHRcdHdoaWxlIChjb3VudGVyID4gMCl7XG5cdFx0XHQvLyBQaWNrIGEgcmFuZG9tIGluZGV4XG5cdFx0XHRpbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvdW50ZXIpO1xuXHRcdFx0Y291bnRlci0tOyAvLyBEZWNyZWFzZSBjb3VudGVyIGJ5IDFcblx0XHRcdFxuXHRcdFx0Ly8gQW5kIHN3YXAgdGhlIGxhc3QgZWxlbWVudCB3aXRoIGl0XG5cdFx0XHR0ZW1wID0gYXJyYXlbY291bnRlcl07XG5cdFx0XHRhcnJheVtjb3VudGVyXSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGFycmF5W2luZGV4XSA9IHRlbXA7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gYXJyYXk7XG5cdH07XG5cdFxuXHR0YWckLmRlZmluZVRhZygncGF0dGVybicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcblx0XHRcdHZhciBwYXJ0cyA9IHt0YWdzOiBbXSxrZXl3b3JkczogW10sbWV0aG9kczogW119O1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgbGluZXMgPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgbyA9IEltYmEuVGFnLnByb3RvdHlwZSwgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0ayA9IGtleXNbaV07aXRlbXMucHVzaCgoXCI8ZW0+XCIgKyBrICsgXCI8L2VtPlwiKSk7XG5cdFx0XHRcdHBhcnRzLm1ldGhvZHMucHVzaCgoXCI8ZW0+XCIgKyBrICsgXCI8L2VtPlwiKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoSFRNTF9UQUdTKSwgbGVuXyA9IGFyeS5sZW5ndGgsIGsxOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdC8vIGZvciBvd24gayx2IG9mIEltYmEuVEFHU1xuXHRcdFx0XHQvLyBpZiB2IGFuZCB2OnByb3RvdHlwZSBpc2EgSW1iYS5UYWdcblx0XHRcdFx0azEgPSBhcnlbaV07XG5cdFx0XHRcdGl0ZW1zLnB1c2goKFwiPHU+Jmx0O1wiICsgazEgKyBcIiZndDs8L3U+XCIpKTtcblx0XHRcdFx0cGFydHMudGFncy5wdXNoKChcIjx1PiZsdDtcIiArIGsxICsgXCImZ3Q7PC91PlwiKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgd29yZHMgPSBcImRlZiBpZiBlbHNlIGVsaWYgd2hpbGUgdW50aWwgZm9yIGluIG9mIHZhciBsZXQgY2xhc3MgZXh0ZW5kIGV4cG9ydCBpbXBvcnQgdGFnIGdsb2JhbFwiO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQod29yZHMuc3BsaXQoXCIgXCIpKSwgbGVuXyA9IGFyeS5sZW5ndGgsIGsyOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdGsyID0gYXJ5W2ldO1xuXHRcdFx0XHRpdGVtcy5wdXNoKChcIjxpPlwiICsgazIgKyBcIjwvaT5cIikpO1xuXHRcdFx0XHRwYXJ0cy5rZXl3b3Jkcy5wdXNoKChcIjxpPlwiICsgazIgKyBcIjwvaT5cIikpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHNodWZmbGVkID0gc2h1ZmZsZShpdGVtcyk7XG5cdFx0XHR2YXIgYWxsID0gW10uY29uY2F0KHNodWZmbGVkKTtcblx0XHRcdHZhciBjb3VudCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGxlbiA9IDEyLCBsbiA9IDA7IGxuIDw9IGxlbjsgbG4rKykge1xuXHRcdFx0XHR2YXIgY2hhcnMgPSAwO1xuXHRcdFx0XHRsaW5lc1tsbl0gPSBbXTtcblx0XHRcdFx0d2hpbGUgKGNoYXJzIDwgMzAwKXtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IChzaHVmZmxlZC5wb3AoKSB8fCBhbGxbTWF0aC5mbG9vcihjb3VudCAqIE1hdGgucmFuZG9tKCkpXSk7XG5cdFx0XHRcdFx0aWYgKGl0ZW0pIHtcblx0XHRcdFx0XHRcdGNoYXJzICs9IGl0ZW0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bGluZXNbbG5dLnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNoYXJzID0gNDAwO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9ICc8ZGl2PicgKyBsaW5lcy5tYXAoZnVuY3Rpb24obG4pIHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2IGNsYXNzPVwibGluZVwiPicgKyBsbi5qb2luKFwiIFwiKSArICc8L2Rpdj4nO1xuXHRcdFx0fSkuam9pbignJykgKyAnPC9kaXY+Jztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdhd2FrZW5pbmcgcGF0dGVybiEhJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHEkKCcubGluZScsdGhpcykpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFyIHogPSAyMCArIGkgKiAxMDtcblx0XHRcdFx0Ly8geiA9IHBhcnNlSW50KC16ICsgTWF0aC5yYW5kb20gKiB6ICogMilcblx0XHRcdFx0YXJ5W2ldLmNzcygndHJhbnNmb3JtJywoXCJ0cmFuc2xhdGVaKFwiICsgeiArIFwicHgpXCIpKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaG9tZScsICdwYWdlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR2YXIgdG9kb3MgPSB7ZGVtbzogdHJ1ZSxhdXRvcnVuOiB0cnVlfTtcblx0XHR2YXIgY2xvY2sgPSB7ZGVtbzogdHJ1ZSxhdXRvcnVuOiB0cnVlfTtcblx0XHR2YXIgcmVtaW5kZXJzID0ge2RlbW86IHRydWUsYXV0b3J1bjogdHJ1ZX07XG5cdFx0dmFyIGhlcm8gPSB7YXV0b3J1bjogdHJ1ZX07XG5cdFx0dmFyIGNhbnZhcyA9IHtkZW1vOiB0cnVlLGF1dG9ydW46IHRydWV9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc25pcHBldHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdjb2RlW2RhdGEtc3JjXScpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNuaXBwZXRzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgc25pcHBldDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHNuaXBwZXQgPSBhcnlbaV07XG5cdFx0XHRcdHZhciBzcmMgPSBzbmlwcGV0LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoaW5nIHNuaXBwZXQgZm9yICcsc3JjXG5cdFx0XHRcdERFUFNbc3JjXSA9IHtodG1sOiBzbmlwcGV0LmlubmVySFRNTH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5hd2FrZW4uYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYXYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0O1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX2JvZHk9dGhpcy5fYm9keSB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2JvZHknLHRoaXMpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0KHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRkaXYoKS5zZXRJZCgnaGVybycpLmZsYWcoJ2RhcmsnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0KHRoaXMuX3BhdHRlcm4gPSB0aGlzLl9wYXR0ZXJuIHx8IHRhZyQuJHBhdHRlcm4oKS5zZXRSZWYoJ3BhdHRlcm4nLHRoaXMpLmZsYWcoJ2F3YWtlbicpKS5lbmQoKSxcblx0XHRcdFx0XHQodDEuJCRiID0gdDEuJCRiIHx8IHRhZyQuJGV4YW1wbGUoKS5mbGFnKCdoZXJvJykuZmxhZygnZGFyaycpLnNldFNyYygnL2hvbWUvZXhhbXBsZXMvaGVyby5pbWJhJykpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKCksXG5cdFx0XHRcdFxuXHRcdFx0XHQodDIgPSB0aGlzLl9jb250ZW50PXRoaXMuX2NvbnRlbnQgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdjb250ZW50Jyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0KHQyLiQkYSA9IHQyLiQkYSB8fCB0YWckLiRtYXJrZWQoKS5mbGFnKCdzZWN0aW9uJykuZmxhZygnbWQnKS5mbGFnKCd3ZWxjb21lJykuZmxhZygnaHVnZScpLmZsYWcoJ2xpZ2h0JykpLnNldFRleHQoXCIjIFJ1YnksIFB5dGhvbiBhbmQgUmVhY3QgZ290IHRvZ2V0aGVyLiBOaW5lIG1vbnRocyBsYXRlciwgSW1iYSB3YXMgYm9ybi5cXG5cXG5JbWJhIGlzIGEgbmV3IHByb2dyYW1taW5nIGxhbmd1YWdlIGZvciB0aGUgd2ViIHRoYXQgY29tcGlsZXMgdG8gaGlnaGx5IFxcbnBlcmZvcm1hbnQgYW5kIHJlYWRhYmxlIEphdmFTY3JpcHQuIEl0IGhhcyBsYW5ndWFnZSBsZXZlbCBzdXBwb3J0IGZvciBkZWZpbmluZywgXFxuZXh0ZW5kaW5nLCBzdWJjbGFzc2luZywgaW5zdGFudGlhdGluZyBhbmQgcmVuZGVyaW5nIGRvbSBub2Rlcy4gRm9yIGEgc2VtaS1jb21wbGV4IFxcbmFwcGxpY2F0aW9uIGxpa2UgVG9kb01WQywgaXQgaXMgbW9yZSB0aGFuIFxcblsxMCB0aW1lcyBmYXN0ZXIgdGhhbiBSZWFjdF0oaHR0cDovL3NvbWViZWUuZ2l0aHViLmlvL3RvZG9tdmMtcmVuZGVyLWJlbmNobWFyay9pbmRleC5odG1sKSBcXG53aXRoIGxlc3MgY29kZSwgYW5kIGEgbXVjaCBzbWFsbGVyIGxpYnJhcnkuXFxuXFxuLS0tXFxuXFxuLSAjIyBJbWJhLmluc3BpcmF0aW9uXFxuICBJbWJhIGJyaW5ncyB0aGUgYmVzdCBmcm9tIFJ1YnksIFB5dGhvbiwgYW5kIFJlYWN0ICgrIEpTWCkgdG9nZXRoZXIgaW4gYSBjbGVhbiBsYW5ndWFnZSBhbmQgcnVudGltZS5cXG5cXG4tICMjIEltYmEuaW50ZXJvcGVyYWJpbGl0eVxcbiAgSW1iYSBjb21waWxlcyBkb3duIHRvIGNsZWFuIGFuZCByZWFkYWJsZSBKYXZhU2NyaXB0LiBVc2UgYW55IEpTIGxpYnJhcnkgaW4gSW1iYSBhbmQgdmljYS12ZXJzYS5cXG5cXG4tICMjIEltYmEucGVyZm9ybWFuY2VcXG4gIEJ1aWxkIHlvdXIgYXBwbGljYXRpb24gdmlld3MgdXNpbmcgSW1iYSdzIG5hdGl2ZSB0YWdzIGZvciB1bnByZWNlZGVudGVkIHBlcmZvcm1hbmNlLlxcblwiKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDIuJCRiID0gdDIuJCRiIHx8IHRhZyQuJGV4YW1wbGUoKS5mbGFnKCdkYXJrJykuc2V0SGVhZGluZyhcIlNpbXBsZSByZW1pbmRlcnNcIikuc2V0U3JjKCcvaG9tZS9leGFtcGxlcy9yZW1pbmRlcnMuaW1iYScpKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDIuJCRjID0gdDIuJCRjIHx8IHRhZyQuJG1hcmtlZCgpLmZsYWcoJ3NlY3Rpb24nKS5mbGFnKCdtZCcpKS5zZXRUZXh0KFwiIyMgUmV1c2FibGUgY29tcG9uZW50c1xcblxcbkEgY3VzdG9tIHRhZyAvIGNvbXBvbmVudCBjYW4gbWFpbnRhaW4gaW50ZXJuYWwgc3RhdGUgYW5kIGNvbnRyb2wgaG93IHRvIHJlbmRlciBpdHNlbGYuXFxuV2l0aCB0aGUgcGVyZm9ybWFuY2Ugb2YgRE9NIHJlY29uY2lsaWF0aW9uIGluIEltYmEsIHlvdSBjYW4gdXNlIG9uZS13YXkgZGVjbGFyYXRpdmUgYmluZGluZyxcXG5ldmVuIGZvciBhbmltYXRpb25zLiBXcml0ZSBhbGwgeW91ciB2aWV3cyBpbiBhIHN0cmFpZ2h0LWZvcndhcmQgbGluZWFyIGZhc2hpb24gYXMgaWYgeW91IGNvdWxkXFxucmVyZW5kZXIgeW91ciB3aG9sZSBhcHBsaWNhdGlvbiBvbiAqKmV2ZXJ5IHNpbmdsZSoqIGRhdGEvc3RhdGUgY2hhbmdlLlwiKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDIuJCRkID0gdDIuJCRkIHx8IHRhZyQuJGV4YW1wbGUoKS5mbGFnKCdkYXJrJykuc2V0SGVhZGluZyhcIldvcmxkIGNsb2NrXCIpLnNldFNyYygnL2hvbWUvZXhhbXBsZXMvY2xvY2suaW1iYScpKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDIuJCRlID0gdDIuJCRlIHx8IHRhZyQuJG1hcmtlZCgpLmZsYWcoJ3NlY3Rpb24nKS5mbGFnKCdtZCcpKS5zZXRUZXh0KFwiIyMgRXh0ZW5kIG5hdGl2ZSB0YWdzXFxuXFxuSW4gYWRkaXRpb24gdG8gZGVmaW5pbmcgY3VzdG9tIHRhZ3MsIHlvdSBjYW4gYWxzbyBleHRlbmQgbmF0aXZlIHRhZ3MsIG9yIGluaGVyaXQgZnJvbSB0aGVtLlxcbkJpbmRpbmcgdG8gZG9tIGV2ZW50cyBpcyBhcyBzaW1wbGUgYXMgZGVmaW5pbmcgbWV0aG9kcyBvbiB5b3VyIHRhZ3M7IGFsbCBldmVudHMgd2lsbCBiZVxcbmVmZmljaWVudGx5IGRlbGVnYXRlZCBhbmQgaGFuZGxlZCBieSBJbWJhLiBMZXQncyBkZWZpbmUgYSBzaW1wbGUgc2tldGNocGFkLi4uXCIpLmVuZCgpLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCh0Mi4kJGYgPSB0Mi4kJGYgfHwgdGFnJC4kZXhhbXBsZSgpLmZsYWcoJ2RhcmsnKS5zZXRIZWFkaW5nKFwiQ3VzdG9tIGNhbnZhc1wiKS5zZXRTcmMoJy9ob21lL2V4YW1wbGVzL2NhbnZhcy5pbWJhJykpLmVuZCgpLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCh0MyA9IHQyLiQkZz10Mi4kJGcgfHwgdGFnJC4kZm9vdGVyKCkpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0XHQodDQgPSB0My4kJGE9dDMuJCRhIHx8IHRhZyQuJG5hdigpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0KHQ0LiQkYSA9IHQ0LiQkYSB8fCB0YWckLiRhKCkuZmxhZygnYnV0dG9uJykuZmxhZygnaHVnZScpLmZsYWcoJ21haW4nKS5zZXRIcmVmKCcvaW5zdGFsbCcpKS5zZXRUZXh0KFwiSW5zdGFsbFwiKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0KHQ0LiQkYiA9IHQ0LiQkYiB8fCB0YWckLiRhKCkuZmxhZygnYnV0dG9uJykuZmxhZygnaHVnZScpLnNldEhyZWYoJy9ndWlkZXMnKSkuc2V0VGV4dChcIkxlYXJuIG1vcmVcIikuZW5kKClcblx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHQsMikuZW5kKClcblx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XSwyKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGRlZiBhd2FrZW5cblx0XHQvLyBcdCMgYXdha2VuIHRoZSBzbmlwcGV0c1xuXHRcdC8vIFx0c2NoZWR1bGVcblx0XHQvLyBcdGZvciBlbCBpbiAlKHNuaXBwZXQpXG5cdFx0Ly8gXHRcdGVsXG5cdFx0Ly8gXHRzZWxmXG5cdFx0XG5cdFx0Ly8gZGVmIHRpY2tcblx0XHQvLyBcdGxvZyAnaG9tZS50aWNrJ1xuXHRcdC8vIFx0c2VsZlxuXHRcdFxuXHRcdC8vIGRlZiBhc3NlbWJsZVxuXHRcdC8vIFx0cmV0dXJuIHNlbGYgaWYgSW1iYS5pc0NsaWVudFxuXHRcdC8vIFx0c3VwZXJcblx0XHQvLyBcdCMgZmxhZygnc2NvcGVkJyxyb3V0ZXIuc2NvcGVkKHJvdXRlLHNlbGYpKVxuXHRcdC8vIFx0IyBmbGFnKCdzZWxlY3RlZCcscm91dGVyLm1hdGNoKHJvdXRlLHNlbGYpKVxuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvaG9tZS5pbWJhXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRyZXF1aXJlKCcuL3BhZ2UnKTtcblx0XG5cdHZhciBEb2MgPSByZXF1aXJlKCcuLi9hcHAnKS5Eb2M7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYmxvZycsICdwYWdlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIG5yO1xuXHRcdFx0aWYgKG5yID0gdGhpcy5yb3V0ZXIoKS5zY29wZWQoL2Jsb2dcXC8oXFxkKykvLDEpKSB7XG5cdFx0XHRcdHJldHVybiBEb2MuZ2V0KCcvaXNzdWVzLycgKyBuciArICcuanNvbicpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWV0YSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIERvYy5nZXQoJy9ibG9nLmpzb24nKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmF2ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHNlbGYgPSB0aGlzLCB0MTtcblx0XHRcdHJldHVybiAodDAgPSBzZWxmLl9uYXY9c2VsZi5fbmF2IHx8IHRhZyQuJG5hdm1lbnUoKS5zZXRSZWYoJ25hdicsdGhpcykpLnNldENvbnRlbnQoXG5cdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnY29udGVudCcpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdChmdW5jdGlvbih0MSkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKEFQUC5pc3N1ZXMoKS5vYmplY3QoKSksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQxWyckJGEnICsgaV0gPSB0MVsnJCRhJyArIGldIHx8IHRhZyQuJGlzc3VlX2xpKCkpLnNldE9iamVjdChhcnlbaV0pLmVuZCgpKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdH0pKHQxKVxuXHRcdFx0XHQsMykuZW5kKClcblx0XHRcdCwyKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX2JvZHk9dGhpcy5fYm9keSB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2JvZHknLHRoaXMpLmZsYWcoJ2xpZ2h0JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodGhpcy5kb2MoKSkgPyAoXG5cdFx0XHRcdFx0KHQwLiQkYSA9IHQwLiQkYSB8fCB0YWckLiRpc3N1ZSgpKS5zZXRPYmplY3QodGhpcy5kb2MoKSkuZW5kKClcblx0XHRcdFx0KSA6IHZvaWQoMClcblx0XHRcdF0sMSkuZW5kKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2Jsb2dwb3N0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIG9iamVjdF87XG5cdFx0XHRpZiAoIShvYmplY3RfID0gdGhpcy5vYmplY3QoKSkgJiYgb2JqZWN0Xy5yZWFkeSAgJiYgIG9iamVjdF8ucmVhZHkoKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnbWQnKS5zZXRCb2R5KCh0aGlzLm9iamVjdCgpLmJvZHkoKSkpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpe1xuXHRcdFx0aWYgKGJvZHkgIT0gdGhpcy5fYm9keSkge1xuXHRcdFx0XHR0aGlzLl9ib2R5ID0gYm9keTtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSBib2R5O1xuXHRcdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpKSB0aGlzLnJlYXdha2VuKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocSQoJy5fc25pcHBldCcsdGhpcykpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9ibG9nLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHJlcXVpcmUoJy4vcGFnZScpO1xuXHRcblx0ZnVuY3Rpb24gR3VpZGUocGF0aCl7XG5cdFx0dGhpcy5fcGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5fcmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLmZldGNoKCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHZhciBjYWNoZSA9IHt9O1xuXHRcblx0R3VpZGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpe1xuXHRcdHZhciAkMTtcblx0XHR2YXIgY2FjaGUgPSBBUFAuY2FjaGUoKTtcblx0XHRyZXR1cm4gY2FjaGVbKCQxID0gJ2d1aWRlLScgKyBwYXRoKV0gfHwgKGNhY2hlWyQxXSA9IG5ldyB0aGlzKHBhdGgpKTtcblx0fTtcblx0XG5cdFxuXHRcblx0R3VpZGUucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BhdGg7IH1cblx0R3VpZGUucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbih2KXsgdGhpcy5fcGF0aCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3JlYWR5O1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmIChJbWJhLlNFUlZFUikge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoIEd1aWRlIG9uIHNlcnZlcicscGF0aFxuXHRcdFx0cmV0dXJuIEFQUC5mZXRjaERvY3VtZW50KHNlbGYuX3BhdGggKyAnLm1kJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoIEd1aWRlIG9uIHNlcnZlciBkb25lJyxwYXRoXG5cdFx0XHRcdHJldHVybiBzZWxmLmxvYWQocmVzKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuX3Byb21pc2UgfHwgKHNlbGYuX3Byb21pc2UgPSBBUFAuZmV0Y2hEb2N1bWVudChzZWxmLl9wYXRoICsgJy5tZCcsZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5sb2FkKHJlcyk7XG5cdFx0fSkpO1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoZG9jKXtcblx0XHR0aGlzLl9vYmplY3QgPSBkb2M7XG5cdFx0dGhpcy5fbWV0YSA9IGRvYy5tZXRhIHx8IHt9O1xuXHRcdHRoaXMuX3JlYWR5ID0gdHJ1ZTtcblx0XHRJbWJhLmVtaXQodGhpcywncmVhZHknKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEd1aWRlLnByb3RvdHlwZS50aXRsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9vYmplY3QudGl0bGUgfHwgJ3BhdGgnO1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLnRvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9vYmplY3QgJiYgdGhpcy5fb2JqZWN0LnRvY1swXTtcblx0fTtcblx0XG5cdEd1aWRlLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX29iamVjdCAmJiB0aGlzLl9vYmplY3QuYm9keTtcblx0fTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZ3VpZGUtdG9jJywgJ3RvYycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RvYzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VG9jID0gZnVuY3Rpb24odil7IHRoaXMuX3RvYyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubGV2ZWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdsZXZlbCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMZXZlbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbGV2ZWwnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm91dGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um91dGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvdXRlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl90b2MgfHwgdGhpcy5vYmplY3QoKS50b2MoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucm91dGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAoXCJcIiArICh0aGlzLm9iamVjdCgpLnBhdGgoKSkgKyBcIiNcIiArICh0aGlzLnRvYygpLnNsdWcpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy50b2dnbGVGbGFnKCdjb2xsYXBzZWQnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCBzZWxmID0gdGhpcywgdDIsIHQzO1xuXHRcdFx0aWYgKCF0aGlzLm9iamVjdCgpLnJlYWR5KCkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFxuXHRcdFx0dGhpcy5yZXJvdXRlKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ2VudHJ5Jykuc2V0TGV2ZWwoKHRoaXMudG9jKCkubGV2ZWwpKS5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHRoaXMudG9jKCkuY2hpbGRyZW4ubGVuZ3RoICYmIHRoaXMudG9jKCkubGV2ZWwgPCAyID8gKEltYmEuc3RhdGljKFtcblx0XHRcdFx0XHQodDAgPSB0aGlzLiRhPXRoaXMuJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykuc2V0SGFuZGxlcigndGFwJywndG9nZ2xlJyx0aGlzKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kYSgpKS5zZXRIcmVmKHRoaXMucm91dGUoKSkuc2V0Q29udGVudCh0aGlzLnRvYygpLnRpdGxlLDMpLmVuZCgpXG5cdFx0XHRcdFx0LDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MiA9IHNlbGYuJGI9c2VsZi4kYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0XHQoZnVuY3Rpb24odDIpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYudG9jKCkuY2hpbGRyZW4pLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQyWyckJGEnICsgaV0gPSB0MlsnJCRhJyArIGldIHx8IHRhZyQuJGd1aWRlX3RvYygpKS5zZXRUb2MoYXJ5W2ldKS5zZXRPYmplY3Qoc2VsZi5vYmplY3QoKSkuZW5kKCkpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdFx0fSkodDIpXG5cdFx0XHRcdFx0LDMpLmVuZCgpXG5cdFx0XHRcdF0sMikpIDogKFxuXHRcdFx0XHRcdCh0MyA9IHNlbGYuJGM9c2VsZi4kYyB8fCB0YWckLiRhKCkpLnNldEhyZWYoc2VsZi5yb3V0ZSgpKS5zZXRDb250ZW50KHNlbGYudG9jKCkudGl0bGUsMykuZW5kKClcblx0XHRcdFx0KVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZ3VpZGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgb2JqZWN0Xztcblx0XHRcdGlmICghKG9iamVjdF8gPSB0aGlzLm9iamVjdCgpKSAmJiBvYmplY3RfLnJlYWR5ICAmJiAgb2JqZWN0Xy5yZWFkeSgpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdtZCcpLnNldEJvZHkoKHRoaXMub2JqZWN0KCkuYm9keSgpKSkuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldEJvZHkgPSBmdW5jdGlvbiAoYm9keSl7XG5cdFx0XHRpZiAoYm9keSAhPSB0aGlzLl9ib2R5KSB7XG5cdFx0XHRcdHRoaXMuX2JvZHkgPSBib2R5O1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IGJvZHk7XG5cdFx0XHRcdGlmIChJbWJhLmlzQ2xpZW50KCkpIHRoaXMucmVhd2FrZW4oKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVhd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChxJCgnLl9zbmlwcGV0Jyx0aGlzKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdndWlkZXMnLCAncGFnZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYXYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDE7XG5cdFx0XHRyZXR1cm4gKHQwID0gdGhpcy5fbmF2PXRoaXMuX25hdiB8fCB0YWckLiRuYXZtZW51KCkuc2V0UmVmKCduYXYnLHRoaXMpKS5zZXRDb250ZW50KFxuXHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0KHQxLiQkYSA9IHQxLiQkYSB8fCB0YWckLiRndWlkZV90b2MoKSkuc2V0T2JqZWN0KEd1aWRlLmdldCgnL2d1aWRlcycpKS5lbmQoKSxcblx0XHRcdFx0XHQodDEuJCRiID0gdDEuJCRiIHx8IHRhZyQuJGd1aWRlX3RvYygpKS5zZXRPYmplY3QoR3VpZGUuZ2V0KCcvZ3VpZGVzL2xhbmd1YWdlJykpLmVuZCgpXG5cdFx0XHRcdC8vIDxndWlkZS10b2NbR3VpZGUuZ2V0KCcvZ3VpZGVzL3RpcHMnKV0+XG5cdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdCwyKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX2JvZHk9dGhpcy5fYm9keSB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2JvZHknLHRoaXMpLmZsYWcoJ2xpZ2h0JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodGhpcy5ndWlkZSgpKSA/ICgodDAuJCRhID0gdDAuJCRhIHx8IHRhZyQuJGd1aWRlKCkpLnNldE9iamVjdCh0aGlzLmd1aWRlKCkpLmVuZCgpKSA6IHZvaWQoMClcblx0XHRcdC8vIDxndWlkZUBkb2MubWQubCBzcmM9XCJ7cm91dGVyLnBhdGh9XCI+XG5cdFx0XHRdLDEpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnJvdXRlID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Ly8gbG9nICdvbnJvdXRlIGd1aWRlcycscm91dGVyLmhhc2hcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0XG5cdFx0XHR2YXIgc2Nyb2xsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbDtcblx0XHRcdFx0aWYgKGVsID0gc2VsZi5maXJzdCgnIycgKyBzZWxmLnJvdXRlcigpLmhhc2goKSkpIHtcblx0XHRcdFx0XHRlbC5kb20oKS5zY3JvbGxJbnRvVmlldyh0cnVlKTtcblx0XHRcdFx0XHRzZWxmLl9zY3JvbGxGcmVlemUgPSB3aW5kb3cuc2Nyb2xsWTtcblx0XHRcdFx0XHRyZXR1cm4gZWw7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChzZWxmLnJvdXRlcigpLmhhc2goKSkge1xuXHRcdFx0XHRzZWxmLnJlbmRlcigpO1xuXHRcdFx0XHRzY3JvbGwoKSB8fCBzZXRUaW1lb3V0KHNjcm9sbCwyMCxmdW5jdGlvbigpIHsgIH0pO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ3VpZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICh0aGlzLnJvdXRlcigpLnNjb3BlZCgnL2d1aWRlcycpKSB7XG5cdFx0XHRcdHJldHVybiBHdWlkZS5nZXQodGhpcy5yb3V0ZXIoKS5wYXRoKCkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpKSB7XG5cdFx0XHRcdC8vIEBkb2MgPSAlJShndWlkZSlcblx0XHRcdFx0c2VsZi5zY2hlZHVsZSh7ZnBzOiAxfSk7XG5cdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdjaGVjayBzY3JvbGxpbmcnXG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYuc2Nyb2xsZWQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNjcm9sbGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAoIXRoaXMuaGFzRmxhZygnc2NvcGVkJykpIHsgcmV0dXJuIH07XG5cdFx0XHRcblx0XHRcdHZhciBpdGVtcyA9IHEkKCdbaWRdJyx0aGlzKTtcblx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIHByb2JhYmx5IGNhY2hlIHRoZXNlIHBlcmlvZGljYWxseVxuXHRcdFx0dmFyIHNjcm9sbFRvcCA9IHdpbmRvdy5zY3JvbGxZO1xuXHRcdFx0dmFyIHdoID0gd2luZG93LmlubmVySGVpZ2h0O1xuXHRcdFx0dmFyIGRoID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQ7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9zY3JvbGxGcmVlemUgPj0gMCkge1xuXHRcdFx0XHR2YXIgZGlmZiA9IE1hdGguYWJzKHNjcm9sbFRvcCAtIHRoaXMuX3Njcm9sbEZyZWV6ZSk7XG5cdFx0XHRcdGlmIChkaWZmIDwgNTApIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFx0dGhpcy5fc2Nyb2xsRnJlZXplID0gLTE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgc2Nyb2xsQm90dG9tID0gZGggLSAoc2Nyb2xsVG9wICsgd2gpO1xuXHRcdFx0XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBzY3JvbGxUb3Asd2gsZGgsc2Nyb2xsQm90dG9tXG5cdFx0XHRcblx0XHRcdGlmIChzY3JvbGxCb3R0b20gPT0gMCkge1xuXHRcdFx0XHRtYXRjaCA9IGl0ZW1zLmxhc3QoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChpdGVtcyksIGxlbiA9IGFyeS5sZW5ndGgsIGl0ZW07IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGl0ZW0gPSBhcnlbaV07XG5cdFx0XHRcdFx0dmFyIHQgPSAoaXRlbS5kb20oKS5vZmZzZXRUb3AgKyAzMCArIDYwKTsgLy8gaGFja1xuXHRcdFx0XHRcdHZhciBkaXN0ID0gc2Nyb2xsVG9wIC0gdDtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcIntpdGVtLmlkfSB7dH0ge2Rpc3R9XCJcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZGlzdCA8IDApIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gaXRlbTticmVhaztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwibWF0Y2ggaXMge21hdGNoLmlkfVwiXG5cdFx0XHRcdGlmICh0aGlzLl9oYXNoICE9IG1hdGNoLmlkKCkpIHtcblx0XHRcdFx0XHR0aGlzLl9oYXNoID0gbWF0Y2guaWQoKTtcblx0XHRcdFx0XHR0aGlzLnJvdXRlcigpLmdvKCcjJyArIHRoaXMuX2hhc2gse30sdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9ndWlkZXMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0ZnVuY3Rpb24gcGF0aFRvQW5jaG9yKHBhdGgpe1xuXHRcdHJldHVybiAnYXBpLScgKyBwYXRoLnJlcGxhY2UoL1xcLi9nLCdfJykucmVwbGFjZSgvXFwjL2csJ19fJyk7XG5cdH07XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLWRlc2MnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHRtbCA9IGZ1bmN0aW9uIChodG1sKXtcblx0XHRcdGlmIChodG1sICE9IHRoaXMuX2h0bWwpIHtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB0aGlzLl9odG1sID0gaHRtbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktcmVmJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLWl0ZW0nKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktcGF0aCcsICdzcGFuJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgb2JqZWN0Xztcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0aWYgKCh0eXBlb2YgKG9iamVjdF8gPSB0aGlzLm9iamVjdCgpKT09J3N0cmluZyd8fG9iamVjdF8gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdHRoaXMuc2V0SHRtbCh0aGlzLm9iamVjdCgpLnJlcGxhY2UoL1xcYihbXFx3XSt8XFwufFxcIylcXGIvZyxmdW5jdGlvbihtLGkpIHtcblx0XHRcdFx0XHRpZiAoaSA9PSAnLicgfHwgaSA9PSAnIycpIHtcblx0XHRcdFx0XHRcdHJldHVybiAoXCI8aT5cIiArIGkgKyBcIjwvaT5cIik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpWzBdID09IGlbMF0udG9VcHBlckNhc2UoKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIChcIjxiIGNsYXNzPSdjb25zdCc+XCIgKyBpICsgXCI8L2I+XCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFwiPGIgY2xhc3M9J2lkJz5cIiArIGkgKyBcIjwvYj5cIik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSkpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktbGluaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0KHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJGFwaV9wYXRoKCkuZmxhZygndmFsdWUnKSkuc2V0T2JqZWN0KHRoaXMub2JqZWN0KCkudmFsdWUpLmVuZCgpLFxuXHRcdFx0XHQodDAgPSB0aGlzLiRiPXRoaXMuJGIgfHwgdGFnJC4kc3BhbigpLmZsYWcoJ2Rlc2MnKSkuc2V0Q29udGVudCh0aGlzLm9iamVjdCgpLmRlc2MsMykuZW5kKClcblx0XHRcdF0sMikuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLXJldHVybicsICdhcGktbGluaycpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1jbGFzcycsICdhcGktaXRlbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX29iamVjdCA9IHt3YXRjaDogJ3BhcnNlJyxuYW1lOiAnb2JqZWN0J307XG5cdFx0dGFnLnByb3RvdHlwZS5vYmplY3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29iamVjdDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0T2JqZWN0ID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMub2JqZWN0KCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fb2JqZWN0ID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMucGFyc2UgJiYgdGhpcy5wYXJzZSh2LGEsdGhpcy5fX29iamVjdCkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5vYmplY3QoKVsnLiddKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbSwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRtID0gYXJ5W2ldO1xuXHRcdFx0XHRpZiAoIW0uZGVzYykgeyBjb250aW51ZTsgfTtcblx0XHRcdFx0cmVzLnB1c2gobSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fc3RhdGljcyA9IHJlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLm9iamVjdCgpWycjJ10pLCBsZW4gPSBhcnkubGVuZ3RoLCBtMSwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRtMSA9IGFyeVtpXTtcblx0XHRcdFx0aWYgKCFtMS5kZXNjKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRyZXMucHVzaChtMSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fbWV0aG9kcyA9IHJlcztcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHNlbGYgPSB0aGlzLCB0NSwgdDYsIHQ3O1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodGhpcy4kYSA9IHRoaXMuJGEgfHwgdGFnJC4kc3BhbigpLmZsYWcoJ3RvYy1hbmNob3InKSkuc2V0SWQocGF0aFRvQW5jaG9yKHRoaXMub2JqZWN0KCkubmFtZXBhdGgpKS5lbmQoKSxcblx0XHRcdFx0KHQwID0gdGhpcy4kYj10aGlzLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpKS5zZXRDb250ZW50KCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygndGl0bGUnKSkuc2V0Q29udGVudCgodDEuJCRhID0gdDEuJCRhIHx8IHRhZyQuJGFwaV9wYXRoKCkpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLm5hbWVwYXRoKS5lbmQoKSwyKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMuJGMgPSB0aGlzLiRjIHx8IHRhZyQuJGFwaV9kZXNjKCkpLnNldEh0bWwodGhpcy5vYmplY3QoKS5odG1sKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMub2JqZWN0KCkuY3RvcikgPyAoXG5cdFx0XHRcdFx0KHQyID0gdGhpcy4kZD10aGlzLiRkIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKS5mbGFnKCdjdG9yJykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0XHQodDIuJCRhID0gdDIuJCRhIHx8IHRhZyQuJGFwaV9tZXRob2QoKSkuc2V0UGF0aCgodGhpcy5vYmplY3QoKS5uYW1lcGF0aCArICcubmV3JykpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLmN0b3IpLmVuZCgpXG5cdFx0XHRcdFx0LDIpLmVuZCgpXG5cdFx0XHRcdCkgOiB2b2lkKDApLFxuXHRcdFx0XHRcblx0XHRcdFx0KHQzID0gc2VsZi4kZT1zZWxmLiRlIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0KHRoaXMuX3N0YXRpY3MubGVuZ3RoID4gMCkgPyAoXG5cdFx0XHRcdFx0XHQodDQgPSB0My4kJGE9dDMuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3NlY3Rpb24nKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdCh0NC4kJGEgPSB0NC4kJGEgfHwgdGFnJC4kaDIoKS5mbGFnKCdoZWFkZXInKSkuc2V0VGV4dCgnU3RhdGljIE1ldGhvZHMnKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0KHQ1ID0gdDQuJCRiPXQ0LiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykuZmxhZygnbGlzdCcpKS5zZXRDb250ZW50KChmdW5jdGlvbih0NSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLl9zdGF0aWNzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQ1WyckJGEnICsgaV0gPSB0NVsnJCRhJyArIGldIHx8IHRhZyQuJGFwaV9tZXRob2QoKS5mbGFnKCdkb2MnKSkuc2V0SW5hbWUoc2VsZi5vYmplY3QoKS5uYW1lcGF0aCkuc2V0T2JqZWN0KGFyeVtpXSkuZW5kKCkpO1xuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHRcdFx0fSkodDUpLDMpLmVuZCgpXG5cdFx0XHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRcdFx0KSA6IHZvaWQoMCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHNlbGYuX21ldGhvZHMubGVuZ3RoID4gMCkgPyAoXG5cdFx0XHRcdFx0XHQodDYgPSB0My4kJGI9dDMuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3NlY3Rpb24nKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdCh0Ni4kJGEgPSB0Ni4kJGEgfHwgdGFnJC4kaDIoKS5mbGFnKCdoZWFkZXInKSkuc2V0VGV4dCgnSW5zdGFuY2UgTWV0aG9kcycpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDcgPSB0Ni4kJGI9dDYuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKS5mbGFnKCdsaXN0JykpLnNldENvbnRlbnQoKGZ1bmN0aW9uKHQ3KSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuX21ldGhvZHMpLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDdbJyQkYScgKyBpXSA9IHQ3WyckJGEnICsgaV0gfHwgdGFnJC4kYXBpX21ldGhvZCgpLmZsYWcoJ2RvYycpKS5zZXRJbmFtZShzZWxmLm9iamVjdCgpLmluYW1lKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdFx0XHR9KSh0NyksMykuZW5kKClcblx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHQpIDogdm9pZCgwKVxuXHRcdFx0XHRdLDEpLmVuZCgpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS12YWx1ZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBvYmplY3RfLCAkMTtcblx0XHRcdGlmICh0aGlzLm9iamVjdCgpLnR5cGUpIHtcblx0XHRcdFx0dGhpcy5mbGFnKHRoaXMub2JqZWN0KCkudHlwZSkuc2V0Q2hpbGRyZW4oXG5cdFx0XHRcdFx0dGhpcy5vYmplY3QoKS52YWx1ZVxuXHRcdFx0XHQsMykuc3luY2VkKCk7XG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgKG9iamVjdF8gPSB0aGlzLm9iamVjdCgpKT09J3N0cmluZyd8fG9iamVjdF8gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdHRoaXMuZmxhZygnc3RyJykuc2V0VGV4dCh0aGlzLm9iamVjdCgpKS5zeW5jZWQoKTtcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiAoJDEgPSB0aGlzLm9iamVjdCgpKT09J251bWJlcid8fCQxIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0XHR0aGlzLmZsYWcoJ251bScpLnNldFRleHQodGhpcy5vYmplY3QoKSkuc3luY2VkKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1wYXJhbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5vYmplY3QoKS50eXBlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgdDAsIHQxO1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZyhzZWxmLnR5cGUoKSkuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHRzZWxmLnR5cGUoKSA9PSAnTmFtZWRQYXJhbXMnID8gKFxuXHRcdFx0XHRcdChmdW5jdGlvbihzZWxmKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5vYmplY3QoKS5ub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHNlbGZbJyRhJyArIGldID0gc2VsZlsnJGEnICsgaV0gfHwgdGFnJC4kYXBpX3BhcmFtKCkpLnNldE9iamVjdChhcnlbaV0pLmVuZCgpKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdH0pKHNlbGYpXG5cdFx0XHRcdCkgOiAoSW1iYS5zdGF0aWMoW1xuXHRcdFx0XHRcdCh0MCA9IHNlbGYuJGI9c2VsZi4kYiB8fCB0YWckLiRkaXYoKS5mbGFnKCduYW1lJykpLnNldENvbnRlbnQoc2VsZi5vYmplY3QoKS5uYW1lLDMpLmVuZCgpLFxuXHRcdFx0XHRcdChzZWxmLm9iamVjdCgpLmRlZmF1bHRzKSA/IChJbWJhLnN0YXRpYyhbXG5cdFx0XHRcdFx0XHQodDEgPSBzZWxmLiRjPXNlbGYuJGMgfHwgdGFnJC4kaSgpKS5zZXRDb250ZW50KFtzZWxmLnR5cGUoKSA9PSAnTmFtZWRQYXJhbScgPyAoJzogJykgOiAoJyA9ICcpXSwxKS5lbmQoKSxcblx0XHRcdFx0XHRcdChzZWxmLiRkID0gc2VsZi4kZCB8fCB0YWckLiRhcGlfdmFsdWUoKSkuc2V0T2JqZWN0KHNlbGYub2JqZWN0KCkuZGVmYXVsdHMpLmVuZCgpXG5cdFx0XHRcdFx0XSwyKSkgOiB2b2lkKDApXG5cdFx0XHRcdF0sMykpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1tZXRob2QnLCAnYXBpLWl0ZW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2luYW1lOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRJbmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pbmFtZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcGF0aDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50YWdzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDA7XG5cdFx0XHRyZXR1cm4gKHQwID0gdGhpcy5fdGFncz10aGlzLl90YWdzIHx8IHRhZyQuJGRpdigpLnNldFJlZigndGFncycsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodGhpcy5vYmplY3QoKS5kZXByZWNhdGVkKSA/IChcblx0XHRcdFx0XHQodDAuJCRhID0gdDAuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2RlcHJlY2F0ZWQnKS5mbGFnKCdyZWQnKSkuc2V0VGV4dCgnTWV0aG9kIGlzIGRlcHJlY2F0ZWQnKS5lbmQoKVxuXHRcdFx0XHQpIDogdm9pZCgwKSxcblx0XHRcdFx0KHRoaXMub2JqZWN0KCkucmV0dXJuKSA/ICgodDAuJCRiID0gdDAuJCRiIHx8IHRhZyQuJGFwaV9yZXR1cm4oKS5zZXROYW1lKCdyZXR1cm5zJykpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLnJldHVybikuZW5kKCkpIDogdm9pZCgwKVxuXHRcdFx0XSwxKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhdGggfHwgKHRoaXMuaW5hbWUoKSArICcuJyArIHRoaXMub2JqZWN0KCkubmFtZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNsdWcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBwYXRoVG9BbmNob3IodGhpcy5vYmplY3QoKS5uYW1lcGF0aCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCBzZWxmID0gdGhpcywgdDE7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdkZXByZWNhdGVkJyx0aGlzLm9iamVjdCgpLmRlcHJlY2F0ZWQpLnNldENoaWxkcmVuKFtcblx0XHRcdFx0KHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJHNwYW4oKS5mbGFnKCd0b2MtYW5jaG9yJykpLnNldElkKHRoaXMuc2x1ZygpKS5lbmQoKSxcblx0XHRcdFx0KHQwID0gc2VsZi4kYj1zZWxmLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodDAuJCRhID0gdDAuJCRhIHx8IHRhZyQuJGFwaV9wYXRoKCkpLnNldE9iamVjdCh0aGlzLnBhdGgoKSkuZW5kKCksXG5cdFx0XHRcdFx0KHQxID0gdDAuJCRiPXQwLiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdwYXJhbXMnKSkuc2V0Q29udGVudCgoZnVuY3Rpb24odDEpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLm9iamVjdCgpLnBhcmFtcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQxWyckJGEnICsgaV0gPSB0MVsnJCRhJyArIGldIHx8IHRhZyQuJGFwaV9wYXJhbSgpKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHR9KSh0MSksMykuZW5kKCksXG5cdFx0XHRcdFx0KHQwLiQkYyA9IHQwLiQkYyB8fCB0YWckLiRkaXYoKS5mbGFnKCdncm93JykpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKCksXG5cdFx0XHRcdChzZWxmLiRjID0gc2VsZi4kYyB8fCB0YWckLiRhcGlfZGVzYygpLmZsYWcoJ21kJykpLnNldEh0bWwoc2VsZi5vYmplY3QoKS5odG1sKS5lbmQoKSxcblx0XHRcdFx0c2VsZi50YWdzKClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZG9jLWxpbmsnLCAnYScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuc2V0SHJlZigoXCIvZG9jcyNcIiArIHBhdGhUb0FuY2hvcih0aGlzLm9iamVjdCgpLm5hbWVwYXRoKSkpLnNldENoaWxkcmVuKCh0aGlzLiRhID0gdGhpcy4kYSB8fCB0YWckLiRhcGlfcGF0aCgpKS5zZXRPYmplY3QodGhpcy5vYmplY3QoKS5uYW1lcGF0aCkuZW5kKCksMikuc3luY2VkKCk7XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5yZW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRhcCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGFnLl9fc3VwZXJfXy5vbnRhcC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gdGhpcy51cChxJCgnLl9kb2NzJyx0aGlzKSkucmVmb2N1cygpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2RvYy1ncm91cCcsICd0b2MnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250YXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnRvZ2dsZUZsYWcoJ2NvbGxhcHNlZCcpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnZG9jcycsICdwYWdlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fdmVyc2lvbiA9IHsnZGVmYXVsdCc6ICcwLjE0LjEnLG5hbWU6ICd2ZXJzaW9uJ307XG5cdFx0dGFnLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92ZXJzaW9uOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWZXJzaW9uID0gZnVuY3Rpb24odil7IHRoaXMuX3ZlcnNpb24gPSB2OyByZXR1cm4gdGhpczsgfVxuXHRcdHRhZy5wcm90b3R5cGUuX3ZlcnNpb24gPSAnMC4xNC4xJztcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvb3RzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb290czsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um9vdHMgPSBmdW5jdGlvbih2KXsgdGhpcy5fcm9vdHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIChcIi9hcGkvXCIgKyB0aGlzLnZlcnNpb24oKSArIFwiLmpzb25cIik7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRvY3MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kb2NzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9hZCgpO1xuXHRcdFx0dGhpcy5zY2hlZHVsZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvYWQoKTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHRcdC8vIHJldHVybiBzZWxmXG5cdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCksZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdFx0c2VsZi5fZG9jcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzKSk7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYuZ2VuZXJhdGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbGYuX3JlcXVlc3QgfHwgKHNlbGYuX3JlcXVlc3QgPSBBUFAuZmV0Y2hEb2N1bWVudChzZWxmLnNyYygpLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRET0NTID0gc2VsZi5fZG9jcyA9IHJlcztcblx0XHRcdFx0RE9DTUFQID0gc2VsZi5fZG9jcy5lbnRpdGllcztcblx0XHRcdFx0c2VsZi5nZW5lcmF0ZSgpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5sb2FkZWQoKTtcblx0XHRcdH0pKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0Ly8gcmVhbGx5P1xuXHRcdFx0aWYgKGRvY3VtZW50LmxvY2F0aW9uLmhhc2gpIHtcblx0XHRcdFx0aWYgKGVsID0gdGhpcy5maXJzdChkb2N1bWVudC5sb2NhdGlvbi5oYXNoKSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdzaG91bGQgc2Nyb2xsIGhlcmU/IT8hPyEnLGVsXG5cdFx0XHRcdFx0ZWwuZG9tKCkuc2Nyb2xsSW50b1ZpZXcoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVmb2N1cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0aWYgKGVsID0gdGhpcy5maXJzdChkb2N1bWVudC5sb2NhdGlvbi5oYXNoKSkge1xuXHRcdFx0XHRlbC5kb20oKS5zY3JvbGxJbnRvVmlldygpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAocGF0aCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2NzKCkuZW50aXRpZXNbcGF0aF07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLl9yb290cyA9IFtdO1xuXHRcdFx0dmFyIGVudHMgPSB0aGlzLl9kb2NzLmVudGl0aWVzO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBvID0gdGhpcy5kb2NzKCkuZW50aXRpZXMsIGl0ZW0sIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMobyksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdGl0ZW0gPSBvW2tleXNbaV1dO2lmIChpdGVtLnR5cGUgPT0gJ2NsYXNzJyB8fCBrZXlzW2ldID09ICdJbWJhJykge1xuXHRcdFx0XHRcdGl0ZW1bJy4nXSA9IChpdGVtWycuJ10gfHwgW10pLnNvcnQoKS5tYXAoZnVuY3Rpb24ocGF0aCkgeyByZXR1cm4gZW50c1twYXRoXTsgfSkuZmlsdGVyKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYudHlwZSA9PSAnbWV0aG9kJyAmJiB2LmRlc2M7IH0pO1xuXHRcdFx0XHRcdGl0ZW1bJyMnXSA9IChpdGVtWycjJ10gfHwgW10pLnNvcnQoKS5tYXAoZnVuY3Rpb24ocGF0aCkgeyByZXR1cm4gZW50c1twYXRoXTsgfSkuZmlsdGVyKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYudHlwZSA9PSAnbWV0aG9kJyAmJiB2LmRlc2M7IH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpdGVtLmRlc2MpIHsgdGhpcy5fcm9vdHMucHVzaChpdGVtKSB9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICghKHRoaXMuZG9jcygpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ucmVuZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCB0MDtcblx0XHRcdHJldHVybiAodDAgPSBzZWxmLl9ib2R5PXNlbGYuX2JvZHkgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdib2R5Jyx0aGlzKS5mbGFnKCdsaWdodCcpKS5zZXRDb250ZW50KFxuXHRcdFx0XHQoZnVuY3Rpb24odDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5yb290cygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzLnB1c2goKHQwWyckJGEnICsgaV0gPSB0MFsnJCRhJyArIGldIHx8IHRhZyQuJGFwaV9jbGFzcygpLmZsYWcoJ2RvYycpLmZsYWcoJ2wnKSkuc2V0T2JqZWN0KGFyeVtpXSkuZW5kKCkpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fSkodDApXG5cdFx0XHQsMykuZW5kKCk7XG5cdFx0fTtcblx0XHR0YWcucHJvdG90eXBlLm5hdiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCBzZWxmID0gdGhpcywgdDE7XG5cdFx0XHRyZXR1cm4gKHQwID0gc2VsZi5fbmF2PXNlbGYuX25hdiB8fCB0YWckLiRuYXZtZW51KCkuc2V0UmVmKCduYXYnLHRoaXMpKS5zZXRDb250ZW50KFxuXHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHQoZnVuY3Rpb24odDEpIHtcblx0XHRcdFx0XHRcdHZhciB0MiwgdDMsIHQ0LCB0NSwgdDY7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5yb290cygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcm9vdCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRyb290ID0gYXJ5W2ldO1xuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDIgPSB0MVsnJCRhJyArIGldPXQxWyckJGEnICsgaV0gfHwgdGFnJC4kZG9jX2dyb3VwKCkuZmxhZygnY2xhc3MnKS5mbGFnKCdzZWN0aW9uJykuZmxhZygnY29tcGFjdCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0XHQodDMgPSB0Mi4kJGE9dDIuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpKS5zZXRDb250ZW50KCh0My4kJGEgPSB0My4kJGEgfHwgdGFnJC4kZG9jX2xpbmsoKS5mbGFnKCdjbGFzcycpKS5zZXRPYmplY3Qocm9vdCkuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0XHRcdFx0KHQ0ID0gdDIuJCRiPXQyLiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHRcdFx0KHQ1ID0gdDQuJCRhPXQ0LiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCdzdGF0aWMnKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdFx0XHRcdFx0KGZ1bmN0aW9uKHQ1KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHQ2O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBpdGVtcyA9IGl0ZXIkKHJvb3RbJy4nXSksIGxlbl8gPSBpdGVtcy5sZW5ndGgsIG1ldGgsIHJlczEgPSBbXTsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWV0aCA9IGl0ZW1zW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFtZXRoLmRlc2MpIHsgY29udGludWU7IH07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXMxLnB1c2goKHQ2ID0gdDVbJyQkYScgKyBqXT10NVsnJCRhJyArIGpdIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2VudHJ5JykpLnNldENvbnRlbnQoKHQ2LiQkYSA9IHQ2LiQkYSB8fCB0YWckLiRkb2NfbGluaygpKS5zZXRPYmplY3QobWV0aCkuZW5kKCksMikuZW5kKCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlczE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pKHQ1KVxuXHRcdFx0XHRcdFx0XHRcdFx0LDMpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0KHQ2ID0gdDQuJCRiPXQ0LiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdpbnN0YW5jZScpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoZnVuY3Rpb24odDYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdDc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGl0ZW1zID0gaXRlciQocm9vdFsnIyddKSwgbGVuXyA9IGl0ZW1zLmxlbmd0aCwgbWV0aCwgcmVzMSA9IFtdOyBqIDwgbGVuXzsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtZXRoID0gaXRlbXNbal07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW1ldGguZGVzYykgeyBjb250aW51ZTsgfTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlczEucHVzaCgodDcgPSB0NlsnJCRhJyArIGpdPXQ2WyckJGEnICsgal0gfHwgdGFnJC4kZGl2KCkuZmxhZygnZW50cnknKSkuc2V0Q29udGVudCgodDcuJCRhID0gdDcuJCRhIHx8IHRhZyQuJGRvY19saW5rKCkpLnNldE9iamVjdChtZXRoKS5lbmQoKSwyKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSkodDYpXG5cdFx0XHRcdFx0XHRcdFx0XHQsMykuZW5kKClcblx0XHRcdFx0XHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdF0sMikuZW5kKCkpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fSkodDEpXG5cdFx0XHRcdCwzKS5lbmQoKVxuXHRcdFx0LDIpLmVuZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2RvY3MuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gZXh0ZXJucztcblx0XG5cdC8vIHZhciBobGpzID0gcmVxdWlyZSAnaGlnaGxpZ2h0LmpzJ1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3Rvb2wnLCAnYnV0dG9uJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFjdGlvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aW9uOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBY3Rpb24gPSBmdW5jdGlvbih2KXsgdGhpcy5fYWN0aW9uID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ3N5bScpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy5sb2coJ2J1dHRvbiBjbGljaycsZSk7XG5cdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCd0b3VjaHN0YXJ0Jyk7XG5cdFx0XHR0cnVlO1xuXHRcdFx0cmV0dXJuIGUuZXZlbnQoKS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3NuaXBwZXQtaGludCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0VGV4dChcIkkgYW0gYSBoaW50ISFcIikuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnb3ZlcmxheXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciByb290O1xuXHRcdFx0aWYgKHJvb3QgPSB0aGlzLnZpZXcoKS5fcm9vdCkge1xuXHRcdFx0XHR2YXIgbGVmdCA9IDAsdG9wID0gMCxlbCA9IHJvb3QuZG9tKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoZWwgJiYgIWVsLmNvbnRhaW5zKHRoaXMuX2RvbSkpe1xuXHRcdFx0XHRcdGxlZnQgKz0gZWwub2Zmc2V0TGVmdDtcblx0XHRcdFx0XHR0b3AgKz0gZWwub2Zmc2V0VG9wIC0gZWwuc2Nyb2xsVG9wO1xuXHRcdFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX2RvbS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG5cdFx0XHRcdHRoaXMuX2RvbS5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaGludC1sYWJlbCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdGlmICh0ZXh0ICE9IHRoaXMuX2xhYmVsKSB7XG5cdFx0XHRcdHRoaXMuX2xhYmVsID0gdGV4dDtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB0ZXh0O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ292ZXJsYXktaGludCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fcm93ID0ge3dhdGNoOiAncm93RGlkU2V0JyxuYW1lOiAncm93J307XG5cdFx0dGFnLnByb3RvdHlwZS5yb3cgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3JvdzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um93ID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMucm93KCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fcm93ID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMucm93RGlkU2V0ICYmIHRoaXMucm93RGlkU2V0KHYsYSx0aGlzLl9fcm93KSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19jb2wgPSB7d2F0Y2g6ICdjb2xEaWRTZXQnLG5hbWU6ICdjb2wnfTtcblx0XHR0YWcucHJvdG90eXBlLmNvbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY29sOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb2wgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5jb2woKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9jb2wgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5jb2xEaWRTZXQgJiYgdGhpcy5jb2xEaWRTZXQodixhLHRoaXMuX19jb2wpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2xlbiA9IHt3YXRjaDogJ2xlbkRpZFNldCcsbmFtZTogJ2xlbid9O1xuXHRcdHRhZy5wcm90b3R5cGUubGVuID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9sZW47IH1cblx0XHR0YWcucHJvdG90eXBlLnNldExlbiA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmxlbigpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2xlbiA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmxlbkRpZFNldCAmJiB0aGlzLmxlbkRpZFNldCh2LGEsdGhpcy5fX2xlbikgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvd0RpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHR2YXIgdmFsID0gKFwiXCIgKyAodGhpcy5vYmplY3QoKS5yb3coKSAqIHRoaXMudmlldygpLmxpbmVIZWlnaHQoKSkgKyBcInB4XCIpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5zdHlsZS50b3AgPSB2YWw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbERpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHR2YXIgdmFsID0gKFwiXCIgKyAodGhpcy5vYmplY3QoKS5jb2woKSAqIHRoaXMudmlldygpLmNoYXJXaWR0aCgpKSArIFwicHhcIik7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnN0eWxlLmxlZnQgPSB2YWw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxlbkRpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHR2YXIgd2lkdGggPSAoXCJcIiArIChuZXckICogdGhpcy52aWV3KCkuY2hhcldpZHRoKCkpICsgXCJweFwiKTtcblx0XHRcdHJldHVybiB0aGlzLl9kb20uc3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaGludCBhdCcsb2JqZWN0LnJvd1xuXHRcdFx0dmFyIHJlZyA9IHRoaXMub2JqZWN0KCkucmVnaW9uKCk7XG5cdFx0XHRcblx0XHRcdGlmIChyZWcpIHtcblx0XHRcdFx0dGhpcy5zZXRSb3codGhpcy5vYmplY3QoKS5yb3coKSk7XG5cdFx0XHRcdHRoaXMuc2V0Q29sKHRoaXMub2JqZWN0KCkuY29sKCkpO1xuXHRcdFx0XHR0aGlzLnNldExlbihyZWcuc2l6ZSgpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ3dhcm4nKS5mbGFnKCdnbG9iYWwnLCghcmVnKSkuc2V0VHlwZSgodGhpcy5vYmplY3QoKS50eXBlKCkpKS5zZXRDaGlsZHJlbihcblx0XHRcdFx0KHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJGhpbnRfbGFiZWwoKS5mbGFnKCdsYWJlbCcpKS5zZXRMYWJlbCh0aGlzLm9iamVjdCgpLmxhYmVsKCkpLmVuZCgpXG5cdFx0XHQsMikuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnanN2aWV3JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oKHRoaXMuX2NvZGUgPSB0aGlzLl9jb2RlIHx8IHRhZyQuJGNvZGUoKS5zZXRSZWYoJ2NvZGUnLHRoaXMpKS5lbmQoKSwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb2RlLGNiKXtcblx0XHRcdC8vIHNob3VsZCBjb21waWxlIGJhcmVcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcL1xcL1xcIyBzb3VyY2VNYXBwaW5nKC4qKSQvLCcnKTtcblx0XHRcdGNvZGUgPSBjb2RlLnJlcGxhY2UoL15cXChmdW5jdGlvblxcKFxcKVxce1xcbi8sJycpO1xuXHRcdFx0Y29kZSA9IGNvZGUucmVwbGFjZSgvXFxuP1xcfVxcKVxcKFxcKVxcbj8kLywnJyk7XG5cdFx0XHQvLyBjb2RlID0gY29kZS5yZXBsYWNlKC9eXFx0L21nLCcnKVxuXHRcdFx0dGhpcy5fY29kZS50ZXh0Q29udGVudCA9IGNvZGU7XG5cdFx0XHRcblx0XHRcdHRoaXMuZmxhZygnaHVnZScsY29kZS5sZW5ndGggPiAxMDAwKTtcblx0XHRcdFxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0aGxqcy5jb25maWd1cmUoe2NsYXNzUHJlZml4OiAnJ30pO1xuXHRcdFx0XHR2YXIgaGwgPSBobGpzLmhpZ2hsaWdodCgnamF2YXNjcmlwdCcsY29kZSk7XG5cdFx0XHRcdHNlbGYuX2NvZGUuc2V0SHRtbChobC52YWx1ZSk7XG5cdFx0XHRcdHJldHVybiBjYiAmJiBjYihzZWxmKTtcblx0XHRcdH0sMCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2NvbnNvbGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZWRpdG9yID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lZGl0b3I7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEVkaXRvciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lZGl0b3IgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmVtcHR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0XHRjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLGFyZ3VtZW50cyk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmVkaXRvcigpKSB7XG5cdFx0XHRcdHRoaXMuZWRpdG9yKCkuZmxhZygnY29uc29sZScpO1xuXHRcdFx0fTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdsb2dnaW5nIHZhbCcsdmFsXG5cdFx0XHRcblx0XHRcdGlmICh2YWwgPT0gdGhpcykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsICYmIHZhbC5kb20pIHtcblx0XHRcdFx0dmFsID0gdmFsLmRvbSgpLm91dGVySFRNTDtcblx0XHRcdH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRcdHZhbCA9IEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLmFwcGVuZCh0YWckLiRkaXYoKS5mbGFnKCdqc29uJykuc2V0Q29udGVudCh2YWwsMCkuZW5kKCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdC8vIHRoaXMgaXMgYmFzaWNhbGx5IGxpa2UgYW4gZWRpdG9yXG5cdHRhZyQuZGVmaW5lVGFnKCdzbmlwcGV0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbWJhID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9pbWJhOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRJbWJhID0gZnVuY3Rpb24odil7IHRoaXMuX2ltYmEgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY29uZmlnOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb25maWcgPSBmdW5jdGlvbih2KXsgdGhpcy5fY29uZmlnID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX3NyYyA9IHt3YXRjaDogJ3JlbG9hZCcsbmFtZTogJ3NyYyd9O1xuXHRcdHRhZy5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zcmM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLnNyYygpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX3NyYyA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLnJlbG9hZCAmJiB0aGlzLnJlbG9hZCh2LGEsdGhpcy5fX3NyYykgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhlYWRpbmcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdoZWFkaW5nJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhlYWRpbmcgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hlYWRpbmcnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xheW91dCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMYXlvdXQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2xheW91dCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGFiID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndGFiJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFRhYiA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndGFiJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2FjdGl2ZSA9IHt3YXRjaDogJ2FjdGl2ZURpZFNldCcsbmFtZTogJ2FjdGl2ZSd9O1xuXHRcdHRhZy5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9hY3RpdmU7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmFjdGl2ZSgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2FjdGl2ZSA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmFjdGl2ZURpZFNldCAmJiB0aGlzLmFjdGl2ZURpZFNldCh2LGEsdGhpcy5fX2FjdGl2ZSkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZG9tXztcblx0XHRcdHJldHVybiAoZG9tXyA9IHRoaXMuZG9tKCkpLmlkIHx8IChkb21fLmlkID0gKFwic25pcHBldFwiICsgKGNvdW50ZXIrKykpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWN0aXZlRGlkU2V0ID0gZnVuY3Rpb24gKGJvb2wpe1xuXHRcdFx0cmV0dXJuIGJvb2wgPyAodGhpcy5zY2hlZHVsZSh7ZnBzOiA2MH0pKSA6ICh0aGlzLnVuc2NoZWR1bGUoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlucHV0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQgfHwgdGFnJC4kaW1jYXB0b3IoKS5zZXRSZWYoJ2lucHV0Jyx0aGlzKSkuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl92aWV3IHx8ICh0aGlzLl92aWV3ID0gKHRoaXMuX3ZpZXcgPSB0aGlzLl92aWV3IHx8IHRhZyQuJGltdmlldygpLnNldFJlZigndmlldycsdGhpcykpLnNldElucHV0KHRoaXMuaW5wdXQoKSkuZW5kKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDU7XG5cdFx0XHRpZiAoSW1iYS5TRVJWRVIpIHtcblx0XHRcdFx0aWYgKHNlbGYuc3JjKCkgJiYgc2VsZi5zcmMoKS5tYXRjaCgvXFwuaW1iYSQvKSkge1xuXHRcdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCksZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdFx0XHR2YXIgdl87XG5cdFx0XHRcdFx0XHRyZXR1cm4gKHNlbGYuc2V0SW1iYSh2XyA9IHJlcy5odG1sKSx2Xyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHByZXJlbmRlciBzaGVsbFxuXHRcdFx0XHRzZWxmLnNldENoaWxkcmVuKFtcblx0XHRcdFx0XHQodDAgPSBzZWxmLl9tYWluPXNlbGYuX21haW4gfHwgdGFnJC4kc2VjdGlvbigpLnNldFJlZignbWFpbicsc2VsZikpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0KHQxID0gc2VsZi5faGVhZGVyPXNlbGYuX2hlYWRlciB8fCB0YWckLiRoZWFkZXIoKS5zZXRSZWYoJ2hlYWRlcicsc2VsZikpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHQodDIgPSB0MS4kJGE9dDEuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3RpdGxlJykuZmxhZygncGF0aCcpKS5zZXRDb250ZW50KHNlbGYuaGVhZGluZygpLDMpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDMgPSB0MS4kJGI9dDEuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3Rvb2xzJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHRcdCh0My4kJGEgPSB0My4kJGEgfHwgdGFnJC4kdG9vbCgpLmZsYWcoJ3Jlc2V0Jykuc2V0VGl0bGUoJ3Jlc2V0Jykuc2V0SGFuZGxlcigndGFwJywncmVzZXQnLHNlbGYpKS5zZXRUZXh0KCdyZXNldCcpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHRcdCh0My4kJGIgPSB0My4kJGIgfHwgdGFnJC4kdG9vbCgpLmZsYWcoJ2pzJykuc2V0VGl0bGUoJ3Nob3cganMnKS5zZXRIYW5kbGVyKCd0YXAnLCd0b2dnbGVKUycsc2VsZikpLnNldFRleHQoJ3Nob3cganMnKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0XHQodDMuJCRjID0gdDMuJCRjIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdydW4nKS5zZXRUaXRsZSgncnVuJykuc2V0SGFuZGxlcigndGFwJywncnVuJyxzZWxmKSkuc2V0VGV4dCgncnVuJykuZW5kKClcblx0XHRcdFx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XHRcdFx0XSwyKS5lbmQoKSxcblx0XHRcdFx0XHRcdCh0NCA9IHNlbGYuX3ZpZXc9c2VsZi5fdmlldyB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ3ZpZXcnLHNlbGYpKS5zZXRDb250ZW50KCh0NSA9IHQ0LiQkYT10NC4kJGEgfHwgdGFnJC4kY29kZSgpLmZsYWcoJ2ltYmFjb2RlJykpLmRhdGFzZXQoJ3NyYycsKHNlbGYuc3JjKCkpKS5zZXRDb250ZW50KHNlbGYuaW1iYSgpLDMpLmVuZCgpLDIpLmVuZCgpXG5cdFx0XHRcdFx0XSwyKS5lbmQoKSxcblx0XHRcdFx0XHQoc2VsZi5faW5zcGVjdG9yID0gc2VsZi5faW5zcGVjdG9yIHx8IHRhZyQuJGRpdigpLnNldFJlZignaW5zcGVjdG9yJyxzZWxmKSkuZW5kKClcblx0XHRcdFx0XSwyKS5zeW5jZWQoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHNlbGYsYXJndW1lbnRzKTtcblx0XHRcdGlmIChzZWxmLnNyYygpKSB7IHJldHVybiBzZWxmLnJlbG9hZCgpIH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpe1xuXHRcdFx0dmFyIHZfO1xuXHRcdFx0aWYgKGNmZyAhPSB0aGlzLl9vcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX29wdGlvbnMgPSBjZmc7XG5cdFx0XHRcdGlmIChjZmcudGl0bGUpIHsgKHRoaXMuc2V0SGVhZGluZyh2XyA9IGNmZy50aXRsZSksdl8pIH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvcHRzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29wdHMgfHwgKHRoaXMuX2NvcHRzID0ge1xuXHRcdFx0XHRiYXJlOiBmYWxzZSxcblx0XHRcdFx0c3RhbmRhbG9uZTogZmFsc2UsXG5cdFx0XHRcdHNvdXJjZU1hcElubGluZTogdHJ1ZSxcblx0XHRcdFx0ZmlsZW5hbWU6IChcIlwiICsgdGhpcy5pZCgpICsgXCIuaW1iYVwiKSxcblx0XHRcdFx0dGFyZ2V0UGF0aDogKFwiXCIgKyB0aGlzLmlkKCkgKyBcIi5qc1wiKSxcblx0XHRcdFx0c291cmNlUGF0aDogKFwiXCIgKyB0aGlzLmlkKCkgKyBcIi5pbWJhXCIpXG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKGtleSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucyA/ICh0aGlzLl9vcHRpb25zW2tleV0pIDogKG51bGwpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHR0aGlzLl9vcHRpb25zID0gbztcblx0XHRcdHJldHVybiB0aGlzLnJlbmRlcigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBjb25maWcgPSB7fTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBjb2RlID0gcSQkKCcuaW1iYWNvZGUnLHRoaXMpLmRvbSgpLmlubmVySFRNTDtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgfTtcblx0XHRcdFxuXHRcdFx0aWYgKGNvZGUpIHtcblx0XHRcdFx0Y29uZmlnLmh0bWwgPSBjb2RlO1xuXHRcdFx0XHR0aGlzLnZpZXcoKS5sb2FkKG51bGwse2h0bWw6IGNvZGV9KTtcblx0XHRcdFx0dGhpcy5jb25maWd1cmUoY29uZmlnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvZGUsbyl7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdGlmIChjb2RlIHx8IG8uaHRtbCkgeyB0aGlzLnZpZXcoKS5sb2FkKGNvZGUsbykgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuY29kZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGNvZGUsbyxibGspe1xuXHRcdFx0Ly8gY2FjaGUgbGF0ZXN0IGNvbXBpbGF0aW9uIC0gcmV0dXJuP1xuXHRcdFx0aWYoYmxrPT11bmRlZmluZWQgJiYgdHlwZW9mIG8gPT0gJ2Z1bmN0aW9uJykgYmxrID0gbyxvID0gdGhpcy5jb3B0cygpO1xuXHRcdFx0aWYobz09dW5kZWZpbmVkKSBvID0gdGhpcy5jb3B0cygpO1xuXHRcdFx0cmV0dXJuIFNjcmltYmxhLndvcmtlcigpLmNvbXBpbGUoY29kZSxvLGJsayk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm92ZXJsYXlzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy52aWV3KCkuaGludHMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIGhpbnQsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aGludCA9IGFyeVtpXTtcblx0XHRcdFx0aWYgKCFoaW50LmFjdGl2ZSgpKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRyZXMucHVzaCgodGhpc1snXycgKyAnaGludCcgKyBpXSA9IHRoaXNbJ18nICsgJ2hpbnQnICsgaV0gfHwgdGFnJC4kb3ZlcmxheV9oaW50KCkpLnNldFZpZXcodGhpcy52aWV3KCkpLnNldE9iamVjdChoaW50KS5lbmQoKSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9nZ2xlSlMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICh0aGlzLnRhYigpICE9ICdqcycpIHtcblx0XHRcdFx0dGhpcy5zaG93anMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0VGFiKCdpbWJhJyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5wdXRmb2N1cyA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdFZJRVcgPSB0aGlzOyAvLyBoYWNrXG5cdFx0XHR0aGlzLmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHRyZXR1cm4gKHRoaXMuc2V0QWN0aXZlKHRydWUpLHRydWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmlucHV0Ymx1ciA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMudW5mbGFnKCdmb2N1cycpO1xuXHRcdFx0dmFyIHJlbCA9IGUuZXZlbnQoKS5yZWxhdGVkVGFyZ2V0O1xuXHRcdFx0aWYgKCEocmVsICYmIHRoaXMuZG9tKCkuY29udGFpbnMocmVsKSkpIHtcblx0XHRcdFx0dGhpcy51bmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHRcdHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NTtcblx0XHRcdGlmIChJbWJhLlNFUlZFUikgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHRoaXMuX2lucHV0LFxuXHRcdFx0XHQodDAgPSB0aGlzLl9tYWluPXRoaXMuX21haW4gfHwgdGFnJC4kc2VjdGlvbigpLnNldFJlZignbWFpbicsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0MSA9IHRoaXMuX2hlYWRlcj10aGlzLl9oZWFkZXIgfHwgdGFnJC4kaGVhZGVyKCkuc2V0UmVmKCdoZWFkZXInLHRoaXMpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdCh0MiA9IHQxLiQkYT10MS4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygndGl0bGUnKS5mbGFnKCdwYXRoJykpLnNldENvbnRlbnQodGhpcy5oZWFkaW5nKCksMykuZW5kKCksXG5cdFx0XHRcdFx0XHQodDMgPSB0MS4kJGI9dDEuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3Rvb2xzJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHQodDMuJCRhID0gdDMuJCRhIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdyZXNldCcpLnNldFRpdGxlKCdyZXNldCcpLnNldEhhbmRsZXIoJ3RhcCcsJ3Jlc2V0Jyx0aGlzKSkuc2V0VGV4dCgncmVzZXQnKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0KHQzLiQkYiA9IHQzLiQkYiB8fCB0YWckLiR0b29sKCkuZmxhZygnanMnKS5zZXRUaXRsZSgnc2hvdyBqcycpLnNldEhhbmRsZXIoJ3RhcCcsJ3RvZ2dsZUpTJyx0aGlzKSkuc2V0VGV4dCgnc2hvdyBqcycpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDMuJCRjID0gdDMuJCRjIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdydW4nKS5zZXRUaXRsZSgncnVuJykuc2V0SGFuZGxlcigndGFwJywncnVuJyx0aGlzKSkuc2V0VGV4dCgncnVuJykuZW5kKClcblx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHRdLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0NCA9IHRoaXMuX292ZXJsYXlzPXRoaXMuX292ZXJsYXlzIHx8IHRhZyQuJG92ZXJsYXlzKCkuc2V0UmVmKCdvdmVybGF5cycsdGhpcykpLnNldFZpZXcodGhpcy52aWV3KCkpLnNldENvbnRlbnQodGhpcy5vdmVybGF5cygpLDMpLmVuZCgpLFxuXHRcdFx0XHRcdCh0aGlzLl9qc3ZpZXcgPSB0aGlzLl9qc3ZpZXcgfHwgdGFnJC4kanN2aWV3KCkuc2V0UmVmKCdqc3ZpZXcnLHRoaXMpKS5lbmQoKSxcblx0XHRcdFx0XHR0aGlzLl92aWV3LmVuZCgpLFxuXHRcdFx0XHRcdCh0aGlzLl9jb25zb2xlID0gdGhpcy5fY29uc29sZSB8fCB0YWckLiRjb25zb2xlKCkuc2V0UmVmKCdjb25zb2xlJyx0aGlzKS5mbGFnKCdkYXJrJykpLnNldEVkaXRvcih0aGlzKS5lbmQoKVxuXHRcdFx0XHRdLDEpLmVuZCgpLFxuXHRcdFx0XHQodDUgPSB0aGlzLl9pbnNwZWN0b3I9dGhpcy5faW5zcGVjdG9yIHx8IHRhZyQuJGRpdigpLnNldFJlZignaW5zcGVjdG9yJyx0aGlzKSkuc2V0Q29udGVudCh0aGlzLnBsYXlncm91bmQoKSwzKS5lbmQoKVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2FuZGJveCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICh0aGlzLl9zYW5kYm94ID0gdGhpcy5fc2FuZGJveCB8fCB0YWckLiRzYW5kYm94KCkuc2V0UmVmKCdzYW5kYm94Jyx0aGlzKS5mbGFnKCdwbGF5Z3JvdW5kJykpLnNldEVkaXRvcih0aGlzKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxheWdyb3VuZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2FuZGJveCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmICghc2VsZi5fYnVpbHQpIHsgcmV0dXJuIH07XG5cdFx0XHRcblx0XHRcdGlmIChERVBTW3NlbGYuc3JjKCldKSB7XG5cdFx0XHRcdHZhciByZXMgPSBERVBTW3NlbGYuc3JjKCldO1xuXHRcdFx0XHRzZWxmLnZpZXcoKS5sb2FkKG51bGwse2h0bWw6IHJlcy5odG1sLGZpbGVuYW1lOiBzZWxmLnNyYygpfSk7XG5cdFx0XHRcdGlmIChzZWxmLmF1dG9ydW4oKSkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLnJ1bigpOyB9LDUwKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBnZXQgaW1iYSBkb2N1bWVudD8hP1xuXHRcdFx0QVBQLmZldGNoRG9jdW1lbnQoc2VsZi5zcmMoKSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0c2VsZi52aWV3KCkubG9hZChyZXMuYm9keSx7ZmlsZW5hbWU6IHNlbGYuc3JjKCl9KTtcblx0XHRcdFx0aWYgKHNlbGYuYXV0b3J1bigpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLnJ1bigpOyB9LDUwKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ucnVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5ydW4oKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXV0b3J1biA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVkaXRlZGFzeW5jID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmZsYWcoJ2RpcnR5Jyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25zYXZlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5oaW50cygpLmNsZWFyKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5ydW4oKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLl9jb25zb2xlLnJlc2V0KCk7XG5cdFx0XHRpZiAodGhpcy5fb3B0aW9ucy5odG1sKSB7XG5cdFx0XHRcdHRoaXMudmlldygpLmxvYWQobnVsbCx7aHRtbDogdGhpcy5fb3B0aW9ucy5odG1sfSk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGUpIHtcblx0XHRcdFx0ZS5jYW5jZWwoKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnVuZmxhZygnZGlydHknKTtcblx0XHRcdHRoaXMudmlldygpLmNhcmV0KCkubm9ybWFsaXplKCkuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYuZmxhZygncnVubmluZycpO1xuXHRcdFx0c2VsZi5jb21waWxlKHNlbGYuY29kZSgpLHNlbGYuY29wdHMoKSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0c2VsZi52aWV3KCkuaGludHMoKS5yZW0oZnVuY3Rpb24oaGludCkgeyByZXR1cm4gaGludC5ncm91cCgpID09ICdydW50aW1lJzsgfSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEuY29kZSkge1xuXHRcdFx0XHRcdC8vIEBqc3ZpZXcubG9hZChyZXM6ZGF0YTpjb2RlKSBpZiByZXM6ZGF0YVxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2VsZi5fc2FuZGJveC5ydW4ocmVzLmRhdGEpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjb25zb2xlLmxvZygnZXJyb3InKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2hvd2pzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgbyA9IHtiYXJlOiB0cnVlLHN0YW5kYWxvbmU6IGZhbHNlLGZpbGVuYW1lOiAnYS5pbWJhJ307XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmLmNvbXBpbGUoc2VsZi5jb2RlKCksbyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0aWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmNvZGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5fanN2aWV3LmxvYWQocmVzLmRhdGEuY29kZSxmdW5jdGlvbigpIHsgdmFyIHZfO1xuXHRcdFx0XHRcdHJldHVybiAoc2VsZi5zZXRUYWIodl8gPSAnanMnKSx2Xyk7IH0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmVycm9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnNvbGUubG9nKCdoYXMgZXJyb3InKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW5FcnJvciA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdG8udHlwZSA9ICdlcnJvcic7XG5cdFx0XHRvLmdyb3VwID0gJ3J1bnRpbWUnO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3J1bkVycm9yJyxvXG5cdFx0XHQvLyBvbmx5IHNob3cgZXJyb3IgaWYgd2UgaGF2ZSBhIGxpbmUgYW5kIGNvbHVtblxuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLmhpbnRzKCkuYWRkKG8pLmFjdGl2YXRlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJ1bkxvZyA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdG8udHlwZSA9ICdsb2cnO1xuXHRcdFx0by5ncm91cCA9ICdydW50aW1lJztcblx0XHRcdG8ubWVzc2FnZSB8fCAoby5tZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoby5wYXJhbXNbMF0pKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdydW5Mb2cnLG9cblx0XHRcdFxuXHRcdFx0aWYgKG8ubnIgIT0gbnVsbCAmJiAhby5sb2MpIHtcblx0XHRcdFx0dmFyIGxvZ3MgPSB0aGlzLnZpZXcoKS5maW5kKCcuaWRlbnRpZmllci5sb2csLmlkZW50aWZpZXJbbmFtZT1cImxvZ1wiXScpLnRvQXJyYXkoKTtcblx0XHRcdFx0dmFyIG5vZGUgPSBsb2dzW28ubnJdO1xuXHRcdFx0XHRcblx0XHRcdFx0by5ub2RlID0gbm9kZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdFx0dmFyIHJlZyA9IG5vZGUucmVnaW9uKCk7IC8vIG5vZGUubmV4dCA/IG5vZGUubmV4dC5yZWdpb24gOiBcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnZm91bmQgbG9jISEnLG5vZGUscmVnKTtcblx0XHRcdFx0XHQvLyBsZXQgY29sID0gdmlldy5idWZmZXIubGluZShyZWcucm93KVs6bGVuZ3RoXVxuXHRcdFx0XHRcdG8ubG9jID0gcmVnLmVuZEF0TGluZSgpLmNvbGxhcHNlKCk7IC8vIHtsaW5lOiByZWcucm93LCBjb2x1bW46IGNvbH0gIyAgcmVnLnRvSlNPTiAjIHtsaW5lOiByZWcucm93LCBjb2x1bW46IDEwMH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBvOmxvYyA9IGxvZ3Nbbzpucl0ucmVnaW9uLnRvSlNPTlxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5oaW50cygpLmFkZChvKS5hY3RpdmF0ZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW5SZXN1bHQgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncnVuUmVzdWx0JyxvXG5cdFx0XHR0aGlzLmZsYWcoJ3JlcGwnLCEhbyk7XG5cdFx0XHR0aGlzLl9jb25zb2xlLmxvZyhvKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2V4YW1wbGUnLCAnc25pcHBldCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hdXRvcnVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdGlmICghSW1iYS5TRVJWRVIpIHtcblx0XHRJbWJhLkV2ZW50LlBST0NFU1NJTkc7XG5cdFx0XG5cdFx0XG5cdFx0XHRcblx0XHRcdHZhciBwcmV2ID0gSW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2Vzcztcblx0XHRcdFxuXHRcdFx0SW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRJbWJhLkV2ZW50LlBST0NFU1NJTkcgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcHJldi5jYWxsKHRoaXMpO1xuXHRcdFx0fTtcblx0XHRcblx0fTtcblx0XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3NhbmRib3gnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZWRpdG9yID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lZGl0b3I7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEVkaXRvciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lZGl0b3IgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnNvbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmVkaXRvcigpLl9jb25zb2xlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKG1zZyx1cmwsbGluZSxjb2wsZXJyKXtcblx0XHRcdFxuXHRcdFx0dmFyIHN0YWNrXztcblx0XHRcdGlmICh1cmwubWF0Y2goL3NuaXBwZXQoXFxkKylcXC4oaW1iYXxqcykvKSkge1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGlkID0gdXJsLnNwbGl0KCcuJykuc2hpZnQoKTtcblx0XHRcdFx0dmFyIHNuaXBwZXQgPSB0YWckd3JhcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNuaXBwZXQpIHtcblx0XHRcdFx0XHRzbmlwcGV0LnBsYXlncm91bmQoKS5vbmVycm9yKG1zZywnJyxsaW5lLGNvbCxlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAodXJsID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdC8vIHNhZmFyaT9cblx0XHRcdFx0dmFyIGV2ID0gSW1iYS5FdmVudC5QUk9DRVNTSU5HO1xuXHRcdFx0XHRjb25zb2xlLmxvZygnbGFzdCBldmVudCB0YXJnZXQnLGV2ICYmIGV2LnRhcmdldCgpKTtcblx0XHRcdFx0aWYgKGV2ICYmIGV2LnRhcmdldCgpKSB7XG5cdFx0XHRcdFx0c25pcHBldCA9IGV2LnRhcmdldCgpLmNsb3Nlc3QocSQoJy5fc25pcHBldCcsdGhpcykpO1xuXHRcdFx0XHRcdGlmIChzbmlwcGV0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc25pcHBldC5wbGF5Z3JvdW5kKCkub25lcnJvcihtc2csJycsbGluZSxjb2wsZXJyKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS5sb2coJ2NhdWdodCB0aGUgZXJyb3IgaGVyZSEhIScsYXJndW1lbnRzLHRoaXMpO1xuXHRcdFx0dmFyIGxvY3MgPSBbXTtcblx0XHRcdFxuXHRcdFx0ZXJyICYmIChzdGFja18gPSBlcnIuc3RhY2spICYmIHN0YWNrXy5yZXBsYWNlICAmJiAgc3RhY2tfLnJlcGxhY2UoLyhcXDxhbm9ueW1vdXNcXD58c25pcHBldFxcZCtcXC5pbWJhKVxcOihcXGQrKTooXFxkKykvZyxmdW5jdGlvbihtLHNvdXJjZSxsaW5lLGNvbCkge1xuXHRcdFx0XHRsb2NzLnB1c2goe2xpbmU6IHBhcnNlSW50KGxpbmUpLGNvbHVtbjogcGFyc2VJbnQoY29sKX0pO1xuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRsb2NzLnB1c2goe2xpbmU6IGxpbmUsY29sdW1uOiBjb2x9KTtcblx0XHRcdFxuXHRcdFx0aWYgKGxvY3NbMF0pIHtcblx0XHRcdFx0dmFyIG1hcCA9IHRoaXMub2JqZWN0KCkuc291cmNlbWFwO1xuXHRcdFx0XHR2YXIgY29uc3VtZXIgPSBTY3JpbWJsYS5Tb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIobWFwKTtcblx0XHRcdFx0dmFyIGxvYyA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IobG9jc1swXSk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdvcmlnaW5hbCBsb2NhdGlvbiBpcycsbG9jKTtcblx0XHRcdFx0dGhpcy5lZGl0b3IoKS5ydW5FcnJvcih7bWVzc2FnZTogbXNnLGxvYzogbG9jfSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25sb2cgPSBmdW5jdGlvbiAobnIscGFycyl7XG5cdFx0XHR0aGlzLmVkaXRvcigpLnJ1bkxvZyh7bnI6IG5yLHBhcmFtczogcGFyc30pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocSQoJy5zY2hlZHVsZWRfJyx0aGlzKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0udW5zY2hlZHVsZSgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLmVtcHR5LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJlc2VudCA9IGZ1bmN0aW9uIChyZXMpe1xuXHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRpZiAocmVzICYmIChyZXMucHJvdG90eXBlIGluc3RhbmNlb2YgSW1iYS5UYWcpKSB7XG5cdFx0XHRcdG5vZGUgPSBuZXcgcmVzKHJlcy5jcmVhdGVOb2RlKCkpO1xuXHRcdFx0fSBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBJbWJhLlRhZykge1xuXHRcdFx0XHRub2RlID0gcmVzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZChub2RlKTtcblx0XHRcdFx0bm9kZS5lbmQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNvbnNvbGUoKS5sb2cobm9kZSB8fCByZXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoc3JjKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBjb2RlID0gc3JjLmNvZGU7XG5cdFx0XHRpZiAoIWNvZGUpIHsgcmV0dXJuIHNlbGYgfTtcblx0XHRcdFxuXHRcdFx0c2VsZi5fb2JqZWN0ID0gc3JjO1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uKG1zZyx1cmwsbGluZSxjb2wsZXJyKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ2NhdWdodCBlcnJvcicsbXNnLHVybCxsaW5lLGNvbCxlcnIsdGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYub25lcnJvcihtc2csdXJsLGxpbmUsY29sLGVycik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb2RlID0gY29kZSArICdcXG4vLyMgc291cmNlVVJMPScgKyBzZWxmLmVkaXRvcigpLmlkKCkgKyAnLmltYmEnO1xuXHRcdFx0XHR2YXIgdGFnJCA9IEltYmEuVEFHUy5fX2Nsb25lKCk7XG5cdFx0XHRcdHZhciBjb25zb2xlID0gc2VsZi5jb25zb2xlKCk7XG5cdFx0XHRcdHZhciByZXMgPSBldmFsKGNvZGUpO1xuXHRcdFx0XHRzZWxmLnByZXNlbnQocmVzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5sb2coJ2ltbWVkaWF0ZSBlcnJvciBpbiBldmFsLWlubGluZScsZSk7XG5cdFx0XHRcdHNlbGYub25lcnJvcihlLm1lc3NhZ2UsJycsZS5saW5lTnIgfHwgZS5saW5lIHx8IDAsZS5jb2x1bW4sZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3Mvc25pcHBldC5pbWJhXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2lzc3VlLWxpJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCB0MSwgdDIsIHNlbGYgPSB0aGlzLCB0Mztcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0KHQwID0gdGhpcy4kYT10aGlzLiRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kYSgpLmZsYWcoJ3RpdGxlJykpLnNldEhyZWYoKFwiL2Jsb2cvXCIgKyAodGhpcy5vYmplY3QoKS5udW1iZXIpKSkuc2V0Q29udGVudCh0aGlzLm9iamVjdCgpLnRpdGxlLDMpLmVuZCgpXG5cdFx0XHRcdCwyKS5lbmQoKSxcblx0XHRcdFx0KHQyID0gdGhpcy4kYj10aGlzLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2xlZ2VuZCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcIldyaXR0ZW4gYnkgXCIsXG5cdFx0XHRcdFx0KHQyLiQkYSA9IHQyLiQkYSB8fCB0YWckLiRnaF91c2VyKCkpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLnVzZXIpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKCksXG5cdFx0XHRcdFxuXHRcdFx0XHQodDMgPSBzZWxmLiRjPXNlbGYuJGMgfHwgdGFnJC4kZGl2KCkuZmxhZygnbGFiZWxzJykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0KGZ1bmN0aW9uKHQzKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5vYmplY3QoKS5sYWJlbHMpLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHJlcy5wdXNoKCh0M1snJCRhJyArIGldID0gdDNbJyQkYScgKyBpXSB8fCB0YWckLiRnaF9sYWJlbCgpKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHR9KSh0Mylcblx0XHRcdFx0LDMpLmVuZCgpXG5cdFx0XHRdLDIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2doLWxhYmVsJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5zZXRUaXRsZSgodGhpcy5vYmplY3QoKS5uYW1lKSkuc2V0Q2hpbGRyZW4odGhpcy5vYmplY3QoKS5uYW1lLDMpLnN5bmNlZCgpO1xuXHRcdFx0aWYgKEltYmEuQ0xJRU5UKSB7XG5cdFx0XHRcdHRoaXMuY3NzKHtiYWNrZ3JvdW5kQ29sb3I6ICcjJyArIHRoaXMub2JqZWN0KCkuY29sb3J9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdnaC11c2VyJywgJ3NwYW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDA7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihcblx0XHRcdFx0KHQwID0gdGhpcy4kYT10aGlzLiRhIHx8IHRhZyQuJGEoKSkuc2V0SHJlZigoXCJodHRwOi8vZ2l0aHViLmNvbS9cIiArICh0aGlzLm9iamVjdCgpLmxvZ2luKSkpLnNldENvbnRlbnQodGhpcy5vYmplY3QoKS5sb2dpbiwzKS5lbmQoKVxuXHRcdFx0LDIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpc3N1ZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLm9iamVjdCgpLm9iamVjdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDEsIHQyO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodDAgPSB0aGlzLiRhPXRoaXMuJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kaDEoKS5mbGFnKCd0aXRsZScpKS5zZXRDb250ZW50KHRoaXMuZG9jKCkudGl0bGUsMykuZW5kKCksXG5cdFx0XHRcdFx0KHQyID0gdDAuJCRiPXQwLiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdsZWdlbmQnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcIldyaXR0ZW4gYnkgXCIsXG5cdFx0XHRcdFx0XHQodDIuJCRhID0gdDIuJCRhIHx8IHRhZyQuJGdoX3VzZXIoKSkuc2V0T2JqZWN0KHRoaXMuZG9jKCkudXNlcikuZW5kKCksXG5cdFx0XHRcdFx0XHQoXCIgYXQgXCIgKyAodGhpcy5kb2MoKS5jcmVhdGVkX2F0KSlcblx0XHRcdFx0XHRdLDEpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKCksXG5cdFx0XHRcdCh0aGlzLiRiID0gdGhpcy4kYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykuZmxhZygnbWQnKSkuc2V0SHRtbCgodGhpcy5kb2MoKS5tZCkpLmVuZCgpXG5cdFx0XHRdLDIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9pc3N1ZXMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9